();
	afx_msg virtual void OnClose();

protected:
	DECLARE_MESSAGE_MAP()

// Implementation
public:
	CDocListDocTemplate* m_pDocTemplate; // if a doctemplate created the doclist, here is its pointer

private:
	CString m_strFilterList;	// '|'-delimited list of filters, terminated with '||\0'
	CString m_strFolder;		// contains full path name after return
	DOCLISTCREATE m_dlc;		// DocList creation structure
};
#endif // _WIN32_WCE_DOCLIST_SUPPORT

#ifndef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// Splitter Window

#define SPLS_DYNAMIC_SPLIT  0x0001
#define SPLS_INVERT_TRACKER 0x0002  // obsolete (now ignored)

class CSplitterWnd : public CWnd
{
	DECLARE_DYNAMIC(CSplitterWnd)

// Construction
public:
	CSplitterWnd();
	// Create a single view type splitter with multiple splits
	virtual BOOL Create(CWnd* pParentWnd,
				int nMaxRows, int nMaxCols, SIZE sizeMin,
				CCreateContext* pContext,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE |
					WS_HSCROLL | WS_VSCROLL | SPLS_DYNAMIC_SPLIT,
				UINT nID = AFX_IDW_PANE_FIRST);

	// Create a multiple view type splitter with static layout
	virtual BOOL CreateStatic(CWnd* pParentWnd,
				int nRows, int nCols,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE,
				UINT nID = AFX_IDW_PANE_FIRST);

	virtual BOOL CreateView(int row, int col, CRuntimeClass* pViewClass,
			SIZE sizeInit, CCreateContext* pContext);

// Attributes
public:
	int GetRowCount() const;
	int GetColumnCount() const;

	// information about a specific row or column
	void GetRowInfo(int row, int& cyCur, int& cyMin) const;
	void SetRowInfo(int row, int cyIdeal, int cyMin);
	void GetColumnInfo(int col, int& cxCur, int& cxMin) const;
	void SetColumnInfo(int col, int cxIdeal, int cxMin);

	// for setting and getting shared scroll bar style
	DWORD GetScrollStyle() const;
	void SetScrollStyle(DWORD dwStyle);

	// views inside the splitter
	CWnd* GetPane(int row, int col) const;
	BOOL IsChildPane(CWnd* pWnd, int* pRow, int* pCol);
	AFX_DEPRECATED("IsChildPane(CWnd *, int&, int&) has been superseded by IsChildPane(CWnd*, int*, int*)") 
			BOOL IsChildPane(CWnd* pWnd, int& row, int& col); // obsolete
	int IdFromRowCol(int row, int col) const;

	BOOL IsTracking();  // TRUE during split operation

// Operations
public:
	virtual void RecalcLayout();    // call after changing sizes

// Overridables
protected:
	// to customize the drawing
	enum ESplitType { splitBox, splitBar, splitIntersection, splitBorder };
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	virtual void OnInvertTracker(const CRect& rect);

public:
	// for customizing scrollbar regions
	virtual BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID);

	// for customizing DYNAMIC_SPLIT behavior
	virtual void DeleteView(int row, int col);
	virtual BOOL SplitRow(int cyBefore);
	virtual BOOL SplitColumn(int cxBefore);
	virtual void DeleteRow(int rowDelete);
	virtual void DeleteColumn(int colDelete);

	// determining active pane from focus or active view in frame
	virtual CWnd* GetActivePane(int* pRow = NULL, int* pCol = NULL);
	virtual void SetActivePane(int row, int col, CWnd* pWnd = NULL);
protected:
	AFX_DEPRECATED("GetActivePane(int&, int&) has been superseded by GetActivePane(int*, int*)") 
			CWnd* GetActivePane(int& row, int& col); // obsolete

public:
	// high level command operations - called by default view implementation
	virtual BOOL CanActivateNext(BOOL bPrev = FALSE);
	virtual void ActivateNext(BOOL bPrev = FALSE);
	virtual BOOL DoKeyboardSplit();

	// synchronized scrolling
	virtual BOOL DoScroll(CView* pViewFrom, UINT nScrollCode,
		BOOL bDoScroll = TRUE);
	virtual BOOL DoScrollBy(CView* pViewFrom, CSize sizeScroll,
		BOOL bDoScroll = TRUE);

// Implementation
public:
	virtual ~CSplitterWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation structure
	struct CRowColInfo
	{
		int nMinSize;       // below that try not to show
		int nIdealSize;     // user set size
		// variable depending on the available size layout
		int nCurSize;       // 0 => invisible, -1 => nonexistant
	};

protected:
	// customizable implementation attributes (set by constructor or Create)
	CRuntimeClass* m_pDynamicViewClass;
	int m_nMaxRows, m_nMaxCols;

	// implementation attributes which control layout of the splitter
	int m_cxSplitter, m_cySplitter;         // size of splitter bar
	int m_cxBorderShare, m_cyBorderShare;   // space on either side of splitter
	int m_cxSplitterGap, m_cySplitterGap;   // amount of space between panes
	int m_cxBorder, m_cyBorder;             // borders in client area

	// current state information
	int m_nRows, m_nCols;
	BOOL m_bHasHScroll, m_bHasVScroll;
	CRowColInfo* m_pColInfo;
	CRowColInfo* m_pRowInfo;

	// Tracking info - only valid when 'm_bTracking' is set
	BOOL m_bTracking, m_bTracking2;
	CPoint m_ptTrackOffset;
	CRect m_rectLimit;
	CRect m_rectTracker, m_rectTracker2;
	int m_htTrack;

	// implementation routines
	BOOL CreateCommon(CWnd* pParentWnd, SIZE sizeMin, DWORD dwStyle, UINT nID);
	virtual int HitTest(CPoint pt) const;
	virtual void GetInsideRect(CRect& rect) const;
	virtual void GetHitRect(int ht, CRect& rect);
	virtual void TrackRowSize(int y, int row);
	virtual void TrackColumnSize(int x, int col);
	virtual void DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside);
	virtual void SetSplitCursor(int ht);
	CWnd* GetSizingParent();

	// starting and stopping tracking
	virtual void StartTracking(int ht);
	virtual void StopTracking(BOOL bAccept);

	// special command routing to frame
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	//{{AFX_MSG(CSplitterWnd)
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
	afx_msg void OnCancelMode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnDisplayChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CFormView - generic view constructed from a dialog template

class CFormView : public CScrollView
{
	DECLARE_DYNAMIC(CFormView)

// Construction
protected:      // must derive your own class
	CFormView(LPCTSTR lpszTemplateName);
	CFormView(UINT nIDTemplate);

// Implementation
public:
    virtual ~CFormView();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	virtual void OnInitialUpdate();

public:
#ifndef _WIN32_WCE // Not supported feature on CE
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild)
	{
		return GetAccessibleChild(varChild, ppdispChild);
	}

	virtual HRESULT get_accChildCount(long *pcountChildren)
	{
		(*pcountChildren) = GetAccessibleChildCount();
		return S_OK;
	}

	HRESULT get_accName(VARIANT varChild, BSTR *pszName)
	{
		return GetAccessibleName(varChild, pszName);
	}

	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
	{
		return GetAccessibilityLocation(varChild, pxLeft, pyTop, pcxWidth, pcyHeight);
	}

	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild)
	{
		return GetAccessibilityHitTest(xLeft, yTop, pvarChild);
	}
#endif // !_WIN32_WCE

protected:
	LPCTSTR m_lpszTemplateName;
	CCreateContext* m_pCreateContext;
	HWND m_hWndFocus;   // last window to have focus

	virtual void OnDraw(CDC* pDC);      // default does nothing
	// special case override of child window creation
	virtual BOOL Create(LPCTSTR, LPCTSTR, DWORD,
		const RECT&, CWnd*, UINT, CCreateContext*);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnActivateView(BOOL, CView*, CView*);
	virtual void OnActivateFrame(UINT, CFrameWnd*);
	BOOL SaveFocusControl();    // updates m_hWndFocus

#ifndef _AFX_NO_OCC_SUPPORT
	// data and functions necessary for OLE control containment
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
#endif

	//{{AFX_MSG(CFormView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _WIN32_WCE // View
/////////////////////////////////////////////////////////////////////////////
// CEditView - simple text editor view

class CEditView : public CCtrlView
{
	DECLARE_DYNCREATE(CEditView)

// Construction
public:
	CEditView();

// Attributes
public:
	static AFX_DATA const DWORD dwStyleDefault;
	// CEdit control access
	CEdit& GetEditCtrl() const;

	// presentation attributes
	CFont* GetPrinterFont() const;
	void SetPrinterFont(CFont* pFont);
	void SetTabStops(int nTabStops);

	// other attributes
	void GetSelectedText(CString& strResult) const;

	// buffer access
	LPCTSTR LockBuffer() const;
	void UnlockBuffer() const;
	UINT GetBufferLength() const;

// Operations
public:
	BOOL FindText(LPCTSTR lpszFind, BOOL bNext = TRUE, BOOL bCase = TRUE);
	void SerializeRaw(CArchive& ar);
	UINT PrintInsideRect(CDC* pDC, RECT& rectLayout, UINT nIndexStart,
		UINT nIndexStop);

// Overrideables
protected:
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase);
	virtual void OnTextNotFound(LPCTSTR lpszFind);

// Implementation
public:
	virtual ~CEditView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	void ReadFromArchive(CArchive& ar, UINT nLen);
	void WriteToArchive(CArchive& ar);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA const UINT nMaxSize;
		// maximum number of characters supported

protected:
	int m_nTabStops;            // tab stops in dialog units
	LPTSTR m_pShadowBuffer;     // special shadow buffer only used in Win95
	UINT m_nShadowSize;

	CUIntArray m_aPageStart;    // array of starting pages
	HFONT m_hPrinterFont;       // if NULL, mirror display font
	HFONT m_hMirrorFont;        // font object used when mirroring

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	// printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL InitializeReplace();
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase);

	// special overrides for implementation
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

	//{{AFX_MSG(CEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg BOOL OnEditChange();
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg LRESULT OnFindReplaceCmd(WPARAM wParam, LPARAM lParam);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMetaFileDC

class CMetaFileDC : public CDC
{
	DECLARE_DYNAMIC(CMetaFileDC)

// Constructors
public:
	CMetaFileDC();
	BOOL Create(LPCTSTR lpszFilename = NULL);
	BOOL CreateEnhanced(CDC* pDCRef, LPCTSTR lpszFileName,
		LPCRECT lpBounds, LPCTSTR lpszDescription);

// Operations
	HMETAFILE Close();
	HENHMETAFILE CloseEnhanced();

// Implementation
public:
	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC

protected:
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC -- Not allowed
	virtual void ReleaseOutputDC();     // Release the Output DC -- Not allowed

public:
	virtual ~CMetaFileDC();

// Clipping Functions (use the Attribute DC's clip region)
	virtual int GetClipBox(LPRECT lpRect) const;
	virtual BOOL PtVisible(int x, int y) const;
			BOOL PtVisible(POINT point) const;
	virtual BOOL RectVisible(LPCRECT lpRect) const;

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
			BOOL TextOut(int x, int y, const CString& str);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
			BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				const CString& str, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
			CSize TabbedTextOut(int x, int y, const CString& str,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int _AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat);

	virtual int _AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int _AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);


			int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);

			int DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Viewport Functions
	virtual CPoint SetViewportOrg(int x, int y);
			CPoint SetViewportOrg(POINT point);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
			CSize SetViewportExt(SIZE size);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

protected:
	void AdjustCP(int cx);
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CRectTracker - simple rectangular tracking rectangle w/resize handles

class CRectTracker
{
public:
// Constructors
	CRectTracker();
	CRectTracker(LPCRECT lpSrcRect, UINT nStyle);

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_nStyle;      // current state
	CRect m_rect;       // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(CDC* pDC) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(CWnd* pWnd, UINT nHitTest) const;
	BOOL Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert = FALSE,
		CWnd* pWndClipTo = NULL);
	BOOL TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

// Overridables
	virtual void DrawTrackerRect(LPCRECT lpRect, CWnd* pWndClipTo,
		CDC* pDC, CWnd* pWnd);
	virtual void AdjustRect(int nHandle, LPRECT lpRect);
	virtual void OnChangedRect(const CRect& rectOld);
	virtual UINT GetHandleMask() const;

// Implementation
public:
	virtual ~CRectTracker();

protected:
	BOOL m_bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bErase;          // TRUE if DrawTrackerRect is called for erasing
	BOOL m_bFinalErase;     // TRUE if DragTrackerRect called for final erase

	// implementation helpers
	int HitTestHandles(CPoint point) const;
	void GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void GetModifyPointers(int nHandle, int**ppx, int**ppy, int* px, int*py);
	virtual int GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL TrackHandle(int nHandle, CWnd* pWnd, CPoint point, CWnd* pWndClipTo);
	void Construct();
};

/////////////////////////////////////////////////////////////////////////////
// Informational data structures

#ifndef _AFX_NO_PRINTING_SUPPORT
struct CPrintInfo // Printing information structure
{
	CPrintInfo();
	~CPrintInfo();

	CPrintDialog* m_pPD;     // pointer to print dialog

	BOOL m_bDocObject;       // TRUE if printing by IPrint interface
	BOOL m_bPreview;         // TRUE if in preview mode
	BOOL m_bDirect;          // TRUE if bypassing Print Dialog
	BOOL m_bContinuePrinting;// set to FALSE to prematurely end printing
	UINT m_nCurPage;         // Current page
	UINT m_nNumPreviewPages; // Desired number of preview pages
	CString m_strPageDesc;   // Format string for page number display
	LPVOID m_lpUserData;     // pointer to user created struct
	CRect m_rectDraw;        // rectangle defining current usable page area
	int m_nJobNumber;			 // job number (after StartDoc)

	// these only valid if m_bDocObject
	UINT m_nOffsetPage;      // offset of first page in combined IPrint job
	DWORD m_dwFlags;         // flags passed to IPrint::Print

	void SetMinPage(UINT nMinPage);
	void SetMaxPage(UINT nMaxPage);
	UINT GetMinPage() const;
	UINT GetMaxPage() const;
	UINT GetFromPage() const;
	UINT GetToPage() const;
	UINT GetOffsetPage() const;
};

struct CPrintPreviewState   // Print Preview context/state
{
	UINT nIDMainPane;          // main pane ID to hide
	HMENU hMenu;               // saved hMenu
	DWORD dwStates;            // Control Bar Visible states (bit map)
	CView* pViewActiveOld;     // save old active view during preview
	BOOL (CALLBACK* lpfnCloseProc)(CFrameWnd* pFrameWnd);
	HACCEL hAccelTable;       // saved accelerator table

// Implementation
	CPrintPreviewState();
};
#endif // !_AFX_NO_PRINTING_SUPPORT

struct CCreateContext   // Creation information structure
	// All fields are optional and may be NULL
{
	// for creating new views
	CRuntimeClass* m_pNewViewClass; // runtime class of view to create or NULL
	CDocument* m_pCurrentDoc;

	// for creating MDI children (CMDIChildWnd::LoadFrame)
	CDocTemplate* m_pNewDocTemplate;

	// for sharing view/frame state from the original view/frame
	CView* m_pLastView;
	CFrameWnd* m_pCurrentFrame;

// Implementation
	CCreateContext();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXEXT_INLINE AFX_INLINE
#include <afxext.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXEXT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxhtml.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXHTML_H__
#define __AFXHTML_H__

#ifdef _AFX_NO_HTML_SUPPORT
	#error HTML classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

#ifndef __exdisp_h__
	#include <exdisp.h>
#endif

#ifndef __mshtmhst_h__
#include <mshtmhst.h>
#endif

#ifndef __mshtml_h__
#include <mshtml.h>
#endif

#ifndef __mshtmcid_h__
#include <mshtmcid.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#pragma warning(push)
#pragma warning(disable:4571)//catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

/////////////////////////////////////////////////////////////////////////////
// AFXHTML - MFC Visual HTML classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd,CHtmlEditCtrlBase<CHtmlEditCtrl>
			class CHtmlEditCtrl;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CHtmlView;

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView,CHtmlEditCtrlBase<CHtmlEditView>
						class CHtmlEditView;

//CObject
	//CCmdTarget;
		//CDocument
			class CHtmlEditDoc;


#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// CHtmlView

class CHtmlView : public CFormView
{
protected: // create from serialization only
	CHtmlView();
	DECLARE_DYNCREATE(CHtmlView)
	DECLARE_EVENTSINK_MAP()

// Attributes
public:
	CString GetType() const;
	long GetLeft() const;
	void SetLeft(long nNewValue);
	long GetTop() const;
	void SetTop(long nNewValue);
	long GetHeight() const;
	void SetHeight(long nNewValue);
	long GetWidth() const;
	void SetWidth(long nNewValue);
	void SetVisible(BOOL bNewValue);
	BOOL GetVisible() const;
	CString GetLocationName() const;
	READYSTATE GetReadyState() const;
	BOOL GetOffline() const;
	void SetOffline(BOOL bNewValue);
	BOOL GetSilent() const;
	void SetSilent(BOOL bNewValue);
	BOOL GetTopLevelContainer() const;
	CString GetLocationURL() const;
	BOOL GetBusy() const;
	LPDISPATCH GetApplication() const;
	LPDISPATCH GetParentBrowser() const;
	LPDISPATCH GetContainer() const;
	LPDISPATCH GetHtmlDocument() const;
	CString GetFullName() const;
	int GetToolBar() const;
	void SetToolBar(int nNewValue);
	BOOL GetMenuBar() const;
	void SetMenuBar(BOOL bNewValue);
	BOOL GetFullScreen() const;
	void SetFullScreen(BOOL bNewValue);
	OLECMDF QueryStatusWB(OLECMDID cmdID) const;
	BOOL GetRegisterAsBrowser() const;
	void SetRegisterAsBrowser(BOOL bNewValue);
	BOOL GetRegisterAsDropTarget() const;
	void SetRegisterAsDropTarget(BOOL bNewValue);
	BOOL GetTheaterMode() const;
	void SetTheaterMode(BOOL bNewValue);
	BOOL GetAddressBar() const;
	void SetAddressBar(BOOL bNewValue);
	BOOL GetStatusBar() const;
	void SetStatusBar(BOOL bNewValue);

// Operations
public:
	void GoBack();
	void GoForward();
	void GoHome();
	void GoSearch();
	void Navigate(LPCTSTR URL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,
		LPCTSTR lpszHeaders = NULL, LPVOID lpvPostData = NULL,
		DWORD dwPostDataLen = 0);
	void Navigate2(LPITEMIDLIST pIDL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags = 0,
		LPCTSTR lpszTargetFrameName = NULL,	LPCTSTR lpszHeaders = NULL,
		LPVOID lpvPostData = NULL, DWORD dwPostDataLen = 0);
	void Navigate2(LPCTSTR lpszURL, DWORD dwFlags,
		CByteArray& baPostedData,
		LPCTSTR lpszTargetFrameName = NULL, LPCTSTR lpszHeader = NULL);
	void Refresh();
	void Refresh2(int nLevel);
	void Stop();
	void PutProperty(LPCTSTR lpszProperty, const VARIANT& vtValue);
	void PutProperty(LPCTSTR lpszPropertyName, double dValue);
	void PutProperty(LPCTSTR lpszPropertyName, LPCTSTR lpszValue);
	void PutProperty(LPCTSTR lpszPropertyName, long lValue);
	void PutProperty(LPCTSTR lpszPropertyName, short nValue);
	BOOL GetProperty(LPCTSTR lpszProperty, CString& strValue);
	COleVariant GetProperty(LPCTSTR lpszProperty);
	void ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT* pvaIn,
		VARIANT* pvaOut);
	BOOL GetSource(CString& strRef);
	BOOL LoadFromResource(LPCTSTR lpszResource);
	BOOL LoadFromResource(UINT nRes);

	HRESULT QueryFormsCommand(DWORD dwCommandID, BOOL* pbSupported,
								BOOL* pbEnabled, BOOL* pbChecked);
	HRESULT ExecFormsCommand(DWORD dwCommandID, VARIANT* pVarIn,
								VARIANT* pVarOut);

// Overrides
public:
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
	   COleControlSite** ppSite, UINT nID, REFCLSID clsid);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
		DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	//{{AFX_MSG(CHtmlView)
	afx_msg void OnFilePrint();
	//}}AFX_MSG

	// DocHostUIHandler overrideables
	virtual HRESULT OnShowContextMenu(DWORD dwID, LPPOINT ppt,
		LPUNKNOWN pcmdtReserved, LPDISPATCH pdispReserved);
	virtual HRESULT OnGetExternal(LPDISPATCH *lppDispatch);
	virtual HRESULT OnGetHostInfo(DOCHOSTUIINFO *pInfo);
	virtual HRESULT OnShowUI(DWORD dwID,
		LPOLEINPLACEACTIVEOBJECT pActiveObject,
		LPOLECOMMANDTARGET pCommandTarget, LPOLEINPLACEFRAME pFrame,
		LPOLEINPLACEUIWINDOW pDoc);
	virtual HRESULT OnHideUI();
	virtual HRESULT OnUpdateUI();
	virtual HRESULT OnEnableModeless(BOOL fEnable);
	virtual HRESULT OnDocWindowActivate(BOOL fActivate);
	virtual HRESULT OnFrameWindowActivate(BOOL fActivate);
	virtual HRESULT OnResizeBorder(LPCRECT prcBorder,
		LPOLEINPLACEUIWINDOW pUIWindow, BOOL fFrameWindow);
	virtual HRESULT OnTranslateAccelerator(LPMSG lpMsg,
		const GUID* pguidCmdGroup, DWORD nCmdID);
	virtual HRESULT OnGetOptionKeyPath(LPOLESTR* pchKey, DWORD dwReserved);
	virtual HRESULT OnFilterDataObject(LPDATAOBJECT pDataObject,
		LPDATAOBJECT* ppDataObject);
	virtual HRESULT OnTranslateUrl(DWORD dwTranslate,
		OLECHAR* pchURLIn, OLECHAR** ppchURLOut);
	virtual HRESULT OnGetDropTarget(LPDROPTARGET pDropTarget,
		LPDROPTARGET* ppDropTarget);

	// Events
	virtual void OnNavigateComplete2(LPCTSTR strURL);
	virtual void OnBeforeNavigate2(LPCTSTR lpszURL, DWORD nFlags,
		LPCTSTR lpszTargetFrameName, CByteArray& baPostedData,
		LPCTSTR lpszHeaders, BOOL* pbCancel);
	virtual void OnStatusTextChange(LPCTSTR lpszText);
	virtual void OnProgressChange(long nProgress, long nProgressMax);
	virtual void OnCommandStateChange(long nCommand, BOOL bEnable);
	virtual void OnDownloadBegin();
	virtual void OnDownloadComplete();
	virtual void OnTitleChange(LPCTSTR lpszText);
	virtual void OnPropertyChange(LPCTSTR lpszProperty);
	virtual void OnNewWindow2(LPDISPATCH* ppDisp, BOOL* Cancel);
	virtual void OnDocumentComplete(LPCTSTR lpszURL);
	virtual void OnQuit();
	virtual void OnVisible(BOOL bVisible);
	virtual void OnToolBar(BOOL bToolBar);
	virtual void OnMenuBar(BOOL bMenuBar);
	virtual void OnStatusBar(BOOL bStatusBar);
	virtual void OnFullScreen(BOOL bFullScreen);
	virtual void OnTheaterMode(BOOL bTheaterMode);
	virtual void OnNavigateError(LPCTSTR lpszURL, LPCTSTR lpszFrame, DWORD dwError, BOOL *pbCancel);

// Implementation
public:
	virtual ~CHtmlView();
	virtual void OnDraw(CDC* pDC);
	CWnd m_wndBrowser;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	::ATL::CComPtr<IWebBrowser2> m_pBrowserApp;

// Event reflectors (not normally overridden)
protected:
	virtual void NavigateComplete2(LPDISPATCH pDisp, VARIANT* URL);
	virtual void BeforeNavigate2(LPDISPATCH pDisp, VARIANT* URL,
		VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData,
		VARIANT* Headers, VARIANT_BOOL* Cancel);
	virtual void DocumentComplete(LPDISPATCH pDisp, VARIANT* URL);
	virtual void NavigateError(LPDISPATCH pDisp, VARIANT* pvURL,
		VARIANT* pvFrame, VARIANT* pvStatusCode, VARIANT_BOOL* pvbCancel);

// Generated message map functions
protected:
	//{{AFX_MSG(CHtmlView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// CStreamOnCString
// This is a helper class used by the CHtmlEditCtrlBase class to stream
// HTML into and out of the web browser control.
class CStreamOnCString : public IStream
{
public:
// Construction
	CStreamOnCString()
	{
		m_current_index = 0;
	}

	CStreamOnCString(LPCTSTR szData):
		m_strStream(szData)
	{
		m_current_index = 0;
	}

	// Copies the data currently held in this
	// object into a CString
	BOOL CopyData(CString& target)
	{
		target = m_strStream;
		return TRUE;
	}

	// Sets the value of 
	BOOL SetData(LPCTSTR szData)
	{
		_ATLTRY
		{
			m_strStream = szData;
		}
		_ATLCATCHALL()
		{
			return FALSE;
		}
		return TRUE;
	}

// Implementation
	STDMETHOD(QueryInterface)(REFIID iid, void **ppUnk)
	{
		if (ppUnk == NULL) 
		{ 
			return E_POINTER; 
		}
		if (::InlineIsEqualGUID(iid, IID_IUnknown) ||
			::InlineIsEqualGUID(iid, IID_IStream) ||
			::InlineIsEqualGUID(iid, IID_ISequentialStream))
		{
			*ppUnk = (void*)this;
			AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	ULONG STDMETHODCALLTYPE AddRef( void) 
	{
		return (ULONG)1;
	}

	ULONG STDMETHODCALLTYPE Release( void) 
	{
		return (ULONG)1;
	}

	STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead)
	{
		if (pcbRead)
			*pcbRead = 0;
		if (m_strAnsi.GetLength() == 0)
			m_strAnsi = m_strStream;

		if (!pv)
			return E_POINTER;

		unsigned int length = m_strAnsi.GetLength();
		char *pStream = m_strAnsi.GetBuffer();
		if (!pStream)
			return E_UNEXPECTED;

		UINT_PTR uSum = (UINT_PTR)pStream + length;
		if (uSum < static_cast<UINT_PTR>(length))
			return E_UNEXPECTED;
		char *pEnd = reinterpret_cast<char*>(uSum);

		uSum = (UINT_PTR)pStream + m_current_index;
		if (uSum < m_current_index)
			return E_UNEXPECTED;
		char *pStart = reinterpret_cast<char*>(uSum);

		if (pStart >= pEnd)
			return S_FALSE; // no more data to read
		
		int bytes_left = (int)(pEnd-pStart);
		int bytes_to_copy = (int)__min(bytes_left, (int)cb);
		if (bytes_to_copy <= 0)
		{
			// reset members so this stream can be used again
			m_current_index = 0;
			m_strAnsi.Empty();
			return S_FALSE;
		}

		::ATL::Checked::memcpy_s(pv, cb, (void*)uSum, bytes_to_copy);
		if (pcbRead)
			*pcbRead = (ULONG)bytes_to_copy;
		m_current_index += bytes_to_copy;
		m_strAnsi.ReleaseBuffer(0);
		return S_OK;
	}

	STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten)
	{
		if (pcbWritten)
			*pcbWritten = 0;
		try
		{
#ifdef _UNICODE
			int flags = IS_TEXT_UNICODE_UNICODE_MASK;
			if (0 != IsTextUnicode((LPVOID)pv, cb, &flags))
			{
				// compiling UNICODE and got a UNICODE buffer
				UINT nCharsToSkip = flags & IS_TEXT_UNICODE_SIGNATURE ? 1 : 0;
				m_strStream.Append((wchar_t*)( ((wchar_t*)pv)+nCharsToSkip), (cb/sizeof(wchar_t))-nCharsToSkip);
				if (pcbWritten)
					*pcbWritten = cb-nCharsToSkip*sizeof(wchar_t);
			}
			else
			{
				// compiling UNICODE and got an ansi buffer
				// convert ansi buffer to UNICODE buffer
				CStringW strTemp((LPCSTR)pv, cb);
				m_strStream.Append(strTemp);
				if (pcbWritten)
					*pcbWritten = cb;
				
			}
#else
			int flags = IS_TEXT_UNICODE_UNICODE_MASK;
			if (0 != IsTextUnicode((LPVOID)pv, cb, &flags))
			{
				// compiling ANSI and got a UNICODE buffer
				UINT nCharsToSkip = flags & IS_TEXT_UNICODE_SIGNATURE ? 1 : 0;
				CStringA strTemp((const wchar_t*)pv + nCharsToSkip, (cb/sizeof(wchar_t))- nCharsToSkip);
				m_strStream.Append(strTemp);
				if (pcbWritten)
					*pcbWritten = cb-nCharsToSkip*sizeof(wchar_t);
			}
			else
			{
				// compiling ANSI and got an ANSI buffer
				m_strStream.Append((char*)pv, cb);
				if (pcbWritten)
					*pcbWritten = cb;
			}
#endif
		}
		catch (CMemoryException* e)
		{
			e->Delete();
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}

	STDMETHOD(Seek)(LARGE_INTEGER , DWORD , ULARGE_INTEGER *)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(SetSize)(ULARGE_INTEGER )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(CopyTo)(IStream *, ULARGE_INTEGER , ULARGE_INTEGER *,
		ULARGE_INTEGER *)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Commit)(DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Revert)( void)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(LockRegion)(ULARGE_INTEGER , ULARGE_INTEGER , DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(UnlockRegion)(ULARGE_INTEGER , ULARGE_INTEGER ,
		DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Stat)(STATSTG *, DWORD )
	{
		return E_NOTIMPL;
	}

	STDMETHOD(Clone)(IStream **)
	{
		return E_NOTIMPL;
	}

protected:
	CString m_strStream;
	CStringA m_strAnsi;
	UINT m_current_index;

};

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrlBase

template <class T>
class CHtmlEditCtrlBase 
{
public:
	BOOL SetDesignMode(BOOL bMode) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			if (bMode)
				return S_OK == spDoc->put_designMode(CComBSTR(L"On")) ? TRUE : FALSE;
			else
				return S_OK == spDoc->put_designMode(CComBSTR(L"Off")) ? TRUE : FALSE;
		}
		return FALSE;
	}

	HRESULT ExecCommand(const GUID *pGuid, long cmdID, long cmdExecOpt, VARIANT* pInVar=NULL, VARIANT* pOutVar=NULL) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		HRESULT hr = E_FAIL;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
			if (spCmdTarg)
			{
				hr = spCmdTarg->Exec(pGuid, cmdID, cmdExecOpt, pInVar , pOutVar);
			}
			else
				hr = E_NOINTERFACE;
		}
		return hr;
	}
	HRESULT ExecCommand(long cmdID, long cmdExecOpt, VARIANT* pInVar=NULL, VARIANT* pOutVar=NULL) const
	{
		return ExecCommand(&CGID_MSHTML, cmdID, cmdExecOpt, 
					pInVar , pOutVar );
	}

	long QueryStatus(long cmdID) const
	{
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spDoc;
		pT->GetDHtmlDocument(&spDoc);
		if (spDoc)
		{
			CComQIPtr<IOleCommandTarget> spCmdTarg = spDoc;
			if (spCmdTarg)
			{
				OLECMD ocmd = {cmdID, 0};
				if (S_OK == spCmdTarg->QueryStatus(&CGID_MSHTML, 1, &ocmd, NULL))
					return ocmd.cmdf;
			}
		}
		// if an error occurred, returning 0 means the command is disabled
		return 0;
	}

	HRESULT GetEvent(IHTMLEventObj **ppEventObj) const
	{
		::ATL::CComPtr<IHTMLWindow2> sphtmlWnd;
		::ATL::CComPtr<IHTMLDocument2> sphtmlDoc;

		if (!ppEventObj)
			return E_POINTER;

		*ppEventObj = NULL;
		HRESULT hr = E_FAIL;

		if (GetDocument(&sphtmlDoc))
		{
			hr = sphtmlDoc->get_parentWindow(&sphtmlWnd);
			if(hr == S_OK)
			{
				hr = sphtmlWnd->get_event(ppEventObj);
			}
		}
		return hr;
	}

	HRESULT GetEventSrcElement(IHTMLElement **ppSrcElement) const
	{
		::ATL::CComPtr<IHTMLEventObj> spEventObj;
		if (!ppSrcElement)
			return E_POINTER;

		*ppSrcElement = NULL;
		HRESULT hr = GetEvent(&spEventObj);
		if (hr == S_OK)
		{
			hr = spEventObj->get_srcElement(ppSrcElement);
		}
		return hr;
	}

	HRESULT GetDocument(IHTMLDocument2** ppDoc) const
	{	
		const T* pT = static_cast<const T*>(this);
		return pT->GetDHtmlDocument(ppDoc) ? S_OK : E_NOINTERFACE;
	}

	HRESULT NewDocument() const
	{
		HRESULT hr = E_FAIL;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;
		CStreamOnCString stream;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
			{
				hr = spPSI->InitNew();
			}
		}
		return hr;
	}

	HRESULT GetDocumentHTML(CString& szHTML) const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;
		CStreamOnCString stream;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
			{
				hr = spPSI->Save(static_cast<IStream*>(&stream), FALSE);
				if (hr == S_OK)
				{
					if (!stream.CopyData(szHTML))
						hr = E_OUTOFMEMORY;
				}
			}
		}
		return hr;
	}

	HRESULT SetDocumentHTML(LPCTSTR szHTML) const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		CStreamOnCString stream(szHTML);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
				hr = spPSI->Load(static_cast<IStream*>(&stream));
		}
		return hr;
	}

	HRESULT GetIsDirty() const
	{
		HRESULT hr = E_NOINTERFACE;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComQIPtr<IPersistStreamInit> spPSI;

		pT->GetDHtmlDocument(&spHTMLDocument);
		if (spHTMLDocument)
		{
			spPSI = spHTMLDocument;
			if (spPSI)
				hr = spPSI->IsDirty();
		}
		return hr;
	}

	HRESULT GetDocumentTitle(CString& szTitle) const
	{
		HRESULT hr = E_FAIL;
		const T* pT = static_cast<const T*>(this);
		::ATL::CComPtr<IHTMLDocument2> spHTMLDocument;
		CComBSTR bstrTitle;
		pT->GetDHtmlDocument(&spHTMLDocument);
		if (!spHTMLDocument)
			hr = E_NOINTERFACE;
		else
		{
			hr = spHTMLDocument->get_title(&bstrTitle);
			if (hr == S_OK)
				szTitle = COLE2CT(bstrTitle);
		}
		return hr;
	}

	HRESULT GetBlockFormatNames(CStringArray &sa) const
	{
		CComVariant vaRet;
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(IDM_GETBLOCKFMTS);
		if (lStatus & OLECMDF_ENABLED || lStatus & OLECMDF_LATCHED)
		{
			if (S_OK == ExecCommand(IDM_GETBLOCKFMTS, OLECMDEXECOPT_DODEFAULT, NULL, &vaRet))
			{						 
				if(vaRet.vt & VT_ARRAY)
				{
					SAFEARRAY *psa = vaRet.parray;
					
					long lBound = 0,uBound = 0;
					if(S_OK == SafeArrayGetLBound(psa,1,&lBound) &&
					   S_OK == SafeArrayGetUBound(psa,1,&uBound) )
					{
						for(long i=lBound; i<=uBound; i++)
						{	
							CComBSTR bstrElem;
							if( (S_OK == SafeArrayGetElement(psa, &i, &bstrElem) ))
							{
								sa.Add(CString(bstrElem));
							}
						}		
						hr = S_OK;
					}
				}
			}
		}

		if (vaRet.vt == VT_ERROR)
			hr = V_ERROR(&vaRet);

		return hr;
	}

	HRESULT SetForeColor(LPCTSTR szColor) const
	{
		return ExecHelperSetVal(IDM_FORECOLOR, szColor);
	}

	HRESULT SetForeColor(int nColor) const
	{
		return ExecHelperSetVal(IDM_FORECOLOR, nColor, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
	}

	HRESULT GetForeColor(int &nColor)
	{
		return ExecHelperGetVal(IDM_FORECOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT GetBackColor(int& nColor) const
	{
		return ExecHelperGetVal(IDM_BACKCOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetBackColor(LPCTSTR szColor) const
	{
		return ExecHelperSetVal(IDM_BACKCOLOR, szColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetBackColor(int nColor) const
	{
		return ExecHelperSetVal(IDM_BACKCOLOR, nColor, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetDefaultComposeSettings(LPCSTR szFontName=NULL,
									  unsigned short nFontSize=3,
									  COLORREF crFontColor=0xFF000000,
									  COLORREF crFontBgColor=0xFF000000,
									  bool bBold = false,
									  bool bItalic = false,
									  bool bUnderline = false) const
	{

		HRESULT hr = ExecHelperSetVal(IDM_HTMLEDITMODE, true);
		if (FAILED(hr))
			return hr;

		CString strBuffer;
		TCHAR szFontColor[12];
		TCHAR szBgColor[12];
		if(crFontColor == 0xFF000000)
			szFontColor[0] = 0;
		else
			if (0 > _sntprintf(szFontColor, 12, _T("%d.%d.%d"), GetRValue(crFontColor),
					GetGValue(crFontColor), GetBValue(crFontColor)))
					return E_UNEXPECTED;

		if (crFontBgColor == 0xFF000000)
			szBgColor[0] = 0;
		else
			if (0 > _sntprintf(szBgColor, 12, _T("%d.%d.%d"), GetRValue(crFontBgColor),
					GetGValue(crFontBgColor), GetBValue(crFontBgColor)))
					return E_UNEXPECTED;

		_ATLTRY
		{
		strBuffer.Format(_T("%d,%d,%d,%d,%s,%s,%s"),
						bBold ? 1 : 0,
						bItalic ? 1 : 0,
						bUnderline ? 1 : 0,
						nFontSize,
						szFontColor[0] ? szFontColor : _T(""),
						szBgColor[0] ? szBgColor : _T(""),
						szFontName);
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}
		return ExecHelperSetVal(IDM_COMPOSESETTINGS, (LPCTSTR)strBuffer);
	}

	HRESULT GetBlockFormat(CString& strFormat) const
	{
		return ExecHelperGetVal(IDM_BLOCKFMT, strFormat, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
	}

	HRESULT SetBlockFormat(LPCTSTR szFormat) const
	{
		return ExecHelperSetVal(IDM_BLOCKFMT, szFormat);
	}

	HRESULT GetFontFace(CString& strFace) const
	{
		return ExecHelperGetVal(IDM_FONTNAME, strFace, OLECMDF_ENABLED|OLECMDF_SUPPORTED);
	}

	HRESULT SetFontFace(LPCTSTR szFace) const
	{
		return ExecHelperSetVal(IDM_FONTNAME, szFace);
	}

	HRESULT IE50Paste(LPCTSTR szData) const
	{
		return ExecHelperSetVal(IDM_IE50_PASTE, szData);
	}

	HRESULT GetBookMark(CString& strAnchor) const
	{
		return ExecHelperGetVal(IDM_BOOKMARK, strAnchor);
	}

	HRESULT SetBookMark(LPCTSTR szAnchorName) const
	{
		return ExecHelperSetVal(IDM_BOOKMARK, szAnchorName,OLECMDF_SUPPORTED);
	}

	HRESULT SetOverwriteMode(bool bMode) const
	{
		return ExecHelperSetVal(IDM_OVERWRITE, bMode);
	}

	HRESULT Is1DElement(bool& bValue) const
	{
		return ExecHelperGetVal(IDM_1D_ELEMENT, bValue);
	}

	HRESULT Is2DElement(bool& bValue) const
	{
		return ExecHelperGetVal(IDM_2D_ELEMENT, bValue);
	}

	HRESULT GetFontSize(short& nSize) const
	{
		return ExecHelperGetVal(IDM_FONTSIZE, nSize);
	}

	HRESULT SetFontSize(unsigned short size) const
	{
		return ExecHelperSetVal(IDM_FONTSIZE, (short)size);
	}

	HRESULT GetFrameZone(short& nZone) const
	{
		return ExecHelperGetVal(IDM_GETFRAMEZONE, nZone);
	}

	HRESULT SetCSSEditingLevel(short nLevel) const
	{
		return ExecHelperSetVal(IDM_CSSEDITING_LEVEL, nLevel, 0);
	}

	HRESULT HyperLink(LPCTSTR szUrl = NULL) const
	{
		if (szUrl)
			return ExecHelperSetVal(IDM_HYPERLINK, szUrl, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		return ExecHelperNN(IDM_HYPERLINK, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
	}

	HRESULT Image(LPCTSTR szUrl = NULL) const
	{
		if (szUrl)
			return ExecHelperSetVal(IDM_IMAGE, szUrl, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		return ExecHelperNN(IDM_IMAGE, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
	}

	HRESULT OrderList(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_ORDERLIST, szId);
	}

	HRESULT UnorderList(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_UNORDERLIST, szId);
	}

	HRESULT AddToGlyphTable(LPCTSTR szTag,
							LPCTSTR szImgUrl,
							unsigned short nTagType,
							unsigned short nAlignment,
							unsigned short nPosInfo,
							unsigned short nDirection,
							unsigned int nImgWidth,
							unsigned int nImgHeight) const
	{
		// Check Paramters
		if (!szTag ||
			!szImgUrl ||
			nTagType > 2 ||
			nAlignment > 3 ||
			nPosInfo > 3 ||
			nDirection > 4)
			return E_INVALIDARG;

		CString strGlyphEntry;
		_ATLTRY
		{
			strGlyphEntry.Format(_T("%%%%%s^^%%%%%s^^%%%%%d^^%%%%%d^^%%%%%d^^")
								 _T("%%%%%d^^%%%%%d^^%%%%%d^^%%%%%d^^%%%%%d^^**"),
								 szTag, szImgUrl, nTagType, nAlignment, nPosInfo,
								 nDirection, nImgWidth, nImgHeight, nImgWidth, nImgHeight);
		}
		_ATLCATCHALL()
		{
			return E_UNEXPECTED;
		}
		CComVariant vIn((LPCTSTR)strGlyphEntry);
		return ExecCommand(IDM_ADDTOGLYPHTABLE, OLECMDEXECOPT_DODEFAULT, &vIn);
	}

	HRESULT EmptyGlyphTable() const
	{
		return ExecHelperNN(IDM_EMPTYGLYPHTABLE);
	}

	HRESULT Button(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_BUTTON, szId);
	}

	HRESULT CheckBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_CHECKBOX, szId);
	}

	HRESULT DropDownBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_DROPDOWNBOX, szId);
	}

	HRESULT HorizontalLine(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_HORIZONTALLINE, szId);
	}

	HRESULT Iframe(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_IFRAME, szId);
	}

	HRESULT InsFieldSet(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSFIELDSET, szId);
	}

	HRESULT InsInputButton(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTBUTTON, szId);
	}

	HRESULT InsInputHidden(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTHIDDEN, szId);
	}

	HRESULT InsInputImage(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTIMAGE, szId);
	}

	HRESULT InsInputPassword(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTPASSWORD, szId);
	}

	HRESULT InsInputReset(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTRESET, szId);
	}

	HRESULT InsInputSubmit(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTSUBMIT, szId);
	}

	HRESULT InsInputUpload(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_INSINPUTUPLOAD, szId);
	}

	HRESULT ListBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_LISTBOX, szId);
	}

	HRESULT Marquee(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_MARQUEE, szId);
	}

	HRESULT Paragraph(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_PARAGRAPH, szId);
	}

	HRESULT RadioButton(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_RADIOBUTTON, szId);
	}

	HRESULT SaveAs(LPCTSTR szPath = NULL) const
	{
		if (szPath)
		{
			return ExecHelperSetVal(IDM_SAVEAS, szPath, OLECMDF_SUPPORTED,
									OLECMDEXECOPT_DONTPROMPTUSER);
		}
		else
		{
			return ExecHelperNN(IDM_SAVEAS, OLECMDF_SUPPORTED, OLECMDEXECOPT_DODEFAULT);
		}
	}

	HRESULT TextArea(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_TEXTAREA, szId);
	}

	HRESULT TextBox(LPCTSTR szId = NULL) const
	{
		return ExecHelperSetVal(IDM_TEXTBOX, szId);
	}

	HRESULT GetAbsolutePosition(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_ABSOLUTE_POSITION) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetAbsolutePosition(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_ABSOLUTE_POSITION, bNewValue );
	}


	HRESULT Set2DPosition(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_2D_POSITION, bNewValue, 0);
	}

	HRESULT SetAtomicSelection(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_ATOMICSELECTION, bNewValue, 0);
	}

	HRESULT SetAutoURLDetectMode(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_AUTOURLDETECT_MODE, bNewValue, 0);
	}

	HRESULT SetDisableEditFocusUI(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_DISABLE_EDITFOCUS_UI, bNewValue, 0);
	}

	HRESULT SetIE5PasteMode(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_IE50_PASTE_MODE, bNewValue, 0);
	}

	HRESULT SetLiveResize(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_LIVERESIZE, bNewValue, 0);
	}

	HRESULT SetMultiSelect(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_MULTIPLESELECTION, bNewValue, 0);
	}

	HRESULT SetOverrideCursor(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_OVERRIDE_CURSOR, bNewValue, 0);
	}

	HRESULT SetRespectVisInDesign(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_RESPECTVISIBILITY_INDESIGN, bNewValue, 0);
	}

	HRESULT GetShowAlignedSiteTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWALIGNEDSITETAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAlignedSiteTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWALIGNEDSITETAGS, bNewValue);
	}

	HRESULT GetShowAllTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWALLTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAllTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWALLTAGS, bNewValue);
	}

	HRESULT GetShowAreaTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWAREATAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowAreaTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWAREATAGS, bNewValue);
	}

	HRESULT GetShowCommentTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWCOMMENTTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowCommentTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWCOMMENTTAGS, bNewValue);
	}

	HRESULT GetShowMiscTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWMISCTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowMiscTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWMISCTAGS, bNewValue);
	}

	HRESULT GetShowScriptTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWSCRIPTTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowScriptTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWSCRIPTTAGS, bNewValue);
	}

	HRESULT GetShowStyleTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWSTYLETAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowStyleTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWSTYLETAGS, bNewValue);
	}

	HRESULT GetShowUnknownTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWUNKNOWNTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowUnknownTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWUNKNOWNTAGS, bNewValue);
	}

	HRESULT GetShowBRTags(bool &bCurValue) const
	{
		bCurValue = (QueryStatus(IDM_SHOWWBRTAGS) & OLECMDF_LATCHED) != 0;
		return S_OK;
	}

	HRESULT SetShowBRTags(bool bNewValue) const
	{
		return ExecHelperSetVal(IDM_SHOWWBRTAGS, bNewValue);
	}

	HRESULT PrintDocument() const
	{
		return ExecHelperNN(IDM_PRINT);
	}

	HRESULT PrintDocument(LPCTSTR szPrintTemplate) const
	{
		return ExecHelperSetVal(IDM_PRINT, szPrintTemplate);
	}

	HRESULT PrintDocument(bool bShowPrintDialog) const
	{
		return ExecHelperSetVal(IDM_PRINT, (short)(bShowPrintDialog ? 1 : 0));
	}

	HRESULT PrintPreview() const
	{
		return ExecHelperNN(IDM_PRINTPREVIEW);
	}

	HRESULT PrintPreview(LPCTSTR szPrintTemplate) const
	{
		return ExecHelperSetVal(IDM_PRINTPREVIEW, szPrintTemplate);
	}

	HRESULT Bold() const
	{
		return ExecHelperNN(IDM_BOLD);
	}

	HRESULT Copy() const
	{
		return ExecHelperNN(IDM_COPY);
	}

	HRESULT Cut() const
	{
		return ExecHelperNN(IDM_CUT);
	}

	HRESULT Delete() const
	{
		return ExecHelperNN(IDM_DELETE);
	}

	HRESULT Indent() const
	{
		return ExecHelperNN(IDM_INDENT);
	}

	HRESULT Italic() const
	{
		return ExecHelperNN(IDM_ITALIC);
	}

	HRESULT JustifyCenter() const
	{
		return ExecHelperNN(IDM_JUSTIFYCENTER);
	}

	HRESULT JustifyLeft() const
	{
		return ExecHelperNN(IDM_JUSTIFYLEFT);
	}

	HRESULT JustifyRight() const
	{
		return ExecHelperNN(IDM_JUSTIFYRIGHT);
	}

	HRESULT Outdent() const
	{
		return ExecHelperNN(IDM_OUTDENT);
	}

	HRESULT Paste() const
	{
		return ExecHelperNN(IDM_PASTE);
	}

	HRESULT RemoveFormat() const
	{
		return ExecHelperNN(IDM_REMOVEFORMAT);
	}

	HRESULT SelectAll() const
	{
		return ExecHelperNN(IDM_SELECTALL);
	}

	HRESULT Underline() const
	{
		return ExecHelperNN(IDM_UNDERLINE);
	}

	HRESULT Unlink() const
	{
		return ExecHelperNN(IDM_UNLINK);
	}

	HRESULT ClearSelection() const
	{
		return ExecHelperNN(IDM_CLEARSELECTION);
	}

	HRESULT Font() const
	{
		return ExecHelperNN(IDM_FONT);
	}

	HRESULT RefreshDocument() const
	{
		return ExecHelperNN(IDM_REFRESH, OLECMDF_SUPPORTED);
	}

	HRESULT UnBookmark() const
	{
		return ExecHelperNN(IDM_UNBOOKMARK);
	}

// Implementation
	HRESULT ExecHelperNN(UINT nID,
						 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
						 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
			hr = ExecCommand(nID, nExecOpt);
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID, 
							 LPCTSTR szID=NULL,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			if (szID)
			{
				CComVariant vName(szID);
				return ExecCommand(nCmdID, nExecOpt, &vName);
			}
			else
				return ExecCommand(nCmdID, nExecOpt);
		}
		return E_FAIL;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 bool bValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn(bValue);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 short nNewVal,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn((short)nNewVal);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperSetVal(UINT nCmdID,
							 int nNewVal,
							 long nMinSupportLevel = OLECMDF_SUPPORTED|OLECMDF_ENABLED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vIn((int)nNewVal);
			hr = ExecCommand(nCmdID, nExecOpt, &vIn);
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 bool &bValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		bValue = false;
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vOut;
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vOut);
			if (hr == S_OK)
			{
				switch(vOut.vt)
				{
				case VT_BOOL:
					bValue = vOut.boolVal == VARIANT_TRUE ? true : false;
					break;
				case VT_NULL:
				case VT_EMPTY:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vOut);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 short &nValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		int nTempVal;
		HRESULT hr = ExecHelperGetVal(nCmdID, nTempVal, nMinSupportLevel, nExecOpt);
		if (hr == S_OK)
			nValue = (short)nTempVal;
		return hr;
	}


	HRESULT ExecHelperGetVal(UINT nCmdID,
							 int &nValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		long lStatus = QueryStatus(nCmdID);
		nValue = 0;
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			CComVariant vOut;
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vOut);
			if (hr == S_OK)
			{
				switch (vOut.vt)
				{
				case VT_I4:
					nValue = vOut.lVal;
					break;
				case VT_I2:
					nValue = vOut.iVal;
					break;
				case VT_EMPTY:
				case VT_NULL:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vOut);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}

	HRESULT ExecHelperGetVal(UINT nCmdID,
							 CString& strValue,
							 long nMinSupportLevel = OLECMDF_SUPPORTED,
							 long nExecOpt = OLECMDEXECOPT_DODEFAULT) const
	{
		HRESULT hr = E_FAIL;
		CComVariant vaRet;
		strValue.Empty();
		long lStatus = QueryStatus(nCmdID);
		if ((lStatus & nMinSupportLevel) == nMinSupportLevel)
		{
			hr = ExecCommand(nCmdID, nExecOpt, NULL, &vaRet);
			if (hr == S_OK)
			{
				switch(vaRet.vt)
				{
				case VT_BSTR:
					{
					CW2T szVal(vaRet.bstrVal);
					strValue = szVal;
					}
					break;
				case VT_NULL:
				case VT_EMPTY:
					break;
				case VT_ERROR:
					hr = V_ERROR(&vaRet);
					break;
				default:
					hr = E_UNEXPECTED;
					break;
				}
			}
		}
		return hr;
	}
}; //CHtmlEditCtrlBase

/////////////////////////////////////////////////////////////////////////////
// CHtmlEditCtrl
class CHtmlEditCtrl:
	public CWnd,
	public CHtmlEditCtrlBase<CHtmlEditCtrl>
{
public:
	// Construct
	CHtmlEditCtrl();

	// Create a new instance of the control. This will also call the 
	// contained WebBrowser control's Navigate method to load a default
	// document into the WebBrowser control.
	virtual BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID, CCreateContext *pContext=NULL);

	// Retrieves the URL to a default document to load.
	virtual LPCTSTR GetStartDocument();

	// Retrieves the IHTMLDocument2 interface on the contained WebBrowser control's
	// currently loaded document.
	BOOL GetDHtmlDocument(IHTMLDocument2 **ppDocument) const;
protected:
// Implementation
	virtual ~CHtmlEditCtrl();
	DECLARE_EVENTSINK_MAP()
	void _OnNavigateComplete2(LPDISPATCH pDisp, VARIANT FAR* URL);

};


/////////////////////////////////////////////////////////////////////////////
// CHtmlEditView
#define AFX_INVALID_DHTML_CMD_ID 0xFFFFFFFF
#define AFX_UI_ELEMTYPE_NORMAL	0
#define AFX_UI_ELEMTYPE_CHECBOX	1
#define AFX_UI_ELEMTYPE_RADIO	2


#define DECLARE_DHTMLEDITING_CMDMAP(className) \
public: \
	UINT GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL&, UINT&); \
	BOOL ExecHandler(UINT nCmdID); \
	typedef void  (className##::*PFN_##className##_CMDHDLR)(UINT); \
	struct className##dhtml_cmd_mapping \
	{ \
		UINT windowsCommand; \
		UINT dhtmlCommand; \
		UINT nElementType; \
		PFN_##className##_CMDHDLR pfn; \
	}; \
	static className##dhtml_cmd_mapping m_commands[];\

#define DHTMLEDITING_CMD_ENTRY(cmdID, dhtmlcmdID)\
{cmdID, dhtmlcmdID, AFX_UI_ELEMTYPE_NORMAL, NULL}, 

#define DHTMLEDITING_CMD_ENTRY_FUNC(cmdID, dhtmlcmdID, member_func_name)\
{cmdID, dhtmlcmdID, AFX_UI_ELEMTYPE_NORMAL, member_func_name},

#define DHTMLEDITING_CMD_ENTRY_TYPE(cmdID, dhtmlcmdID, elemType)\
{cmdID, dhtmlcmdID, elemType, NULL}, 

#define DHTMLEDITING_CMD_ENTRY_FUNC_TYPE(cmdID, dhtmlcmdID, member_func_name, elemType)\
{cmdID, dhtmlcmdID, elemType, member_func_name},

#define BEGIN_DHTMLEDITING_CMDMAP(className) \
PTM_WARNING_DISABLE \
BOOL className##::ExecHandler(UINT nWindowsCommand)\
{\
	const className##dhtml_cmd_mapping *pMapping = className##::m_commands;\
	while (pMapping->dhtmlCommand != 0)\
	 {\
	 if (nWindowsCommand == pMapping->windowsCommand)\
	 {\
		(this->*pMapping->pfn)(pMapping->dhtmlCommand);\
		return TRUE;\
	 }\
	 pMapping++;\
	 }\
	return FALSE;\
}\
UINT className##::GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL& bHasExecFunc, UINT& uiElemType)\
{ \
	const className##dhtml_cmd_mapping *pMapping = className##::m_commands;\
	 while (pMapping->dhtmlCommand != 0)\
	 {\
	 if (pMapping->windowsCommand == nIDWindowsCommand)\
	 {\
		 bHasExecFunc = pMapping->pfn != NULL ? TRUE : FALSE;\
		 uiElemType = pMapping->nElementType;\
		 return pMapping->dhtmlCommand;\
	 }\
	 pMapping++;\
	 }\
	return AFX_INVALID_DHTML_CMD_ID;\
}\
className##::className##dhtml_cmd_mapping className##::m_commands[] = {

#define END_DHTMLEDITING_CMDMAP()\
		{0, 0, 0, NULL} \
	}; \
	PTM_WARNING_RESTORE

class CHtmlEditView :
	public CHtmlView,
	public CHtmlEditCtrlBase<CHtmlEditView>
{
public:
	CHtmlEditView();

	// Retrieve the IHTMLDocument2 interface associated with the
	// document loaded in the contained WebBrowser control.
	BOOL GetDHtmlDocument(IHTMLDocument2 **ppDocument) const;

	// Create a new window object. This function will also call the
	// contained WebBrowser's Navigate method to load a default document.
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName,
		DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);

	// Retrieve the name of the default document for this view.
	virtual LPCTSTR GetStartDocument();

// Implementation
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual UINT GetDHtmlCommandMapping(UINT nIDWindowsCommand, BOOL& bHasExecFunc, UINT& uiElemType);
	virtual BOOL ExecHandler(UINT nCmdID);
	virtual void OnNavigateComplete2(LPCTSTR strURL);
	void OnPaint();
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CHtmlEditView)
	virtual ~CHtmlEditView();
};

class AFX_NOVTABLE CHtmlEditDoc : public CDocument
{
public:
	// Construction
	CHtmlEditDoc();

	// Get the CHtmlEditView associated with this document
	virtual CHtmlEditView* GetView() const;

	// Open a URL into the view associated with this document
	virtual BOOL OpenURL(LPCTSTR lpszURL);

	// See if the associated view's WebBrowser control contains a 
	// document that has been modified by the user.
	virtual BOOL IsModified();

// Implementation
public:
	virtual ~CHtmlEditDoc();
	virtual void DeleteContents();
	virtual BOOL OnOpenDocument(LPCTSTR lpszFileName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszFileName);
	virtual BOOL OnNewDocument();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	DECLARE_DYNCREATE(CHtmlEditDoc)
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#pragma warning(pop)

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXHTML_INLINE AFX_INLINE
#include <afxhtml.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFXHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxisapi.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXISAPI_H_
#define __AFXISAPI_H_

#ifndef _WIN32_WCE // Internet Server API

#ifdef _UNICODE
#error ERROR: ISAPI does not support Unicode.
#endif

#pragma once

#include <afxv_cpu.h>

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#ifdef _AFX_ALL_WARNINGS
#pragma warning( push )
#endif

// warnings generated with common MFC/Windows code
#pragma warning(disable: 4127)  // constant expression for TRACE/ASSERT
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4201)  // nameless unions are part of C++
#pragma warning(disable: 4320)  // structs w/ uuid and single base class
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#pragma warning(disable: 4514)  // unreferenced inlines are common
#pragma warning(disable: 4710)  // function not inlined
#pragma warning(disable: 4705)  // statement has no effect in optimized code
#pragma warning(disable: 4191)  // pointer-to-function casting
// warnings caused by normal optimizations
#ifndef _DEBUG
#pragma warning(disable: 4701)  // local variable *may* be used without init
#pragma warning(disable: 4702)  // unreachable code caused by optimizations
#pragma warning(disable: 4791)  // loss of debugging info in retail version
#pragma warning(disable: 4189)  // initialized but unused variable
#pragma warning(disable: 4390)  // empty controlled statement
#endif
// warnings specific to _AFXDLL version
#ifdef _AFXDLL
#pragma warning(disable: 4204)  // non-constant aggregate initializer
#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#endif

#define STRICT 1

#ifndef _AFX_ENABLE_INLINES
#define _AFX_ENABLE_INLINES
#endif

#include <httpext.h>
#include <httpfilt.h>

#ifndef _INC_STDLIB
	#include <stdlib.h>
#endif
#ifndef _INC_TCHAR
	#include <tchar.h>
#endif
#ifndef _INC_ERRNO 
	#include <errno.h>
#endif


#ifndef UNUSED
#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#endif

#define AFXISAPI __stdcall
#define AFXIS_DATADEF
#define AFXISAPI_CDECL __cdecl

#ifndef AFX_INLINE
#define AFX_INLINE __forceinline
#endif

#if !defined(UNALIGNED)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#if !defined(_countof)
#if !defined(__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else
extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper(UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) sizeof(*__countof_helper(_Array))
}
#endif
#endif

// Catches
// limits.h must not define its constants in terms of hex. [we are ok here]
// Actual limits.h values may cause excessive buffer.

// Users should use INT_MIN, not INT_MAX, to allow space for signs 
// makes a literal into a string

#define AFXISAPI_STRINGIZE(x) (# x)
// expands a macro and then makes that into a string

#define AFXISAPI_STRINGIZE_MACRO(x) AFXISAPI_STRINGIZE(x)

// determines the character count (includeing terminator) required by a numeric macro
#define AFXISAPI_CHARCOUNT_CONSTANT(x) (sizeof(AFXISAPI_STRINGIZE_MACRO(x)))


/////////////////////////////////////////////////////////////////////////////
// Internet Server API Library

#ifndef _AFX_NOFORCE_LIBS

#ifdef _AFXDLL
#ifdef _DEBUG
	#ifdef _UNICODE
		#pragma comment(lib, "MFCISUD.lib")
	#else
		#pragma comment(lib, "EAFXISD.lib")
	#endif
#else
	#ifdef _UNICODE
		#pragma comment(lib, "MFCISU.lib")
	#else
		#pragma comment(lib, "EAFXIS.lib")
	#endif // _UNICODE
#endif // _DEBUG
#else
#ifdef _DEBUG
	#ifdef _UNICODE
		#pragma comment(lib, "UAFXISD.lib")
	#else
		#pragma comment(lib, "NAFXISD.lib")
	#endif
#else
	#ifdef _UNICODE
		#pragma comment(lib, "UAFXIS.lib")
	#else
		#pragma comment(lib, "NAFXIS.lib")
	#endif // _UNICODE
#endif // _DEBUG
#endif // _AFXDLL

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "winspool.lib")
#pragma comment(lib, "advapi32.lib")

#endif // _AFX_NOFORCE_LIBS

extern HINSTANCE AFXISAPI AfxGetResourceHandle();

/////////////////////////////////////////////////////////////////////////////
// AFXIASPI - MFC Internet Server API support

// Classes declared in this file

class CHtmlStream;
class CHttpServerContext;
class CHttpServer;
class CHttpFilterContext;
class CHttpFilter;
class CHttpArgList;
struct CHttpArg;

// Classes this file uses from elsewhere, sometimes

#ifdef _AFX
class CLongBinary;
class CByteArray;
#endif

///////////////////////////////////////////////////////////////////////
// CHtmlStream -- manages in-memory HTML

class CHtmlStream
{
public:
// Constructors
	/* explicit */ CHtmlStream(UINT nGrowBytes = 4096);
	CHtmlStream(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);

// Operations
	void Attach(BYTE* lpBuffer, UINT nBufferSize, UINT nGrowBytes = 0);
	BYTE* Detach();
	DWORD GetStreamSize() const;

	virtual void Abort();
	virtual void Close();
	virtual void InitStream();
	virtual void Reset();

	virtual void Write(const void* lpBuf, UINT nCount);

	CHtmlStream& operator<<(LPCTSTR psz);
	CHtmlStream& operator<<(short int w);
	CHtmlStream& operator<<(long int dw);
	CHtmlStream& operator<<(const CHtmlStream& stream);
	CHtmlStream& operator<<(double d);
	CHtmlStream& operator<<(float f);

#ifdef _AFX
	// only available if building with core MFC
	CHtmlStream& operator<<(const CByteArray& array);
#ifndef _AFX_NO_DB_SUPPORT
	CHtmlStream& operator<<(const CLongBinary& blob);
#endif // _AFX_NO_DB_SUPPORT
#endif

// Advanced Overridables
protected:
	virtual BYTE* Alloc(DWORD nBytes);
	virtual BYTE* Realloc(BYTE* lpMem, DWORD nBytes);
	virtual BYTE* Memcpy(BYTE* lpMemTarget, const BYTE* lpMemSource, UINT nBytes);
	virtual void GrowStream(DWORD dwNewLen);

	DWORD   m_nStreamSize;

public:
	virtual void Free(BYTE* lpMem);

// Implementation
protected:
	UINT    m_nGrowBytes;
	DWORD   m_nPosition;
	DWORD   m_nBufferSize;
	BYTE*   m_lpBuffer;
	BOOL    m_bAutoDelete;

public:
	virtual ~CHtmlStream();
};


///////////////////////////////////////////////////////////////////////
// Status codes for HTTP transactions

#ifndef _WININET_ // these symbols may come from WININET.H

#define HTTP_STATUS_OK                  200     // OK
#define HTTP_STATUS_CREATED             201     // created
#define HTTP_STATUS_ACCEPTED            202     // accepted
#define HTTP_STATUS_NO_CONTENT          204     // no content
#define HTTP_STATUS_REDIRECT            302     // moved permanently
#define HTTP_STATUS_TEMP_REDIRECT       302     // moved temporarily
#define HTTP_STATUS_NOT_MODIFIED        304     // not modified
#define HTTP_STATUS_BAD_REQUEST         400     // bad request
#define HTTP_STATUS_AUTH_REQUIRED       401     // unauthorized
#define HTTP_STATUS_FORBIDDEN           403     // forbidden
#define HTTP_STATUS_NOT_FOUND           404     // not found
#define HTTP_STATUS_REQUEST_TOO_LARGE   413     // Request entity was too large
#define HTTP_STATUS_SERVER_ERROR        500     // internal server error
#define HTTP_STATUS_NOT_IMPLEMENTED     501     // not implemented
#define HTTP_STATUS_BAD_GATEWAY         502     // bad gateway
#define HTTP_STATUS_SERVICE_NA          503     // service unavailable
#endif

///////////////////////////////////////////////////////////////////////
// Parse Map macros

#ifndef AFX_PARSE_CALL
#define AFX_PARSE_CALL
#endif

typedef void (AFX_PARSE_CALL CHttpServer::*AFX_PISAPICMD)(CHttpServerContext* pCtxt);

struct AFX_PARSEMAP_ENTRY;  // declared after CHttpServer, below

struct AFX_PARSEMAP
{
	UINT (PASCAL* pfnGetNumMapEntries)();
#ifdef _AFXDLL
	const AFX_PARSEMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_PARSEMAP* pBaseMap;
#endif
	const AFX_PARSEMAP_ENTRY* lpEntries;
	~AFX_PARSEMAP();
};

struct AFX_PARSEMAP_ENTRY_PARAMS
{
	int nParams;            // number of parameters
	int nRequired;          // number of parameters without defaults
	// all of these are arrays!
	LPTSTR* ppszInfo;       // pointers to name[2n], pointer to default[2n+1]
	BYTE*   ppszDefaults;   // pointers to coerced default values
	~AFX_PARSEMAP_ENTRY_PARAMS();
};

#ifdef _AFXDLL
#define DECLARE_PARSE_MAP() \
private: \
	static AFX_PARSEMAP_ENTRY _parseEntries[]; \
public: \
	static const AFX_PARSEMAP parseMap; \
	static const AFX_PARSEMAP* PASCAL GetThisParseMap(); \
	static UINT PASCAL GetNumMapEntries(); \
	virtual const AFX_PARSEMAP* GetParseMap() const; \

#else
#define DECLARE_PARSE_MAP() \
private: \
	static AFX_PARSEMAP_ENTRY _parseEntries[]; \
public: \
	static const AFX_PARSEMAP parseMap; \
	static UINT PASCAL GetNumMapEntries(); \
	virtual const AFX_PARSEMAP* GetParseMap() const; \

#endif // _AFXDLL

#ifdef _AFXDLL
#define BEGIN_PARSE_MAP(theClass, baseClass) \
	const AFX_PARSEMAP* PASCAL theClass::GetThisParseMap() \
		{ return &theClass::parseMap; } \
	typedef void (AFX_PARSE_CALL theClass::*theClass##CALL)(CHttpServerContext*); \
	const AFX_PARSEMAP* theClass::GetParseMap() const \
		{ return &theClass::parseMap; } \
	AFXIS_DATADEF const AFX_PARSEMAP theClass::parseMap = \
		{ &theClass::GetNumMapEntries, &baseClass::GetThisParseMap, &theClass::_parseEntries[0] }; \
	AFX_PARSEMAP_ENTRY theClass::_parseEntries[] = \
	{ \

#else
#define BEGIN_PARSE_MAP(theClass, baseClass) \
	typedef void (AFX_PARSE_CALL theClass::*theClass##CALL)(CHttpServerContext*); \
	const AFX_PARSEMAP* theClass::GetParseMap() const \
		{ return &theClass::parseMap; } \
	AFXIS_DATADEF const AFX_PARSEMAP theClass::parseMap = \
		{ &theClass::GetNumMapEntries, &baseClass::parseMap, &theClass::_parseEntries[0] }; \
	AFX_PARSEMAP_ENTRY theClass::_parseEntries[] = \
	{ \

#endif

#define ON_PARSE_COMMAND(FnName, mapClass, Args) \
	{ _T(#FnName), (AFX_PISAPICMD) (mapClass##CALL)&mapClass::FnName,\
		Args, NULL },

#define ON_PARSE_COMMAND_PARAMS(Params) \
	{ NULL, (AFX_PISAPICMD) NULL, Params, NULL },

#define DEFAULT_PARSE_COMMAND(FnName, mapClass) \
	{ _T(#FnName), (AFX_PISAPICMD) (mapClass##CALL)&mapClass::FnName,\
		NULL, NULL },

#define END_PARSE_MAP(theClass) \
	}; \
	UINT PASCAL theClass::GetNumMapEntries() { \
		return sizeof(theClass::_parseEntries) /\
		sizeof(AFX_PARSEMAP_ENTRY); } \

///////////////////////////////////////////////////////////////////////
//

class CHttpServerContext
{
public:
	explicit CHttpServerContext(EXTENSION_CONTROL_BLOCK* pECB);
	virtual ~CHttpServerContext();

// Operations
	BOOL GetServerVariable(__in_z LPTSTR lpszVariableName,
		__out_bcount_part_z(*lpdwSize, *lpdwSize) LPVOID lpvBuffer, __inout LPDWORD lpdwSize);
	BOOL WriteClient(LPVOID lpvBuffer, LPDWORD lpdwBytes, DWORD dwReserved = 0);
	BOOL ReadClient(LPVOID lpvBuffer, LPDWORD lpdwSize);
	BOOL ServerSupportFunction(DWORD dwHSERRequest,
		LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType);
	BOOL TransmitFile(HANDLE hFile,
		DWORD dwFlags = HSE_IO_DISCONNECT_AFTER_SEND,
		LPVOID pstrHeader = NULL, DWORD dwHeaderLen = 0,
		LPVOID pstrTrailer = NULL, DWORD dwTrailerLen = 0);

	CHttpServerContext& operator<<(LPCTSTR psz);
	CHttpServerContext& operator<<(long int dw);
	CHttpServerContext& operator<<(short int w);
	CHttpServerContext& operator<<(const CHtmlStream& stream);
	CHttpServerContext& operator<<(double d);
	CHttpServerContext& operator<<(float f);

#ifdef _AFX
#ifndef _AFX_NO_DB_SUPPORT
	CHttpServerContext& operator<<(const CLongBinary& blob);
#endif //_AFX_NO_DB_SUPPORT
	CHttpServerContext& operator<<(const CByteArray& array);
#endif

	DWORD SetChunkSize(DWORD dwNewSize);
	DWORD GetChunkSize() const;

	void Reset();

// Attributes
public:
	BOOL m_bSendHeaders;
	DWORD m_dwStatusCode;
	EXTENSION_CONTROL_BLOCK* const m_pECB;
	CHtmlStream* m_pStream;
	DWORD m_dwEndOfHeaders;
#ifdef _DEBUG
	DWORD m_dwOldEndOfHeaders;
#endif

// Implementation
	DWORD m_dwBytesReceived;
	DWORD m_dwChunkSize;
	CHttpArgList* m_pArgList;
};


///////////////////////////////////////////////////////////////////////
// Internet Information Server Extension Support

class CHttpServer
{
public:
	/* explicit */ CHttpServer(TCHAR cDelimiter = '&');
	virtual ~CHttpServer();

	enum errors {
		callOK = 0,         // everything is fine
		callParamRequired,  // a required parameter was missing
		callBadParamCount,  // there were too many or too few parameters
		callBadCommand,     // the command name was not found
		callNoStackSpace,   // no stack space was available
		callNoStream,       // no CHtmlStream was available
		callMissingQuote,   // a parameter had a bad format
		callMissingParams,  // no parameters were available
		callBadParam,       // a paremeter had a bad format (ie, only one quote)
		callNoMemory,		// ran out of memory
	};

// overridables
	virtual int CallFunction(__in CHttpServerContext* pCtxt,
		__in_z LPTSTR pszQuery, __in_z_opt LPTSTR pszCommand);
	virtual BOOL OnParseError(CHttpServerContext* pCtxt, int nCause);
	virtual BOOL OnWriteBody(CHttpServerContext* pCtxt, LPBYTE pbContent,
		DWORD dwSize, DWORD dwReserved = 0);

// operations
	virtual void EndContent(CHttpServerContext* pCtxt) const;
	virtual void StartContent(CHttpServerContext* pCtxt) const;
	virtual void WriteTitle(CHttpServerContext* pCtxt) const;
	virtual LPCTSTR GetTitle() const;
	void AddHeader(CHttpServerContext* pCtxt, LPCTSTR pszString) const;

	virtual BOOL TerminateExtension(DWORD dwFlags);
	virtual DWORD HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB);
	virtual BOOL GetExtensionVersion(HSE_VERSION_INFO *pVer);
	virtual CHtmlStream* ConstructStream();

	virtual BOOL InitInstance(CHttpServerContext* pCtxt);

// implementation
protected:
	UINT PASCAL GetStackSize(const BYTE* pbParams);
	int CallMemberFunc(__in CHttpServerContext* pCtxt,
		__in const AFX_PARSEMAP_ENTRY* pEntry,
		__in AFX_PARSEMAP_ENTRY* pParams, __in_z_opt LPTSTR szParams);
	LPTSTR GetQuery(CHttpServerContext* pCtxt, __in_z LPTSTR lpszQuery);
	const AFX_PARSEMAP_ENTRY* LookUp(LPCTSTR szMethod,
		const AFX_PARSEMAP*& pMap, AFX_PARSEMAP_ENTRY*& pParams,
		AFX_PISAPICMD pCmdDefault = NULL);
	int CountParams(LPCTSTR pszCommandLine, int& nCount);
	int ParseDefaultParams(AFX_PARSEMAP_ENTRY* pParams,
		int nParams, AFX_PARSEMAP_ENTRY_PARAMS*& pBlock,
		const BYTE* pbTypes);
	LPVOID PreprocessString(__in_z LPTSTR psz);
	void BuildStatusCode(__in_z LPTSTR pszResponse, __in DWORD dwCode);

#ifdef _SHADOW_DOUBLES
	int PushDefaultStackArgs(BYTE* pStack,
		CHttpServerContext* pCtxt, const BYTE* pbParams,
		__in_z_opt LPTSTR lpszParams, AFX_PARSEMAP_ENTRY_PARAMS* pDefParams,
		int nSizeArgs);
	int PushStackArgs(BYTE* pStack, CHttpServerContext* pCtxt,
		const BYTE* pbParams, __in_z_opt LPTSTR lpszParams, UINT nSizeArgs);
	BYTE* StoreStackParameter(BYTE* pStack, BYTE nType,
		__in_z LPTSTR pszCurParam, UINT nSizeArgs, BOOL bDoShadow);
	BYTE* StoreRawStackParameter(BYTE* pStack, BYTE nType,
		BYTE* pRawParam, int nSizeArgs);
#else
	int PushDefaultStackArgs(BYTE* pStack,
		CHttpServerContext* pCtxt, const BYTE* pbParams,
		__in_z_opt LPTSTR lpszParams, AFX_PARSEMAP_ENTRY_PARAMS* pDefParams);
	int PushStackArgs(BYTE* pStack, CHttpServerContext* pCtxt,
		const BYTE* pbParams, __in_z_opt LPTSTR lpszParams);
	BYTE* StoreStackParameter(BYTE* pStack, BYTE nType, __in_z LPTSTR pszParam);
	BYTE* StoreRawStackParameter(BYTE* pStack, BYTE nType, BYTE* pRawParam);
#endif

	const TCHAR m_cTokenDelimiter;  // can't EVER change

	DECLARE_PARSE_MAP()
};

extern "C" BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pVer);
extern "C" DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB);

struct AFX_PARSEMAP_ENTRY
{
	LPTSTR          pszFnName;     // if default param entry, ptr to AFX_PARSEMAP_ENTRY_PARAMS
	AFX_PISAPICMD   pfn;           // NULL if default param entry
	LPCSTR          pszArgs;       // NULL if default function entry
	LPSTR           pszParamInfo;  // copy of pszArgs for parsing
};

///////////////////////////////////////////////////////////////////////
// Constants to describe parameter types

#define ITS_EMPTY           "\x06"      // no parameters
#define ITS_I2              "\x01"      // a 'short'
#define ITS_I4              "\x02"      // a 'long'
#define ITS_R4              "\x03"      // a 'float'
#define ITS_R8              "\x04"      // a 'double'
#define ITS_PSTR            "\x05"      // a 'LPCTSTR'
#define ITS_RAW             "\x07"      // exactly as received
#define ITS_I8              "\x08"      // an '_int64'
#define ITS_ARGLIST         "\x09"      // pointer to CHttpArgList

enum INETVARENUM
{
	IT_I2       = 1,
	IT_I4       = 2,
	IT_R4       = 3,
	IT_R8       = 4,
	IT_PSTR     = 5,
	IT_EMPTY    = 6,
	IT_RAW      = 7,
	IT_I8       = 8,
	IT_ARGLIST  = 9,
};

///////////////////////////////////////////////////////////////////////
// class to describe parameters as received

#ifndef _AFX
struct __POSITION { };
typedef __POSITION* POSITION;
#endif

struct CHttpArg
{
protected:
	// Implementation
	~CHttpArg();
	CHttpArg *m_pNext;
	friend class CHttpArgList;

	// Constructors
public:
	explicit CHttpArg(CHttpArg* pPrevious, LPCTSTR pstrRaw = NULL);

	// Attributes
	LPCTSTR m_pstrRaw;	// unparsed "param=value" string
	LPCTSTR m_pstrParam;	// parsed parameter name
	LPCTSTR m_pstrValue;	// parsed value for parameter
};

class CHttpArgList
{
public:
	static void Unescape(__in_z LPTSTR pstrChunk);

	// Operations

	// Get POSITION of first argument
	POSITION GetFirstArgPosition() const;

	// get pointer to argument and move POSITION to 
	// reference next argument
	CHttpArg* GetNextArg(POSITION& pos) const;

	// Implementation
public:
	~CHttpArgList();
	bool BuildArgList(__in_z LPTSTR psz, TCHAR cDelimiter);
	CHttpArgList();

protected:
	CHttpArg* m_pFirstArg;
};

///////////////////////////////////////////////////////////////////////
// Internet Information Server Entry Points

extern "C" DWORD WINAPI HttpFilterProc(PHTTP_FILTER_CONTEXT pfc,
	DWORD dwNotificationType, LPVOID pvNotification);

extern "C" BOOL WINAPI GetFilterVersion(PHTTP_FILTER_VERSION pVer);


///////////////////////////////////////////////////////////////////////
// Internet Information Server Filter Support

class CHttpFilterContext
{
public:
	CHttpFilterContext(PHTTP_FILTER_CONTEXT pfc);
	~CHttpFilterContext() { }

	BOOL GetServerVariable(__in_z LPTSTR lpszVariableName, __out_ecount_part(*lpdwSize, *lpdwSize) LPVOID lpvBuffer,
		__inout LPDWORD lpdwSize);
	BOOL AddResponseHeaders(__in_z LPTSTR lpszHeaders, DWORD dwReserved = 0);
	BOOL WriteClient(LPVOID lpvBuffer, LPDWORD lpdwBytes,
		DWORD dwReserved = 0);
	LPVOID AllocMem(DWORD cbSize, DWORD dwReserved = 0);
	BOOL ServerSupportFunction(enum SF_REQ_TYPE sfReq,
		LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType);

	PHTTP_FILTER_CONTEXT const m_pFC;
};


///////////////////////////////////////////////////////////////////////
//

class CHttpFilter
{
public:
	CHttpFilter();
	~CHttpFilter();

protected:

public:
	virtual DWORD HttpFilterProc(PHTTP_FILTER_CONTEXT pfc,
		DWORD dwNotificationType, LPVOID pvNotification);
	virtual BOOL GetFilterVersion(PHTTP_FILTER_VERSION pVer);

	virtual DWORD OnReadRawData(CHttpFilterContext* pfc, PHTTP_FILTER_RAW_DATA pRawData);
	virtual DWORD OnPreprocHeaders(CHttpFilterContext* pfc, PHTTP_FILTER_PREPROC_HEADERS pHeaders);
	virtual DWORD OnAuthentication(CHttpFilterContext* pfc, PHTTP_FILTER_AUTHENT pAuthent);
	virtual DWORD OnUrlMap(CHttpFilterContext* pfc, PHTTP_FILTER_URL_MAP pUrlMap);
	virtual DWORD OnSendRawData(CHttpFilterContext* pfc, PHTTP_FILTER_RAW_DATA pRawData);
	virtual DWORD OnLog(CHttpFilterContext* pfc, PHTTP_FILTER_LOG pLog);
	virtual DWORD OnEndOfNetSession(CHttpFilterContext* pfc);
	virtual DWORD OnEndOfRequest(CHttpFilterContext* pfc);
	virtual DWORD OnAuthComplete(CHttpFilterContext* pfc, PHTTP_FILTER_AUTH_COMPLETE_INFO pAuthComplInfo);
	virtual DWORD OnSendResponse(CHttpFilterContext*, PHTTP_FILTER_SEND_RESPONSE);
	virtual DWORD OnAccessDenied(CHttpFilterContext*, PHTTP_FILTER_ACCESS_DENIED);
};


/////////////////////////////////////////////////////////////////////////////
// Alternate debugging suppot

#include <malloc.h>
#include <crtdbg.h>

#ifdef _AFX
#define ISAPIASSERT(expr)                   ASSERT(expr)
#define ISAPITRACE                          TRACE
#define ISAPITRACE0(str)                    TRACE0(str)
#define ISAPITRACE1(str, arg1)              TRACE1(str, arg1)
#define ISAPITRACE2(str, arg1, arg2)        TRACE2(str, arg1, arg2)
#define ISAPITRACE3(str, arg1, arg2, arg3)  TRACE3(str, arg1, arg2, arg3)

#define ISAPIENSURE(expr)					do{ int __afx_condVal=!!(expr); ISAPIASSERT(__afx_condVal); if (!(__afx_condVal)) {AfxThrowInvalidArgException();}}while(false)

#else // !_AFX
#define ISAPIASSERT(expr)                   _ASSERTE(expr)
#define ISAPITRACE0(str)                    _RPT0(_CRT_WARN, str)
#define ISAPITRACE1(str, arg1)              _RPT1(_CRT_WARN, str, arg1)
#define ISAPITRACE2(str, arg1, arg2)        _RPT2(_CRT_WARN, str, arg1, arg2)
#define ISAPITRACE3(str, arg1, arg2, arg3)  _RPT3(_CRT_WARN, arg1, arg2, arg3)

#include <exception>

class CException {};
class CSimpleException : public CException {};
class CMemoryException : public CException {};
class CInvalidArgException : public CSimpleException {};

#define ISAPIENSURE(expr)					do{ int __afx_condVal=!!(expr); ISAPIASSERT(__afx_condVal); if (!(__afx_condVal)) { throw new CInvalidArgException(); }}while(false)

void AFXISAPI_CDECL AfxISAPITrace(LPCTSTR lpszFormat, ...);

#ifdef _DEBUG
#define ISAPITRACE                          AfxISAPITrace
#else
#define ISAPITRACE                          __noop
#endif // _DEBUG
#endif // _AFX

#ifdef _DEBUG
#define ISAPIVERIFY(expr)                   ISAPIASSERT(expr)
#else
#define ISAPIVERIFY(expr)                   ((void)(expr))
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXISAPI_INLINE AFX_INLINE
#include <afxisapi.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#ifdef _AFX_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif // !_WIN32_WCE
#endif // __AFXISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxinet.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXINET_H_
#define __AFXINET_H_

#ifdef _AFX_NO_INET_SUPPORT
	#error Internet Services classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif


#ifndef _WININET_
#include <wininet.h>
#endif

#ifdef _AFXDLL
#pragma comment(lib, "wininet.lib")
#endif

/////////////////////////////////////////////////////////////////////////////
// classes that are declared in this file

class CInternetSession; // from CObject

class CGopherLocator;   // from CObject

class CInternetFile;    // from CStdioFile (FILETXT.CPP)
	class CHttpFile;
	class CGopherFile;

class CInternetConnection;
	class CFtpConnection;
	class CGopherConnection;
	class CHttpConnection;

class CFtpFileFind;     // from CFileFind (FILEFIND.CPP)
class CGopherFileFind;

class CInternetException;

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Global Functions

BOOL AFXAPI AfxParseURL(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort);
BOOL AFXAPI AfxParseURLEx(LPCTSTR pstrURL, DWORD& dwServiceType,
	CString& strServer, CString& strObject, INTERNET_PORT& nPort,
	CString& strUsername, CString& strPassword, DWORD dwFlags = 0);

DWORD AFXAPI AfxGetInternetHandleType(HINTERNET hQuery);

// see CInternetException at the bottom of this file

void AFXAPI AfxThrowInternetException(DWORD_PTR dwContext, DWORD dwError = 0);

// these are defined by WININET.H

#define AFX_INET_SERVICE_FTP        INTERNET_SERVICE_FTP
#define AFX_INET_SERVICE_HTTP       INTERNET_SERVICE_HTTP
#define AFX_INET_SERVICE_GOPHER     INTERNET_SERVICE_GOPHER

// these are types that MFC parsing functions understand

#define AFX_INET_SERVICE_UNK        0x1000
#define AFX_INET_SERVICE_FILE       (AFX_INET_SERVICE_UNK+1)
#define AFX_INET_SERVICE_MAILTO     (AFX_INET_SERVICE_UNK+2)
#define AFX_INET_SERVICE_MID        (AFX_INET_SERVICE_UNK+3)
#define AFX_INET_SERVICE_CID        (AFX_INET_SERVICE_UNK+4)
#define AFX_INET_SERVICE_NEWS       (AFX_INET_SERVICE_UNK+5)
#define AFX_INET_SERVICE_NNTP       (AFX_INET_SERVICE_UNK+6)
#define AFX_INET_SERVICE_PROSPERO   (AFX_INET_SERVICE_UNK+7)
#define AFX_INET_SERVICE_TELNET     (AFX_INET_SERVICE_UNK+8)
#define AFX_INET_SERVICE_WAIS       (AFX_INET_SERVICE_UNK+9)
#define AFX_INET_SERVICE_AFS        (AFX_INET_SERVICE_UNK+10)
#define AFX_INET_SERVICE_HTTPS      (AFX_INET_SERVICE_UNK+11)

/////////////////////////////////////////////////////////////////////////////
// classes that are declared in this file

class CInternetSession : public CObject
{
public:
	/* explicit */ CInternetSession(LPCTSTR pstrAgent = NULL,
		DWORD_PTR dwContext = 1,
		DWORD dwAccessType = PRE_CONFIG_INTERNET_ACCESS,
		LPCTSTR pstrProxyName = NULL,
		LPCTSTR pstrProxyBypass = NULL,
		DWORD dwFlags = 0);

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;
	BOOL QueryOption(DWORD dwOption, CString& refString) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

	CStdioFile* OpenURL(LPCTSTR pstrURL,
		DWORD_PTR dwContext = 1, DWORD dwFlags = INTERNET_FLAG_TRANSFER_ASCII,
		LPCTSTR pstrHeaders = NULL, DWORD dwHeadersLength = 0);

	CFtpConnection* GetFtpConnection(LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		BOOL bPassive = FALSE);

	CHttpConnection* GetHttpConnection(LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL);
	CHttpConnection* GetHttpConnection(LPCTSTR pstrServer, DWORD dwFlags,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL);

	CGopherConnection* GetGopherConnection(LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

	BOOL EnableStatusCallback(BOOL bEnable = TRUE);

// Operations

	DWORD_PTR GetContext() const;
	operator HINTERNET() const;
	virtual void Close();

	// cookies
	static BOOL SetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, LPCTSTR pstrCookieData);
	static BOOL GetCookie(__in_z LPCTSTR pstrUrl, __in_z LPCTSTR pstrCookieName, __out_ecount_z(dwBufLen) LPTSTR pstrCookieData, __in DWORD dwBufLen);
	static DWORD GetCookieLength(LPCTSTR pstrUrl, LPCTSTR pstrCookieName);
	static BOOL GetCookie(LPCTSTR pstrUrl, LPCTSTR pstrCookieName, CString& strCookieData);

// Overridables
	virtual void OnStatusCallback(DWORD_PTR dwContext, DWORD dwInternetStatus,
		LPVOID lpvStatusInformation, DWORD dwStatusInformationLength);

// Implementation
	DECLARE_DYNAMIC(CInternetSession)
	~CInternetSession();

protected:
	DWORD_PTR m_dwContext;
	HINTERNET m_hSession;
	INTERNET_STATUS_CALLBACK m_pOldCallback;
	BOOL m_bCallbackEnabled;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};


////////////////////////////////////////////////////////////////////////////
// Internet File Access Wrapper

class CInternetFile : public CStdioFile
{
// Constructors
protected:
	CInternetFile(HINTERNET hFile, LPCTSTR pstrFileName,
		CInternetConnection* pConnection, BOOL bReadMode);
	CInternetFile(HINTERNET hFile, HINTERNET hSession,
		LPCTSTR pstrFileName, LPCTSTR pstrServer, DWORD_PTR dwContext,
		BOOL bReadMode);

// Attributes
protected:
	HINTERNET m_hFile;
public:
	operator HINTERNET() const;
	DWORD_PTR GetContext() const;

// Operations
	BOOL SetWriteBufferSize(UINT nWriteSize);
	BOOL SetReadBufferSize(UINT nReadSize);

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;
	BOOL QueryOption(DWORD dwOption, CString& refString) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

// Overridables
	virtual ULONGLONG Seek(LONGLONG lOffset, UINT nFrom);

	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);

	virtual void Abort();
	virtual void Flush();

	virtual void Close();
	virtual ULONGLONG GetLength() const;

	virtual BOOL ReadString(CString& rString);
	virtual LPTSTR ReadString(__out_ecount_z(nMax) LPTSTR pstr, __in UINT nMax);
	virtual void WriteString(LPCTSTR pstr);

	// Not supported by CInternetFile
	void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	CFile* Duplicate() const;
	virtual void SetLength(ULONGLONG dwNewLen);

// Implementation
public:
	virtual ~CInternetFile();

protected:
	BOOL m_bReadMode;
	DWORD_PTR m_dwContext;
	HINTERNET m_hConnection;

	CString m_strServerName;

	UINT m_nWriteBufferSize;
	UINT m_nWriteBufferPos;
	LPBYTE m_pbWriteBuffer;

	UINT m_nReadBufferSize;
	UINT m_nReadBufferPos;
	LPBYTE m_pbReadBuffer;
	UINT m_nReadBufferBytes;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CInternetSession;
	friend class CFtpConnection;
	friend class CHttpConnection;
	friend class CGopherConnection;
	DECLARE_DYNAMIC(CInternetFile)
};


class CHttpFile : public CInternetFile
{
// Constructors
protected:
	CHttpFile(HINTERNET hFile, HINTERNET hSession, LPCTSTR pstrObject,
		LPCTSTR pstrServer, LPCTSTR pstrVerb, DWORD_PTR dwContext);
	CHttpFile(HINTERNET hFile, LPCTSTR pstrVerb, LPCTSTR pstrObject,
		CHttpConnection* pConnection);

// Operations
public:
	BOOL AddRequestHeaders(LPCTSTR pstrHeaders,
		DWORD dwFlags = HTTP_ADDREQ_FLAG_ADD_IF_NEW, int dwHeadersLen = -1);
	BOOL AddRequestHeaders(CString& str,
		DWORD dwFlags = HTTP_ADDREQ_FLAG_ADD_IF_NEW);

	BOOL SendRequest(LPCTSTR pstrHeaders = NULL, DWORD dwHeadersLen = 0,
		LPVOID lpOptional = NULL, DWORD dwOptionalLen = 0);
	BOOL SendRequest(CString& strHeaders,
		LPVOID lpOptional = NULL, DWORD dwOptionalLen = 0);
	BOOL SendRequestEx(DWORD dwTotalLen,
		DWORD dwFlags = HSR_INITIATE,	DWORD_PTR dwContext = 1);
	BOOL SendRequestEx(LPINTERNET_BUFFERS lpBuffIn,
		LPINTERNET_BUFFERS lpBuffOut, DWORD dwFlags = HSR_INITIATE,
		DWORD_PTR dwContext = 1);
	BOOL EndRequest(DWORD dwFlags = 0,
		LPINTERNET_BUFFERS lpBuffIn = NULL, DWORD_PTR dwContext = 1);
	BOOL QueryInfo(DWORD dwInfoLevel, LPVOID lpvBuffer,
		LPDWORD lpdwBufferLength, LPDWORD lpdwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, CString& str,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, SYSTEMTIME* pSysTime,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfo(DWORD dwInfoLevel, DWORD& dwResult,
		LPDWORD dwIndex = NULL) const;
	BOOL QueryInfoStatusCode(DWORD& dwStatusCode) const;

	DWORD ErrorDlg(CWnd* pParent = NULL,
		DWORD dwError = ERROR_INTERNET_INCORRECT_PASSWORD,
		DWORD dwFlags = FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
		LPVOID* lppvData = NULL);

// Attributes
public:
	CString GetVerb() const;

#pragma push_macro("GetObject")
#undef GetObject
	CString _AFX_FUNCNAME(GetObject)() const;
	CString GetObject() const;
#pragma pop_macro("GetObject")

	virtual CString GetFileURL() const;

// Implementation
public:
	virtual ~CHttpFile();
protected:
	CString m_strObject;
	CString m_strVerb;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CHttpConnection;
	friend class CInternetSession;
	DECLARE_DYNAMIC(CHttpFile)
};

// class CGopherFile is declared after CGopherLocator, below


////////////////////////////////////////////////////////////////////////////
// Connection types

class CInternetConnection : public CObject
{
public:
	CInternetConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		DWORD_PTR dwContext = 1);

// Operations
	operator HINTERNET() const;
	DWORD_PTR GetContext() const;
	CInternetSession* GetSession() const;

	CString GetServerName() const;

	BOOL QueryOption(DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufLen) const;
	BOOL QueryOption(DWORD dwOption, DWORD& dwValue) const;
	BOOL QueryOption(DWORD dwOption, CString& refString) const;

	BOOL SetOption(DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength,
			DWORD dwFlags = 0);
	BOOL SetOption(DWORD dwOption, DWORD dwValue, DWORD dwFlags = 0);

	virtual void Close();

// Implementation
protected:
	HINTERNET m_hConnection;
	DWORD_PTR m_dwContext;
	CInternetSession* m_pSession;

	CString m_strServerName;
	INTERNET_PORT m_nPort;

public:
	~CInternetConnection();
	DECLARE_DYNAMIC(CInternetConnection)

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	void AssertValid() const;
#endif
};

class CFtpConnection : public CInternetConnection
{
public:
	enum CmdResponseType
	{
		CmdRespNone = 0,
		CmdRespRead,
		CmdRespWrite
	};

public:
	CFtpConnection(CInternetSession* pSession, HINTERNET hConnected,
		LPCTSTR pstrServer, DWORD_PTR dwContext);
	CFtpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 0,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		BOOL bPassive = FALSE);

#pragma push_macro("SetCurrentDirectory")
#undef SetCurrentDirectory
	BOOL _AFX_FUNCNAME(SetCurrentDirectory)(LPCTSTR pstrDirName);
	BOOL SetCurrentDirectory(LPCTSTR pstrDirName);
#pragma pop_macro("SetCurrentDirectory")

	BOOL GetCurrentDirectory(CString& strDirName) const;
	BOOL GetCurrentDirectory(__out_ecount_part_z(*lpdwLen, *lpdwLen) LPTSTR pstrDirName, __inout LPDWORD lpdwLen) const;
	BOOL GetCurrentDirectoryAsURL(__out_ecount_part_z(*lpdwLen, *lpdwLen) LPTSTR pstrName, __inout LPDWORD lpdwLen) const;
	BOOL GetCurrentDirectoryAsURL(CString& strDirName) const;

	BOOL RemoveDirectory(LPCTSTR pstrDirName);
#pragma push_macro("CreateDirectory")
#undef CreateDirectory
	BOOL _AFX_FUNCNAME(CreateDirectory)(LPCTSTR pstrDirName);
	BOOL CreateDirectory(LPCTSTR pstrDirName);
#pragma pop_macro("CreateDirectory")
	BOOL Rename(LPCTSTR pstrExisting, LPCTSTR pstrNew);
	BOOL Remove(LPCTSTR pstrFileName);

	BOOL PutFile(LPCTSTR pstrLocalFile, LPCTSTR pstrRemoteFile,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

	BOOL GetFile(LPCTSTR pstrRemoteFile, LPCTSTR pstrLocalFile,
		BOOL bFailIfExists = TRUE,
		DWORD dwAttributes = FILE_ATTRIBUTE_NORMAL,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

	CInternetFile* OpenFile(LPCTSTR pstrFileName,
		DWORD dwAccess = GENERIC_READ,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY, DWORD_PTR dwContext = 1);

#if _WIN32_IE >= 0x0500
	CInternetFile* Command(LPCTSTR pszCommand, CmdResponseType eResponse = CmdRespNone,
		DWORD dwFlags = FTP_TRANSFER_TYPE_BINARY,
		DWORD_PTR dwContext = 1);
#endif

// Implementation
	~CFtpConnection();

protected:
	CString m_strServerName;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFtpConnection)
};

class CHttpConnection : public CInternetConnection
{
public:
	enum {
		_HTTP_VERB_MIN      = 0,
		HTTP_VERB_POST      = 0,
		HTTP_VERB_GET       = 1,
		HTTP_VERB_HEAD      = 2,
		HTTP_VERB_PUT       = 3,
		HTTP_VERB_LINK      = 4,
		HTTP_VERB_DELETE    = 5,
		HTTP_VERB_UNLINK    = 6,
		_HTTP_VERB_MAX      = 6,
	};

public:
	CHttpConnection(CInternetSession* pSession, HINTERNET hConnected,
		LPCTSTR pstrServer, DWORD_PTR dwContext);
	CHttpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 1);
	CHttpConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		DWORD dwFlags, INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 1);

	CHttpFile* OpenRequest(LPCTSTR pstrVerb,    LPCTSTR pstrObjectName,
		LPCTSTR pstrReferer = NULL,DWORD_PTR dwContext = 1,
		LPCTSTR* ppstrAcceptTypes = NULL, LPCTSTR pstrVersion = NULL,
		DWORD dwFlags = INTERNET_FLAG_EXISTING_CONNECT);

	CHttpFile* OpenRequest(int nVerb, LPCTSTR pstrObjectName,
		LPCTSTR pstrReferer = NULL, DWORD_PTR dwContext = 1,
		LPCTSTR* ppstrAcceptTypes = NULL, LPCTSTR pstrVersion = NULL,
		DWORD dwFlags = INTERNET_FLAG_EXISTING_CONNECT);

// Implementation
	~CHttpConnection();

protected:
	CString m_strServerName;
	static const LPCTSTR szHtmlVerbs[];

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	friend class CInternetSession;  // just to access szHtmlVerbs
	DECLARE_DYNAMIC(CHttpConnection)
};

class CGopherConnection : public CInternetConnection
{
public:
	CGopherConnection(CInternetSession* pSession,
		HINTERNET hConnected, LPCTSTR pstrServer, DWORD_PTR dwContext);

	CGopherConnection(CInternetSession* pSession, LPCTSTR pstrServer,
		LPCTSTR pstrUserName = NULL, LPCTSTR pstrPassword = NULL,
		DWORD_PTR dwContext = 0,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

	CGopherFile* OpenFile(CGopherLocator& refLocator, DWORD dwFlags = 0,
		LPCTSTR pstrView = NULL, DWORD_PTR dwContext = 1);

	CGopherLocator CreateLocator(LPCTSTR pstrDisplayString,
		LPCTSTR pstrSelectorString, DWORD dwGopherType);

	BOOL CGopherConnection::GetAttribute(CGopherLocator& refLocator,
		CString strRequestedAttributes, CString& strResult);

	static CGopherLocator CreateLocator(LPCTSTR pstrLocator);
	static CGopherLocator CreateLocator(LPCTSTR pstrServerName,
		LPCTSTR pstrDisplayString,
		LPCTSTR pstrSelectorString, DWORD dwGopherType,
		INTERNET_PORT nPort = INTERNET_INVALID_PORT_NUMBER);

// Implementation
	~CGopherConnection();

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	DECLARE_DYNAMIC(CGopherConnection)
};


/////////////////////////////////////////////////////////////////////////////
// CFtpFileFind

class CFtpFileFind : public CFileFind
{
public:
	explicit CFtpFileFind(CFtpConnection* pConnection, DWORD_PTR dwContext = 1);
	virtual ~CFtpFileFind();

	virtual BOOL FindFile(LPCTSTR pstrName = NULL,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindNextFile();
	CString GetFileURL() const;

// Implementation
protected:
	virtual void CloseContext();
	CFtpConnection* m_pConnection;
	DWORD_PTR m_dwContext;

public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

	DECLARE_DYNAMIC(CFtpFileFind)
};


/////////////////////////////////////////////////////////////////////////////
// CGopherLocator

class CGopherLocator : public CObject
{
public:
	~CGopherLocator();
	operator LPCTSTR() const;
	CGopherLocator(const CGopherLocator& ref);
	BOOL GetLocatorType(DWORD& dwRef) const;

private:
	// this only created by CGopherConnection::CreateLocator or by serialization
	CGopherLocator(LPCTSTR pstrLocator, DWORD dwLocLen);

	CString m_Locator;  // _not_ a zero-terminated string!
	DWORD m_dwBufferLength;

	friend class CGopherConnection;
	friend class CGopherFile;
};


/////////////////////////////////////////////////////////////////////////////
// CGopherFile

class CGopherFile : public CInternetFile
{
// Constructors
protected:
	CGopherFile(HINTERNET hFile, CGopherLocator& refLocator,
		CGopherConnection* pConnection);
	CGopherFile(HINTERNET hFile, HINTERNET hSession,
		LPCTSTR pstrLocator, DWORD dwLocLen, DWORD_PTR dwContext);

// Operations
public:
	virtual void Write(const void* lpBuf, UINT nCount);
	void WriteString(LPCTSTR pstr);

// Implementation
protected:
	CGopherLocator m_Locator;
public:
	virtual ~CGopherFile();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class CInternetSession;
	friend class CGopherConnection;
	DECLARE_DYNAMIC(CGopherFile)
};


/////////////////////////////////////////////////////////////////////////////
// CGopherFileFind

class CGopherFileFind : public CFileFind
{
public:
	explicit CGopherFileFind(CGopherConnection* pConnection, DWORD_PTR dwContext = 1);
	virtual ~CGopherFileFind();

	virtual BOOL FindFile(CGopherLocator& refLocator, LPCTSTR pstrString,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindFile(LPCTSTR pstrString,
		DWORD dwFlags = INTERNET_FLAG_RELOAD);
	virtual BOOL FindNextFile();

	virtual BOOL IsDots() const;

	virtual BOOL GetLastWriteTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastAccessTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetCreationTime(FILETIME* pTimeStamp) const;
	virtual BOOL GetLastWriteTime(CTime& refTime) const;
	virtual BOOL GetLastAccessTime(CTime& refTime) const;
	virtual BOOL GetCreationTime(CTime& refTime) const;

	CGopherLocator GetLocator() const;
	CString GetScreenName() const;

	virtual ULONGLONG GetLength() const;

protected:
	virtual void CloseContext();
	CGopherConnection* m_pConnection;
	DWORD_PTR m_dwContext;

// Implementation
public:
	// Unsupported APIs
	CString GetFileName() const;
	CString GetFilePath() const;
	CString GetFileTitle() const;
	CString GetFileURL() const;
	CString GetRoot() const;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	DECLARE_DYNAMIC(CGopherFileFind)
};


///////////////////////////////////////////////////////////////////////
// CInternetException

class CInternetException : public CException
{
public:
// Constructor
	CInternetException(DWORD dwError);

// Attributes
	DWORD m_dwError;
	DWORD_PTR m_dwContext;

// Implementation
public:
	~CInternetException();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL GetErrorMessage(__out_ecount_z(nMaxError) LPTSTR lpstrError, __in UINT nMaxError,
		__out_opt PUINT pnHelpContext = NULL) const;
	DECLARE_DYNAMIC(CInternetException)
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXINET_INLINE AFX_INLINE
#include <afxinet.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#ifndef _AFX_DISABLE_DEPRECATED
#pragma deprecated( CGopherLocator )
#pragma deprecated( CGopherFile )
#pragma deprecated( CGopherConnection )
#pragma deprecated( CGopherFileFind )
#endif

#endif // __AFXINET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxmt.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXMT.H

#pragma once

#ifdef _AFXMT_INLINE

_AFXMT_INLINE CSyncObject::operator HANDLE() const
	{ return m_hObject;}

_AFXMT_INLINE BOOL CSemaphore::Unlock()
	{ return Unlock(1, NULL); }

_AFXMT_INLINE BOOL CEvent::SetEvent()
	{ ASSERT(m_hObject != NULL); return ::SetEvent(m_hObject); }
_AFXMT_INLINE BOOL CEvent::PulseEvent()
	{ ASSERT(m_hObject != NULL); return ::PulseEvent(m_hObject); }
_AFXMT_INLINE BOOL CEvent::ResetEvent()
	{ ASSERT(m_hObject != NULL); return ::ResetEvent(m_hObject); }

_AFXMT_INLINE CSingleLock::~CSingleLock()
	{ Unlock(); }
_AFXMT_INLINE BOOL CSingleLock::IsLocked()
	{ return m_bAcquired; }

_AFXMT_INLINE BOOL CMultiLock::IsLocked(DWORD dwObject)
	{ ASSERT(dwObject < m_dwCount);
		 return m_bLockedArray[dwObject]; }

_AFXMT_INLINE BOOL CCriticalSection::Init()
{
	__try
	{
		::InitializeCriticalSection(&m_sect);
	}
	__except(STATUS_NO_MEMORY == GetExceptionCode())
	{
		return FALSE;
	}

	return TRUE;
}

_AFXMT_INLINE CCriticalSection::CCriticalSection() : CSyncObject(NULL)
	{ 	
		BOOL bSuccess;

		bSuccess = Init();
		if (!bSuccess)
			AfxThrowMemoryException();
	}

_AFXMT_INLINE CCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }
_AFXMT_INLINE CCriticalSection::~CCriticalSection()
	{ ::DeleteCriticalSection(&m_sect); }
_AFXMT_INLINE BOOL CCriticalSection::Lock()
	{	
		__try
		{
			::EnterCriticalSection(&m_sect); 
		}
		__except(STATUS_NO_MEMORY == GetExceptionCode())
		{
			AfxThrowMemoryException();
		}
		return TRUE; 
	}
_AFXMT_INLINE BOOL CCriticalSection::Lock(DWORD dwTimeout)
	{ ASSERT(dwTimeout == INFINITE); (void)dwTimeout; return Lock(); }
_AFXMT_INLINE BOOL CCriticalSection::Unlock()
	{ ::LeaveCriticalSection(&m_sect); return TRUE; }

#endif //_AFXMT_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxmsg_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)

#pragma once

/////////////////////////////////////////////////////////////////////////////

// Entries in a message map (a 'AFX_MSGMAP_ENTRY') table can be of 9 formats
//
// 1) control notification message (i.e. in response to WM_COMMAND)
//      WM_COMMAND, nNotifyCode, nControlID, nControlID, signature type, parameterless member function
//      (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )
// 2) control notification message range (i.e. in response to WM_COMMAND)
//      WM_COMMAND, nNotifyCode, nControlIDFirst, nControlIDLast, signature type, parameterless member function
//      (eg: WM_COMMAND, LBN_SELCHANGE, IDC_LISTBOX1, IDC_LISTBOX5, AfxSig_vw, ... )
// 3) WM_NOTIFY notification
//      WM_NOTIFY, nNotifyCode, nControlID, nControlID, signature type, ...)
// 3) Update Command UI
//      -1, 0, nControlID, 0, signature Unknown, parameterless member function
// 4) Update Command UI Range
//      -1, 0, nControlIDFirst, nControlIDLast, signature Unknown, parameterless member function
// 5) menu/accelerator notification message (i.e. special case of first format)
//      WM_COMMAND, 0, nID, 0, signature type, parameterless member function
//      (eg: WM_COMMAND, 0, IDM_FILESAVE, 0, AfxSig_vv, ... )
// 6) menu/accelerator notification message range
//      WM_COMMAND, 0, nIDFirst, nIDLast, signature type, parameterless member function
//      (eg: WM_COMMAND, 0, IDM_FILE_MRU1, IDM_FILE_MRU4, AfxSig_vw, ... )
// 7) constant windows message
//      nMessage, 0, 0, 0, signature type, member function
//      (eg: WM_PAINT, 0, ...)
// 8) variable windows message (using RegisterWindowMessage)
//      0xC000, 0, 0, 0, &nMessage, special member function
//
// The end of the message map is marked with a special value
//      0, 0, AfxSig_end, 0
/////////////////////////////////////////////////////////////////////////////

// Naming scheme:
// <signature> -> AfxSig_<ReturnType>_<WPARAMType>_<LPARAMType>
// <ReturnType> -> b (BOOL)
//                 h (HANDLE)
//                 v (void)
//                 i (int)
//                 l (LRESULT)
// <WPARAMType> ->                  
// Naming scheme:
// b - BOOL
// D - CDC*
// W - CWnd*
// w - UINT
// h - handle
// i - int
// s - LPTSTR
// v - void
// l - LPARAM
// M - CMenu*
// p - CPoint
// POS - WINDOWPOS*
// CALC - NCCALCSIZE_PARAMS*
// NMHDR - NMHDR*
// HELPINFO - HELPINFO*
// SIZING - LPRECT
// cmdui - CCmdUI*
// CDS - COPYDATASTRUCT*
// s - short

enum AfxSig
{
	AfxSig_end = 0,     // [marks end of message map]

	AfxSig_b_D_v,				// BOOL (CDC*)
	AfxSig_b_b_v,				// BOOL (BOOL)
	AfxSig_b_u_v,				// BOOL (UINT)
	AfxSig_b_h_v,				// BOOL (HANDLE)
	AfxSig_b_W_uu,				// BOOL (CWnd*, UINT, UINT)
	AfxSig_b_W_COPYDATASTRUCT,				// BOOL (CWnd*, COPYDATASTRUCT*)
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	AfxSig_b_v_HELPINFO,		// BOOL (LPHELPINFO);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	AfxSig_CTLCOLOR,			// HBRUSH (CDC*, CWnd*, UINT)
	AfxSig_CTLCOLOR_REFLECT,	// HBRUSH (CDC*, UINT)
	AfxSig_i_u_W_u,				// int (UINT, CWnd*, UINT)  // ?TOITEM
	AfxSig_i_uu_v,				// int (UINT, UINT)
	AfxSig_i_W_uu,				// int (CWnd*, UINT, UINT)
	AfxSig_i_v_s,				// int (LPTSTR)
	AfxSig_l_w_l,				// LRESULT (WPARAM, LPARAM)
	AfxSig_l_uu_M,				// LRESULT (UINT, UINT, CMenu*)
	AfxSig_v_b_h,				// void (BOOL, HANDLE)
	AfxSig_v_h_v,				// void (HANDLE)
	AfxSig_v_h_h,				// void (HANDLE, HANDLE)
	AfxSig_v_v_v,				// void ()
	AfxSig_v_u_v,				// void (UINT)
	AfxSig_v_u_u,				// void (UINT, UINT)
	AfxSig_v_uu_v,				// void (UINT, UINT)
	AfxSig_v_v_ii,				// void (int, int)
	AfxSig_v_u_uu,				// void (UINT, UINT, UINT)
	AfxSig_v_u_ii,				// void (UINT, int, int)
	AfxSig_v_u_W,				// void (UINT, CWnd*)
	AfxSig_i_u_v,				// int (UINT)
	AfxSig_u_u_v,				// UINT (UINT)
	AfxSig_b_v_v,				// BOOL ()
	AfxSig_v_w_l,				// void (WPARAM, LPARAM)
#ifndef _WIN32_WCE
	AfxSig_MDIACTIVATE,			// void (BOOL, CWnd*, CWnd*)
#endif // !_WIN32_WCE
	AfxSig_v_D_v,				// void (CDC*)
	AfxSig_v_M_v,				// void (CMenu*)
	AfxSig_v_M_ub,				// void (CMenu*, UINT, BOOL)
	AfxSig_v_W_v,				// void (CWnd*)
	AfxSig_v_v_W,				// void (CWnd*)
	AfxSig_v_W_uu,				// void (CWnd*, UINT, UINT)
	AfxSig_v_W_p,				// void (CWnd*, CPoint)
	AfxSig_v_W_h,				// void (CWnd*, HANDLE)
	AfxSig_C_v_v,				// HCURSOR ()
	AfxSig_ACTIVATE,			// void (UINT, CWnd*, BOOL)
	AfxSig_SCROLL,				// void (UINT, UINT, CWnd*)
	AfxSig_SCROLL_REFLECT,		// void (UINT, UINT)
	AfxSig_v_v_s,				// void (LPTSTR)
	AfxSig_v_u_cs,				// void (UINT, LPCTSTR)
	AfxSig_OWNERDRAW,			// void (int, LPTSTR) force return TRUE
	AfxSig_i_i_s,				// int (int, LPTSTR)
	AfxSig_u_v_p,				// UINT (CPoint)
	AfxSig_u_v_v,				// UINT ()
#ifndef _WIN32_WCE
	AfxSig_v_b_NCCALCSIZEPARAMS,	// void (BOOL, NCCALCSIZE_PARAMS*)
#endif // !_WIN32_WCE
	AfxSig_v_v_WINDOWPOS,		// void (WINDOWPOS*)
	AfxSig_v_uu_M,				// void (UINT, UINT, HMENU)
	AfxSig_v_u_p,				// void (UINT, CPoint)
#ifndef _WIN32_WCE
	AfxSig_SIZING,				// void (UINT, LPRECT)
#endif // !_WIN32_WCE
	AfxSig_MOUSEWHEEL,			// BOOL (UINT, short, CPoint)
	AfxSigCmd_v,				// void ()
	AfxSigCmd_b,				// BOOL ()
	AfxSigCmd_RANGE,			// void (UINT)
	AfxSigCmd_EX,				// BOOL (UINT)
	AfxSigNotify_v,				// void (NMHDR*, LRESULT*)
	AfxSigNotify_b,				// BOOL (NMHDR*, LRESULT*)
	AfxSigNotify_RANGE,			// void (UINT, NMHDR*, LRESULT*)
	AfxSigNotify_EX,			// BOOL (UINT, NMHDR*, LRESULT*)
	AfxSigCmdUI,				// void (CCmdUI*)
	AfxSigCmdUI_RANGE,			// void (CCmdUI*, UINT)
	AfxSigCmd_v_pv,				// void (void*)
	AfxSigCmd_b_pv,				// BOOL (void*)
	AfxSig_l,					// LRESULT ()
	AfxSig_l_p,					// LRESULT (CPOINT)	
// Old
	AfxSig_bD = AfxSig_b_D_v,      // BOOL (CDC*)
	AfxSig_bb = AfxSig_b_b_v,      // BOOL (BOOL)
	AfxSig_bWww = AfxSig_b_W_uu,    // BOOL (CWnd*, UINT, UINT)
	AfxSig_hDWw = AfxSig_CTLCOLOR,    // HBRUSH (CDC*, CWnd*, UINT)
	AfxSig_hDw = AfxSig_CTLCOLOR_REFLECT,     // HBRUSH (CDC*, UINT)
	AfxSig_iwWw = AfxSig_i_u_W_u,    // int (UINT, CWnd*, UINT)
	AfxSig_iww = AfxSig_i_uu_v,     // int (UINT, UINT)
	AfxSig_iWww = AfxSig_i_W_uu,    // int (CWnd*, UINT, UINT)
	AfxSig_is = AfxSig_i_v_s,      // int (LPTSTR)
	AfxSig_lwl = AfxSig_l_w_l,     // LRESULT (WPARAM, LPARAM)
	AfxSig_lwwM = AfxSig_l_uu_M,    // LRESULT (UINT, UINT, CMenu*)
	AfxSig_vv = AfxSig_v_v_v,      // void (void)

	AfxSig_vw = AfxSig_v_u_v,      // void (UINT)
	AfxSig_vww = AfxSig_v_u_u,     // void (UINT, UINT)
	AfxSig_vww2 = AfxSig_v_uu_v,    // void (UINT, UINT) // both come from wParam
	AfxSig_vvii = AfxSig_v_v_ii,    // void (int, int) // wParam is ignored
	AfxSig_vwww = AfxSig_v_u_uu,    // void (UINT, UINT, UINT)
	AfxSig_vwii = AfxSig_v_u_ii,    // void (UINT, int, int)
	AfxSig_vwl = AfxSig_v_w_l,     // void (UINT, LPARAM)
#ifndef _WIN32_WCE
	AfxSig_vbWW = AfxSig_MDIACTIVATE,    // void (BOOL, CWnd*, CWnd*)
#endif // !_WIN32_WCE
	AfxSig_vD = AfxSig_v_D_v,      // void (CDC*)
	AfxSig_vM = AfxSig_v_M_v,      // void (CMenu*)
	AfxSig_vMwb = AfxSig_v_M_ub,    // void (CMenu*, UINT, BOOL)

	AfxSig_vW = AfxSig_v_W_v,      // void (CWnd*)
	AfxSig_vWww = AfxSig_v_W_uu,    // void (CWnd*, UINT, UINT)
	AfxSig_vWp = AfxSig_v_W_p,     // void (CWnd*, CPoint)
	AfxSig_vWh = AfxSig_v_W_h,     // void (CWnd*, HANDLE)
	AfxSig_vwW = AfxSig_v_u_W,     // void (UINT, CWnd*)
	AfxSig_vwWb = AfxSig_ACTIVATE,    // void (UINT, CWnd*, BOOL)
	AfxSig_vwwW = AfxSig_SCROLL,    // void (UINT, UINT, CWnd*)
	AfxSig_vwwx = AfxSig_SCROLL_REFLECT,    // void (UINT, UINT)
	AfxSig_vs = AfxSig_v_v_s,      // void (LPTSTR)
	AfxSig_vOWNER = AfxSig_OWNERDRAW,  // void (int, LPTSTR), force return TRUE
	AfxSig_iis = AfxSig_i_i_s,     // int (int, LPTSTR)
	AfxSig_wp = AfxSig_u_v_p,      // UINT (CPoint)
	AfxSig_wv = AfxSig_u_v_v,      // UINT (void)
	AfxSig_vPOS = AfxSig_v_v_WINDOWPOS,    // void (WINDOWPOS*)
#ifndef _WIN32_WCE
	AfxSig_vCALC = AfxSig_v_b_NCCALCSIZEPARAMS,   // void (BOOL, NCCALCSIZE_PARAMS*)
#endif // !_WIN32_WCE
	AfxSig_vNMHDRpl = AfxSigNotify_v,    // void (NMHDR*, LRESULT*)
	AfxSig_bNMHDRpl = AfxSigNotify_b,    // BOOL (NMHDR*, LRESULT*)
	AfxSig_vwNMHDRpl = AfxSigNotify_RANGE,   // void (UINT, NMHDR*, LRESULT*)
	AfxSig_bwNMHDRpl = AfxSigNotify_EX,   // BOOL (UINT, NMHDR*, LRESULT*)
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	AfxSig_bHELPINFO = AfxSig_b_v_HELPINFO,   // BOOL (HELPINFO*)
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
#ifndef _WIN32_WCE
	AfxSig_vwSIZING = AfxSig_SIZING,    // void (UINT, LPRECT) -- return TRUE
#endif // !_WIN32_WCE

	// signatures specific to CCmdTarget
	AfxSig_cmdui = AfxSigCmdUI,   // void (CCmdUI*)
	AfxSig_cmduiw = AfxSigCmdUI_RANGE,  // void (CCmdUI*, UINT)
	AfxSig_vpv = AfxSigCmd_v_pv,     // void (void*)
	AfxSig_bpv = AfxSigCmd_b_pv,     // BOOL (void*)

	// Other aliases (based on implementation)
	AfxSig_vwwh = AfxSig_v_uu_M,                // void (UINT, UINT, HMENU)
	AfxSig_vwp = AfxSig_v_u_p,                 // void (UINT, CPoint)
	AfxSig_bw = AfxSig_b_u_v,      // BOOL (UINT)
	AfxSig_bh = AfxSig_b_h_v,      // BOOL (HANDLE)
	AfxSig_iw = AfxSig_i_u_v,      // int (UINT)
	AfxSig_ww = AfxSig_u_u_v,      // UINT (UINT)
	AfxSig_bv = AfxSig_b_v_v,      // BOOL (void)
	AfxSig_hv = AfxSig_C_v_v,      // HANDLE (void)
	AfxSig_vb = AfxSig_vw,      // void (BOOL)
	AfxSig_vbh = AfxSig_v_b_h,    // void (BOOL, HANDLE)
	AfxSig_vbw = AfxSig_vww,    // void (BOOL, UINT)
	AfxSig_vhh = AfxSig_v_h_h,    // void (HANDLE, HANDLE)
	AfxSig_vh = AfxSig_v_h_v,      // void (HANDLE)
	AfxSig_viSS = AfxSig_vwl,   // void (int, STYLESTRUCT*)
	AfxSig_bwl = AfxSig_lwl,
#ifndef _WIN32_WCE
	AfxSig_vwMOVING = AfxSig_vwSIZING,  // void (UINT, LPRECT) -- return TRUE
#endif // !_WIN32_WCE

	AfxSig_vW2 = AfxSig_v_v_W,                 // void (CWnd*) (CWnd* comes from lParam)
	AfxSig_bWCDS = AfxSig_b_W_COPYDATASTRUCT,               // BOOL (CWnd*, COPYDATASTRUCT*)
	AfxSig_bwsp = AfxSig_MOUSEWHEEL,                // BOOL (UINT, short, CPoint)
	AfxSig_vws = AfxSig_v_u_cs,
};

/////////////////////////////////////////////////////////////////////////////
// Command notifications for CCmdTarget notifications

#define CN_COMMAND              0               // void ()
#define CN_UPDATE_COMMAND_UI    ((UINT)(-1))    // void (CCmdUI*)
#define CN_EVENT                ((UINT)(-2))    // OLE event
#define CN_OLECOMMAND           ((UINT)(-3))    // OLE document command
#define CN_OLE_UNREGISTER       ((UINT)(-4))    // OLE unregister
// > 0 are control notifications
// < 0 are for MFC's use

#define ON_COMMAND(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_v, \
		static_cast<AFX_PMSG> (memberFxn) },
		// ON_COMMAND(id, OnBar) is the same as
		//   ON_CONTROL(0, id, OnBar) or ON_BN_CLICKED(0, id, OnBar)

#define ON_COMMAND_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSigCmd_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },
		// ON_COMMAND_RANGE(id, idLast, OnBar) is the same as
		//   ON_CONTROL_RANGE(0, id, idLast, OnBar)

#define ON_COMMAND_EX(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },

#define ON_COMMAND_EX_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)idLast, AfxSigCmd_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT) > \
		(memberFxn)) },

// update ui's are listed as WM_COMMAND's so they get routed like commands
#define ON_UPDATE_COMMAND_UI(id, memberFxn) \
	{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)id, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

#define ON_UPDATE_COMMAND_UI_RANGE(id, idLast, memberFxn) \
	{ WM_COMMAND, CN_UPDATE_COMMAND_UI, (WORD)id, (WORD)idLast, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

#ifndef _WIN32_WCE
#define ON_NOTIFY(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_v, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },
#else
#define ON_NOTIFY(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_v, \
		(AFX_PMSG) \
		(void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*))memberFxn },
#endif // !_WIN32_WCE

#define ON_NOTIFY_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigNotify_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_EX(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_NOTIFY_EX_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigNotify_EX, \
		(AFX_PMSG) \
		(static_cast< BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT, NMHDR*, LRESULT*) > \
		(memberFxn)) },

// for general controls
#define ON_CONTROL(wNotifyCode, id, memberFxn) \
	{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)id, AfxSigCmd_v, \
		(static_cast< AFX_PMSG > (memberFxn)) },

#define ON_CONTROL_RANGE(wNotifyCode, id, idLast, memberFxn) \
	{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)idLast, AfxSigCmd_RANGE, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(UINT) > (memberFxn)) },

#define WM_REFLECT_BASE 0xBC00

// for control notification reflection
#define ON_CONTROL_REFLECT(wNotifyCode, memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSigCmd_v, \
		(static_cast<AFX_PMSG> (memberFxn)) },

#define ON_CONTROL_REFLECT_EX(wNotifyCode, memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSigCmd_b, \
		(AFX_PMSG) \
		(static_cast<BOOL (AFX_MSG_CALL CCmdTarget::*)(void)> (memberFxn)) },

#ifndef _WIN32_WCE
#define ON_NOTIFY_REFLECT(wNotifyCode, memberFxn) \
	{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, AfxSigNotify_v, \
		(AFX_PMSG) \
		(static_cast<void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },
#else
#define ON_NOTIFY_REFLECT(wNotifyCode, memberFxn) \
	{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, AfxSigNotify_v, \
		(AFX_PMSG) \
		(void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*))memberFxn },
#endif // !_WIN32_WCE

#define ON_NOTIFY_REFLECT_EX(wNotifyCode, memberFxn) \
	{ WM_NOTIFY+WM_REFLECT_BASE, (WORD)(int)wNotifyCode, 0, 0, AfxSigNotify_b, \
		(AFX_PMSG) \
		(static_cast<BOOL (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \
		(memberFxn)) },

#define ON_UPDATE_COMMAND_UI_REFLECT(memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)CN_UPDATE_COMMAND_UI, 0, 0, AfxSigCmdUI, \
		(AFX_PMSG) \
		(static_cast<void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*) > \
		(memberFxn)) },

/////////////////////////////////////////////////////////////////////////////
// Message map tables for Windows messages

#define ON_WM_CREATE() \
	{ WM_CREATE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG) (AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT) > ( &ThisClass :: OnCreate)) },

#define ON_WM_COPYDATA() \
	{ WM_COPYDATA, 0, 0, 0, AfxSig_bWCDS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, COPYDATASTRUCT*) > ( &ThisClass :: OnCopyData)) },

#define ON_WM_DESTROY() \
	{ WM_DESTROY, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDestroy)) },

#define ON_WM_MOVE() \
	{ WM_MOVE, 0, 0, 0, AfxSig_vvii, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, int) > ( &ThisClass :: OnMove)) },

#define ON_WM_SIZE() \
	{ WM_SIZE, 0, 0, 0, AfxSig_vwii, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, int, int) > ( &ThisClass :: OnSize)) },

#define ON_WM_ACTIVATE() \
	{ WM_ACTIVATE, 0, 0, 0, AfxSig_vwWb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*, BOOL) > ( &ThisClass :: OnActivate)) },

#define ON_WM_SETFOCUS() \
	{ WM_SETFOCUS, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnSetFocus)) },

#define ON_WM_KILLFOCUS() \
	{ WM_KILLFOCUS, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnKillFocus)) },

#define ON_WM_ENABLE() \
	{ WM_ENABLE, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEnable)) },

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
#define ON_WM_HELPINFO() \
	{ WM_HELP, 0, 0, 0, AfxSig_bHELPINFO, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(HELPINFO*) > ( &ThisClass :: OnHelpInfo)) },
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

#define ON_WM_PAINT() \
	{ WM_PAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnPaint)) },

#define ON_WM_CLOSE() \
	{ WM_CLOSE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnClose)) },

#ifdef _WIN32_WCE
#define ON_WM_HIBERNATE() \
	{ WM_HIBERNATE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnHibernate)) },
#endif // _WIN32_WCE

#ifndef _WIN32_WCE
#define ON_WM_QUERYENDSESSION() \
	{ WM_QUERYENDSESSION, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryEndSession)) },

#define ON_WM_QUERYOPEN() \
	{ WM_QUERYOPEN, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryOpen)) },
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > (OnQueryOpen)) },
#endif // !_WIN32_WCE

#define ON_WM_ERASEBKGND() \
	{ WM_ERASEBKGND, 0, 0, 0, AfxSig_bD, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CDC*) > ( &ThisClass :: OnEraseBkgnd)) },

#define ON_WM_SYSCOLORCHANGE() \
	{ WM_SYSCOLORCHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnSysColorChange)) },

#ifndef _WIN32_WCE
#define ON_WM_ENDSESSION() \
	{ WM_ENDSESSION, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEndSession)) },
#endif // !_WIN32_WCE

#define ON_WM_SHOWWINDOW() \
	{ WM_SHOWWINDOW, 0, 0, 0, AfxSig_vbw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, UINT) > ( &ThisClass :: OnShowWindow)) },

#define ON_WM_CTLCOLOR() \
	{ WM_CTLCOLOR, 0, 0, 0, AfxSig_hDWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, CWnd*, UINT)>  ( &ThisClass :: OnCtlColor)) },

#define ON_WM_CTLCOLOR_REFLECT() \
	{ WM_CTLCOLOR+WM_REFLECT_BASE, 0, 0, 0, AfxSig_hDw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, UINT) > ( &ThisClass :: CtlColor)) },

#define ON_WM_SETTINGCHANGE() \
	{ WM_SETTINGCHANGE, 0, 0, 0, AfxSig_vws, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPCTSTR) > ( &ThisClass :: OnSettingChange)) },

#define ON_WM_WININICHANGE() \
	{ WM_WININICHANGE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPCTSTR) > ( &ThisClass :: OnWinIniChange)) },

#ifndef _AFX_NO_PRINTING_SUPPORT
#define ON_WM_DEVMODECHANGE() \
	{ WM_DEVMODECHANGE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPTSTR) > ( &ThisClass :: OnDevModeChange)) },
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE
#define ON_WM_ACTIVATEAPP() \
	{ WM_ACTIVATEAPP, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, DWORD) > ( &ThisClass :: OnActivateApp)) },
#endif // !_WIN32_WCE

#define ON_WM_FONTCHANGE() \
	{ WM_FONTCHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnFontChange)) },

#ifndef _WIN32_WCE
#define ON_WM_TIMECHANGE() \
	{ WM_TIMECHANGE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnTimeChange)) },
#endif // !_WIN32_WCE

#define ON_WM_CANCELMODE() \
	{ WM_CANCELMODE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnCancelMode)) },

#define ON_WM_SETCURSOR() \
	{ WM_SETCURSOR, 0, 0, 0, AfxSig_bWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnSetCursor)) },

#ifndef _WIN32_WCE
#define ON_WM_MOUSEACTIVATE() \
	{ WM_MOUSEACTIVATE, 0, 0, 0, AfxSig_iWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnMouseActivate)) },

#define ON_WM_CHILDACTIVATE() \
	{ WM_CHILDACTIVATE, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnChildActivate)) },

#define ON_WM_GETMINMAXINFO() \
	{ WM_GETMINMAXINFO, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(MINMAXINFO*) > ( &ThisClass :: OnGetMinMaxInfo)) },

#define ON_WM_ICONERASEBKGND() \
	{ WM_ICONERASEBKGND, 0, 0, 0, AfxSig_vD, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CDC*) > ( &ThisClass :: OnIconEraseBkgnd)) },
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT
#define ON_WM_SPOOLERSTATUS() \
	{ WM_SPOOLERSTATUS, 0, 0, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnSpoolerStatus)) },
#endif // !_AFX_NO_PRINTING_SUPPORT

#define ON_WM_DRAWITEM() \
	{ WM_DRAWITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPDRAWITEMSTRUCT) > ( &ThisClass :: OnDrawItem)) },

#define ON_WM_DRAWITEM_REFLECT() \
	{ WM_DRAWITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPDRAWITEMSTRUCT) > ( &ThisClass :: DrawItem)) },

#define ON_WM_MEASUREITEM() \
	{ WM_MEASUREITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPMEASUREITEMSTRUCT) > ( &ThisClass :: OnMeasureItem)) },

#define ON_WM_MEASUREITEM_REFLECT() \
	{ WM_MEASUREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPMEASUREITEMSTRUCT) > ( &ThisClass :: MeasureItem)) },

#define ON_WM_DELETEITEM() \
	{ WM_DELETEITEM, 0, 0, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPDELETEITEMSTRUCT) > ( &ThisClass :: OnDeleteItem)) },

#define ON_WM_DELETEITEM_REFLECT() \
	{ WM_DELETEITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(LPDELETEITEMSTRUCT) > ( &ThisClass :: DeleteItem)) },

#define ON_WM_CHARTOITEM() \
	{ WM_CHARTOITEM, 0, 0, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT) > ( &ThisClass :: OnCharToItem)) },

#define ON_WM_CHARTOITEM_REFLECT() \
	{ WM_CHARTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: CharToItem)) },

#define ON_WM_VKEYTOITEM() \
	{ WM_VKEYTOITEM, 0, 0, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT) > ( &ThisClass :: OnVKeyToItem)) },

#define ON_WM_VKEYTOITEM_REFLECT() \
	{ WM_VKEYTOITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_iww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: VKeyToItem)) },

#define ON_WM_QUERYDRAGICON() \
	{ WM_QUERYDRAGICON, 0, 0, 0, AfxSig_hv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< HCURSOR (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryDragIcon)) },

#define ON_WM_COMPAREITEM() \
	{ WM_COMPAREITEM, 0, 0, 0, AfxSig_iis, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(int, LPCOMPAREITEMSTRUCT) > ( &ThisClass :: OnCompareItem)) },

#define ON_WM_COMPAREITEM_REFLECT() \
	{ WM_COMPAREITEM+WM_REFLECT_BASE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< int (AFX_MSG_CALL CWnd::*)(LPCOMPAREITEMSTRUCT) > ( &ThisClass :: CompareItem)) },

#ifndef _WIN32_WCE
#define ON_WM_COMPACTING() \
	{ WM_COMPACTING, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT) > ( &ThisClass :: OnCompacting)) },

#define ON_WM_NCCREATE() \
	{ WM_NCCREATE, 0, 0, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT) > ( &ThisClass :: OnNcCreate)) },
#endif // !_WIN32_WCE

#define ON_WM_NCDESTROY() \
	{ WM_NCDESTROY, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnNcDestroy)) },

#ifndef _WIN32_WCE
#define ON_WM_NCCALCSIZE() \
	{ WM_NCCALCSIZE, 0, 0, 0, AfxSig_vCALC, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, NCCALCSIZE_PARAMS*) > ( &ThisClass :: OnNcCalcSize)) },

#define ON_WM_NCHITTEST() \
	{ WM_NCHITTEST, 0, 0, 0, AfxSig_l_p, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(CPoint) > (&ThisClass :: OnNcHitTest)) },

#define ON_WM_NCPAINT() \
	{ WM_NCPAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnNcPaint)) },

#define ON_WM_NCACTIVATE() \
	{ WM_NCACTIVATE, 0, 0, 0, AfxSig_bb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnNcActivate)) },
#endif // !_WIN32_WCE

#define ON_WM_GETDLGCODE() \
	{ WM_GETDLGCODE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnGetDlgCode)) },

#ifndef _WIN32_WCE
#define ON_WM_NCMOUSEMOVE() \
	{ WM_NCMOUSEMOVE, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMouseMove)) },

#define ON_WM_NCLBUTTONDOWN() \
	{ WM_NCLBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonDown)) },

#define ON_WM_NCLBUTTONUP() \
	{ WM_NCLBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonUp)) },

#define ON_WM_NCLBUTTONDBLCLK() \
	{ WM_NCLBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcLButtonDblClk)) },

#define ON_WM_NCRBUTTONDOWN() \
	{ WM_NCRBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonDown)) },

#define ON_WM_NCRBUTTONUP() \
	{ WM_NCRBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonUp)) },

#define ON_WM_NCRBUTTONDBLCLK() \
	{ WM_NCRBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcRButtonDblClk)) },

#define ON_WM_NCMBUTTONDOWN() \
	{ WM_NCMBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonDown)) },

#define ON_WM_NCMBUTTONUP() \
	{ WM_NCMBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonUp)) },

#define ON_WM_NCMBUTTONDBLCLK() \
	{ WM_NCMBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnNcMButtonDblClk)) },
#endif // !_WIN32_WCE

#define ON_WM_KEYDOWN() \
	{ WM_KEYDOWN, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnKeyDown)) },

#define ON_WM_KEYUP() \
	{ WM_KEYUP, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnKeyUp)) },

#define ON_WM_CHAR() \
	{ WM_CHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnChar)) },

#define ON_WM_DEADCHAR() \
	{ WM_DEADCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnDeadChar)) },

#define ON_WM_SYSKEYDOWN() \
	{ WM_SYSKEYDOWN, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysKeyDown)) },

#define ON_WM_SYSKEYUP() \
	{ WM_SYSKEYUP, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysKeyUp)) },

#define ON_WM_SYSCHAR() \
	{ WM_SYSCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast<void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysChar)) },

#define ON_WM_SYSDEADCHAR() \
	{ WM_SYSDEADCHAR, 0, 0, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT) > ( &ThisClass :: OnSysDeadChar)) },

#define ON_WM_SYSCOMMAND() \
	{ WM_SYSCOMMAND, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: OnSysCommand)) },

#ifndef _WIN32_WCE
#define ON_WM_TCARD() \
	{ WM_TCARD, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, DWORD) > ( &ThisClass :: OnTCard)) },
#endif // !_WIN32_WCE

#define ON_WM_TIMER() \
	{ WM_TIMER, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT_PTR) > ( &ThisClass :: OnTimer)) },

#define ON_WM_HSCROLL() \
	{ WM_HSCROLL, 0, 0, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*) > ( &ThisClass :: OnHScroll)) },

#define ON_WM_HSCROLL_REFLECT() \
	{ WM_HSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: HScroll)) },

#define ON_WM_VSCROLL() \
	{ WM_VSCROLL, 0, 0, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*) > ( &ThisClass :: OnVScroll)) },

#define ON_WM_VSCROLL_REFLECT() \
	{ WM_VSCROLL+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwwx, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: VScroll)) },

#ifndef _WIN32_WCE
#define ON_WM_INITMENU() \
	{ WM_INITMENU, 0, 0, 0, AfxSig_vM, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CMenu*) > ( &ThisClass :: OnInitMenu)) },
#endif // !_WIN32_WCE

#define ON_WM_INITMENUPOPUP() \
	{ WM_INITMENUPOPUP, 0, 0, 0, AfxSig_vMwb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CMenu*, UINT, BOOL) > ( &ThisClass :: OnInitMenuPopup)) },

#ifndef _WIN32_WCE
#define ON_WM_MENUSELECT() \
	{ WM_MENUSELECT, 0, 0, 0, AfxSig_vwwh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT, HMENU) > ( &ThisClass :: OnMenuSelect)) },
#endif // !_WIN32_WCE

#define ON_WM_MENUCHAR() \
	{ WM_MENUCHAR, 0, 0, 0, AfxSig_lwwM, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(UINT, UINT, CMenu*) > ( &ThisClass :: OnMenuChar)) },

#ifndef _WIN32_WCE
#define ON_WM_ENTERIDLE() \
	{ WM_ENTERIDLE, 0, 0, 0, AfxSig_vwW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*) > ( &ThisClass :: OnEnterIdle)) },
#endif // !_WIN32_WCE

#define ON_WM_MOUSEMOVE() \
	{ WM_MOUSEMOVE, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMouseMove)) },

#define ON_WM_MOUSEWHEEL() \
	{ WM_MOUSEWHEEL, 0, 0, 0, AfxSig_bwsp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(UINT, short, CPoint) > ( &ThisClass :: OnMouseWheel)) },

#define ON_WM_LBUTTONDOWN() \
	{ WM_LBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonDown)) },

#define ON_WM_LBUTTONUP() \
	{ WM_LBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonUp)) },

#define ON_WM_LBUTTONDBLCLK() \
	{ WM_LBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnLButtonDblClk)) },

#define ON_WM_RBUTTONDOWN() \
	{ WM_RBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonDown)) },

#define ON_WM_RBUTTONUP() \
	{ WM_RBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonUp)) },

#define ON_WM_RBUTTONDBLCLK() \
	{ WM_RBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnRButtonDblClk)) },

#define ON_WM_MBUTTONDOWN() \
	{ WM_MBUTTONDOWN, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonDown)) },

#define ON_WM_MBUTTONUP() \
	{ WM_MBUTTONUP, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonUp)) },

#define ON_WM_MBUTTONDBLCLK() \
	{ WM_MBUTTONDBLCLK, 0, 0, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, CPoint) > ( &ThisClass :: OnMButtonDblClk)) },

#ifndef _WIN32_WCE
#define ON_WM_PARENTNOTIFY() \
	{ WM_PARENTNOTIFY, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast<void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: OnParentNotify)) },

#define ON_WM_PARENTNOTIFY_REFLECT() \
	{ WM_PARENTNOTIFY+WM_REFLECT_BASE, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM) > ( &ThisClass :: ParentNotify)) },

#define ON_WM_MDIACTIVATE() \
	{ WM_MDIACTIVATE, 0, 0, 0, AfxSig_vbWW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL, CWnd*, CWnd*) > ( &ThisClass :: OnMDIActivate)) },
#endif // !_WIN32_WCE

#define ON_WM_RENDERFORMAT() \
	{ WM_RENDERFORMAT, 0, 0, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT) > ( &ThisClass :: OnRenderFormat)) },

#define ON_WM_RENDERALLFORMATS() \
	{ WM_RENDERALLFORMATS, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnRenderAllFormats)) },

#define ON_WM_DESTROYCLIPBOARD() \
	{ WM_DESTROYCLIPBOARD, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDestroyClipboard)) },

#ifndef _WIN32_WCE
#define ON_WM_DRAWCLIPBOARD() \
	{ WM_DRAWCLIPBOARD, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnDrawClipboard)) },

#define ON_WM_PAINTCLIPBOARD() \
	{ WM_PAINTCLIPBOARD, 0, 0, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL) > ( &ThisClass :: OnPaintClipboard)) },

#define ON_WM_VSCROLLCLIPBOARD() \
	{ WM_VSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnVScrollClipboard)) },
#endif // !_WIN32_WCE

#define ON_WM_CONTEXTMENU() \
	{ WM_CONTEXTMENU, 0, 0, 0, AfxSig_vWp, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, CPoint) > ( &ThisClass :: OnContextMenu)) },

#ifndef _WIN32_WCE
#define ON_WM_SIZECLIPBOARD() \
	{ WM_SIZECLIPBOARD, 0, 0, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL)> ( &ThisClass :: OnSizeClipboard)) },

#define ON_WM_ASKCBFORMATNAME() \
	{ WM_ASKCBFORMATNAME, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPTSTR) > ( &ThisClass :: OnAskCbFormatName)) },

#define ON_WM_CHANGECBCHAIN() \
	{ WM_CHANGECBCHAIN, 0, 0, 0, AfxSig_vhh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(HWND, HWND) > ( &ThisClass :: OnChangeCbChain)) },

#define ON_WM_HSCROLLCLIPBOARD() \
	{ WM_HSCROLLCLIPBOARD, 0, 0, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT) > ( &ThisClass :: OnHScrollClipboard)) },
#endif // !_WIN32_WCE

#define ON_WM_QUERYNEWPALETTE() \
	{ WM_QUERYNEWPALETTE, 0, 0, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryNewPalette)) },

#define ON_WM_PALETTECHANGED() \
	{ WM_PALETTECHANGED, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnPaletteChanged)) },

#ifndef _WIN32_WCE
#define ON_WM_PALETTEISCHANGING() \
	{ WM_PALETTEISCHANGING, 0, 0, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnPaletteIsChanging)) },

#define ON_WM_DROPFILES() \
	{ WM_DROPFILES, 0, 0, 0, AfxSig_vh, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(HDROP) > ( &ThisClass :: OnDropFiles)) },

#define ON_WM_WINDOWPOSCHANGING() \
	{ WM_WINDOWPOSCHANGING, 0, 0, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(WINDOWPOS*) > ( &ThisClass :: OnWindowPosChanging)) },
#endif // !_WIN32_WCE

#define ON_WM_WINDOWPOSCHANGED() \
	{ WM_WINDOWPOSCHANGED, 0, 0, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(WINDOWPOS*) > ( &ThisClass :: OnWindowPosChanged)) },

#define ON_WM_EXITMENULOOP() \
	{ WM_EXITMENULOOP, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnExitMenuLoop)) },

#define ON_WM_ENTERMENULOOP() \
	{ WM_ENTERMENULOOP, 0, 0, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(BOOL) > ( &ThisClass :: OnEnterMenuLoop)) },

#define ON_WM_STYLECHANGED() \
	{ WM_STYLECHANGED, 0, 0, 0, AfxSig_viSS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPSTYLESTRUCT) > ( &ThisClass :: OnStyleChanged)) },

#ifndef _WIN32_WCE
#define ON_WM_STYLECHANGING() \
	{ WM_STYLECHANGING, 0, 0, 0, AfxSig_viSS, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(int, LPSTYLESTRUCT) > ( &ThisClass :: OnStyleChanging)) },

#define ON_WM_SIZING() \
	{ WM_SIZING, 0, 0, 0, AfxSig_vwSIZING, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPRECT) > ( &ThisClass :: OnSizing)) },

#define ON_WM_MOVING() \
	{ WM_MOVING, 0, 0, 0, AfxSig_vwMOVING, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, LPRECT) > ( &ThisClass :: OnMoving)) },
#endif // !_WIN32_WCE

#define ON_WM_CAPTURECHANGED() \
	{ WM_CAPTURECHANGED, 0, 0, 0, AfxSig_vW2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(CWnd*) > ( &ThisClass :: OnCaptureChanged)) },

#define ON_WM_DEVICECHANGE() \
	{ WM_DEVICECHANGE, 0, 0, 0, AfxSig_bwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< BOOL (AFX_MSG_CALL CWnd::*)(UINT, DWORD_PTR) > ( &ThisClass :: OnDeviceChange)) },

#ifndef _WIN32_WCE
#if (_WIN32_WINNT >= 0x0500 && WINVER >= 0x0500)

#define ON_WM_CHANGEUISTATE() \
	{ WM_CHANGEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnChangeUIState)) },

#define ON_WM_UPDATEUISTATE() \
	{ WM_UPDATEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnUpdateUIState)) },

#define ON_WM_QUERYUISTATE() \
	{ WM_QUERYUISTATE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryUIState)) },
#else

#define ON_WM_CHANGEUISTATE() \
	__pragma(message("WM_CHANGEUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_CHANGEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnChangeUIState)) },

#define ON_WM_UPDATEUISTATE() \
	__pragma(message("WM_UPDATEUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_UPDATEUISTATE, 0, 0, 0, AfxSig_vww2, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(UINT, UINT) > ( &ThisClass :: OnUpdateUIState)) },

#define ON_WM_QUERYUISTATE() \
	__pragma(message("WM_QUERYUISTATE requires _WIN32_WINNT and WINVER to be >= 0x500")) \
	{ WM_QUERYUISTATE, 0, 0, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< UINT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnQueryUIState)) },

#endif // (_WIN32_WINNT >= 0x0500 && WINVER >= 0x0500)
#endif // _WIN32_WCE

#if(_WIN32_WINNT >= 0x0501)
#define ON_WM_THEMECHANGED() \
	{ WM_THEMECHANGED, 0, 0, 0, AfxSig_l, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnThemeChanged)) },
#else
#define ON_WM_THEMECHANGED \
	__pragma(message("ON_WM_THEMECHANGED requires _WIN32_WINNT >= 0x0501")) \
	{ WM_THEMECHANGED, 0, 0, 0, AfxSig_l, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnThemeChanged)) },
#endif	 // _WIN32_WINNT >= 0x0501


/////////////////////////////////////////////////////////////////////////////
// Message map tables for Control Notification messages

// Static control notification codes
#define ON_STN_CLICKED(id, memberFxn) \
	ON_CONTROL(STN_CLICKED, id, memberFxn)
#define ON_STN_DBLCLK(id, memberFxn) \
	ON_CONTROL(STN_DBLCLK, id, memberFxn)
#define ON_STN_ENABLE(id, memberFxn) \
	ON_CONTROL(STN_ENABLE, id, memberFxn)
#define ON_STN_DISABLE(id, memberFxn) \
	ON_CONTROL(STN_DISABLE, id, memberFxn)


// Edit Control Notification Codes
#define ON_EN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(EN_SETFOCUS, id, memberFxn)
#define ON_EN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(EN_KILLFOCUS, id, memberFxn)
#define ON_EN_CHANGE(id, memberFxn) \
	ON_CONTROL(EN_CHANGE, id, memberFxn)
#define ON_EN_UPDATE(id, memberFxn) \
	ON_CONTROL(EN_UPDATE, id, memberFxn)
#define ON_EN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(EN_ERRSPACE, id, memberFxn)
#define ON_EN_MAXTEXT(id, memberFxn) \
	ON_CONTROL(EN_MAXTEXT, id, memberFxn)
#define ON_EN_HSCROLL(id, memberFxn) \
	ON_CONTROL(EN_HSCROLL, id, memberFxn)
#define ON_EN_VSCROLL(id, memberFxn) \
	ON_CONTROL(EN_VSCROLL, id, memberFxn)

#if(_WIN32_WINNT >= 0x0500)
#define ON_EN_ALIGN_LTR_EC(id, memberFxn) \
	ON_CONTROL(EN_ALIGN_LTR_EC, id, memberFxn)
#define ON_EN_ALIGN_RTL_EC(id, memberFxn) \
	ON_CONTROL(EN_ALIGN_RTL_EC, id, memberFxn)
#else
#define ON_EN_ALIGN_LTR_EC(id, memberFxn) \
	__pragma(message("EN_ALIGN_LTR_EC requires _WIN32_WINNT to be >= 0x0500")) \
	ON_CONTROL(EN_ALIGN_LTR_EC, id, memberFxn)
#define ON_EN_ALIGN_RTL_EC(id, memberFxn) \
	__pragma(message("EN_ALIGN_RTL_EC requires _WIN32_WINNT to be >= 0x0500")) \
	ON_CONTROL(EN_ALIGN_RTL_EC, id, memberFxn)
#endif // _WIN32_WINNT >= 0x0500

// Richedit Control Notification Codes
#define ON_EN_IMECHANGE(id, memberFxn) \
	ON_CONTROL(EN_IMECHANGE, id, memberFxn)
#define ON_EN_ALIGNLTR(id, memberFxn) \
	ON_CONTROL(EN_ALIGNLTR, id, memberFxn)
#define ON_EN_ALIGNRTL(id, memberFxn) \
	ON_CONTROL(EN_ALIGNRTL, id, memberFxn)

// Animation Control Notification Codes
#define ON_ACN_START(id, memberFxn) \
	ON_CONTROL(ACN_START, id, memberFxn)
#define ON_ACN_STOP(id, memberFxn) \
	ON_CONTROL(ACN_STOP, id, memberFxn)

// User Button Notification Codes
#define ON_BN_CLICKED(id, memberFxn) \
	ON_CONTROL(BN_CLICKED, id, memberFxn)
#define ON_BN_DOUBLECLICKED(id, memberFxn) \
	ON_CONTROL(BN_DOUBLECLICKED, id, memberFxn)
#define ON_BN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(BN_SETFOCUS, id, memberFxn)
#define ON_BN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(BN_KILLFOCUS, id, memberFxn)

// old BS_USERBUTTON button notifications - obsolete in Win31
#define ON_BN_PAINT(id, memberFxn) \
	ON_CONTROL(BN_PAINT, id, memberFxn)
#define ON_BN_HILITE(id, memberFxn) \
	ON_CONTROL(BN_HILITE, id, memberFxn)
#define ON_BN_UNHILITE(id, memberFxn) \
	ON_CONTROL(BN_UNHILITE, id, memberFxn)
#define ON_BN_DISABLE(id, memberFxn) \
	ON_CONTROL(BN_DISABLE, id, memberFxn)

// Listbox Notification Codes
#define ON_LBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(LBN_ERRSPACE, id, memberFxn)
#define ON_LBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(LBN_SELCHANGE, id, memberFxn)
#define ON_LBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(LBN_DBLCLK, id, memberFxn)
#define ON_LBN_SELCANCEL(id, memberFxn) \
	ON_CONTROL(LBN_SELCANCEL, id, memberFxn)
#define ON_LBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_SETFOCUS, id, memberFxn)
#define ON_LBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_KILLFOCUS, id, memberFxn)

// Check Listbox Notification codes
#define CLBN_CHKCHANGE (40)
#define ON_CLBN_CHKCHANGE(id, memberFxn) \
	ON_CONTROL(CLBN_CHKCHANGE, id, memberFxn)

// Combo Box Notification Codes
#define ON_CBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(CBN_ERRSPACE, id, memberFxn)
#define ON_CBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_SELCHANGE, id, memberFxn)
#define ON_CBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(CBN_DBLCLK, id, memberFxn)
#define ON_CBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_SETFOCUS, id, memberFxn)
#define ON_CBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_KILLFOCUS, id, memberFxn)
#define ON_CBN_EDITCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_EDITCHANGE, id, memberFxn)
#define ON_CBN_EDITUPDATE(id, memberFxn) \
	ON_CONTROL(CBN_EDITUPDATE, id, memberFxn)
#define ON_CBN_DROPDOWN(id, memberFxn) \
	ON_CONTROL(CBN_DROPDOWN, id, memberFxn)
#define ON_CBN_CLOSEUP(id, memberFxn)  \
	ON_CONTROL(CBN_CLOSEUP, id, memberFxn)
#define ON_CBN_SELENDOK(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDOK, id, memberFxn)
#define ON_CBN_SELENDCANCEL(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDCANCEL, id, memberFxn)

/////////////////////////////////////////////////////////////////////////////
// User extensions for message map entries

// for Windows messages
#define ON_MESSAGE(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_lwl, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Registered Windows messages
#define ON_REGISTERED_MESSAGE(nMessageVariable, memberFxn) \
	{ 0xC000, 0, 0, 0, (UINT_PTR)(UINT*)(&nMessageVariable), \
		/*implied 'AfxSig_lwl'*/ \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Thread messages
#define ON_THREAD_MESSAGE(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGT) \
		(static_cast< void (AFX_MSG_CALL CWinThread::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

// for Registered Windows messages
#define ON_REGISTERED_THREAD_MESSAGE(nMessageVariable, memberFxn) \
	{ 0xC000, 0, 0, 0, (UINT_PTR)(UINT*)(&nMessageVariable), \
		/*implied 'AfxSig_vwl'*/ \
		(AFX_PMSG)(AFX_PMSGT) \
		(static_cast< void (AFX_MSG_CALL CWinThread::*)(WPARAM, LPARAM) > \
		(memberFxn)) },

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxodlgs.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXODLGS_H__
#define __AFXODLGS_H__

#ifndef _WIN32_WCE // OLE

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif

// include OLE dialog/helper APIs
#ifndef _OLEDLG_H_
	#include <oledlg.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXODLGS.H - MFC OLE dialogs

// Classes declared in this file

//CCommonDialog
	class COleDialog;                   // base class for OLE dialog wrappers
		class COleInsertDialog;         // insert object dialog
		class COleConvertDialog;        // convert dialog
		class COleChangeIconDialog;     // change icon dialog
		class COlePasteSpecialDialog;   // paste special dialog
		class COleLinksDialog;          // edit links dialog
			class COleUpdateDialog;     // update links/embeddings dialog
		class COleBusyDialog;           // used for
		class COlePropertiesDialog;
		class COleChangeSourceDialog;

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// COleUILinkInfo -- used internally to implement
// IOleUILinkInfo and IOleUILinkContainer
// used by COleLinksDialog and COleChangeSourceDialog

class COleUILinkInfo : public IOleUILinkInfo
{
public:
	COleUILinkInfo(COleDocument* pDocument);

// Implementation
	COleDocument* m_pDocument;          // document being manipulated
	COleClientItem* m_pSelectedItem;    // primary selected item in m_pDocument
	POSITION m_pos;						// used during link enumeration

	BOOL m_bUpdateLinks;                // update links?
	BOOL m_bUpdateEmbeddings;           // update embeddings?

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	// IOleUILinkContainer
	STDMETHOD_(DWORD,GetNextLink)(DWORD);
	STDMETHOD(SetLinkUpdateOptions)(DWORD, DWORD);
	STDMETHOD(GetLinkUpdateOptions)(DWORD, LPDWORD);
	STDMETHOD(SetLinkSource)(DWORD, LPTSTR, ULONG, ULONG*, BOOL);
	STDMETHOD(GetLinkSource)(DWORD, LPTSTR*, ULONG*, LPTSTR*, LPTSTR*, BOOL*,
		BOOL*);
	STDMETHOD(OpenLinkSource)(DWORD);
	STDMETHOD(UpdateLink)(DWORD, BOOL, BOOL);
	STDMETHOD(CancelLink)(DWORD);
	// IOleUILinkInfo
	STDMETHOD(GetLastUpdate)(DWORD dwLink, FILETIME* lpLastUpdate);

private:
	COleClientItem* GetLinkItem(DWORD dwLink);
};

/////////////////////////////////////////////////////////////////////////////
// Wrappers for OLE UI dialogs

class AFX_NOVTABLE COleDialog : public CCommonDialog
{
	DECLARE_DYNAMIC(COleDialog)

// Attributes
public:
	UINT GetLastError() const;

// Implementation
public:
	int MapResult(UINT nResult);
	explicit COleDialog(CWnd* pParentWnd);
	virtual ~COleDialog() = 0 { }
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	UINT m_nLastError;
};

/////////////////////////////////////////////////////////////////////////////
// COleInsertDialog

class COleInsertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleInsertDialog)

// Attributes
public:
	OLEUIINSERTOBJECT m_io; // structure for OleUIInsertObject

// Constructors
	/* explicit */ COleInsertDialog(DWORD dwFlags = IOF_SELECTCREATENEW,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
	INT_PTR DoModal(DWORD dwFlags);
	BOOL CreateItem(COleClientItem* pItem);
		// call after DoModal to create item based on dialog data

// Attributes (after DoModal returns IDOK)
	enum Selection { createNewItem, insertFromFile, linkToFile };
	UINT GetSelectionType() const;
		// return type of selection made

	CString GetPathName() const;  // return full path name
	REFCLSID GetClassID() const;    // get class ID of new item

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COleInsertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

	enum FilterFlags {
		DocObjectsOnly = 1,
		ControlsOnly = 2,
	};

protected:
	TCHAR m_szFileName[_MAX_PATH];
		// contains full path name after return

	void AddClassIDToList(LPCLSID& lpList, int& nListCount,
		int& nBufferLen, LPCLSID pNewID);
};

/////////////////////////////////////////////////////////////////////////////
// COleConvertDialog

class COleConvertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleConvertDialog)

// Attributes
public:
	OLEUICONVERT m_cv;  // structure for OleUIConvert

// Constructors
	explicit COleConvertDialog(COleClientItem* pItem,
		DWORD dwFlags = CF_SELECTCONVERTTO, CLSID* pClassID = NULL,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
		// just display the dialog and collect convert info
	BOOL DoConvert(COleClientItem* pItem);
		// do the conversion on pItem (after DoModal == IDOK)

// Attributes (after DoModal returns IDOK)
	enum Selection { noConversion, convertItem, activateAs };
	UINT GetSelectionType() const;

	HGLOBAL GetIconicMetafile() const;  // will return NULL if same as before
	REFCLSID GetClassID() const;    // get class ID to convert or activate as
	DVASPECT GetDrawAspect() const; // get new draw aspect

// Implementation
public:
	virtual ~COleConvertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COleChangeIconDialog

class COleChangeIconDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleChangeIconDialog)

// Attributes
public:
	OLEUICHANGEICON m_ci;   // structure for OleUIChangeIcon

// Constructors
	explicit COleChangeIconDialog(COleClientItem* pItem,
		DWORD dwFlags = CIF_SELECTCURRENT,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();
	BOOL DoChangeIcon(COleClientItem* pItem);

// Attributes
	HGLOBAL GetIconicMetafile() const;

// Implementation
public:
	virtual ~COleChangeIconDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COlePasteSpecialDialog

class COlePasteSpecialDialog : public COleDialog
{
	DECLARE_DYNAMIC(COlePasteSpecialDialog)

// Attributes
public:
	OLEUIPASTESPECIAL m_ps; // structure for OleUIPasteSpecial

// Constructors
	/* explicit */ COlePasteSpecialDialog(DWORD dwFlags = PSF_SELECTPASTE,
		COleDataObject* pDataObject = NULL, CWnd *pParentWnd = NULL);

// Operations
	OLEUIPASTEFLAG AddLinkEntry(UINT cf);
	void AddFormat(const FORMATETC& formatEtc, __in_z LPTSTR lpszFormat,
		__in_z LPTSTR lpszResult, DWORD flags);
	void AddFormat(UINT cf, DWORD tymed, UINT nFormatID, BOOL bEnableIcon,
		BOOL bLink);
	void AddStandardFormats(BOOL bEnableLink = TRUE);

	virtual INT_PTR DoModal();
	BOOL CreateItem(COleClientItem *pNewItem);
		// creates a standard OLE item from selection data

// Attributes (after DoModal returns IDOK)
	int GetPasteIndex() const;      // resulting index to use for paste

	enum Selection { pasteLink = 1, pasteNormal = 2, pasteStatic = 3, pasteOther = 4};
	UINT GetSelectionType() const;
		// get selection type (pasteLink, pasteNormal, pasteStatic)

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COlePasteSpecialDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	unsigned int m_arrLinkTypes[8];
		// size limit imposed by MFCUIx32.DLL library
};

/////////////////////////////////////////////////////////////////////////////
// COleLinksDialog

class COleLinksDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleLinksDialog)

// Attributes
public:
	OLEUIEDITLINKS m_el;    // structure for OleUIEditLinks

// Constructors
	COleLinksDialog(COleDocument* pDoc, CView* pView, DWORD dwFlags = 0,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();  // display the dialog and edit links

// Implementation
public:
	virtual ~COleLinksDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

public:
	COleUILinkInfo m_xLinkInfo; // implements IOleUILinkContainer
};

/////////////////////////////////////////////////////////////////////////////
// COleUpdateDialog

class COleUpdateDialog : public COleLinksDialog
{
	DECLARE_DYNAMIC(COleUpdateDialog)

// Constructors
public:
	explicit COleUpdateDialog(COleDocument* pDoc,
		BOOL bUpdateLinks = TRUE, BOOL bUpdateEmbeddings = FALSE,
		CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Implementation
public:
	virtual ~COleUpdateDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CString m_strCaption;   // caption for the dialog
};

/////////////////////////////////////////////////////////////////////////////
// COleBusyDialog - useful in managing concurrency

class COleBusyDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleBusyDialog)

// Attributes
public:
	OLEUIBUSY m_bz;

// Constructors
	explicit COleBusyDialog(HTASK htaskBusy, BOOL bNotResponding = FALSE,
		DWORD dwFlags = 0, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

	enum Selection { switchTo = 1, retry = 2, callUnblocked = 3 };
	UINT GetSelectionType() const;

// Implementation
public:
	~COleBusyDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	Selection m_selection;  // selection after DoModal returns IDOK
};

/////////////////////////////////////////////////////////////////////////////
// COleEditProperties

class COlePropertiesDialog : public COleDialog
{
	DECLARE_DYNAMIC(COlePropertiesDialog)

// Attributes
public:
	OLEUIOBJECTPROPS m_op;      // structure for OleUIObjectProperties
	OLEUIGNRLPROPS m_gp;        // specific to "General" page
	OLEUIVIEWPROPS m_vp;        // specific to "View" page
	OLEUILINKPROPS m_lp;        // specific to "Link" page
	PROPSHEETHEADER m_psh;      // PROPSHEETHEADER for customization

// Constructors
public:
	COlePropertiesDialog(COleClientItem* pItem,
		UINT nScaleMin = 10, UINT nScaleMax = 500, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Overridables
	virtual BOOL OnApplyScale(
		COleClientItem* pItem, int nCurrentScale, BOOL bRelativeToOrig);

// Implementation
public:
	COleDocument* m_pDoc;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual BOOL OnInitDialog();

	BEGIN_INTERFACE_PART(OleUIObjInfo, IOleUIObjInfo)
		INIT_INTERFACE_PART(COlePropertiesDialog, OleUIObjInfo)
		STDMETHOD(GetObjectInfo) (THIS_ DWORD dwObject,
			DWORD* lpdwObjSize, LPTSTR* lplpszLabel,
			LPTSTR* lplpszType, LPTSTR* lplpszShortType,
			LPTSTR* lplpszLocation);
		STDMETHOD(GetConvertInfo) (THIS_ DWORD dwObject,
			CLSID* lpClassID, WORD* lpwFormat,
			CLSID* lpConvertDefaultClassID,
			LPCLSID* lplpClsidExclude, UINT* lpcClsidExclude);
		STDMETHOD(ConvertObject) (THIS_ DWORD dwObject, REFCLSID clsidNew);
		STDMETHOD(GetViewInfo) (THIS_ DWORD dwObject,
			HGLOBAL* phMetaPict, DWORD* pdvAspect, int* pnCurrentScale);
		STDMETHOD(SetViewInfo) (THIS_ DWORD dwObject,
			HGLOBAL hMetaPict, DWORD dvAspect,
			int nCurrentScale, BOOL bRelativeToOrig);
	END_INTERFACE_PART(OleUIObjInfo)
	COleUILinkInfo m_xLinkInfo; // implements IOleUILinkContainer
};

/////////////////////////////////////////////////////////////////////////////
// COleChangeSourceDialog

class COleChangeSourceDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleChangeSourceDialog)

// Attributes
public:
	OLEUICHANGESOURCE m_cs; // structure for OleUIChangeSource

// Constructors
public:
	explicit COleChangeSourceDialog(COleClientItem* pItem, CWnd* pParentWnd = NULL);

// Operations
	virtual INT_PTR DoModal();

// Attributes (after DoModal returns IDOK)
	BOOL IsValidSource();
	CString GetDisplayName();
	CString GetFileName();
	CString GetItemName();
	CString GetFromPrefix();
	CString GetToPrefix();

// Implementation
public:
	COleUILinkInfo m_xLinkInfo;

	virtual ~COleChangeSourceDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual void PreInitDialog();
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXODLGS_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXODLGS_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // !_WIN32_WCE
#endif //__AFXODLGS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif


struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#ifndef _WIN64
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT_PTR nMax, UINT_PTR cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXMT_H__
#define __AFXMT_H__

#pragma once

#ifndef __AFX_H__
	#include <afx.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXMT - MFC Multithreaded Extensions (Syncronization Objects)

// Classes declared in this file

//CObject
	class CSyncObject;
		class CSemaphore;
		class CMutex;
		class CEvent;
		class CCriticalSection;

class CSingleLock;
class CMultiLock;

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject : public CObject
{
	DECLARE_DYNAMIC(CSyncObject)

// Constructor
public:
	explicit CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
#ifdef _DEBUG
	CString m_strName;
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
	DECLARE_DYNAMIC(CSemaphore)

// Constructor
public:
	/* explicit */ CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
	DECLARE_DYNAMIC(CMutex)

// Constructor
public:
	/* explicit */ CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
	DECLARE_DYNAMIC(CEvent)

private:
   using CSyncObject::Unlock;

// Constructor
public:
	/* explicit */ CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
	DECLARE_DYNAMIC(CCriticalSection)

private:
   using CSyncObject::Unlock;

// Constructor
public:
	CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();

private:
	BOOL Init();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	explicit CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXMT_INLINE AFX_INLINE
#include <afxmt.inl>
#undef _AFXMT_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxocc.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOCC_H__
#define __AFXOCC_H__

#pragma once

#ifndef _AFX_NO_OCC_SUPPORT

#include <afxtempl.h>
#ifndef _WIN32_WCE
#include <oledb.h>
#endif // !_WIN32_WCE
#include "olebind.h"
#include "ocdbid.h"
#include "ocdb.h"

#ifndef _AFX_NO_DB_SUPPORT
class CDataSourceControl;
class CDataBoundProperty;
#endif // !_AFX_NO_DB_SUPPORT

// CCmdTarget
	class COleControlContainer;
	class COleControlSite;

class COccManager;
struct _AFX_OCC_DIALOG_INFO;

#define DISPID_DATASOURCE   0x80010001
#define DISPID_DATAFIELD    0x80010002


class COleControlSiteFactory;
__declspec(selectany) extern const CLSID CLSID_WinFormsControl = 
{0xb7e7a666,0xd623,0x457f,{0xa3,0x0a,0x6a,0x49,0xa3,0xe5,0xb4,0x70}};
/////////////////////////////////////////////////////////////////////////////
// Control site factory interface - allow instantiation of different control sites

class IControlSiteFactory 
{
public:
		virtual ~IControlSiteFactory() {}
		virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Control site factory collection manager class

class CControlSiteFactoryMgr : public CNoTrackObject {
public:
	CControlSiteFactoryMgr();
	virtual ~CControlSiteFactoryMgr();
	BOOL RegisterSiteFactory(IControlSiteFactory* pFactory);
	BOOL UnregisterSiteFactory(IControlSiteFactory* pFactory);
	COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo);
protected:
	CList <IControlSiteFactory*,IControlSiteFactory*> m_lstFactory;
	COleControlSiteFactory* m_pOleControlSiteDefaultFactory;
};

BOOL AFXAPI AfxRegisterSiteFactory(IControlSiteFactory* pFactory);
BOOL AFXAPI AfxUnregisterSiteFactory(IControlSiteFactory* pFactory);



class CControlCreationInfo {
public:
	CControlCreationInfo();
	enum HandleKind { ReflectionType,ControlInstance,NullHandle };
	BOOL IsManaged() const;
	HandleKind m_hk;
#ifndef _WIN32_WCE
	intptr_t   m_nHandle;
#else
	HANDLE m_nHandle;
#endif // !_WIN32_WCE
	CLSID m_clsid;
};


/////////////////////////////////////////////////////////////////////////////
// Control containment helper functions

DLGTEMPLATE* _AfxSplitDialogTemplate(const DLGTEMPLATE* pTemplate,
	CMapWordToPtr* pOleItemMap);

void _AfxZOrderOleControls(CWnd* pWnd, CMapWordToPtr* pOleItemMap);

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer

class COleControlContainer : public CCmdTarget
{
public:
// Constructor
	explicit COleControlContainer(CWnd*  pWnd);

// Operations
	virtual void BroadcastAmbientPropertyChange(DISPID dispid);
	BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
		CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL,
		COleControlSite** ppNewSite=NULL);
   // Overload to allow creation of default-sized controls
	BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt,
	  const SIZE* psize, UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE,
	  BSTR bstrLicKey=NULL, COleControlSite** ppNewSite=NULL);
	//Overload to create managed controls
	BOOL CreateControl(CWnd* pWndCtrl,const CControlCreationInfo& creationInfo,
			DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID);

	BOOL CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
			LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize,
		   UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL, COleControlSite** ppNewSite=NULL);


	virtual COleControlSite* FindItem(UINT nID) const;
	virtual BOOL GetAmbientProp(COleControlSite* pSite, DISPID dispid,
		VARIANT* pvarResult);
#ifndef _WIN32_WCE // unresolved external symbol __imp__OleCreateFontIndirect
	void CreateOleFont(CFont* pFont);
#endif // !_WIN32_WCE
	void FreezeAllEvents(BOOL bFreeze);
	virtual void ScrollChildren(int dx, int dy);
	virtual void OnUIActivate(COleControlSite* pSite);
	virtual void OnUIDeactivate(COleControlSite* pSite);

	virtual void CheckDlgButton(int nIDButton, UINT nCheck);
	virtual void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
		int nIDCheckButton);
	virtual CWnd* GetDlgItem(int nID) const;
	virtual void GetDlgItem(int nID, HWND* phWnd) const;
	virtual UINT GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const;
	virtual int GetDlgItemText(__in int nID, __out_ecount_part(nMaxCount, return + 1) __out_z LPTSTR lpStr, __in int nMaxCount) const;
	virtual LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
		LPARAM lParam);
	virtual void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned);
	virtual void SetDlgItemText(int nID, LPCTSTR lpszString);
	virtual UINT IsDlgButtonChecked(int nIDButton) const;

   virtual BOOL HandleSetFocus();
   virtual BOOL HandleWindowlessMessage(UINT message, WPARAM wParam, 
	  LPARAM lParam, LRESULT* plResult );
   virtual BOOL OnPaint(CDC* pDC);
#ifndef _AFXDLL
	virtual void AttachControlSite(CWnd* pWnd, UINT nIDC = 0);
#else
	void AttachControlSite(CWnd* pWnd, UINT nIDC = 0);
#endif
	virtual BOOL FillListSitesOrWnds(_AFX_OCC_DIALOG_INFO* pOccDlgInfo);
// Attributes
	CWnd* m_pWnd;
	CMapPtrToPtr m_siteMap;
	CTypedPtrList< CPtrList, COleControlSiteOrWnd* > m_listSitesOrWnds;
	COLORREF m_crBack;
	COLORREF m_crFore;
	LPFONTDISP m_pOleFont;
	COleControlSite* m_pSiteUIActive;
	COleControlSite* m_pSiteCapture;
	COleControlSite* m_pSiteFocus;
	int m_nWindowlessControls;

// Implementation
public:
	virtual ~COleControlContainer();

public:
	// Interface maps
	BEGIN_INTERFACE_PART(OleIPFrame, IOleInPlaceFrame)
		INIT_INTERFACE_PART(COleControlContainer, OleIPFrame)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(GetBorder)(LPRECT);
		STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS);
		STDMETHOD(SetActiveObject)(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR);
		STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS);
		STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND);
		STDMETHOD(RemoveMenus)(HMENU);
		STDMETHOD(SetStatusText)(LPCOLESTR);
		STDMETHOD(EnableModeless)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG, WORD);
	END_INTERFACE_PART(OleIPFrame)

	BEGIN_INTERFACE_PART(OleContainer, IOleContainer)
		INIT_INTERFACE_PART(COleControlContainer, OleContainer)
		STDMETHOD(ParseDisplayName)(LPBINDCTX, LPOLESTR, ULONG*, LPMONIKER*);
		STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
		STDMETHOD(LockContainer)(BOOL);
	END_INTERFACE_PART(OleContainer)

	DECLARE_INTERFACE_MAP()
	DECLARE_DISPATCH_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleControlSite

#define VT_MFCFORCEPUTREF   0x8000  // force DISPATCH_PROPERTYPUTREF

class COleControlSite : public CCmdTarget
{
public:
// Constructor
	explicit COleControlSite(COleControlContainer* pCtrlCont);

// Operations
	virtual HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
		CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);
   // Overload to allow creation of default-sized controls
	virtual HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt,
	  const SIZE* psize, UINT nID, CFile* pPersist=NULL, BOOL bStorage=FALSE,
	  BSTR bstrLicKey=NULL);

	HRESULT CreateControl(CWnd* pWndCtrl, const CControlCreationInfo& creationInfo,
			 DWORD dwStyle, const POINT* ppt, const SIZE* psize,UINT nID);

	virtual BOOL DestroyControl();
	BOOL GetEventIID(IID* piid);
	virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg = NULL);
	BOOL IsDefaultButton();
	DWORD GetDefBtnCode();
	void SetDefaultButton(BOOL bDefault);
	void FreezeEvents(BOOL bFreeze);

	virtual void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, va_list argList);
	virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList);
	virtual void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, ...);
	virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
	virtual void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	virtual BOOL AFX_CDECL SafeSetProperty(DISPID dwDispID, VARTYPE vtProp, ...);

	virtual DWORD GetStyle() const;
	virtual DWORD GetExStyle() const;
	virtual BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
	virtual BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
	virtual void SetWindowText(LPCTSTR lpszString);
	virtual void GetWindowText(CString& str) const;
	virtual int GetDlgCtrlID() const;
	virtual int SetDlgCtrlID(int nID);
	virtual void MoveWindow(int x, int y, int nWidth, int nHeight);
	virtual BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
		int cx, int cy, UINT nFlags);
	virtual BOOL ShowWindow(int nCmdShow);
	virtual BOOL IsWindowEnabled() const;
	virtual BOOL EnableWindow(BOOL bEnable);
	virtual CWnd* SetFocus();
	virtual CWnd* SetFocus(LPMSG lpmsg);
#ifndef _AFX_NO_DB_SUPPORT
	virtual void EnableDSC();
	virtual void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
	virtual void BindProperty(DISPID dwDispId, CWnd* pWndDSC);
#endif // !_AFX_NO_DB_SUPPORT

// Overridables
	virtual BOOL QuickActivate();

// Attributes
	COleControlContainer* m_pCtrlCont;
	HWND m_hWnd;
	CWnd* m_pWndCtrl;
	UINT m_nID;
	CRect m_rect;
	IID m_iidEvents;
	LPOLEOBJECT m_pObject;
	LPOLEINPLACEOBJECT m_pInPlaceObject;
	LPOLEINPLACEACTIVEOBJECT m_pActiveObject;
	IOleInPlaceObjectWindowless* m_pWindowlessObject;
	DWORD m_dwEventSink;
	DWORD m_dwPropNotifySink;
	DWORD m_dwStyleMask;
	DWORD m_dwStyle;
	DWORD m_dwMiscStatus;
	BOOL m_bIsWindowless;
	CONTROLINFO m_ctlInfo;

protected:
	void GetControlInfo();

	virtual HRESULT CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize, UINT nID,
		CFile* pPersist, BOOL bStorage, BSTR bstrLicKey);

// Implementation
public:
	~COleControlSite();

	BOOL IsMatchingMnemonic(LPMSG lpMsg);
	void SendMnemonic(LPMSG lpMsg);
	
	void AttachWindow();
	void DetachWindow();
protected:
	BOOL SetExtent();

	virtual HRESULT CreateOrLoad(const CControlCreationInfo& creationInfo);
	virtual	HRESULT CreateOrLoad(REFCLSID clsid, CFile* pPersist, BOOL bStorage,
		BSTR bstrLicKey);

	DWORD ConnectSink(REFIID iid, LPUNKNOWN punkSink);
	void DisconnectSink(REFIID iid, DWORD dwCookie);
	
	BOOL OnEvent(AFX_EVENT* pEvent);
	HRESULT GetCursor(DISPID dispid, LPUNKNOWN* ppcursorOut, LPVOID *ppcidOut);

public:
#ifndef _AFX_NO_DB_SUPPORT
	// Databound control stuff
	BOOL m_bIgnoreNotify;
	DWORD m_dwNotifyDBEvents; // INotifyDBEvents sink cookie
	CDataSourceControl* m_pDataSourceControl;
	CDataBoundProperty* m_pBindings;
	union {
		COleControlSite *m_pDSCSite;
		WORD m_ctlidRowSource;
	};
	DISPID m_defdispid;
	UINT m_dwType;
	CString m_strDataField;
	BOOL m_bIsDirty;
#endif // !_AFX_NO_DB_SUPPORT
	VARIANT m_varResult;

protected:
	COleDispatchDriver m_dispDriver;
   CDC* m_pDC;

public:
// Interface maps
	BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
		INIT_INTERFACE_PART(COleControlSite, OleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(GetContainer)(LPOLECONTAINER*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(OleClientSite)

#ifndef _WIN32_WCE
	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSiteWindowless)
		INIT_INTERFACE_PART(COleControlSite, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);

		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);

	  STDMETHOD(OnInPlaceActivateEx)( BOOL* ptNoRedraw, DWORD dwFlags );
	  STDMETHOD(OnInPlaceDeactivateEx)( BOOL tNoRedraw );
	  STDMETHOD(RequestUIActivate)();

	  STDMETHOD(AdjustRect)( LPRECT prect );
	  STDMETHOD(CanWindowlessActivate)();
	  STDMETHOD(GetCapture)();
	  STDMETHOD(GetDC)( LPCRECT prect, DWORD dwFlags, HDC* phDC );
	  STDMETHOD(GetFocus)();
	  STDMETHOD(InvalidateRect)( LPCRECT prect, BOOL tErase );
	  STDMETHOD(InvalidateRgn)( HRGN hRgn, BOOL tErase );
	  STDMETHOD(OnDefWindowMessage)( UINT nMessage, WPARAM wParam,
		 LPARAM lParam, LRESULT* plResult );
	  STDMETHOD(ReleaseDC)( HDC hDC );
	  STDMETHOD(ScrollRect)( int dx, int dy, LPCRECT prectScroll,
		 LPCRECT prectClip );
	  STDMETHOD(SetCapture)( BOOL tCapture );
	  STDMETHOD(SetFocus)( BOOL tFocus );
   END_INTERFACE_PART(OleIPSite)
#else
	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
		INIT_INTERFACE_PART(COleControlSite, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);

		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(OleIPSite)
#endif // !_WIN32_WCE

	BEGIN_INTERFACE_PART(OleControlSite, IOleControlSite)
		INIT_INTERFACE_PART(COleControlSite, OleControlSite)
		STDMETHOD(OnControlInfoChanged)();
		STDMETHOD(LockInPlaceActive)(BOOL fLock);
		STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
		STDMETHOD(TransformCoords)(POINTL* lpptlHimetric,
			POINTF* lpptfContainer, DWORD flags);
		STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
		STDMETHOD(OnFocus)(BOOL fGotFocus);
		STDMETHOD(ShowPropertyFrame)();
	END_INTERFACE_PART(OleControlSite)

	BEGIN_INTERFACE_PART(AmbientProps, IDispatch)
		INIT_INTERFACE_PART(COleControlSite, AmbientProps)
		STDMETHOD(GetTypeInfoCount)(unsigned int*);
		STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
		STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
		STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
						  VARIANT*, EXCEPINFO*, unsigned int*);
	END_INTERFACE_PART(AmbientProps)

	BEGIN_INTERFACE_PART(PropertyNotifySink, IPropertyNotifySink)
		INIT_INTERFACE_PART(COleControlSite, PropertyNotifySink)
		STDMETHOD(OnChanged)(DISPID dispid);
		STDMETHOD(OnRequestEdit)(DISPID dispid);
	END_INTERFACE_PART(PropertyNotifySink)

	BEGIN_INTERFACE_PART(EventSink, IDispatch)
		INIT_INTERFACE_PART(COleControlSite, EventSink)
		STDMETHOD(GetTypeInfoCount)(unsigned int*);
		STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
		STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
		STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
						  VARIANT*, EXCEPINFO*, unsigned int*);
	END_INTERFACE_PART(EventSink)

#ifndef _AFX_NO_DB_SUPPORT
	BEGIN_INTERFACE_PART(BoundObjectSite, IBoundObjectSite)
		STDMETHOD(GetCursor)(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);
	END_INTERFACE_PART(BoundObjectSite)

	BEGIN_INTERFACE_PART(NotifyDBEvents, INotifyDBEvents)
		STDMETHOD(OKToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(Cancelled)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(SyncBefore)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(AboutToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(FailedToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(SyncAfter)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
		STDMETHOD(DidEvent)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);

		// Not part of i/f - just a helper
		HRESULT FireEvent(DWORD dwEventWhat, ULONG cReasons,
			DBNOTIFYREASON rgReasons[], DSCSTATE nState);
	END_INTERFACE_PART(NotifyDBEvents)

	BEGIN_INTERFACE_PART(RowsetNotify, IRowsetNotify)
		STDMETHOD(OnFieldChange)(IRowset* pRowset, HROW hRow, DBORDINAL cColumns, DBORDINAL rgColumns[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowChange)(IRowset* pRowset, DBCOUNTITEM cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
		STDMETHOD(OnRowsetChange)(IRowset* pRowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
	END_INTERFACE_PART(RowsetNotify)
#endif // !_AFX_NO_DB_SUPPORT

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleControlSiteOrWnd (helper)
struct COleControlSiteOrWnd
{
	COleControlSiteOrWnd();
	COleControlSiteOrWnd(COleControlSite *pSite);
	COleControlSiteOrWnd(HWND hWnd, BOOL bAutoRadioButton);
	~COleControlSiteOrWnd();

	DWORD GetStyle() const;

	HWND m_hWnd;
	COleControlSite *m_pSite;
	BOOL m_bAutoRadioButton;
};

COleControlSiteOrWnd* AFXAPI _AfxFindSiteOrWnd(CWnd *pWndDlg, CWnd *pWnd);

/////////////////////////////////////////////////////////////////////////////
// OLE control container manager

class COccManager : public CNoTrackObject
{
// Operations
public:
	// Event handling
	virtual BOOL OnEvent(CCmdTarget* pCmdTarget, UINT idCtrl, AFX_EVENT* pEvent,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	// Internal object creation
	virtual COleControlContainer* CreateContainer(CWnd* pWnd);
	virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont);
	virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont,const CControlCreationInfo& creationInfo);

	// Dialog creation
	virtual const DLGTEMPLATE* PreCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo,
		const DLGTEMPLATE* pOrigTemplate);
	virtual void PostCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual DLGTEMPLATE* SplitDialogTemplate(const DLGTEMPLATE* pTemplate,
		DLGITEMTEMPLATE** ppOleDlgItems);
	virtual BOOL CreateDlgControls(CWnd* pWndParent, LPCTSTR lpszResourceName,
		_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual BOOL CreateDlgControls(CWnd* pWndParent, void* lpResource,
		_AFX_OCC_DIALOG_INFO* pOccDialogInfo);

	// Dialog manager
	virtual BOOL IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg);
	static BOOL AFX_CDECL IsLabelControl(CWnd* pWnd);
	static BOOL AFX_CDECL IsLabelControl(COleControlSiteOrWnd* pWnd);
	static BOOL AFX_CDECL IsMatchingMnemonic(CWnd* pWnd, LPMSG lpMsg);
	static BOOL AFX_CDECL IsMatchingMnemonic(COleControlSiteOrWnd* pWnd, LPMSG lpMsg);
	static void AFX_CDECL SetDefaultButton(CWnd* pWnd, BOOL bDefault);
	static DWORD AFX_CDECL GetDefBtnCode(CWnd* pWnd);

// Implementation
protected:
	// Dialog creation
	BOOL CreateDlgControl(CWnd* pWndParent, HWND hwAfter, BOOL bDialogEx,
		LPDLGITEMTEMPLATE pDlgItem, WORD nMsg, BYTE* lpData, DWORD cb, HWND* phWnd);

#ifndef _AFX_NO_DB_SUPPORT
	// Databinding
	void BindControls(CWnd* pWndParent);
#endif // !_AFX_NO_DB_SUPPORT

	// Dialog manager
	static void AFX_CDECL UIActivateControl(CWnd* pWndNewFocus);
	static void AFX_CDECL UIDeactivateIfNecessary(CWnd* pWndOldFocus, CWnd* pWndNewFocus);
};

struct _AFX_OCC_DIALOG_INFO
{
	DLGTEMPLATE* m_pNewTemplate;
	DLGITEMTEMPLATE** m_ppOleDlgItems;

#ifdef _WIN32_WCE
	// In OCCCONT.CPP, we use this "remembered value" because DLGTEMPLATEEX
	// dialogs get converted to DLGTEMPLATE's, but the OLE items are still DIGITEMTEMPLATEEX's.
	BOOL m_bDialogEx;
#endif // _WIN32_WCE

	unsigned m_cItems;
	struct ItemInfo
	{
		unsigned nId;
		BOOL bAutoRadioButton;
	};
	ItemInfo *m_pItemInfo;
};

#endif // !_AFX_NO_OCC_SUPPORT
#endif // __AFXOCC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxisapi.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXISAPI.H

#ifdef _AFXISAPI_INLINE

_AFXISAPI_INLINE CHttpServerContext::CHttpServerContext(EXTENSION_CONTROL_BLOCK* pECB)
#ifdef _DEBUG
	: m_dwStatusCode(DWORD(-1)), m_bSendHeaders(TRUE), m_pECB(pECB), 
	  m_pStream(NULL), m_dwEndOfHeaders(0), m_dwOldEndOfHeaders(0),
	  m_dwChunkSize(0), m_pArgList(NULL)
#else
	: m_dwStatusCode(DWORD(-1)), m_bSendHeaders(TRUE), m_pECB(pECB),
	  m_pStream(NULL), m_dwEndOfHeaders(0), m_dwChunkSize(0), m_pArgList(NULL)
#endif
	{
		ISAPIENSURE(NULL != pECB);
	}

_AFXISAPI_INLINE CHttpServerContext::~CHttpServerContext()
	{ delete m_pStream; delete m_pArgList; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(double d)
	{	ISAPIENSURE(m_pStream != NULL);
		*m_pStream << d;
		return *this; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(float f)
	{	ISAPIENSURE(m_pStream != NULL);
		*m_pStream << f;
		return *this; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(long int dw)
	{	ISAPIENSURE(m_pStream != NULL);
		*m_pStream << dw;
		return *this; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(short int w)
	{	ISAPIENSURE(m_pStream != NULL);
		*m_pStream << w;
		return *this; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(const CHtmlStream& stream)
	{	ISAPIENSURE(m_pStream != NULL);
		*m_pStream << stream;
		return *this; }

_AFXISAPI_INLINE CHttpServerContext& CHttpServerContext::operator<<(LPCTSTR psz)
	{	ISAPIENSURE(m_pStream != NULL && psz != NULL);
		*m_pStream << psz;
		return *this; }

_AFXISAPI_INLINE BOOL CHttpServerContext::GetServerVariable(__in_z LPTSTR lpszVariableName,
		__out_ecount_part(*lpdwSize, *lpdwSize) LPVOID lpvBuffer, __inout LPDWORD lpdwSize)
	{
		ISAPIENSURE(m_pECB != NULL);
		return m_pECB->GetServerVariable(m_pECB->ConnID,
			lpszVariableName, lpvBuffer, lpdwSize);
	}

_AFXISAPI_INLINE BOOL CHttpServerContext::WriteClient(LPVOID pBuffer, LPDWORD lpdwBytes,
	DWORD dwReserved /* = 0 */)
	{
		ISAPIENSURE(m_pECB != NULL);
		return m_pECB->WriteClient(m_pECB->ConnID, pBuffer,
			lpdwBytes, dwReserved);
	}

_AFXISAPI_INLINE BOOL CHttpServerContext::ReadClient(LPVOID lpvBuffer, LPDWORD lpdwSize)
	{
		ISAPIENSURE(m_pECB != NULL);
		return m_pECB->ReadClient(m_pECB->ConnID, lpvBuffer, lpdwSize);
	}

_AFXISAPI_INLINE BOOL CHttpServerContext::ServerSupportFunction(DWORD dwHSERRequest,
		LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
	{
		ISAPIENSURE(m_pECB != NULL);
		return m_pECB->ServerSupportFunction(m_pECB->ConnID, dwHSERRequest,
			lpvBuffer, lpdwSize, lpdwDataType);
	}

_AFXISAPI_INLINE CHttpArgList::CHttpArgList()
	: m_pFirstArg(NULL)
	{ }

_AFXISAPI_INLINE CHttpArg::~CHttpArg()
	{ free((void*) m_pstrRaw); free((void*) m_pstrParam); }


_AFXISAPI_INLINE POSITION CHttpArgList::GetFirstArgPosition() const
	{ return (POSITION) m_pFirstArg; }

_AFXISAPI_INLINE CHttpArg* CHttpArgList::GetNextArg(POSITION& pos) const
	{
		ISAPIENSURE(pos != NULL);
		CHttpArg* pArg = (CHttpArg*) pos;
		pos = (POSITION) pArg->m_pNext;
		return pArg;
	}


_AFXISAPI_INLINE DWORD CHtmlStream::GetStreamSize() const
	{ return m_nStreamSize; }

_AFXISAPI_INLINE CHttpFilterContext::CHttpFilterContext(PHTTP_FILTER_CONTEXT pCtx)
	: m_pFC(pCtx)
	{
		ISAPIENSURE(NULL != pCtx);
	}

_AFXISAPI_INLINE BOOL CHttpFilterContext::GetServerVariable(__in_z LPTSTR lpszVariableName,
		__out_ecount_part(*lpdwSize, *lpdwSize) LPVOID lpvBuffer, __inout LPDWORD lpdwSize)
	{
		ISAPIENSURE(m_pFC != NULL);
		return m_pFC->GetServerVariable(m_pFC, lpszVariableName, lpvBuffer, lpdwSize);
	}
_AFXISAPI_INLINE BOOL CHttpFilterContext::AddResponseHeaders(__in_z LPTSTR lpszHeaders,
		__in DWORD dwReserved /* = 0 */)
	{
		ISAPIENSURE(m_pFC != NULL);
		return m_pFC->AddResponseHeaders(m_pFC, lpszHeaders, dwReserved);
	}
_AFXISAPI_INLINE BOOL CHttpFilterContext::WriteClient(LPVOID lpvBuffer,
		LPDWORD lpdwBytes, DWORD dwReserved /* = 0 */)
	{
		ISAPIENSURE(m_pFC != NULL);
		return m_pFC->WriteClient(m_pFC, lpvBuffer, lpdwBytes, dwReserved);
	}
_AFXISAPI_INLINE LPVOID CHttpFilterContext::AllocMem(DWORD cbSize,
		DWORD dwReserved /* = 0 */)
	{
		ISAPIENSURE(m_pFC != NULL);
		return m_pFC->AllocMem(m_pFC, cbSize, dwReserved);
	}
_AFXISAPI_INLINE BOOL CHttpFilterContext::ServerSupportFunction(enum SF_REQ_TYPE sfReq,
		LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
	{
		ISAPIENSURE(m_pFC != NULL);
		return m_pFC->ServerSupportFunction(m_pFC, sfReq, lpvBuffer,
			(DWORD_PTR) lpdwSize, (DWORD_PTR) lpdwDataType);
	}


#endif // _AFXISAPI_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxole.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOLE_H__
#define __AFXOLE_H__

#ifdef _AFX_NO_OLE_SUPPORT
	#error OLE classes not supported in this library variant.
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifndef __AFXDISP_H__
	#include <afxdisp.h>
#endif

// include OLE Compound Document headers
#ifndef _OLE2_H_
	#include <ole2.h>
#endif

// ActiveX Document support
#ifndef __docobj_h__
	#include <docobj.h>
#endif

// URL Monikers support
#ifndef __urlmon_h__
	#include <urlmon.h>
#endif

#ifndef __AFXCOM_H__
#include <afxcom_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif


#ifndef _AFX_NOFORCE_LIBS

#pragma comment(lib, "urlmon.lib")

#endif // !_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// AFXOLE.H - MFC OLE support

// Classes declared in this file

#ifndef _WIN32_WCE
//CDocument
	class COleDocument;             // OLE container document
		class COleLinkingDoc;       // supports links to embeddings
			class COleServerDoc;    // OLE server document
	class CDocObjectServer;         // might be owned by a COleServerDoc

//CCmdTarget
	class CDocItem;                 // part of a document
		class COleClientItem;       // embedded ole object from outside
			class COleDocObjectItem;// ActiveX Document item
		class COleServerItem;       // ole object to export
	class COleDataSource;           // clipboard data source mechanism
	class COleDropSource;           // drag/drop source
	class COleDropTarget;           // drag/drop target
	class COleMessageFilter;        // concurrency management

//CFrameWnd
	class COleIPFrameWnd;           // frame window for in-place servers

//CControlBar
	class COleResizeBar;            // implements in-place resizing

//CFile
	class COleStreamFile;           // CFile wrapper for IStream interface
		class CMonikerFile;         // bound to via IMoniker
			class CAsyncMonikerFile;// asynchronous IMoniker
class COleDataObject;               // wrapper for IDataObject interface
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// backward compatibility

// COleClientDoc is now obsolete -- use COleDocument instead
#define COleClientDoc COleDocument

// COleServer has been replaced by the more general COleObjectFactory
#define COleServer  COleObjectFactory

/////////////////////////////////////////////////////////////////////////////
// Useful OLE specific types (some from OLE 1.0 headers)

// Codes for CallBack events
enum OLE_NOTIFICATION
{
	OLE_CHANGED,        // representation of a draw aspect has changed
	OLE_SAVED,          // the item has committed its storage
	OLE_CLOSED,         // the item has closed
	OLE_RENAMED,        // the item has changed its moniker
	OLE_CHANGED_STATE,  // the item state (open, active, etc.) has changed
	OLE_CHANGED_ASPECT, // the item draw aspect has changed
};

// Object types
enum OLE_OBJTYPE
{
	OT_UNKNOWN = 0,

	// These are OLE 1.0 types and OLE 2.0 types as returned from GetType().
	OT_LINK = 1,
	OT_EMBEDDED = 2,
	OT_STATIC = 3,

	// All OLE2 objects are written with this tag when serialized.  This
	//  differentiates them from OLE 1.0 objects written with MFC 2.0.
	//  This value will never be returned from GetType().
	OT_OLE2 = 256,
};

#ifndef _WIN32_WCE // OLE
/////////////////////////////////////////////////////////////////////////////
// COleDataObject -- simple wrapper for IDataObject

class COleDataObject
{
// Constructors
public:
	COleDataObject();

// Operations
	void Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease = TRUE);
	LPDATAOBJECT Detach();  // detach and get ownership of m_lpDataObject
	void Release(); // detach and Release ownership of m_lpDataObject
	BOOL AttachClipboard(); // attach to current clipboard object

// Attributes
	void BeginEnumFormats();
	BOOL GetNextFormat(LPFORMATETC lpFormatEtc);
	CFile* GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	HGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	BOOL GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);
	BOOL IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Implementation
public:
	LPDATAOBJECT m_lpDataObject;
	LPENUMFORMATETC m_lpEnumerator;
	~COleDataObject();

	// advanced use and implementation
	LPDATAOBJECT GetIDataObject(BOOL bAddRef);
	void EnsureClipboardObject();
	BOOL m_bClipboard;      // TRUE if represents the Win32 clipboard

protected:
	BOOL m_bAutoRelease;    // TRUE if destructor should call Release

private:
	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
	COleDataObject(const COleDataObject&);  // no implementation
	void operator=(const COleDataObject&);  // no implementation
};

/////////////////////////////////////////////////////////////////////////////
// COleDataSource -- wrapper for implementing IDataObject
//  (works similar to how data is provided on the clipboard)

struct AFX_DATACACHE_ENTRY;
class COleDropSource;

class COleDataSource : public CCmdTarget
{
// Constructors
public:
	COleDataSource();

// Operations
	void Empty();   // empty cache (similar to ::EmptyClipboard)

	// CacheData & DelayRenderData operations similar to ::SetClipboardData
	void CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal,
		LPFORMATETC lpFormatEtc = NULL);    // for HGLOBAL based data
	void DelayRenderFileData(CLIPFORMAT cfFormat,
		LPFORMATETC lpFormatEtc = NULL);    // for CFile* based delayed render

	// Clipboard and Drag/Drop access
	DROPEFFECT DoDragDrop(
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK,
		LPCRECT lpRectStartDrag = NULL,
		COleDropSource* pDropSource = NULL);
	void SetClipboard();
	static void PASCAL FlushClipboard();
	static COleDataSource* PASCAL GetClipboardOwner();

	// Advanced: STGMEDIUM based cached data
	void CacheData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);    // for LPSTGMEDIUM based data
	// Advanced: STGMEDIUM or HGLOBAL based delayed render
	void DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

	// Advanced: support for SetData in COleServerItem
	//  (not generally useful for clipboard or drag/drop operations)
	void DelaySetData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Overidables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// OnRenderFileData and OnRenderGlobalData are called by
		//  the default implementation of OnRenderData.

	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);
		// used only in COleServerItem implementation

// Implementation
public:
	virtual ~COleDataSource();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	AFX_DATACACHE_ENTRY* m_pDataCache;  // data cache itself
	UINT m_nMaxSize;    // current allocated size
	UINT m_nSize;       // current size of the cache
	UINT m_nGrowBy;     // number of cache elements to grow by for new allocs

	AFX_DATACACHE_ENTRY* Lookup(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir) const;
	AFX_DATACACHE_ENTRY* GetCacheEntry(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleDataSource, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServerItem;
};

//////////////////////////////////////////////////////////////////////////////
// DocItem support

class CDocItem : public CCmdTarget
{
	DECLARE_SERIAL(CDocItem)

// Constructors
protected:      // abstract class
	CDocItem();

// Attributes
public:
	CDocument* GetDocument() const; // return container document

// Overridables
public:
	// Raw data access (native format)
	virtual BOOL IsBlank() const;

// Implementation
protected:
	COleDocument* m_pDocument;

public:
	virtual void Serialize(CArchive& ar);   // for Native data
	virtual ~CDocItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class COleDocument;              // for access to back pointer
};

//////////////////////////////////////////////////////////////////////////////
// COleDocument - common OLE container behavior (enables server functionality)

class COleDocument : public CDocument
{
	DECLARE_DYNAMIC(COleDocument)

// Constructors
public:
	COleDocument();

// Attributes
	BOOL HasBlankItems() const; // check for BLANK items
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
		// return in-place active item for this view or NULL if none

// Operations
	// iterating over existing items
	virtual POSITION GetStartPosition() const;
	virtual CDocItem* GetNextItem(POSITION& pos) const;

	// iterator helpers (helpers use virtual GetNextItem above)
	COleClientItem* GetNextClientItem(POSITION& pos) const;
	COleServerItem* GetNextServerItem(POSITION& pos) const;

	// adding new items - called from item constructors
	virtual void AddItem(CDocItem* pItem);
	virtual void RemoveItem(CDocItem* pItem);

	void EnableCompoundFile(BOOL bEnable = TRUE);
		// enable compound file support (only call during constructor)
	virtual void UpdateModifiedFlag();
		// scan for modified items -- mark document modified

	// printer-device caching/control
	BOOL ApplyPrintDevice(const DVTARGETDEVICE* ptd);
	BOOL ApplyPrintDevice(const PRINTDLG* ppd);
		// these apply the target device to all COleClientItem objects

// Overridables
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
		// return primary selected item or NULL if none
	virtual void OnShowViews(BOOL bVisible);
		// called during app-idle when visibility of a document has changed

// Implementation
public:
	CObList m_docItemList;  // not owned items

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	CFrameWnd* GetFirstFrame();

	// document handling overrides
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
	virtual ~COleDocument();
	virtual void DeleteContents(); // delete client items in list
	virtual void Serialize(CArchive& ar);   // serialize items to file
	virtual void PreCloseFrame(CFrameWnd* pFrame);
	virtual BOOL SaveModified();
	virtual void OnIdle();

	// compound file implementation
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	void CommitItems(BOOL bSuccess, LPSTORAGE pNewStorage = NULL);    // called during File.Save & File.Save As

	// minimal linking protocol
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual LPOLEITEMCONTAINER GetContainer();

protected:
	// document state implementation
	UINT m_dwNextItemNumber;// serial number for next item in this document
	BOOL m_bLastVisible;    // TRUE if one or more views was last visible

	// 'docfile' support
	BOOL m_bCompoundFile;   // TRUE if use compound files
	LPSTORAGE m_lpRootStg;  // root storage for the document
	BOOL m_bSameAsLoad;     // TRUE = file-save, FALSE = Save [Copy] As
	BOOL m_bRemember;       // if FALSE, indicates Save Copy As

	DVTARGETDEVICE* m_ptd;  // current document target device

	// implementation helpers
	virtual void LoadFromStorage();
	virtual void SaveToStorage(CObject* pObject = NULL);
	CDocItem* GetNextItemOfKind(POSITION& pos, CRuntimeClass* pClass) const;

	// command handling
public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	afx_msg void OnUpdatePasteMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePasteLinkMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditLinksMenu(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	afx_msg void OnEditConvert();
	afx_msg void OnUpdateEditChangeIcon(CCmdUI* pCmdUI);
	afx_msg void OnEditChangeIcon();
	afx_msg void OnUpdateObjectVerbMenu(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();

	friend class COleClientItem;
	friend class COleServerItem;
};

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - Supports OLE2 non-inplace editing.
//      implements IOleClientSite, IAdviseSink, and IOleInPlaceSite

class COleFrameHook;    // forward reference (see ..\src\oleimpl2.h)

class COleClientItem : public CDocItem
{
	DECLARE_DYNAMIC(COleClientItem)

// Constructors
public:
	/* explicit */ COleClientItem(COleDocument* pContainerDoc = NULL);

	// create from the clipboard
	BOOL CreateFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from a class ID (Insert New Object dialog)
	BOOL CreateNewItem(REFCLSID clsid, OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from COleDataObject
	BOOL CreateFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from file (package support)
	BOOL CreateFromFile(LPCTSTR lpszFileName, REFCLSID clsid = CLSID_NULL,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromFile(LPCTSTR lpszFileName,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create a copy
	BOOL CreateCloneFrom(const COleClientItem* pSrcItem);

// General Attributes
public:
	HICON GetIconFromRegistry() const;
	static HICON GetIconFromRegistry(CLSID& clsid);
	SCODE GetLastStatus() const;
	OLE_OBJTYPE GetType() const; // OT_LINK, OT_EMBEDDED, OT_STATIC
	void GetClassID(CLSID* pClassID) const;
	void GetUserType(USERCLASSTYPE nUserClassType, CString& rString);
	BOOL GetExtent(LPSIZE lpSize, DVASPECT nDrawAspect = (DVASPECT)-1);
		// will return FALSE if item is BLANK
	BOOL GetCachedExtent(LPSIZE lpSize, DVASPECT nDrawAspect = (DVASPECT)-1);

	// getting/setting iconic cache
	HGLOBAL GetIconicMetafile();
	BOOL SetIconicMetafile(HGLOBAL hMetaPict);

	// setting/getting default display aspect
	DVASPECT GetDrawAspect() const;
	virtual void SetDrawAspect(DVASPECT nDrawAspect);

	// for printer presentation cache
	BOOL SetPrintDevice(const DVTARGETDEVICE* ptd);
	BOOL SetPrintDevice(const PRINTDLG* ppd);

	// Item state
	enum ItemState
		{ emptyState, loadedState, openState, activeState, activeUIState };
	UINT GetItemState() const;

	BOOL IsModified() const;
	BOOL IsRunning() const;
	BOOL IsInPlaceActive() const;
	BOOL IsOpen() const;
	CView* GetActiveView() const;

	// Data access
	void AttachDataObject(COleDataObject& rDataObject) const;

	// other rare access information
	COleDocument* GetDocument() const; // return container

	// helpers for checking clipboard data availability
	static BOOL PASCAL CanPaste();
	static BOOL PASCAL CanPasteLink();

	// helpers for checking COleDataObject, useful in drag drop
	static BOOL PASCAL CanCreateFromData(const COleDataObject* pDataObject);
	static BOOL PASCAL CanCreateLinkFromData(const COleDataObject* pDataObject);

// General Operations
	virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
		// cleanup, detach (close if needed)
	void Close(OLECLOSE dwCloseOption = OLECLOSE_SAVEIFDIRTY);
		// close without releasing the item
	void Delete(BOOL bAutoDelete = TRUE);
		// logically delete from file -- not part of the document anymore
	void Run(); // insure item is in running state

	// Drawing
	BOOL Draw(CDC* pDC, LPCRECT lpBounds,
		DVASPECT nDrawAspect = (DVASPECT)-1);   // defaults to m_nDrawAspect

	// Activation
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);
	void Activate(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

	// In-place Activation
	void Deactivate();          // completely deactivate
	void DeactivateUI();        // deactivate the user interface
	BOOL ReactivateAndUndo();   // reactivate then perform undo command
	BOOL SetItemRects(LPCRECT lpPosRect = NULL, LPCRECT lpClipRect = NULL);
	CWnd* GetInPlaceWindow();

	// Clipboard operations
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
	DROPEFFECT DoDragDrop(LPCRECT lpItemRect, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

	// called for creating a COleDataSource by CopyToClipboard and DoDragDrop
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);

	// Operations that apply to embedded items only
	void SetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj);
	void SetExtent(const CSize& size, DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// Operations that apply to linked items only
	//  (link options are rarely changed, except through Links dialog)
	OLEUPDATE GetLinkUpdateOptions();
	void SetLinkUpdateOptions(OLEUPDATE dwUpdateOpt);

	// Link-source update status (also useful for embeddings that contain links)
	BOOL UpdateLink();  // make up-to-date
	BOOL IsLinkUpToDate() const;    // is link up-to-date

	// object conversion
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld, REFCLSID clsidNew);
	BOOL Reload();  // for lazy reload after ActivateAs

// Overridables (notifications of IAdviseSink, IOleClientSite and IOleInPlaceSite)
	// Callbacks/notifications from the server you must/should implement
	virtual void OnChange(OLE_NOTIFICATION nCode, DWORD dwParam);
		// implement OnChange to invalidate when item changes

protected:
	virtual void OnGetItemPosition(CRect& rPosition);
		// implement OnGetItemPosition if you support in-place activation

	// Common overrides for in-place activation
	virtual BOOL OnScrollBy(CSize sizeExtent);

	// Common overrides for applications supporting undo
	virtual void OnDiscardUndoState();
	virtual void OnDeactivateAndUndo();

public:
	virtual void OnDeactivateUI(BOOL bUndoable);

protected:
	// Common overrides for applications supporting links to embeddings
	virtual void OnShowItem();

	// Advanced overrides for in-place activation
	virtual void OnGetClipRect(CRect& rClipRect);
	virtual BOOL CanActivate();

public:
	virtual void OnActivate();
	virtual void OnActivateUI();
	virtual void OnDeactivate();

protected:
	virtual BOOL OnGetWindowContext(CFrameWnd** ppMainFrame,
		CFrameWnd** ppDocFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
		// default calls SetItemRects and caches the pos rect

public:
	// Advanced overrides for menu/title handling (rarely overridden)
	virtual void OnInsertMenus(CMenu* pMenuShared,
		LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu,
		HWND hwndActiveObject);
	virtual void OnRemoveMenus(CMenu* pMenuShared);
	virtual BOOL OnUpdateFrameTitle();

	// Advanced override for control bar handling
	virtual BOOL OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);

// Implementation
public:
	// data to support non-inplace activated items
	LPOLEOBJECT m_lpObject; // in case you want direct access to the OLE object
	LPVIEWOBJECT2 m_lpViewObject;// IViewObject for IOleObject above
	DWORD m_dwItemNumber;   // serial number for this item in this document
	DVASPECT m_nDrawAspect; // current default display aspect
	SCODE m_scLast;         // last error code encountered
	LPSTORAGE m_lpStorage;  // provides storage for m_lpObject
	LPLOCKBYTES m_lpLockBytes;  // part of implementation of m_lpStorage
	DWORD m_dwConnection;   // advise connection to the m_lpObject
	BYTE m_bLinkUnavail;    // TRUE if link is currently unavailable
	BYTE m_bMoniker;        // TRUE if moniker is assigned
	BYTE m_bLocked;         // TRUE if object has external lock
	BYTE m_bNeedCommit;     // TRUE if need CommitItem
	BYTE m_bClosing;        // TRUE if currently doing COleClientItem::Close
	BYTE m_bReserved[3];    // (reserved for future use)

	// for compound file support
	LPSTORAGE m_lpNewStorage;   // used during Save As situations

	// item state & item type
	ItemState m_nItemState; // item state (see ItemState enumeration)
	OLE_OBJTYPE m_nItemType;    // item type (depends on how created)

	// data valid when in-place activated
	CView* m_pView; // view when object is in-place activated
	DWORD m_dwContainerStyle;   // style of the container wnd before activation
	COleFrameHook* m_pInPlaceFrame;// frame window when in-place active
	COleFrameHook* m_pInPlaceDoc;   // doc window when in-place (may be NULL)
	HWND m_hWndServer;  // HWND of in-place server window

public:
	virtual ~COleClientItem();
	virtual void Serialize(CArchive& ar);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	virtual BOOL ReportError(SCODE sc) const;
	virtual BOOL FreezeLink();  // converts to static: for edit links dialog

	DWORD GetNewItemNumber();   // generates new item number
	_AFX_INSECURE_DEPRECATE("COleClientItem::GetItemName(TCHAR *) is insecure. Instead use COleClientItem::GetItemName(TCHAR *, UINT *size)")
	void GetItemName(__out_z LPTSTR lpszItemName) const; // gets readable item name
	void GetItemName(__out_ecount_z(cchItemName) LPTSTR lpszItemName, UINT cchItemName) const;

	void UpdateItemType();  // update m_nItemType

protected:
	// clipboard helpers
	void GetEmbeddedItemData(LPSTGMEDIUM lpStgMedium);
	void AddCachedData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

	// interface helpers
	virtual LPOLECLIENTSITE GetClientSite();

	// helpers for printer-cached representation
	BOOL GetPrintDeviceInfo(LPOLECACHE* plpOleCache,
		DVTARGETDEVICE** pptd, DWORD* pdwConnection);

// Advanced Overridables for implementation
protected:
	virtual BOOL FinishCreate(SCODE sc);
	virtual void CheckGeneral(SCODE sc);

	virtual void OnDataChange(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium);

public:
	// for storage hookability (override to use 'docfiles')
	virtual void GetItemStorage();  // allocate storage for new item
	virtual void ReadItem(CArchive& ar);    // read item from archive
	virtual void WriteItem(CArchive& ar);   // write item to archive
	virtual void CommitItem(BOOL bSuccess); // commit item's storage

	// compound & flat file implementations of above
	void GetItemStorageFlat();
	void ReadItemFlat(CArchive& ar);
	void WriteItemFlat(CArchive& ar);
	void GetItemStorageCompound();
	void ReadItemCompound(CArchive& ar);
	void WriteItemCompound(CArchive& ar);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
		INIT_INTERFACE_PART(COleClientItem, OleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(GetContainer)(LPOLECONTAINER*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(OleClientSite)

	BEGIN_INTERFACE_PART(AdviseSink, IAdviseSink)
		INIT_INTERFACE_PART(COleClientItem, AdviseSink)
		STDMETHOD_(void,OnDataChange)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD_(void,OnViewChange)(DWORD, LONG);
		STDMETHOD_(void,OnRename)(LPMONIKER);
		STDMETHOD_(void,OnSave)();
		STDMETHOD_(void,OnClose)();
	END_INTERFACE_PART(AdviseSink)

	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
		INIT_INTERFACE_PART(COleClientItem, OleIPSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(OleIPSite)

	DECLARE_INTERFACE_MAP()

// Friendship declarations (to avoid many public members)
	friend class COleUIWindow;
	friend class COleFrameWindow;
	friend class COleLinkingDoc;
};

class COleDocObjectItem : public COleClientItem
{
	friend class COleFrameHook;
	DECLARE_DYNAMIC(COleDocObjectItem)

// Constructors
public:
	/* explicit */ COleDocObjectItem(COleDocument* pContainerDoc = NULL);

//Overridables
public:
	LPOLEDOCUMENTVIEW GetActiveView() const;
	virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
	virtual void OnInsertMenus(CMenu* pMenuShared,
		LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnRemoveMenus(CMenu *pMenuShared);

// Operations
public:
#ifndef _AFX_NO_PRINTING_SUPPORT
	static HRESULT DoDefaultPrinting(CView *pCaller, CPrintInfo *pInfo);
	static BOOL OnPreparePrinting(CView* pCaller, CPrintInfo* pInfo,
		BOOL bPrintAll = TRUE);
	static void OnPrint(CView* pCaller, CPrintInfo* pInfo,
		BOOL bPrintAll = TRUE);
#endif // _AFX_NO_PRINTING_SUPPORT
	BOOL GetPageCount(LPLONG pnFirstPage, LPLONG pcPages);
	HRESULT ExecCommand(DWORD nCmdID,
		DWORD nCmdExecOpt = OLECMDEXECOPT_DONTPROMPTUSER,
		const GUID* pguidCmdGroup = NULL);
	HRESULT QueryCommand(ULONG nCmdID,
			DWORD* pdwStatus,
			OLECMDTEXT* pCmdText=NULL,
			const GUID* pguidCmdGroup=NULL);

	//command routing of OLE commands
	DECLARE_OLECMD_MAP()
	BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
// Implementation
public:
	virtual ~COleDocObjectItem();
	CMenu* m_pHelpPopupMenu;

protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual CMenu* GetHelpMenu(UINT& nPosition);
	void ActivateAndShow();
	LPOLEDOCUMENTVIEW m_pActiveView;
	LPPRINT m_pIPrint;
	BOOL SupportsIPrint();
	BOOL m_bInHelpMenu;

	BEGIN_INTERFACE_PART(OleDocumentSite, IOleDocumentSite)
		INIT_INTERFACE_PART(COleDocObjectItem, OleDocumentSite)
		STDMETHOD(ActivateMe)(LPOLEDOCUMENTVIEW pViewToActivate);
	END_INTERFACE_PART(OleDocumentSite)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleServerItem - IOleObject & IDataObject OLE component

class AFX_NOVTABLE COleServerItem : public CDocItem
{
	DECLARE_DYNAMIC(COleServerItem)
protected:
	// NOTE: many members in this class are protected - since everything
	//   in this class is designed for implementing an OLE server.
	// Requests will come from OLE containers through non-C++ mechanisms,
	//   which will result in virtual functions in this class being called.

// Constructors
	COleServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete);
		// If your COleServerItem is an integral part of your data,
		//  bAutoDelete should be FALSE.  If your COleServerItem can be
		//  deleted when a link is released, it can be TRUE.

	COleDataSource* GetDataSource();
		// Use this data source to add conversion formats that your
		//  server should support.  Usually such formats are
		//  added in the item's constructor.

// Public Attributes
public:
	COleServerDoc* GetDocument() const; // return server document

	// naming (for links only)
	const CString& GetItemName() const; // get name of linked item
	void SetItemName(LPCTSTR lpszItemName);  // set name of linked item

	// link state
	BOOL IsConnected() const;   // returns TRUE if item has a client
	BOOL IsLinkedItem() const;  // returns TRUE if item is not embedded item

	// extents
	CSize m_sizeExtent;
		// HIMETRIC size -- the default implementation of OnSetExtent
		//  updates this member variable.  This member tells the server how
		//  much of the object is visible in the container document.

// Operations
public:
	void NotifyChanged(DVASPECT nDrawAspect = DVASPECT_CONTENT);
		// call this after you change item
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
		// helper for implementing server 'copy to clipboard'
	DROPEFFECT DoDragDrop(LPCRECT lpRectItem, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

// Overridables
	// overridables you must implement for yourself
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize) = 0;
		// drawing for metafile format (return FALSE if not supported or error)
		//  (called for DVASPECT_CONTENT only)

	// overridables you may want to implement yourself
	virtual void OnUpdate(COleServerItem* pSender,
		LPARAM lHint, CObject* pHint, DVASPECT nDrawAspect);
		// the default implementation always calls NotifyChanged

	virtual BOOL OnDrawEx(CDC* pDC, DVASPECT nDrawAspect, CSize& rSize);
		// advanced drawing -- called for DVASPECT other than DVASPECT_CONTENT
	virtual BOOL OnSetExtent(DVASPECT nDrawAspect, const CSize& size);
	virtual BOOL OnGetExtent(DVASPECT nDrawAspect, CSize& rSize);
		// default implementation uses m_sizeExtent

	// overridables you do not have to implement
	virtual void OnDoVerb(LONG iVerb);
		// default routes to OnShow &/or OnOpen
	virtual BOOL OnSetColorScheme(const LOGPALETTE* lpLogPalette);
		// default does nothing
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);
		// called for access to clipboard data
	virtual BOOL OnQueryUpdateItems();
		// called to determine if there are any contained out-of-date links
	virtual void OnUpdateItems();
		// called to update any out-of-date links

protected:
	virtual void OnShow();
		// show item in the user interface (may edit in-place)
	virtual void OnOpen();
		// show item in the user interface (must open fully)
	virtual void OnHide();
		// hide document (and sometimes application)

	// very advanced overridables
public:
	virtual BOOL OnInitFromData(COleDataObject* pDataObject, BOOL bCreation);
		// initialize object from IDataObject

	// see COleDataSource for a description of these overridables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// HGLOBAL version will be called first, then CFile* version

	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL bRelease);
		// Rare -- only if you support SetData (programmatic paste)

	// advanced helpers for CopyToClipboard
	void GetEmbedSourceData(LPSTGMEDIUM lpStgMedium);
	void AddOtherClipboardData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

// Implementation
public:
	BOOL m_bNeedUnlock;             // if TRUE need to pDoc->LockExternal(FALSE)
	BOOL m_bAutoDelete;             // if TRUE will OnRelease will 'delete this'

	// special version of OnFinalRelease to implement document locking
	virtual void OnFinalRelease();

protected:
	CString m_strItemName;          // simple item name

public:
	LPOLEADVISEHOLDER m_lpOleAdviseHolder;  // may be NULL
	LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // may be NULL

	virtual ~COleServerItem() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation helpers
	void NotifyClient(OLE_NOTIFICATION wNotification, DWORD_PTR dwParam);
	LPDATAOBJECT GetDataObject();
	LPOLEOBJECT GetOleObject();
	LPMONIKER GetMoniker(OLEGETMONIKER nAssign);

protected:
	virtual BOOL GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM pmedium);
		// calls OnDraw or OnDrawEx
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);
	virtual BOOL IsBlank() const;

	// CItemDataSource implements OnRender reflections to COleServerItem
	class CItemDataSource : public COleDataSource
	{
	protected:
		// the GetData and SetData interfaces forward to m_pItem
		virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
		virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
		virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
			// HGLOBAL version will be called first, then CFile* version

		virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
			BOOL bRelease);
	};
	CItemDataSource m_dataSource;
		// data source used to implement IDataObject

// Interface Maps
//  (Note: these interface maps are used just for link implementation)
public:
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleServerItem, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(LPENUMOLEVERB*);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(LPCLSID);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleServerItem, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class CItemDataSource;
	friend class COleServerDoc;
	friend class COleLinkingDoc;
};

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc -
//  (enables linking to embeddings - beginnings of server fuctionality)

class COleLinkingDoc : public COleDocument
{
	DECLARE_DYNAMIC(COleLinkingDoc)

// Constructors
public:
	COleLinkingDoc();

// Operations
	BOOL Register(COleObjectFactory* pFactory, LPCTSTR lpszPathName);
		// notify the running object table and connect to pServer
	void Revoke();
		// revoke from running object table

// Overridables
protected:
	virtual COleServerItem* OnGetLinkedItem(LPCTSTR lpszItemName);
		// return item for the named linked item (for supporting links)
	virtual COleClientItem* OnFindEmbeddedItem(LPCTSTR lpszItemName);
		// return item for the named embedded item (for links to embeddings)

// Implementation
public:
	COleObjectFactory* m_pFactory;  // back-pointer to server

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleLinkingDoc();

	// overrides for updating of monikers & running object table registration
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual LPOLEITEMCONTAINER GetContainer();
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);

	// special handling of error messages during save/load
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
		CException* e, BOOL bSaving, UINT nIDPDefault);
	void BeginDeferErrors();
	SCODE EndDeferErrors(SCODE sc);

protected:
	BOOL m_bDeferErrors;    // TRUE if in non-interactive OLE mode
	CException* m_pLastException;

	DWORD m_dwRegister;     // file moniker's registration in the ROT
	LPMONIKER m_lpMonikerROT; // file moniker that is registered
	CString m_strMoniker;   // filename used to create moniker
	BOOL m_bVisibleLock;    // TRUE if user is holding lock on document

	// implementation helpers
	virtual BOOL RegisterIfServerAttached(LPCTSTR lpszPathName, BOOL bMessage);
	void LockExternal(BOOL bLock, BOOL bRemoveRefs);
	void UpdateVisibleLock(BOOL bVisible, BOOL bRemoveRefs);
	virtual void OnShowViews(BOOL bVisible);

	virtual void SaveToStorage(CObject* pObject = NULL);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PersistFile, IPersistFile)
		INIT_INTERFACE_PART(COleLinkingDoc, PersistFile)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPCOLESTR, DWORD);
		STDMETHOD(Save)(LPCOLESTR, BOOL);
		STDMETHOD(SaveCompleted)(LPCOLESTR);
		STDMETHOD(GetCurFile)(LPOLESTR*);
	END_INTERFACE_PART(PersistFile)

	BEGIN_INTERFACE_PART(OleItemContainer, IOleItemContainer)
		INIT_INTERFACE_PART(COleLinkingDoc, OleItemContainer)
		STDMETHOD(ParseDisplayName)(LPBC, LPOLESTR, ULONG*, LPMONIKER*);
		STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
		STDMETHOD(LockContainer)(BOOL);
		STDMETHOD(GetObject)(LPOLESTR, DWORD, LPBINDCTX, REFIID, LPVOID*);
		STDMETHOD(GetObjectStorage)(LPOLESTR, LPBINDCTX, REFIID, LPVOID*);
		STDMETHOD(IsRunning)(LPOLESTR);
	END_INTERFACE_PART(OleItemContainer)

	DECLARE_INTERFACE_MAP()

	friend class COleClientItem;
	friend class COleClientItem::XOleClientSite;
	friend class COleServerItem::XOleObject;
};

//////////////////////////////////////////////////////////////////////////////
// COleServerDoc - registered server document containing COleServerItems

class AFX_NOVTABLE COleServerDoc : public COleLinkingDoc
{
	DECLARE_DYNAMIC(COleServerDoc)

// Constructors and Destructors
public:
	COleServerDoc();

// Attributes
	BOOL IsEmbedded() const;    // TRUE if document is an embedding
	BOOL IsDocObject() const;   // TRUE if document is a DocObject
	COleServerItem* GetEmbeddedItem();
		// return embedded item for document (will allocate if necessary)

	// attributes specific to in-place activation
	BOOL IsInPlaceActive() const;
	void GetItemPosition(LPRECT lpPosRect) const;
		// get current position rectangle of in-place edit
	void GetItemClipRect(LPRECT lpClipRect) const;
		// get current clipping rectangle of in-place edit
	BOOL GetZoomFactor(LPSIZE lpSizeNum = NULL, LPSIZE lpSizeDenom = NULL,
		LPCRECT lpPosRect = NULL) const;
		// returns the zoom factor in pixels

// Operations
	void NotifyChanged();
		// call this after you change some global attribute like
		//  document dimensions
	void UpdateAllItems(COleServerItem* pSender,
		LPARAM lHint = 0L, CObject* pHint = NULL,
		DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// changes to the entire document (automatically notifies clients)
	void NotifyRename(LPCTSTR lpszNewName);
	void NotifySaved();
	void NotifyClosed();        // call this after you close document

	// specific operations for embedded documents
	void SaveEmbedding();       // call this to save embedded (before closing)

	// specific to in-place activation
	BOOL ActivateInPlace();
	void ActivateDocObject();
	void RequestPositionChange(LPCRECT lpPosRect);
	BOOL ScrollContainerBy(CSize sizeScroll);
	BOOL DeactivateAndUndo();
	BOOL DiscardUndoState();

public:
// Overridables for standard user interface (full server)
	virtual BOOL OnUpdateDocument(); // implementation of embedded update

protected:
// Overridables you must implement for yourself
	virtual COleServerItem* OnGetEmbeddedItem() = 0;
		// return item representing entire (embedded) document

// Overridables you do not have to implement
	virtual void OnClose(OLECLOSE dwCloseOption);
	virtual void OnSetHostNames(LPCTSTR lpszHost, LPCTSTR lpszHostObj);
	virtual HRESULT OnExecOleCmd(const GUID* pguidCmdGroup, DWORD nCmdID,
		DWORD nCmdExecOpt, VARIANTARG* pvarargIn, VARIANTARG* pvarargOut);
	virtual CDocObjectServer* GetDocObjectServer(LPOLEDOCUMENTSITE pDocSite);

// Advanced overridables
	LPUNKNOWN GetInterfaceHook(const void* piid);
	virtual void OnShowDocument(BOOL bShow);
		// show first frame for document or hide all frames for document

// Advanced overridables for in-place activation
public:
	virtual void OnDeactivate();
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void OnDocWindowActivate(BOOL bActivate);
	virtual void OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);

protected:
	virtual void OnSetItemRects(LPCRECT lpPosRect, LPCRECT lpClipRect);
	virtual BOOL OnReactivateAndUndo();

	virtual void OnFrameWindowActivate(BOOL bActivate);

	virtual COleIPFrameWnd* CreateInPlaceFrame(CWnd* pParentWnd);
	virtual void DestroyInPlaceFrame(COleIPFrameWnd* pFrameWnd);
public:
	virtual void OnResizeBorder(LPCRECT lpRectBorder,
		LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame);

	LPOLECLIENTSITE GetClientSite() const;
// Implementation
protected:
	LPOLECLIENTSITE m_lpClientSite;     // for embedded item
	CString m_strHostObj;               // name of document in container
	BOOL m_bCntrVisible;                // TRUE if OnShowWindow(TRUE) called
	BOOL m_bClosing;                    // TRUE if shutting down
	COleServerItem* m_pEmbeddedItem;    // pointer to embedded item for document

	COleIPFrameWnd* m_pInPlaceFrame;    // not NULL if in-place activated
	CWnd* m_pOrigParent;                // not NULL if existing view used
	DWORD m_dwOrigStyle;                // original style of in-place view
	DWORD m_dwOrigStyleEx;              // original extended style

	CDocObjectServer* m_pDocObjectServer;  // if DocObject, ptr to doc site

public:
	virtual ~COleServerDoc() = 0;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// overridables for implementation
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual void DeleteContents(); // delete auto-delete server items
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual COleServerItem* OnGetLinkedItem(LPCTSTR lpszItemName);
		// return item for the named linked item (only if supporting links)
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);

protected:
	// overrides to handle server user-interface
	virtual BOOL SaveModified();        // return TRUE if ok to continue
	virtual HMENU GetDefaultMenu();     // return menu based on doc type
	virtual HACCEL GetDefaultAccelerator(); // return accel table based on doc type
	virtual BOOL GetFileTypeString(CString& rString);

	// IPersistStorage implementation
	virtual void OnNewEmbedding(LPSTORAGE lpStorage);
	virtual void OnOpenEmbedding(LPSTORAGE lpStorage);
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);

	// Implementation helpers
	void NotifyAllItems(OLE_NOTIFICATION wNotification, DWORD_PTR dwParam);
	BOOL SaveModifiedPrompt();
	void ConnectView(CWnd* pParentWnd, CView* pView);
	void UpdateUsingHostObj(UINT nIDS, CCmdUI* pCmdUI);

// Message Maps
	//{{AFX_MSG(COleServerDoc)
	afx_msg void OnFileUpdate();
	afx_msg void OnFileSaveCopyAs();
	afx_msg void OnUpdateFileUpdate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileExit(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
public:
	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		INIT_INTERFACE_PART(COleServerDoc, PersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART(PersistStorage)

	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		INIT_INTERFACE_PART(COleServerDoc, OleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE*);
		STDMETHOD(SetHostNames)(LPCOLESTR, LPCOLESTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB**);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID*);
		STDMETHOD(GetUserType)(DWORD, LPOLESTR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		INIT_INTERFACE_PART(COleServerDoc, DataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA*);
	END_INTERFACE_PART(DataObject)

	BEGIN_INTERFACE_PART(OleInPlaceObject, IOleInPlaceObject)
		INIT_INTERFACE_PART(COleServerDoc, OleInPlaceObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
	END_INTERFACE_PART(OleInPlaceObject)

	BEGIN_INTERFACE_PART(OleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleServerDoc, OleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(OleInPlaceActiveObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServer;
	friend class COleServerItem;
	friend class CDocObjectServer;
};

//////////////////////////////////////////////////////////////////////////////
// COleIPFrameWnd

class COleCntrFrameWnd;

class COleIPFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(COleIPFrameWnd)

// Constructors
public:
	COleIPFrameWnd();

// Overridables
public:
	virtual BOOL OnCreateControlBars(CWnd* pWndFrame, CWnd* pWndDoc);
		// create control bars on container windows (pWndDoc can be NULL)
	virtual BOOL OnCreateControlBars(CFrameWnd* pWndFrame, CFrameWnd* pWndDoc);
		// create control bars on container windows (pWndDoc can be NULL)

	virtual void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);
		// Advanced: reposition frame to wrap around new lpPosRect

// Implementation
public:
	BOOL m_bUIActive;   // TRUE if currently in uiacitve state

	virtual BOOL LoadFrame(UINT nIDResource,
		DWORD dwDefaultStyle = WS_CHILD|WS_BORDER|WS_CLIPSIBLINGS,
		CWnd* pParentWnd = NULL,
		CCreateContext* pContext = NULL);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	virtual ~COleIPFrameWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	CFrameWnd* GetDocFrame();
	CFrameWnd* GetMainFrame();
	HRESULT GetInPlaceFrame(LPOLEINPLACEUIWINDOW *ppUIWindow);
	HRESULT GetInPlaceDocFrame(LPOLEINPLACEUIWINDOW *ppUIWindow);
	void SetPreviewMode(BOOL bNewMode);

protected:
	// in-place state
	OLEINPLACEFRAMEINFO m_frameInfo;
	LPOLEINPLACEFRAME m_lpFrame;
	LPOLEINPLACEUIWINDOW m_lpDocFrame;
	COleCntrFrameWnd* m_pMainFrame;
	COleCntrFrameWnd* m_pDocFrame;

	HMENU m_hSharedMenu;
	OLEMENUGROUPWIDTHS m_menuWidths;
	HOLEMENU m_hOleMenu;
	CRect m_rectPos;            // client area rect of the item
	CRect m_rectClip;           // area to which frame should be clipped
	BOOL m_bInsideRecalc;
	BOOL m_bPreviewMode;
	HMENU m_hMenuHelpPopup;

	HMENU _m_Reserved;

	// Advanced: in-place activation virtual implementation
	virtual BOOL BuildSharedMenu();
	virtual void DestroySharedMenu();
	virtual HMENU GetInPlaceMenu();

	// Advanced: possible override to change in-place sizing behavior
	virtual void OnRequestPositionChange(LPCRECT lpRect);

protected:
	//{{AFX_MSG(COleIPFrameWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnRecalcParent(WPARAM wParam, LPARAM lParam);
	afx_msg void OnIdleUpdateCmdUI();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg void OnContextHelp();
	afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnBarCheck(UINT nID);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class COleServerDoc;
	friend class COleCntrFrameWnd;
	friend class CDocObjectServer;
};

/////////////////////////////////////////////////////////////////////////////
// COleResizeBar - supports in-place resizing in server applications

class COleResizeBar : public CControlBar
{
	DECLARE_DYNAMIC(COleResizeBar)

// Constructors
public:
	COleResizeBar();
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE,
		UINT nID = AFX_IDW_RESIZE_BAR);

// Implementation
public:
	virtual ~COleResizeBar();
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
	CRectTracker m_tracker;     // implemented with a tracker

protected:
	//{{AFX_MSG(COleResizeBar)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDown(UINT, CPoint point);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile - implementation of CFile which uses an IStream

class COleStreamFile : public CFile
{
	DECLARE_DYNAMIC(COleStreamFile)

private:
   using CFile::Open;

// Constructors and Destructors
public:
	/* explicit */ COleStreamFile(LPSTREAM lpStream = NULL);

// Operations
	// Note: OpenStream and CreateStream can accept eith STGM_ flags or
	//  CFile::OpenFlags bits since common values are guaranteed to have
	//  the same semantics.
	BOOL OpenStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive,
		CFileException* pError = NULL);
	BOOL CreateStream(LPSTORAGE lpStorage, LPCTSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive|modeCreate,
		CFileException* pError = NULL);

	BOOL CreateMemoryStream(CFileException* pError = NULL);

	// attach & detach can be used when Open/Create functions aren't adequate
	void Attach(LPSTREAM lpStream);
	LPSTREAM Detach();

	IStream* GetStream() const;
	// Returns the current stream

// Implementation
public:
	LPSTREAM m_lpStream;
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	virtual ~COleStreamFile();

	// attributes for implementation
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual ULONGLONG GetPosition() const;

	virtual const CString GetStorageName() const;

	// overrides for implementation
	virtual CFile* Duplicate() const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

protected:
	CString m_strStorageName;
};

#ifndef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// CMonikerFile - implementation of COleStreamFile that uses an IMoniker to
//                get the IStream

class CMonikerFile: public COleStreamFile
{
	DECLARE_DYNAMIC(CMonikerFile)

private:
   using COleStreamFile::Open;

public:
	CMonikerFile();

	virtual BOOL Open(LPCTSTR lpszURL, CFileException* pError=NULL);
	// Uses synchronous URLMonikers to create a moniker.
	// Opens the URL specified.
	// If provided, pError will be set in case of error.
	// Return value: TRUE if successful, FALSE otherwise.

	virtual BOOL Open(IMoniker* pMoniker, CFileException* pError=NULL);
	// Binds to the provided moniker to obtain a stream.
	// If provided, pError will be set in case of error.
	// Return value: TRUE if successful, FALSE otherwise.

	virtual void Close();
	// Detaches the stream, Release()s it, and the moniker.  Close may be
	// called on unopened, or already closed streams.

	BOOL Detach(CFileException* pError = NULL);
	// Closes the stream.  If there is an error when closing, then the
	// error code will be placed in pError and the function will return FALSE.

	IMoniker* GetMoniker() const;
	// Returns the current moniker.  The moniker returned is not AddRef()'ed.

protected:
// Overidables
	IBindCtx* CreateBindContext(CFileException* pError);
	// A hook so users can provide a particular IBindCtx, potentially one
	// on which the user has registered one or more objects.

// Implementation
protected:
	virtual BOOL Open(LPCTSTR lpszUrl, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);
	BOOL Attach(LPCTSTR lpszUrl, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);
	virtual BOOL Open(IMoniker* pMoniker, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);

	BOOL Attach(IMoniker* pMoniker, IBindHost* pBindHost,
		IBindStatusCallback* pBSC, IBindCtx* pBindCtx, CFileException* pError);

	virtual BOOL PostBindToStream(CFileException* pError);

	static IBindHost* CreateBindHost();
public:
	virtual ~CMonikerFile();
	// Closes the stream, and releases the moniker if needed.

	virtual void Flush();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	// Calls COleStreamFile::Dump(), and prints out moniker value.
#endif

protected:
	IPTR(IMoniker) m_Moniker;
	// The moniker provided or created to which this class is bound.

	CMonikerFile(const CMonikerFile&);
	// Prevents copying.
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncMonikerFile - implementation of COleStreamFile that uses an
//                     asynchronous IMoniker to get the IStream

class _AfxBindStatusCallback; // Forward declaration

class CAsyncMonikerFile: public CMonikerFile
{
	DECLARE_DYNAMIC(CAsyncMonikerFile)

private:
   using CMonikerFile::Open;

public:
	CAsyncMonikerFile();
	// Creates the IBindStatusCallback used internally to provide asynchronous
	// operation.

	//All Open overloads call one of these two.
	virtual BOOL Open(LPCTSTR lpszURL, IBindHost* pBindHost,
		CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IBindHost* pBindHost,
		CFileException* pError=NULL);

	//Open overloads that take monikers
	virtual BOOL Open(IMoniker* pMoniker, CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IServiceProvider* pServiceProvider,
		CFileException* pError=NULL);
	virtual BOOL Open(IMoniker* pMoniker, IUnknown* pUnknown,
		CFileException* pError=NULL);

	//Open overloads that take strings
	virtual BOOL Open(LPCTSTR lpszURL, CFileException* pError=NULL);
	virtual BOOL Open(LPCTSTR lpszURL, IServiceProvider* pServiceProvider,
		CFileException* pError=NULL);
	virtual BOOL Open(LPCTSTR lpszURL, IUnknown* pUnknown,
		CFileException* pError=NULL);

	virtual void Close();

	IBinding* GetBinding() const;
	// Returns the binding provided when the asychronous transfer begins.
	// With the IBinding*, the user may abort, or pause the transfer.
	// NULL may be returned if for any reason the transfer could not be
	// made asynchronous, or if the IBinding* has not yet been provided by
	// the system.

	FORMATETC* GetFormatEtc() const;
	// Returns the FORMATETC for the currently opened stream.  NULL will be
	// returned if this is called from outside the context of OnDataAvailable.
	// If you want to keep the FORMATETC beyond this call, make a copy of it.
	// The FORMATETC indicates the format of the data in the stream.

protected:
// Overidables
	virtual IUnknown* CreateBindStatusCallback(IUnknown* pUnkControlling);

	virtual DWORD GetBindInfo() const;
	// Returns the settings returned by IBindStatusCallback::GetBindInfo.
	// The default values returned should work for most cases and should not
	// be changed lightly.

	virtual LONG GetPriority() const;
	// Returns the priority at which the asynchronous transfer will take
	// place.  The value is one of the standard thread priority flags.
	// By default THREAD_PRIORITY_NORMAL is returned.

	virtual void OnDataAvailable(DWORD dwSize, DWORD bscfFlag);
	// Called when there is data available to be read.  dwSize indicates
	// the cumulative number of bytes which can be read.  The bscfFlag may be used
	// to identify first, last, and intermediate blocks of data.

	virtual void OnLowResource();
	// This is called when resources are low.

	virtual void OnStartBinding();
	// Called when the binding is starting up.

	virtual void OnProgress(ULONG ulProgress, ULONG ulProgressMax,
		ULONG ulStatusCode, LPCTSTR szStatusText);

	virtual void OnStopBinding(HRESULT hresult, LPCTSTR szError);
	// Called when the transfer is stopped.  This function releases the
	// IBinding and should nearly always be call when overidden.

// Implementation
public:
	virtual ~CAsyncMonikerFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	// Calls CMonikerFile::Dump(), and prints out IBinding,
	// IBindStatusCallback, and m_pFormatEtc values.
#endif
	virtual UINT Read(void* lpBuf, UINT nCount);

protected:
	friend class _AfxBindStatusCallback;
	_AfxBindStatusCallback* m_pAfxBSCCurrent;
	BOOL m_bStopBindingReceived;
	void EndCallbacks();

	IPTR(IBinding) m_Binding;
	FORMATETC* m_pFormatEtc;

	void SetBinding(IBinding* pBinding);
	// Sets and AddRefs m_Binding

	void SetFormatEtc(FORMATETC* pFormatEtc);
	// Sets the FORMATETC for the current stream.

	virtual BOOL PostBindToStream(CFileException* pError);
};

/////////////////////////////////////////////////////////////////////////////
// COleDropSource (advanced drop source support)

class COleDropSource : public CCmdTarget
{
// Constructors
public:
	COleDropSource();

// Overridables
	virtual SCODE QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState);
	virtual SCODE GiveFeedback(DROPEFFECT dropEffect);
	virtual BOOL OnBeginDrag(CWnd* pWnd);

// Implementation
public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	BEGIN_INTERFACE_PART(DropSource, IDropSource)
		INIT_INTERFACE_PART(COleDropSource, DropSource)
		STDMETHOD(QueryContinueDrag)(BOOL, DWORD);
		STDMETHOD(GiveFeedback)(DWORD);
	END_INTERFACE_PART(DropSource)

	DECLARE_INTERFACE_MAP()

	CRect m_rectStartDrag;  // when mouse leaves this rect, drag drop starts
	BOOL m_bDragStarted;    // has drag really started yet?
	DWORD m_dwButtonCancel; // which button will cancel (going down)
	DWORD m_dwButtonDrop;   // which button will confirm (going up)

	// metrics for drag start determination
	static AFX_DATA UINT nDragMinDist;  // min. amount mouse must move for drag
	static AFX_DATA UINT nDragDelay;    // delay before drag starts

	friend class COleDataSource;
};

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget (advanced drop target support)

class COleDropTarget : public CCmdTarget
{
// Constructors
public:
	COleDropTarget();

// Operations
	BOOL Register(CWnd* pWnd);
	virtual void Revoke();  // virtual for implementation

// Overridables
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual DROPEFFECT OnDragScroll(CWnd* pWnd, DWORD dwKeyState,
		CPoint point);

// Implementation
public:
	virtual ~COleDropTarget();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HWND m_hWnd;            // HWND this IDropTarget is attached to
	LPDATAOBJECT m_lpDataObject;    // != NULL between OnDragEnter, OnDragLeave
	UINT m_nTimerID;        // != MAKEWORD(-1, -1) when in scroll area
	DWORD m_dwLastTick;     // only valid when m_nTimerID valid
	UINT m_nScrollDelay;    // time to next scroll

	// metrics for drag-scrolling
	static AFX_DATA int nScrollInset;
	static AFX_DATA UINT nScrollDelay;
	static AFX_DATA UINT nScrollInterval;

	// implementation helpers
	void SetupTimer(CView* pView, UINT nTimerID);
	void CancelTimer(CWnd* pWnd);

// Interface Maps
public:
	BEGIN_INTERFACE_PART(DropTarget, IDropTarget)
		INIT_INTERFACE_PART(COleDropTarget, DropTarget)
		STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
		STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
		STDMETHOD(DragLeave)();
		STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
	END_INTERFACE_PART(DropTarget)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter (implements IMessageFilter)

class COleMessageFilter : public CCmdTarget
{
// Constructors
public:
	COleMessageFilter();

// Operations
	BOOL Register();
	void Revoke();

	// for controlling the busy state of the server application (called app)
	virtual void BeginBusyState();
	virtual void EndBusyState();
	void SetBusyReply(SERVERCALL nBusyReply);

	// for controlling actions taken against rejected/retried calls
	void SetRetryReply(DWORD nRetryReply = 0);
		// only used when the "not responding" dialog is disabled
	void SetMessagePendingDelay(DWORD nTimeout = 5000);
		// used to determine amount of time before significant message
	void EnableBusyDialog(BOOL bEnableBusy = TRUE);
	void EnableNotRespondingDialog(BOOL bEnableNotResponding = TRUE);
		// used to enable/disable the two types of busy dialogs

// Overridables
	virtual BOOL OnMessagePending(const MSG* pMsg);
		// return TRUE to eat the message (usually only if processed)

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleMessageFilter();
	virtual BOOL IsSignificantMessage(MSG* pMsg);
		// determine if any significant messages are present in the queue
	virtual int OnBusyDialog(HTASK htaskBusy);
	virtual int OnNotRespondingDialog(HTASK htaskBusy);
		// these functions display the busy dialog

protected:
	BOOL m_bRegistered;
	LONG m_nBusyCount;  // for BeginBusyState & EndBusyState
	BOOL m_bEnableBusy;
	BOOL m_bEnableNotResponding;
	BOOL m_bUnblocking;
	DWORD m_nRetryReply;    // only used if m_bEnableNotResponding == FALSE
	DWORD m_nBusyReply;
	DWORD m_nTimeout;

// Interface Maps
public:
	BEGIN_INTERFACE_PART(MessageFilter, IMessageFilter)
		INIT_INTERFACE_PART(COleMessageFilter, MessageFilter)
		STDMETHOD_(DWORD, HandleInComingCall)(DWORD, HTASK, DWORD,
			LPINTERFACEINFO);
		STDMETHOD_(DWORD, RetryRejectedCall)(HTASK, DWORD, DWORD);
		STDMETHOD_(DWORD, MessagePending)(HTASK, DWORD, DWORD);
	END_INTERFACE_PART(MessageFilter)

	DECLARE_INTERFACE_MAP()
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// message map entries for OLE verbs

#define ON_STDOLEVERB(iVerb, memberFxn) \
	{ 0xC002, 0, (UINT)iVerb, (UINT)iVerb, (UINT)-1, \
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(LPMSG, HWND, LPCRECT))&memberFxn },

#define ON_OLEVERB(idsVerbName, memberFxn) \
	{ 0xC002, 0, 1, 1, idsVerbName, \
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(LPMSG, HWND, LPCRECT))&memberFxn },

/////////////////////////////////////////////////////////////////////////////
// global helpers and debugging

#ifndef _WIN32_WCE
void AFXAPI AfxOleSetEditMenu(COleClientItem* pClient, CMenu* pMenu,
	UINT iMenuItem, UINT nIDVerbMin, UINT nIDVerbMax = 0, UINT nIDConvert = 0);
#endif // !_WIN32_WCE

#ifdef _DEBUG
// Mapping SCODEs to readable text
LPCTSTR AFXAPI AfxGetFullScodeString(SCODE sc);
LPCTSTR AFXAPI AfxGetScodeString(SCODE sc);
LPCTSTR AFXAPI AfxGetScodeRangeString(SCODE sc);
LPCTSTR AFXAPI AfxGetSeverityString(SCODE sc);
LPCTSTR AFXAPI AfxGetFacilityString(SCODE sc);

// Mapping IIDs to readable text
LPCTSTR AFXAPI AfxGetIIDString(REFIID iid);
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXOLE_INLINE AFX_INLINE
#define _AFXOLECLI_INLINE AFX_INLINE
#define _AFXOLESVR_INLINE AFX_INLINE
#define _AFXOLEDOBJ_INLINE AFX_INLINE
#define _AFXOLEMONIKER_INLINE AFX_INLINE
#include <afxole.inl>
#undef _AFXOLE_INLINE
#undef _AFXOLECLI_INLINE
#undef _AFXOLESVR_INLINE
#undef _AFXOLEDOBJ_INLINE
#undef _AFXOLEMONIKER_INLINE
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXOLE_H__

/////////////////////////////////////////////////////////////////////////////x
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxole.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXOLE.H

// more than one _INLINE type; can't use #pragma once

/////////////////////////////////////////////////////////////////////////////
// General OLE inlines (CDocItem, COleDocument)

#ifndef _WIN32_WCE // OLE
#ifdef _AFXOLE_INLINE

// CDocItem
_AFXOLE_INLINE CDocument* CDocItem::GetDocument() const
	{ return m_pDocument; }

// COleDocument
_AFXOLE_INLINE void COleDocument::EnableCompoundFile(BOOL bEnable)
	{ m_bCompoundFile = bEnable; }

// COleMessageFilter
_AFXOLE_INLINE void COleMessageFilter::SetBusyReply(SERVERCALL nBusyReply)
	{ ASSERT_VALID(this); m_nBusyReply = nBusyReply; }
_AFXOLE_INLINE void COleMessageFilter::SetRetryReply(DWORD nRetryReply)
	{ ASSERT_VALID(this); m_nRetryReply = nRetryReply; }
_AFXOLE_INLINE void COleMessageFilter::SetMessagePendingDelay(DWORD nTimeout)
	{ ASSERT_VALID(this); m_nTimeout = nTimeout; }
_AFXOLE_INLINE void COleMessageFilter::EnableBusyDialog(BOOL bEnable)
	{ ASSERT_VALID(this); m_bEnableBusy = bEnable; }
_AFXOLE_INLINE void COleMessageFilter::EnableNotRespondingDialog(BOOL bEnable)
	{ ASSERT_VALID(this); m_bEnableNotResponding = bEnable; }

#endif //_AFXOLE_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE Moniker inlines

#ifdef _AFXOLEMONIKER_INLINE

// CMonikerFile
_AFXOLEMONIKER_INLINE CMonikerFile::CMonikerFile() { }
_AFXOLEMONIKER_INLINE IMoniker* CMonikerFile::GetMoniker() const
	{ ASSERT_VALID(this); return m_Moniker; }

// CAsyncMonikerFile
_AFXOLEMONIKER_INLINE IBinding* CAsyncMonikerFile::GetBinding() const
	{ ASSERT_VALID(this); return m_Binding; }
_AFXOLEMONIKER_INLINE void CAsyncMonikerFile::SetBinding(IBinding* pBinding)
	{ ASSERT_VALID(this); m_Binding=pBinding; }
_AFXOLEMONIKER_INLINE void CAsyncMonikerFile::SetFormatEtc(FORMATETC* pFormatEtc)
	{ ASSERT_VALID(this); m_pFormatEtc=pFormatEtc; }
_AFXOLEMONIKER_INLINE FORMATETC* CAsyncMonikerFile::GetFormatEtc() const
	{ ASSERT_VALID(this); return m_pFormatEtc; }

#endif //_AFXOLEMONIKER_INLINE
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// OLE automation inlines

#ifdef _AFXDISP_INLINE

// COleException
_AFXDISP_INLINE COleException::COleException()
	{ m_sc = S_OK; }
_AFXDISP_INLINE COleException::~COleException()
	{ }

// CCmdTarget
_AFXDISP_INLINE DWORD CCmdTarget::InternalAddRef()
	{ ASSERT(GetInterfaceMap() != NULL); return ::InterlockedIncrement(&m_dwRef); }

// CObjectFactory
_AFXDISP_INLINE BOOL COleObjectFactory::IsRegistered() const
	{ ASSERT_VALID(this); return m_dwRegister != 0; }
_AFXDISP_INLINE REFCLSID COleObjectFactory::GetClassID() const
	{ ASSERT_VALID(this); return m_clsid; }

// COleDispatchDriver
_AFXDISP_INLINE COleDispatchDriver::~COleDispatchDriver()
	{ ReleaseDispatch(); }
_AFXDISP_INLINE COleDispatchDriver::operator LPDISPATCH()
	{ return m_lpDispatch; }

// COleVariant
_AFXDISP_INLINE COleVariant::COleVariant()
	{ AfxVariantInit(this); }
_AFXDISP_INLINE COleVariant::~COleVariant()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE void COleVariant::Clear()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE COleVariant::COleVariant(LPCTSTR lpszSrc)
	{ vt = VT_EMPTY; *this = lpszSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(CString& strSrc)
	{ vt = VT_EMPTY; *this = strSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(BYTE nSrc)
	{ vt = VT_UI1; bVal = nSrc; }
#ifndef _WIN32_WCE // OLE
_AFXDISP_INLINE COleVariant::COleVariant(const COleCurrency& curSrc)
	{ vt = VT_CY; cyVal = curSrc.m_cur; }
#endif // !_WIN32_WCE
#if (_WIN32_WINNT >= 0x0510) || defined(_ATL_SUPPORT_VT_I8)
_AFXDISP_INLINE COleVariant::COleVariant(LONGLONG nSrc)
	{ vt = VT_I8; llVal = nSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(ULONGLONG nSrc)
	{ vt = VT_UI8; ullVal = nSrc; }
#endif
_AFXDISP_INLINE COleVariant::COleVariant(float fltSrc)
	{ vt = VT_R4; fltVal = fltSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(double dblSrc)
	{ vt = VT_R8; dblVal = dblSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const COleDateTime& dateSrc)
	{ vt = VT_DATE; date = dateSrc; }
_AFXDISP_INLINE COleVariant::COleVariant(const CByteArray& arrSrc)
	{ vt = VT_EMPTY; *this = arrSrc; }
#ifndef _AFX_NO_DB_SUPPORT
_AFXDISP_INLINE COleVariant::COleVariant(const CLongBinary& lbSrc)
	{ vt = VT_EMPTY; *this = lbSrc; }
#endif // !_AFX_NO_DB_SUPPORT
_AFXDISP_INLINE BOOL COleVariant::operator==(LPCVARIANT pSrc) const
	{ return *this == *pSrc; }
_AFXDISP_INLINE COleVariant::operator LPVARIANT()
	{ return this; }
_AFXDISP_INLINE COleVariant::operator LPCVARIANT() const
	{ return this; }

#ifndef _WIN32_WCE // OLE
// COleCurrency
_AFXDISP_INLINE COleCurrency::COleCurrency()
	{ m_cur.Hi = 0; m_cur.Lo = 0; SetStatus(valid); }
_AFXDISP_INLINE COleCurrency::COleCurrency(CURRENCY cySrc)
	{ m_cur = cySrc; SetStatus(valid); }
_AFXDISP_INLINE COleCurrency::COleCurrency(const COleCurrency& curSrc)
	{ m_cur = curSrc.m_cur; m_status = curSrc.m_status; }
_AFXDISP_INLINE COleCurrency::COleCurrency(const VARIANT& varSrc)
	{ *this = varSrc; }
_AFXDISP_INLINE COleCurrency::CurrencyStatus COleCurrency::GetStatus() const
	{ return m_status; }
_AFXDISP_INLINE void COleCurrency::SetStatus(CurrencyStatus status)
	{ m_status = status; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator+=(const COleCurrency& cur)
	{ *this = *this + cur; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator-=(const COleCurrency& cur)
	{ *this = *this - cur; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator*=(long nOperand)
	{ *this = *this * nOperand; return *this; }
_AFXDISP_INLINE const COleCurrency& COleCurrency::operator/=(long nOperand)
	{ *this = *this / nOperand; return *this; }
_AFXDISP_INLINE BOOL COleCurrency::operator==(const COleCurrency& cur) const
	{ return(m_status == cur.m_status && m_cur.Hi == cur.m_cur.Hi &&
		m_cur.Lo == cur.m_cur.Lo); }
_AFXDISP_INLINE BOOL COleCurrency::operator!=(const COleCurrency& cur) const
	{ return(m_status != cur.m_status || m_cur.Hi != cur.m_cur.Hi ||
		m_cur.Lo != cur.m_cur.Lo); }
_AFXDISP_INLINE COleCurrency::operator CURRENCY() const
	{ return m_cur; }

// COleSafeArray
_AFXDISP_INLINE COleSafeArray::COleSafeArray()
	{ AfxSafeArrayInit(this);
		vt = VT_EMPTY; }
_AFXDISP_INLINE COleSafeArray::~COleSafeArray()
	{ Clear(); }
_AFXDISP_INLINE void COleSafeArray::Clear()
	{ VERIFY(::VariantClear(this) == NOERROR); }
_AFXDISP_INLINE COleSafeArray::operator LPVARIANT()
	{ return this; }
_AFXDISP_INLINE COleSafeArray::operator LPCVARIANT() const
	{ return this; }
_AFXDISP_INLINE DWORD COleSafeArray::GetDim()
	{ return ::SafeArrayGetDim(parray); }
_AFXDISP_INLINE DWORD COleSafeArray::GetElemSize()
	{ return ::SafeArrayGetElemsize(parray); }
#endif // !_WIN32_WCE

#endif //_AFXDISP_INLINE

#ifndef _WIN32_WCE // OLE
/////////////////////////////////////////////////////////////////////////////
// OLE Container inlines

#ifdef _AFXOLECLI_INLINE

// COleClientItem
_AFXOLECLI_INLINE SCODE COleClientItem::GetLastStatus() const
	{ ASSERT_VALID(this); return m_scLast; }
_AFXOLECLI_INLINE COleDocument* COleClientItem::GetDocument() const
	{ ASSERT_VALID(this); return (COleDocument*)m_pDocument; }
_AFXOLECLI_INLINE OLE_OBJTYPE COleClientItem::GetType() const
	{ ASSERT_VALID(this); return m_nItemType; }
_AFXOLECLI_INLINE DVASPECT COleClientItem::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_nDrawAspect; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsRunning() const
	{ ASSERT_VALID(this);
		ASSERT(m_lpObject != NULL);
		return ::OleIsRunning(m_lpObject); }
_AFXOLECLI_INLINE UINT COleClientItem::GetItemState() const
	{ ASSERT_VALID(this); return m_nItemState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsInPlaceActive() const
	{ ASSERT_VALID(this);
		return m_nItemState == activeState || m_nItemState == activeUIState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsOpen() const
	{ ASSERT_VALID(this); return m_nItemState == openState; }
_AFXOLECLI_INLINE BOOL COleClientItem::IsLinkUpToDate() const
	{ ASSERT_VALID(this);
		ASSERT(m_lpObject != NULL);
		// TRUE if result is S_OK (aka S_TRUE)
		return m_lpObject->IsUpToDate() == NOERROR; }
_AFXOLECLI_INLINE CView* COleClientItem::GetActiveView() const
	{ return m_pView; }

// COleLinkingDoc
_AFXOLECLI_INLINE void COleLinkingDoc::BeginDeferErrors()
	{ ASSERT(m_pLastException == NULL); ++m_bDeferErrors; }

#endif //_AFXOLECLI_INLINE

#ifdef _AFXOLEDOBJ_INLINE

// COleDataObject
_AFXOLEDOBJ_INLINE COleDataObject::~COleDataObject()
	{ Release(); }

#endif //_AFXOLECTL_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE dialog inlines

#ifdef _AFXODLGS_INLINE

_AFXODLGS_INLINE UINT COleDialog::GetLastError() const
	{ return m_nLastError; }
_AFXODLGS_INLINE CString COleInsertDialog::GetPathName() const
	{ ASSERT_VALID(this);
		ASSERT(GetSelectionType() != createNewItem); return m_szFileName; }
_AFXODLGS_INLINE REFCLSID COleInsertDialog::GetClassID() const
	{ ASSERT_VALID(this); return m_io.clsid; }
_AFXODLGS_INLINE HGLOBAL COleInsertDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_io.hMetaPict; }
_AFXODLGS_INLINE DVASPECT COleInsertDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_io.dwFlags & IOF_CHECKDISPLAYASICON ?
		DVASPECT_ICON : DVASPECT_CONTENT; }
_AFXODLGS_INLINE HGLOBAL COleConvertDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_cv.hMetaPict; }
_AFXODLGS_INLINE DVASPECT COleConvertDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return (DVASPECT)m_cv.dvAspect; }
_AFXODLGS_INLINE REFCLSID COleConvertDialog::GetClassID() const
	{ ASSERT_VALID(this); return m_cv.clsidNew; }
_AFXODLGS_INLINE HGLOBAL COleChangeIconDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_ci.hMetaPict; }
_AFXODLGS_INLINE int COlePasteSpecialDialog::GetPasteIndex() const
	{ ASSERT_VALID(this); return m_ps.nSelectedIndex; }
_AFXODLGS_INLINE DVASPECT COlePasteSpecialDialog::GetDrawAspect() const
	{ ASSERT_VALID(this); return m_ps.dwFlags & PSF_CHECKDISPLAYASICON ?
		DVASPECT_ICON : DVASPECT_CONTENT; }
_AFXODLGS_INLINE HGLOBAL COlePasteSpecialDialog::GetIconicMetafile() const
	{ ASSERT_VALID(this); return m_ps.hMetaPict; }
_AFXODLGS_INLINE UINT COleBusyDialog::GetSelectionType() const
	{ ASSERT_VALID(this); return m_selection; }

_AFXODLGS_INLINE BOOL COleChangeSourceDialog::IsValidSource()
	{ return m_cs.dwFlags & CSF_VALIDSOURCE; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetDisplayName()
	{ return m_cs.lpszDisplayName; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetFileName()
	{ return CString(m_cs.lpszDisplayName, m_cs.nFileLength); }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetItemName()
	{ return m_cs.lpszDisplayName+m_cs.nFileLength; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetFromPrefix()
	{ return m_cs.lpszFrom; }
_AFXODLGS_INLINE CString COleChangeSourceDialog::GetToPrefix()
	{ return m_cs.lpszTo; }

#endif //_AFXODLGS_INLINE

/////////////////////////////////////////////////////////////////////////////
// OLE Server inlines

#ifdef _AFXOLESVR_INLINE

// COleServerItem
_AFXOLESVR_INLINE COleServerDoc* COleServerItem::GetDocument() const
	{ ASSERT_VALID(this); return (COleServerDoc*)m_pDocument; }
_AFXOLESVR_INLINE void COleServerItem::NotifyChanged(DVASPECT nDrawAspect)
	{ ASSERT_VALID(this); NotifyClient(OLE_CHANGED, nDrawAspect); }
_AFXOLESVR_INLINE const CString& COleServerItem::GetItemName() const
	{ ASSERT_VALID(this); return m_strItemName; }
_AFXOLESVR_INLINE void COleServerItem::SetItemName(LPCTSTR lpszItemName)
{
	ASSERT_VALID(this);
	ASSERT(lpszItemName != NULL);
	ASSERT(AfxIsValidString(lpszItemName));
	m_strItemName = lpszItemName;
}
_AFXOLESVR_INLINE BOOL COleServerItem::IsLinkedItem() const
	{ ASSERT_VALID(this); return GetDocument()->m_pEmbeddedItem != this; }
_AFXOLESVR_INLINE COleDataSource* COleServerItem::GetDataSource()
	{ ASSERT_VALID(this); return &m_dataSource; }

// COleServerDoc
_AFXOLESVR_INLINE void COleServerDoc::NotifyChanged()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_CHANGED, DVASPECT_CONTENT); }
_AFXOLESVR_INLINE void COleServerDoc::NotifyClosed()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_CLOSED, 0); }
_AFXOLESVR_INLINE void COleServerDoc::NotifySaved()
	{ ASSERT_VALID(this); NotifyAllItems(OLE_SAVED, 0); }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsEmbedded() const
	{ ASSERT_VALID(this); return m_bEmbedded; }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsDocObject() const
	{ ASSERT_VALID(this); return m_pDocObjectServer != NULL; }
_AFXOLESVR_INLINE BOOL COleServerDoc::IsInPlaceActive() const
	{ ASSERT_VALID(this); return m_pInPlaceFrame != NULL; }
_AFXOLESVR_INLINE LPOLECLIENTSITE COleServerDoc::GetClientSite() const
	{ ASSERT_VALID(this); return m_lpClientSite; }

// COleIPFrameWnd
_AFXOLESVR_INLINE CFrameWnd* COleIPFrameWnd::GetDocFrame() { return (CFrameWnd*)m_pDocFrame; }
_AFXOLESVR_INLINE CFrameWnd* COleIPFrameWnd::GetMainFrame() { return (CFrameWnd*)m_pMainFrame; }
_AFXOLESVR_INLINE HRESULT COleIPFrameWnd::GetInPlaceFrame(LPOLEINPLACEUIWINDOW *ppUIWindow)
{
	HRESULT hr = E_UNEXPECTED;
	if (m_pMainFrame && m_lpFrame)
	{
		hr = m_lpFrame->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow);
	}
	return hr;
}
_AFXOLESVR_INLINE HRESULT COleIPFrameWnd::GetInPlaceDocFrame(LPOLEINPLACEUIWINDOW *ppUIWindow)
{
	HRESULT hr = E_UNEXPECTED;
	if (m_pDocFrame && m_lpDocFrame)
	{
		hr = m_lpDocFrame->QueryInterface(IID_IOleInPlaceUIWindow, (void**)ppUIWindow);
	}
	return hr;
}
_AFXOLESVR_INLINE void COleIPFrameWnd::SetPreviewMode(BOOL bNewMode) { m_bPreviewMode = bNewMode; }

#endif //_AFXOLESVR_INLINE
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxrich.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXRICH.H

#pragma once

#ifdef _AFXRICH_INLINE

// CRichEditView
// NOTE: The cast in GetRichEditCtrl is ugly, but must be preserved for compatibility.
// CRichEditCtrl is not related to CRichEditView by inheritance so we must be careful to ensure 
// that CRichEditCtrl remains a binary compatible subset of CRichEditView.
_AFXRICH_INLINE CRichEditCtrl& CRichEditView::GetRichEditCtrl() const
	{ return *(CRichEditCtrl*)this; }
int _AFXRICH_INLINE CRichEditView::GetPrintWidth() const
	{ return m_sizePaper.cx - m_rectMargin.left - m_rectMargin.right;}
CRect _AFXRICH_INLINE CRichEditView::GetPrintRect() const
	{ return CRect(m_rectMargin.left, m_rectMargin.top, m_sizePaper.cx - m_rectMargin.right, m_sizePaper.cy - m_rectMargin.bottom); }
CRect _AFXRICH_INLINE CRichEditView::GetPageRect() const
	{ return CRect(CPoint(0,0), m_sizePaper); }
void _AFXRICH_INLINE CRichEditView::SetPaperSize(CSize sizePaper)
	{ m_sizePaper = sizePaper; }
CSize _AFXRICH_INLINE CRichEditView::GetPaperSize() const
	{ return m_sizePaper; }
void _AFXRICH_INLINE CRichEditView::SetMargins(const CRect& rectMargin)
	{ m_rectMargin = rectMargin; }
CRect _AFXRICH_INLINE CRichEditView::GetMargins() const
	{ return m_rectMargin; }

_AFXRICH_INLINE long CRichEditView::GetTextLength() const
	{ return GetRichEditCtrl().GetTextLength(); }

_AFXRICH_INLINE	long CRichEditView::GetTextLengthEx(DWORD dwFlags, UINT uCodePage) const
	{ return GetRichEditCtrl().GetTextLengthEx(dwFlags, uCodePage); }

_AFXRICH_INLINE CRichEditDoc* CRichEditView::GetDocument() const
{
	AFXASSUME(m_pDocument != NULL);
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CRichEditDoc)));
	return (CRichEditDoc*)m_pDocument;
}
_AFXRICH_INLINE int CRichEditDoc::GetStreamFormat() const
	{ return m_bRTF ? SF_RTF : SF_TEXT; }
_AFXRICH_INLINE void CRichEditDoc::InvalidateObjectCache()
	{ m_bUpdateObjectCache = TRUE; }

_AFXRICH_INLINE void CRichEditCntrItem::Mark(BOOL b)
	{ m_bMark = b; }
_AFXRICH_INLINE BOOL CRichEditCntrItem::IsMarked()
	{ return m_bMark||m_bLock; }
_AFXRICH_INLINE CRichEditDoc* CRichEditCntrItem::GetDocument()
	{ return (CRichEditDoc*)COleClientItem::GetDocument(); }
_AFXRICH_INLINE CRichEditView* CRichEditCntrItem::GetActiveView()
	{ return (CRichEditView*)COleClientItem::GetActiveView(); }
#endif //_AFXRICH_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxsock.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXSOCK.H

#pragma once

#ifdef _AFXSOCK_INLINE

_AFXSOCK_INLINE CAsyncSocket::operator SOCKET() const
	{ return m_hSocket; }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
	{ return (SOCKET_ERROR != getpeername(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
	{ return (SOCKET_ERROR != getsockname(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel)
	{ return (SOCKET_ERROR != setsockopt(m_hSocket, nLevel, nOptionName, (LPCSTR)lpOptionValue, nOptionLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel)
	{ return (SOCKET_ERROR != getsockopt(m_hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen)); }
_AFXSOCK_INLINE CAsyncSocket* PASCAL CAsyncSocket::FromHandle(SOCKET hSocket)
	{ return CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE int PASCAL CAsyncSocket::GetLastError()
	{ return WSAGetLastError(); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen)
	{ return (SOCKET_ERROR != bind(m_hSocket, lpSockAddr, nSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
	{ return ConnectHelper(lpSockAddr, nSockAddrLen); }
_AFXSOCK_INLINE BOOL CAsyncSocket::IOCtl(long lCommand, DWORD* lpArgument)
	{ return (SOCKET_ERROR != ioctlsocket(m_hSocket, lCommand, lpArgument)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Listen(int nConnectionBacklog)
	{ return (SOCKET_ERROR != listen(m_hSocket, nConnectionBacklog)); }
_AFXSOCK_INLINE int CAsyncSocket::ReceiveFrom(void* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
	{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }
_AFXSOCK_INLINE BOOL CAsyncSocket::ShutDown(int nHow)
	{ return (SOCKET_ERROR != shutdown(m_hSocket,nHow)); }
_AFXSOCK_INLINE int CAsyncSocket::SendTo(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
	{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }

_AFXSOCK_INLINE BOOL CSocket::Create(UINT nSocketPort, int nSocketType, LPCTSTR lpszSocketAddress)
	{ return CAsyncSocket::Create(nSocketPort, nSocketType, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE, lpszSocketAddress); }
_AFXSOCK_INLINE BOOL CSocket::IsBlocking()
	{ return (m_pbBlocking != NULL); }
_AFXSOCK_INLINE CSocket* PASCAL CSocket::FromHandle(SOCKET hSocket)
	{ return (CSocket*)CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE BOOL CSocket::Attach(SOCKET hSocket)
		{ return CAsyncSocket::Attach(hSocket); }

#endif //_AFXSOCK_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxpriv2.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXPRIV2_H__
// Do not define __AFXPRIV2_H__ here.  It is defined at the bottom,
// and so this header can't use #pragma once.

#ifndef __AFXPRIV_H__
	#include <afxpriv.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXPRIV2 - MFC Private Classes

// General OLE features

#if (!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)

// Implementation structures
struct AFX_EVENT;               // Event sink implementation

// Classes declared in this file
class COleControlLock;

#endif

// OLE Automation features

#ifdef __AFXDISP_H__
// Classes declared in this file

//IStream
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	class CArchiveStream;
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

// Functions declared in this file

// AfxBSTR2ABTSR
// AfxTaskStringA2W
// AfxTaskStringW2A

#endif

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// General OLE features

#if (!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)
#ifndef __AFXPRIV2_H__OLE__
#define __AFXPRIV2_H__OLE__

/////////////////////////////////////////////////////////////////////////////
// Implementation of event sink handling

struct AFX_EVENT
{
	enum
	{
		event,
		propRequest, propChanged,
		propDSCNotify
	};

	AFX_EVENT(int eventKind);

	AFX_EVENT(int eventKind, DISPID dispid, DISPPARAMS* pDispParams = NULL,
		EXCEPINFO* pExcepInfo = NULL, UINT* puArgError = NULL);

	int m_eventKind;
	DISPID m_dispid;
	DISPPARAMS* m_pDispParams;
	EXCEPINFO* m_pExcepInfo;
	UINT* m_puArgError;
	BOOL m_bPropChanged;
	HRESULT m_hResult;
	DSCSTATE m_nDSCState;
	DSCREASON m_nDSCReason;
};

AFX_INLINE AFX_EVENT::AFX_EVENT(int eventKind)
{
	m_eventKind = eventKind;
	m_dispid = DISPID_UNKNOWN;
	m_pDispParams = NULL;
	m_pExcepInfo = NULL;
	m_puArgError = NULL;
	m_hResult = NOERROR;
	m_nDSCState = dscNoState;
	m_nDSCReason = dscNoReason;
}

AFX_INLINE AFX_EVENT::AFX_EVENT(int eventKind, DISPID dispid,
	DISPPARAMS* pDispParams, EXCEPINFO* pExcepInfo, UINT* puArgError)
{
	m_eventKind = eventKind;
	m_dispid = dispid;
	m_pDispParams = pDispParams;
	m_pExcepInfo = pExcepInfo;
	m_puArgError = puArgError;
	m_hResult = NOERROR;
	m_nDSCState = dscNoState;
	m_nDSCReason = dscNoReason;
}

/////////////////////////////////////////////////////////////////////////////
// COleControlLock

class COleControlLock
{
// Constructors
public:
	explicit COleControlLock(REFCLSID clsid);

// Attributes
	CLSID m_clsid;
	LPCLASSFACTORY m_pClassFactory;
	COleControlLock* m_pNextLock;

// Implementation
public:
	virtual ~COleControlLock();
};

#endif // __AFXPRIV2_H__OLE__
#endif //(!defined _AFX_NO_OLE_SUPPORT) && (defined _OBJBASE_H_)

/////////////////////////////////////////////////////////////////////////////
// OLE Automation features

#ifdef __AFXDISP_H__
#ifndef __AFXPRIV2_H__DISP__
#define __AFXPRIV2_H__DISP__

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
/////////////////////////////////////////////////////////////////////////////
// CArchiveStream

class CArchiveStream : public IStream
{
public:
	CArchiveStream(CArchive* pArchive);

// Implementation
	CArchive* m_pArchive;

	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();
	STDMETHOD(QueryInterface)(REFIID, LPVOID*);

	STDMETHOD(Read)(void*, ULONG, ULONG*);
	STDMETHOD(Write)(const void*, ULONG cb, ULONG*);
	STDMETHOD(Seek)(LARGE_INTEGER, DWORD, ULARGE_INTEGER*);
	STDMETHOD(SetSize)(ULARGE_INTEGER);
	STDMETHOD(CopyTo)(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*,
		ULARGE_INTEGER*);
	STDMETHOD(Commit)(DWORD);
	STDMETHOD(Revert)();
	STDMETHOD(LockRegion)(ULARGE_INTEGER, ULARGE_INTEGER,DWORD);
	STDMETHOD(UnlockRegion)(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
	STDMETHOD(Stat)(STATSTG*, DWORD);
	STDMETHOD(Clone)(LPSTREAM*);
};
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

void AFXAPI AfxBSTR2CString(CString* pStr, BSTR bstr);

#if !defined(_UNICODE)
BSTR AFXAPI AfxBSTR2ABSTR(BSTR bstrW);
LPWSTR AFXAPI AfxTaskStringA2W(LPCSTR lpa);
LPSTR AFXAPI AfxTaskStringW2A(LPCWSTR lpw);
#endif

#endif // __AFXPRIV2_H__DISP__
#endif // __AFXDISP_H__

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#if (defined __AFXPRIV2_H__OLE__) && (defined __AFXPRIV2_H__DISP__)
#define __AFXPRIV2_H__
#endif

#endif // __AFXPRIV2_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxoledb.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXOLEDB_H__
#define __AFXOLEDB_H__

#ifndef _WIN32_WCE

//#ifdef _AFX_NO_DAO_SUPPORT
//	#error OLE DB classes not supported in this library variant.
//#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#include <atldbcli.h>

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class COleDBRecordView; // view records with a form

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_DB_DATA

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DB_NUMERIC& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBDATE& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBTIME& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DBTIMESTAMP& value);

void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBDATE& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBTIME& value);
void AFXAPI DDX_DateTimeCtrl(CDataExchange* pDX, int nIDC, DBTIMESTAMP& value);
void AFXAPI DDX_MonthCalCtrl(CDataExchange* pDX, int nIDC, DBDATE& value);

/////////////////////////////////////////////////////////////////////////////
// CRecordView - form for viewing data records

class COleDBRecordView : public CFormView
{
	DECLARE_DYNAMIC(COleDBRecordView)

// Construction
protected:  // must derive your own class
	COleDBRecordView(LPCTSTR lpszTemplateName)
		: CFormView(lpszTemplateName)
	{
		m_bOnFirstRecord = TRUE;
		m_bOnLastRecord = FALSE;
	}
	COleDBRecordView(UINT nIDTemplate)
		: CFormView(nIDTemplate)
	{
		m_bOnFirstRecord = TRUE;
		m_bOnLastRecord = FALSE;
	}

// Attributes
public:
	virtual CRowset<>* OnGetRowset() = 0;

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual void OnInitialUpdate();

protected:
	BOOL m_bOnFirstRecord;
	BOOL m_bOnLastRecord;

	//{{AFX_MSG(CRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // !_WIN32_WCE
#endif __AFXOLEDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxpriv.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Note: This header file contains useful classes that are documented only
//  in the MFC Technical Notes.  These classes may change from version to
//  version, so be prepared to change your code accordingly if you utilize
//  this header.  In the future, commonly used portions of this header
//  may be moved and officially documented.

#ifndef __AFXPRIV_H__
#define __AFXPRIV_H__

#pragma once

#ifdef _DEBUG
// Special _CLIENT_BLOCK type to identifiy CObjects.
#define _AFX_CLIENT_BLOCK (_CLIENT_BLOCK|(0xc0<<16))
#endif

#ifndef __AFXADV_H__
	#include <afxadv.h>
#endif

#ifndef _INC_MALLOC
	#include <malloc.h>
#endif

#ifndef __AFXEXT_H__
	#include <afxext.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXPRIV - MFC Private Classes

// Implementation structures
struct AFX_SIZEPARENTPARAMS;    // Control bar implementation
struct AFX_CMDHANDLERINFO;      // Command routing implementation

// Classes declared in this file

#ifndef _AFX_NO_PRINTING_SUPPORT 
	//CDC
		class CPreviewDC;               // Virtual DC for print preview

	//CCmdTarget
		//CWnd
			//CView
				class CPreviewView;     // Print preview view
#endif // !_AFX_NO_PRINTING_SUPPORT
#ifndef _WIN32_WCE
		//CFrameWnd
			class COleCntrFrameWnd;
			//CMiniFrameWnd
				class CMiniDockFrameWnd;

class CDockContext;                     // for dragging control bars
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Global ID ranges (see Technical note TN020 for more details)

// 8000 -> FFFF command IDs (used for menu items, accelerators and controls)
#define IS_COMMAND_ID(nID)  ((nID) & 0x8000)

// 8000 -> DFFF : user commands
// E000 -> EFFF : AFX commands and other things
// F000 -> FFFF : standard windows commands and other things etc
	// E000 -> E7FF standard commands
	// E800 -> E8FF control bars (first 32 are special)
	// E900 -> EEFF standard window controls/components
	// EF00 -> EFFF SC_ menu help
	// F000 -> FFFF standard strings
#define ID_COMMAND_FROM_SC(sc)  (((sc - 0xF000) >> 4) + AFX_IDS_SCFIRST)

// 0000 -> 7FFF IDR range
// 0000 -> 6FFF : user resources
// 7000 -> 7FFF : AFX (and standard windows) resources
// IDR ranges (NOTE: IDR_ values must be <32768)
#define ASSERT_VALID_IDR(nIDR) ASSERT((nIDR) != 0 && (nIDR) < 0x8000)

/////////////////////////////////////////////////////////////////////////////
// Context sensitive help support (see Technical note TN028 for more details)

// Help ID bases
#define HID_BASE_COMMAND    0x00010000UL        // ID and IDM
#define HID_BASE_RESOURCE   0x00020000UL        // IDR and IDD
#define HID_BASE_PROMPT     0x00030000UL        // IDP
#define HID_BASE_NCAREAS    0x00040000UL
#define HID_BASE_CONTROL    0x00050000UL        // IDC
#define HID_BASE_DISPATCH   0x00060000UL        // IDispatch help codes

/////////////////////////////////////////////////////////////////////////////
// Internal AFX Windows messages (see Technical note TN024 for more details)
// (0x0360 - 0x037F are reserved for MFC)

#define WM_QUERYAFXWNDPROC  0x0360  // lResult = 1 if processed by AfxWndProc
#define WM_SIZEPARENT       0x0361  // lParam = &AFX_SIZEPARENTPARAMS
#define WM_SETMESSAGESTRING 0x0362  // wParam = nIDS (or 0),
									// lParam = lpszOther (or NULL)
#define WM_IDLEUPDATECMDUI  0x0363  // wParam == bDisableIfNoHandler
#define WM_INITIALUPDATE    0x0364  // (params unused) - sent to children
#define WM_COMMANDHELP      0x0365  // lResult = TRUE/FALSE,
									// lParam = dwContext
#define WM_HELPHITTEST      0x0366  // lResult = dwContext,
									// lParam = MAKELONG(x,y)
#define WM_EXITHELPMODE     0x0367  // (params unused)
#define WM_RECALCPARENT     0x0368  // force RecalcLayout on frame window
									//  (only for inplace frame windows)
#define WM_SIZECHILD        0x0369  // special notify from COleResizeBar
									// wParam = ID of child window
									// lParam = lpRectNew (new position/size)
#define WM_KICKIDLE         0x036A  // (params unused) causes idles to kick in
#define WM_QUERYCENTERWND   0x036B  // lParam = HWND to use as centering parent
#define WM_DISABLEMODAL     0x036C  // lResult = 0, disable during modal state
									// lResult = 1, don't disable
#define WM_FLOATSTATUS      0x036D  // wParam combination of FS_* flags below

// WM_ACTIVATETOPLEVEL is like WM_ACTIVATEAPP but works with hierarchies
//   of mixed processes (as is the case with OLE in-place activation)
#define WM_ACTIVATETOPLEVEL 0x036E  // wParam = nState (like WM_ACTIVATE)
									// lParam = pointer to HWND[2]
									//  lParam[0] = hWnd getting WM_ACTIVATE
									//  lParam[1] = hWndOther

#define WM_RESERVED_036F	0x036F  // was WM_QUERY3DCONTROLS (now not used)

// Note: Messages 0x0370, 0x0371, and 0x372 were incorrectly used by
//  some versions of Windows.  To remain compatible, MFC does not
//  use messages in that range.
#define WM_RESERVED_0370    0x0370
#define WM_RESERVED_0371    0x0371
#define WM_RESERVED_0372    0x0372

// WM_SOCKET_NOTIFY and WM_SOCKET_DEAD are used internally by MFC's
// Windows sockets implementation.  For more information, see sockcore.cpp
#define WM_SOCKET_NOTIFY    0x0373
#define WM_SOCKET_DEAD      0x0374

// same as WM_SETMESSAGESTRING except not popped if IsTracking()
#define WM_POPMESSAGESTRING 0x0375

// WM_HELPPROMPTADDR is used internally to get the address of 
//	m_dwPromptContext from the associated frame window. This is used
//	during message boxes to setup for F1 help while that msg box is
//	displayed. lResult is the address of m_dwPromptContext.
#define WM_HELPPROMPTADDR	0x0376

// Constants used in DLGINIT resources for OLE control containers
// NOTE: These are NOT real Windows messages they are simply tags
// used in the control resource and are never used as 'messages'
#define WM_OCC_LOADFROMSTREAM           0x0376
#define WM_OCC_LOADFROMSTORAGE          0x0377
#define WM_OCC_INITNEW                  0x0378
#define WM_OCC_LOADFROMSTREAM_EX        0x037A
#define WM_OCC_LOADFROMSTORAGE_EX       0x037B

// Marker used while rearranging the message queue
#define WM_QUEUE_SENTINEL   0x0379

// Note: Messages 0x037C - 0x37E reserved for future MFC use.
#define WM_RESERVED_037C    0x037C
#define WM_RESERVED_037D    0x037D
#define WM_RESERVED_037E    0x037E

// WM_FORWARDMSG - used by ATL to forward a message to another window for processing
//	WPARAM - DWORD dwUserData - defined by user
//	LPARAM - LPMSG pMsg - a pointer to the MSG structure
//	return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

// like ON_MESSAGE but no return value
#define ON_MESSAGE_VOID(message, memberFxn) \
	{ message, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))&memberFxn },

// special struct for WM_SIZEPARENT
struct AFX_SIZEPARENTPARAMS
{
	HDWP hDWP;       // handle for DeferWindowPos
	RECT rect;       // parent client rectangle (trim as appropriate)
	SIZE sizeTotal;  // total size on each side as layout proceeds
	BOOL bStretch;   // should stretch to fill all space
};

// flags for wParam in the WM_FLOATSTATUS message
enum {  FS_SHOW = 0x01, FS_HIDE = 0x02,
		FS_ACTIVATE = 0x04, FS_DEACTIVATE = 0x08,
		FS_ENABLE = 0x10, FS_DISABLE = 0x20,
		FS_SYNCACTIVE = 0x40 };

void AFXAPI AfxRepositionWindow(AFX_SIZEPARENTPARAMS* lpLayout,
	HWND hWnd, LPCRECT lpRect);

/////////////////////////////////////////////////////////////////////////////
// Implementation of command routing

struct AFX_CMDHANDLERINFO
{
	CCmdTarget* pTarget;
	void (AFX_MSG_CALL CCmdTarget::*pmf)(void);
};

#ifndef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// Robust file save support
// opens a temp file if modeCreate specified and enough free space
// renaming, etc occurs automatically if everything succeeds

class CMirrorFile : public CFile
{
// Implementation
public:
	virtual void Abort();
	virtual void Close();
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

protected:
	CString m_strMirrorName;
};
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT 
/////////////////////////////////////////////////////////////////////////////
// Implementation of PrintPreview

class CPreviewDC : public CDC
{
	DECLARE_DYNAMIC(CPreviewDC)

public:
	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC
	virtual void SetOutputDC(HDC hDC);

	virtual void ReleaseOutputDC();

// Constructors
	CPreviewDC();

// Implementation
public:
	virtual ~CPreviewDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	void SetScaleRatio(int nNumerator, int nDenominator);
	void SetTopLeftOffset(CSize TopLeft);
	void ClipToPage();

	// These conversion functions can be used without an output DC

	void PrinterDPtoScreenDP(LPPOINT lpPoint) const;

// Device-Context Functions
	virtual int SaveDC();
	virtual BOOL RestoreDC(int nSavedDC);

public:
	virtual CGdiObject* SelectStockObject(int nIndex);
	virtual CFont* SelectObject(CFont* pFont);

// Drawing-Attribute Functions
	virtual COLORREF SetBkColor(COLORREF crColor);
	virtual COLORREF SetTextColor(COLORREF crColor);

// Mapping Functions
	virtual int SetMapMode(int nMapMode);
	virtual CPoint SetViewportOrg(int x, int y);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);
	virtual CSize SetWindowExt(int x, int y);
	virtual CSize ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom);

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
	virtual int _AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat)
	{
		return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat);
	}
	int DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{
		return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams);
	}
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")
	virtual BOOL GrayString(CBrush* pBrush,
				BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int),
					LPARAM lpData, int nCount,
					int x, int y, int nWidth, int nHeight);

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Implementation
protected:
	void MirrorMappingMode(BOOL bCompute);
	void MirrorViewportOrg();
	void MirrorFont();
	void MirrorAttributes();

	CSize ComputeDeltas(int& x, __in_z LPCTSTR lpszString, UINT& nCount, __in BOOL bTabbed,
					__in UINT nTabStops, __in_ecount(nTabStops) LPINT lpnTabStops, __in int nTabOrigin,
					__out_z LPTSTR lpszOutputString, int* pnDxWidths, int& nRightFixup);

protected:
	int m_nScaleNum;    // Scale ratio Numerator
	int m_nScaleDen;    // Scale ratio Denominator
	int m_nSaveDCIndex; // DC Save index when Screen DC Attached
	int m_nSaveDCDelta; // delta between Attrib and output restore indices
	CSize m_sizeTopLeft;// Offset for top left corner of page
	HFONT m_hFont;      // Font selected into the screen DC (NULL if none)
	HFONT m_hPrinterFont; // Font selected into the print DC

	CSize m_sizeWinExt; // cached window extents computed for screen
	CSize m_sizeVpExt;  // cached viewport extents computed for screen
};

/////////////////////////////////////////////////////////////////////////////
// CPreviewView

class CDialogBar;

class CPreviewView : public CScrollView
{
	DECLARE_DYNCREATE(CPreviewView)

// Constructors
public:
	CPreviewView();
	BOOL SetPrintView(CView* pPrintView);

// Attributes
protected:
	CView* m_pOrigView;
	CView* m_pPrintView;
	CPreviewDC* m_pPreviewDC;  // Output and attrib DCs Set, not created
	CDC m_dcPrint;             // Actual printer DC

// Operations
	void SetZoomState(UINT nNewState, UINT nPage, CPoint point);
	void SetCurrentPage(UINT nPage, BOOL bClearRatios);

	// Returns TRUE if in a page rect. Returns the page index
	// in nPage and the point converted to 1:1 screen device coordinates
	BOOL FindPageRect(CPoint& point, UINT& nPage);


// Overridables
	virtual void OnActivateView(BOOL bActivate,
			CView* pActivateView, CView* pDeactiveView);

	// Returns .cx/.cy as the numerator/denominator pair for the ratio
	// using CSize for convenience
	virtual CSize CalcScaleRatio(CSize windowSize, CSize actualSize);

	virtual void PositionPage(UINT nPage);
	virtual void OnDisplayPageNumber(UINT nPage, UINT nPagesDisplayed);

// Implementation
public:
	virtual ~CPreviewView();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
	IOleInPlaceUIWindow *m_pIPUIWindow;
#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif

protected:
	//{{AFX_MSG(CPreviewView)
	afx_msg void OnPreviewClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDraw(CDC* pDC);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnNumPageChange();
	afx_msg void OnNextPage();
	afx_msg void OnPrevPage();
	afx_msg void OnPreviewPrint();
	afx_msg void OnZoomIn();
	afx_msg void OnZoomOut();
	afx_msg void OnUpdateNumPageChange(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNextPage(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePrevPage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateZoomIn(CCmdUI* pCmdUI);
	afx_msg void OnUpdateZoomOut(CCmdUI* pCmdUI);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG

	void DoZoom(UINT nPage, CPoint point);
	void SetScaledSize(UINT nPage);
	CSize CalcPageDisplaySize();

	CPrintPreviewState* m_pPreviewState; // State to restore
	CDialogBar* m_pToolBar; // Toolbar for preview

	struct PAGE_INFO
	{
		PAGE_INFO();
		CRect rectScreen; // screen rect (screen device units)
		CSize sizeUnscaled; // unscaled screen rect (screen device units)
		CSize sizeScaleRatio; // scale ratio (cx/cy)
		CSize sizeZoomOutRatio; // scale ratio when zoomed out (cx/cy)
	};

	PAGE_INFO* m_pPageInfo; // Array of page info structures
	PAGE_INFO m_pageInfoArray[2]; // Embedded array for the default implementation

	BOOL m_bPageNumDisplayed;// Flags whether or not page number has yet
								// been displayed on status line
	UINT m_nZoomOutPages; // number of pages when zoomed out
	UINT m_nZoomState;
	UINT m_nMaxPages; // for sanity checks
	UINT m_nCurrentPage;
	UINT m_nPages;
	int m_nSecondPageOffset; // used to shift second page position

	HCURSOR m_hMagnifyCursor;

	CSize m_sizePrinterPPI; // printer pixels per inch
	CPoint m_ptCenterPoint;
	CPrintInfo* m_pPreviewInfo;

	DECLARE_MESSAGE_MAP()

	friend class CView;
	friend BOOL CALLBACK _AfxPreviewCloseProc(CFrameWnd* pFrameWnd);
};
#endif // !_AFX_NO_PRINTING_SUPPORT

// Zoom States
#define ZOOM_OUT    0
#define ZOOM_MIDDLE 1
#define ZOOM_IN     2

/////////////////////////////////////////////////////////////////////////////
// mirroring support

// some mirroring stuff will be in wingdi.h someday
#ifndef LAYOUT_LTR
#define LAYOUT_LTR								 0x00000000	
#endif

#ifndef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// toolbar docking support

class CDockContext
{
public:
// Construction
	explicit CDockContext(CControlBar* pBar);

// Attributes
	CPoint m_ptLast;            // last mouse position during drag
	CRect m_rectLast;
	CSize m_sizeLast;
	BOOL m_bDitherLast;

	// Rectangles used during dragging or resizing
	CRect m_rectDragHorz;
	CRect m_rectDragVert;
	CRect m_rectFrameDragHorz;
	CRect m_rectFrameDragVert;

	CControlBar* m_pBar;        // the toolbar that created this context
	CFrameWnd* m_pDockSite;     // the controlling frame of the CControlBar
	DWORD m_dwDockStyle;        // allowable dock styles for bar
	DWORD m_dwOverDockStyle;    // style of dock that rect is over
	DWORD m_dwStyle;            // style of control bar
	BOOL m_bFlip;               // if shift key is down
	BOOL m_bForceFrame;         // if ctrl key is down

	CDC* m_pDC;                 // where to draw during drag
	BOOL m_bDragging;
	int m_nHitTest;

	UINT m_uMRUDockID;
	CRect m_rectMRUDockPos;

	DWORD m_dwMRUFloatStyle;
	CPoint m_ptMRUFloatPos;

// Drag Operations
	virtual void StartDrag(CPoint pt);
	void Move(CPoint pt);       // called when mouse has moved
	void EndDrag();             // drop
	void OnKey(int nChar, BOOL bDown);

// Resize Operations
	virtual void StartResize(int nHitTest, CPoint pt);
	void Stretch(CPoint pt);
	void EndResize();

// Double Click Operations
	virtual void ToggleDocking();

// Operations
	void InitLoop();
	void CancelLoop();

// Implementation
public:
	~CDockContext();
	BOOL Track();
	void DrawFocusRect(BOOL bRemoveRect = FALSE);
		// draws the correct outline
	void UpdateState(BOOL* pFlag, BOOL bNewValue);
	DWORD CanDock();
	CDockBar* GetDockBar(DWORD dwOverDockStyle);
};

/////////////////////////////////////////////////////////////////////////////
// CControlBarInfo - used for docking serialization

class CControlBarInfo
{
public:
// Implementation
	CControlBarInfo();

// Attributes
	UINT m_nBarID;      // ID of this bar
	BOOL m_bVisible;    // visibility of this bar
	BOOL m_bFloating;   // whether floating or not
	BOOL m_bHorz;       // orientation of floating dockbar
	BOOL m_bDockBar;    // TRUE if a dockbar
	CPoint m_pointPos;  // topleft point of window

	UINT m_nMRUWidth;   // MRUWidth for Dynamic Toolbars
	BOOL m_bDocking;    // TRUE if this bar has a DockContext
	UINT m_uMRUDockID;  // most recent docked dockbar
	CRect m_rectMRUDockPos; // most recent docked position
	DWORD m_dwMRUFloatStyle; // most recent floating orientation
	CPoint m_ptMRUFloatPos; // most recent floating position

	CPtrArray m_arrBarID;   // bar IDs for bars contained within this one
	CControlBar* m_pBar;    // bar which this refers to (transient)

	void Serialize(CArchive& ar, CDockState* pDockState);
	BOOL LoadState(LPCTSTR lpszProfileName, int nIndex, CDockState* pDockState);
	BOOL SaveState(LPCTSTR lpszProfileName, int nIndex);
};

/////////////////////////////////////////////////////////////////////////////
// CDockBar - used for docking

class CDockBar : public CControlBar
{
	DECLARE_DYNAMIC(CDockBar)

// Construction
public:
	/* explicit */ CDockBar(BOOL bFloating = FALSE);   // TRUE if attached to CMiniDockFrameWnd
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle, UINT nID);

// Attributes
	BOOL m_bFloating;

	virtual BOOL IsDockBar() const;
	int GetDockedCount() const;
	virtual int GetDockedVisibleCount() const;

// Operations
	void DockControlBar(CControlBar* pBar, LPCRECT lpRect = NULL);
	void ReDockControlBar(CControlBar* pBar, LPCRECT lpRect = NULL);
	BOOL RemoveControlBar(CControlBar*, int nPosExclude = -1, int nAddPlaceHolder = 0);
	void RemovePlaceHolder(CControlBar* pBar);

// Implementation
public:
	virtual ~CDockBar();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual void DoPaint(CDC* pDC);

	// public implementation helpers
	void GetBarInfo(CControlBarInfo* pInfo);
	void SetBarInfo(CControlBarInfo* pInfo, CFrameWnd* pFrameWnd);
	int FindBar(CControlBar* pBar, int nPosExclude = -1);
	void ShowAll(BOOL bShow);

	CPtrArray m_arrBars;    // each element is a CControlBar
protected:
	BOOL m_bLayoutQuery;
	CRect m_rectLayout;

	CControlBar* GetDockedControlBar(int nPos) const;

	// implementation helpers
	int Insert(CControlBar* pBar, CRect rect, CPoint ptMid);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	//{{AFX_MSG(CDockBar)
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg void OnPaint();
	afx_msg LRESULT OnSizeParent(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CMiniDockFrameWnd;
};

class CMiniDockFrameWnd : public CMiniFrameWnd
{
	DECLARE_DYNCREATE(CMiniDockFrameWnd)

public:
// Construction
	CMiniDockFrameWnd();
	virtual BOOL Create(CWnd* pParent, DWORD dwBarStyle);

// Operations
	virtual void RecalcLayout(BOOL bNotify = TRUE);

// Implementation
public:
	CDockBar m_wndDockBar;

	//{{AFX_MSG(CMiniFrameWnd)
	afx_msg void OnClose();
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	//}}AFX_MSG
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleCntrFrameWnd

class COleIPFrameWnd;

class COleCntrFrameWnd : public CFrameWnd
{
// Constructor
public:
	explicit COleCntrFrameWnd(COleIPFrameWnd* pInPlaceFrame);

// Implementation
protected:
	COleIPFrameWnd* m_pInPlaceFrame;
	virtual void PostNcDestroy();

public:
	virtual ~COleCntrFrameWnd();
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	void OnIdleUpdateCmdUI();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
#ifdef _DEBUG
	void AssertValid() const;
#endif
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CDialogTemplate

class CDialogTemplate
{
// Constructors
public:
	/* explicit */ CDialogTemplate(const DLGTEMPLATE* pTemplate = NULL);
	explicit CDialogTemplate(HGLOBAL hGlobal);

// Attributes
	BOOL HasFont() const;
	BOOL SetFont(LPCTSTR lpFaceName, WORD nFontSize);
	BOOL SetSystemFont(WORD nFontSize = 0);
	BOOL GetFont(CString& strFaceName, WORD& nFontSize) const;
	void GetSizeInDialogUnits(SIZE* pSize) const;
	void GetSizeInPixels(SIZE* pSize) const;

	static BOOL AFX_CDECL GetFont(const DLGTEMPLATE* pTemplate,
		CString& strFaceName, WORD& nFontSize);

// Operations
	BOOL Load(LPCTSTR lpDialogTemplateID);
	HGLOBAL Detach();

// Implementation
public:
	~CDialogTemplate();

	HGLOBAL m_hTemplate;
	DWORD m_dwTemplateSize;
	BOOL m_bSystemFont;

protected:
	static BYTE* AFX_CDECL GetFontSizeField(const DLGTEMPLATE* pTemplate);
	static UINT AFX_CDECL GetTemplateSize(const DLGTEMPLATE* pTemplate);
	BOOL SetTemplate(const DLGTEMPLATE* pTemplate, UINT cb);
};

/////////////////////////////////////////////////////////////////////////////
// WM_NOTIFY support

struct AFX_NOTIFY
{
	LRESULT* pResult;
	NMHDR* pNMHDR;
};


////////////////////////////////////////////////////////////////////////////
// other global state
class CPushRoutingFrame
{
protected:
	CFrameWnd* pOldRoutingFrame;
	_AFX_THREAD_STATE* pThreadState;
   CPushRoutingFrame* pOldPushRoutingFrame;

public:
	explicit CPushRoutingFrame(CFrameWnd* pNewRoutingFrame)
	{ 
		pThreadState = AfxGetThreadState();
	  pOldPushRoutingFrame = pThreadState->m_pPushRoutingFrame;
		pOldRoutingFrame = pThreadState->m_pRoutingFrame;
		pThreadState->m_pRoutingFrame = pNewRoutingFrame;
	  pThreadState->m_pPushRoutingFrame = this;
	}
	~CPushRoutingFrame()
	{ 
	  if (pThreadState != NULL)
	  {
		 ASSERT( pThreadState->m_pPushRoutingFrame == this );
		 pThreadState->m_pRoutingFrame = pOldRoutingFrame;
		 pThreadState->m_pPushRoutingFrame = pOldPushRoutingFrame;
	  }
   }
   void Pop()
   {
	  ENSURE( pThreadState != NULL );
	  ASSERT( pThreadState->m_pPushRoutingFrame == this );
	  pThreadState->m_pRoutingFrame = pOldRoutingFrame;
	  pThreadState->m_pPushRoutingFrame = pOldPushRoutingFrame;
	  pThreadState = NULL;
   }
};

#ifndef _WIN32_WCE
class CChevronOwnerDrawMenu : public CMenu
{
public:
	CChevronOwnerDrawMenu();

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

private:
	CFont m_MenuFont;
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// Global implementation helpers

// window creation hooking
void AFXAPI AfxHookWindowCreate(CWnd* pWnd);
BOOL AFXAPI AfxUnhookWindowCreate();
void AFXAPI AfxResetMsgCache();

#ifdef _WIN32_WCE
BOOL AFXAPI PreCreateWindowEx(CREATESTRUCT& cs);
void AFXAPI PostCreateWindowEx(CREATESTRUCT& cs, HWND hWnd, HMENU nIDorHMenu);
#endif // _WIN32_WCE

// for backward compatibility to previous versions
#define _AfxHookWindowCreate    AfxHookWindowCreate
#define _AfxUnhookWindowCreate  AfxUnhookWindowCreate

// string helpers
void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew);
int AFXAPI AfxLoadString(__in UINT nIDS, __out_ecount_part_z(nMaxBuf, return + 1) LPSTR lpszBuf, __in UINT nMaxBuf = 256);
int AFXAPI AfxLoadString(__in UINT nIDS, __out_ecount_part_z(nMaxBuf, return + 1) LPWSTR lpszBuf, __in UINT nMaxBuf = 256);

HDC AFXAPI AfxCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode);

void AFXAPI AfxGetModuleShortFileName(HINSTANCE hInst, CString& strShortName);

// Failure dialog helpers
void AFXAPI AfxFailMaxChars(CDataExchange* pDX, int nChars);
void AFXAPI AfxFailRadio(CDataExchange* pDX);

#ifndef __AFXCONV_H__
#include <afxconv.h>
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFXPRIV_H__

/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXPRIV2_H__
#include <afxpriv2.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxtls_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTLS_H__
#define __AFXTLS_H__

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

// Classes declared in this file

class CSimpleList;
class CThreadSlotData;                  // for manipulationg thread local storage
class CThreadLocalObject;               // for storing thread local data
class CProcessLocalObject;              // for storing thread local data
class CNoTrackObject;

// template class CTypedSimpleList<>
// template class CThreadLocal<>
// template class CProcessLocal<>

/////////////////////////////////////////////////////////////////////////////
// CSimpleList (simple/small subset of CList)

class CSimpleList
{
public:
	CSimpleList(int nNextOffset = 0);
	void Construct(int nNextOffset);

// Operations
	BOOL IsEmpty() const;
	void AddHead(void* p);
	void RemoveAll();
	void* GetHead() const;
	void* GetNext(void* p) const;
	BOOL Remove(void* p);

// Implementation
	void* m_pHead;
	size_t m_nNextOffset;

	void** GetNextPtr(void* p) const;   // somewhat trusting...
};

AFX_INLINE CSimpleList::CSimpleList(int nNextOffset)
	{ m_pHead = NULL; m_nNextOffset = nNextOffset; }
AFX_INLINE void CSimpleList::Construct(int nNextOffset)
	{ ASSERT(m_pHead == NULL); m_nNextOffset = nNextOffset; }
AFX_INLINE BOOL CSimpleList::IsEmpty() const
	{ return m_pHead == NULL; }
AFX_INLINE void** CSimpleList::GetNextPtr(void* p) const
	{ ENSURE_ARG(p != NULL); return (void**)((BYTE*)p+m_nNextOffset); }
AFX_INLINE void CSimpleList::RemoveAll()
	{ m_pHead = NULL; }
AFX_INLINE void* CSimpleList::GetHead() const
	{ return m_pHead; }
AFX_INLINE void* CSimpleList::GetNext(void* prevElement) const
	{ return *GetNextPtr(prevElement); }

template<class TYPE>
class CTypedSimpleList : public CSimpleList
{
public:
	CTypedSimpleList(int nNextOffset = 0)
		: CSimpleList(nNextOffset) { }
	void AddHead(TYPE p)
		{ CSimpleList::AddHead(p); }
	TYPE GetHead()
		{ return (TYPE)CSimpleList::GetHead(); }
	TYPE GetNext(TYPE p)
		{ return (TYPE)CSimpleList::GetNext(p); }
	BOOL Remove(TYPE p)
		{ return CSimpleList::Remove((TYPE)p); }
	operator TYPE();		
};
template<class TYPE>
inline CTypedSimpleList<TYPE>::operator TYPE()
{ 
	return (TYPE)CSimpleList::GetHead(); 
}
/////////////////////////////////////////////////////////////////////////////
// CThreadSlotData - manages owned array of "slots" for thread local storage

struct CThreadData; // private to implementation
struct CSlotData;   // private to implementation

class CThreadSlotData
{
public:
	CThreadSlotData();

// Operations
	int AllocSlot();
	void FreeSlot(int nSlot);	
	void SetValue(int nSlot, void* pValue);
	// delete all values in process/thread
	void DeleteValues(HINSTANCE hInst, BOOL bAll = FALSE);
	// assign instance handle to just constructed slots
	void AssignInstance(HINSTANCE hInst);

// Implementation
	DWORD m_tlsIndex;   // used to access system thread-local storage

	int m_nAlloc;       // number of slots allocated (in UINTs)
	int m_nRover;       // (optimization) for quick finding of free slots
	int m_nMax;         // size of slot table below (in bits)
	CSlotData* m_pSlotData; // state of each slot (allocated or not)
	CTypedSimpleList<CThreadData*> m_list;  // list of CThreadData structures
	CRITICAL_SECTION m_sect;

	void* GetThreadValue(int nSlot); // special version for threads only!
	void* PASCAL operator new(size_t, void* p)
		{ return p; }
	void DeleteValues(CThreadData* pData, HINSTANCE hInst);
	~CThreadSlotData();
};

class AFX_NOVTABLE CNoTrackObject
{
public:
	void* PASCAL operator new(size_t nSize);
	void PASCAL operator delete(void*);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	void* PASCAL operator new(size_t nSize, LPCSTR, int);
#if _MSC_VER >= 1200
	void PASCAL operator delete(void* pObject, LPCSTR, int);
#endif
#endif
    virtual ~CNoTrackObject() {};
};

class AFX_NOVTABLE CThreadLocalObject
{
public:
// Attributes
	CNoTrackObject* GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)());
	CNoTrackObject* GetDataNA();

// Implementation
	int m_nSlot;
	~CThreadLocalObject();
};

class AFX_NOVTABLE CProcessLocalObject
{
public:
// Attributes
	CNoTrackObject* GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)());

// Implementation
	CNoTrackObject* volatile m_pObject;
	~CProcessLocalObject();
};

template<class TYPE>
class CThreadLocal : public CThreadLocalObject
{
// Attributes
public:
	AFX_INLINE TYPE* GetData()
	{
		TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&CreateObject);
		ENSURE(pData != NULL);
		return pData;
	}
	AFX_INLINE TYPE* GetDataNA()
	{
		TYPE* pData = (TYPE*)CThreadLocalObject::GetDataNA();
		return pData;
	}
	AFX_INLINE operator TYPE*()
	{ 
		return GetData(); 
	}
	AFX_INLINE TYPE* operator->()
	{ 
		return GetData(); 
	}

// Implementation
public:
	static CNoTrackObject* AFXAPI CreateObject()
		{ return new TYPE; }
};

#define THREAD_LOCAL(class_name, ident_name) \
	AFX_COMDAT CThreadLocal<class_name> ident_name;
#define EXTERN_THREAD_LOCAL(class_name, ident_name) \
	extern CThreadLocal<class_name> ident_name;

template<class TYPE>
class CProcessLocal : public CProcessLocalObject
{
// Attributes
public:
	AFX_INLINE TYPE* GetData()
	{
		TYPE* pData = (TYPE*)CProcessLocalObject::GetData(&CreateObject);
		ENSURE(pData != NULL);
		return pData;
	}
	AFX_INLINE TYPE* GetDataNA()
		{ return (TYPE*)m_pObject; }
	AFX_INLINE operator TYPE*()
		{ return GetData(); }
	AFX_INLINE TYPE* operator->()
		{ return GetData(); }

// Implementation
public:
	static CNoTrackObject* AFXAPI CreateObject()
		{ return new TYPE; }
};

#define PROCESS_LOCAL(class_name, ident_name) \
	AFX_COMDAT CProcessLocal<class_name> ident_name;
#define EXTERN_PROCESS_LOCAL(class_name, ident_name) \
	extern CProcessLocal<class_name> ident_name;

/////////////////////////////////////////////////////////////////////////////

void AFXAPI AfxInitLocalData(HINSTANCE hInstInit);
void AFXAPI AfxTermLocalData(HINSTANCE hInstTerm, BOOL bAll = FALSE);
void AFXAPI AfxTlsAddRef();
void AFXAPI AfxTlsRelease();

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#endif //__AFXTLS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxv_cfg.h ===
// afxv_cfg.h - target configuration control for non-Microsoft compilers
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// You can define _AFX_PORTABLE in order to keep the library from using
//  certain Microsoft extensions that are not commonly implemented by
//  other compilers.

#define _AFX_PORTABLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxsock.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXSOCK_H__
#define __AFXSOCK_H__

#pragma once

#ifdef _AFX_NO_SOCKET_SUPPORT
	#error Windows Sockets classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

	#include <atlsocket.h>
#ifndef _WINSOCK2API_
#ifdef _WINSOCKAPI_
	#error MFC requires use of Winsock2.h
#endif


#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _WIN32_WCE
#pragma comment(lib, "wsock32.lib")
#else
#pragma comment(lib, "ws2.lib")
#endif // !_WIN32_WCE

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXSOCK - MFC support for Windows Sockets

// Classes declared in this file

	// CObject
		class CAsyncSocket; // Async Socket implementation and
							// base class for Synchronous Socket
			class CSocket;  // Synchronous Socket

	// CFile
		class CSocketFile; // Used with CSocket and CArchive for
						   // streaming objects on sockets.

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_NET_DATA

/////////////////////////////////////////////////////////////////////////////
// CSocketWnd -- internal use only
//  Implementation for sockets notification callbacks.
//  Future versions of MFC may or may not include this exact class.

class CSocketWnd : public CWnd
{
// Construction
public:
	CSocketWnd();

protected:
	//{{AFX_MSG(CSocketWnd)
	LRESULT OnSocketNotify(WPARAM wParam, LPARAM lParam);
	LRESULT OnSocketDead(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket

class CAsyncSocket : public CObject
{
	DECLARE_DYNAMIC(CAsyncSocket);
private:
	CAsyncSocket(const CAsyncSocket& rSrc);    // no implementation
	void operator=(const CAsyncSocket& rSrc);  // no implementation

public:
#ifdef _WIN32_WCE
	class CSocketInfo 
	{
// Construction and destruction
public:
		CSocketInfo() 
		{
			InitializeCriticalSection(&m_sectData);
			InitializeCriticalSection(&m_sectSocketTerm);
			m_bSocketInitialized = FALSE;
		}

		virtual ~CSocketInfo()
		{
			DeleteCriticalSection(&m_sectData);
			DeleteCriticalSection(&m_sectSocketTerm);
		}		
// properties
public:
		CMapPtrToPtr m_pmapSocketEvent;
		CMapPtrToPtr m_pmapSocketWindow;

		BOOL m_bSocketInitialized;

		CRITICAL_SECTION m_sectData;
		CRITICAL_SECTION m_sectSocketTerm;
		HANDLE m_hMapUpdatedEvent;
		HANDLE m_hThreadTerminatedEvent;
		HANDLE m_hSocketTerminatedEvent;

		CWinThread* m_pWorkerThread;

// operations
public:
		static UINT WorkerThreadProc(LPVOID param);
		static BOOL Init();
		static void Term();

		static void OnSocketDead(SOCKET hSocket);
	};
	static CSocketInfo afxSocketInfo;
#endif // _WIN32_WCE

// Construction
public:
	CAsyncSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		LPCTSTR lpszSocketAddress = NULL);

	BOOL CreateEx(ADDRINFOT* pAI, 
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

// Attributes
public:
	SOCKET m_hSocket;
#ifdef _WIN32_WCE
	long m_lEvent;
#endif // _WIN32_WCE

	operator SOCKET() const;
	BOOL Attach(SOCKET hSocket, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
	SOCKET Detach();

	BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
	BOOL GetPeerNameEx(CString& rPeerAddress, UINT& rPeerPort);	

	BOOL GetSockName(CString& rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
	BOOL GetSockNameEx(CString& rSocketAddress, UINT& rSocketPort);

	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue,
		int nOptionLen, int nLevel = SOL_SOCKET);
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue,
		int* lpOptionLen, int nLevel = SOL_SOCKET);

	static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket);
	static int PASCAL GetLastError();

// Operations
public:

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress = NULL);
	BOOL Bind (const SOCKADDR* lpSockAddr, int nSockAddrLen);
	BOOL BindEx(ADDRINFOT* pAI);

	virtual void Close();

	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	BOOL ConnectEx(ADDRINFOT* pAI);

	BOOL IOCtl(long lCommand, DWORD* lpArgument);

	BOOL Listen(int nConnectionBacklog=5);

	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	int ReceiveFrom(void* lpBuf, int nBufLen,
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0);
	int ReceiveFromEx(void* lpBuf, int nBufLen,
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
		

	enum { receives = 0, sends = 1, both = 2 };
	BOOL ShutDown(int nHow = sends);

	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendTo(const void* lpBuf, int nBufLen,
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0);
	int SendToEx(const void* lpBuf, int nBufLen,
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);

	BOOL AsyncSelect(long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
// Overridable callbacks
protected:
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);
	virtual void OnOutOfBandData(int nErrorCode);
	virtual void OnAccept(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnClose(int nErrorCode);

// Implementation
public:
	virtual ~CAsyncSocket();

	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead = FALSE);
	static void PASCAL DetachHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL KillSocket(SOCKET hSocket, CAsyncSocket* pSocket);
	static void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);

	BOOL Socket(int nSocketType=SOCK_STREAM, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		int nProtocolType = 0, int nAddressFormat = PF_INET);

#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif

protected:
	friend class CSocketWnd;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
};

/////////////////////////////////////////////////////////////////////////////
// CSocket

class CSocket : public CAsyncSocket
{
	DECLARE_DYNAMIC(CSocket);
private:
	CSocket(const CSocket& rSrc);         // no implementation
	void operator=(const CSocket& rSrc);  // no implementation

// Construction
public:
	CSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		LPCTSTR lpszSocketAddress = NULL);

// Attributes
public:
	BOOL IsBlocking();
	static CSocket* PASCAL FromHandle(SOCKET hSocket);
	BOOL Attach(SOCKET hSocket);

// Operations
public:
	void CancelBlockingCall();

// Overridable callbacks
protected:
	virtual BOOL OnMessagePending();

// Implementation
public:
	int m_nTimeOut;

	virtual ~CSocket();

	static int PASCAL ProcessAuxQueue();

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendChunk(const void* lpBuf, int nBufLen, int nFlags);

protected:
	friend class CSocketWnd;

	BOOL* m_pbBlocking;
	int m_nConnectError;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);

	static void PASCAL AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam);

	virtual BOOL PumpMessages(UINT uStopFlag);

#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSocketFile

class CSocketFile : public CFile
{
	DECLARE_DYNAMIC(CSocketFile)
public:
//Constructors
	explicit CSocketFile(CSocket* pSocket, BOOL bArchiveCompatible = TRUE);

// Implementation
public:
	CSocket* m_pSocket;
	BOOL m_bArchiveCompatible;

	virtual ~CSocketFile();

	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount, void** ppBufStart,
		void** ppBufMax);
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Close();

// Unsupported APIs
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL);
	virtual CFile* Duplicate() const;
	virtual ULONGLONG GetPosition() const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void Flush();
	virtual void Abort();
};

/////////////////////////////////////////////////////////////////////////////
// Global functions

BOOL AFXAPI AfxSocketInit(WSADATA* lpwsaData = NULL);
void AFXAPI AfxSocketTerm();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXSOCK_INLINE AFX_INLINE
#include <afxsock.inl>
#undef _AFXSOCK_INLINE
#endif

inline BOOL CAsyncSocket::CreateEx(ADDRINFOT* pAI, long lEvent)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Socket(pAI->ai_socktype, lEvent, pAI->ai_protocol, pAI->ai_family);
}

inline BOOL CAsyncSocket::BindEx(ADDRINFOT* pAI)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Bind((SOCKADDR*)pAI->ai_addr, (int)pAI->ai_addrlen);
}

inline BOOL CAsyncSocket::ConnectEx(ADDRINFOT* pAI)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Connect((SOCKADDR*)pAI->ai_addr, (int)pAI->ai_addrlen);
}

inline BOOL CAsyncSocket::GetPeerNameEx(CString& rPeerAddress, UINT& rPeerPort)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetPeerName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		char szName[NI_MAXHOST];
		bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rPeerAddress = szName;
			rPeerPort = ntohs(SS_PORT(&sockAddr));
		}
	}
	return bResult;
}

inline BOOL CAsyncSocket::GetSockNameEx(CString& rSocketAddress, UINT& rSocketPort)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetSockName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		char szName[NI_MAXHOST];
		bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rSocketAddress = szName;
			rSocketPort = ntohs(SS_PORT(&sockAddr));
		}
	}
	return bResult;
}

inline int CAsyncSocket::ReceiveFromEx(void* lpBuf, int nBufLen, CString& rSocketAddress, UINT& rSocketPort, int nFlags)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	int nResult = ReceiveFrom(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, &nSockAddrLen, nFlags);
	if(nResult != SOCKET_ERROR)
	{
		char szName[NI_MAXHOST];
		BOOL bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rSocketAddress = szName;
			rSocketPort = ntohs(SS_PORT(&sockAddr));
		}
	}
	return nResult;
}

inline int CAsyncSocket::SendToEx(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress, int nFlags)
{
	if (lpszHostAddress == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}
	
	SOCKADDR_STORAGE sockAddrSelf;
	memset(&sockAddrSelf, 0, sizeof(sockAddrSelf));

	int nSockAddrSelfLen = sizeof(sockAddrSelf);

	BOOL bResult = GetSockName((SOCKADDR*)&sockAddrSelf, &nSockAddrSelfLen);
	if (!bResult)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;		
	}
	
	int nSocketType;
	int nSocketTypeLen = int(sizeof(int));
	if (!GetSockOpt(SO_TYPE, &nSocketType, &nSocketTypeLen))
	{
		return SOCKET_ERROR;
	}

	ATL::CSocketAddr sockAddr;
	int nRet = sockAddr.FindAddr(lpszHostAddress, nHostPort, 0, sockAddrSelf.ss_family, nSocketType, 0);
	if (nRet != 0)
	{
		WSASetLastError(nRet);
		return SOCKET_ERROR;
	}
	
	ADDRINFOT *p = sockAddr.GetAddrInfo();

	return SendTo(lpBuf, nBufLen, p->ai_addr, (int)p->ai_addrlen, nFlags);
}

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFXSOCK_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
   #include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef RC_INVOKED
	#if defined(_VC80_UPGRADE) && (_VC80_UPGRADE >= 0x0700) && (_VC80_UPGRADE < 0x0800) && defined(IDR_MANIFEST)
		// Handle project upgrade from VC7/VC7.1 for projects with manifest
		#define IDR_MANIFEST	1024
	#endif
#endif	// RC_INVOKED

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Manifest Resource ID of manifest containing Localized DLL information
#define ID_MFCLOC_MANIFEST             1000

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

#ifndef _WIN32_WCE // Docking
// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F
#endif // !_WIN32_WCE

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C
#define ID_FILE_NEW_FRAME               0xE10D

#ifndef _WIN32_WCE // Recent File List
#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F
#endif // !_WIN32_WCE

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

#ifndef _WIN32_WCE // Printing
// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306
#endif // !_WIN32_WCE

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
   // E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
   // E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024
#define AFX_IDS_INVALID_ARG_EXCEPTION   0xF025

#ifndef _WIN32_WCE // Printing
// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049
#endif // !_WIN32_WCE


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#ifndef _WIN32_WCE // OLE
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#endif // !_WIN32_WCE
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119
#define AFX_IDP_PARSE_GUID              0xF11A
#define AFX_IDP_PARSE_TIME              0xF11B
#define AFX_IDP_PARSE_DATE              0xF11C

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// Script errors / prompt strings
#ifndef _WIN32_WCE // Script
#define AFX_IDP_SCRIPT_ERROR            0xF130
#define AFX_IDP_SCRIPT_DISPATCH_EXCEPTION 0xF131
#endif // !_WIN32_WCE

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#ifndef _WIN32_WCE // Ole
#define AFX_IDS_NOT_DOCOBJECT           0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#endif // !_WIN32_WCE
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#ifndef _WIN32_WCE // MAPI
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192
#endif // !_WIN32_WCE

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

#ifndef _WIN32_WCE // DB
// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                   0xF29D
#endif // !_WIN32_WCE

#ifndef _WIN32_WCE // DAO
// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5
#endif // !_WIN32_WCE

#ifndef _WIN32_WCE // Internet Server API
/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// Strings for Accessibility support for CCheckListBox
#define AFX_IDS_CHECKLISTBOX_UNCHECK	0xF2E1
#define AFX_IDS_CHECKLISTBOX_CHECK	0xF2E2
#define AFX_IDS_CHECKLISTBOX_MIXED	0xF2E3

#ifdef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// Strings for Doclist support
#define AFX_IDS_INTL_ALLFILES		0xFF01
#define AFX_IDS_INTL_ALLFOLDERS		0xFF02
#define AFX_IDS_INTL_DIRMYDOCUMENTS	0xFF03
#endif // _WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101
#define AFX_IDC_BROWSER             102

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

#ifdef _WIN32_WCE
#define AFX_IDR_SCRATCH_SHMENU          28700
#endif // _WIN32_WCE

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#ifndef _WIN32_WCE // Printing
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723
#endif // !_WIN32_WCE

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

//WinForms
#define AFX_IDD_EMPTYDIALOG				30734

// Standard cursors (0x7901->)
   // AFX_IDC = Cursor resources
#ifndef _WIN32_WCE // Help
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#endif // !_WIN32_WCE
#ifndef _WIN32_WCE // Splitter
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#endif // !_WIN32_WCE
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Wheel mouse cursors
// NOTE: values must be in this order!  See CScrollView::OnTimer()
#ifndef _WIN32_WCE // Mouse
#define AFX_IDC_MOUSE_PAN_NW            30998       // pan east
#define AFX_IDC_MOUSE_PAN_N             30999       // pan northeast
#define AFX_IDC_MOUSE_PAN_NE            31000       // pan north
#define AFX_IDC_MOUSE_PAN_W             31001       // pan northwest
#define AFX_IDC_MOUSE_PAN_HV            31002       // pan both axis
#define AFX_IDC_MOUSE_PAN_E             31003       // pan west
#define AFX_IDC_MOUSE_PAN_SW            31004       // pan south-west
#define AFX_IDC_MOUSE_PAN_S             31005       // pan south
#define AFX_IDC_MOUSE_PAN_SE            31006       // pan south-east
#define AFX_IDC_MOUSE_PAN_HORZ          31007       // pan X-axis
#define AFX_IDC_MOUSE_PAN_VERT          31008       // pan Y-axis
#endif // !_WIN32_WCE

// Wheel mouse bitmaps
#define AFX_IDC_MOUSE_ORG_HORZ          31009       // anchor for horz only
#define AFX_IDC_MOUSE_ORG_VERT          31010       // anchor for vert only
#define AFX_IDC_MOUSE_ORG_HV            31011       // anchor for horz/vert
#define AFX_IDC_MOUSE_MASK              31012

// Mini frame window bitmap ID
#ifndef _WIN32_WCE // Mini Frame
#define AFX_IDB_MINIFRAME_MENU          30994
#endif // !_WIN32_WCE

// CheckListBox checks bitmap ID
#ifndef _WIN32_WCE // CheckListBox
#define AFX_IDB_CHECKLISTBOX_95         30996
#endif // !_WIN32_WCE

// AFX standard accelerator resources
#ifndef _WIN32_WCE // Printing
#define AFX_IDR_PREVIEW_ACCEL           30997
#endif // !_WIN32_WCE

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#ifndef _WIN32_WCE // MDI Frame
#define AFX_IDI_STD_MDIFRAME            31233
#endif // !_WIN32_WCE
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXSTR.H - Framework-independent, templateable string class

#ifndef __AFXSTR_H__
#define __AFXSTR_H__

#pragma once

#ifndef _AFX
#error afxstr.h can only be used in MFC projects.  Use atlstr.h
#endif

#ifndef _WIN32_WCE
#include <mbstring.h>
#endif // _WIN32_WCE

HINSTANCE AFXAPI AfxGetResourceHandle();
HINSTANCE AFXAPI AfxFindStringResourceHandle(UINT nID);

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
UINT_PTR AFXAPI AfxReadStringLength(CArchive& ar, int& nCharSize);
void AFXAPI AfxWriteStringLength(CArchive& ar, UINT_PTR nLength, BOOL bUnicode);
#endif // _WIN32_WCE_NO_ARCHIVE_SUPPORT

#include <atlcore.h>
#ifndef _WIN32_WCE
#include <cstringt.h>
#else
#include <atlstr.h>
#endif // !_WIN32_WCE

ATL::IAtlStringMgr* AFXAPI AfxGetStringManager();

#ifndef _WIN32_WCE
template< typename _CharType = char, class StringIterator = ATL::ChTraitsCRT< _CharType > >
#else
template< typename _CharType = char, class StringIterator = ATL::ChTraitsOS< _CharType > >
#endif // !_WIN32_WCE
class StrTraitMFC : 
	public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance( UINT nID ) throw()
	{
		return( AfxFindStringResourceHandle( nID ) );
	}

	static ATL::IAtlStringMgr* GetDefaultManager() throw()
	{
		return( AfxGetStringManager() );
	}
};

template< typename _CharType, class StringIterator>
class StrTraitMFC_DLL : public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance( UINT nID ) throw()
	{
		return( AfxFindStringResourceHandle( nID ) );
	}

	static ATL::IAtlStringMgr* GetDefaultManager() throw()
	{
		return( AfxGetStringManager() );
	}
};

// MFC-enabled compilation. Use MFC memory management and exceptions;
// also, use MFC module state.

// Don't import when MFC dll is being built
#if defined(_AFXDLL)

#if defined(_MFC_DLL_BLD)

#ifndef _WIN32_WCE
template class ATL::CSimpleStringT< char, true >;
template class ATL::CStringT< char, StrTraitMFC_DLL< char > >;
#endif // !_WIN32_WCE
template class ATL::CSimpleStringT< wchar_t, true >;
template class ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > >;

#else

#ifndef _WIN32_WCE
template class __declspec(dllimport) ATL::CSimpleStringT< char, true >;
template class __declspec(dllimport) ATL::CStringT< char, StrTraitMFC_DLL< char > >;
#endif // !_WIN32_WCE
template class __declspec(dllimport) ATL::CSimpleStringT< wchar_t, true >;
template class __declspec(dllimport) ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > >;
#if defined(_NATIVE_WCHAR_T)
template class __declspec(dllimport) ATL::CSimpleStringT< unsigned short, true >;
template class __declspec(dllimport) ATL::CStringT< unsigned short, StrTraitMFC_DLL< unsigned short > >;
#endif	// _NATIVE_WCHAR_T

#endif	// _MFC_DLL_BLD

typedef ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > > CStringW;
typedef ATL::CStringT< char, StrTraitMFC_DLL< char > > CStringA;
typedef ATL::CStringT< TCHAR, StrTraitMFC_DLL< TCHAR > > CString;

#else

typedef ATL::CStringT< wchar_t, StrTraitMFC< wchar_t > > CStringW;
typedef ATL::CStringT< char, StrTraitMFC< char > > CStringA;
typedef ATL::CStringT< TCHAR, StrTraitMFC< TCHAR > > CString;

#endif	// _AFXDLL

#endif	// __AFXSTR_H__ (whole file)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxv_dll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// special header for _AFXDLL variant.

// default AFX_XXX_DATA and AFX_XXX_DATADEF macros for using MFC DLLs

#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA       AFX_DATA_IMPORT
	#define AFX_CORE_DATADEF
#endif

#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA        AFX_DATA_IMPORT
	#define AFX_OLE_DATADEF
#endif

#ifndef AFX_DB_DATA
	#define AFX_DB_DATA         AFX_DATA_IMPORT
	#define AFX_DB_DATADEF
#endif

#ifndef AFX_NET_DATA
	#define AFX_NET_DATA        AFX_DATA_IMPORT
	#define AFX_NET_DATADEF
#endif

// default AFX_EXT_DATA and AFX_EXT_DATADEF macros for using or
//  creating MFC extension DLLs, depending on _AFX_EXT_IMPL
// AFX_EXT_CLASS can be used to import or export entire classes
//  in an extension DLL without the hassle of creating a .DEF file
//  with decorated names.

#ifndef AFX_EXT_DATA
	#ifdef _AFXEXT
		#define AFX_EXT_CLASS       AFX_CLASS_EXPORT
		#define AFX_EXT_API         AFX_API_EXPORT
		#define AFX_EXT_DATA        AFX_DATA_EXPORT
		#define AFX_EXT_DATADEF
	#else
		#define AFX_EXT_CLASS       AFX_CLASS_IMPORT
		#define AFX_EXT_API         AFX_API_IMPORT
		#define AFX_EXT_DATA        AFX_DATA_IMPORT
		#define AFX_EXT_DATADEF
	#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxstat_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXSTATE_H__
#define __AFXSTATE_H__

#pragma once


#ifndef __ATLTYPES_H__
#include <atltypes.h>
#endif

#ifdef _WIN32_WCE
#include <afxtempl.h>
#endif // _WIN32_WCE

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifndef __AFXTLS_H__
	#include <afxtls_.h>
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// _AFX_DEBUG_STATE

#ifdef _DEBUG

class _AFX_DEBUG_STATE : public CNoTrackObject
{
public:
	_AFX_DEBUG_STATE();
	virtual ~_AFX_DEBUG_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_DEBUG_STATE, afxDebugState)

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// _AFX_WIN_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_WIN_STATE : public CNoTrackObject
{
public:
	// printing abort
	BOOL m_bUserAbort;
};

EXTERN_PROCESS_LOCAL(_AFX_WIN_STATE, _afxWinState)

/////////////////////////////////////////////////////////////////////////////
// Type library cache - AFX_INTERNAL

#ifndef _AFX_NO_OLE_SUPPORT

struct ITypeInfo;
typedef ITypeInfo* LPTYPEINFO;

struct ITypeLib;
typedef ITypeLib* LPTYPELIB;

typedef struct _GUID GUID;
#ifndef _REFCLSID_DEFINED
#define REFGUID const GUID &
#endif

class CTypeLibCache
{
public:
	CTypeLibCache() : m_cRef(0), m_lcid((LCID)-1), m_ptlib(NULL), m_ptinfo(NULL) {}
	void Lock();
	void Unlock();
	BOOL Lookup(LCID lcid, LPTYPELIB* pptlib);
	void Cache(LCID lcid, LPTYPELIB ptlib);
	BOOL LookupTypeInfo(LCID lcid, REFGUID guid, LPTYPEINFO* pptinfo);
	void CacheTypeInfo(LCID lcid, REFGUID guid, LPTYPEINFO ptinfo);
	const GUID* m_pTypeLibID;

protected:
	LCID m_lcid;
	LPTYPELIB m_ptlib;
	GUID m_guidInfo;
	LPTYPEINFO m_ptinfo;
	long m_cRef;
};

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// AFX_MODULE_STATE : portion of state that is pushed/popped

// forward references required for AFX_MODULE_THREAD_STATE definition
class CWinThread;
class CHandleMap;
class CFrameWnd;
class CToolTipCtrl;
class CControlBar;
class CWnd;

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

template<class TYPE> 
class CEmbeddedButActsLikePtr
{
public:
	AFX_INLINE TYPE* operator->() { return &m_data; }
	AFX_INLINE operator TYPE*() { return &m_data; }
	TYPE m_data;
};

// AFX_MODULE_THREAD_STATE (local to thread *and* module)
class AFX_MODULE_THREAD_STATE : public CNoTrackObject
{
public:
	AFX_MODULE_THREAD_STATE();
	virtual ~AFX_MODULE_THREAD_STATE();

	// current CWinThread pointer
	CWinThread* m_pCurrentWinThread;

	// list of CFrameWnd objects for thread
	CTypedSimpleList<CFrameWnd*> m_frameList;

	// temporary/permanent map state
	DWORD m_nTempMapLock;           // if not 0, temp maps locked
	CHandleMap* m_pmapHWND;
	CHandleMap* m_pmapHMENU;
	CHandleMap* m_pmapHDC;
	CHandleMap* m_pmapHGDIOBJ;
	CHandleMap* m_pmapHIMAGELIST;

	// thread-local MFC new handler (separate from C-runtime)
	_PNH m_pfnNewHandler;

#ifndef _AFX_NO_SOCKET_SUPPORT
	// WinSock specific thread state
	HWND m_hSocketWindow;
#ifdef _AFXDLL
	CEmbeddedButActsLikePtr<CMapPtrToPtr> m_pmapSocketHandle;
	CEmbeddedButActsLikePtr<CMapPtrToPtr> m_pmapDeadSockets;
	CEmbeddedButActsLikePtr<CPtrList> m_plistSocketNotifications;
#else
	CMapPtrToPtr* m_pmapSocketHandle;
	CMapPtrToPtr* m_pmapDeadSockets;
	CPtrList* m_plistSocketNotifications;
#endif
#endif

	// common controls thread state
#ifndef _WIN32_WCE_NO_TOOLTIPS
	CToolTipCtrl* m_pToolTip;
	CWnd* m_pLastHit;       // last window to own tooltip
	INT_PTR m_nLastHit;         // last hittest code
	TOOLINFO* m_pLastInfo;    // last TOOLINFO structure
	INT_PTR m_nLastStatus;      // last flyby status message
	CControlBar* m_pLastStatus; // last flyby status control bar
#endif // !_WIN32_WCE_NO_TOOLTIPS
};

// forward references required for AFX_MODULE_STATE definition
class CWinApp;
class COleObjectFactory;

class CWnd;

#ifdef _AFXDLL
class CDynLinkLibrary;
#endif

#ifndef _AFX_NO_OCC_SUPPORT
class COccManager;
class COleControlLock;
#endif

#ifndef _AFX_NO_DAO_SUPPORT
class _AFX_DAO_STATE;
#endif

class CDllIsolationWrapperBase;
#ifndef _AFX_NO_AFXCMN_SUPPORT
class CComCtlWrapper;
#endif
class CCommDlgWrapper;

class CTypeLibCacheMap : public CMapPtrToPtr
{
public:
	virtual void RemoveAll(void* pExcept);
};


// AFX_MODULE_STATE (global data for a module)
class AFX_MODULE_STATE : public CNoTrackObject
{
public:
#ifdef _AFXDLL
	AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,
		BOOL bSystem = FALSE);
#else
	explicit AFX_MODULE_STATE(BOOL bDLL);
#endif
	~AFX_MODULE_STATE();

	CWinApp* m_pCurrentWinApp;
	HINSTANCE m_hCurrentInstanceHandle;
	HINSTANCE m_hCurrentResourceHandle;
	LPCTSTR m_lpszCurrentAppName;
	BYTE m_bDLL;    // TRUE if module is a DLL, FALSE if it is an EXE
	BYTE m_bSystem; // TRUE if module is a "system" module, FALSE if not
	BYTE m_bReserved[2]; // padding

	DWORD m_fRegisteredClasses; // flags for registered window classes

	// runtime class data
#ifdef _AFXDLL
	CRuntimeClass* m_pClassInit;
#endif
	CTypedSimpleList<CRuntimeClass*> m_classList;

	// OLE object factories
#ifndef _AFX_NO_OLE_SUPPORT
#ifdef _AFXDLL
	COleObjectFactory* m_pFactoryInit;
#endif
	CTypedSimpleList<COleObjectFactory*> m_factoryList;
#endif
	// number of locked OLE objects
	long m_nObjectCount;
	BOOL m_bUserCtrl;

	// AfxRegisterClass and AfxRegisterWndClass data

	CString m_strUnregisterList;

#ifdef _AFXDLL
	WNDPROC m_pfnAfxWndProc;
	DWORD m_dwVersion;  // version that module linked against
#endif

	// variables related to a given process in a module
	//  (used to be AFX_MODULE_PROCESS_STATE)
#ifndef _WIN32_WCE_NO_TOOLTIPS
	void (PASCAL *m_pfnFilterToolTipMessage)(MSG*, CWnd*);
#endif // !_WIN32_WCE_NO_TOOLTIPS

#ifdef _AFXDLL
	// CDynLinkLibrary objects (for resource chain)
	CTypedSimpleList<CDynLinkLibrary*> m_libraryList;

	// special case for MFC80XXX.DLL (localized MFC resources)
	HINSTANCE m_appLangDLL;
#endif

#ifndef _AFX_NO_OCC_SUPPORT
	// OLE control container manager
	COccManager* m_pOccManager;
	// locked OLE controls
	CTypedSimpleList<COleControlLock*> m_lockList;
#endif

#ifndef _AFX_NO_DAO_SUPPORT
	_AFX_DAO_STATE* m_pDaoState;
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// Type library caches
	CTypeLibCache m_typeLibCache;
	CTypeLibCacheMap* m_pTypeLibCacheMap;
#endif

	// define thread local portions of module state
	CThreadLocal<AFX_MODULE_THREAD_STATE> m_thread;

#ifndef _WIN32_WCE
	//Fusion: declare pointer to array of pointers to isolation aware dll wrappers (ex: comctl32).
	CDllIsolationWrapperBase** m_pDllIsolationWrappers;
	//Defaults to TRUE. When FALSE - MFC will not activate context in AFX_MAINTAIN_STATE2 (used by AFX_MANAGE_STATE).
	BOOL	m_bSetAmbientActCtx;
	//Handle of the module context.
	HANDLE	m_hActCtx;
	void CreateActivationContext();
#else // !_WIN32_WCE
	CComCtlWrapper* m_pComCtlWrapper;
#endif // !_WIN32_WCE
};

AFX_MODULE_STATE* AFXAPI AfxGetAppModuleState();
#ifdef _AFXDLL
AFX_MODULE_STATE* AFXAPI AfxSetModuleState(AFX_MODULE_STATE* pNewState);
#endif
AFX_MODULE_STATE* AFXAPI AfxGetModuleState();
BOOL AFXAPI AfxIsModuleDll();
BOOL AFXAPI AfxInitCurrentStateApp();
AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState();
HINSTANCE AFXAPI AfxGetInstanceHandleHelper();

AFX_MODULE_THREAD_STATE* AFXAPI AfxGetModuleThreadState();

#ifdef _AFXDLL
#define _AFX_CMDTARGET_GETSTATE() (m_pModuleState)
#else
#define _AFX_CMDTARGET_GETSTATE() (AfxGetModuleState())
#endif

/////////////////////////////////////////////////////////////////////////////
// macros & classes to manage pushing/popping the module state

#ifdef _AFXDLL
struct AFX_MAINTAIN_STATE
{
	explicit AFX_MAINTAIN_STATE(AFX_MODULE_STATE* pModuleState) throw();
	~AFX_MAINTAIN_STATE();

protected:
	AFX_MODULE_STATE* m_pPrevModuleState;
};
#endif

class _AFX_THREAD_STATE;
struct AFX_MAINTAIN_STATE2
{
	explicit AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pModuleState) throw();
	~AFX_MAINTAIN_STATE2();

protected:
#ifdef _AFXDLL
	AFX_MODULE_STATE* m_pPrevModuleState;
	_AFX_THREAD_STATE* m_pThreadState;
#endif

#ifndef _WIN32_WCE
	ULONG_PTR m_ulActCtxCookie;
	BOOL m_bValidActCtxCookie;
#endif // !_WIN32_WCE
};
#define AFX_MANAGE_STATE(p) AFX_MAINTAIN_STATE2 _ctlState(p);

/////////////////////////////////////////////////////////////////////////////
// Thread global state

// forward references required for _AFX_THREAD_STATE definition
class CView;
class CToolTipCtrl;
class CControlBar;
class CPushRoutingFrame;
class CPushRoutingView;

#define _AFX_TEMP_CLASS_NAME_SIZE 96
class _AFX_THREAD_STATE : public CNoTrackObject
{
public:
	_AFX_THREAD_STATE();
	virtual ~_AFX_THREAD_STATE();

	// override for m_pModuleState in _AFX_APP_STATE
	AFX_MODULE_STATE* m_pModuleState;
	AFX_MODULE_STATE* m_pPrevModuleState;

	// memory safety pool for temp maps
	void* m_pSafetyPoolBuffer;    // current buffer

	// thread local exception context
	AFX_EXCEPTION_CONTEXT m_exceptionContext;

	// CWnd create, gray dialog hook, and other hook data
	CWnd* m_pWndInit;
#ifdef _WIN32_WCE
	WNDPROC m_pOldProc;
	CWnd* m_pWndInitPropertySheet;
#endif // _WIN32_WCE
	CWnd* m_pAlternateWndInit;      // special case commdlg hooking
	DWORD m_dwPropStyle;
	DWORD m_dwPropExStyle;
	HWND m_hWndInit;
#ifndef _WIN32_WCE
	HHOOK m_hHookOldCbtFilter;
	HHOOK m_hHookOldMsgFilter;
#endif // !_WIN32_WCE

	// message pump for Run
	MSG m_msgCur;                   // current message
	CPoint m_ptCursorLast;          // last mouse position
	UINT m_nMsgLast;                // last mouse message

#ifdef _DEBUG
		int m_nDisablePumpCount; // Diagnostic trap to detect illegal re-entrancy
#endif

	// other CWnd modal data
	MSG m_lastSentMsg;              // see CWnd::WindowProc
	HWND m_hTrackingWindow;         // see CWnd::TrackPopupMenu
	HMENU m_hTrackingMenu;
	TCHAR m_szTempClassName[_AFX_TEMP_CLASS_NAME_SIZE];    // see AfxRegisterWndClass
	HWND m_hLockoutNotifyWindow;    // see CWnd::OnCommand
	BOOL m_bInMsgFilter;

	// other framework modal data
	CView* m_pRoutingView;          // see CCmdTarget::GetRoutingView
   CPushRoutingView* m_pPushRoutingView;
	CFrameWnd* m_pRoutingFrame;     // see CCmdTarget::GetRoutingFrame
   CPushRoutingFrame* m_pPushRoutingFrame;

	// MFC/DB thread-local data
	BOOL m_bWaitForDataSource;

	// OLE control thread-local data
	CWnd* m_pWndPark;       // "parking space" window
	long m_nCtrlRef;        // reference count on parking window
	BOOL m_bNeedTerm;       // TRUE if OleUninitialize needs to be called
};

EXTERN_THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)

_AFX_THREAD_STATE* AFXAPI AfxGetThreadState();

#ifdef _WIN32_WCE
/////////////////////////////////////////////////////////////////////////////
// AYGSHELL state

typedef BOOL (__cdecl * AYGSHELL_SHCREATEMENUBAR)(SHMENUBARINFO*);
typedef BOOL (__cdecl * AYGSHELL_SHDONEBUTTON)(HWND, DWORD);
typedef HWND (__cdecl * AYGSHELL_SHFINDMENUBAR)(HWND);              //
typedef BOOL (__cdecl * AYGSHELL_SHHANDLEWMACTIVATE)(HWND, WPARAM, LPARAM, SHACTIVATEINFO*, DWORD);
typedef BOOL (__cdecl * AYGSHELL_SHHANDLEWMSETTINGCHANGE)(HWND, WPARAM, LPARAM, SHACTIVATEINFO*);
typedef BOOL (__cdecl * AYGSHELL_SHINITDIALOG)(PSHINITDLGINFO);
typedef DWORD (__cdecl * AYGSHELL_SHRECOGNIZEGESTURE)(SHRGINFO*);
typedef BOOL (__cdecl * AYGSHELL_SHSIPINFO)(UINT, UINT, PVOID, UINT);
typedef BOOL (__cdecl * AYGSHELL_SHSIPPREFERENCE)(HWND, SIPSTATE);

struct _AFX_AYGSHELL_STATE : public CNoTrackObject
{
public:
	// Handle initialization and cleanup of AYGSHELL
	_AFX_AYGSHELL_STATE();
	virtual ~_AFX_AYGSHELL_STATE();

	// the handle to the AYGSHELL DLL on the target device, if the DLL exists
	HINSTANCE m_hAygshellDLL;

	// the type of the target device 
	int m_nAygshellUIModel;

	// enable DRA or not
	BOOL m_bIsDRAEnabled;

	// addresses of the exported function of AYGSHELL DLL
	AYGSHELL_SHCREATEMENUBAR m_pfnSHCreateMenuBar;
	AYGSHELL_SHDONEBUTTON m_pfnSHDoneButton;
	AYGSHELL_SHFINDMENUBAR m_pfnSHFindMenuBar;
	AYGSHELL_SHHANDLEWMACTIVATE m_pfnSHHandleWMActivate;
	AYGSHELL_SHHANDLEWMSETTINGCHANGE m_pfnSHHandleWMSettingChange;
	AYGSHELL_SHINITDIALOG m_pfnSHInitDialog;
	AYGSHELL_SHRECOGNIZEGESTURE m_pfnSHRecognizeGesture;
	AYGSHELL_SHSIPINFO m_pfnSHSipInfo;
	AYGSHELL_SHSIPPREFERENCE m_pfnSHSipPreference;
};

const _AFX_AYGSHELL_STATE& AFX_CDECL _AfxGetAygshellState();
BOOL WINAPI AfxIsAygshellSupported();

enum AfxAygshellUIModel { NoAygshell = 0, WindowsCE = 1, PocketPC = 2, Smartphone = 3, UnsupportedWindowsVersion = -1 };
int WINAPI AfxGetAygshellUIModel();

BOOL WINAPI AfxIsDRAEnabled();
void WINAPI AfxEnableDRA(BOOL bEnable);

namespace AYGSHELL
{
	inline BOOL SHCreateMenuBar(SHMENUBARINFO* pmb)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHCreateMenuBar);
		
		return aygshellState.m_pfnSHCreateMenuBar(pmb);
	}
		
	inline BOOL SHDoneButton(HWND hWndRequester, DWORD dwState)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHDoneButton);

		return aygshellState.m_pfnSHDoneButton(hWndRequester, dwState);
	}
	
	inline HWND SHFindMenuBar(HWND hWnd)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHFindMenuBar);

		return aygshellState.m_pfnSHFindMenuBar(hWnd);
	}
	
	inline BOOL SHHandleWMActivate(HWND hWnd, WPARAM wParam, LPARAM lParam, SHACTIVATEINFO* pSHActivateInfo, DWORD dwFlags)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHHandleWMActivate);

		return aygshellState.m_pfnSHHandleWMActivate(hWnd, wParam, lParam, pSHActivateInfo, dwFlags);
	}
	
	inline BOOL SHHandleWMSettingChange(HWND hWnd, WPARAM wParam, LPARAM lParam, SHACTIVATEINFO* pSHActivateInfo)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHHandleWMSettingChange);

		return aygshellState.m_pfnSHHandleWMSettingChange(hWnd, wParam, lParam, pSHActivateInfo);
	}
	
	inline BOOL SHInitDialog(PSHINITDLGINFO pSHInitDlgInfo)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHInitDialog);

		return aygshellState.m_pfnSHInitDialog(pSHInitDlgInfo);
	}
	
	inline DWORD SHRecognizeGesture(SHRGINFO* pSHRgInfo)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHRecognizeGesture);
	
		return aygshellState.m_pfnSHRecognizeGesture(pSHRgInfo);
	}
	
	inline BOOL SHSipInfo(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHSipInfo);

		return aygshellState.m_pfnSHSipInfo(uiAction, uiParam, pvParam, fWinIni);
	}

	inline BOOL SHSipPreference(HWND hWnd, SIPSTATE st)
	{
		const _AFX_AYGSHELL_STATE& aygshellState = _AfxGetAygshellState();
		ASSERT(aygshellState.m_pfnSHSipInfo);

		return aygshellState.m_pfnSHSipPreference(hWnd, st);
	}

}
#endif // _WIN32_WCE

//////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#endif //__AFXSTATE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxrich.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRICH_H__
#define __AFXRICH_H__

#ifdef _AFX_NO_RICHEDIT_SUPPORT
	#error Windows RichEdit classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif
#ifndef _RICHEDIT_
	#include <richedit.h>
#endif
#ifndef _RICHOLE_
	#include <richole.h>
	#define _RICHOLE_
#endif
#ifndef __AFXCMN_H__
	#include <afxcmn.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - MFC RichEdit classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CRichEditView;// rich text editor view

		//CDocument
			//COleDocument
				class CRichEditDoc;
		//CDocItem
			//COleClientItem
				class CRichEditCntrItem;

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEditView

class _AFX_RICHEDIT_STATE;  // private to implementation

class CRichEditView : public CCtrlView
{
	DECLARE_DYNCREATE(CRichEditView)

// Construction
public:
	CRichEditView();

// Attributes
public:
	enum WordWrapType
	{
		WrapNone = 0,
		WrapToWindow = 1,
		WrapToTargetDevice = 2
	};
	int m_nWordWrap;
	int m_nBulletIndent;

	void SetPaperSize(CSize sizePaper);
	CSize GetPaperSize() const;
	void SetMargins(const CRect& rectMargin);
	CRect GetMargins() const;
	int GetPrintWidth() const;
	CRect GetPrintRect() const;
	CRect GetPageRect() const;

	//formatting
	CHARFORMAT2& GetCharFormatSelection();
	PARAFORMAT2& GetParaFormatSelection();
	void SetCharFormat(CHARFORMAT2 cf);
	BOOL SetParaFormat(PARAFORMAT2& pf);
	CRichEditCntrItem* GetSelectedItem() const;
	CRichEditCntrItem* GetInPlaceActiveItem() const;

	// CEdit control access
	CRichEditCtrl& GetRichEditCtrl() const;
	CRichEditDoc* GetDocument() const;

	// other attributes
	long GetTextLength() const;
	long GetTextLengthEx(DWORD dwFlags, UINT uCodePage = -1) const;

	static BOOL AFX_CDECL IsRichEditFormat(CLIPFORMAT cf);
	BOOL CanPaste() const;

// Operations
public:
	void AdjustDialogPosition(CDialog* pDlg);
	HRESULT InsertItem(CRichEditCntrItem* pItem);
	void InsertFileAsObject(LPCTSTR lpszFileName);
	BOOL FindText(LPCTSTR lpszFind, BOOL bCase = TRUE, BOOL bWord = TRUE,
		BOOL bNext = TRUE);
	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bCase = TRUE,
		BOOL bWord = TRUE, BOOL bNext = TRUE);
	long PrintInsideRect(CDC* pDC, RECT& rectLayout, long nIndexStart,
		long nIndexStop, BOOL bOutput);
	long PrintPage(CDC* pDC, long nIndexStart, long nIndexStop);
	void DoPaste(COleDataObject& dataobj, CLIPFORMAT cf,
		HMETAFILEPICT hMetaPict);

// Helpers
	void OnCharEffect(DWORD dwMask, DWORD dwEffect);
	void OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect) ;
	void OnParaAlign(WORD wAlign);
	void OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign);

// Overrideables
protected:
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	virtual void OnInitialUpdate();
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		BOOL bWord, LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase, BOOL bWord);
	virtual void OnTextNotFound(LPCTSTR lpszFind);
	virtual void OnPrinterChanged(const CDC& dcPrinter);
	virtual void WrapChanged();
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

// Advanced
	virtual BOOL OnPasteNativeObject(LPSTORAGE lpStg);
	virtual HMENU GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* );
	virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD dwReco,
		LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
	virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
		BOOL, HGLOBAL);

// Implementation
public:
	LPRICHEDITOLE m_lpRichEditOle;
	CDC m_dcTarget;
	long m_lInitialSearchPos;
	UINT m_nPasteType;
	BOOL m_bFirstSearch;

	void TextNotFound(LPCTSTR lpszFind);
	BOOL FindText(_AFX_RICHEDIT_STATE* pEditState);
	BOOL FindTextSimple(_AFX_RICHEDIT_STATE* pEditState);
	long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft);
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	void Stream(CArchive& ar, BOOL bSelection);
#endif // _WIN32_WCE_NO_ARCHIVE_SUPPORT
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT ShowContainerUI(BOOL b);
	static DWORD CALLBACK EditStreamCallBack(DWORD_PTR dwCookie,
		LPBYTE pbBuff, LONG cb, LONG *pcb);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	virtual void Serialize(CArchive& ar);
#endif // _WIN32_WCE_NO_ARCHIVE_SUPPORT
	virtual void DeleteContents();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA ULONG lMaxSize; // maximum number of characters supported

protected:
	CRect m_rectMargin;
	CSize m_sizePaper;
	CDWordArray m_aPageStart;    // array of starting pages
	PARAFORMAT2 m_paraformat;
	CHARFORMAT2 m_charformat;
	BOOL m_bSyncCharFormat;
	BOOL m_bSyncParaFormat;

	// construction
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// printing support
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL bWord);

	// special overrides for implementation

	//{{AFX_MSG(CRichEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditRedo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg void OnDestroy();
	afx_msg void OnEditProperties();
	afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnCharBold();
	afx_msg void OnUpdateCharBold(CCmdUI* pCmdUI);
	afx_msg void OnCharItalic();
	afx_msg void OnUpdateCharItalic(CCmdUI* pCmdUI);
	afx_msg void OnCharUnderline();
	afx_msg void OnUpdateCharUnderline(CCmdUI* pCmdUI);
	afx_msg void OnParaCenter();
	afx_msg void OnUpdateParaCenter(CCmdUI* pCmdUI);
	afx_msg void OnParaLeft();
	afx_msg void OnUpdateParaLeft(CCmdUI* pCmdUI);
	afx_msg void OnParaRight();
	afx_msg void OnUpdateParaRight(CCmdUI* pCmdUI);
	afx_msg void OnBullet();
	afx_msg void OnUpdateBullet(CCmdUI* pCmdUI);
	afx_msg void OnFormatFont();
	afx_msg void OnColorPick(COLORREF cr);
	afx_msg void OnColorDefault();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnUpdateEditPasteSpecial(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnDevModeChange(__in_z LPTSTR lpDeviceName);
	//}}AFX_MSG
	afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

// Interface Map
public:
	BEGIN_INTERFACE_PART(RichEditOleCallback, IRichEditOleCallback)
		INIT_INTERFACE_PART(CRichEditView, RichEditOleCallback)
		STDMETHOD(GetNewStorage) (LPSTORAGE*);
		STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
									  LPOLEINPLACEUIWINDOW*,
									  LPOLEINPLACEFRAMEINFO);
		STDMETHOD(ShowContainerUI) (BOOL);
		STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
		STDMETHOD(DeleteObject) (LPOLEOBJECT);
		STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
		STDMETHOD(ContextSensitiveHelp) (BOOL);
		STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
		STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
		STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
	END_INTERFACE_PART(RichEditOleCallback)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc

class AFX_NOVTABLE CRichEditDoc : public COleServerDoc
{
protected: // create from serialization only
	CRichEditDoc();
	DECLARE_DYNAMIC(CRichEditDoc)

// Attributes
public:
	BOOL m_bRTF; // TRUE when formatted, FALSE when plain text

	virtual CRichEditCntrItem* CreateClientItem(REOBJECT* preo = NULL) const = 0;

	virtual CRichEditView* GetView() const;
	int GetStreamFormat() const;

// Implementation
protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	void MarkItemsClear() const;
	void DeleteUnmarkedItems() const;
	void UpdateObjectCache();
public:
	virtual ~CRichEditDoc() = 0 { }
	BOOL m_bUpdateObjectCache;
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
	virtual void SetTitle(LPCTSTR lpszTitle);
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
	virtual void DeleteContents();
	virtual POSITION GetStartPosition() const;
	virtual void PreCloseFrame(CFrameWnd* pFrameWnd);
	virtual void UpdateModifiedFlag();
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
	CRichEditCntrItem* LookupItem(LPOLEOBJECT lpobj) const;
	void InvalidateObjectCache();
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#endif // _WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CRichEditCntrItem

class CRichEditCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CRichEditCntrItem)

// Constructors
public:
	/* explicit */ CRichEditCntrItem(REOBJECT* preo = NULL, CRichEditDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIAL.
		//  IMPLEMENT_SERIAL requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Operations
	void SyncToRichEditObject(REOBJECT& reo);

// Implementation
public:
	~CRichEditCntrItem();
	LPOLECLIENTSITE m_lpClientSite;
	BOOL m_bMark;
	BOOL m_bLock;   // lock it during creation to avoid deletion
	void Mark(BOOL b);
	BOOL IsMarked();
	CRichEditDoc* GetDocument();
	CRichEditView* GetActiveView();
	HRESULT ShowContainerUI(BOOL b);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual LPOLECLIENTSITE GetClientSite();
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld,
		REFCLSID clsidNew);
	virtual void SetDrawAspect(DVASPECT nDrawAspect);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL CanActivate();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXRICH_INLINE AFX_INLINE
#include <afxrich.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXRICH_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
	#include <afxplex_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
#endif

#pragma warning( push )
#if _SECURE_ATL
#pragma warning( disable: 4505 4127 )
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

#pragma push_macro("new")

#ifndef _INC_NEW
	#include <new.h>
#endif

namespace ATL
{
	class CComBSTR;
}
using ATL::CComBSTR;

// the two functions below are deprecated.  Use a constructor/destructor instead.
#pragma deprecated( DestructElements )
#pragma deprecated( ConstructElements )

template<class TYPE>
AFX_INLINE void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pDest != 0 && pSrc != 0);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<class TYPE>
void AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE)));

	// default is bit-wise read/write
	if (ar.IsStoring())
   {
	  TYPE* pData;
	  UINT_PTR nElementsLeft;

	  nElementsLeft = nCount;
	  pData = pElements;
	  while( nElementsLeft > 0 )
	  {
		 UINT nElementsToWrite;

		 nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));
		 ar.Write(pData, nElementsToWrite*sizeof(TYPE));
		 nElementsLeft -= nElementsToWrite;
		 pData += nElementsToWrite;
	  }
   }
	else
   {
	  TYPE* pData;
	  UINT_PTR nElementsLeft;

	  nElementsLeft = nCount;
	  pData = pElements;
	  while( nElementsLeft > 0 )
	  {
		 UINT nElementsToRead;

		 nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));
		 ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));
		 nElementsLeft -= nElementsToRead;
		 pData += nElementsToRead;
	  }
   }
}

template<>
inline void AFXAPI SerializeElements<CObject*>(CArchive& ar, CObject** pElements, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(CObject*)));

	// default is bit-wise read/write
	if (ar.IsStoring())
	{
		CObject** pAfter = pElements + nCount;

		while( pElements < pAfter )
		{
			ar.WriteObject(*pElements);
			++pElements;
		}
	}
	else
	{
		CObject** pAfter = pElements + nCount;
		
		while( pElements < pAfter )
		{
			*pElements = ar.ReadObject(NULL);
			++pElements;
		}
	}
}

template<class TYPE>
void AFXAPI SerializeElementsInsertExtract(CArchive& ar, TYPE* pElements, 
	INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT((nCount == 0) || 
		(AfxIsValidAddress(pElements, nCount*sizeof(TYPE))));

	if (nCount == 0 || pElements == NULL)
	{
		return;
	}

	if (ar.IsStoring())
	{
		for (; nCount--; ++pElements)
			ar << *pElements;
	}
	else
	{
		for (; nCount--; ++pElements)
			ar >> *pElements;
	}
}
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

#ifdef _DEBUG
#ifndef _WIN32_WCE
template<class TYPE>
void AFXAPI DumpElements(CDumpContext& dc, const TYPE* pElements, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE), FALSE));
	&dc; // not used
	pElements;  // not used
	nCount; // not used

	// default does nothing
}
#endif // !_WIN32_WCE
#endif

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ENSURE(pElement1 != NULL && pElement2 != NULL);
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
AFX_INLINE UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return (DWORD)(((DWORD_PTR)key)>>4);
}

// special versions for CString
#if _MSC_VER >= 1100
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<> void AFXAPI SerializeElements<CStringA> (CArchive& ar, CStringA* pElements, INT_PTR nCount);
template<> void AFXAPI SerializeElements<CStringW> (CArchive& ar, CStringW* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);
#else // _MSC_VER >= 1100
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
void AFXAPI SerializeElements(CArchive& ar, CString* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
UINT AFXAPI HashKey(LPCWSTR key);
UINT AFXAPI HashKey(LPCSTR key);
#endif // _MSC_VER >= 1100

// special versions for CComBSTR
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<> void AFXAPI SerializeElements<CComBSTR> (CArchive& ar, CComBSTR* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
template<> UINT AFXAPI HashKey<CComBSTR> (CComBSTR key);

// forward declarations
class COleVariant;
struct tagVARIANT;

// special versions for COleVariant
#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<COleVariant> (COleVariant* pDest, const COleVariant* pSrc, INT_PTR nCount);
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<> void AFXAPI SerializeElements<COleVariant> (CArchive& ar, COleVariant* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
#ifndef _WIN32_WCE
template<> void AFXAPI DumpElements<COleVariant> (CDumpContext& dc, const COleVariant* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE
#endif
template<> UINT AFXAPI HashKey<const struct tagVARIANT&> (const struct tagVARIANT& var);
#else // _MSC_VER >= 1100
void AFXAPI CopyElements(COleVariant* pDest, const COleVariant* pSrc, INT_PTR nCount);
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
void AFXAPI SerializeElements(CArchive& ar, COleVariant* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
#ifndef _WIN32_WCE
void AFXAPI DumpElements(CDumpContext& dc, const COleVariant* pElements, INT_PTR nCount);
#endif // !_WIN32_WCE
#endif
UINT AFXAPI HashKey(const struct tagVARIANT& var);
#endif // _MSC_VER >= 1100

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE = const TYPE&>
class CArray : public CObject
{
public:
// Construction
	CArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	const TYPE& GetAt(INT_PTR nIndex) const;
	TYPE& GetAt(INT_PTR nIndex);
	void SetAt(INT_PTR nIndex, ARG_TYPE newElement);
	const TYPE& ElementAt(INT_PTR nIndex) const;
	TYPE& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement);
	INT_PTR Add(ARG_TYPE newElement);
	INT_PTR Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	const TYPE& operator[](INT_PTR nIndex) const;
	TYPE& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount = 1);
	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

public:
	~CArray();
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	void Serialize(CArchive&);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
#ifndef _WIN32_WCE
	void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE BOOL CArray<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nSize == 0; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
{
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		m_pData[nIndex] = newElement; 
	else
		AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		for( int i = 0; i < m_nSize; i++ )
			(m_pData + i)->~TYPE();
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			for( int i = 0; i < m_nSize; i++ )
				(m_pData + i)->~TYPE();
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create buffer big enough to hold number of requested elements or
		// m_nGrowBy elements, whichever is larger.
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
		for( int i = 0; i < nNewSize; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( m_pData + i ) ) TYPE;
#pragma pop_macro("new")
		m_nSize = nNewSize;
		m_nMaxSize = nAllocSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
			for( int i = 0; i < nNewSize-m_nSize; i++ )
#pragma push_macro("new")
#undef new
				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
#pragma pop_macro("new")
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			for( int i = 0; i < m_nSize-nNewSize; i++ )
				(m_pData + nNewSize + i)->~TYPE();
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

		// copy new data from old
		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
			m_pData, (size_t)m_nSize * sizeof(TYPE));
		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
		for( int i = 0; i < nNewSize-m_nSize; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
#pragma pop_macro("new")

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself
	
	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);
		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
				m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	
	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		for( int i = 0; i < nCount; i++ )
			(m_pData + nOldSize + i)->~TYPE();
		// shift old data up to fill gap
		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
		for( int i = 0; i < nCount; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
#pragma pop_macro("new")
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();

	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);
	for( int i = 0; i < nCount; i++ )
		(m_pData + nIndex + i)->~TYPE();
	if (nMoveCount)
	{
		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
	}
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);
	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize, -1);
	}
	SerializeElements<TYPE>(ar, m_pData, m_nSize);
}
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

#ifdef _DEBUG
#ifndef _WIN32_WCE
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		dc << "\n";
		DumpElements<TYPE>(dc, m_pData, m_nSize);
	}

	dc << "\n";
}
#endif // !_WIN32_WCE

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE = const TYPE&>
class CList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	/* explicit */ CList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	const TYPE& GetHead() const;
	TYPE& GetTail();
	const TYPE& GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	const TYPE& GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	void Serialize(CArchive&);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
#ifndef _WIN32_WCE
	void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		pNode->data.~TYPE();

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ENSURE(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

#pragma push_macro("new")
#undef new
	::new( (void*)( &pNode->data ) ) TYPE;
#pragma pop_macro("new")
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	pNode->data.~TYPE();
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ENSURE(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ENSURE(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		{
			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
			TYPE* pData;
			/* 
			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
			 * the address of a given object.  We then use the following trick to get the address
			 */
			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
			SerializeElements<TYPE>(ar, pData, 1);
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		while (nNewCount--)
		{
			TYPE newData[1];
			SerializeElements<TYPE>(ar, newData, 1);
			AddTail(newData[0]);
		}
	}
}
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

#ifdef _DEBUG
#ifndef _WIN32_WCE
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
		{
			TYPE temp[1];
			temp[0] = ((CList*)this)->GetNext(pos);
			dc << "\n";
			DumpElements<TYPE>(dc, temp, 1);
		}
	}

	dc << "\n";
}
#endif // !_WIN32_WCE

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
public:
	// CPair
	struct CPair
	{
		const KEY key;
		VALUE value;
	protected:
		CPair( ARG_KEY keyval ) : key( keyval )	{}
	};

protected:
	// Association
	class CAssoc : public CPair
	{
		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
	public:
		CAssoc( ARG_KEY key ) : CPair( key ) {}
	};

public:
// Construction
	/* explicit */ CMap(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
	const CPair *PLookup(ARG_KEY key) const;
	CPair *PLookup(ARG_KEY key);

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;

	const CPair *PGetFirstAssoc() const;
	CPair *PGetFirstAssoc();

	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
	CPair *PGetNextAssoc(const CPair *pAssocRet);

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

#ifdef _WIN32_WCE
	VALUE GetValueAt(ARG_KEY key) const;
#endif // _WIN32_WCE

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc(ARG_KEY key);
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;

public:
	~CMap();
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
	void Serialize(CArchive&);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT
#ifdef _DEBUG
#ifndef _WIN32_WCE
	void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	void AssertValid() const;
#endif

#ifdef _WIN32_WCE 
// For CE we use the template CMap to define CMapPtrToWord
protected:
	// local typedefs for CTypedPtrMap class template
	typedef KEY		BASE_KEY;
	typedef ARG_KEY	  	BASE_ARG_KEY;
	typedef VALUE     	BASE_VALUE;
	typedef ARG_VALUE 	BASE_ARG_VALUE;
#endif // _WIN32_WCE

};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
	{ return m_nCount; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
{ 
	ASSERT_VALID(this);
	if(m_nCount == 0) return NULL;

	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
{ 
	ASSERT_VALID(this);
	if(m_nCount == 0) return NULL;

	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		ENSURE(m_pHashTable != NULL);
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				pAssoc->CAssoc::~CAssoc();
				//DestructElements<VALUE>(&pAssoc->value, 1);
				//DestructElements<KEY>((KEY*)&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ENSURE(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;

	// zero the memory
	CMap::CAssoc* pTemp = pAssoc->pNext;
	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
	pAssoc->pNext = pTemp;

	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
#pragma push_macro("new")
#undef new
	::new(pAssoc) CMap::CAssoc(key);
#pragma pop_macro("new")
//	ConstructElements<KEY>(&pAssoc->key, 1);
//	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	pAssoc->CAssoc::~CAssoc();
//	DestructElements<VALUE>(&pAssoc->value, 1);
//	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey<ARG_KEY>(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PLookup(ARG_KEY key) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PLookup(ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		ENSURE(m_pHashTable);
		// it doesn't exist, add a new Association
		pAssoc = NewAssoc(key);
		pAssoc->nHashValue = nHashValue;
		//'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

#ifdef _WIN32_WCE
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetValueAt(ARG_KEY key) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return ((pAssoc != NULL) ? pAssoc->value : NULL);
}
#endif // _WIN32_WCE

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	UINT nHashValue;
	CAssoc** ppAssocPrev;
	nHashValue = HashKey<ARG_KEY>(key);
	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ENSURE(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ENSURE(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetNextAssoc(const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* pPairRet) const
{
	ASSERT_VALID(this);

	CAssoc* pAssocRet = (CAssoc*)pPairRet;

	ASSERT(m_pHashTable != NULL);  // never call on empty map
	ASSERT(pAssocRet != NULL);
	
	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
		
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION);

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetNextAssoc(const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* pPairRet)
{
	ASSERT_VALID(this);

	CAssoc* pAssocRet = (CAssoc*)pPairRet;

	ASSERT(m_pHashTable != NULL);  // never call on empty map
	ASSERT(pAssocRet != NULL);
	
	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
		
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION);

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				KEY* pKey;
				VALUE* pValue;
				/* 
				 * in some cases the & operator might be overloaded, and we cannot use it to 
				 * obtain the address of a given object.  We then use the following trick to 
				 * get the address
				 */
				pKey = reinterpret_cast< KEY* >( &reinterpret_cast< int& >( const_cast< KEY& > ( static_cast< const KEY& >( pAssoc->key ) ) ) );
				pValue = reinterpret_cast< VALUE* >( &reinterpret_cast< int& >( static_cast< VALUE& >( pAssoc->value ) ) );
				SerializeElements<KEY>(ar, pKey, 1);
				SerializeElements<VALUE>(ar, pValue, 1);
			}
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		while (nNewCount--)
		{
			KEY newKey[1];
			VALUE newValue[1];
			SerializeElements<KEY>(ar, newKey, 1);
			SerializeElements<VALUE>(ar, newValue, 1);
			SetAt(newKey[0], newValue[0]);
		}
	}
}
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

#ifdef _DEBUG
#ifndef _WIN32_WCE
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		KEY key[1];
		VALUE val[1];

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key[0], val[0]);
			dc << "\n\t[";
			DumpElements<KEY>(dc, key, 1);
			dc << "] = ";
			DumpElements<VALUE>(dc, val, 1);
		}
	}

	dc << "\n";
}
#endif // !_WIN32_WCE

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//
#ifdef _WIN32_WCE
	typedef CArray<BYTE, BYTE> CByteArray;
	typedef CArray<DWORD, DWORD> CDWordArray;
	typedef CArray<CObject*, CObject*> CObArray;
	typedef CArray<void*, void*> CPtrArray;
	typedef CArray<CString, CString> CStringArray;
	typedef CArray<UINT, UINT> CUIntArray;
	typedef CArray<WORD, WORD> CWordArray;

	typedef CList<void*, void*> CPtrList;
	typedef CList<CObject*, CObject*> CObList;
	typedef CList<CString, CString> CStringList;

	typedef CMap<WORD, WORD, void*, void*> CMapWordToPtr;
	typedef CMap<void*, void*, WORD, WORD> CMapPtrToWord;
	typedef CMap<void*, void*, void*, void*> CMapPtrToPtr;
	typedef CMap<WORD, WORD, CObject*, CObject*> CMapWordToObj;
	typedef CMap<CString, LPCTSTR, void*, void*> CMapStringToPtr;
	typedef CMap<CString, LPCTSTR, CObject*, CObject*> CMapStringToOb;
	typedef CMap<CString, LPCTSTR, CString, CString> CMapStringToString;
#endif // _WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(INT_PTR nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	INT_PTR Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	INT_PTR Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, TYPE newElement, INT_PTR nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(INT_PTR nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class _CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	_CTypedPtrList(INT_PTR nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, TYPE newElement)
		{ return BASE_CLASS::InsertBefore(position, newElement); }
	POSITION InsertAfter(POSITION position, TYPE newElement)
		{ return BASE_CLASS::InsertAfter(position, newElement); }

	// transfer before or after a given position
	// Transfer semantics ensure no leakage by deleting the element in the case of an exception
	POSITION TransferInsertBefore(POSITION position, TYPE newElement)
	{
		try
		{
			return BASE_CLASS::InsertBefore(position, newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}

	POSITION TransferInsertAfter(POSITION position, TYPE newElement)
	{
		try
		{
			return BASE_CLASS::InsertAfter(position, newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}
};

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public _CTypedPtrList<BASE_CLASS, TYPE>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<BASE_CLASS, TYPE>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// transfer add before head or tail
	POSITION TransferAddHead(TYPE newElement)
	{ 
		try
		{
			return BASE_CLASS::AddHead(newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}
	POSITION TransferAddTail(TYPE newElement)
	{ 
		try
		{
			return BASE_CLASS::AddTail(newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }
};

// need specialized version for CObList because of AddHead/Tail ambiguity
template<> class CTypedPtrList<CObList, CObList*>
	: public _CTypedPtrList<CObList, CObList*>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<CObList, CObList*>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(CObList* newElement)
		{ return _CTypedPtrList<CObList, CObList*>::AddHead((CObject*)newElement); }
	POSITION AddTail(CObList* newElement)
		{ return _CTypedPtrList<CObList, CObList*>::AddTail((CObject*)newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<CObList, CObList*>* pNewList)
		{ _CTypedPtrList<CObList, CObList*>::AddHead(pNewList); }
	void AddTail(CTypedPtrList<CObList, CObList*>* pNewList)
		{ _CTypedPtrList<CObList, CObList*>::AddTail(pNewList); }
};

// need specialized version for CPtrList because of AddHead/Tail ambiguity
template<> class CTypedPtrList<CPtrList, CPtrList*>
	: public _CTypedPtrList<CPtrList, CPtrList*>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<CPtrList, CPtrList*>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(CPtrList* newElement)
		{ return _CTypedPtrList<CPtrList, CPtrList*>::AddHead((void*)newElement); }
	POSITION AddTail(CPtrList* newElement)
		{ return _CTypedPtrList<CPtrList, CPtrList*>::AddTail((void*)newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<CPtrList, CPtrList*>* pNewList)
		{ _CTypedPtrList<CPtrList, CPtrList*>::AddHead(pNewList); }
	void AddTail(CTypedPtrList<CPtrList, CPtrList*>* pNewList)
		{ _CTypedPtrList<CPtrList, CPtrList*>::AddTail(pNewList); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(INT_PTR nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#pragma pop_macro("new")

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#pragma warning( pop )

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxver_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxver_.h - target version/configuration control

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _AFX     1      // Microsoft Application Framework Classes
#ifndef _MFC_VER
#define _MFC_VER 0x0800 // Microsoft Foundation Classes version 8.00
#endif

/////////////////////////////////////////////////////////////////////////////
// turn off reference tracking for certain often used symbols

#ifndef _AFX_PORTABLE
#pragma component(browser, off, references, "ASSERT")
#pragma component(browser, off, references, "AfxAssertFailedLine")
#pragma component(browser, off, references, "AfxDebugBreak")
#pragma component(browser, off, references, "BOOL")
#pragma component(browser, off, references, "BYTE")
#pragma component(browser, off, references, "DECLSPEC_IMPORT")
#pragma component(browser, off, references, "DWORD")
#pragma component(browser, off, references, "FALSE")
#pragma component(browser, off, references, "FAR")
#pragma component(browser, off, references, "LPSTR")
#pragma component(browser, off, references, "LPTSTR")
#pragma component(browser, off, references, "LPCSTR")
#pragma component(browser, off, references, "LPCTSTR")
#pragma component(browser, off, references, "NULL")
#pragma component(browser, off, references, "PASCAL")
#pragma component(browser, off, references, "THIS_FILE")
#pragma component(browser, off, references, "TRUE")
#pragma component(browser, off, references, "UINT")
#pragma component(browser, off, references, "WINAPI")
#pragma component(browser, off, references, "WORD")
#endif  //!_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
// For target version (one of)
//   _CUSTOM   : for custom configurations (causes afxv_cfg.h to be included)
//
// Additional build options:
//  _DEBUG              debug versions (full diagnostics)
//  _AFXDLL             use shared MFC DLL
//  _AFXEXT             extension DLL version, implies _AFXDLL
//  _USRDLL             create regular DLL (_AFXDLL is valid too)
//

#ifndef _DEBUG
#ifndef _AFX_DISABLE_INLINES
	#define _AFX_ENABLE_INLINES
#endif
#endif

#define _AFX_NO_NESTED_DERIVATION

/////////////////////////////////////////////////////////////////////////////
// Special configurations

// _AFXEXT implies _AFXDLL
#if defined(_AFXEXT) && !defined(_AFXDLL)
	#define _AFXDLL
#endif

#if defined(_AFXDLL) && !defined(_DLL)
	#error Please use the /MD switch for _AFXDLL builds
#endif

#if defined(_AFXDLL) && !defined(_MT)
	#error Please use the /MD switch (multithreaded DLL C-runtime)
#endif

/////////////////////////////////////////////////////////////////////////////
// special include files

#ifndef AFX_INLINE
	#define AFX_INLINE inline /*__forceinline*/
#endif

#include <afxv_w32.h>

// Include any non-Intel platform specific items
#ifndef _M_IX86
	#include <afxv_cpu.h>
#endif

#ifdef _M_IX86
	#define _AFX_MINREBUILD
#endif

#ifdef _CUSTOM
// Put any custom configuration items in afxv_cfg.h
	#include <afxv_cfg.h>
#endif

// setup default packing value
#ifndef _AFX_PACKING
	#define _AFX_PACKING    4   // default packs structs at 4 bytes
#endif

#ifdef _AFXDLL
	#include <afxv_dll.h>
#endif

// Define this virtual key for use by status bar
#ifndef VK_KANA
#define VK_KANA             0x15
#endif

/////////////////////////////////////////////////////////////////////////////
// Special AfxDebugBreak: used to break into debugger at critical times

#ifndef AfxDebugBreak
#ifdef _AFX_NO_DEBUG_CRT
// by default, debug break is asm int 3, or a call to DebugBreak, or nothing
#if defined(_M_IX86) && !defined(_AFX_PORTABLE)
#define AfxDebugBreak() _asm { int 3 }
#else
#define AfxDebugBreak() DebugBreak()
#endif
#else
#define AfxDebugBreak() _CrtDbgBreak()
#endif
#endif

#ifndef _DEBUG
#ifdef AfxDebugBreak
#undef AfxDebugBreak
#endif
#define AfxDebugBreak()
#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Standard preprocessor symbols if not already defined
/////////////////////////////////////////////////////////////////////////////

// SIZE_T_MAX is used by the collection classes
#ifndef SIZE_T_MAX
	#define SIZE_T_MAX  UINT_MAX
#endif

// PASCAL is used for static member functions
#ifndef PASCAL
	#define PASCAL  __stdcall
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall     
#endif

// CDECL and EXPORT are defined in case WINDOWS.H doesn't
#ifndef CDECL
	#define CDECL __cdecl
#endif

#ifndef EXPORT
	#define EXPORT
#endif

// UNALIGNED is used for unaligned data access (in CArchive mostly)
#if !defined(UNALIGNED)
#if defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

// AFX_DEPRECATED is used for functions that should no longer be used
#ifndef AFX_DEPRECATED
#ifdef _AFX_DISABLE_DEPRECATED
	#define AFX_DEPRECATED(_Message) 
#else
	#define AFX_DEPRECATED(_Message) __declspec(deprecated(_Message))
#endif
#endif

// _AFX_INSECURE_DEPRECATE is used for deprecated, insecure functions.
#ifndef _AFX_INSECURE_DEPRECATE
#ifdef _AFX_SECURE_NO_DEPRECATE
#define _AFX_INSECURE_DEPRECATE(_Message)
#else
#define _AFX_INSECURE_DEPRECATE(_Message) __declspec(deprecated(_Message))
#endif // _AFX_SECURE_NO_DEPRECATE
#endif // _AFX_INSECURE_DEPRECATE

// AFXAPI is used on global public functions
#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFXOLEAPI is used for some special OLE functions
#ifndef AFXOLEAPI
	#define AFXOLEAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// AFX_EXPORT is used for functions which need to be exported
#ifndef AFX_EXPORT
	#define AFX_EXPORT EXPORT
#endif

#ifndef AFX_STATIC
	#define AFX_STATIC extern
	#define AFX_STATIC_DATA extern __declspec(selectany)
#endif

// The following macros are used to enable export/import

// for data
#ifndef AFX_DATA_EXPORT
	#define AFX_DATA_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_DATA_IMPORT
	#define AFX_DATA_IMPORT __declspec(dllimport)
#endif

// for classes
#ifndef AFX_CLASS_EXPORT
	#define AFX_CLASS_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_CLASS_IMPORT
	#define AFX_CLASS_IMPORT __declspec(dllimport)
#endif

// for global APIs
#ifndef AFX_API_EXPORT
	#define AFX_API_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_API_IMPORT
	#define AFX_API_IMPORT __declspec(dllimport)
#endif

// This macro is used to reduce size requirements of some classes
#ifndef AFX_ALWAYS_VTABLE
#ifndef AFX_NOVTABLE
#if _MSC_VER >= 1100 && !defined(_DEBUG)
#define AFX_NOVTABLE __declspec(novtable)
#else
#define AFX_NOVTABLE
#endif
#endif
#endif

// for global data that should be in COMDATs (packaged data)
#ifndef AFX_COMDAT
#define AFX_COMDAT __declspec(selectany)
#endif

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF
#define AFX_API

// used when building the "core" MFC80.DLL
#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA
	#define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO80.DLL
#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA
	#define AFX_OLE_DATADEF
#endif

// used when building the MFC/DB support MFCD80.DLL
#ifndef AFX_DB_DATA
	#define AFX_DB_DATA
	#define AFX_DB_DATADEF
#endif

// used when building the MFC/NET support MFCN80.DLL
#ifndef AFX_NET_DATA
	#define AFX_NET_DATA
	#define AFX_NET_DATADEF
#endif

// used when building extension DLLs
#ifndef AFX_EXT_DATA
	#define AFX_EXT_DATA
	#define AFX_EXT_DATADEF
	#define AFX_EXT_CLASS
	#define AFX_EXT_API
#endif

// BASED_XXXX macros are provided for backward compatibility
#ifndef BASED_CODE
	#define BASED_CODE
#endif

#ifndef BASED_DEBUG
	#define BASED_DEBUG
#endif

#ifndef BASED_STACK
	#define BASED_STACK
#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxv_cpu.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxv_cpu.h - target version/configuration control for various CPUs

/////////////////////////////////////////////////////////////////////////////

#if defined (_M_ARM) || defined (_M_MRX000) || defined (_M_SH)
// specific overrides for ARM, MIPS, and SH...
#define _AFX_PACKING    8       // default ARM, MIPS, SH alignment (required)
#endif //_MIPS_

/////////////////////////////////////////////////////////////////////////////

#ifdef _ALPHA_
// specific overrides for ALPHA...
#define _AFX_PACKING    8       // default AXP alignment (required)
#ifdef _AFX_NO_DEBUG_CRT
extern "C" void _BPT();
#pragma intrinsic(_BPT)
#define AfxDebugBreak() _BPT()
#else
#define AfxDebugBreak() _CrtDbgBreak()
#endif
#endif  //_ALPHA_

/////////////////////////////////////////////////////////////////////////////

#ifdef _PPC_
// specific overrides for Power PC...
#define _AFX_PACKING    8       // default PPC alignment (required)
#endif //_PPC_

/////////////////////////////////////////////////////////////////////////////

#ifdef _IA64_
// specific overrides for IA64...
#define _AFX_PACKING    8
#define _SHADOW_DOUBLES 8
#endif //_IA64_

/////////////////////////////////////////////////////////////////////////////

#ifdef _AMD64_
// specific overrides for AMD64...
#define _AFX_PACKING    8
#endif //_AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwin1.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 1)

#pragma once

#ifdef _AFXWIN_INLINE

// Global helper functions
_AFXWIN_INLINE CWinApp* AFXAPI AfxGetApp()
	{ return afxCurrentWinApp; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetInstanceHandle()
	{ ASSERT(afxCurrentInstanceHandle != NULL);
		return afxCurrentInstanceHandle; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()
	{ ASSERT(afxCurrentResourceHandle != NULL);
		return afxCurrentResourceHandle; }
_AFXWIN_INLINE void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource)
	{ ASSERT(hInstResource != NULL); afxCurrentResourceHandle = hInstResource; }
_AFXWIN_INLINE LPCTSTR AFXAPI AfxGetAppName()
	{ ASSERT(afxCurrentAppName != NULL); return afxCurrentAppName; }
#ifndef _WIN32_WCE
_AFXWIN_INLINE COleMessageFilter* AFXAPI AfxOleGetMessageFilter()
	{ ASSERT_VALID(AfxGetThread()); return AfxGetThread()->m_pMessageFilter; }
#endif // !_WIN32_WCE
_AFXWIN_INLINE CWnd* AFXAPI AfxGetMainWnd()
	{ CWinThread* pThread = AfxGetThread();
		return pThread != NULL ? pThread->GetMainWnd() : NULL; }

#ifndef _WIN32_WCE
_AFXWIN_INLINE BOOL AFXAPI AfxGetAmbientActCtx()
	{ 	return afxAmbientActCtx; }
_AFXWIN_INLINE void AFXAPI AfxSetAmbientActCtx(BOOL bSet)
	{  afxAmbientActCtx = bSet; }
#endif // !_WIN32_WCE



#ifdef _AFXDLL
// AFX_MAINTAIN_STATE functions
_AFXWIN_INLINE AFX_MAINTAIN_STATE::AFX_MAINTAIN_STATE(AFX_MODULE_STATE* pNewState)
	{  m_pPrevModuleState = AfxSetModuleState(pNewState); }
#endif

// AFX_MAINTAIN_STATE2 functions
_AFXWIN_INLINE AFX_MAINTAIN_STATE2::~AFX_MAINTAIN_STATE2()
{
#ifdef _AFXDLL
	// Not a good place to report errors here, so just be safe
	if(m_pThreadState)
	{
		m_pThreadState->m_pModuleState = m_pPrevModuleState;
	}
#endif

#ifndef _WIN32_WCE
	if (m_bValidActCtxCookie)
	{
		BOOL bRet;
		bRet = AfxDeactivateActCtx(0, m_ulActCtxCookie);
		ASSERT(bRet == TRUE);
	}
#endif // !_WIN32_WCE
}

#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
// CArchive output helpers
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, SIZE size)
	{ ar.Write(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, POINT point)
	{ ar.Write(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect)
	{ ar.Write(&rect, sizeof(RECT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size)
	{ ar.EnsureRead(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, POINT& point)
	{ ar.EnsureRead(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect)
	{ ar.EnsureRead(&rect, sizeof(RECT)); return ar; }
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

// exception support
_AFXWIN_INLINE CResourceException::CResourceException()
	: CSimpleException() { }
_AFXWIN_INLINE CResourceException::CResourceException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CResourceException::~CResourceException()
	{ }
_AFXWIN_INLINE CUserException::CUserException()
	: CSimpleException() { }
_AFXWIN_INLINE CUserException::CUserException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CUserException::~CUserException()
	{ }

// CGdiObject
_AFXWIN_INLINE CGdiObject::operator HGDIOBJ() const
	{ return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE HGDIOBJ CGdiObject::GetSafeHandle() const
	{ return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE CGdiObject::CGdiObject()
	{ m_hObject = NULL; }
_AFXWIN_INLINE CGdiObject::~CGdiObject()
	{ DeleteObject(); }
_AFXWIN_INLINE int CGdiObject::_AFX_FUNCNAME(GetObject)(int nCount, LPVOID lpObject) const
	{ ASSERT(m_hObject != NULL); return ::GetObject(m_hObject, nCount, lpObject); }
#pragma push_macro("GetObject")
#undef GetObject
_AFXWIN_INLINE int CGdiObject::GetObject(int nCount, LPVOID lpObject) const
	{ return _AFX_FUNCNAME(GetObject)(nCount, lpObject); }
#pragma pop_macro("GetObject")
_AFXWIN_INLINE BOOL CGdiObject::CreateStockObject(int nIndex)
	{ return (m_hObject = ::GetStockObject(nIndex)) != NULL; }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CGdiObject::UnrealizeObject()
	{ ASSERT(m_hObject != NULL); return ::UnrealizeObject(m_hObject); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT CGdiObject::GetObjectType() const
	{ return (UINT)::GetObjectType(m_hObject); }
_AFXWIN_INLINE BOOL CGdiObject::operator==(const CGdiObject& obj) const
	{ return ((HGDIOBJ) obj) == m_hObject; }
_AFXWIN_INLINE BOOL CGdiObject::operator!=(const CGdiObject& obj) const
	{ return ((HGDIOBJ) obj) != m_hObject; }

// CPen
_AFXWIN_INLINE CPen::operator HPEN() const
	{ return (HPEN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPen* PASCAL CPen::FromHandle(HPEN hPen)
	{ return (CPen*) CGdiObject::FromHandle(hPen); }
_AFXWIN_INLINE CPen::CPen()
	{ }
_AFXWIN_INLINE CPen::~CPen()
	{ }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{ return Attach(::CreatePen(nPenStyle, nWidth, crColor)); }
_AFXWIN_INLINE BOOL CPen::CreatePenIndirect(LPLOGPEN lpLogPen)
	{ return Attach(::CreatePenIndirect(lpLogPen)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount, const DWORD* lpStyle)
	{ return Attach(::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount,
		lpStyle)); }
_AFXWIN_INLINE int CPen::GetExtLogPen(EXTLOGPEN* pLogPen)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(EXTLOGPEN), pLogPen); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CPen::GetLogPen(LOGPEN* pLogPen)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGPEN), pLogPen); }

// CBrush
_AFXWIN_INLINE CBrush::operator HBRUSH() const
	{ return (HBRUSH)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBrush* PASCAL CBrush::FromHandle(HBRUSH hBrush)
	{ return (CBrush*) CGdiObject::FromHandle(hBrush); }
_AFXWIN_INLINE CBrush::CBrush()
	{ }
_AFXWIN_INLINE CBrush::~CBrush()
	{ }
_AFXWIN_INLINE BOOL CBrush::CreateSolidBrush(COLORREF crColor)
	{ return Attach(::CreateSolidBrush(crColor)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CBrush::CreateHatchBrush(int nIndex, COLORREF crColor)
	{ return Attach(::CreateHatchBrush(nIndex, crColor)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CBrush::CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{ return Attach(ATL::CreateBrushIndirect(lpLogBrush)); }
_AFXWIN_INLINE BOOL CBrush::CreatePatternBrush(CBitmap* pBitmap)
	{ return Attach(::CreatePatternBrush((HBITMAP)pBitmap->GetSafeHandle())); }
_AFXWIN_INLINE BOOL CBrush::CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{ return Attach(::CreateDIBPatternBrushPt(lpPackedDIB, nUsage)); }
_AFXWIN_INLINE BOOL CBrush::CreateSysColorBrush(int nIndex)
	{ return Attach(::GetSysColorBrush(nIndex)); }
_AFXWIN_INLINE int CBrush::GetLogBrush(LOGBRUSH* pLogBrush)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGBRUSH), pLogBrush); }

// CFont
_AFXWIN_INLINE CFont::operator HFONT() const
	{ return (HFONT)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CFont* PASCAL CFont::FromHandle(HFONT hFont)
	{ return (CFont*) CGdiObject::FromHandle(hFont); }
_AFXWIN_INLINE CFont::CFont()
	{ }
_AFXWIN_INLINE CFont::~CFont()
	{ }
_AFXWIN_INLINE BOOL CFont::CreateFontIndirect(const LOGFONT* lpLogFont)
	{ return Attach(::CreateFontIndirect(lpLogFont)); }
_AFXWIN_INLINE BOOL CFont::CreateFont(int nHeight, int nWidth, int nEscapement,
		int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
		BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
		BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
		LPCTSTR lpszFacename)
	{ return Attach(ATL::CreateFont(nHeight, nWidth, nEscapement,
		nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
		nCharSet, nOutPrecision, nClipPrecision, nQuality,
		nPitchAndFamily, lpszFacename)); }
_AFXWIN_INLINE int CFont::GetLogFont(LOGFONT* pLogFont)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGFONT), pLogFont); }

// CBitmap
_AFXWIN_INLINE CBitmap::operator HBITMAP() const
	{ return (HBITMAP)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBitmap* PASCAL CBitmap::FromHandle(HBITMAP hBitmap)
	{ return (CBitmap*) CGdiObject::FromHandle(hBitmap); }
_AFXWIN_INLINE CBitmap::CBitmap() 
#ifdef _WIN32_WCE
	: m_sizeDimension(0, 0)
#endif // _WIN32_WCE
	{ }
_AFXWIN_INLINE CBitmap::~CBitmap()
	{ }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmap(int nWidth, int nHeight, UINT nPlanes,
	 UINT nBitcount, const void* lpBits)
	{ return Attach(::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CBitmap::CreateBitmapIndirect(LPBITMAP lpBitmap)
	{ return Attach(::CreateBitmapIndirect(lpBitmap)); }

_AFXWIN_INLINE DWORD CBitmap::SetBitmapBits(DWORD dwCount, const void* lpBits)
	{ return ::SetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE DWORD CBitmap::GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{ return ::GetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(LPCTSTR lpszResourceName)
	{ return Attach(::LoadBitmap(AfxFindResourceHandle(
		lpszResourceName, RT_BITMAP), lpszResourceName));}
#ifndef _WIN32_WCE // Unsupported Win32 API call
#ifndef _AFX_NO_AFXCMN_SUPPORT
_AFXWIN_INLINE BOOL CBitmap::LoadMappedBitmap(UINT nIDBitmap, UINT nFlags,
	LPCOLORMAP lpColorMap, int nMapSize)
	{ return Attach(::AfxCreateMappedBitmap(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDBitmap), RT_BITMAP), nIDBitmap, (WORD)nFlags,
		lpColorMap, nMapSize)); }
#endif
#endif // !_WIN32_WCE
_AFXWIN_INLINE CSize CBitmap::SetBitmapDimension(int nWidth, int nHeight)
	{
#ifndef _WIN32_WCE // Unsupported Win32 API call SetBitmapDimensionEx
		SIZE size;
		VERIFY(::SetBitmapDimensionEx((HBITMAP)m_hObject, nWidth, nHeight, &size));
#else
		SIZE size(m_sizeDimension);

		m_sizeDimension.cx = nWidth;
		m_sizeDimension.cy = nHeight;
#endif // !_WIN32_WCE
		return size;
	}
_AFXWIN_INLINE CSize CBitmap::GetBitmapDimension() const
	{
#ifndef _WIN32_WCE // Unsupported Win32 API call GetBitmapDimensionEx
		SIZE size;
		VERIFY(::GetBitmapDimensionEx((HBITMAP)m_hObject, &size));
		return size;
#else
		return m_sizeDimension;
#endif // !_WIN32_WCE
	}
_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(UINT nIDResource)
	{ return Attach(::LoadBitmap(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDResource), RT_BITMAP), MAKEINTRESOURCE(nIDResource))); }
_AFXWIN_INLINE BOOL CBitmap::LoadOEMBitmap(UINT nIDBitmap)
	{ return Attach(::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap))); }
_AFXWIN_INLINE BOOL CBitmap::CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateCompatibleBitmap(pDC->m_hDC, nWidth, nHeight)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CBitmap::CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateDiscardableBitmap(pDC->m_hDC, nWidth, nHeight)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CBitmap::GetBitmap(BITMAP* pBitMap)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(BITMAP), pBitMap); }

// CPalette
_AFXWIN_INLINE CPalette::operator HPALETTE() const
	{ return (HPALETTE)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPalette* PASCAL CPalette::FromHandle(HPALETTE hPalette)
	{ return (CPalette*) CGdiObject::FromHandle(hPalette); }
_AFXWIN_INLINE CPalette::CPalette()
	{ }
_AFXWIN_INLINE CPalette::~CPalette()
	{ }
_AFXWIN_INLINE BOOL CPalette::CreatePalette(LPLOGPALETTE lpLogPalette)
	{ return Attach(::CreatePalette(lpLogPalette)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CPalette::CreateHalftonePalette(CDC* pDC)
	{ ASSERT(pDC != NULL && pDC->m_hDC != NULL); return Attach(
		::CreateHalftonePalette(pDC->m_hDC)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT CPalette::GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors) const
	{ ASSERT(m_hObject != NULL); return ::GetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ ASSERT(m_hObject != NULL); return ::SetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE void CPalette::AnimatePalette(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ ASSERT(m_hObject != NULL); ::AnimatePalette((HPALETTE)m_hObject, nStartIndex, nNumEntries,
			lpPaletteColors); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT CPalette::GetNearestPaletteIndex(COLORREF crColor) const
	{ ASSERT(m_hObject != NULL); return ::GetNearestPaletteIndex((HPALETTE)m_hObject, crColor); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CPalette::ResizePalette(UINT nNumEntries)
	{ ASSERT(m_hObject != NULL); return ::ResizePalette((HPALETTE)m_hObject, nNumEntries); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CPalette::GetEntryCount()
	{ ASSERT(m_hObject != NULL); WORD nEntries;
		 ::GetObject(m_hObject, sizeof(WORD), &nEntries); return (int)nEntries; }

// CRgn
_AFXWIN_INLINE CRgn::operator HRGN() const
	{ return (HRGN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CRgn* PASCAL CRgn::FromHandle(HRGN hRgn)
	{ return (CRgn*) CGdiObject::FromHandle(hRgn); }
_AFXWIN_INLINE CRgn::CRgn()
	{ }
_AFXWIN_INLINE CRgn::~CRgn()
	{ }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateRectRgnIndirect(lpRect)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateEllipticRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateEllipticRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{ return Attach(::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode)); }
_AFXWIN_INLINE BOOL CRgn::CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{ return Attach(::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3)); }
_AFXWIN_INLINE BOOL CRgn::CreateFromPath(CDC* pDC)
	{ ASSERT(pDC != NULL); return Attach(::PathToRegion(pDC->m_hDC)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CRgn::CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{ return Attach(::ExtCreateRegion(lpXForm, nCount, pRgnData)); }
_AFXWIN_INLINE int CRgn::GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{ ASSERT(m_hObject != NULL); return (int)::GetRegionData((HRGN)m_hObject, nDataSize, lpRgnData); }
_AFXWIN_INLINE void CRgn::SetRectRgn(int x1, int y1, int x2, int y2)
	{ ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRgn::SetRectRgn(LPCRECT lpRect)
	{ ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE int CRgn::CombineRgn(const CRgn* pRgn1, const CRgn* pRgn2, int nCombineMode)
	{ ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgn1->GetSafeHandle(),
		(HRGN)pRgn2->GetSafeHandle(), nCombineMode); }
_AFXWIN_INLINE int CRgn::CopyRgn(const CRgn* pRgnSrc)
	{ ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgnSrc->GetSafeHandle(), NULL, RGN_COPY); }
_AFXWIN_INLINE BOOL CRgn::EqualRgn(const CRgn* pRgn) const
	{ ASSERT(m_hObject != NULL); return ::EqualRgn((HRGN)m_hObject, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE int CRgn::OffsetRgn(int x, int y)
	{ ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE int CRgn::OffsetRgn(POINT point)
	{ ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE int CRgn::GetRgnBox(LPRECT lpRect) const
	{ ASSERT(m_hObject != NULL); return ::GetRgnBox((HRGN)m_hObject, lpRect); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(int x, int y) const
	{ ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(POINT point) const
	{ ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE BOOL CRgn::RectInRegion(LPCRECT lpRect) const
	{ ASSERT(m_hObject != NULL); return ::RectInRegion((HRGN)m_hObject, lpRect); }

// CDC
_AFXWIN_INLINE CDC::operator HDC() const
	{ return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE HDC CDC::GetSafeHdc() const
	{ return this == NULL ? NULL : m_hDC; }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE CWnd* CDC::GetWindow() const
	{ ASSERT(m_hDC != NULL); return CWnd::FromHandle(::WindowFromDC(m_hDC)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::IsPrinting() const
	{ return m_bPrinting; }
_AFXWIN_INLINE BOOL CDC::CreateDC(LPCTSTR lpszDriverName,
	LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
	{ return Attach(::CreateDC(lpszDriverName,
		lpszDeviceName, lpszOutput, (const DEVMODE*)lpInitData)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::CreateIC(LPCTSTR lpszDriverName,
	LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
	{ return Attach(::CreateIC(lpszDriverName,
		lpszDeviceName, lpszOutput, (const DEVMODE*) lpInitData)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::CreateCompatibleDC(CDC* pDC)
	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE int CDC::ExcludeUpdateRgn(CWnd* pWnd)
	{ ASSERT(m_hDC != NULL); return ::ExcludeUpdateRgn(m_hDC, pWnd->m_hWnd); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CDC::GetDeviceCaps(int nIndex) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetDeviceCaps(m_hAttribDC, nIndex); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE CPoint CDC::GetBrushOrg() const
	{
		ASSERT(m_hDC != NULL);
		POINT point;
		VERIFY(::GetBrushOrgEx(m_hDC, &point));
		return point;
	}
#endif // !_WIN32_WCE
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(int x, int y)
	{
		ASSERT(m_hDC != NULL);
		POINT point;
		VERIFY(::SetBrushOrgEx(m_hDC, x, y, &point));
		return point;
	}
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(POINT point)
	{
		ASSERT(m_hDC != NULL);
		VERIFY(::SetBrushOrgEx(m_hDC, point.x, point.y, &point));
		return point;
	}
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE int CDC::EnumObjects(int nObjectType,
		int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{ ASSERT(m_hAttribDC != NULL); return ::EnumObjects(m_hAttribDC, nObjectType, (GOBJENUMPROC)lpfn, lpData); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE CBitmap* CDC::SelectObject(CBitmap* pBitmap)
	{ ASSERT(m_hDC != NULL); return (CBitmap*) SelectGdiObject(m_hDC, pBitmap->GetSafeHandle()); }
_AFXWIN_INLINE CGdiObject* CDC::SelectObject(CGdiObject* pObject)
	{ ASSERT(m_hDC != NULL); return SelectGdiObject(m_hDC, pObject->GetSafeHandle()); }
_AFXWIN_INLINE HGDIOBJ CDC::SelectObject(HGDIOBJ hObject) // Safe for NULL handles
	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object
		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }
_AFXWIN_INLINE COLORREF CDC::GetNearestColor(COLORREF crColor) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetNearestColor(m_hAttribDC, crColor); }
_AFXWIN_INLINE UINT CDC::RealizePalette()
	{ ASSERT(m_hDC != NULL); return ::RealizePalette(m_hDC); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE void CDC::UpdateColors()
	{ ASSERT(m_hDC != NULL); ::UpdateColors(m_hDC); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE COLORREF CDC::GetBkColor() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetBkColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetBkMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetBkMode(m_hAttribDC); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE int CDC::GetPolyFillMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetPolyFillMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetROP2() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetROP2(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetStretchBltMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetStretchBltMode(m_hAttribDC); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE COLORREF CDC::GetTextColor() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetMapMode() const
#ifndef _WIN32_WCE
	{ ASSERT(m_hAttribDC != NULL); return ::GetMapMode(m_hAttribDC); }
#else
	{ ASSERT(m_hAttribDC != NULL); return MM_TEXT; }
#endif // !_WIN32_WCE
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
_AFXWIN_INLINE int CDC::GetGraphicsMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetGraphicsMode(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetWorldTransform(XFORM* pXform) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetWorldTransform(m_hAttribDC,pXform); }
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

_AFXWIN_INLINE CPoint CDC::GetViewportOrg() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(ATL::GetViewportOrgEx(m_hAttribDC, &point));
		return point;
	}
_AFXWIN_INLINE CSize CDC::GetViewportExt() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(ATL::GetViewportExtEx(m_hAttribDC, &size));
		return size;
	}
_AFXWIN_INLINE CPoint CDC::GetWindowOrg() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(ATL::GetWindowOrgEx(m_hAttribDC, &point));
		return point;
	}
_AFXWIN_INLINE CSize CDC::GetWindowExt() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(ATL::GetWindowExtEx(m_hAttribDC, &size));
		return size;
	}

// non-virtual helpers calling virtual mapping functions
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
_AFXWIN_INLINE CPoint CDC::SetViewportOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetViewportOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetViewportExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetViewportExt(size.cx, size.cy); }
_AFXWIN_INLINE CPoint CDC::SetWindowOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetWindowOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetWindowExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetWindowExt(size.cx, size.cy); }
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

_AFXWIN_INLINE void CDC::DPtoLP(LPPOINT lpPoints, int nCount) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(ATL::DPtoLP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::DPtoLP(LPRECT lpRect) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(ATL::DPtoLP(m_hAttribDC, (LPPOINT)lpRect, 2)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPPOINT lpPoints, int nCount) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(ATL::LPtoDP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPRECT lpRect) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(ATL::LPtoDP(m_hAttribDC, (LPPOINT)lpRect, 2)); }

_AFXWIN_INLINE BOOL CDC::FillRgn(CRgn* pRgn, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::FillRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle()); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight)
	{ ASSERT(m_hDC != NULL); return ::FrameRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle(),
		nWidth, nHeight); }
_AFXWIN_INLINE BOOL CDC::InvertRgn(CRgn* pRgn)
	{ ASSERT(m_hDC != NULL); return ::InvertRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PaintRgn(CRgn* pRgn)
	{ ASSERT(m_hDC != NULL); return ::PaintRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PtVisible(int x, int y) const
	{ ASSERT(m_hDC != NULL); return ::PtVisible(m_hDC, x, y); }
_AFXWIN_INLINE BOOL CDC::PtVisible(POINT point) const
	{ ASSERT(m_hDC != NULL); return PtVisible(point.x, point.y); } // call virtual
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::RectVisible(LPCRECT lpRect) const
	{ ASSERT(m_hDC != NULL); return ::RectVisible(m_hDC, lpRect); }
_AFXWIN_INLINE CPoint CDC::GetCurrentPosition() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(::GetCurrentPositionEx(m_hAttribDC, &point));
		return point;
	}

_AFXWIN_INLINE CPoint CDC::MoveTo(POINT point)
	{ ASSERT(m_hDC != NULL); return MoveTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::LineTo(POINT point)
	{ ASSERT(m_hDC != NULL); return LineTo(point.x, point.y); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Arc(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::Polyline(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::Polyline(m_hDC, lpPoints, nCount); }
#ifdef _DEVICE_RESOLUTION_AWARE
_AFXWIN_INLINE BOOL CDC::Polyline(const POINT* lpPoints, int nCount, int nStyle)
	{ ASSERT(m_hDC != NULL); return DRA::Polyline(m_hDC, lpPoints, nCount, nStyle); }
#endif // _DEVICE_RESOLUTION_AWARE
_AFXWIN_INLINE void CDC::FillRect(LPCRECT lpRect, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); ::FillRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::FrameRect(LPCRECT lpRect, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); ATL::FrameRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::InvertRect(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); ::InvertRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(int x, int y, HICON hIcon)
	{ ASSERT(m_hDC != NULL); return ATL::DrawIcon(m_hDC, x, y, hIcon); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(POINT point, HICON hIcon)
	{ ASSERT(m_hDC != NULL); return ATL::DrawIcon(m_hDC, point.x, point.y, hIcon); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		NULL, (LPARAM)pBitmap->GetSafeHandle(), 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush, NULL,
		(LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(), NULL,
		(LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{ ASSERT(m_hDC != NULL); return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags); }
_AFXWIN_INLINE BOOL CDC::DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{ ASSERT(m_hDC != NULL); return ::DrawFrameControl(m_hDC, lpRect, nType, nState); }

#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::Chord(int x1, int y1, int x2, int y2, int x3, int y3,
	int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Chord(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CDC::DrawFocusRect(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); ::DrawFocusRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::Ellipse(int x1, int y1, int x2, int y2)
	{ ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Ellipse(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Pie(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::Polygon(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::Polygon(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::PolyPolygon(const POINT* lpPoints, const INT* lpPolyCounts, int nCount)
	{ ASSERT(m_hDC != NULL); return ATL::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount); }
_AFXWIN_INLINE BOOL CDC::Rectangle(int x1, int y1, int x2, int y2)
#ifndef _DEVICE_RESOLUTION_AWARE
	{ ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, x1, y1, x2, y2); }
#else
	{ ASSERT(m_hDC != NULL); return AfxIsDRAEnabled() ? DRA::Rectangle(m_hDC, x1, y1, x2, y2) : ::Rectangle(m_hDC, x1, y1, x2, y2); }
#endif // !_DEVICE_RESOLUTION_AWARE
_AFXWIN_INLINE BOOL CDC::Rectangle(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{ ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3); }
_AFXWIN_INLINE BOOL CDC::RoundRect(LPCRECT lpRect, POINT point)
	{ ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop); }
_AFXWIN_INLINE BOOL CDC::BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::BitBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }
_AFXWIN_INLINE BOOL CDC::StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::StretchBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, nSrcHeight,
		dwRop); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(int x, int y) const
	{ ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, x, y); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(POINT point) const
	{ ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, point.x, point.y); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, x, y, crColor); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(POINT point, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, point.x, point.y, crColor); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::FloodFill(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::FloodFill(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{ ASSERT(m_hDC != NULL); return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, LPCTSTR lpszString, int nCount)
	{ ASSERT(m_hDC != NULL); return ::TextOut(m_hDC, x, y, lpszString, nCount); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, const CString& str)
	{ ASSERT(m_hDC != NULL); return TextOut(x, y, (LPCTSTR)str, (int)str.GetLength()); } // call virtual
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		lpszString, nCount, lpDxWidths); }
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	const CString& str, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		str, (UINT)str.GetLength(), lpDxWidths); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, lpszString, nCount,
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, const CString& str,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, str, (int)str.GetLength(),
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
		UINT nFormat)
	{ ASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat)
	{ ASSERT(m_hDC != NULL);
#ifndef _WIN32_WCE // Ellipsis unsupported on CE
		// these flags would modify the string
		ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
		ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
#endif
		return _AFX_FUNCNAME(DrawText)((LPCTSTR)str, (int)str.GetLength(), lpRect, nFormat); }

#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
		UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		return ::DrawTextEx(m_hDC, lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		// these flags would modify the string
		ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
		ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
		return _AFX_FUNCNAME(DrawTextEx)(const_cast<LPTSTR>((LPCTSTR)str), (int)str.GetLength(), lpRect, nFormat, lpDTParams); }
#endif // !_WIN32_WCE

#pragma push_macro("DrawText")
#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
#pragma push_macro("DrawTextEx")
#endif // !_WIN32_WCE
#undef DrawText
#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
#undef DrawTextEx
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::DrawText(const CString& str, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(str, lpRect, nFormat); }
#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
_AFXWIN_INLINE int CDC::DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXWIN_INLINE int CDC::DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(str, lpRect, nFormat, lpDTParams); }
#endif // !_WIN32_WCE
#pragma pop_macro("DrawText")
#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
#pragma pop_macro("DrawTextEx")
#endif // !_WIN32_WCE

_AFXWIN_INLINE CSize CDC::GetTextExtent(LPCTSTR lpszString, int nCount) const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hAttribDC, lpszString, nCount, &size));
		return size;
	}
_AFXWIN_INLINE CSize CDC::GetTextExtent(const CString& str) const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hAttribDC, str, (int)str.GetLength(), &size));
		return size;
	}

_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(LPCTSTR lpszString, int nCount) const
	{
		ASSERT(m_hDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hDC, lpszString, nCount, &size));
		return size;
	}
_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(const CString& str) const
	{
		ASSERT(m_hDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hDC, str, (int)str.GetLength(), &size));
		return size;
	}

#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE CSize CDC::GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC,
		str, (int)str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE CSize CDC::GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetOutputTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC,
		str, (int)str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE BOOL CDC::GrayString(CBrush* pBrush,
	BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int),
		LPARAM lpData, int nCount,
		int x, int y, int nWidth, int nHeight)
	{ ASSERT(m_hDC != NULL); return ::GrayString(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		(GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT CDC::GetTextAlign() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextAlign(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetTextFace(__in int nCount, __out_ecount_part_z(nCount, return + 1) LPTSTR lpszFacename) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextFace(m_hAttribDC, nCount, lpszFacename); }
_AFXWIN_INLINE  int CDC::GetTextFace(CString& rString) const
	{ ASSERT(m_hAttribDC != NULL); int nResult = ::GetTextFace(m_hAttribDC,
		256, rString.GetBuffer(256)); rString.ReleaseBuffer();
		return nResult; }
_AFXWIN_INLINE BOOL CDC::_AFX_FUNCNAME(GetTextMetrics)(LPTEXTMETRIC lpMetrics) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextMetrics(m_hAttribDC, lpMetrics); }
#pragma push_macro("GetTextMetrics")
#undef GetTextMetrics
_AFXWIN_INLINE BOOL CDC::GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ return _AFX_FUNCNAME(GetTextMetrics)(lpMetrics); }
#pragma pop_macro("GetTextMetrics")
_AFXWIN_INLINE BOOL CDC::GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ ASSERT(m_hDC != NULL); return ::GetTextMetrics(m_hDC, lpMetrics); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE int CDC::GetTextCharacterExtra() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextCharacterExtra(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharWidth(m_hAttribDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE BOOL CDC::GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ ASSERT(m_hDC != NULL); return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE DWORD CDC::GetFontLanguageInfo() const
	{ ASSERT(m_hDC != NULL); return ::GetFontLanguageInfo(m_hDC); }

_AFXWIN_INLINE DWORD CDC::GetCharacterPlacement(LPCTSTR lpString, int nCount, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const
	{ ASSERT(m_hDC != NULL); return ::GetCharacterPlacement(m_hDC, lpString, nCount, nMaxExtent, lpResults, dwFlags); }
_AFXWIN_INLINE DWORD CDC::GetCharacterPlacement(CString& str, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const
	{ ASSERT(m_hDC != NULL); return ::GetCharacterPlacement(m_hDC, (LPCTSTR)str, str.GetLength(), nMaxExtent, lpResults, dwFlags); }


_AFXWIN_INLINE CSize CDC::GetAspectRatioFilter() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetAspectRatioFilterEx(m_hAttribDC, &size));
		return size;
	}
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::ScrollDC(int dx, int dy,
		LPCRECT lpRectScroll, LPCRECT lpRectClip,
		CRgn* pRgnUpdate, LPRECT lpRectUpdate)
	{ ASSERT(m_hDC != NULL); return ::ScrollDC(m_hDC, dx, dy, lpRectScroll,
		lpRectClip, (HRGN)pRgnUpdate->GetSafeHandle(), lpRectUpdate); }

#ifndef _AFX_NO_PRINTING_SUPPORT
// Printer Escape Functions
_AFXWIN_INLINE int CDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{ ASSERT(m_hDC != NULL); return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);}
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE // Unsupported Win32 API call
// CDC 3.1 Specific functions
_AFXWIN_INLINE UINT CDC::SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{ ASSERT(m_hDC != NULL); return ::SetBoundsRect(m_hDC, lpRectBounds, flags); }
_AFXWIN_INLINE UINT CDC::GetBoundsRect(LPRECT lpRectBounds, UINT flags)
	{ ASSERT(m_hAttribDC != NULL); return ::GetBoundsRect(m_hAttribDC, lpRectBounds, flags); }
_AFXWIN_INLINE BOOL CDC::ResetDC(const DEVMODE* lpDevMode)
	{ ASSERT(m_hAttribDC != NULL); return ::ResetDC(m_hAttribDC, lpDevMode) != NULL; }
_AFXWIN_INLINE UINT CDC::GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetOutlineTextMetrics(m_hAttribDC, cbData, lpotm); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidths(m_hAttribDC, nFirstChar, nLastChar, lpabc); }


#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE DWORD CDC::GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData,
	DWORD cbData) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetFontData(m_hAttribDC, dwTable, dwOffset, lpData, cbData); }
_AFXWIN_INLINE int CDC::GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetKerningPairs(m_hAttribDC, nPairs, lpkrnpair); }
_AFXWIN_INLINE DWORD CDC::GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetGlyphOutline(m_hAttribDC, nChar, nFormat,
			lpgm, cbBuffer, lpBuffer, lpmat2); }
#endif // !_WIN32_WCE

// Document handling functions

#ifndef _AFX_NO_PRINTING_SUPPORT
_AFXWIN_INLINE int CDC::StartDoc(LPDOCINFO lpDocInfo)
	{ ASSERT(m_hDC != NULL); return ::StartDoc(m_hDC, lpDocInfo); }
_AFXWIN_INLINE int CDC::StartPage()
	{ ASSERT(m_hDC != NULL); return ::StartPage(m_hDC); }
_AFXWIN_INLINE int CDC::EndPage()
	{ ASSERT(m_hDC != NULL); return ::EndPage(m_hDC); }
_AFXWIN_INLINE int CDC::SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{ ASSERT(m_hDC != NULL); return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn); }
_AFXWIN_INLINE int CDC::AbortDoc()
	{ ASSERT(m_hDC != NULL); return ::AbortDoc(m_hDC); }
_AFXWIN_INLINE int CDC::EndDoc()
	{ ASSERT(m_hDC != NULL); return ::EndDoc(m_hDC); }
#endif // !_AFX_NO_PRINTING_SUPPORT

_AFXWIN_INLINE BOOL CDC::MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, pSrcDC->GetSafeHdc(),
		xSrc, ySrc,  (HBITMAP)maskBitmap.m_hObject, xMask, yMask, dwRop); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask)
	{ ASSERT(m_hDC != NULL); return ::PlgBlt(m_hDC, lpPoint, pSrcDC->GetSafeHdc(), xSrc, ySrc, nWidth,
		nHeight, (HBITMAP)maskBitmap.m_hObject, xMask, yMask); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(POINT point, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::AngleArc(int x, int y, int nRadius,
		float fStartAngle, float fSweepAngle)
	{ ASSERT(m_hDC != NULL); return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle); }
_AFXWIN_INLINE BOOL CDC::ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE int CDC::GetArcDirection() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetArcDirection(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::PolyPolyline(const POINT* lpPoints, const DWORD* lpPolyPoints,
		int nCount)
	{ ASSERT(m_hDC != NULL); return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetColorAdjustment(m_hAttribDC, lpColorAdjust); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE CPen* CDC::GetCurrentPen() const
	{ ASSERT(m_hAttribDC != NULL); return CPen::FromHandle((HPEN)::GetCurrentObject(m_hAttribDC, OBJ_PEN)); }
_AFXWIN_INLINE CBrush* CDC::GetCurrentBrush() const
	{ ASSERT(m_hAttribDC != NULL); return CBrush::FromHandle((HBRUSH)::GetCurrentObject(m_hAttribDC, OBJ_BRUSH)); }
_AFXWIN_INLINE CPalette* CDC::GetCurrentPalette() const
	{ ASSERT(m_hAttribDC != NULL); return CPalette::FromHandle((HPALETTE)::GetCurrentObject(m_hAttribDC, OBJ_PAL)); }
_AFXWIN_INLINE CFont* CDC::GetCurrentFont() const
	{ ASSERT(m_hAttribDC != NULL); return CFont::FromHandle((HFONT)::GetCurrentObject(m_hAttribDC, OBJ_FONT)); }
_AFXWIN_INLINE CBitmap* CDC::GetCurrentBitmap() const
	{ ASSERT(m_hAttribDC != NULL); return CBitmap::FromHandle((HBITMAP)::GetCurrentObject(m_hAttribDC, OBJ_BITMAP)); }
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::PolyBezier(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::PolyBezier(m_hDC, lpPoints, nCount); }

#endif // !_WIN32_WCE
#ifndef _AFX_NO_PRINTING_SUPPORT
_AFXWIN_INLINE int CDC::DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{ ASSERT(m_hDC != NULL); return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData); }
_AFXWIN_INLINE int CDC::Escape(__in int nEscape, __in int nInputSize, __in_bcount(nInputSize) LPCSTR lpszInputData,
		__in int nOutputSize, __out_bcount(nOutputSize) LPSTR lpszOutputData)
	{ ASSERT(m_hDC != NULL); return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData,
		nOutputSize, lpszOutputData); }
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidthsFloat(m_hAttribDC, nFirstChar, nLastChar, lpABCF); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharWidthFloat(m_hAttribDC, nFirstChar, nLastChar, lpFloatBuffer); }

_AFXWIN_INLINE BOOL CDC::AbortPath()
	{ ASSERT(m_hDC != NULL); return ::AbortPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::BeginPath()
	{ ASSERT(m_hDC != NULL); return ::BeginPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::CloseFigure()
	{ ASSERT(m_hDC != NULL); return ::CloseFigure(m_hDC); }
_AFXWIN_INLINE BOOL CDC::EndPath()
	{ ASSERT(m_hDC != NULL); return ::EndPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FillPath()
	{ ASSERT(m_hDC != NULL); return ::FillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FlattenPath()
	{ ASSERT(m_hDC != NULL); return ::FlattenPath(m_hDC); }
_AFXWIN_INLINE float CDC::GetMiterLimit() const
	{ ASSERT(m_hDC != NULL); float fMiterLimit;
		VERIFY(::GetMiterLimit(m_hDC, &fMiterLimit)); return fMiterLimit; }
_AFXWIN_INLINE int CDC::GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{ ASSERT(m_hDC != NULL); return ::GetPath(m_hDC, lpPoints, lpTypes, nCount); }
_AFXWIN_INLINE BOOL CDC::SetMiterLimit(float fMiterLimit)
	{ ASSERT(m_hDC != NULL); return ::SetMiterLimit(m_hDC, fMiterLimit, NULL); }
_AFXWIN_INLINE BOOL CDC::StrokeAndFillPath()
	{ ASSERT(m_hDC != NULL); return ::StrokeAndFillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::StrokePath()
	{ ASSERT(m_hDC != NULL); return ::StrokePath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::WidenPath()
	{ ASSERT(m_hDC != NULL); return ::WidenPath(m_hDC); }

_AFXWIN_INLINE BOOL CDC::AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData)
	{ ASSERT(m_hDC != NULL); return ::GdiComment(m_hDC, nDataSize, pCommentData); }

_AFXWIN_INLINE BOOL CDC::PlayMetaFile(HENHMETAFILE hEnhMF, LPCRECT lpBounds)
	{ ASSERT(m_hDC != NULL); return ::PlayEnhMetaFile(m_hDC, hEnhMF, lpBounds); }
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////	

// CMenu
_AFXWIN_INLINE CMenu::CMenu()
	{ m_hMenu = NULL; }
_AFXWIN_INLINE CMenu::~CMenu()
	{ DestroyMenu(); }
_AFXWIN_INLINE BOOL CMenu::CreateMenu()
	{ return Attach(::CreateMenu()); }
_AFXWIN_INLINE BOOL CMenu::CreatePopupMenu()
	{ return Attach(::CreatePopupMenu()); }
_AFXWIN_INLINE CMenu::operator HMENU() const
	{ ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
		return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::operator==(const CMenu& menu) const
	{ return ((HMENU) menu) == m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::operator!=(const CMenu& menu) const
	{ return ((HMENU) menu) != m_hMenu; }
_AFXWIN_INLINE HMENU CMenu::GetSafeHmenu() const
	{ ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
		return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::DeleteMenu(UINT nPosition, UINT nFlags)
	{ ASSERT(::IsMenu(m_hMenu)); return ::DeleteMenu(m_hMenu, nPosition, nFlags); }

_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE UINT CMenu::CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{ ASSERT(::IsMenu(m_hMenu)); return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck); }
_AFXWIN_INLINE UINT CMenu::EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{ ASSERT(::IsMenu(m_hMenu)); return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable); }
#ifndef _WIN32_WCE // unsupported Win32 API call to G(S)etMenuDefaultItem
_AFXWIN_INLINE BOOL CMenu::SetDefaultItem(UINT uItem, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuDefaultItem(m_hMenu, uItem, fByPos); }
_AFXWIN_INLINE UINT CMenu::GetDefaultItem(UINT gmdiFlags, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuDefaultItem(m_hMenu, fByPos, gmdiFlags); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT CMenu::GetMenuItemCount() const
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::GetMenuItemCount(m_hMenu); }
_AFXWIN_INLINE UINT CMenu::GetMenuItemID(int nPos) const
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::GetMenuItemID(m_hMenu, nPos); }
_AFXWIN_INLINE UINT CMenu::GetMenuState(UINT nID, UINT nFlags) const
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::GetMenuState(m_hMenu, nID, nFlags); }
_AFXWIN_INLINE int CMenu::GetMenuString(__in UINT nIDItem, __out_ecount_z(nMaxCount) LPTSTR lpString, __in int nMaxCount, __in UINT nFlags) const
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags); }
_AFXWIN_INLINE BOOL CMenu::GetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::GetMenuItemInfo(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
_AFXWIN_INLINE BOOL CMenu::SetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::SetMenuItemInfo(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
_AFXWIN_INLINE CMenu* CMenu::GetSubMenu(int nPos) const
	{ ASSERT(::IsMenu(m_hMenu)); return CMenu::FromHandle(::GetSubMenu(m_hMenu, nPos)); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
		LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
#ifndef _WIN32_WCE // unsupported win32 api call to InsertMenuItem
_AFXWIN_INLINE BOOL CMenu::InsertMenuItem(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::InsertMenuItem(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ATL::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::RemoveMenu(UINT nPosition, UINT nFlags)
	{ ASSERT(::IsMenu(m_hMenu)); return ::RemoveMenu(m_hMenu, nPosition, nFlags); }
#ifndef _WIN32_WCE // unsupported win32 api call to SetMenuItemBitmaps
_AFXWIN_INLINE BOOL CMenu::SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
		const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags,
		(HBITMAP)pBmpUnchecked->GetSafeHandle(),
		(HBITMAP)pBmpChecked->GetSafeHandle()); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CMenu::LoadMenu(LPCTSTR lpszResourceName)
	{ return Attach(::LoadMenu(AfxFindResourceHandle(lpszResourceName,
		RT_MENU), lpszResourceName)); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(UINT nIDResource)
	{ return Attach(::LoadMenu(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDResource), RT_MENU), MAKEINTRESOURCE(nIDResource))); }
#ifndef _WIN32_WCE // unsupported win32 api call to LoadMenuIndirect
_AFXWIN_INLINE BOOL CMenu::LoadMenuIndirect(const void* lpMenuTemplate)
	{ return Attach(::LoadMenuIndirect(lpMenuTemplate)); }
#endif // !_WIN32_WCE
// Win4
#ifndef _WIN32_WCE_NO_HELP_SUPPORT // unsupported win32 api call to G(S)etMenuContextHelpId
_AFXWIN_INLINE BOOL CMenu::SetMenuContextHelpId(DWORD dwContextHelpId)
	{ return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId); }
_AFXWIN_INLINE DWORD CMenu::GetMenuContextHelpId() const
	{ return ::GetMenuContextHelpId(m_hMenu); }
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
_AFXWIN_INLINE BOOL CMenu::CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{ return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags); }

// CCmdUI
_AFXWIN_INLINE void CCmdUI::ContinueRouting()
	{ m_bContinueRouting = TRUE; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwin3.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines that reference NT5/Win98-only DLLs 

#pragma once

#ifdef _AFXWIN_INLINE

#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CDC::AlphaBlend(int xDest, int yDest, int nDestWidth, int nDestHeight,
   CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, BLENDFUNCTION blend)
   { ASSERT(m_hDC != NULL); return ::AlphaBlend(m_hDC, xDest, yDest, 
	  nDestWidth, nDestHeight, pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, 
	  nSrcHeight, blend); }
_AFXWIN_INLINE BOOL CDC::TransparentBlt(int xDest, int yDest, int nDestWidth, 
   int nDestHeight, CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, 
   int nSrcHeight, UINT crTransparent)
   { ASSERT(m_hDC != NULL); return ::TransparentBlt(m_hDC, xDest, yDest, 
	  nDestWidth, nDestHeight, pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, 
	  nSrcHeight, crTransparent); }
_AFXWIN_INLINE BOOL CDC::GradientFill(TRIVERTEX* pVertices, ULONG nVertices,
   void* pMesh, ULONG nMeshElements, DWORD dwMode)
   { ASSERT(m_hDC != NULL); return ::GradientFill(m_hDC, pVertices, nVertices,
	  pMesh, nMeshElements, dwMode); }
#endif // !_WIN32_WCE

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxv_w32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxv_w32.h - target version/configuration control for Win32

#pragma once

#ifdef _WINDOWS_
	#error WINDOWS.H already included.  MFC apps must not #include <windows.h>
#endif

// STRICT is the only supported option (NOSTRICT is no longer supported)
#ifndef STRICT
#define STRICT 1
#endif

#ifndef WINVER
#ifdef _WIN32_WINNT
#define WINVER _WIN32_WINNT
#else
#ifndef _WIN32_WCE
#pragma message(" WINVER not defined. Defaulting to 0x0502 (Windows Server 2003)")
#define WINVER 0x0502
#else
#pragma message(" WINVER not defined. Defaulting to 0x0400, which is appropriate for all supported Windows CE versions")
#define WINVER 0x0400
#endif
#endif
#else
#if WINVER < 0x0400
#error MFC requires WINVER to be #defined to 0x0400 or greater
#endif
#endif

#ifndef _WIN32_IE
#ifndef _WIN32_WCE
#define _WIN32_IE 0x0560
#else
// Windows CE IE feature set closely maps to IE4.0
#define _WIN32_IE 0x0400
#endif // !_WIN32_WCE
#else
#if _WIN32_IE < 0x0400
#error MFC requires _WIN32_IE to be #defined to 0x0400 or greater
#endif
#endif

#ifndef _WIN32_WINDOWS
#ifndef _WIN32_WCE
#define _WIN32_WINDOWS 0x0410
#endif // !_WIN32_WCE
#else
#ifndef _WIN32_WCE
#if _WIN32_WINDOWS < 0x0400
#error MFC requires _WIN32_WINDOWS to be #defined to 0x0400 or greater
#endif
#else
#undef _WIN32_WINDOWS
#pragma message("_WIN32_WINDOWS was undefined as it is not supported for Windows CE")
#endif // !_WIN32_WCE
#endif

#ifndef _WIN32_WCE
#ifndef _WIN32_WINNT
#ifdef WINVER
#define _WIN32_WINNT WINVER
#else
#pragma message("_WIN32_WINNT not defined. Defaulting to 0x0502 (Windows Server 2003)")
#define _WIN32_WINNT 0x0502
#endif
#else
#if _WIN32_WINNT < 0x0400
#error MFC requires _WIN32_WINNT to be #defined to 0x0400 or greater
#endif
#endif
#endif

// certain parts of WINDOWS.H are necessary
#undef NOKERNEL
#undef NOGDI
#undef NOUSER
#undef NODRIVERS
#undef NOLOGERROR
#undef NOPROFILER
#undef NOMEMMGR
#undef NOLFILEIO
#undef NOOPENFILE
#undef NORESOURCE
#undef NOATOM
#undef NOLANGUAGE
#undef NOLSTRING
#undef NODBCS
#undef NOKEYBOARDINFO
#undef NOGDICAPMASKS
#undef NOCOLOR
#undef NOGDIOBJ
#undef NODRAWTEXT
#undef NOTEXTMETRIC
#undef NOSCALABLEFONT
#undef NOBITMAP
#undef NORASTEROPS
#undef NOMETAFILE
#undef NOSYSMETRICS
#undef NOSYSTEMPARAMSINFO
#undef NOMSG
#undef NOWINSTYLES
#undef NOWINOFFSETS
#undef NOSHOWWINDOW
#undef NODEFERWINDOWPOS
#undef NOVIRTUALKEYCODES
#undef NOKEYSTATES
#undef NOWH
#undef NOMENUS
#undef NOSCROLL
#undef NOCLIPBOARD
#undef NOICONS
#undef NOMB
#undef NOSYSCOMMANDS
#undef NOMDI
#undef NOCTLMGR
#undef NOWINMESSAGES

#ifndef WIN32
#define WIN32
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef VC_EXTRALEAN
#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NORPC

#ifndef NO_ANSIUNI_ONLY
#ifdef _UNICODE
#define UNICODE_ONLY
#else
#define ANSI_ONLY
#endif
#endif //!NO_ANSIUNI_ONLY

#endif //VC_EXTRALEAN

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#pragma warning(push)
#pragma warning(disable: 4311 4312)
#pragma warning(disable: 4201)  // winnt.h uses nameless structs

// Don't include winsock.h
#pragma push_macro("_WINSOCKAPI_")
#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_
#endif

#include <windows.h>

#pragma pop_macro("_WINSOCKAPI_")

#pragma warning(pop)

// Mouse message MFC is interested in
#ifndef AFX_WM_MOUSELAST
#define AFX_WM_MOUSELAST 0x0209
#endif

#ifndef _WIN32_WCE
#include <zmouse.h>
#endif // !_WIN32_WCE

struct HKEY__;
typedef struct HKEY__ *HKEY;

#ifndef _INC_COMMCTRL
	#include <commctrl.h>

	// Note: We must avoid using TB_ADDBUTTONW and TB_INSERTBUTTONW
	//       in the Unicode build or else MFC80U.DLL will not be
	//       compatible with pre-IE4 versions of COMCTL32.DLL.
	#ifdef TB_ADDBUTTONSA
		#undef TB_ADDBUTTONS
		#define TB_ADDBUTTONS TB_ADDBUTTONSA
	#endif

	#ifdef TB_INSERTBUTTONA
		#undef TB_INSERTBUTTON
		#define TB_INSERTBUTTON TB_INSERTBUTTONA
	#endif
#endif

#ifndef EXPORT
#define EXPORT
#endif

#ifndef _INC_TCHAR
	#include <tchar.h>      // used for ANSI v.s. UNICODE abstraction
#endif
#ifdef _MBCS
#ifndef _INC_MBCTYPE
	#include <mbctype.h>
#endif
#ifndef _INC_MBSTRING
	#include <mbstring.h>
#endif
#endif

#ifdef _WIN64
#define _AFX_NO_CTL3D_SUPPORT
#endif

/////////////////////////////////////////////////////////////////////////////
// Now for the Windows API specific parts

// WM_CTLCOLOR for 16 bit API compatability
#define WM_CTLCOLOR     0x0019

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetWindowTask
#undef GetWindowTask
#ifdef _WIN32
AFX_INLINE HTASK GetWindowTask(HWND hWnd)
	{ return (HTASK)(DWORD_PTR)::GetWindowThreadProcessId(hWnd, NULL); }
#endif
#endif

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetNextWindow
#undef GetNextWindow
AFX_INLINE HWND GetNextWindow(HWND hWnd, UINT nDirection)
	{ return ::GetWindow(hWnd, nDirection); }
#endif

// Avoid Win95 mapping CToolBar::DrawState to DrawState[A/W]
#ifdef DrawState
#undef DrawState
AFX_INLINE BOOL WINAPI DrawState(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc,
	LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags)
#ifdef UNICODE
	{ return ::DrawStateW(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#else
	{ return ::DrawStateA(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#endif
#endif

// Avoid Win95 mapping CStatusBar::DrawStatusText to DrawStatusText[A/W]
#ifdef DrawStatusText
#undef DrawStatusText
AFX_INLINE void WINAPI AfxDrawStatusTextA(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags);
AFX_INLINE void WINAPI AfxDrawStatusTextW(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags);
AFX_INLINE void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags) 
#ifdef UNICODE
	{ ::AfxDrawStatusTextW(hDC, lprc, szText, uFlags); }
#else
	{ ::AfxDrawStatusTextA(hDC, lprc, szText, uFlags); }
#endif
#endif

// FreeResource is not required on Win32 platforms
#undef FreeResource
AFX_INLINE BOOL WINAPI FreeResource(HGLOBAL) { return TRUE; }
// UnlockResource is not required on Win32 platforms
#undef UnlockResource
AFX_INLINE int WINAPI UnlockResource(HGLOBAL) { return 0; }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwinforms.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWINFORMS.H

#pragma warning(disable:4439)	// C4439: function with a managed parameter must have a __clrcall calling convention

extern "C" void MFCM80EnsureManagedInitialization();

namespace Microsoft {
	namespace VisualC {
		namespace MFC {

#ifndef AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD
#define AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD

//CWinFormsEventsHelper
inline CWinFormsEventsHelper::CWinFormsEventsHelper() 
    {	
		m_pSink = NULL;
	}	
inline void CWinFormsEventsHelper::Control::set(System::Windows::Forms::Control^ pControl)
	{
		ENSURE_ARG(pControl!=nullptr);
		ENSURE(m_pControl == nullptr);
		m_pControl=pControl;
		  m_pControl->HandleCreated += 
			  gcnew System::EventHandler(this, &CWinFormsEventsHelper::OnHandleCreated);
		  m_pControl->HandleDestroyed += 
			  gcnew System::EventHandler(this, &CWinFormsEventsHelper::OnHandleDestroyed);

	}
inline System::Windows::Forms::Control^ CWinFormsEventsHelper::Control::get()
	{
		return m_pControl;
	}
inline void CWinFormsEventsHelper::Advise(IHandleEvents* pSink)
	{	
		ENSURE_ARG(pSink!=NULL);
		ENSURE_ARG(m_pSink == NULL || m_pSink == pSink);
		m_pSink = pSink;
	}

inline void CWinFormsEventsHelper::Unadvise(IHandleEvents* pSink)
	{
		ENSURE_ARG(m_pSink == NULL || m_pSink == pSink);
		m_pSink = NULL;
	}

inline void CWinFormsEventsHelper::OnHandleCreated( System::Object^ o, System::EventArgs^ args)
	{
		if (m_pSink)
		{
			m_pSink->OnHandleCreated(o, args);
		}
	}
inline void CWinFormsEventsHelper::OnHandleDestroyed( System::Object^ o, System::EventArgs^ args)
	{
		if (m_pSink)
		{
			m_pSink->OnHandleDestroyed(o, args);
		}
		
	}

//CWinFormsControl<class TManagedControl>

template<class TManagedControl>
CWinFormsControl<TManagedControl>::CWinFormsControl()
	{		
	}

template<class TManagedControl>
inline TManagedControl^ CWinFormsControl<TManagedControl>::GetControl() const
	{
		CWinFormsControlSite* pSite=static_cast<CWinFormsControlSite*>(m_pCtrlSite);
		TManagedControl^ pCtrl=nullptr;
		if (pSite)
		{
			pCtrl=static_cast<TManagedControl^>(pSite->get_Control());
		}
		return pCtrl;
	}

template<class TManagedControl>
inline CWinFormsControl<TManagedControl>::operator TManagedControl^() const
	{
		return GetControl();
	}

template<class TManagedControl>
inline TManagedControl^ CWinFormsControl<TManagedControl>::operator->() const
	{
		return GetControl();
	}

template<class TManagedControl>
inline HWND CWinFormsControl<TManagedControl>::GetControlHandle() const
	{
		return reinterpret_cast<HWND>(static_cast<INT_PTR>(GetControl()->Handle));
	}	
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::InternalCreateManagedControl(const CControlCreationInfo& info,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
{
	CRect rect2( rect );
	CPoint pt;
	CSize size;

	pt = rect2.TopLeft();
	size = rect2.Size();
	MFCM80EnsureManagedInitialization();
	pParentWnd->m_nFlags |= WF_NOWIN32ISDIALOGMSG;
	return CreateControl(info,dwStyle,&pt,&size,pParentWnd,nID);
}

template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(System::Type^ pType,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
	{
		//Marshal the .Net Type a GCHandle to pass through native MFC.
		CControlCreationInfoEx info;
		info.Init(pType,CControlCreationInfo::ReflectionType);
		info.m_clsid=CLSID_WinFormsControl;
		return InternalCreateManagedControl(info,dwStyle,rect,pParentWnd,nID);		
	}

template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(TManagedControl^ pControl,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
	{
		ENSURE_ARG(pControl!=nullptr);
		CControlCreationInfoEx info;
		info.Init(pControl,CControlCreationInfo::ControlInstance);
		info.m_clsid=CLSID_WinFormsControl;
		return InternalCreateManagedControl(info,dwStyle,rect,pParentWnd,nID);		
	}
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(DWORD dwStyle,const RECT& rect, CWnd* pParentWnd, int nID)
	{
		return CreateManagedControl(TManagedControl::typeid,dwStyle,rect, pParentWnd, nID);		
	}
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(DWORD dwStyle,
		int nPlaceHolderID, CWnd* pParentWnd)
	{		
		ENSURE_ARG(pParentWnd!=NULL);
		CWnd* pwnd = pParentWnd->GetDlgItem(nPlaceHolderID);
		CRect rectPlaceHolder;
		ENSURE(pwnd != NULL);
		pwnd->GetWindowRect(&rectPlaceHolder);
		pParentWnd->ScreenToClient(rectPlaceHolder);
		//Combine caller supplied with place holder styles.
		DWORD controlStyle = dwStyle | pwnd->GetStyle();		
		BOOL ret=CreateManagedControl(controlStyle,rectPlaceHolder,pParentWnd,nPlaceHolderID);
		// Set ZOrder only, so managed control replaces the STATIC place holder in the child windows list.
		// This list affects Z-Order and Tab order.

		ASSERT(GetControlHandle()!=NULL);
		BOOL ok=::SetWindowPos(GetControlHandle(), pwnd->m_hWnd, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		ASSERT(ok);
				
		
		//Also need to change the linked list of tab order, maintained to support MFC implementation of 
		//IsDialogMessage, to delete the last entry (added by CreateControl), and change the place holder
		//entry, to point at our new control.
		COleControlSiteOrWnd *pThisSitePlaceHolderWnd=_AfxFindSiteOrWnd(pParentWnd,this);
		COleControlSiteOrWnd *pSitePlaceHolderWnd=_AfxFindSiteOrWnd(pParentWnd,pwnd);
		POSITION posRemove=pParentWnd->GetControlContainer()->m_listSitesOrWnds.Find(pThisSitePlaceHolderWnd);
		ASSERT(posRemove != NULL);
		if (posRemove)
		{
			pParentWnd->GetControlContainer()->m_listSitesOrWnds.RemoveAt(posRemove);
			ENSURE(pThisSitePlaceHolderWnd!=NULL);
			pThisSitePlaceHolderWnd->m_pSite = NULL; //So delete m_pSite in COleControlSiteOrWnd will not destory the site.
			delete pThisSitePlaceHolderWnd;
		}

		ASSERT(pSitePlaceHolderWnd);
		if (pSitePlaceHolderWnd)
		{
			pSitePlaceHolderWnd->m_hWnd = NULL;
			pSitePlaceHolderWnd->m_pSite = GetControlSite();
		}

		pwnd->DestroyWindow();
		return ret;
	}

///////////////////////////////////////////////////////////////////////////////
//CWinFormsDialog

BEGIN_MESSAGE_MAP_TEMPLATE(CWinFormsDialog, TManagedControl, CDialog)
	ON_WM_SIZE()
END_MESSAGE_MAP()

template <typename TManagedControl>
CWinFormsDialog<TManagedControl>::CWinFormsDialog(UINT nIDTemplate, CWnd* pParentWnd)
: CDialog(nIDTemplate, pParentWnd)
{
	m_pWFControl = gcnew TManagedControl();
}

template <typename TManagedControl>
BOOL CWinFormsDialog<TManagedControl>::OnInitDialog()
{	
	BOOL bRet=CDialog::OnInitDialog();
	ENSURE(bRet);
	//Create an instance of the control and retrieve its Size
	TManagedControl^ pControl = m_pWFControl;
	//Adjust the size of the dialog to accommodate for the control size.	
	CRect rcDlg;
	GetWindowRect(&rcDlg);	
	CRect rcDlgClient;
	GetClientRect(&rcDlgClient);
	ClientToScreen(&rcDlgClient);
	rcDlg.bottom -= rcDlgClient.Height();
	rcDlg.bottom +=  pControl->Size.Height;
	rcDlg.right  = rcDlg.left + pControl->Size.Width;
	MoveWindow(&rcDlg,FALSE);

	//Set title text to match control Text property
	CString title(pControl->Text);
	SetWindowText(title.GetString());
	//Host the new control in the mfc dialog
	CControlCreationInfoEx info;
	info.Init(pControl,CControlCreationInfo::ControlInstance);
	info.m_clsid=CLSID_WinFormsControl;	

	CRect rcCtrl;
	rcCtrl.top  = 0;
	rcCtrl.left = 0;
	rcCtrl.bottom = pControl->Size.Height;
	rcCtrl.right  = pControl->Size.Width;
	bRet=m_control.InternalCreateManagedControl(info,WS_VISIBLE | WS_TABSTOP,rcCtrl,this,IDC_WINFRMCTRL_DIALOG);

	ENSURE(GetControlHandle()!=NULL && bRet);
	return TRUE;
}
template <typename TManagedControl>
inline TManagedControl^ CWinFormsDialog<TManagedControl>::GetControl() const
	{
		return m_pWFControl;
	}

template <typename TManagedControl>
inline CWinFormsDialog<TManagedControl>::operator TManagedControl^() const
	{
		return GetControl();
	}

template <typename TManagedControl>
inline TManagedControl^ CWinFormsDialog<TManagedControl>::operator->() const
	{
		return GetControl();
	}

template <typename TManagedControl>
inline HWND CWinFormsDialog<TManagedControl>::GetControlHandle() const
	{
		return reinterpret_cast<HWND>(static_cast<INT_PTR>(GetControl()->Handle));
	}

template <typename TManagedControl>
void CWinFormsDialog<TManagedControl>::OnSize(UINT nType, int cx, int cy)
{		
	__super::OnSize(nType, cx, cy);

	//When view size changes, adjust the WinForms control (which is child of the view) 
	//size to occupy the entire client area of the view.
	CRect rcView;
	GetClientRect(&rcView);
	System::Drawing::Size size(rcView.Width(), rcView.Height());

	if (GetControl()!=nullptr)
	{
		GetControl()->Size = size;
	}
}

template <typename T>
void DDX_ManagedControl(CDataExchange* pDX, int nIDC,CWinFormsControl<T>& control)
{	
	if ((control.m_hWnd == NULL) && (control.GetControlUnknown() == NULL))    // not attached yet	
	{
		ASSERT(!pDX->m_bSaveAndValidate);		

		if (!control.CreateManagedControl(0,nIDC, pDX->m_pDlgWnd))
		{
			ASSERT(FALSE);
			AfxThrowNotSupportedException();
		}
	}
}

#endif //AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD

#ifndef METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE
#define METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE
//Inline in both Debug and Release - workaround for non-exportable __clrcall methods.

inline void CWinFormsControlSite::OnHandleCreated( System::Object^ , System::EventArgs^ )
	{		
		OnHandleCreatedHandler();
	}

inline void CWinFormsControlSite::OnHandleDestroyed( System::Object^ , System::EventArgs^ )
	{		
		DetachWindow();
	}

inline void CControlCreationInfoEx::Init(System::Object^ p,HandleKind hk)
	{
		// no need to check for valid handle; was allocated in ctor
		(GCHandle::operator GCHandle(static_cast<System::IntPtr>(m_nHandle) )).Target = p;		
		m_hk=hk;
	}

inline System::Windows::Forms::Control^  CWinFormsControlSite::get_Control() const
	{		
		System::Windows::Forms::Control^ pControl=m_gcEventHelper->Control::get();
		ENSURE((CWinFormsEventsHelper^)m_gcEventHelper!=nullptr && pControl!=nullptr);
		return pControl;
	}

//CWinFormsView
inline CWinFormsView::CWinFormsView(System::Type^ pManagedViewType)
	: m_pManagedViewType(pManagedViewType)
	{					
		ASSERT((System::Type^)m_pManagedViewType!=nullptr);		
	}

inline System::Windows::Forms::Control^ CWinFormsView::GetControl() const
	{
		return m_control.GetControl();
	}

inline CWinFormsView::operator System::Windows::Forms::Control^() const
	{
		return GetControl();
	}

#endif //METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE

#ifdef _AFXWIN_INLINE
#ifndef AFXWFRM_INL_INCLUDE_GUARD
#define AFXWFRM_INL_INCLUDE_GUARD

//CControlCreationInfoEx
_AFXWIN_INLINE CControlCreationInfoEx::CControlCreationInfoEx()
	{		
		m_nHandle = static_cast<intptr_t>( GCHandle::operator System::IntPtr(GCHandle::Alloc(nullptr)) );
	}

_AFXWIN_INLINE CControlCreationInfoEx::~CControlCreationInfoEx()
	{
		GCHandle g = GCHandle::operator GCHandle(static_cast<System::IntPtr>(m_nHandle));
		g.Free();
		m_nHandle = 0;
	}

//CWinFormsControlSite
_AFXWIN_INLINE CWinFormsControlSite::CWinFormsControlSite(COleControlContainer* pCtrlCont)
	: COleControlSite(pCtrlCont),m_gcEventHelper(gcnew CWinFormsEventsHelper())
	{
		m_gcEventHelper->Advise(this);
	}

_AFXWIN_INLINE CWinFormsControlSite::~CWinFormsControlSite() 
	{
		m_gcEventHelper->Unadvise(this);
	}
_AFXWIN_INLINE void CWinFormsControlSite::SetControlEnabled(bool bEnable)
	{
		get_Control()->Enabled=bEnable;
	}
_AFXWIN_INLINE void CWinFormsControlSite::OnHandleDestroyed( gcroot<System::Object^> , gcroot<System::EventArgs^> )
	{
		DetachWindow();
	}


#endif //AFXWFRM_INL_INCLUDE_GUARD
#endif // _AFXWIN_INLINE
		} //MFC
	} //VisualC
} //Microsoft
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwin2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 2)

#pragma once

#ifdef _AFXWIN_INLINE

// CWnd
_AFXWIN_INLINE CWnd::operator HWND() const
	{ return this == NULL ? NULL : m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator==(const CWnd& wnd) const
	{ return ((HWND) wnd) == m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator!=(const CWnd& wnd) const
	{ return ((HWND) wnd) != m_hWnd; }
_AFXWIN_INLINE HWND CWnd::GetSafeHwnd() const
	{ return this == NULL ? NULL : m_hWnd; }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE DWORD CWnd::GetStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_STYLE); }
_AFXWIN_INLINE DWORD CWnd::GetExStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ModifyStyle(m_hWnd, dwRemove, dwAdd, nFlags); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ModifyStyleEx(m_hWnd, dwRemove, dwAdd, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetOwner() const
	{ return m_hWndOwner != NULL ? CWnd::FromHandle(m_hWndOwner) : GetParent(); }
_AFXWIN_INLINE void CWnd::SetOwner(CWnd* pOwnerWnd)
	{ m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }

_AFXWIN_INLINE LRESULT CWnd::_AFX_FUNCNAME(SendMessage)(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, message, wParam, lParam); }
#pragma push_macro("SendMessage")
#undef SendMessage
_AFXWIN_INLINE LRESULT CWnd::SendMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ return _AFX_FUNCNAME(SendMessage)(message, wParam, lParam); }
#pragma pop_macro("SendMessage")
_AFXWIN_INLINE BOOL CWnd::PostMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::PostMessage(m_hWnd, message, wParam, lParam); }
#ifndef _WIN32_WCE // Drag n' Drop, unsupported win32 api call to DragDetect
_AFXWIN_INLINE BOOL CWnd::DragDetect(POINT pt) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::DragDetect(m_hWnd, pt); }
#endif // !_WIN32_WCE
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetWindowText(LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetWindowText(m_hWnd, lpszString); }
_AFXWIN_INLINE int CWnd::GetWindowText(__out_ecount_part_z(nMaxCount, return + 1) LPTSTR lpszString, __in int nMaxCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowText(m_hWnd, lpszString, nMaxCount); }
_AFXWIN_INLINE int CWnd::GetWindowTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowTextLength(m_hWnd); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetFont(CFont* pFont, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }
_AFXWIN_INLINE CFont* CWnd::GetFont() const
	{ ASSERT(::IsWindow(m_hWnd)); return CFont::FromHandle(
		(HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0)); }
_AFXWIN_INLINE CMenu* CWnd::GetMenu() const
	{ ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle(::GetMenu(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::SetMenu(CMenu* pMenu)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetMenu(m_hWnd, pMenu->GetSafeHmenu()); }
#ifndef _WIN32_WCE // Drag n' Drop, unsupported win32 api call to DragAcceptFiles
_AFXWIN_INLINE void CWnd::DragAcceptFiles(BOOL bAccept)
	{ ASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::DrawMenuBar()
	{ ASSERT(::IsWindow(m_hWnd)); ::DrawMenuBar(m_hWnd); }
_AFXWIN_INLINE CMenu* CWnd::GetSystemMenu(BOOL bRevert) const
	{ ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle(::GetSystemMenu(m_hWnd, bRevert)); }
#ifndef _WIN32_WCE // unsupported win32 api call to HiliteMenuItem
_AFXWIN_INLINE BOOL CWnd::HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite)
	{ ASSERT(::IsWindow(m_hWnd)); return ::HiliteMenuItem(m_hWnd, pMenu->m_hMenu, nIDHiliteItem, nHilite); }
#endif // !_WIN32_WCE
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE int CWnd::GetDlgCtrlID() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgCtrlID(m_hWnd); }
_AFXWIN_INLINE int CWnd::SetDlgCtrlID(int nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SetWindowLong(m_hWnd, GWL_ID, nID); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CFrameWnd* CWnd::EnsureParentFrame() const
{
    CFrameWnd *pFrameWnd=GetParentFrame();
    ENSURE_VALID(pFrameWnd);
    return pFrameWnd;
}
_AFXWIN_INLINE CWnd* CWnd::EnsureTopLevelParent() const
{
    CWnd *pWnd=GetTopLevelParent();
    ENSURE_VALID(pWnd);
    return pWnd;
}
_AFXWIN_INLINE BOOL CWnd::IsIconic() const
	{ ASSERT(::IsWindow(m_hWnd)); return ATL::IsIconic(m_hWnd); }
#ifndef _WIN32_WCE // unsupported win32 api call to IsZoomed
_AFXWIN_INLINE BOOL CWnd::IsZoomed() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsZoomed(m_hWnd); }
#endif // !_WIN32_WCE
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint)
	{ ASSERT(::IsWindow(m_hWnd)); ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(LPCRECT lpRect, BOOL bRepaint)
	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
		lpRect->bottom - lpRect->top, bRepaint); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
		x, y, cx, cy, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT
#ifndef _WIN32_WCE // unsupported win32 api call to ArrangeIconicWindows
_AFXWIN_INLINE UINT CWnd::ArrangeIconicWindows()
	{ ASSERT(::IsWindow(m_hWnd)); return ::ArrangeIconicWindows(m_hWnd); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CWnd::SetWindowRgn(HRGN hRgn, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowRgn(m_hWnd, hRgn, bRedraw); }
_AFXWIN_INLINE int CWnd::GetWindowRgn(HRGN hRgn) const
	{ ASSERT(::IsWindow(m_hWnd) && hRgn != NULL); return ::GetWindowRgn(m_hWnd, hRgn); }
_AFXWIN_INLINE void CWnd::BringWindowToTop()
	{ ASSERT(::IsWindow(m_hWnd)); ::BringWindowToTop(m_hWnd); }
_AFXWIN_INLINE void CWnd::GetWindowRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::GetClientRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), lpPoint, nCount); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), (LPPOINT)lpRect, 2); }
_AFXWIN_INLINE void CWnd::ClientToScreen(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); ::ClientToScreen(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, lpPoint); }
_AFXWIN_INLINE CDC* CWnd::BeginPaint(LPPAINTSTRUCT lpPaint)
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::BeginPaint(m_hWnd, lpPaint)); }
_AFXWIN_INLINE void CWnd::EndPaint(LPPAINTSTRUCT lpPaint)
	{ ASSERT(::IsWindow(m_hWnd)); ::EndPaint(m_hWnd, lpPaint); }
_AFXWIN_INLINE CDC* CWnd::GetDC()
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDC(m_hWnd)); }
_AFXWIN_INLINE CDC* CWnd::GetWindowDC()
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetWindowDC(m_hWnd)); }
_AFXWIN_INLINE int CWnd::ReleaseDC(CDC* pDC)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ReleaseDC(m_hWnd, pDC->m_hDC); }
_AFXWIN_INLINE void CWnd::UpdateWindow()
	{ ASSERT(::IsWindow(m_hWnd)); ::UpdateWindow(m_hWnd); }
_AFXWIN_INLINE void CWnd::SetRedraw(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETREDRAW, bRedraw, 0); }
_AFXWIN_INLINE BOOL CWnd::GetUpdateRect(LPRECT lpRect, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE int CWnd::GetUpdateRgn(CRgn* pRgn, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::Invalidate(BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRect(LPCRECT lpRect, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRgn(CRgn* pRgn, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::ValidateRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::ValidateRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::ValidateRgn(CRgn* pRgn)
	{ ASSERT(::IsWindow(m_hWnd)); ::ValidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::ShowWindow(int nCmdShow)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ShowWindow(m_hWnd, nCmdShow); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowVisible() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsWindowVisible(m_hWnd); }
#ifndef _WIN32_WCE // unsupported win32 api call to ShowOwnedPopups
_AFXWIN_INLINE void CWnd::ShowOwnedPopups(BOOL bShow)
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowOwnedPopups(m_hWnd, bShow); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::SendMessageToDescendants(
	UINT message, WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm)
	{ ASSERT(::IsWindow(m_hWnd)); CWnd::SendMessageToDescendants(m_hWnd, message, wParam, lParam, bDeep,
		bOnlyPerm); }
_AFXWIN_INLINE CWnd* CWnd::GetDescendantWindow(int nID, BOOL bOnlyPerm) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::GetDescendantWindow(m_hWnd, nID, bOnlyPerm); }

#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsDialogMessage(LPMSG lpMsg)
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsDialogMessage(m_hWnd, lpMsg); }
#endif

_AFXWIN_INLINE CDC* CWnd::GetDCEx(CRgn* prgnClip, DWORD flags)
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDCEx(m_hWnd, (HRGN)prgnClip->GetSafeHandle(), flags)); }
#ifndef _WIN32_WCE // unsupported win32 api call to LockWindowUpdate
_AFXWIN_INLINE BOOL CWnd::LockWindowUpdate()
	{ ASSERT(::IsWindow(m_hWnd)); return ::LockWindowUpdate(m_hWnd); }
_AFXWIN_INLINE void CWnd::UnlockWindowUpdate()
	{ ASSERT(::IsWindow(m_hWnd)); ::LockWindowUpdate(NULL); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::RedrawWindow(LPCRECT lpRectUpdate, CRgn* prgnUpdate,
	UINT flags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::RedrawWindow(m_hWnd, lpRectUpdate, (HRGN)prgnUpdate->GetSafeHandle(), flags); }
#ifndef _WIN32_WCE // undeclared identifier ESB_ENABLE_BOTH and unsupported win32 api call to EnableScrollBar, DrawAnimatedRects, and DrawCaption
_AFXWIN_INLINE BOOL CWnd::EnableScrollBar(int nSBFlags, UINT nArrowFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::EnableScrollBar(m_hWnd, nSBFlags, nArrowFlags); }
_AFXWIN_INLINE BOOL CWnd::DrawAnimatedRects(int idAni, CONST RECT *lprcFrom, CONST RECT *lprcTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::DrawAnimatedRects(m_hWnd, idAni, lprcFrom, lprcTo); }
_AFXWIN_INLINE BOOL CWnd::DrawCaption(CDC* pDC, LPCRECT lprc, UINT uFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::DrawCaption(m_hWnd, pDC->GetSafeHdc(), lprc, uFlags); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE UINT_PTR CWnd::SetTimer(UINT_PTR nIDEvent, UINT nElapse,
		void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD))
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetTimer(m_hWnd, nIDEvent, nElapse,
		lpfnTimer); }
_AFXWIN_INLINE BOOL CWnd::KillTimer(UINT_PTR nIDEvent)
	{ ASSERT(::IsWindow(m_hWnd)); return ::KillTimer(m_hWnd, nIDEvent); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowEnabled() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsWindowEnabled(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::EnableWindow(BOOL bEnable)
	{ ASSERT(::IsWindow(m_hWnd)); return ::EnableWindow(m_hWnd, bEnable); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetActiveWindow()
	{ return CWnd::FromHandle(::GetActiveWindow()); }
_AFXWIN_INLINE CWnd* CWnd::SetActiveWindow()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetActiveWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetCapture()
	{ return CWnd::FromHandle(::GetCapture()); }
_AFXWIN_INLINE CWnd* CWnd::SetCapture()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetCapture(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetFocus()
	{ return CWnd::FromHandle(::GetFocus()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::SetFocus()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetFocus(m_hWnd)); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetDesktopWindow()
	{ return CWnd::FromHandle(::GetDesktopWindow()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::CheckDlgButton(int nIDButton, UINT nCheck)
	{ ASSERT(::IsWindow(m_hWnd)); ::CheckDlgButton(m_hWnd, nIDButton, nCheck); }
_AFXWIN_INLINE void CWnd::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
		int nIDCheckButton)
	{ ASSERT(::IsWindow(m_hWnd)); ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton); }
#endif //_AFX_NO_OCC_SUPPORT
#ifndef _WIN32_WCE // unsupported win32 api call to DlgDirList, DlgDirListComboBox, DlgDirSelectEx, DlgDirSelectComboBoxEx
_AFXWIN_INLINE int CWnd::DlgDirList(__inout_z LPTSTR lpPathSpec, __in int nIDListBox,
		__in int nIDStaticPath, __in UINT nFileType)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox,
			nIDStaticPath, nFileType); }
_AFXWIN_INLINE int CWnd::DlgDirListComboBox(__inout_z LPTSTR lpPathSpec, __in int nIDComboBox,
		__in int nIDStaticPath, __in UINT nFileType)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirListComboBox(m_hWnd, lpPathSpec,
			nIDComboBox, nIDStaticPath, nFileType); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(LPTSTR lpString, int nIDListBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectEx(m_hWnd, lpString, _MAX_PATH, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(LPTSTR lpString, int nSize, int nIDListBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectEx(m_hWnd, lpString, nSize, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(LPTSTR lpString, int nIDComboBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, _MAX_PATH, nIDComboBox);}
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(LPTSTR lpString, int nSize, int nIDComboBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nSize, nIDComboBox);}
#endif // !_WIN32_WCE
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetDlgItem(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetDlgItem(m_hWnd, nID)); }
_AFXWIN_INLINE void CWnd::GetDlgItem(int nID, HWND* phWnd) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(phWnd != NULL); *phWnd = ::GetDlgItem(m_hWnd, nID); }
_AFXWIN_INLINE UINT CWnd::GetDlgItemInt(int nID, BOOL* lpTrans,
		BOOL bSigned) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);}
_AFXWIN_INLINE int CWnd::GetDlgItemText(__in int nID, __out_ecount_part_z(nMaxCount, return + 1) LPTSTR lpStr, __in int nMaxCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);}
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgGroupItem(m_hWnd,
			pWndCtl->GetSafeHwnd(), bPrevious)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgTabItem(m_hWnd,
			pWndCtl->GetSafeHwnd(), bPrevious)); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE UINT CWnd::IsDlgButtonChecked(int nIDButton) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsDlgButtonChecked(m_hWnd, nIDButton); }
_AFXWIN_INLINE LPARAM CWnd::SendDlgItemMessage(int nID, UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); }
_AFXWIN_INLINE void CWnd::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned); }
_AFXWIN_INLINE void CWnd::SetDlgItemText(int nID, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemText(m_hWnd, nID, lpszString); }
_AFXWIN_INLINE int CWnd::ScrollWindowEx(int dx, int dy,
	LPCRECT lpRectScroll, LPCRECT lpRectClip,
	CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip,
			(HRGN)prgnUpdate->GetSafeHandle(), lpRectUpdate, flags); }
#endif //_AFX_NO_OCC_SUPPORT

#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::ShowScrollBar(UINT nBar, BOOL bShow)
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, nBar, bShow); }
#else
_AFXWIN_INLINE void CWnd::ShowScrollBar(UINT nBar, BOOL bShow)
{
	ASSERT(::IsWindow(m_hWnd));
	
	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
	if (bShow)
		dwStyle |= ((nBar == SB_HORZ) ? WS_HSCROLL : WS_VSCROLL);
	else
		dwStyle &= ~((nBar == SB_HORZ) ? WS_HSCROLL : WS_VSCROLL);

	::SetWindowLong(m_hWnd, GWL_STYLE, dwStyle);
}
#endif // !_WIN32_WCE
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPoint(m_hWnd, point)); }
#ifndef _WIN32_WCE  // unsupported win32 api call to ChildWindowFromPointEx
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point, UINT nFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPointEx(m_hWnd, point, nFlags)); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE CWnd* PASCAL CWnd::FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName)
	{ return CWnd::FromHandle(::FindWindow(lpszClassName, lpszWindowName)); }
#ifndef _WIN32_WCE // unsupported win32 api call to FindWindowEx
_AFXWIN_INLINE CWnd* CWnd::FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow)
	{ return CWnd::FromHandle(::FindWindowEx(hwndParent, hwndChildAfter, lpszClass, lpszWindow)); }
#endif // !_WIN32_WCE

_AFXWIN_INLINE CWnd* CWnd::GetNextWindow(UINT nFlag) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(ATL::GetNextWindow(m_hWnd, nFlag)); }
_AFXWIN_INLINE CWnd* CWnd::GetTopWindow() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(ATL::GetTopWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::GetWindow(UINT nCmd) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetWindow(m_hWnd, nCmd)); }
_AFXWIN_INLINE CWnd* CWnd::GetLastActivePopup() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(ATL::GetLastActivePopup(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::IsChild(const CWnd* pWnd) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsChild(m_hWnd, pWnd->GetSafeHwnd()); }
_AFXWIN_INLINE CWnd* CWnd::GetParent() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetParent(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::SetParent(CWnd* pWndNewParent)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetParent(m_hWnd,
			pWndNewParent->GetSafeHwnd())); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::WindowFromPoint(POINT point)
	{ return CWnd::FromHandle(::WindowFromPoint(point)); }
#pragma push_macro("MessageBox")
#undef MessageBox
_AFXWIN_INLINE int CWnd::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
	{ return _AFX_FUNCNAME(MessageBox)(lpszText, lpszCaption, nType); }
#pragma pop_macro("MessageBox")
#ifndef _WIN32_WCE // unsupported win32 api call to FlashWindow, ChangeClipboardChain, and SetClipboardViewer
_AFXWIN_INLINE BOOL CWnd::FlashWindow(BOOL bInvert)
	{ ASSERT(::IsWindow(m_hWnd)); return ::FlashWindow(m_hWnd, bInvert); }
_AFXWIN_INLINE BOOL CWnd::ChangeClipboardChain(HWND hWndNext)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ChangeClipboardChain(m_hWnd, hWndNext); }
_AFXWIN_INLINE HWND CWnd::SetClipboardViewer()
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetClipboardViewer(m_hWnd); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OpenClipboard()
	{ ASSERT(::IsWindow(m_hWnd)); return ::OpenClipboard(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetOpenClipboardWindow()
	{ return CWnd::FromHandle(::GetOpenClipboardWindow()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardOwner()
	{ return CWnd::FromHandle(::GetClipboardOwner()); }
#ifndef _WIN32_WCE // unsupported win32 api call to GetClipboardViewer
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardViewer()
	{ return CWnd::FromHandle(::GetClipboardViewer()); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::CreateCaret(CBitmap* pBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)pBitmap->GetSafeHandle(), 0, 0); }
_AFXWIN_INLINE void CWnd::CreateSolidCaret(int nWidth, int nHeight)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight); }
_AFXWIN_INLINE void CWnd::CreateGrayCaret(int nWidth, int nHeight)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight); }
_AFXWIN_INLINE CPoint PASCAL CWnd::GetCaretPos()
	{ CPoint point; ::GetCaretPos((LPPOINT)&point); return point; }
_AFXWIN_INLINE void PASCAL CWnd::SetCaretPos(POINT point)
	{ ::SetCaretPos(point.x, point.y); }
_AFXWIN_INLINE void CWnd::HideCaret()
	{ ASSERT(::IsWindow(m_hWnd)); ::HideCaret(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowCaret()
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowCaret(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::SetForegroundWindow()
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetForegroundWindow(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetForegroundWindow()
	{ return CWnd::FromHandle(::GetForegroundWindow()); }

_AFXWIN_INLINE BOOL CWnd::SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendNotifyMessage(m_hWnd, message, wParam, lParam); }

// Win4
_AFXWIN_INLINE HICON CWnd::SetIcon(HICON hIcon, BOOL bBigIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CWnd::GetIcon(BOOL bBigIcon) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0); }
#ifndef _AFX_NO_PRINTING_SUPPORT
_AFXWIN_INLINE void CWnd::Print(CDC* pDC, DWORD dwFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
_AFXWIN_INLINE void CWnd::PrintClient(CDC* pDC, DWORD dwFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE_NO_HELP_SUPPORT // unsupported win32 api call to SetWindowContextHelpId and GetWindowContextHelpId
_AFXWIN_INLINE BOOL CWnd::SetWindowContextHelpId(DWORD dwContextHelpId)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId); }
_AFXWIN_INLINE DWORD CWnd::GetWindowContextHelpId() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowContextHelpId(m_hWnd); }
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// ActiveAccessibility
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::EnableActiveAccessibility()
	{ m_bEnableActiveAccessibility = true; }
_AFXWIN_INLINE void CWnd::NotifyWinEvent(DWORD event, LONG idObjectType, LONG idObject)
	{ ASSERT(::IsWindow(m_hWnd)); if (m_pfnNotifyWinEvent != NULL) (*m_pfnNotifyWinEvent)(event, m_hWnd, idObjectType, idObject); }
#endif // !_WIN32_WCE

// Default message map implementations
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnActivateApp(BOOL, DWORD)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnActivate(UINT, CWnd*, BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnCancelMode()
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnChildActivate()
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnClose()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnContextMenu(CWnd*, CPoint)
	{ Default(); }
_AFXWIN_INLINE int CWnd::OnCopyData(CWnd*, COPYDATASTRUCT*)
	{ return (int)Default(); }
_AFXWIN_INLINE int CWnd::OnCreate(LPCREATESTRUCT)
	{ return (int)Default(); }
_AFXWIN_INLINE void CWnd::OnEnable(BOOL)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnEndSession(BOOL)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OnEraseBkgnd(CDC*)
	{ return (BOOL)Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnGetMinMaxInfo(MINMAXINFO*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnIconEraseBkgnd(CDC*)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnKillFocus(CWnd*)
	{ Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnMenuChar(UINT, UINT, CMenu*)
	{ return Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnMenuSelect(UINT, UINT, HMENU)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnMove(int, int)
	{ Default(); }
_AFXWIN_INLINE HCURSOR CWnd::OnQueryDragIcon()
	{ return (HCURSOR)Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OnQueryEndSession()
	{ return (BOOL)Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OnQueryNewPalette()
	{ return (BOOL)Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OnQueryOpen()
	{ return (BOOL)Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CWnd::OnSetCursor(CWnd*, UINT, UINT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnShowWindow(BOOL, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSize(UINT, int, int)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnTCard(UINT, DWORD)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnWindowPosChanging(WINDOWPOS*)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnWindowPosChanged(WINDOWPOS*)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnDropFiles(HDROP)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteIsChanging(CWnd*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcActivate(BOOL)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcCreate(LPCREATESTRUCT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnNcHitTest(CPoint)
	{ return Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcPaint()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonUp(UINT, CPoint)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnSysChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysCommand(UINT, LPARAM)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyUp(UINT, UINT, UINT)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnCompacting(UINT)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnFontChange()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteChanged(CWnd*)
	{ Default(); }
#ifndef _AFX_NO_PRINTING_SUPPORT
_AFXWIN_INLINE void CWnd::OnSpoolerStatus(UINT, UINT)
	{ Default(); }
#endif // !_AFX_NO_PRINTING_SUPPORT
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnTimeChange()
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnKeyUp(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonDblClk(UINT, CPoint)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnLButtonDown(UINT, CPoint)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonUp(UINT, CPoint)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE int CWnd::OnMouseActivate(CWnd*, UINT, UINT)
	{ return (int)Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnMouseWheel(UINT, short, CPoint)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnRegisteredMouseWheel(WPARAM, LPARAM)
	{ return Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnTimer(UINT_PTR)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnInitMenu(CMenu*)
	{ Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnInitMenuPopup(CMenu*, UINT, BOOL)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnAskCbFormatName(__in UINT nMaxCount, __out_ecount_z(nMaxCount) LPTSTR pszName)
{
	(nMaxCount);
	if(nMaxCount>0)
	{
		/* defwindow proc should do this for us, but to be safe, we'll do it here too */
		pszName[0]=_T('\0');
	}
	Default(); 
}
_AFXWIN_INLINE void CWnd::OnChangeCbChain(HWND, HWND)
	{ Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnDestroyClipboard()
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnDrawClipboard()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnHScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaintClipboard(CWnd*, HGLOBAL)
	{ Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnRenderAllFormats()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRenderFormat(UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSizeClipboard(CWnd*, HGLOBAL)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnVScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE UINT CWnd::OnGetDlgCode()
	{ return (UINT)Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnMDIActivate(BOOL, CWnd*, CWnd*)
	{ Default(); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnEnterMenuLoop(BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnExitMenuLoop(BOOL)
	{ Default(); }
// Win4 support
_AFXWIN_INLINE void CWnd::OnStyleChanged(int, LPSTYLESTRUCT)
	{ Default(); }
#ifndef _WIN32_WCE
_AFXWIN_INLINE void CWnd::OnStyleChanging(int, LPSTYLESTRUCT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSizing(UINT, LPRECT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMoving(UINT, LPRECT)
	{ Default(); }
#endif //!_WIN32_WCE
_AFXWIN_INLINE void CWnd::OnCaptureChanged(CWnd*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnDeviceChange(UINT, DWORD_PTR)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnWinIniChange(LPCTSTR)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnChangeUIState(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnUpdateUIState(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnQueryUIState()
	{ return (UINT)Default(); }

// CWnd dialog data support
_AFXWIN_INLINE void CWnd::DoDataExchange(CDataExchange*)
	{ } // default does nothing

// CWnd modality support
_AFXWIN_INLINE void CWnd::BeginModalState()
	{ ::EnableWindow(m_hWnd, FALSE); }
_AFXWIN_INLINE void CWnd::EndModalState()
	{ ::EnableWindow(m_hWnd, TRUE); }

// CFrameWnd
_AFXWIN_INLINE void CFrameWnd::DelayUpdateFrameTitle()
	{ m_nIdleFlags |= idleTitle; }
_AFXWIN_INLINE void CFrameWnd::DelayRecalcLayout(BOOL bNotify)
	{ m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
_AFXWIN_INLINE BOOL CFrameWnd::InModalState() const
	{ return m_cModalStack != 0; }
_AFXWIN_INLINE void CFrameWnd::AddControlBar(CControlBar *pBar)
	{ m_listControlBars.AddTail(pBar); }
_AFXWIN_INLINE void CFrameWnd::SetTitle(LPCTSTR lpszTitle)
	{ m_strTitle = lpszTitle; }
_AFXWIN_INLINE CString CFrameWnd::GetTitle() const
	{ return m_strTitle; }

// CDialog
_AFXWIN_INLINE BOOL CDialog::Create(UINT nIDTemplate, CWnd* pParentWnd)
	{ return CDialog::Create(ATL_MAKEINTRESOURCE(nIDTemplate), pParentWnd); }
_AFXWIN_INLINE void CDialog::MapDialogRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapDialogRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CDialog::SetHelpID(UINT nIDR)
	{ m_nIDHelp = nIDR; }
_AFXWIN_INLINE void CDialog::NextDlgCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0); }
_AFXWIN_INLINE void CDialog::PrevDlgCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0); }
_AFXWIN_INLINE void CDialog::GotoDlgCtrl(CWnd* pWndCtrl)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)pWndCtrl->m_hWnd, 1L); }
_AFXWIN_INLINE void CDialog::SetDefID(UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, DM_SETDEFID, nID, 0); }
_AFXWIN_INLINE DWORD CDialog::GetDefID() const
//IA64: Assuming retval of DM_GETDEFID won't be expanded
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, DM_GETDEFID, 0, 0)); }

// Window control functions
_AFXWIN_INLINE CStatic::CStatic()
	{ }
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
_AFXWIN_INLINE HICON CStatic::SetIcon(HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L); }
_AFXWIN_INLINE HICON CStatic::GetIcon() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L); }
_AFXWIN_INLINE HENHMETAFILE CStatic::SetEnhMetaFile(HENHMETAFILE hMetaFile)
	{ ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile); }
_AFXWIN_INLINE HENHMETAFILE CStatic::GetEnhMetaFile() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE HBITMAP CStatic::SetBitmap(HBITMAP hBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CStatic::GetBitmap() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CStatic::SetCursor(HCURSOR hCursor)
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CStatic::GetCursor()
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L); }

_AFXWIN_INLINE CButton::CButton()
	{ }
_AFXWIN_INLINE UINT CButton::GetState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0); }
_AFXWIN_INLINE void CButton::SetState(BOOL bHighlight)
	{ ::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0); }
_AFXWIN_INLINE int CButton::GetCheck() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0); }
_AFXWIN_INLINE void CButton::SetCheck(int nCheck)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0); }
_AFXWIN_INLINE UINT CButton::GetButtonStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)GetWindowLong(m_hWnd, GWL_STYLE) & 0xff; }
_AFXWIN_INLINE void CButton::SetButtonStyle(UINT nStyle, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw); }
// Win4
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
_AFXWIN_INLINE HICON CButton::SetIcon(HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CButton::GetIcon() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L); }
_AFXWIN_INLINE HBITMAP CButton::SetBitmap(HBITMAP hBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CButton::GetBitmap() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CButton::SetCursor(HCURSOR hCursor)
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CButton::GetCursor()
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_CURSOR, 0L); }
#endif // !_WIN32_WCE

_AFXWIN_INLINE CListBox::CListBox()
	{ }
_AFXWIN_INLINE int CListBox::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CListBox::SetCurSel(int nSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE int CListBox::GetHorizontalExtent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT,
		0, 0); }
_AFXWIN_INLINE void CListBox::SetHorizontalExtent(int cxExtent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0); }
_AFXWIN_INLINE int CListBox::GetSelCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetSelItems(int nMaxItems, LPINT rgIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex); }
_AFXWIN_INLINE int CListBox::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CListBox::SetTopIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0);}
_AFXWIN_INLINE DWORD_PTR CListBox::GetItemData(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CListBox::GetItemDataPtr(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (LPVOID)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemDataPtr(int nIndex, void* pData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CListBox::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXWIN_INLINE int CListBox::GetSel(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetSel(int nIndex, BOOL bSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex); }
_AFXWIN_INLINE int CListBox::GetText(__in int nIndex, __out_z LPTSTR lpszBuffer) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer); 
}
_AFXWIN_INLINE int CListBox::GetTextLen(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CListBox::SetColumnWidth(int cxWidth)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops); }
_AFXWIN_INLINE void CListBox::SetTabStops()
	{ ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(const int& cxEachStop)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE int CListBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CListBox::GetItemHeight(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CListBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CListBox::GetCaretIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0L); }
_AFXWIN_INLINE int CListBox::SetCaretIndex(int nIndex, BOOL bScroll)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0)); }
_AFXWIN_INLINE int CListBox::AddString(LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::DeleteString(UINT nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }
_AFXWIN_INLINE int CListBox::InsertString(int nIndex, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem); }
_AFXWIN_INLINE void CListBox::ResetContent()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
_AFXWIN_INLINE int CListBox::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CListBox::FindString(int nStartAfter, LPCTSTR lpszItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelectString(int nStartAfter, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
	{ ASSERT(::IsWindow(m_hWnd)); return bSelect ?
		(int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) :
		(int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem); }
_AFXWIN_INLINE void CListBox::SetAnchorIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0); }
_AFXWIN_INLINE int CListBox::GetAnchorIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0); }
_AFXWIN_INLINE LCID CListBox::GetLocale() const
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CListBox::SetLocale(LCID nNewLocale)
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0); }
_AFXWIN_INLINE int CListBox::InitStorage(int nItems, UINT nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes); }

#ifndef _WIN32_WCE // Controls
_AFXWIN_INLINE CCheckListBox::CCheckListBox()
	{ m_cyText = 0; m_nStyle = 0; EnableActiveAccessibility(); }
_AFXWIN_INLINE UINT CCheckListBox::GetCheckStyle()
	{ return m_nStyle; }
#endif // !_WIN32_WCE

_AFXWIN_INLINE CComboBox::CComboBox()
	{ }
_AFXWIN_INLINE int CComboBox::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CComboBox::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetCurSel(int nSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }
//IA64: Assuming retval of CB_GETEDITSEL won't be expanded
_AFXWIN_INLINE DWORD CComboBox::GetEditSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0)); }
_AFXWIN_INLINE BOOL CComboBox::LimitText(int nMaxChars)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0); }
_AFXWIN_INLINE BOOL CComboBox::SetEditSel(int nStartChar, int nEndChar)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar)); }
_AFXWIN_INLINE DWORD_PTR CComboBox::GetItemData(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CComboBox::GetItemDataPtr(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (LPVOID)GetItemData(nIndex); }
_AFXWIN_INLINE int CComboBox::SetItemDataPtr(int nIndex, void* pData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CComboBox::GetLBText(__in int nIndex, __out_z LPTSTR lpszText) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText); 
}
_AFXWIN_INLINE int CComboBox::GetLBTextLen(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CComboBox::ShowDropDown(BOOL bShowIt)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0); }
_AFXWIN_INLINE int CComboBox::AddString(LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::DeleteString(UINT nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0);}
_AFXWIN_INLINE int CComboBox::InsertString(int nIndex, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::ResetContent()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
_AFXWIN_INLINE int CComboBox::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CComboBox::FindString(int nStartAfter, LPCTSTR lpszString) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter,
		(LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::SelectString(int nStartAfter, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CComboBox::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CComboBox::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CComboBox::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CComboBox::GetItemHeight(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CComboBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CComboBox::SetExtendedUI(BOOL bExtended )
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L); }
_AFXWIN_INLINE BOOL CComboBox::GetExtendedUI() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L); }
_AFXWIN_INLINE void CComboBox::GetDroppedControlRect(LPRECT lprect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect); }
_AFXWIN_INLINE BOOL CComboBox::GetDroppedState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L); }
_AFXWIN_INLINE LCID CComboBox::GetLocale() const
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CComboBox::SetLocale(LCID nNewLocale)
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0); }
_AFXWIN_INLINE int CComboBox::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetTopIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::InitStorage(int nItems, UINT nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes); }
_AFXWIN_INLINE void CComboBox::SetHorizontalExtent(UINT nExtent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0); }
_AFXWIN_INLINE UINT CComboBox::GetHorizontalExtent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetDroppedWidth(UINT nWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0); }
_AFXWIN_INLINE int CComboBox::GetDroppedWidth() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0); }
_AFXWIN_INLINE CEdit::CEdit()
	{ }
_AFXWIN_INLINE BOOL CEdit::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXWIN_INLINE int CEdit::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXWIN_INLINE void CEdit::SetModify(BOOL bModified)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0); }
_AFXWIN_INLINE void CEdit::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::GetSel(int& nStartChar, int& nEndChar) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar,(LPARAM)&nEndChar); }
_AFXWIN_INLINE DWORD CEdit::GetSel() const
//IA64: Assuming retval of EM_GETSEL won't be expanded
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, EM_GETSEL, 0, 0)); }
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
_AFXWIN_INLINE HLOCAL CEdit::GetHandle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0); }
_AFXWIN_INLINE void CEdit::SetHandle(HLOCAL hBuffer)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE int CEdit::GetLine(__in int nIndex, __out LPTSTR lpszBuffer) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CEdit::GetLine(__in int nIndex, __out_ecount_part(nMaxLength, return) LPTSTR lpszBuffer, __in int nMaxLength) const
	{
		ASSERT(::IsWindow(m_hWnd));
		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
_AFXWIN_INLINE void CEdit::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::FmtLines(BOOL bAddEOL)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0); }
_AFXWIN_INLINE void CEdit::LimitText(int nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0); }
_AFXWIN_INLINE int CEdit::LineFromChar(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0); }
_AFXWIN_INLINE int CEdit::LineIndex(int nLine) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0); }
_AFXWIN_INLINE int CEdit::LineLength(int nLine) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0); }
_AFXWIN_INLINE void CEdit::LineScroll(int nLines, int nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines); }
_AFXWIN_INLINE void CEdit::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXWIN_INLINE void CEdit::SetPasswordChar(TCHAR ch)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0); }
_AFXWIN_INLINE void CEdit::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetRectNP(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetSel(DWORD dwSelection, BOOL bNoScroll)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL,
		LOWORD(dwSelection), HIWORD(dwSelection));
	  if (!bNoScroll)
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE void CEdit::SetSel(int nStartChar, int nEndChar, BOOL bNoScroll)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
	  if (!bNoScroll)
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops,
		(LPARAM)rgTabStops); }
_AFXWIN_INLINE void CEdit::SetTabStops()
	{ ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(const int& cxEachStop)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS,
		1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE BOOL CEdit::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXWIN_INLINE void CEdit::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CEdit::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CEdit::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CEdit::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetReadOnly(BOOL bReadOnly )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXWIN_INLINE int CEdit::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXWIN_INLINE TCHAR CEdit::GetPasswordChar() const
	{ ASSERT(::IsWindow(m_hWnd)); return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L); }
_AFXWIN_INLINE void CEdit::SetMargins(UINT nLeft, UINT nRight)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight)); }
_AFXWIN_INLINE DWORD CEdit::GetMargins() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0); }
_AFXWIN_INLINE void CEdit::SetLimitText(UINT nMax)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0); }
_AFXWIN_INLINE UINT CEdit::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0); }
_AFXWIN_INLINE CPoint CEdit::PosFromChar(UINT nChar) const
	{ ASSERT(::IsWindow(m_hWnd)); return CPoint( (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0)); }
_AFXWIN_INLINE int CEdit::CharFromPos(CPoint pt) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y)); }

_AFXWIN_INLINE CScrollBar::CScrollBar()
	{ }
_AFXWIN_INLINE int CScrollBar::GetScrollPos() const
{ ASSERT(::IsWindow(m_hWnd)); return ATL::GetScrollPos(m_hWnd, SB_CTL); }
_AFXWIN_INLINE int CScrollBar::SetScrollPos(int nPos, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
	{ ASSERT(::IsWindow(m_hWnd)); ATL::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos); }
_AFXWIN_INLINE void CScrollBar::SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::ShowScrollBar(BOOL bShow)
#ifndef _WIN32_WCE
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, SB_CTL, bShow); }
#else
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowWindow(m_hWnd, (bShow) ? SW_SHOW : SW_HIDE); }
#endif // !_WIN32_WCE
#ifndef _WIN32_WCE // Unsupported Win32 API call
_AFXWIN_INLINE BOOL CScrollBar::EnableScrollBar(UINT nArrowFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags); }
#endif // !_WIN32_WCE
_AFXWIN_INLINE BOOL CScrollBar::SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw)
	{ return CWnd::SetScrollInfo(SB_CTL, lpScrollInfo, bRedraw); }
_AFXWIN_INLINE BOOL CScrollBar::GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask)
	{ return CWnd::GetScrollInfo(SB_CTL, lpScrollInfo, nMask); }
_AFXWIN_INLINE int CScrollBar::GetScrollLimit()
	{ return CWnd::GetScrollLimit(SB_CTL); }

#ifndef _WIN32_WCE // Frame Windows
// MDI functions
_AFXWIN_INLINE void CMDIFrameWnd::MDIActivate(CWnd* pWndActivate)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE,
		(WPARAM)pWndActivate->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIIconArrange()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIMaximize(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIPrev()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 1); }
_AFXWIN_INLINE void CMDIFrameWnd::MDINext()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIRestore(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE CMenu* CMDIFrameWnd::MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu)
	{ ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle((HMENU)::SendMessage(
		m_hWndMDIClient, WM_MDISETMENU, (WPARAM)pFrameMenu->GetSafeHmenu(),
		(LPARAM)pWindowMenu->GetSafeHmenu())); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDICascade()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, 0, 0); }

_AFXWIN_INLINE void CMDIFrameWnd::MDICascade(int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, nType, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile(int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, nType, 0); }
_AFXWIN_INLINE void CMDIChildWnd::MDIDestroy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIDESTROY, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIActivate()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIACTIVATE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIMaximize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIMAXIMIZE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIRestore()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIRESTORE, (WPARAM)m_hWnd, 0L); }
#endif // !_WIN32_WCE

// CView
_AFXWIN_INLINE CDocument* CView::GetDocument() const
	{ ASSERT(this != NULL); return m_pDocument; }
_AFXWIN_INLINE CSize CScrollView::GetTotalSize() const
	{ ASSERT(this != NULL); return m_totalLog; }

// CDocument
_AFXWIN_INLINE const CString& CDocument::GetTitle() const
	{ ASSERT(this != NULL); return m_strTitle; }
_AFXWIN_INLINE const CString& CDocument::GetPathName() const
	{ ASSERT(this != NULL); return m_strPathName; }
_AFXWIN_INLINE CDocTemplate* CDocument::GetDocTemplate() const
	{ ASSERT(this != NULL); return m_pDocTemplate; }
_AFXWIN_INLINE BOOL CDocument::IsModified()
	{ ASSERT(this != NULL); return m_bModified; }
_AFXWIN_INLINE void CDocument::SetModifiedFlag(BOOL bModified)
	{ ASSERT(this != NULL); m_bModified = bModified; }

// CWinThread
_AFXWIN_INLINE CWinThread::operator HANDLE() const
	{ return this == NULL ? NULL : m_hThread; }
_AFXWIN_INLINE BOOL CWinThread::SetThreadPriority(int nPriority)
	{ ASSERT(m_hThread != NULL); return ::SetThreadPriority(m_hThread, nPriority); }
_AFXWIN_INLINE int CWinThread::GetThreadPriority()
	{ ASSERT(m_hThread != NULL); return ::GetThreadPriority(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::ResumeThread()
	{ ASSERT(m_hThread != NULL); return ::ResumeThread(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::SuspendThread()
	{ ASSERT(m_hThread != NULL); return ::SuspendThread(m_hThread); }
_AFXWIN_INLINE BOOL CWinThread::PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(m_hThread != NULL); return ::PostThreadMessage(m_nThreadID, message, wParam, lParam); }

// CWinApp
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(LPCTSTR lpszResourceName) const
	{ return ::LoadCursor(AfxFindResourceHandle(lpszResourceName,
		ATL_RT_GROUP_CURSOR), lpszResourceName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(UINT nIDResource) const
	{ return ::LoadCursor(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),
		ATL_RT_GROUP_CURSOR), ATL_MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadStandardCursor(LPCTSTR lpszCursorName) const
	{ return ::LoadCursor(NULL, lpszCursorName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadOEMCursor(UINT nIDCursor) const
	{ return ::LoadCursor(NULL, ATL_MAKEINTRESOURCE(nIDCursor)); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(LPCTSTR lpszResourceName) const
	{ return ::LoadIcon(AfxFindResourceHandle(lpszResourceName,
		ATL_RT_GROUP_ICON), lpszResourceName); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(UINT nIDResource) const
	{ return ::LoadIcon(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),
		ATL_RT_GROUP_ICON), ATL_MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HICON CWinApp::LoadStandardIcon(LPCTSTR lpszIconName) const
	{ return ::LoadIcon(NULL, lpszIconName); }
_AFXWIN_INLINE HICON CWinApp::LoadOEMIcon(UINT nIDIcon) const
	{ return ::LoadIcon(NULL, ATL_MAKEINTRESOURCE(nIDIcon)); }
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
_AFXWIN_INLINE void CWinApp::EnableHtmlHelp()
	{ SetHelpMode( afxHTMLHelp ); }
_AFXWIN_INLINE AFX_HELP_TYPE CWinApp::GetHelpMode() 
	{ return m_eHelpType; }

_AFXWIN_INLINE void CWinApp::SetHelpMode( AFX_HELP_TYPE eHelpType )
	{ 
		ASSERT( eHelpType == afxHTMLHelp || eHelpType == afxWinHelp );
		m_eHelpType = eHelpType; 
	}
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

#pragma warning(push)
#pragma warning(disable: 4996)
_AFXWIN_INLINE BOOL CWinApp::Enable3dControls()
	{ return TRUE; }
#ifndef _AFXDLL
_AFXWIN_INLINE BOOL CWinApp::Enable3dControlsStatic()
	{ return TRUE; }
#endif
_AFXWIN_INLINE void CWinApp::SetDialogBkColor(COLORREF /*clrCtlBk*/, COLORREF /*clrCtlText*/)
{
}
#pragma warning(pop)

_AFXWIN_INLINE CWaitCursor::CWaitCursor()
	{ AfxGetApp()->BeginWaitCursor(); }
_AFXWIN_INLINE CWaitCursor::~CWaitCursor()
{
	AFX_BEGIN_DESTRUCTOR

	AfxGetApp()->EndWaitCursor();

	AFX_END_DESTRUCTOR
}
_AFXWIN_INLINE void CWaitCursor::Restore()
	{ AfxGetApp()->RestoreWaitCursor(); }

/////////////////////////////////////////////////////////////////////////////
// Obsolete and non-portable

#ifndef _WIN32_WCE // unsupported win32 api call to CloseWindow and OpenIcon
_AFXWIN_INLINE void CWnd::CloseWindow()
	{ ASSERT(::IsWindow(m_hWnd)); ::CloseWindow(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenIcon()
	{ ASSERT(::IsWindow(m_hWnd)); return ::OpenIcon(m_hWnd); }
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwinforms.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_WINFORMS_H__
#define __AFX_WINFORMS_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __cplusplus_cli
	#error MFC WinForms support requires /clr (doesn't support oldSyntax)
#endif

#ifndef _AFXDLL
	#error MFC WinForms support requires MFC dll version.
#endif

#pragma once

#using <mscorlib.dll>
#using <System.dll>
#using <System.Windows.Forms.dll>
#using <System.Drawing.dll>


#using <mfcmifc80.dll>

#ifdef BUILD_MFCM80
#define AFX_MFCM80_EXPORT __declspec(dllexport)
#else
#define AFX_MFCM80_EXPORT __declspec(dllimport)







#ifndef _UNICODE
	#ifdef _DEBUG
		#pragma comment(lib, "mfcm80d.lib")		
	#else		
		#pragma comment(lib, "mfcm80.lib")		
	#endif
#else
	#ifdef _DEBUG
		#pragma comment(lib, "mfcm80ud.lib")		
	#else
		#pragma comment(lib, "mfcm80u.lib")		
	#endif
#endif




#if defined(_M_IX86)
#pragma comment(linker, "/INCLUDE:_DummyIncludeMFC80MDll")
#elif defined(_M_IA64) || defined(_M_AMD64)
#pragma comment(linker, "/INCLUDE:DummyIncludeMFC80MDll")
#else
#pragma message("Unknown platform.  Make sure the linker includes DummyIncludeMFC80MDll")
#endif

#endif //BUILD_MFCM80

#include <vcclr.h>
#include <msclr\event.h>
#include <afxdisp.h>
#include <afxpriv.h>



namespace Microsoft {
	namespace VisualC {
		namespace MFC {



/////////////////////////////////////////////////////////////////////////////
// CWin32Window - Win32 HWND wrapper implementing IWin32Window. Used to pass 
// Parent HWNDs from MFC to WinForms.
//

public ref class CWin32Window : public System::Windows::Forms::IWin32Window 
{
	const HWND m_hWnd;
public:
	CWin32Window(HWND hWnd) : m_hWnd(hWnd){}
	property System::IntPtr Handle
	{
		virtual System::IntPtr get()
		{
			return static_cast<System::IntPtr>(m_hWnd);
		}		
	}	
};

/////////////////////////////////////////////////////////////////////////////
// CControlCreationInfoEx - Inits and Cleanup CControlCreationInfo struct 
//  GCHandle information.
//

class CControlCreationInfoEx : public CControlCreationInfo {
public:
	typedef System::Runtime::InteropServices::GCHandle GCHandle;
	CControlCreationInfoEx();
	
	void Init(System::Object^ p,HandleKind hk);
	
	~CControlCreationInfoEx();
	
};

////////////////////////////////////
// Notification from __gc Helper class.
__interface IHandleEvents {
	void OnHandleCreated(System::Object^ o, System::EventArgs^ e);
	void OnHandleDestroyed(System::Object^ o, System::EventArgs^ e);
};


public ref class CWinFormsEventsHelper
{
public:
	CWinFormsEventsHelper();
    

	property System::Windows::Forms::Control^ Control
	{
		System::Windows::Forms::Control^ get();
		void set(System::Windows::Forms::Control^ pControl);
	}
	
	void Advise(IHandleEvents* pSink);
	void Unadvise(IHandleEvents* pSink);
	

protected:
	void OnHandleCreated( System::Object^ o, System::EventArgs^ args);
	
	void OnHandleDestroyed( System::Object^ o, System::EventArgs^ args);
	
public:
	System::Windows::Forms::Control^ m_pControl;
	IHandleEvents* m_pSink;

};

/////////////////////////////////////////////////////////////////////////////
// CWinFormsControlSite - overrides COleControlSite when the ActiveX is a 
// WinForm control.

 
class CWinFormsControlSite : public COleControlSite,public IHandleEvents {
public:
	CWinFormsControlSite(COleControlContainer* pCtrlCont);
	~CWinFormsControlSite();
	
	virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg);
	
	virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
	
	void SetControlEnabled(bool bEnable);
	
	virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList);
	
	virtual DWORD GetStyle() const;	

	virtual HRESULT CreateOrLoad(const CControlCreationInfo& creationInfo);	
	virtual HRESULT CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize, UINT nID,
		CFile* pPersist, BOOL bStorage, BSTR bstrLicKey);

	void OnHandleCreatedHandler();

	virtual void OnHandleCreated( gcroot<System::Object^> , gcroot<System::EventArgs^> );
	virtual void OnHandleDestroyed( gcroot<System::Object^> , gcroot<System::EventArgs^> );

	virtual void OnHandleCreated(System::Object^, System::EventArgs^);	
	virtual void OnHandleDestroyed(System::Object^, System::EventArgs^);
	
	System::Windows::Forms::Control^ get_Control() const;
	
	gcroot<CWinFormsEventsHelper^> m_gcEventHelper;
};

/////////////////////////////////////////////////////////////////////////////
// CWinFormsControl
// Provides the basic functionality for AX hosting of WinForms Control
//
template<class TManagedControl>
class CWinFormsControl : public CWnd	
{
public:
	CWinFormsControl();

	inline TManagedControl^ GetControl() const;
	

	inline operator TManagedControl^() const;
	inline TManagedControl^ operator->() const;
	inline HWND GetControlHandle() const;

	inline BOOL CreateManagedControl(System::Type^ pType,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);

	inline BOOL CreateManagedControl(typename TManagedControl^ pControl,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);
	

	inline BOOL CreateManagedControl(DWORD dwStyle,const RECT& rect, CWnd* pParentWnd, int nID);
	
	////////////////////////////////////////////////////////////////
	//Purpose: Create a WinForms control and placing it on top
	// of a STATIC control, placed in Resource Editor as a place holder
	// for the .Net control.
	//Input: window styles, IDC_ of STATIC place holder, and Parent CWnd*
	//Return: TRUE if creation succeeded.
	////////////////////////////////////////////////////////////////
	inline BOOL CreateManagedControl(DWORD dwStyle,int nPlaceHolderID, CWnd* pParentWnd);	

	//Creates a control of managed type.
	inline BOOL InternalCreateManagedControl(const CControlCreationInfo& info,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);
};

////////////////////////////////////////////////////////////////////////
// CWinFormsView 
// Provides generic functionality for AX hosting of WinForms Control as an MFC View
// 

class CWinFormsView : public CView 
{
	DECLARE_DYNAMIC(CWinFormsView)

public:
	
	CWinFormsView(System::Type^ pManagedViewType);

	System::Windows::Forms::Control^ GetControl() const;
	
	operator System::Windows::Forms::Control^() const;
	

protected:
	virtual void OnInitialUpdate();
	
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);

	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
								CView* pDeactiveView);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
	
protected:
	virtual void OnDraw(CDC*) { };
	afx_msg void OnSize(UINT nType, int cx, int cy);
	
	gcroot<System::Type^> m_pManagedViewType;
private:
	CWinFormsControl<System::Windows::Forms::Control> m_control;
	gcroot<System::Object^> m_CmdSource;
		
	DECLARE_MESSAGE_MAP()

};

#define IDC_WINFRMCTRL_DIALOG 45002

//
// The WinForms Form wrapper
//
template <typename TManagedControl>
class CWinFormsDialog : public CDialog
{	
public:
	enum { IDD = AFX_IDD_EMPTYDIALOG };
public:		
	CWinFormsDialog(UINT nIDTemplate = IDD, CWnd* pParentWnd = NULL);
	virtual BOOL OnInitDialog();		
	//
	// The .Net Control  interface accessors
	//
	inline TManagedControl^ GetControl() const;
	inline operator TManagedControl^() const throw();
	inline TManagedControl^ operator->() const throw();
	inline HWND GetControlHandle() const throw();	
protected:
	CWinFormsControl<TManagedControl> m_control;
	afx_msg void OnSize(UINT nType, int cx, int cy);
	
private:
	DECLARE_MESSAGE_MAP()
	gcroot<TManagedControl^> m_pWFControl;
};

template <typename T>
void DDX_ManagedControl(CDataExchange* pDX, int nIDC,CWinFormsControl<T>& control);

		namespace Internal {
			using Microsoft::VisualC::MFC::CControlCreationInfoEx;
			using Microsoft::VisualC::MFC::CWin32Window;
			using Microsoft::VisualC::MFC::IHandleEvents;
			using Microsoft::VisualC::MFC::CWinFormsEventsHelper;
		}
		
	} //namespace MFC


	} //VisualC
} //Microsoft

using Microsoft::VisualC::MFC::CWinFormsView;
using Microsoft::VisualC::MFC::CWinFormsDialog;
using Microsoft::VisualC::MFC::CWinFormsControl;
using Microsoft::VisualC::MFC::CWinFormsControlSite;
using Microsoft::VisualC::MFC::DDX_ManagedControl;

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#endif
#include <afxwinforms.inl>



#endif // __AFX_WINFORMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwin.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
#ifndef RC_INVOKED
#define __AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
// Make sure 'afx.h' is included first

#ifndef __AFX_H__
	#include <afx.h>
#endif

// Note: WINDOWS.H already included from AFXV_W32.H

#ifndef _INC_SHELLAPI
	#include <shellapi.h>
#endif

#ifndef __AFXRES_H__
	#include <afxres.h>     // standard resource IDs
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>    // standard collections
#endif

#ifndef _OBJBASE_H_
	#include <objbase.h> //needed for commdlg.h (STDMETHOD)
#endif
#ifndef _INC_COMMDLG
	
	#include <commdlg.h>    // common dialog APIs
#endif

#ifndef _WIN32_WCE
// Avoid mapping GetFileTitle to GetFileTitle[A/W]
#ifdef GetFileTitle
#undef GetFileTitle
AFX_INLINE short APIENTRY GetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
#ifdef UNICODE
	{ return ::GetFileTitleW(lpszFile, lpszTitle, cbBuf); }
#else
	{ return ::GetFileTitleA(lpszFile, lpszTitle, cbBuf); }
#endif
#endif
#endif // _WIN32_WCE

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcomctl32.h>
#endif

#if (_WIN32_WINNT >= 0x501)
#include <uxtheme.h>
#include <tmschema.h>
#endif	// (_WIN32_WINNT >= 0x501)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifndef _AFX_NOFORCE_LIBS
#pragma comment(lib, "uuid.lib")
#endif

#ifdef _INC_WINDOWSX
// The following names from WINDOWSX.H collide with names in this header
#undef SubclassWindow
#undef CopyRgn
#endif

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
#include <htmlhelp.h>
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#pragma warning( push )
#pragma warning( disable: 4121 )


/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
	//CException
		//CSimpleException
			class CResourceException;// Win resource failure exception
			class CUserException;    // Message Box alert and stop operation

	class CGdiObject;            // CDC drawing tool
		class CPen;              // a pen / HPEN wrapper
		class CBrush;            // a brush / HBRUSH wrapper
		class CFont;             // a font / HFONT wrapper
		class CBitmap;           // a bitmap / HBITMAP wrapper
		class CPalette;          // a palette / HPALLETE wrapper
		class CRgn;              // a region / HRGN wrapper

	class CDC;                   // a Display Context / HDC wrapper
		class CClientDC;         // CDC for client of window
		class CWindowDC;         // CDC for entire window
		class CPaintDC;          // embeddable BeginPaint struct helper

	class CMenu;                 // a menu / HMENU wrapper

	class CCmdTarget;            // a target for user commands
		class CWnd;                 // a window / HWND wrapper
			class CDialog;          // a dialog

			// standard windows controls
			class CStatic;          // Static control
			class CButton;          // Button control
			class CListBox;         // ListBox control
				class CCheckListBox;// special listbox with checks
			class CComboBox;        // ComboBox control
			class CEdit;            // Edit control
			class CScrollBar;       // ScrollBar control

			// frame windows
			class CFrameWnd;        // standard SDI frame
#ifndef _WIN32_WCE
				class CMDIFrameWnd; // standard MDI frame
				class CMDIChildWnd; // standard MDI child
				class CMiniFrameWnd;// half-height caption frame wnd
#endif // !_WIN32_WCE

			// views on a document
			class CView;            // a view on a document
				class CScrollView;  // a scrolling view

		class CWinThread;           // thread base class
			class CWinApp;          // application base class

		class CDocTemplate;         // template for document creation
			class CSingleDocTemplate;// SDI support
#ifndef _WIN32_WCE
			class CMultiDocTemplate; // MDI support
#endif // !_WIN32_WCE

		class CDocument;            // main document abstraction


// Helper classes
class CCmdUI;           // Menu/button enabling
class CDataExchange;    // Data exchange and validation context
class CCommandLineInfo; // CommandLine parsing helper
class CDocManager;      // CDocTemplate manager object

struct COleControlSiteOrWnd; // ActiveX dialog control helper


class CControlCreationInfo; //Used in CWnd::CreateControl overloads.

class CVariantBoolConverter;
/////////////////////////////////////////////////////////////////////////////

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
enum AFX_HELP_TYPE
{
	afxWinHelp = 0,
	afxHTMLHelp = 1
};
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Type modifier for message handlers
#ifndef afx_msg
#define afx_msg         // intentional placeholder
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA


#ifndef __ATLTYPES_H__
#include <atltypes.h>
#endif

#ifdef _DEBUG
#ifndef _WIN32_WCE
// Diagnostic Output
CDumpContext& AFXAPI operator<<(CDumpContext& dc, SIZE size);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, POINT point);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const RECT& rect);
#endif // !_WIN32_WCE
#endif //_DEBUG

// Serialization
#ifndef _WIN32_WCE_NO_ARCHIVE_SUPPORT
CArchive& AFXAPI operator<<(CArchive& ar, SIZE size);
CArchive& AFXAPI operator<<(CArchive& ar, POINT point);
CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect);
CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size);
CArchive& AFXAPI operator>>(CArchive& ar, POINT& point);
CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect);
#endif // !_WIN32_WCE_NO_ARCHIVE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// Standard exceptions

class CResourceException : public CSimpleException    // resource failure
{
	DECLARE_DYNAMIC(CResourceException)
public:
	CResourceException();

// Implementation
public:
	explicit CResourceException(BOOL bAutoDelete);
	CResourceException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CResourceException();
};

class CUserException : public CSimpleException   // general user visible alert
{
	DECLARE_DYNAMIC(CUserException)
public:
	CUserException();

// Implementation
public:
	explicit CUserException(BOOL bAutoDelete);
	CUserException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CUserException();
};

void AFXAPI AfxThrowResourceException();
void AFXAPI AfxThrowUserException();

void AFXAPI AfxGetGrayBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF crBackground);
void AFXAPI AfxDrawGrayBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF crBackground);
#ifndef _WIN32_WCE
void AFXAPI AfxGetDitheredBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF cr1, COLORREF cr2);
void AFXAPI AfxDrawDitheredBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF cr1, COLORREF cr2);
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CGdiObject abstract class for CDC SelectObject

class CGdiObject : public CObject
{
	DECLARE_DYNCREATE(CGdiObject)
public:

// Attributes
	HGDIOBJ m_hObject;                  // must be first data member
	operator HGDIOBJ() const;
	HGDIOBJ GetSafeHandle() const;

	static CGdiObject* PASCAL FromHandle(HGDIOBJ hObject);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HGDIOBJ hObject);
	HGDIOBJ Detach();

// Constructors
	CGdiObject(); // must Create a derived class object
	BOOL DeleteObject();

// Operations
#pragma push_macro("GetObject")
#undef GetObject
	int _AFX_FUNCNAME(GetObject)(int nCount, LPVOID lpObject) const;
	int GetObject(int nCount, LPVOID lpObject) const;
#pragma pop_macro("GetObject")
	UINT GetObjectType() const;
	BOOL CreateStockObject(int nIndex);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL UnrealizeObject();
#endif // !_WIN32_WCE
	BOOL operator==(const CGdiObject& obj) const;
	BOOL operator!=(const CGdiObject& obj) const;

// Implementation
public:
	virtual ~CGdiObject();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CGdiObject subclasses (drawing tools)

class CPen : public CGdiObject
{
	DECLARE_DYNAMIC(CPen)

public:
	static CPen* PASCAL FromHandle(HPEN hPen);

// Constructors
	CPen();
	CPen(int nPenStyle, int nWidth, COLORREF crColor);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount = 0, const DWORD* lpStyle = NULL);
#endif // !_WIN32_WCE
	BOOL CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount = 0, const DWORD* lpStyle = NULL);
#endif // !_WIN32_WCE
	BOOL CreatePenIndirect(LPLOGPEN lpLogPen);

// Attributes
	operator HPEN() const;
	int GetLogPen(LOGPEN* pLogPen);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int GetExtLogPen(EXTLOGPEN* pLogPen);
#endif // !_WIN32_WCE

// Implementation
public:
	virtual ~CPen();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

class CBrush : public CGdiObject
{
	DECLARE_DYNAMIC(CBrush)

public:
	static CBrush* PASCAL FromHandle(HBRUSH hBrush);

// Constructors
	CBrush();
	CBrush(COLORREF crColor);             // CreateSolidBrush
#ifndef _WIN32_WCE // Unsupported Win32 API call
	CBrush(int nIndex, COLORREF crColor); // CreateHatchBrush
#endif // !_WIN32_WCE
	explicit CBrush(CBitmap* pBitmap);          // CreatePatternBrush

	BOOL CreateSolidBrush(COLORREF crColor);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateHatchBrush(int nIndex, COLORREF crColor);
#endif // !_WIN32_WCE
	BOOL CreateBrushIndirect(const LOGBRUSH* lpLogBrush);
	BOOL CreatePatternBrush(CBitmap* pBitmap);
	BOOL CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage);
	BOOL CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage);
	BOOL CreateSysColorBrush(int nIndex);

// Attributes
	operator HBRUSH() const;
	int GetLogBrush(LOGBRUSH* pLogBrush);

// Implementation
public:
	virtual ~CBrush();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

class CFont : public CGdiObject
{
	DECLARE_DYNAMIC(CFont)

public:
	static CFont* PASCAL FromHandle(HFONT hFont);

// Constructors
	CFont();
	BOOL CreateFontIndirect(const LOGFONT* lpLogFont);
	BOOL CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename);
	BOOL CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL);
	BOOL CreatePointFontIndirect(const LOGFONT* lpLogFont, CDC* pDC = NULL);

// Attributes
	operator HFONT() const;
	int GetLogFont(LOGFONT* pLogFont);

// Implementation
public:
	virtual ~CFont();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

class CBitmap : public CGdiObject
{
	DECLARE_DYNAMIC(CBitmap)

public:
	static CBitmap* PASCAL FromHandle(HBITMAP hBitmap);

// Constructors
	CBitmap();

	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL LoadOEMBitmap(UINT nIDBitmap); // for OBM_/OCR_/OIC_
#ifndef _AFX_NO_AFXCMN_SUPPORT
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0,
		LPCOLORMAP lpColorMap = NULL, int nMapSize = 0);
#endif // !_WIN32_WCE
#endif
	BOOL CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount,
			const void* lpBits);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateBitmapIndirect(LPBITMAP lpBitmap);
#endif // !_WIN32_WCE
	BOOL CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight);
#endif // !_WIN32_WCE

// Attributes
	operator HBITMAP() const;
	int GetBitmap(BITMAP* pBitMap);

// Operations
#ifndef _WIN32_WCE // Unsupported Win32 API call
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits);
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const;
#endif // !_WIN32_WCE
	CSize SetBitmapDimension(int nWidth, int nHeight);
	CSize GetBitmapDimension() const;

// Implementation
public:
	virtual ~CBitmap();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif

#ifdef _WIN32_WCE
// Attributes
protected:
	CSize m_sizeDimension;
#endif // _WIN32_WCE
};

class CPalette : public CGdiObject
{
	DECLARE_DYNAMIC(CPalette)

public:
	static CPalette* PASCAL FromHandle(HPALETTE hPalette);

// Constructors
	CPalette();
	BOOL CreatePalette(LPLOGPALETTE lpLogPalette);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateHalftonePalette(CDC* pDC);
#endif // !_WIN32_WCE

// Attributes
	operator HPALETTE() const;
	int GetEntryCount();
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors) const;
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors);

// Operations
#ifndef _WIN32_WCE // Unsupported Win32 API call
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors);
#endif // !_WIN32_WCE
	UINT GetNearestPaletteIndex(COLORREF crColor) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL ResizePalette(UINT nNumEntries);
#endif // !_WIN32_WCE

// Implementation
	virtual ~CPalette();
};

class CRgn : public CGdiObject
{
	DECLARE_DYNAMIC(CRgn)

public:
	static CRgn* PASCAL FromHandle(HRGN hRgn);
	operator HRGN() const;

// Constructors
	CRgn();
	BOOL CreateRectRgn(int x1, int y1, int x2, int y2);
	BOOL CreateRectRgnIndirect(LPCRECT lpRect);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateEllipticRgn(int x1, int y1, int x2, int y2);
	BOOL CreateEllipticRgnIndirect(LPCRECT lpRect);
	BOOL CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode);
	BOOL CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts,
			int nCount, int nPolyFillMode);
	BOOL CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3);
	BOOL CreateFromPath(CDC* pDC);
#endif // !_WIN32_WCE
	BOOL CreateFromData(const XFORM* lpXForm, int nCount,
		const RGNDATA* pRgnData);

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2);
	void SetRectRgn(LPCRECT lpRect);
	int CombineRgn(const CRgn* pRgn1, const CRgn* pRgn2, int nCombineMode);
	int CopyRgn(const CRgn* pRgnSrc);
	BOOL EqualRgn(const CRgn* pRgn) const;
	int OffsetRgn(int x, int y);
	int OffsetRgn(POINT point);
	int GetRgnBox(LPRECT lpRect) const;
	BOOL PtInRegion(int x, int y) const;
	BOOL PtInRegion(POINT point) const;
	BOOL RectInRegion(LPCRECT lpRect) const;
	int GetRegionData(LPRGNDATA lpRgnData, int nCount) const;

// Implementation
	virtual ~CRgn();
};

/////////////////////////////////////////////////////////////////////////////
// The device context

class CDC : public CObject
{
	DECLARE_DYNCREATE(CDC)
public:

// Attributes
	HDC m_hDC;          // The output DC (must be first data member)
	HDC m_hAttribDC;    // The Attribute DC
	operator HDC() const;
	HDC GetSafeHdc() const; // Always returns the Output DC
#ifndef _WIN32_WCE // Unsupported Win32 API call
	CWnd* GetWindow() const;
#endif // !_WIN32_WCE

	static CDC* PASCAL FromHandle(HDC hDC);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HDC hDC);   // Attach/Detach affects only the Output DC
	HDC Detach();

	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC
	virtual void ReleaseAttribDC();     // Release the Attribute DC
	virtual void ReleaseOutputDC();     // Release the Output DC

	BOOL IsPrinting() const;            // TRUE if being used for printing

	CPen* GetCurrentPen() const;
	CBrush* GetCurrentBrush() const;
	CPalette* GetCurrentPalette() const;
	CFont* GetCurrentFont() const;
	CBitmap* GetCurrentBitmap() const;

	// for bidi and mirrored localization
	DWORD GetLayout() const;
	DWORD SetLayout(DWORD dwLayout);

// Constructors
	CDC();
	BOOL CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const void* lpInitData);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL CreateIC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const void* lpInitData);
#endif // !_WIN32_WCE
	BOOL CreateCompatibleDC(CDC* pDC);

	BOOL DeleteDC();

// Device-Context Functions
	virtual int SaveDC();
	virtual BOOL RestoreDC(int nSavedDC);
	int GetDeviceCaps(int nIndex) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags);
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags);
	BOOL ResetDC(const DEVMODE* lpDevMode);
#endif // !_WIN32_WCE

// Drawing-Tool Functions
#ifndef _WIN32_WCE // Unsupported Win32 API call
	CPoint GetBrushOrg() const;
#endif // !_WIN32_WCE
	CPoint SetBrushOrg(int x, int y);
	CPoint SetBrushOrg(POINT point);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int EnumObjects(int nObjectType,
			int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData);
#endif // !_WIN32_WCE

// Type-safe selection helpers
public:
	virtual CGdiObject* SelectStockObject(int nIndex);
	CPen* SelectObject(CPen* pPen);
	CBrush* SelectObject(CBrush* pBrush);
	virtual CFont* SelectObject(CFont* pFont);
	CBitmap* SelectObject(CBitmap* pBitmap);
	int SelectObject(CRgn* pRgn);       // special return for regions
	CGdiObject* SelectObject(CGdiObject* pObject);
		// CGdiObject* provided so compiler doesn't use SelectObject(HGDIOBJ)

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const;
	CPalette* SelectPalette(CPalette* pPalette, BOOL bForceBackground);
	UINT RealizePalette();
#ifndef _WIN32_WCE // Unsupported Win32 API call
	void UpdateColors();
#endif // !_WIN32_WCE

// Drawing-Attribute Functions
	COLORREF GetBkColor() const;
	int GetBkMode() const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int GetPolyFillMode() const;
	int GetROP2() const;
	int GetStretchBltMode() const;
#endif // !_WIN32_WCE
	COLORREF GetTextColor() const;

	virtual COLORREF SetBkColor(COLORREF crColor);
	int SetBkMode(int nBkMode);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int SetPolyFillMode(int nPolyFillMode);
#endif // !_WIN32_WCE
	int SetROP2(int nDrawMode);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int SetStretchBltMode(int nStretchMode);
#endif // !_WIN32_WCE
	virtual COLORREF SetTextColor(COLORREF crColor);

#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);
#endif // !_WIN32_WCE

#if (_WIN32_WINNT >= 0x0500)

#ifndef _WIN32_WCE
	COLORREF GetDCBrushColor() const;
	COLORREF SetDCBrushColor(COLORREF crColor);

	COLORREF GetDCPenColor() const;
	COLORREF SetDCPenColor(COLORREF crColor);
#endif // !_WIN32_WCE

#endif

	// Graphics mode
	int SetGraphicsMode(int iMode);
	int GetGraphicsMode() const;

	// World transform
	BOOL SetWorldTransform(const XFORM* pXform);
	BOOL ModifyWorldTransform(const XFORM* pXform,DWORD iMode);
	BOOL GetWorldTransform(XFORM* pXform) const;

	// Mapping Functions
	int GetMapMode() const;
	CPoint GetViewportOrg() const;
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
	virtual int SetMapMode(int nMapMode);
	// Viewport Origin
	virtual CPoint SetViewportOrg(int x, int y);
			CPoint SetViewportOrg(POINT point);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

	// Viewport Extent
	CSize GetViewportExt() const;
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
	virtual CSize SetViewportExt(int cx, int cy);
			CSize SetViewportExt(SIZE size);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

	// Window Origin
	CPoint GetWindowOrg() const;
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
	CPoint SetWindowOrg(int x, int y);
	CPoint SetWindowOrg(POINT point);
	CPoint OffsetWindowOrg(int nWidth, int nHeight);
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

	// Window extent
	CSize GetWindowExt() const;
#ifndef _AFX_NO_GDITRANSFORM_SUPPORT
	virtual CSize SetWindowExt(int cx, int cy);
			CSize SetWindowExt(SIZE size);
	virtual CSize ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom);
#endif // !_AFX_NO_GDITRANSFORM_SUPPORT

// Coordinate Functions
	void DPtoLP(LPPOINT lpPoints, int nCount = 1) const;
	void DPtoLP(LPRECT lpRect) const;
	void DPtoLP(LPSIZE lpSize) const;
	void LPtoDP(LPPOINT lpPoints, int nCount = 1) const;
	void LPtoDP(LPRECT lpRect) const;
	void LPtoDP(LPSIZE lpSize) const;

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	void DPtoHIMETRIC(LPSIZE lpSize) const;
	void LPtoHIMETRIC(LPSIZE lpSize) const;
	void HIMETRICtoDP(LPSIZE lpSize) const;
	void HIMETRICtoLP(LPSIZE lpSize) const;

// Region Functions
	BOOL FillRgn(CRgn* pRgn, CBrush* pBrush);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight);
	BOOL InvertRgn(CRgn* pRgn);
	BOOL PaintRgn(CRgn* pRgn);
#endif // !_WIN32_WCE

// Clipping Functions
	virtual int GetClipBox(LPRECT lpRect) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	virtual BOOL PtVisible(int x, int y) const;
			BOOL PtVisible(POINT point) const;
#endif // !_WIN32_WCE
	virtual BOOL RectVisible(LPCRECT lpRect) const;
			int SelectClipRgn(CRgn* pRgn);
			int ExcludeClipRect(int x1, int y1, int x2, int y2);
			int ExcludeClipRect(LPCRECT lpRect);
#ifndef _WIN32_WCE // Unsupported Win32 API call
			int ExcludeUpdateRgn(CWnd* pWnd);
#endif // !_WIN32_WCE
			int IntersectClipRect(int x1, int y1, int x2, int y2);
			int IntersectClipRect(LPCRECT lpRect);
#ifndef _WIN32_WCE // Unsupported Win32 API call
			int OffsetClipRgn(int x, int y);
			int OffsetClipRgn(SIZE size);
#endif // !_WIN32_WCE
	int SelectClipRgn(CRgn* pRgn, int nMode);

// Line-Output Functions
	CPoint GetCurrentPosition() const;
	CPoint MoveTo(int x, int y);
	CPoint MoveTo(POINT point);
	BOOL LineTo(int x, int y);
	BOOL LineTo(POINT point);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
#endif // !_WIN32_WCE
	BOOL Polyline(const POINT* lpPoints, int nCount);
#ifdef _DEVICE_RESOLUTION_AWARE
	BOOL Polyline(const POINT* lpPoints, int nCount, int nStyle);
#endif // _DEVICE_RESOLUTION_AWARE
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle);
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
	int GetArcDirection() const;
	int SetArcDirection(int nArcDirection);

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount);
#endif // !_WIN32_WCE
	BOOL PolylineTo(const POINT* lpPoints, int nCount);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount);

	BOOL PolyBezier(const POINT* lpPoints, int nCount);
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount);
#endif // !_WIN32_WCE

// Simple Drawing Functions
	void FillRect(LPCRECT lpRect, CBrush* pBrush);
	void FrameRect(LPCRECT lpRect, CBrush* pBrush);
	void InvertRect(LPCRECT lpRect);
	BOOL DrawIcon(int x, int y, HICON hIcon);
	BOOL DrawIcon(POINT point, HICON hIcon);
#ifndef _WIN32_WCE
	BOOL DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags,
		HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags,
		CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
		HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
		CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, CBrush* pBrush = NULL);

// Ellipse and Polygon Functions
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3,
		int x4, int y4);
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
#endif // !_WIN32_WCE
	void DrawFocusRect(LPCRECT lpRect);
	BOOL Ellipse(int x1, int y1, int x2, int y2);
	BOOL Ellipse(LPCRECT lpRect);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
#endif // !_WIN32_WCE
	BOOL Polygon(const POINT* lpPoints, int nCount);	
	BOOL PolyPolygon(const POINT* lpPoints, const INT* lpPolyCounts, int nCount);
	BOOL Rectangle(int x1, int y1, int x2, int y2);
	BOOL Rectangle(LPCRECT lpRect);
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3);
	BOOL RoundRect(LPCRECT lpRect, POINT point);

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop);
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, DWORD dwRop);
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop);
	COLORREF GetPixel(int x, int y) const;
	COLORREF GetPixel(POINT point) const;
	COLORREF SetPixel(int x, int y, COLORREF crColor);
	COLORREF SetPixel(POINT point, COLORREF crColor);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL FloodFill(int x, int y, COLORREF crColor);
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType);
#endif // !_WIN32_WCE
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask,
		DWORD dwRop);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask);
	BOOL SetPixelV(int x, int y, COLORREF crColor);
	BOOL SetPixelV(POINT point, COLORREF crColor);
   BOOL GradientFill(TRIVERTEX* pVertices, ULONG nVertices, 
	  void* pMesh, ULONG nMeshElements, DWORD dwMode);
   BOOL TransparentBlt(int xDest, int yDest, int nDestWidth, int nDestHeight,
	  CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
	  UINT clrTransparent);
   BOOL AlphaBlend(int xDest, int yDest, int nDestWidth, int nDestHeight,
	  CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
	  BLENDFUNCTION blend);

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
			BOOL TextOut(int x, int y, const CString& str);
#endif // !_WIN32_WCE
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
			BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				const CString& str, LPINT lpDxWidths);
#ifndef _WIN32_WCE // Unsupported Win32 API call
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
			CSize TabbedTextOut(int x, int y, const CString& str,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
#endif // !_WIN32_WCE

#pragma push_macro("DrawText")
#ifndef _WIN32_WCE
#pragma push_macro("DrawTextEx")
#endif // !_WIN32_WCE
#undef DrawText
#ifndef _WIN32_WCE
#undef DrawTextEx
#endif // !_WIN32_WCE
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int _AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat);
#ifndef _WIN32_WCE
	virtual int _AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int _AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#endif // !_WIN32_WCE

			int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);

#ifndef _WIN32_WCE // Unsupported data structure LPDRAWTEXTPARAMS
			int DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#endif // !_WIN32_WCE
#pragma pop_macro("DrawText")
#ifndef _WIN32_WCE
#pragma pop_macro("DrawTextEx")
#endif // !_WIN32_WCE

	CSize GetTextExtent(LPCTSTR lpszString, int nCount) const;
	CSize GetTextExtent(const CString& str) const;
	CSize GetOutputTextExtent(LPCTSTR lpszString, int nCount) const;
	CSize GetOutputTextExtent(const CString& str) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	CSize GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetOutputTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	virtual BOOL GrayString(CBrush* pBrush,
		BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
			int nCount, int x, int y, int nWidth, int nHeight);
#endif // !_WIN32_WCE
	UINT GetTextAlign() const;
	UINT SetTextAlign(UINT nFlags);
	int GetTextFace(__in int nCount, __out_ecount_part_z(nCount, return + 1) LPTSTR lpszFacename) const;
	int GetTextFace(CString& rString) const;
#pragma push_macro("GetTextMetrics")
#undef GetTextMetrics
	BOOL _AFX_FUNCNAME(GetTextMetrics)(LPTEXTMETRIC lpMetrics) const;
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
#pragma pop_macro("GetTextMetrics")
	BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	int SetTextJustification(int nBreakExtra, int nBreakCount);
	int GetTextCharacterExtra() const;
	int SetTextCharacterExtra(int nCharExtra);

	DWORD GetCharacterPlacement(LPCTSTR lpString, int nCount, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const;
	DWORD GetCharacterPlacement(CString& str, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const;
#endif // !_WIN32_WCE

#if (_WIN32_WINNT >= 0x0500)

#ifndef _WIN32_WCE
	BOOL GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, __out_opt LPSIZE lpSize) const;
	BOOL GetTextExtentPointI(LPWORD pgiIn, int cgi, __out_opt LPSIZE lpSize) const;
#endif // !_WIN32_WCE

#endif



// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags);
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState);

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
		CRgn* pRgnUpdate, LPRECT lpRectUpdate);

// Font Functions
#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
	BOOL GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
	DWORD SetMapperFlags(DWORD dwFlag);
	CSize GetAspectRatioFilter() const;
#endif // !_WIN32_WCE

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const;
#ifndef _WIN32_WCE // Unsupported Win32 API call
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const;
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const;
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const;
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const;

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const;
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const;

	DWORD GetFontLanguageInfo() const;
#endif // !_WIN32_WCE

#if (_WIN32_WINNT >= 0x0500)

	BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const;
#ifndef _WIN32_WCE
	BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const;
#endif // !_WIN32_WCE

#endif

#ifndef _AFX_NO_PRINTING_SUPPORT
// Printer/Device Escape Functions
	virtual int Escape(__in int nEscape, __in int nCount,
		__in_bcount(nCount) LPCSTR lpszInData, __in LPVOID lpOutData);
	int Escape(__in int nEscape, __in int nInputSize, __in_bcount(nInputSize) LPCSTR lpszInputData,
		__in int nOutputSize, __out_bcount(nOutputSize) LPSTR lpszOutputData);
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData);

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName);  // old Win3.0 version
	int StartDoc(LPDOCINFO lpDocInfo);
	int StartPage();
	int EndPage();
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
	int AbortDoc();
	int EndDoc();
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE // Unsupported Win32 API call
// MetaFile Functions
	BOOL PlayMetaFile(HMETAFILE hMF);
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds);
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData);
		// can be used for enhanced metafiles only

// Path Functions
	BOOL AbortPath();
	BOOL BeginPath();
	BOOL CloseFigure();
	BOOL EndPath();
	BOOL FillPath();
	BOOL FlattenPath();
	BOOL StrokeAndFillPath();
	BOOL StrokePath();
	BOOL WidenPath();
	float GetMiterLimit() const;
	BOOL SetMiterLimit(float fMiterLimit);
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const;
	BOOL SelectClipPath(int nMode);
#endif // !_WIN32_WCE

// Misc Helper Functions
	static CBrush* PASCAL GetHalftoneBrush();
	void DrawDragRect(LPCRECT lpRect, SIZE size,
		LPCRECT lpRectLast, SIZE sizeLast,
		CBrush* pBrush = NULL, CBrush* pBrushLast = NULL);
	void FillSolidRect(LPCRECT lpRect, COLORREF clr);
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr);
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight);
	void Draw3dRect(int x, int y, int cx, int cy,
		COLORREF clrTopLeft, COLORREF clrBottomRight);

// Implementation
public:
	virtual ~CDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif

	// advanced use and implementation
	BOOL m_bPrinting;
	HGDIOBJ SelectObject(HGDIOBJ);      // do not use for regions

protected:
	// used for implementation of non-virtual SelectObject calls
	static CGdiObject* PASCAL SelectGdiObject(HDC hDC, HGDIOBJ h);
#ifdef _WIN32_WCE
	CPoint m_ptCurPos;
#endif // _WIN32_WCE
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
	DECLARE_DYNAMIC(CPaintDC)

// Constructors
public:
	explicit CPaintDC(CWnd* pWnd);   // BeginPaint

// Attributes
protected:
	HWND m_hWnd;
public:
	PAINTSTRUCT m_ps;       // actual paint struct!

// Implementation
public:
	virtual ~CPaintDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

class CClientDC : public CDC
{
	DECLARE_DYNAMIC(CClientDC)

// Constructors
public:
	explicit CClientDC(CWnd* pWnd);

// Attributes
protected:
	HWND m_hWnd;

// Implementation
public:
	virtual ~CClientDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

class CWindowDC : public CDC
{
	DECLARE_DYNAMIC(CWindowDC)

// Constructors
public:
	explicit CWindowDC(CWnd* pWnd);

// Attributes
protected:
	HWND m_hWnd;

// Implementation
public:
	virtual ~CWindowDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu : public CObject
{
	DECLARE_DYNCREATE(CMenu)
public:

// Constructors
	CMenu();

	BOOL CreateMenu();
	BOOL CreatePopupMenu();
	BOOL LoadMenu(LPCTSTR lpszResourceName);
	BOOL LoadMenu(UINT nIDResource);
#ifndef _WIN32_WCE // unsupported Win32 API call to LoadMenuIndirect
	BOOL LoadMenuIndirect(const void* lpMenuTemplate);
#endif // !_WIN32_WCE
	BOOL DestroyMenu();

// Attributes
	HMENU m_hMenu;          // must be first data member
	HMENU GetSafeHmenu() const;
	operator HMENU() const;

	static CMenu* PASCAL FromHandle(HMENU hMenu);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HMENU hMenu);
	HMENU Detach();

// CMenu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags);
	BOOL TrackPopupMenu(UINT nFlags, int x, int y,
						CWnd* pWnd, LPCRECT lpRect = 0);
	BOOL TrackPopupMenuEx(UINT fuFlags, int x, int y, CWnd* pWnd, LPTPMPARAMS lptpm);

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL SetMenuInfo(LPCMENUINFO lpcmi);
	BOOL GetMenuInfo(LPMENUINFO lpcmi) const;

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

	BOOL operator==(const CMenu& menu) const;
	BOOL operator!=(const CMenu& menu) const;

// CMenuItem Operations
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp);
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck);
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable);
	UINT GetMenuItemCount() const;
	UINT GetMenuItemID(int nPos) const;
	UINT GetMenuState(UINT nID, UINT nFlags) const;
	int GetMenuString(__in UINT nIDItem, __out_ecount_z(nMaxCount) LPTSTR lpString, __in int nMaxCount,
					__in UINT nFlags) const;
	int GetMenuString(UINT nIDItem, CString& rString, UINT nFlags) const;
	BOOL GetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
	BOOL SetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
	CMenu* GetSubMenu(int nPos) const;
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
					const CBitmap* pBmp);
#ifndef _WIN32_WCE // unsupported Win32 API call to InsertMenuItem
	BOOL InsertMenuItem(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
#endif // !_WIN32_WCE
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
					const CBitmap* pBmp);
	BOOL RemoveMenu(UINT nPosition, UINT nFlags);
#ifndef _WIN32_WCE // unsupported Win32 API call to SetMenuItemBitmaps
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
					const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked);
				const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked);
#endif // !_WIN32_WCE
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags);
#ifndef _WIN32_WCE // unsupported Win32 API call to G(S)MenuDefaultItem
	BOOL SetDefaultItem(UINT uItem, BOOL fByPos = FALSE);
	UINT GetDefaultItem(UINT gmdiFlags, BOOL fByPos = FALSE);
#endif // !_WIN32_WCE

// Context Help Functions
#ifndef _WIN32_WCE_NO_HELP_SUPPORT // Unsupported Win32 API call to G(S)etMenuContextHelpId
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId);
	DWORD GetMenuContextHelpId() const;
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Overridables (must override draw and measure for owner-draw menu items)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
public:
	virtual ~CMenu();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	static CMenu* PASCAL CMenu::FromHandlePermanent(HMENU hMenu);
};

/////////////////////////////////////////////////////////////////////////////
// Window message map handling

struct AFX_MSGMAP_ENTRY;       // declared below after CWnd

struct AFX_MSGMAP
{
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
	const AFX_MSGMAP_ENTRY* lpEntries;
};


#define DECLARE_MESSAGE_MAP() \
protected: \
	static const AFX_MSGMAP* PASCAL GetThisMessageMap(); \
	virtual const AFX_MSGMAP* GetMessageMap() const; \

#define BEGIN_MESSAGE_MAP_TEMPLATE(theClass, type_name, baseClass)			\
	PTM_WARNING_DISABLE														\
	template < typename type_name >											\
	const AFX_MSGMAP* theClass< type_name >::GetMessageMap() const			\
		{ return GetThisMessageMap(); }										\
	template < typename type_name >											\
	const AFX_MSGMAP* PASCAL theClass< type_name >::GetThisMessageMap()		\
	{																		\
		typedef theClass< type_name > ThisClass;							\
		typedef baseClass TheBaseClass;										\
		static const AFX_MSGMAP_ENTRY _messageEntries[] =					\
		{

#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_MSGMAP* theClass::GetMessageMap() const \
		{ return GetThisMessageMap(); } \
	const AFX_MSGMAP* PASCAL theClass::GetThisMessageMap() \
	{ \
		typedef theClass ThisClass;						   \
		typedef baseClass TheBaseClass;					   \
		static const AFX_MSGMAP_ENTRY _messageEntries[] =  \
		{

#define END_MESSAGE_MAP() \
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
	}; \
		static const AFX_MSGMAP messageMap = \
		{ &TheBaseClass::GetThisMessageMap, &_messageEntries[0] }; \
		return &messageMap; \
	}								  \
	PTM_WARNING_RESTORE


// Message map signature values and macros in separate header
#include <afxmsg_.h>

/////////////////////////////////////////////////////////////////////////////
// Dialog data exchange (DDX_) and validation (DDV_)

class COleControlSite;

// CDataExchange - for data exchange and validation
class CDataExchange
{
// Attributes
public:
	BOOL m_bSaveAndValidate;   // TRUE => save and validate data
	CWnd* m_pDlgWnd;           // container usually a dialog

// Operations (for implementors of DDX and DDV procs)
	HWND PrepareCtrl(int nIDC);     
	HWND PrepareEditCtrl(int nIDC); 
	void Fail();                    // will throw exception

	CDataExchange(CWnd* pDlgWnd, BOOL bSaveAndValidate);

#ifndef _AFX_NO_OCC_SUPPORT
	COleControlSite* PrepareOleCtrl(int nIDC); // for OLE controls in dialog
#endif

// Implementation
   UINT m_idLastControl;      // last control used (for validation)
	BOOL m_bEditLastControl;   // last control was an edit item
};

#include <afxdd_.h>     // standard DDX_ and DDV_ routines

/////////////////////////////////////////////////////////////////////////////
// OLE types

typedef LONG HRESULT;

struct IUnknown;
typedef IUnknown* LPUNKNOWN;

struct IDispatch;
typedef IDispatch* LPDISPATCH;

struct IConnectionPoint;
typedef IConnectionPoint* LPCONNECTIONPOINT;

struct IEnumOLEVERB;
typedef IEnumOLEVERB* LPENUMOLEVERB;

typedef struct _GUID GUID;
typedef GUID IID;
typedef GUID CLSID;
#ifndef _REFCLSID_DEFINED
#define REFCLSID const CLSID &
#endif

typedef long DISPID;
typedef unsigned short VARTYPE;
typedef long SCODE;

typedef WCHAR OLECHAR;
typedef OLECHAR* BSTR;

struct tagDISPPARAMS;
typedef tagDISPPARAMS DISPPARAMS;

struct tagVARIANT;
typedef tagVARIANT VARIANT;

struct ITypeInfo;
typedef ITypeInfo* LPTYPEINFO;

struct ITypeLib;
typedef ITypeLib* LPTYPELIB;

struct IAccessible;
struct IAccessibleProxy;
struct IAccessibleServer;
struct IEnumVARIANT;

struct tagEXCEPINFO;
typedef tagEXCEPINFO EXCEPINFO;


/////////////////////////////////////////////////////////////////////////////
// CCmdTarget

// private structures
struct AFX_CMDHANDLERINFO;  // info about where the command is handled
struct AFX_EVENT;           // info about an event
class CTypeLibCache;        // cache for OLE type libraries

/////////////////////////////////////////////////////////////////////////////
// OLE interface map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_INTERFACEMAP_ENTRY
{
	const void* piid;       // the interface id (IID) (NULL for aggregate)
	size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_INTERFACEMAP
{
#ifdef _AFXDLL
	const AFX_INTERFACEMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
	const AFX_INTERFACEMAP* pBaseMap;
#endif
	const AFX_INTERFACEMAP_ENTRY* pEntry; // map for this class
};


#ifdef _AFXDLL
#define DECLARE_INTERFACE_MAP() \
private: \
	static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
	static const AFX_INTERFACEMAP interfaceMap; \
	static const AFX_INTERFACEMAP* PASCAL GetThisInterfaceMap(); \
	virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#else
#define DECLARE_INTERFACE_MAP() \
private: \
	static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
	static const AFX_INTERFACEMAP interfaceMap; \
	virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#endif

/////////////////////////////////////////////////////////////////////////////
// OLE COM (Component Object Model) implementation infrastructure
//      - data driven QueryInterface
//      - standard implementation of aggregate AddRef and Release
// (see CCmdTarget in AFXWIN.H for more information)

#define METHOD_PROLOGUE(theClass, localClass) \
	theClass* pThis = \
		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
	AFX_MANAGE_STATE(pThis->m_pModuleState) \
	pThis; // avoid warning from compiler \

#define METHOD_PROLOGUE_(theClass, localClass) \
	theClass* pThis = \
		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
	pThis; // avoid warning from compiler \

#ifndef _AFX_NO_NESTED_DERIVATION
#define METHOD_PROLOGUE_EX(theClass, localClass) \
	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
	AFX_MANAGE_STATE(pThis->m_pModuleState) \
	pThis; // avoid warning from compiler \

#define METHOD_PROLOGUE_EX_(theClass, localClass) \
	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
	pThis; // avoid warning from compiler \

#else
#define METHOD_PROLOGUE_EX(theClass, localClass) \
	METHOD_PROLOGUE(theClass, localClass) \

#define METHOD_PROLOGUE_EX_(theClass, localClass) \
	METHOD_PROLOGUE_(theClass, localClass) \

#endif

// Provided only for compatibility with CDK 1.x
#define METHOD_MANAGE_STATE(theClass, localClass) \
	METHOD_PROLOGUE_EX(theClass, localClass) \

#define BEGIN_INTERFACE_PART(localClass, baseClass) \
	class X##localClass : public baseClass \
	{ \
	public: \
		STDMETHOD_(ULONG, AddRef)(); \
		STDMETHOD_(ULONG, Release)(); \
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj); \

#ifndef _AFX_NO_NESTED_DERIVATION
#define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
	class X##localClass : public baseClass \
	{ \
	public: \

#else
#define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
	BEGIN_INTERFACE_PART(localClass, baseClass) \

#endif

#ifndef _AFX_NO_NESTED_DERIVATION
#define INIT_INTERFACE_PART(theClass, localClass) \
		size_t m_nOffset; \
		INIT_INTERFACE_PART_DERIVE(theClass, localClass) \

#define INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
		X##localClass() \
			{ m_nOffset = offsetof(theClass, m_x##localClass); } \

#else
#define INIT_INTERFACE_PART(theClass, localClass)
#define INIT_INTERFACE_PART_DERIVE(theClass, localClass)

#endif

// Note: Inserts the rest of OLE functionality between these two macros,
//  depending upon the interface that is being implemented.  It is not
//  necessary to include AddRef, Release, and QueryInterface since those
//  member functions are declared by the macro.

#define END_INTERFACE_PART(localClass) \
	} m_x##localClass; \
	friend class X##localClass; \

struct CInterfacePlaceHolder
{
	DWORD_PTR m_vtbl;   // filled in with USE_INTERFACE_PART
	CInterfacePlaceHolder() { m_vtbl = 0; }
};

#define END_INTERFACE_PART_OPTIONAL(localClass) \
	}; \
	CInterfacePlaceHolder m_x##localClass; \
	friend class X##localClass; \

#ifdef _AFXDLL
#define END_INTERFACE_PART_STATIC END_INTERFACE_PART
#else
#define END_INTERFACE_PART_STATIC END_INTERFACE_PART
#endif

#define USE_INTERFACE_PART(localClass) \
	m_x##localClass.m_vtbl = *(DWORD_PTR*)&X##localClass(); \

#ifdef _AFXDLL
#define BEGIN_INTERFACE_MAP(theClass, theBase) \
	const AFX_INTERFACEMAP* PASCAL theClass::GetThisInterfaceMap() \
		{ return &theClass::interfaceMap; } \
	const AFX_INTERFACEMAP* theClass::GetInterfaceMap() const \
		{ return &theClass::interfaceMap; } \
	AFX_COMDAT const AFX_INTERFACEMAP theClass::interfaceMap = \
		{ &theBase::GetThisInterfaceMap, &theClass::_interfaceEntries[0], }; \
	AFX_COMDAT const AFX_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
	{ \

#else
#define BEGIN_INTERFACE_MAP(theClass, theBase) \
	const AFX_INTERFACEMAP* theClass::GetInterfaceMap() const \
		{ return &theClass::interfaceMap; } \
	AFX_COMDAT const AFX_INTERFACEMAP theClass::interfaceMap = \
		{ &theBase::interfaceMap, &theClass::_interfaceEntries[0], }; \
	AFX_COMDAT const AFX_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
	{ \

#endif

#define INTERFACE_PART(theClass, iid, localClass) \
		{ &iid, offsetof(theClass, m_x##localClass) }, \

#define INTERFACE_AGGREGATE(theClass, theAggr) \
		{ NULL, offsetof(theClass, theAggr) }, \

#define END_INTERFACE_MAP() \
		{ NULL, (size_t)-1 } \
	}; \


#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE dispatch map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_DISPMAP_ENTRY;

struct AFX_DISPMAP
{
#ifdef _AFXDLL
	const AFX_DISPMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_DISPMAP* pBaseMap;
#endif
	const AFX_DISPMAP_ENTRY* lpEntries;
	UINT* lpEntryCount;
	DWORD* lpStockPropMask;
};

#ifdef _AFXDLL
#define DECLARE_DISPATCH_MAP() \
private: \
	static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
	static UINT _dispatchEntryCount; \
	static DWORD _dwStockPropMask; \
protected: \
	static const AFX_DISPMAP dispatchMap; \
	static const AFX_DISPMAP* PASCAL GetThisDispatchMap(); \
	virtual const AFX_DISPMAP* GetDispatchMap() const; \

#else
#define DECLARE_DISPATCH_MAP() \
private: \
	static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
	static UINT _dispatchEntryCount; \
	static DWORD _dwStockPropMask; \
protected: \
	static const AFX_DISPMAP dispatchMap; \
	virtual const AFX_DISPMAP* GetDispatchMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE Document Object command target handling

#ifndef _AFX_NO_DOCOBJECT_SUPPORT

struct AFX_OLECMDMAP_ENTRY
{
   const GUID* pguid;   // id of the command group
   ULONG       cmdID;   // OLECMD ID
   UINT        nID;     // corresponding WM_COMMAND message ID
};

struct AFX_OLECMDMAP
{
#ifdef _AFXDLL
	const AFX_OLECMDMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_OLECMDMAP* pBaseMap;
#endif
	const AFX_OLECMDMAP_ENTRY* lpEntries;
};

#ifdef _AFXDLL
#define DECLARE_OLECMD_MAP() \
private: \
	static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
	static const AFX_OLECMDMAP commandMap; \
	static const AFX_OLECMDMAP* PASCAL GetThisCommandMap(); \
	virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#else
#define DECLARE_OLECMD_MAP() \
private: \
	static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
	static const AFX_OLECMDMAP commandMap; \
	virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#endif

#ifdef _AFXDLL
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
	const AFX_OLECMDMAP* PASCAL theClass::GetThisCommandMap() \
		{ return &theClass::commandMap; } \
	const AFX_OLECMDMAP* theClass::GetCommandMap() const \
		{ return &theClass::commandMap; } \
	AFX_COMDAT const AFX_OLECMDMAP theClass::commandMap = \
	{ &baseClass::GetThisCommandMap, &theClass::_commandEntries[0] }; \
	AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
	{ \

#else
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
	const AFX_OLECMDMAP* theClass::GetCommandMap() const \
		{ return &theClass::commandMap; } \
	AFX_COMDAT const AFX_OLECMDMAP theClass::commandMap = \
	{ &baseClass::commandMap, &theClass::_commandEntries[0] }; \
	AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
	{ \

#endif

#define END_OLECMD_MAP() \
		{NULL, 0, 0} \
	}; \

class COleCmdUI;

#endif //!_AFX_NO_DOCOBJECT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE event sink map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OCC_SUPPORT

struct AFX_EVENTSINKMAP_ENTRY;

struct AFX_EVENTSINKMAP
{
#ifdef _AFXDLL
	const AFX_EVENTSINKMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_EVENTSINKMAP* pBaseMap;
#endif
	const AFX_EVENTSINKMAP_ENTRY* lpEntries;
	UINT* lpEntryCount;
};

#ifdef _AFXDLL
#define DECLARE_EVENTSINK_MAP() \
private: \
	static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
	static UINT _eventsinkEntryCount; \
protected: \
	static const AFX_EVENTSINKMAP eventsinkMap; \
	static const AFX_EVENTSINKMAP* PASCAL GetThisEventSinkMap(); \
	virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#else
#define DECLARE_EVENTSINK_MAP() \
private: \
	static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
	static UINT _eventsinkEntryCount; \
protected: \
	static const AFX_EVENTSINKMAP eventsinkMap; \
	virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#endif

#endif //!_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE connection map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_CONNECTIONMAP_ENTRY
{
	const void* piid;   // the interface id (IID)
	size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_CONNECTIONMAP
{
#ifdef _AFXDLL
	const AFX_CONNECTIONMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
	const AFX_CONNECTIONMAP* pBaseMap;
#endif
	const AFX_CONNECTIONMAP_ENTRY* pEntry; // map for this class
};

#ifdef _AFXDLL
#define DECLARE_CONNECTION_MAP() \
private: \
	static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
	static const AFX_CONNECTIONMAP connectionMap; \
	static const AFX_CONNECTIONMAP* PASCAL GetThisConnectionMap(); \
	virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#else
#define DECLARE_CONNECTION_MAP() \
private: \
	static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
	static const AFX_CONNECTIONMAP connectionMap; \
	virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget proper

#ifndef _AFX_NO_OCC_SUPPORT
class COccManager;      // forward reference (see ..\src\occimpl.h)
#endif

class AFX_NOVTABLE CCmdTarget : public CObject
{
	DECLARE_DYNAMIC(CCmdTarget)
protected:

public:
// Constructors
	CCmdTarget();

// Attributes
	LPDISPATCH GetIDispatch(BOOL bAddRef);
		// retrieve IDispatch part of CCmdTarget
	static CCmdTarget* PASCAL FromIDispatch(LPDISPATCH lpDispatch);
		// map LPDISPATCH back to CCmdTarget* (inverse of GetIDispatch)
	BOOL IsResultExpected();
		// returns TRUE if automation function should return a value

// Operations
	void EnableAutomation();
		// call in constructor to wire up IDispatch
	void EnableConnections();
		// call in constructor to wire up IConnectionPointContainer

	void BeginWaitCursor();
	void EndWaitCursor();
	void RestoreWaitCursor();       // call after messagebox

#ifndef _AFX_NO_OLE_SUPPORT
	// dispatch OLE verbs through the message map
	BOOL EnumOleVerbs(LPENUMOLEVERB* ppenumOleVerb);
	BOOL DoOleVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
#endif

// Overridables
	// route and dispatch standard command message types
	//   (more sophisticated than OnCommand)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

#ifndef _AFX_NO_OLE_SUPPORT
	// called when last OLE reference is released
	virtual void OnFinalRelease();
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// called before dispatching to an automation handler function
	virtual BOOL IsInvokeAllowed(DISPID dispid);
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// support for OLE type libraries
	void EnableTypeLib();
	HRESULT GetTypeInfoOfGuid(LCID lcid, const GUID& guid,
		LPTYPEINFO* ppTypeInfo);
	virtual BOOL GetDispatchIID(IID* pIID);
	virtual UINT GetTypeInfoCount();
	virtual CTypeLibCache* GetTypeLibCache();
	virtual HRESULT GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib);
#endif

// Implementation
public:
	virtual ~CCmdTarget() = 0;
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif
#ifndef _AFX_NO_OLE_SUPPORT
	void GetNotSupported();
	void SetNotSupported();
#endif

protected:
	friend class CView;

	CView* GetRoutingView();
	CFrameWnd* GetRoutingFrame();
	static CView* PASCAL GetRoutingView_();
	static CFrameWnd* PASCAL GetRoutingFrame_();
	DECLARE_MESSAGE_MAP()       // base class - no {{ }} macros

#ifndef _AFX_NO_DOCOBJECT_SUPPORT
	DECLARE_OLECMD_MAP()
	friend class COleCmdUI;
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	DECLARE_DISPATCH_MAP()
	DECLARE_CONNECTION_MAP()
	DECLARE_INTERFACE_MAP()

#ifndef _AFX_NO_OCC_SUPPORT
	DECLARE_EVENTSINK_MAP()
#endif // !_AFX_NO_OCC_SUPPORT

	// OLE interface map implementation
public:
	// data used when CCmdTarget is made OLE aware
	long m_dwRef;
	LPUNKNOWN m_pOuterUnknown;  // external controlling unknown if != NULL
	DWORD_PTR m_xInnerUnknown;  // place-holder for inner controlling unknown

public:
	// advanced operations
	void EnableAggregation();       // call to enable aggregation
	void ExternalDisconnect();      // forcibly disconnect
	LPUNKNOWN GetControllingUnknown();
		// get controlling IUnknown for aggregate creation

	// these versions do not delegate to m_pOuterUnknown
	DWORD InternalQueryInterface(const void*, LPVOID* ppvObj);
	DWORD InternalAddRef();
	DWORD InternalRelease();
	// these versions delegate to m_pOuterUnknown
	DWORD ExternalQueryInterface(const void*, LPVOID* ppvObj);
	DWORD ExternalAddRef();
	DWORD ExternalRelease();

	// implementation helpers
	LPUNKNOWN GetInterface(const void*);
	LPUNKNOWN QueryAggregates(const void*);

	// advanced overrideables for implementation
	virtual BOOL OnCreateAggregates();
	virtual LPUNKNOWN GetInterfaceHook(const void*);

	// OLE automation implementation
protected:
	struct XDispatch
	{
		DWORD_PTR m_vtbl;   // place-holder for IDispatch vtable
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
#endif
	} m_xDispatch;
	BOOL m_bResultExpected;

	// member variable-based properties
	void GetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
		VARIANT* pvarResult, UINT* puArgErr);
	SCODE SetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
		DISPPARAMS* pDispParams, UINT* puArgErr);

	// DISPID to dispatch map lookup
	static UINT PASCAL GetEntryCount(const AFX_DISPMAP* pDispMap);
	const AFX_DISPMAP_ENTRY* PASCAL GetDispEntry(LONG memid);
	static LONG PASCAL MemberIDFromName(const AFX_DISPMAP* pDispMap, LPCTSTR lpszName);

	// helpers for member function calling implementation
	static UINT PASCAL GetStackSize(const BYTE* pbParams, VARTYPE vtResult);
#ifdef _SHADOW_DOUBLES
	SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
		void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
		UINT* puArgErr, VARIANT* rgTempVars, UINT nSizeArgs,CVariantBoolConverter* pTempStackArgs = NULL);
#else
	SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
		void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
		UINT* puArgErr, VARIANT* rgTempVars,CVariantBoolConverter* pTempStackArgs = NULL);
#endif
	SCODE CallMemberFunc(const AFX_DISPMAP_ENTRY* pEntry, WORD wFlags,
		VARIANT* pvarResult, DISPPARAMS* pDispParams, UINT* puArgErr);

	friend class COleDispatchImpl;

#ifndef _AFX_NO_OCC_SUPPORT
public:
	// OLE event sink implementation
	BOOL OnEvent(UINT idCtrl, AFX_EVENT* pEvent,
		AFX_CMDHANDLERINFO* pHandlerInfo);
protected:
	const AFX_EVENTSINKMAP_ENTRY* PASCAL GetEventSinkEntry(UINT idCtrl,
		AFX_EVENT* pEvent);
#endif // !_AFX_NO_OCC_SUPPORT

	// OLE connection implementation
	struct XConnPtContainer
	{
		DWORD_PTR m_vtbl;   // place-holder for IConnectionPointContainer vtable
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
#endif
	} m_xConnPtContainer;

	AFX_MODULE_STATE* m_pModuleState;
	friend class CInnerUnknown;
	friend UINT APIENTRY _AfxThreadEntry(void* pParam);

	virtual BOOL GetExtraConnectionPoints(CPtrArray* pConnPoints);
	virtual LPCONNECTIONPOINT GetConnectionHook(const IID& iid);

	friend class COleConnPtContainer;

#endif //!_AFX_NO_OLE_SUPPORT
};

class CCmdUI        // simple helper class
{
public:
// Attributes
	UINT m_nID;
	UINT m_nIndex;          // menu item or other index

	// if a menu item
	CMenu* m_pMenu;         // NULL if not a menu
	CMenu* m_pSubMenu;      // sub containing menu item
							// if a popup sub menu - ID is for first in popup

	// if from some other window
	CWnd* m_pOther;         // NULL if a menu or not a CWnd

// Operations to do in ON_UPDATE_COMMAND_UI
	virtual void Enable(BOOL bOn = TRUE);
	virtual void SetCheck(int nCheck = 1);   // 0, 1 or 2 (indeterminate)
	virtual void SetRadio(BOOL bOn = TRUE);
	virtual void SetText(LPCTSTR lpszText);

// Advanced operation
	void ContinueRouting();

// Implementation
	CCmdUI();
	BOOL m_bEnableChanged;
	BOOL m_bContinueRouting;
	UINT m_nIndexMax;       // last + 1 for iterating m_nIndex

	CMenu* m_pParentMenu;   // NULL if parent menu not easily determined
							//  (probably a secondary popup menu)

	BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
};

// special CCmdUI derived classes are used for other UI paradigms
//  like toolbar buttons and status indicators

// pointer to afx_msg member function
#ifndef AFX_MSG_CALL
#define AFX_MSG_CALL
#endif
typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);

enum AFX_DISPMAP_FLAGS
{
	afxDispCustom = 0,
	afxDispStock = 1
};

//IA64: AFX_DISPMAP_ENTRY could be ordered more efficiently to reduce size
// bloat from alignment
#pragma warning( disable: 4121 )
struct AFX_DISPMAP_ENTRY
{
	LPCTSTR lpszName;       // member/property name
	long lDispID;           // DISPID (may be DISPID_UNKNOWN)
	LPCSTR lpszParams;      // member parameter description
	WORD vt;                // return value type / or type of property
	AFX_PMSG pfn;           // normal member On<membercall> or, OnGet<property>
	AFX_PMSG pfnSet;        // special member for OnSet<property>
	size_t nPropOffset;     // property offset
	AFX_DISPMAP_FLAGS flags;// flags (e.g. stock/custom)
};
#pragma warning( default: 4121 )

struct AFX_EVENTSINKMAP_ENTRY
{
	AFX_DISPMAP_ENTRY dispEntry;
	UINT nCtrlIDFirst;
	UINT nCtrlIDLast;
};

// DSC Sink state/reason codes passed to MFC user event handlers
enum DSCSTATE
{
	dscNoState = 0,
	dscOKToDo,
	dscCancelled,
	dscSyncBefore,
	dscAboutToDo,
	dscFailedToDo,
	dscSyncAfter,
	dscDidEvent
};

enum DSCREASON
{
	dscNoReason = 0,
	dscClose,
	dscCommit,
	dscDelete,
	dscEdit,
	dscInsert,
	dscModify,
	dscMove
};

/////////////////////////////////////////////////////////////////////////////
// CWnd implementation

// structures (see afxext.h)
struct CCreateContext;      // context for creating things
#ifndef _AFX_NO_PRINTING_SUPPORT
struct CPrintInfo;          // print preview customization info
#endif // !_AFX_NO_PRINTING_SUPPORT

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT_PTR nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // routine to call (or special value)
};

/////////////////////////////////////////////////////////////////////////////
// CWnd - a Microsoft Windows application window

#ifndef _WIN32_WCE // OLE
class COleDropTarget;   // for more information see AFXOLE.H
#endif // !_WIN32_WCE
class COleControlContainer;
class COleControlSite;

// CWnd::m_nFlags (generic to CWnd)
#define WF_TOOLTIPS         0x0001  // window is enabled for tooltips
#define WF_TEMPHIDE         0x0002  // window is temporarily hidden
#define WF_STAYDISABLED     0x0004  // window should stay disabled
#define WF_MODALLOOP        0x0008  // currently in modal loop
#define WF_CONTINUEMODAL    0x0010  // modal loop should continue running
#define WF_OLECTLCONTAINER  0x0100  // some descendant is an OLE control
#define WF_TRACKINGTOOLTIPS 0x0400  // window is enabled for tracking tooltips

// CWnd::m_nFlags (specific to CFrameWnd)
#define WF_STAYACTIVE       0x0020  // look active even though not active
#define WF_NOPOPMSG         0x0040  // ignore WM_POPMESSAGESTRING calls
#define WF_MODALDISABLE     0x0080  // window is disabled
#define WF_KEEPMINIACTIVE   0x0200  // stay activate even though you are deactivated


#define WF_NOWIN32ISDIALOGMSG   0x0800
#define WF_ISWINFORMSVIEWWND    0x1000

// flags for CWnd::RunModalLoop
#define MLF_NOIDLEMSG       0x0001  // don't send WM_ENTERIDLE messages
#define MLF_NOKICKIDLE      0x0002  // don't send WM_KICKIDLE messages
#define MLF_SHOWONIDLE      0x0004  // show window if not visible at idle time

// extra MFC defined TTF_ flags for TOOLINFO::uFlags
#define TTF_NOTBUTTON       0x80000000L // no status help on buttondown
#define TTF_ALWAYSTIP       0x40000000L // always show the tip even if not active

class CWnd : public CCmdTarget
{
	DECLARE_DYNCREATE(CWnd)
protected:
	static const MSG* PASCAL GetCurrentMessage();

// Attributes
public:
	HWND m_hWnd;            // must be first data member
	operator HWND() const;
	BOOL operator==(const CWnd& wnd) const;
	BOOL operator!=(const CWnd& wnd) const;

	HWND GetSafeHwnd() const;
	DWORD GetStyle() const;
	DWORD GetExStyle() const;
	BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
	BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);

	CWnd* GetOwner() const;
	void SetOwner(CWnd* pOwnerWnd);

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL GetWindowInfo(PWINDOWINFO pwi) const;
	BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

// Constructors and other creation
	CWnd();

	static CWnd* PASCAL FromHandle(HWND hWnd);
	static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HWND hWndNew);
	HWND Detach();

	// subclassing/unsubclassing functions
	virtual void PreSubclassWindow();
	BOOL SubclassWindow(HWND hWnd);
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
	HWND UnsubclassWindow();

	// handling of RT_DLGINIT resource (extension to RT_DIALOG)
	BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
	BOOL ExecuteDlgInit(LPVOID lpResource);

public:
	// for child windows, views, panes etc
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);

	// advanced creation (allows access to extended styles)
	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		int x, int y, int nWidth, int nHeight,
		HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam = NULL);

	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		LPVOID lpParam = NULL);

#ifndef _AFX_NO_OCC_SUPPORT
	// for wrapping OLE controls
	BOOL CreateControl(REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
		BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);

	BOOL CreateControl(LPCTSTR pszClass, LPCTSTR pszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
		BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);

   // Another overload for creating controls that use default extents.
   BOOL CreateControl( REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
	  const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID,
	  CFile* pPersist = NULL, BOOL bStorage = FALSE, BSTR bstrLicKey = NULL );


   //Overload for special controls (WinForms), that require more than CLSID.
   BOOL CreateControl(const CControlCreationInfo& creationInfo, DWORD dwStyle,
	const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID);

	LPUNKNOWN GetControlUnknown();
	BOOL PaintWindowlessControls(CDC *pDC);
#endif

	virtual BOOL DestroyWindow();

	// special pre-creation and window rect adjustment hooks
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// Advanced: virtual AdjustWindowRect
	enum AdjustType { adjustBorder = 0, adjustOutside = 1 };
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

// Window tree access
	int GetDlgCtrlID() const;
	int SetDlgCtrlID(int nID);
		// get and set window ID, for child windows only
	CWnd* GetDlgItem(int nID) const;
		// get immediate child with given ID
	void GetDlgItem(int nID, HWND* phWnd) const;
		// as above, but returns HWND
	CWnd* GetDescendantWindow(int nID, BOOL bOnlyPerm = FALSE) const;
		// like GetDlgItem but recursive
	void SendMessageToDescendants(UINT message, WPARAM wParam = 0,
		LPARAM lParam = 0, BOOL bDeep = TRUE, BOOL bOnlyPerm = FALSE);
	CFrameWnd* GetParentFrame() const;
	CFrameWnd* EnsureParentFrame() const;
	CWnd* GetTopLevelParent() const;
	CWnd* EnsureTopLevelParent() const;
	CWnd* GetTopLevelOwner() const;
	CWnd* GetParentOwner() const;
	CFrameWnd* GetTopLevelFrame() const;
	static CWnd* PASCAL GetSafeOwner(CWnd* pParent = NULL, HWND* pWndTop = NULL);

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	CWnd* GetAncestor(UINT gaFlags) const;

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

// Message Functions
#pragma push_macro("SendMessage")
#undef SendMessage
	LRESULT _AFX_FUNCNAME(SendMessage)(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);
	LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);
#pragma pop_macro("SendMessage")
	BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);

	BOOL SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam);
	BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);

#ifndef _WIN32_WCE // Drag n' Drop, unsupported win32 api call to DragDetect
	BOOL DragDetect(POINT pt) const;
#endif // !_WIN32_WCE


// Message processing for modeless dialog-like windows
	BOOL IsDialogMessage(LPMSG lpMsg);

// Window Text Functions
	void SetWindowText(LPCTSTR lpszString);
	int GetWindowText(__out_ecount_part_z(nMaxCount, return + 1) LPTSTR lpszStringBuf, __in int nMaxCount) const;
	void GetWindowText(CString& rString) const;
	int GetWindowTextLength() const;
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE);
	CFont* GetFont() const;

#ifdef _WIN32_WCE
// Windows CE shell functions
	BOOL SHDoneButton(BOOL bShow);
	BOOL SHRecognizeGesture(CPoint point, BOOL bSendNotification = TRUE); 
#endif // WIN32_WCE

// CMenu Functions - non-Child windows only
#ifdef _WIN32_WCE
	HMENU m_hMenu;
#endif // _WIN32_WCE
	CMenu* GetMenu() const;
	BOOL SetMenu(CMenu* pMenu);
	void DrawMenuBar();
	CMenu* GetSystemMenu(BOOL bRevert) const;
#ifndef _WIN32_WCE // unsupported win32 api call to HiliteMenuItem
	BOOL HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite);
#endif // !_WIN32_WCE

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL GetMenuBarInfo(LONG idObject, LONG idItem, PMENUBARINFO pmbi) const;

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

// Window Size and Position Functions
	BOOL IsIconic() const;
#ifndef _WIN32_WCE // unsupported win32 api call to IsZoomed
	BOOL IsZoomed() const;
#endif // !_WIN32_WCE
	void MoveWindow(int x, int y, int nWidth, int nHeight,
				BOOL bRepaint = TRUE);
	void MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE);
	int SetWindowRgn(HRGN hRgn, BOOL bRedraw);
	int GetWindowRgn(HRGN hRgn) const;

	static AFX_DATA const CWnd wndTop; // SetWindowPos's pWndInsertAfter
	static AFX_DATA const CWnd wndBottom; // SetWindowPos's pWndInsertAfter
	static AFX_DATA const CWnd wndTopMost; // SetWindowPos pWndInsertAfter
	static AFX_DATA const CWnd wndNoTopMost; // SetWindowPos pWndInsertAfter

	BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
				int cx, int cy, UINT nFlags);
#ifndef _WIN32_WCE // unsupported win32 api call to ArrangeIconicWindows
	UINT ArrangeIconicWindows();
#endif // !_WIN32_WCE
	void BringWindowToTop();
	void GetWindowRect(LPRECT lpRect) const;
	void GetClientRect(LPRECT lpRect) const;

#ifndef _WIN32_WCE // Unsupported data structure WINDOWPLACEMENT
	BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
	BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);
#endif // !_WIN32_WCE

// Coordinate Mapping Functions
	void ClientToScreen(LPPOINT lpPoint) const;
	void ClientToScreen(LPRECT lpRect) const;
	void ScreenToClient(LPPOINT lpPoint) const;
	void ScreenToClient(LPRECT lpRect) const;
	void MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const;
	void MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const;

// Update/Painting Functions
	CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
	void EndPaint(LPPAINTSTRUCT lpPaint);
	CDC* GetDC();
	CDC* GetWindowDC();
	int ReleaseDC(CDC* pDC);
#ifndef _AFX_NO_PRINTING_SUPPORT
	void Print(CDC* pDC, DWORD dwFlags) const;
	void PrintClient(CDC* pDC, DWORD dwFlags) const;
#endif // !_AFX_NO_PRINTING_SUPPORT

	void UpdateWindow();
	void SetRedraw(BOOL bRedraw = TRUE);
	BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE);
	int GetUpdateRgn(CRgn* pRgn, BOOL bErase = FALSE);
	void Invalidate(BOOL bErase = TRUE);
	void InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE);
	void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
	void ValidateRect(LPCRECT lpRect);
	void ValidateRgn(CRgn* pRgn);
	BOOL ShowWindow(int nCmdShow);
	BOOL IsWindowVisible() const;
#ifndef _WIN32_WCE // unsupported win32 api call to ShowOwnedPopups
	void ShowOwnedPopups(BOOL bShow = TRUE);
#endif // !_WIN32_WCE

	CDC* GetDCEx(CRgn* prgnClip, DWORD flags);
#ifndef _WIN32_WCE // unsupported win32 api call to LockWindowUpdate
	BOOL LockWindowUpdate();
	void UnlockWindowUpdate();
#endif // !_WIN32_WCE
	BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL,
		CRgn* prgnUpdate = NULL,
#ifndef _WIN32_WCE
		UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
#else
		UINT flags = 0);
#endif // !_WIN32_WCE 
#ifndef _WIN32_WCE // undeclared identifier ESB_ENABLE_BOTH and unsupported win32 api call to EnableScrollBar, DrawAnimatedRects, and DrawCaption
	BOOL EnableScrollBar(int nSBFlags, UINT nArrowFlags = ESB_ENABLE_BOTH);

	BOOL DrawAnimatedRects(int idAni, CONST RECT *lprcFrom, CONST RECT *lprcTo);
	BOOL DrawCaption(CDC* pDC, LPCRECT lprc, UINT uFlags);
#endif // !_WIN32_WCE

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL AnimateWindow(DWORD dwTime, DWORD dwFlags);

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

#if(_WIN32_WINNT >= 0x0501)

#ifndef _AFX_NO_PRINTING_SUPPORT
	BOOL PrintWindow(CDC* pDC, UINT nFlags) const;
#endif // !_AFX_NO_PRINTING_SUPPORT

#endif	// _WIN32_WINNT >= 0x0501

// Layered Window

#if(_WIN32_WINNT >= 0x0500)

#ifndef _WIN32_WCE
	BOOL SetLayeredWindowAttributes(COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
	BOOL UpdateLayeredWindow(CDC* pDCDst, POINT *pptDst, SIZE *psize, 
		CDC* pDCSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);
#endif // !_WIN32_WCE

#endif	// _WIN32_WINNT >= 0x0500

#if(_WIN32_WINNT >= 0x0501)

	BOOL GetLayeredWindowAttributes(COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags) const;

#endif	// _WIN32_WINNT >= 0x0501


// Timer Functions
	UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse,
		void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD));
	BOOL KillTimer(UINT_PTR nIDEvent);

#ifndef _WIN32_WCE_NO_TOOLTIPS
// ToolTip Functions
	BOOL EnableToolTips(BOOL bEnable = TRUE);
	BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
	static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
	void FilterToolTipMessage(MSG* pMsg);

	// for command hit testing (used for automatic tooltips)
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
#endif // !_WIN32_WCE_NO_TOOLTIPS

// Window State Functions
	BOOL IsWindowEnabled() const;
	BOOL EnableWindow(BOOL bEnable = TRUE);

	// the active window applies only to top-level (frame windows)
	static CWnd* PASCAL GetActiveWindow();
	CWnd* SetActiveWindow();

	// the foreground window applies only to top-level windows (frame windows)
	BOOL SetForegroundWindow();
	static CWnd* PASCAL GetForegroundWindow();

	// capture and focus apply to all windows
	static CWnd* PASCAL GetCapture();
	CWnd* SetCapture();
	static CWnd* PASCAL GetFocus();
	CWnd* SetFocus();

	static CWnd* PASCAL GetDesktopWindow();

// Obsolete and non-portable APIs - not recommended for new code
#ifndef _WIN32_WCE // unsupported win32 api call to CloseWindow and OpenIcon
	void CloseWindow();
	BOOL OpenIcon();
#endif // !_WIN32_WCE

// Dialog-Box Item Functions
// (NOTE: Dialog-Box Items/Controls are not necessarily in dialog boxes!)
	void CheckDlgButton(int nIDButton, UINT nCheck);
	void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
					int nIDCheckButton);
	int GetCheckedRadioButton(int nIDFirstButton, int nIDLastButton);

#ifndef _WIN32_WCE // unsupported win32 api call to DlgDirList, DlgDirListComboBox, DlgDirSelectEx, DlgDirSelectComboBoxEx
	int DlgDirList(__inout_z LPTSTR lpPathSpec, __in int nIDListBox,
					__in int nIDStaticPath, __in UINT nFileType);
	int DlgDirListComboBox(__inout_z LPTSTR lpPathSpec, __in int nIDComboBox,
					__in int nIDStaticPath, __in UINT nFileType);
	AFX_DEPRECATED("CWnd::DlgDirSelect(lpszOut, nControlId) is no longer supported. Instead, use CWnd::DlgDirSelect(lpszOut, nSize, nControlId)")
		BOOL DlgDirSelect(__out_ecount_z(_MAX_PATH) LPTSTR lpString, __in int nIDListBox);
	BOOL DlgDirSelect(__out_ecount_z(nSize) LPTSTR lpString, __in int nSize, __in int nIDListBox);
	AFX_DEPRECATED("CWnd::DlgDirSelectComboBox(lpszOut, nControlId) is no longer supported. Instead, use CWnd::DlgDirSelectComboBox(lpszOut, nSize, nControlId)")
		BOOL DlgDirSelectComboBox(__out_ecount_z(_MAX_PATH) LPTSTR lpString, __in int nIDComboBox);
	BOOL DlgDirSelectComboBox(__out_ecount_z(nSize) LPTSTR lpString, __in int nSize, __in int nIDComboBox);
#endif // !_WIN32_WCE

	UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL,
					BOOL bSigned = TRUE) const;
	int GetDlgItemText(__in int nID, __out_ecount_part_z(nMaxCount, return + 1) LPTSTR lpStr, __in int nMaxCount) const;
	int GetDlgItemText(int nID, CString& rString) const;
	CWnd* GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
	COleControlSiteOrWnd* GetNextDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd = NULL) const;
	COleControlSiteOrWnd* GetPrevDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd = NULL) const;
	void RemoveRadioCheckFromGroup(const COleControlSiteOrWnd *pSiteOrWnd) const;
	CWnd* GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
	COleControlSiteOrWnd* GetNextDlgTabItem(COleControlSiteOrWnd *pCurSiteOrWnd, BOOL bPrevious) const;
	UINT IsDlgButtonChecked(int nIDButton) const;
	LRESULT SendDlgItemMessage(int nID, UINT message,
					WPARAM wParam = 0, LPARAM lParam = 0);
	void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE);
	void SetDlgItemText(int nID, LPCTSTR lpszString);
	POSITION FindSiteOrWnd(const COleControlSiteOrWnd *pSiteOrWnd) const;
	POSITION FindSiteOrWndWithFocus() const;

// Scrolling Functions
	int GetScrollPos(int nBar) const;
	void GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const;
	void ScrollWindow(int xAmount, int yAmount,
					LPCRECT lpRect = NULL,
					LPCRECT lpClipRect = NULL);
	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE);
	void SetScrollRange(int nBar, int nMinPos, int nMaxPos,
			BOOL bRedraw = TRUE);
	void ShowScrollBar(UINT nBar, BOOL bShow = TRUE);
	void EnableScrollBarCtrl(int nBar, BOOL bEnable = TRUE);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
			// return sibling scrollbar control (or NULL if none)

	int ScrollWindowEx(int dx, int dy,
				LPCRECT lpRectScroll, LPCRECT lpRectClip,
				CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags);
	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo,
		BOOL bRedraw = TRUE);
	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
	int GetScrollLimit(int nBar);

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL GetScrollBarInfo(LONG idObject, PSCROLLBARINFO psbi) const;

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

// Window Access Functions
	CWnd* ChildWindowFromPoint(POINT point) const;
#ifndef _WIN32_WCE // unsupported win32 api call to ChildWindowFromPointEx
	CWnd* ChildWindowFromPoint(POINT point, UINT nFlags) const;
#endif // !_WIN32_WCE
	static CWnd* PASCAL FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName);
#ifndef _WIN32_WCE // unsupported win32 api call to FindWindowEx
	static CWnd* FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow);
#endif // !_WIN32_WCE

	CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
	CWnd* GetTopWindow() const;

	CWnd* GetWindow(UINT nCmd) const;
	CWnd* GetLastActivePopup() const;

	BOOL IsChild(const CWnd* pWnd) const;
	CWnd* GetParent() const;
	CWnd* SetParent(CWnd* pWndNewParent);
	static CWnd* PASCAL WindowFromPoint(POINT point);

// Alert Functions
#ifndef _WIN32_WCE // unsupported win32 api call to FlashWindow
	BOOL FlashWindow(BOOL bInvert);
#endif // !_WIN32_WCE
#pragma push_macro("MessageBox")
#undef MessageBox
	int _AFX_FUNCNAME(MessageBox)(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
#pragma pop_macro("MessageBox")

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

	BOOL FlashWindowEx(DWORD dwFlags, UINT  uCount, DWORD dwTimeout);

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

// Clipboard Functions
#ifndef _WIN32_WCE // unsupported win32 api call to ChangeClipboardChain and SetClipboardViewer
	BOOL ChangeClipboardChain(HWND hWndNext);
	HWND SetClipboardViewer();
#endif // !_WIN32_WCE
	BOOL OpenClipboard();
	static CWnd* PASCAL GetClipboardOwner();
#ifndef _WIN32_WCE // unsupported win32 api call to GetClipboardViewer
	static CWnd* PASCAL GetClipboardViewer();
#endif // !_WIN32_WCE
	static CWnd* PASCAL GetOpenClipboardWindow();

// Caret Functions
	void CreateCaret(CBitmap* pBitmap);
	void CreateSolidCaret(int nWidth, int nHeight);
	void CreateGrayCaret(int nWidth, int nHeight);
	static CPoint PASCAL GetCaretPos();
	static void PASCAL SetCaretPos(POINT point);
	void HideCaret();
	void ShowCaret();

#ifndef _WIN32_WCE // Drag n' Drop, unsupported win32 api call to DragAcceptFiles
// Shell Interaction Functions
	void DragAcceptFiles(BOOL bAccept = TRUE);
#endif // !_WIN32_WCE

// Icon Functions
	HICON SetIcon(HICON hIcon, BOOL bBigIcon);
	HICON GetIcon(BOOL bBigIcon) const;

#ifndef _WIN32_WCE_NO_HELP_SUPPORT // unsupported win32 api call to SetWindowContextHelpId and GetWindowContextHelpId
// Context Help Functions
	BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
	DWORD GetWindowContextHelpId() const;
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Dialog Data support
public:
	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
			// data wnd must be same type as this

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
// Help Command Handlers
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX
	afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING
	virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual void WinHelpInternal(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Layout and other functions
public:
	enum RepositionFlags
		{ reposDefault = 0, reposQuery = 1, reposExtra = 2, reposNoPosLeftOver=0x8000 };
	void RepositionBars(UINT nIDFirst, UINT nIDLast, UINT nIDLeftOver,
		UINT nFlag = reposDefault, LPRECT lpRectParam = NULL,
		LPCRECT lpRectClient = NULL, BOOL bStretch = TRUE);

	// dialog support
	void UpdateDialogControls(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
	void CenterWindow(CWnd* pAlternateOwner = NULL);
	int RunModalLoop(DWORD dwFlags = 0);
	virtual BOOL ContinueModal();
	virtual void EndModalLoop(int nResult);

#ifndef _AFX_NO_OCC_SUPPORT
// OLE control wrapper functions
   COleControlSite* GetOleControlSite(UINT idControl) const;
	void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
	void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
#ifndef _WIN32_WCE // CDataSourceControl - _AFX_NO_DB_SUPPORT
	IUnknown* GetDSCCursor();
	void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
	void BindProperty(DISPID dwDispId, CWnd* pWndDSC);
#endif // !_WIN32_WCE
#endif // !_AFX_NO_OCC_SUPPORT

// Accessibility Support
#ifndef _WIN32_WCE // Accessibility and unsupported win32 api NotifyWinEvent
public :
	void EnableActiveAccessibility();
	void NotifyWinEvent(DWORD event, LONG idObjectType, LONG idObject);
#endif // !_WIN32_WCE

protected :
#ifndef _WIN32_WCE // Accessibility
	bool m_bEnableActiveAccessibility;
	IAccessible* m_pStdObject;
	typedef VOID (WINAPI *PFNNOTIFYWINEVENT)(DWORD, HWND, LONG, LONG);
	static PFNNOTIFYWINEVENT m_pfnNotifyWinEvent;
#endif // !_WIN32_WCE
	friend BOOL AFXAPI AfxWinInit(__in HINSTANCE hInstance, __in HINSTANCE hPrevInstance,
		__in_z LPTSTR lpCmdLine, __in int nCmdShow);

protected:
#ifndef _WIN32_WCE // Accessibility
	IAccessibleProxy* m_pProxy;
	afx_msg LRESULT OnGetObject(WPARAM, LPARAM);

#ifndef _AFX_NO_OLE_SUPPORT
	DECLARE_INTERFACE_MAP()
#endif

	class XAccessible //: public IAccessible
	{	
	public:
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
		XAccessible()
			{ m_nOffset = offsetof(CWnd, m_xAccessible); }
#endif
		virtual ULONG __stdcall AddRef(); 
		virtual ULONG __stdcall Release(); 
		virtual HRESULT __stdcall QueryInterface(REFIID iid, LPVOID* ppvObj); 
		virtual HRESULT __stdcall Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
		virtual HRESULT __stdcall GetIDsOfNames(REFIID, LPOLESTR *, UINT, LCID, DISPID *);
		virtual HRESULT __stdcall GetTypeInfoCount(unsigned int *);
		virtual HRESULT __stdcall GetTypeInfo(unsigned int, LCID, ITypeInfo**);
		virtual HRESULT __stdcall get_accParent(IDispatch **ppdispParent);
		virtual HRESULT __stdcall get_accChildCount(long *pcountChildren);
		virtual HRESULT __stdcall get_accChild(VARIANT varChild, IDispatch **ppdispChild);
		virtual HRESULT __stdcall get_accName(VARIANT varChild, BSTR *pszName);
		virtual HRESULT __stdcall get_accValue(VARIANT varChild, BSTR *pszValue);
		virtual HRESULT __stdcall get_accDescription(VARIANT varChild, BSTR *pszDescription);
		virtual HRESULT __stdcall get_accRole(VARIANT varChild, VARIANT *pvarRole);
		virtual HRESULT __stdcall get_accState(VARIANT varChild, VARIANT *pvarState);
		virtual HRESULT __stdcall get_accHelp(VARIANT varChild, BSTR *pszHelp);
		virtual HRESULT __stdcall get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
		virtual HRESULT __stdcall get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
		virtual HRESULT __stdcall get_accFocus(VARIANT *pvarChild);
		virtual HRESULT __stdcall get_accSelection(VARIANT *pvarChildren);
		virtual HRESULT __stdcall get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
		virtual HRESULT __stdcall accSelect(long flagsSelect, VARIANT varChild);
		virtual HRESULT __stdcall accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
		virtual HRESULT __stdcall accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
		virtual HRESULT __stdcall accHitTest(long xLeft, long yTop, VARIANT *pvarChild);
		virtual HRESULT __stdcall accDoDefaultAction(VARIANT varChild);
		virtual HRESULT __stdcall put_accName(VARIANT varChild, BSTR szName);
		virtual HRESULT __stdcall put_accValue(VARIANT varChild, BSTR szValue);
	} m_xAccessible;
	friend class XAccessible; 

	class XAccessibleServer //: public IAccessibleServer
	{	
	public:
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
		XAccessibleServer()
			{ m_nOffset = offsetof(CWnd, m_xAccessibleServer); }
#endif		
		virtual ULONG __stdcall AddRef(); 
		virtual ULONG __stdcall Release(); 
		virtual HRESULT __stdcall QueryInterface(REFIID iid, LPVOID* ppvObj); 
		virtual HRESULT __stdcall SetProxy(IAccessibleProxy *pProxy);
		virtual HRESULT __stdcall GetHWND(HWND *phWnd);
		virtual HRESULT __stdcall GetEnumVariant(IEnumVARIANT **ppEnumVariant);
	} m_xAccessibleServer;
	friend class XAccessibleServer;

public :
	virtual HRESULT EnsureStdObj();

	virtual HRESULT get_accParent(IDispatch **ppdispParent);
	virtual HRESULT get_accChildCount(long *pcountChildren);
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);
	virtual HRESULT get_accValue(VARIANT varChild, BSTR *pszValue);
	virtual HRESULT get_accDescription(VARIANT varChild, BSTR *pszDescription);
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accHelp(VARIANT varChild, BSTR *pszHelp);
	virtual HRESULT get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
	virtual HRESULT get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
	virtual HRESULT get_accFocus(VARIANT *pvarChild);
	virtual HRESULT get_accSelection(VARIANT *pvarChildren);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
	virtual HRESULT accSelect(long flagsSelect, VARIANT varChild);
	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
	virtual HRESULT accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild);
	virtual HRESULT accDoDefaultAction(VARIANT varChild);
	//Obsolete
	virtual HRESULT put_accName(VARIANT varChild, BSTR szName);
	//Obsolete
	virtual HRESULT put_accValue(VARIANT varChild, BSTR szValue);
	virtual HRESULT SetProxy(IAccessibleProxy *pProxy);
	virtual HRESULT CreateAccessibleProxy(WPARAM wParam, LPARAM lParam, LRESULT *pResult);

	// Helpers for windows that contain windowless controls
#else
public:
#endif // !_WIN32_WCE
	long GetWindowLessChildCount();
	long GetWindowedChildCount();
#ifndef _WIN32_WCE // Accessibility
	long GetAccessibleChildCount();
	HRESULT GetAccessibleChild(VARIANT varChild, IDispatch** ppdispChild);
	HRESULT GetAccessibleName(VARIANT varChild, BSTR* pszName);
	HRESULT GetAccessibilityLocation(VARIANT varChild, long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight);
	HRESULT GetAccessibilityHitTest(long xLeft, long yTop, VARIANT *pvarChild);
#endif // !_WIN32_WCE


// Window-Management message handler member functions
protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
#ifndef _WIN32_WCE
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
#endif // !_WIN32_WCE
	afx_msg LRESULT OnActivateTopLevel(WPARAM, LPARAM);
	afx_msg void OnCancelMode();
#ifndef _WIN32_WCE
	afx_msg void OnChildActivate();
#endif // !_WIN32_WCE
	afx_msg void OnClose();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint pos);
	afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
#ifdef _WIN32_WCE
public:	
	// need to simulate OnCreate calls for dialog boxes, so we have to get public access to this method
#endif // !_WIN32_WCE
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

#ifdef _WIN32_WCE
protected:
#endif // !_WIN32_WCE
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnDestroy();
	afx_msg void OnEnable(BOOL bEnable);
#ifndef _WIN32_WCE
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
#endif // !_WIN32_WCE
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
#ifndef _WIN32_WCE
	afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
#endif // !_WIN32_WCE
#ifndef _WIN32_WCE_NO_HELP_SUPPORT // unsupported data structure HELPINFO
	afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
#ifndef _WIN32_WCE
	afx_msg void OnIconEraseBkgnd(CDC* pDC);
#endif // !_WIN32_WCE
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
#ifndef _WIN32_WCE
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
#endif // !_WIN32_WCE
	afx_msg void OnMove(int x, int y);
	afx_msg void OnPaint();
#ifndef _WIN32_WCE
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
#endif // !_WIN32_WCE
	afx_msg HCURSOR OnQueryDragIcon();
#ifndef _WIN32_WCE
	afx_msg BOOL OnQueryEndSession();
#endif // !_WIN32_WCE
	afx_msg BOOL OnQueryNewPalette();
#ifndef _WIN32_WCE
	afx_msg BOOL OnQueryOpen();
#endif // !_WIN32_WCE
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSize(UINT nType, int cx, int cy);
#ifndef _WIN32_WCE
	afx_msg void OnTCard(UINT idAction, DWORD dwActionData);
	afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
#endif // !_WIN32_WCE
	afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);

	afx_msg void OnChangeUIState(UINT nAction, UINT nUIElement);
	afx_msg void OnUpdateUIState(UINT nAction, UINT nUIElement);
	afx_msg UINT OnQueryUIState();

#ifndef _WIN32_WCE
// Nonclient-Area message handler member functions
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
#endif // !_WIN32_WCE
	afx_msg void OnNcDestroy();
#ifndef _WIN32_WCE
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcPaint();
	afx_msg void OnNcRButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
#endif // !_WIN32_WCE

// System message handler member functions
#ifndef _WIN32_WCE
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
#endif // !_WIN32_WCE
	afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSysDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
#ifndef _WIN32_WCE
	afx_msg void OnCompacting(UINT nCpuTime);
#endif // !_WIN32_WCE
#ifndef _AFX_NO_PRINTING_SUPPORT
	afx_msg void OnDevModeChange(__in_z LPTSTR lpDeviceName);
#endif // !_AFX_NO_PRINTING_SUPPORT
	afx_msg void OnFontChange();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
#ifndef _AFX_NO_PRINTING_SUPPORT
	afx_msg void OnSpoolerStatus(UINT nStatus, UINT nJobs);
#endif // !_AFX_NO_PRINTING_SUPPORT
	afx_msg void OnSysColorChange();
#ifndef _WIN32_WCE
	afx_msg void OnTimeChange();
#endif // !_WIN32_WCE
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnWinIniChange(LPCTSTR lpszSection);

// Input message handler member functions
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
#ifndef _WIN32_WCE
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
#endif // !_WIN32_WCE
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg LRESULT OnRegisteredMouseWheel(WPARAM wParam, LPARAM lParam);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnTimer(UINT_PTR nIDEvent);

// Initialization message handler member functions
#ifndef _WIN32_WCE
	afx_msg void OnInitMenu(CMenu* pMenu);
#endif // !_WIN32_WCE
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);

// Clipboard message handler member functions
#ifndef _WIN32_WCE
	afx_msg void OnAskCbFormatName(__in UINT nMaxCount, __out_ecount_z(nMaxCount) LPTSTR lpszString);
	afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
#endif // !_WIN32_WCE
	afx_msg void OnDestroyClipboard();
#ifndef _WIN32_WCE
	afx_msg void OnDrawClipboard();
	afx_msg void OnHScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
	afx_msg void OnPaintClipboard(CWnd* pClipAppWnd, HGLOBAL hPaintStruct);
#endif // !_WIN32_WCE
	afx_msg void OnRenderAllFormats();
	afx_msg void OnRenderFormat(UINT nFormat);
	afx_msg void OnSizeClipboard(CWnd* pClipAppWnd, HGLOBAL hRect);
#ifndef _WIN32_WCE
	afx_msg void OnVScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
#endif // !_WIN32_WCE

// Control message handler member functions
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);

#ifndef _WIN32_WCE
// MDI message handler member functions
	afx_msg void OnMDIActivate(BOOL bActivate,
		CWnd* pActivateWnd, CWnd* pDeactivateWnd);
#endif // !_WIN32_WCE

// Menu loop notification messages
	afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
	afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);

// Win4 messages
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
#ifndef _WIN32_WCE
	afx_msg void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg void OnSizing(UINT nSide, LPRECT lpRect);
	afx_msg void OnMoving(UINT nSide, LPRECT lpRect);
#endif // !_WIN32_WCE
	afx_msg void OnCaptureChanged(CWnd* pWnd);
	afx_msg BOOL OnDeviceChange(UINT nEventType, DWORD_PTR dwData);

// Overridables and other helpers (for implementation of derived classes)
protected:
	// for deriving from a standard control
	virtual WNDPROC* GetSuperWndProcAddr();

	// for dialog data exchange and validation
	virtual void DoDataExchange(CDataExchange* pDX);

public:
	// for modality
	virtual void BeginModalState();
	virtual void EndModalState();

	// for translating Windows messages in main message pump
	virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifndef _AFX_NO_OCC_SUPPORT
	// for ambient properties exposed to contained OLE controls
	virtual BOOL OnAmbientProperty(COleControlSite* pSite, DISPID dispid,
		VARIANT* pvar);
#endif

protected:
	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	// for handling default processing
	LRESULT Default();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// for custom cleanup after WM_NCDESTROY
	virtual void PostNcDestroy();

	// for notifications from parent
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
		// return TRUE if parent should not process this message
	BOOL ReflectChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	static BOOL PASCAL ReflectLastMsg(HWND hWndChild, LRESULT* pResult = NULL);

// Implementation
public:
	virtual ~CWnd();
	virtual BOOL CheckAutoCenter();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	static BOOL PASCAL GrayCtlColor(HDC hDC, HWND hWnd, UINT nCtlColor,
		HBRUSH hbrGray, COLORREF clrText);

	// helper routines for implementation
#ifndef _WIN32_WCE // Docking n' Floating
	BOOL HandleFloatingSysCommand(UINT nID, LPARAM lParam);
#endif // !_WIN32_WCE
	BOOL IsTopParentActive() const;
#ifndef _WIN32_WCE // Docking n' Floating
	void ActivateTopParent();
#endif // !_WIN32_WCE
	static BOOL PASCAL WalkPreTranslateTree(HWND hWndStop, MSG* pMsg);
	static CWnd* PASCAL GetDescendantWindow(HWND hWnd, int nID,
		BOOL bOnlyPerm);
	static void PASCAL SendMessageToDescendants(HWND hWnd, UINT message,
		WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm);
	virtual BOOL IsFrameWnd() const; // IsKindOf(RUNTIME_CLASS(CFrameWnd)))
	virtual void OnFinalRelease();
	BOOL PreTranslateInput(LPMSG lpMsg);
	static BOOL PASCAL ModifyStyle(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
		UINT nFlags);
	static BOOL PASCAL ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
		UINT nFlags);
#ifndef _WIN32_WCE_NO_TOOLTIPS
	static void PASCAL _FilterToolTipMessage(MSG* pMsg, CWnd* pWnd);
	BOOL _EnableToolTips(BOOL bEnable, UINT nFlag);
#endif // !_WIN32_WCE_NO_TOOLTIPS
	static HWND PASCAL GetSafeOwner_(HWND hWnd, HWND* pWndTop);
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	void PrepareForHelp();
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

	COleControlContainer* GetControlContainer();

public:
	HWND m_hWndOwner;   // implementation of SetOwner and GetOwner
	UINT m_nFlags;      // see WF_ flags above

protected:
	WNDPROC m_pfnSuper; // for subclassing of controls
#ifndef _WIN32_WCE // CDragListBox
	static const UINT m_nMsgDragList;
#endif // !_WIN32_WCE
	int m_nModalResult; // for return values from CWnd::RunModalLoop

#ifndef _WIN32_WCE // OLE
	COleDropTarget* m_pDropTarget;  // for automatic cleanup of drop target
	friend class COleDropTarget;
#endif // !_WIN32_WCE
	friend class CFrameWnd;

	// for creating dialogs and dialog-like windows
	BOOL CreateDlg(LPCTSTR lpszTemplateName, CWnd* pParentWnd);
	BOOL CreateDlgIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
		HINSTANCE hInst);

#ifndef _AFX_NO_OCC_SUPPORT
	COleControlContainer* m_pCtrlCont;  // for containing OLE controls
	COleControlSite* m_pCtrlSite;       // for wrapping an OLE control
	friend class COccManager;
	friend class COleControlSite;
	friend class COleControlContainer;
	BOOL InitControlContainer(BOOL bCreateFromResource=FALSE);
   virtual BOOL CreateControlContainer(COleControlContainer** ppContainer);
   virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
	  COleControlSite** ppSite, UINT nID, REFCLSID clsid);
	virtual BOOL SetOccDialogInfo(struct _AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
	void AttachControlSite(CHandleMap* pMap);
public:
	void AttachControlSite(CWnd* pWndParent, UINT nIDC = 0);
	COleControlSite* GetControlSite() const
	{
		return m_pCtrlSite;
	}
#endif

protected:
	// implementation of message dispatch/hooking
	friend LRESULT CALLBACK _AfxSendMsgHook(int, WPARAM, LPARAM);
	friend void AFXAPI _AfxStandardSubclass(HWND);
	friend LRESULT CALLBACK _AfxCbtFilterHook(int, WPARAM, LPARAM);
#ifdef _WIN32_WCE
	friend LRESULT CALLBACK DefWindowProcEx(HWND, UINT, WPARAM, LPARAM);
#endif // _WIN32_WCE
	friend LRESULT AFXAPI AfxCallWndProc(CWnd*, HWND, UINT, WPARAM, LPARAM);

	// standard message implementation
	afx_msg LRESULT OnNTCtlColor(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDisplayChange(WPARAM, LPARAM);
#ifndef _WIN32_WCE // CDragListBox
	afx_msg LRESULT OnDragList(WPARAM, LPARAM);
#endif // !_WIN32_WCE

	//{{AFX_MSG(CWnd)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CWnd(HWND hWnd);    // just for special initialization
#ifdef _WIN32_WCE
	BOOL m_bShowDoneButton;
#endif // _WIN32_WCE
};

// helpers for registering your own WNDCLASSes
LPCTSTR AFXAPI AfxRegisterWndClass(UINT nClassStyle,
	HCURSOR hCursor = 0, HBRUSH hbrBackground = 0, HICON hIcon = 0);

BOOL AFXAPI AfxRegisterClass(WNDCLASS* lpWndClass);

#ifndef _AFX_NO_RICHEDIT_SUPPORT
// helper to initialize rich edit 1.0 control
BOOL AFXAPI AfxInitRichEdit();
// helper to initialize rich edit 2.0 control
BOOL AFXAPI AfxInitRichEdit2();
#endif // !_AFX_NO_RICHEDIT_SUPPORT

// Implementation
LRESULT CALLBACK AfxWndProc(HWND, UINT, WPARAM, LPARAM);

WNDPROC AFXAPI AfxGetAfxWndProc();
#define AfxWndProc (*AfxGetAfxWndProc())

typedef void (AFX_MSG_CALL CWnd::*AFX_PMSGW)(void);
	// like 'AFX_PMSG' but for CWnd derived classes only

typedef void (AFX_MSG_CALL CWinThread::*AFX_PMSGT)(void);
	// like 'AFX_PMSG' but for CWinThread-derived classes only

/////////////////////////////////////////////////////////////////////////////
// CDialog - a modal or modeless dialog
class CDialog : public CWnd
{
	DECLARE_DYNAMIC(CDialog)

	// Modeless construct
public:
	CDialog();

	virtual BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	virtual BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
		void* lpDialogInit = NULL);
	virtual BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

	// Modal construct
public:
	explicit CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	explicit CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
#ifdef _DEVICE_RESOLUTION_AWARE
	explicit CDialog(UINT nIDTemplate, UINT nIDWideTemplate, CWnd* pParentWnd = NULL);
#endif // _DEVICE_RESOLUTION_AWARE
	BOOL InitModalIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
		void* lpDialogInit = NULL);
	BOOL InitModalIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

// Attributes
public:
	void MapDialogRect(LPRECT lpRect) const;
	void SetHelpID(UINT nIDR);

// Operations
public:
	// modal processing
	virtual INT_PTR DoModal();

	// support for passing on tab control - use 'PostMessage' if needed
	void NextDlgCtrl() const;
	void PrevDlgCtrl() const;
	void GotoDlgCtrl(CWnd* pWndCtrl);

	// default button access
	void SetDefID(UINT nID);
	DWORD GetDefID() const;

	// termination
	void EndDialog(int nResult);

// Overridables (special message map entries)
	virtual BOOL OnInitDialog();
	virtual void OnSetFont(CFont* pFont);
protected:
	virtual void OnOK();
	virtual void OnCancel();

// Implementation
public:
	virtual ~CDialog();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL CheckAutoCenter();

#ifdef _WIN32_WCE
	BOOL m_bFullScreen;
private:
	SHACTIVATEINFO m_SHActivateInfo;
	void SHInitDialog();
#endif // _WIN32_WCE 

protected:
	UINT m_nIDHelp;                 // Help ID (0 for none, see HID_BASE_RESOURCE)

	// parameters for 'DoModal'
	LPCTSTR m_lpszTemplateName;     // name or MAKEINTRESOURCE
#ifdef _WIN32_WCE
	LPCTSTR m_lpszWideTemplateName; // name or MAKEINTRESOURCE
#endif // _WIN32_WCE
	HGLOBAL m_hDialogTemplate;      // indirect (m_lpDialogTemplate == NULL)
	LPCDLGTEMPLATE m_lpDialogTemplate;  // indirect if (m_lpszTemplateName == NULL)
	void* m_lpDialogInit;           // DLGINIT resource data
	CWnd* m_pParentWnd;             // parent/owner window
	HWND m_hWndTop;                 // top level parent window (may be disabled)

#ifndef _AFX_NO_OCC_SUPPORT
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
#endif
	virtual void PreInitDialog();

	// implementation helpers
	HWND PreModal();
	void PostModal();

	BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
		void* lpDialogInit, HINSTANCE hInst);
	BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd,
		HINSTANCE hInst);

protected:
	//{{AFX_MSG(CDialog)
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg LRESULT HandleSetFont(WPARAM, LPARAM);
#ifdef _WIN32_WCE
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
#endif // _WIN32_WCE
#ifdef _DEVICE_RESOLUTION_AWARE
	afx_msg void OnSize(UINT nType, int cx, int cy);
#endif // _DEVICE_RESOLUTION_AWARE
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// all CModalDialog functionality is now in CDialog
#define CModalDialog    CDialog

/////////////////////////////////////////////////////////////////////////////
// Standard Windows controls

class CStatic : public CWnd
{
	DECLARE_DYNAMIC(CStatic)

// Constructors
public:
	CStatic();
	virtual BOOL Create(LPCTSTR lpszText, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID = 0xffff);

// Operations
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
	HICON SetIcon(HICON hIcon);
	HICON GetIcon() const;

	HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile);
	HENHMETAFILE GetEnhMetaFile() const;
#endif // !_WIN32_WCE
	HBITMAP SetBitmap(HBITMAP hBitmap);
	HBITMAP GetBitmap() const;
	HCURSOR SetCursor(HCURSOR hCursor);
	HCURSOR GetCursor();

// Overridables (for owner draw only)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CStatic();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CButton : public CWnd
{
	DECLARE_DYNAMIC(CButton)

// Constructors
public:
	CButton();
	virtual BOOL Create(LPCTSTR lpszCaption, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	UINT GetState() const;
	void SetState(BOOL bHighlight);
	int GetCheck() const;
	void SetCheck(int nCheck);
	UINT GetButtonStyle() const;
	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE);

#ifndef _WIN32_WCE
	HICON SetIcon(HICON hIcon);
	HICON GetIcon() const;
	HBITMAP SetBitmap(HBITMAP hBitmap);
	HBITMAP GetBitmap() const;
	HCURSOR SetCursor(HCURSOR hCursor);
	HCURSOR GetCursor();
#endif // !_WIN32_WCE

#if (_WIN32_WINNT >= 0x501)
	BOOL GetIdealSize(SIZE* psize);
	BOOL SetImageList(PBUTTON_IMAGELIST pbuttonImagelist);
	BOOL GetImageList(PBUTTON_IMAGELIST pbuttonImagelist);
	BOOL SetTextMargin(RECT* pmargin);
	BOOL GetTextMargin(RECT* pmargin);
#endif  // (_WIN32_WINNT >= 0x501)

// Overridables (for owner draw only)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CButton();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CListBox : public CWnd
{
	DECLARE_DYNAMIC(CListBox)

// Constructors
public:
	CListBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes

	// for entire listbox
	int GetCount() const;
	int GetHorizontalExtent() const;
	void SetHorizontalExtent(int cxExtent);
	int GetTopIndex() const;
	int SetTopIndex(int nIndex);
	LCID GetLocale() const;
	LCID SetLocale(LCID nNewLocale);
	int InitStorage(int nItems, UINT nBytes);
	UINT ItemFromPoint(CPoint pt, BOOL& bOutside) const;

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	DWORD GetListBoxInfo() const;
#endif	// WINVER >= 0x0500 && !_WIN32_WCE

	// for single-selection listboxes
	int GetCurSel() const;
	int SetCurSel(int nSelect);

	// for multiple-selection listboxes
	int GetSel(int nIndex) const;           // also works for single-selection
	int SetSel(int nIndex, BOOL bSelect = TRUE);
	int GetSelCount() const;
	int GetSelItems(int nMaxItems, LPINT rgIndex) const;
	void SetAnchorIndex(int nIndex);
	int GetAnchorIndex() const;

	// for listbox items
	DWORD_PTR GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD_PTR dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetItemRect(int nIndex, LPRECT lpRect) const;
	int GetText(__in int nIndex, __out_z LPTSTR lpszBuffer) const;
	void GetText(int nIndex, CString& rString) const;
	int GetTextLen(int nIndex) const;

	// Settable only attributes
	void SetColumnWidth(int cxWidth);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
	int GetCaretIndex() const;
	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE);

// Operations
	// manipulating listbox items
	int AddString(LPCTSTR lpszItem);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCTSTR lpszItem);
	void ResetContent();
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
	int Dir(UINT attr, LPCTSTR lpszWildCard);
#endif // !_WIN32_WCE

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszItem) const;
	int SelectString(int nStartAfter, LPCTSTR lpszItem);
	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem);

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
	virtual int VKeyToItem(UINT nKey, UINT nIndex);
	virtual int CharToItem(UINT nKey, UINT nIndex);

// Implementation
public:
	virtual ~CListBox();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

#ifndef _WIN32_WCE // Controls
class CCheckListBox : public CListBox
{
	DECLARE_DYNAMIC(CCheckListBox)

// Constructors
public:
	CCheckListBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	void SetCheckStyle(UINT nStyle);
	UINT GetCheckStyle();
	void SetCheck(int nIndex, int nCheck);
	int GetCheck(int nIndex);
	void Enable(int nIndex, BOOL bEnabled = TRUE);
	BOOL IsEnabled(int nIndex);

	virtual CRect OnGetCheckPosition(CRect rectItem, CRect rectCheckBox);

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
protected:
	void PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void PreMeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	int PreCompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	void PreDeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
	bool PreDrawItemThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem);
	void PreDrawItemNonThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem);
	void PreDrawItemHelper(LPDRAWITEMSTRUCT lpDrawItemStruct);	

	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

   void SetSelectionCheck( int nCheck );

// Active Accessibility
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
	virtual HRESULT accDoDefaultAction(VARIANT varChild);

#ifdef _DEBUG
	virtual void PreSubclassWindow();
#endif

	int CalcMinimumItemHeight();
	void InvalidateCheck(int nIndex);
	void InvalidateItem(int nIndex);
	int CheckFromPoint(CPoint point, BOOL& bInCheck);

	int m_cyText;
	UINT m_nStyle;

	// Message map functions
protected:
	//{{AFX_MSG(CCheckListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBAddString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBFindString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBFindStringExact(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBGetItemData(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBInsertString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSelectString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSetItemData(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSetItemHeight(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif // !_WIN32_WCE

class CComboBox : public CWnd
{
	DECLARE_DYNAMIC(CComboBox)

// Constructors
public:
	CComboBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	// for entire combo box
	int GetCount() const;
	int GetCurSel() const;
	int SetCurSel(int nSelect);
	LCID GetLocale() const;
	LCID SetLocale(LCID nNewLocale);
// Win4
	int GetTopIndex() const;
	int SetTopIndex(int nIndex);
	int InitStorage(int nItems, UINT nBytes);
	void SetHorizontalExtent(UINT nExtent);
	UINT GetHorizontalExtent() const;
	int SetDroppedWidth(UINT nWidth);
	int GetDroppedWidth() const;

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
	BOOL GetComboBoxInfo(PCOMBOBOXINFO pcbi) const;
#endif	// WINVER >= 0x0500 && !_WIN32_WCE

	// for edit control
	DWORD GetEditSel() const;
	BOOL LimitText(int nMaxChars);
	BOOL SetEditSel(int nStartChar, int nEndChar);

	// for combobox item
	DWORD_PTR GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD_PTR dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetLBText(__in int nIndex, __out_z LPTSTR lpszText) const;
	void GetLBText(int nIndex, CString& rString) const;
	int GetLBTextLen(int nIndex) const;

	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
	int SetExtendedUI(BOOL bExtended = TRUE);
	BOOL GetExtendedUI() const;
	void GetDroppedControlRect(LPRECT lprect) const;
	BOOL GetDroppedState() const;

// Operations
	// for drop-down combo boxes
	void ShowDropDown(BOOL bShowIt = TRUE);

	// manipulating listbox items
	int AddString(LPCTSTR lpszString);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCTSTR lpszString);
	void ResetContent();
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
	int Dir(UINT attr, LPCTSTR lpszWildCard);
#endif // !_WIN32_WCE

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszString) const;
	int SelectString(int nStartAfter, LPCTSTR lpszString);

	// Clipboard operations
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
	virtual ~CComboBox();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
#ifdef _WIN32_WCE
	// Message map functions
protected:
	//{{AFX_MSG(CComboBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
#endif // _WIN32_WCE
};

// NOTE: This class must remain a binary-compatible subset
// of CEditView. Do not add data members or virtual functions
// directly to this class.
class CEdit : public CWnd
{
	// DECLARE_DYNAMIC virtual OK - CWnd already has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CEdit)

// Constructors
public:
	CEdit();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	DWORD GetSel() const;
	void GetSel(int& nStartChar, int& nEndChar) const;
#ifndef _WIN32_WCE // Unsupported data structure/message/macro
	HLOCAL GetHandle() const;
	void SetHandle(HLOCAL hBuffer);
#endif // !_WIN32_WCE
	void SetMargins(UINT nLeft, UINT nRight);
	DWORD GetMargins() const;
	void SetLimitText(UINT nMax);
	UINT GetLimitText() const;
	CPoint PosFromChar(UINT nChar) const;
	int CharFromPos(CPoint pt) const;

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	// NOTE: may not return null character
	int GetLine(__in int nIndex, __out LPTSTR lpszBuffer) const;
	// NOTE: may not return null character
	int GetLine(__in int nIndex, __out_ecount_part(nMaxLength, return) LPTSTR lpszBuffer, __in int nMaxLength) const;

#if (_WIN32_WINNT >= 0x501)
	BOOL SetCueBanner(LPCWSTR lpcwText);
	BOOL GetCueBanner(__out_ecount_z(cchText) LPWSTR lpwText, __in int cchText);
#endif  // (_WIN32_WINNT >= 0x501)

// Operations
	void EmptyUndoBuffer();
	BOOL FmtLines(BOOL bAddEOL);

	void LimitText(int nChars = 0);
	int LineFromChar(int nIndex = -1) const;
	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
	void SetPasswordChar(TCHAR ch);
	void SetRect(LPCRECT lpRect);
	void SetRectNP(LPCRECT lpRect);
	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;
	TCHAR GetPasswordChar() const;

// Implementation
public:
	// virtual OK here - ~CWnd already virtual
	virtual ~CEdit();
};

class CScrollBar : public CWnd
{
	DECLARE_DYNAMIC(CScrollBar)

// Constructors
public:
	CScrollBar();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	int GetScrollPos() const;
	int SetScrollPos(int nPos, BOOL bRedraw = TRUE);
	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE);
	void ShowScrollBar(BOOL bShow = TRUE);

#ifndef _WIN32_WCE // Unsupported Win32 API call
	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);
#endif // !_WIN32_WCE

	BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);
	BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
	int GetScrollLimit();

#if(_WIN32_WINNT >= 0x0501)
	BOOL GetScrollBarInfo(PSCROLLBARINFO pScrollInfo) const;
#endif	// _WIN32_WINNT >= 0x0501

// Implementation
public:
	virtual ~CScrollBar();
};

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd - base class for SDI and other frame windows

// Frame window styles
#define FWS_ADDTOTITLE  0x00008000L // modify title based on content
#define FWS_PREFIXTITLE 0x00004000L // show document name before app name
#define FWS_SNAPTOBARS  0x00002000L // snap size to size of contained bars

#ifndef _AFX_NO_PRINTING_SUPPORT
struct CPrintPreviewState;  // forward reference (see afxext.h)
#endif // !_AFX_NO_PRINTING_SUPPORT
class CControlBar;          // forward reference (see afxext.h)
class CReBar;               // forward reference (see afxext.h)

class CDockBar;             // forward reference (see afxpriv.h)
class CMiniDockFrameWnd;    // forward reference (see afxpriv.h)
class CDockState;           // forward reference (see afxpriv.h)

class COleFrameHook;        // forward reference (see ..\src\oleimpl2.h)

#ifdef _WIN32_WCE_DOCLIST_SUPPORT
#include <doclist.h>
#endif // _WIN32_WCE_DOCLIST_SUPPORT

class CFrameWnd : public CWnd
{
	DECLARE_DYNCREATE(CFrameWnd)

// Constructors
public:
	static AFX_DATA const CRect rectDefault;
	CFrameWnd();

	BOOL LoadAccelTable(LPCTSTR lpszResourceName);
	virtual BOOL Create(LPCTSTR lpszClassName,
				LPCTSTR lpszWindowName,
				DWORD dwStyle = WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CWnd* pParentWnd = NULL,        // != NULL for popups
				LPCTSTR lpszMenuName = NULL,
				DWORD dwExStyle = 0,
				CCreateContext* pContext = NULL);

	// dynamic creation - load frame and associated resources
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

#ifdef _WIN32_WCE
	HWND m_hCommandBar;
#endif // WIN32_WCE

	// special helper for view creation
	CWnd* CreateView(CCreateContext* pContext, UINT nID = AFX_IDW_PANE_FIRST);

// Attributes
	virtual CDocument* GetActiveDocument();

	// Active child view maintenance
	CView* GetActiveView() const;           // active view or NULL
	void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
		// active view or NULL, bNotify == FALSE if focus should not be set

	// Active frame (for frames within frames -- MDI)
	virtual CFrameWnd* GetActiveFrame();

	// For customizing the default messages on the status bar
	virtual void GetMessageString(UINT nID, CString& rMessage) const;

	BOOL m_bAutoMenuEnable;
		// TRUE => menu items without handlers will be disabled

	BOOL IsTracking() const;

// Operations
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void ActivateFrame(int nCmdShow = -1);
	void InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible);
	void SetTitle(LPCTSTR lpszTitle);
	CString GetTitle() const;

	// to set text of standard status bar
	void SetMessageText(LPCTSTR lpszText);
	void SetMessageText(UINT nID);

#ifndef _WIN32_WCE // Docking
	// control bar docking
	void EnableDocking(DWORD dwDockStyle);
	void DockControlBar(CControlBar* pBar, UINT nDockBarID = 0,
		LPCRECT lpRect = NULL);
	void FloatControlBar(CControlBar* pBar, CPoint point,
		DWORD dwStyle = CBRS_ALIGN_TOP);
#endif // !_WIN32_WCE
	CControlBar* GetControlBar(UINT nID);

	// frame window based modality
	virtual void BeginModalState();
	virtual void EndModalState();
	BOOL InModalState() const;
	void ShowOwnedWindows(BOOL bShow);

	// saving and loading control bar state
#ifndef _WIN32_WCE
	void LoadBarState(LPCTSTR lpszProfileName);
	void SaveBarState(LPCTSTR lpszProfileName) const;
#endif // !_WIN32_WCE
	void ShowControlBar(CControlBar* pBar, BOOL bShow, BOOL bDelay);

#ifndef _WIN32_WCE // Docking
	void SetDockState(const CDockState& state);
	void GetDockState(CDockState& state) const;
#endif // !_WIN32_WCE

// Overridables
#ifndef _AFX_NO_PRINTING_SUPPORT 
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
#endif // !AFX_NO_PRINTING_SUPPORT

	virtual CWnd* GetMessageBar();

	// border space negotiation
	enum BorderCmd
		{ borderGet = 1, borderRequest = 2, borderSet = 3 };
	virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

// Command Handlers
public:
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	afx_msg void OnContextHelp();   // for Shift+F1 help
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnBarCheck(UINT nID);

// Implementation
public:
	virtual ~CFrameWnd();
	int m_nWindow;  // general purpose window number - display as ":n"
					// -1 => unknown, 0 => only window viewing document
					// 1 => first of many windows viewing document, 2=> second

	HMENU m_hMenuDefault;       // default menu resource for this frame
	HACCEL m_hAccelTable;       // accelerator table

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	DWORD m_dwPromptContext;    // current help prompt context for message box
	BOOL m_bHelpMode;           // if TRUE, then Shift+F1 help mode is active
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	CFrameWnd* m_pNextFrameWnd; // next CFrameWnd in app global list
	CRect m_rectBorder;         // for OLE border space negotiation
#ifndef _WIN32_WCE // OLE
	COleFrameHook* m_pNotifyHook;
#endif // !_WIN32_WCE

	CPtrList m_listControlBars; // array of all control bars that have this
								// window as their dock site
	int m_nShowDelay;           // SW_ command for delay show/hide

#ifndef _WIN32_WCE // Docking
	CMiniDockFrameWnd* CreateFloatingFrame(DWORD dwStyle);
	DWORD CanDock(CRect rect, DWORD dwDockStyle,
		CDockBar** ppDockBar = NULL); // called by CDockContext
#endif // !_WIN32_WCE
	void AddControlBar(CControlBar *pBar);
	void RemoveControlBar(CControlBar *pBar);
#ifndef _WIN32_WCE // Docking
	void DockControlBar(CControlBar* pBar, CDockBar* pDockBar,
		LPCRECT lpRect = NULL);
	void ReDockControlBar(CControlBar* pBar, CDockBar* pDockBar,
		LPCRECT lpRect = NULL);
	void NotifyFloatingWindows(DWORD dwFlags);
#endif // !_WIN32_WCE
	void DestroyDockBars();

protected:
	UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)
	UINT m_nIDTracking;         // tracking command ID or string IDS
	UINT m_nIDLastMessage;      // last displayed message string IDS
	CView* m_pViewActive;       // current active view
	BOOL (CALLBACK* m_lpfnCloseProc)(CFrameWnd* pFrameWnd);
	UINT m_cModalStack;         // BeginModalState depth
	HWND* m_phWndDisable;       // windows disabled because of BeginModalState
	HMENU m_hMenuAlt;           // menu to update to (NULL means default)
	CString m_strTitle;         // default title (original)
	BOOL m_bInRecalcLayout;     // avoid recursion in RecalcLayout
#ifndef _WIN32_WCE // Docking
	CRuntimeClass* m_pFloatingFrameClass;
	static const DWORD dwDockBarMap[4][2];
#endif // !_WIN32_WCE
#ifdef _WIN32_WCE
	CWnd* m_pDoneButtonOwner;
protected:
	SHACTIVATEINFO m_SHActivateInfo;
	SHACTIVATEINFO m_SHActivateInfoSaved;
#endif // _WIN32_WCE

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	virtual BOOL IsFrameWnd() const;
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual HACCEL GetDefaultAccelerator();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// idle update of frame user interface
	enum IdleFlags
		{ idleMenu = 1, idleTitle = 2, idleNotify = 4, idleLayout = 8 };
	UINT m_nIdleFlags;          // set of bit flags for idle processing
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	void DelayUpdateFrameTitle();
	void DelayRecalcLayout(BOOL bNotify = TRUE);

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// for Shift+F1 help support
	BOOL CanEnterHelpMode();
	virtual void ExitHelpMode();
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

	// implementation helpers
public:
	void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
protected:
	LPCTSTR GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();   // default to delete this.
	int OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	void BringToTop(int nCmdShow);
		// bring window to top for SW_ commands which affect z-order

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// implementation helpers for Shift+F1 help mode
	BOOL ProcessHelpMsg(MSG& msg, DWORD* pContext);
	HWND SetHelpCapture(POINT point, BOOL* pbDescendant);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

	// CFrameWnd list management
	void AddFrameWnd();
	void RemoveFrameWnd();

	friend class CWnd;  // for access to m_bModalDisable
	friend class CReBar; // for access to m_bInRecalcLayout

	//{{AFX_MSG(CFrameWnd)
	// Windows messages
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnClose();
#ifndef _WIN32_WCE
	afx_msg void OnInitMenu(CMenu*);
#endif // !_WIN32_WCE
	afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
#ifndef _WIN32_WCE
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
#endif // !_WIN32_WCE
	afx_msg LRESULT OnPopMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	afx_msg LRESULT OnHelpPromptAddr(WPARAM wParam, LPARAM lParam);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	afx_msg void OnIdleUpdateCmdUI();
#ifndef _WIN32_WCE
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
#endif // !_WIN32_WCE
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
#ifndef _WIN32_WCE
	afx_msg BOOL OnNcActivate(BOOL bActive);
#endif // !_WIN32_WCE
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
#ifndef _WIN32_WCE
	afx_msg BOOL OnQueryEndSession();
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
#endif // !_WIN32_WCE
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
	afx_msg LRESULT OnActivateTopLevel(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	// standard commands
#ifndef _WIN32_WCE_NO_TOOLTIPS
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
#endif // !_WIN32_WCE_NO_TOOLTIPS
	afx_msg void OnUpdateKeyIndicator(CCmdUI* pCmdUI);
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	afx_msg void OnHelp();
	afx_msg void OnUpdateContextHelp(CCmdUI* pCmdUI);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
#ifdef _WIN32_WCE
	afx_msg void OnOK();
#ifdef _WIN32_WCE_DOCLIST_SUPPORT
	afx_msg void OnFolderChanged(DLNHDR* pNotifyStruct, LRESULT*);
	afx_msg void OnCreateDocList(DLNHDR*, LRESULT*);
	afx_msg void OnDestroyDocList(DLNHDR*, LRESULT*);
#endif // _WIN32_WCE_DOCLIST_SUPPORT
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
#endif // _WIN32_WCE
#ifndef _WIN32_WCE
	afx_msg BOOL OnChevronPushed(UINT id, NMHDR *pnm, LRESULT *result);
#endif // !_WIN32_WCE
	//}}AFX_MSG
protected:
#ifndef _WIN32_WCE
	afx_msg LRESULT OnDDEInitiate(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDEExecute(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDETerminate(WPARAM wParam, LPARAM lParam);
#endif // !_WIN32_WCE
	afx_msg LRESULT OnRegisteredMouseWheel(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

	friend class CWinApp;
};

#ifndef _WIN32_WCE // Frame Windows
/////////////////////////////////////////////////////////////////////////////
// MDI Support

class CMDIFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIFrameWnd)

public:
// Constructors
	CMDIFrameWnd();

// Operations
	void MDIActivate(CWnd* pWndActivate);
	CMDIChildWnd* MDIGetActive(BOOL* pbMaximized = NULL) const;
	void MDIIconArrange();
	void MDIMaximize(CWnd* pWnd);
	void MDINext();
	void MDIPrev();
	void MDIRestore(CWnd* pWnd);
	CMenu* MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu);
	void MDITile();
	void MDICascade();
	void MDITile(int nType);
	void MDICascade(int nType);
	CMDIChildWnd* CreateNewChild(CRuntimeClass* pClass, UINT nResource,
		HMENU hMenu = NULL, HACCEL hAccel = NULL);

// Overridables
	// MFC 1.0 backward compatible CreateClient hook (called by OnCreateClient)
	virtual BOOL CreateClient(LPCREATESTRUCT lpCreateStruct, CMenu* pWindowMenu);
	// customize if using an 'Window' menu with non-standard IDs
	virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);

// Implementation
public:
	HWND m_hWndMDIClient;       // MDI Client window handle

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	virtual CFrameWnd* GetActiveFrame();

protected:
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CMDIFrameWnd)
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateMDIWindowCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnMDIWindowCmd(UINT nID);
	afx_msg void OnWindowNew();
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg void OnIdleUpdateCmdUI();
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT, CMenu*);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CMDIChildWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIChildWnd)

// Constructors
public:
	CMDIChildWnd();

	virtual BOOL Create(LPCTSTR lpszClassName,
				LPCTSTR lpszWindowName,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CMDIFrameWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

// Attributes
	CMDIFrameWnd* GetMDIFrame();

// Operations
	void MDIDestroy();
	void MDIActivate();
	void MDIMaximize();
	void MDIRestore();
	void SetHandles(HMENU hMenu, HACCEL hAccel);

// Implementation
protected:
	HMENU m_hMenuShared;        // menu when we are active

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
					CWnd* pParentWnd, CCreateContext* pContext = NULL);
		// 'pParentWnd' parameter is required for MDI Child
	virtual BOOL DestroyWindow();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
		HMENU hMenuAlt);

	BOOL m_bPseudoInactive;     // TRUE if window is MDI active according to
								//  windows, but not according to MFC...

protected:
	virtual CWnd* GetMessageBar();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	BOOL UpdateClientEdge(LPRECT lpRect = NULL);

	//{{AFX_MSG(CMDIChildWnd)
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnDestroy();
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd

// MiniFrame window styles
#define MFS_SYNCACTIVE      0x00000100L // syncronize activation w/ parent
#define MFS_4THICKFRAME     0x00000200L // thick frame all around (no tiles)
#define MFS_THICKFRAME      0x00000400L // use instead of WS_THICKFRAME
#define MFS_MOVEFRAME       0x00000800L // no sizing, just moving
#define MFS_BLOCKSYSMENU    0x00001000L // block hit testing on system menu

#pragma warning( disable: 4263 )
#pragma warning( disable: 4264 )
class CMiniFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMiniFrameWnd)

// Constructors
public:
	CMiniFrameWnd();
	virtual BOOL Create(LPCTSTR lpClassName, LPCTSTR lpWindowName,
		DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd = NULL, UINT nID = 0);
	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName,
		DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd = NULL, UINT nID = 0);

// Implementation
public:
	~CMiniFrameWnd();

	//{{AFX_MSG(CMiniFrameWnd)
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO* pMMI);
	afx_msg LRESULT OnFloatStatus(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnQueryCenterWnd(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	static void PASCAL CalcBorders(LPRECT lpClientRect,
		DWORD dwStyle = WS_THICKFRAME | WS_CAPTION, DWORD dwExStyle = 0);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

protected:
	BOOL m_bSysTracking;
	BOOL m_bInSys;
	BOOL m_bActive;
	CString m_strCaption;
};
#pragma warning( default: 4263 )
#pragma warning( default: 4264 )
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// class CView is the client area UI for a document

#ifndef _AFX_NO_PRINTING_SUPPORT
class CPrintDialog;     // forward reference (see afxdlgs.h)
class CPreviewView;     // forward reference (see afxpriv.h)
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE
class CSplitterWnd;     // forward reference (see afxext.h)
class COleServerDoc;    // forward reference (see afxole.h)

typedef DWORD DROPEFFECT;
class COleDataObject;   // forward reference (see afxole.h)
#endif // !_WIN32_WCE

class AFX_NOVTABLE CView : public CWnd
{
	DECLARE_DYNAMIC(CView)

// Constructors
protected:
	CView();

// Attributes
public:
	CDocument* GetDocument() const;

// Operations
public:
#ifndef _AFX_NO_PRINTING_SUPPORT
	// for standard printing setup (override OnPreparePrinting)
	BOOL DoPreparePrinting(CPrintInfo* pInfo);
#endif // !_AFX_NO_PRINTING_SUPPORT

// Overridables
public:
#ifndef _WIN32_WCE // OLE
	virtual BOOL IsSelected(const CObject* pDocItem) const; // support for OLE
#endif // !_WIN32_WCE

	// OLE scrolling support (used for drag/drop as well)
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

#ifndef _WIN32_WCE // Drag n' Drop
	// OLE drag/drop support
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave();
	virtual BOOL OnDrop(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDropEx(COleDataObject* pDataObject,
		DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
	virtual DROPEFFECT OnDragScroll(DWORD dwKeyState, CPoint point);
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
#else
	virtual void OnPrepareDC(CDC* pDC);
#endif // !_AFX_NO_PRINTING_SUPPORT

	virtual void OnInitialUpdate(); // called first time after construct

protected:
	// Activation
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);
	virtual void OnActivateFrame(UINT nState, CFrameWnd* pFrameWnd);

	// General drawing/updating
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual void OnDraw(CDC* pDC) = 0;

#ifndef _AFX_NO_PRINTING_SUPPORT
	// Printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
		// must override to enable printing and print preview

	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

	// Advanced: end print preview mode, move to point
	virtual void OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo, POINT point,
		CPreviewView* pView);
#endif // !_AFX_NO_PRINTING_SUPPORT

// Implementation
public:
	virtual ~CView() = 0;
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif //_DEBUG

#ifndef _AFX_NO_PRINTING_SUPPORT
	// Advanced: for implementing custom print preview
	BOOL DoPrintPreview(UINT nIDResource, CView* pPrintView,
			CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState);
#endif // !_AFX_NO_PRINTING_SUPPORT

	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
#ifndef _WIN32_WCE // Splitter Window
	static CSplitterWnd* PASCAL GetParentSplitter(
		const CWnd* pWnd, BOOL bAnyState);
#endif // !_WIN32_WCE

protected:
	CDocument* m_pDocument;

public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PostNcDestroy();

	// friend classes that call protected CView overridables
	friend class CDocument;
	friend class CDocTemplate;
	friend class CPreviewView;
	friend class CFrameWnd;
	friend class CMDIFrameWnd;
	friend class CMDIChildWnd;
	friend class CSplitterWnd;
	friend class COleServerDoc;
	friend class CDocObjectServer;

	//{{AFX_MSG(CView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	// commands
#ifndef _WIN32_WCE // Splitter Window
	afx_msg void OnUpdateSplitCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnSplitCmd(UINT nID);
	afx_msg void OnUpdateNextPaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnNextPaneCmd(UINT nID);
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT
	// not mapped commands - must be mapped in derived class
	afx_msg void OnFilePrint();
	afx_msg void OnFilePrintPreview();
#endif // !_AFX_NO_PRINTING_SUPPORT
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CCtrlView allows almost any control to be a view

class AFX_NOVTABLE CCtrlView : public CView
{
	DECLARE_DYNCREATE(CCtrlView)

public:
	CCtrlView(LPCTSTR lpszClass, DWORD dwStyle);

// Attributes
protected:
	CString m_strClass;
	DWORD m_dwDefaultStyle;

// Overrides
	virtual void OnDraw(CDC* pDC);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	~CCtrlView() = 0;
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif //_DEBUG

protected:
	afx_msg void OnPaint();
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CScrollView supports simple scrolling and scaling

class _AFX_MOUSEANCHORWND;

class CScrollView : public CView
{
	DECLARE_DYNAMIC(CScrollView)

// Constructors
protected:
	CScrollView();

public:
	static AFX_DATA const SIZE sizeDefault;
		// used to specify default calculated page and line sizes

#ifndef _WIN32_WCE
	// in logical units - call one of the following Set routines
	void SetScaleToFitSize(SIZE sizeTotal);
#endif // !_WIN32_WCE
	void SetScrollSizes(int nMapMode, SIZE sizeTotal,
				const SIZE& sizePage = sizeDefault,
				const SIZE& sizeLine = sizeDefault);

// Attributes
public:
	CPoint GetScrollPosition() const;       // upper corner of scrolling
	CSize GetTotalSize() const;             // logical size

#ifndef _WIN32_WCE
	void CheckScrollBars(BOOL& bHasHorzBar, BOOL& bHasVertBar) const;
#endif // !_WIN32_WCE

	// for device units
	CPoint GetDeviceScrollPosition() const;
	void GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
			SIZE& sizePage, SIZE& sizeLine) const;

// Operations
public:
	void ScrollToPosition(POINT pt);    // set upper left position
	void FillOutsideRect(CDC* pDC, CBrush* pBrush);
	void ResizeParentToFit(BOOL bShrinkOnly = TRUE);
#ifndef _WIN32_WCE
	BOOL DoMouseWheel(UINT fFlags, short zDelta, CPoint point);
#endif // !_WIN32_WCE

// Implementation
protected:
#ifndef _WIN32_WCE
	_AFX_MOUSEANCHORWND* m_pAnchorWindow; // window for wheel mouse anchor
	friend class _AFX_MOUSEANCHORWND;
#endif // !_WIN32_WCE
	int m_nMapMode;				 // mapping mode for window creation
	CSize m_totalLog;           // total size in logical units (no rounding)
	CSize m_totalDev;           // total size in device units
	CSize m_pageDev;            // per page scroll size in device units
	CSize m_lineDev;            // per line scroll size in device units

	BOOL m_bCenter;             // Center output if larger than total size
	BOOL m_bInsideUpdate;       // internal state for OnSize callback
	void CenterOnPoint(CPoint ptCenter);
	void ScrollToDevicePosition(POINT ptDev); // explicit scrolling no checking

protected:
	virtual void OnDraw(CDC* pDC) = 0;      // pass on pure virtual

	void UpdateBars();          // adjust scrollbars etc
	BOOL GetTrueClientSize(CSize& size, CSize& sizeSb);
		// size with no bars
	void GetScrollBarSizes(CSize& sizeSb);
	void GetScrollBarState(CSize sizeClient, CSize& needSb,
		CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient);

public:
	virtual ~CScrollView();
#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
#ifndef _AFX_NO_PRINTING_SUPPORT
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
#else
	virtual void OnPrepareDC(CDC* pDC);
#endif // !_AFX_NO_PRINTING_SUPPORT

	virtual CSize GetWheelScrollDistance(CSize sizeDistance,
		BOOL bHorz, BOOL bVert);

	// scrolling implementation support for OLE
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	//{{AFX_MSG(CScrollView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
#ifndef _WIN32_WCE
	afx_msg BOOL OnMouseWheel(UINT fFlags, short zDelta, CPoint point);
#endif // !_WIN32_WCE
//	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
#ifndef _WIN32_WCE
	afx_msg LRESULT HandleMButtonDown(WPARAM wParam, LPARAM lParam);
#endif // !_WIN32_WCE
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWinThread

typedef UINT (AFX_CDECL *AFX_THREADPROC)(LPVOID);

class COleMessageFilter;        // forward reference (see afxole.h)

BOOL AFXAPI AfxPumpMessage();
LRESULT AFXAPI AfxProcessWndProcException(CException*, const MSG* pMsg);
BOOL __cdecl AfxPreTranslateMessage(MSG* pMsg);
BOOL __cdecl AfxIsIdleMessage(MSG* pMsg);

class CWinThread : public CCmdTarget
{
	DECLARE_DYNAMIC(CWinThread)

	friend BOOL AfxInternalPreTranslateMessage(MSG* pMsg);

public:
// Constructors
	CWinThread();
	BOOL CreateThread(DWORD dwCreateFlags = 0, UINT nStackSize = 0,
		LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

// Attributes
	CWnd* m_pMainWnd;       // main window (usually same AfxGetApp()->m_pMainWnd)
	CWnd* m_pActiveWnd;     // active main window (may not be m_pMainWnd)
	BOOL m_bAutoDelete;     // enables 'delete this' after thread termination

	// only valid while running
	HANDLE m_hThread;       // this thread's HANDLE
	operator HANDLE() const;
	DWORD m_nThreadID;      // this thread's ID

	int GetThreadPriority();
	BOOL SetThreadPriority(int nPriority);

// Operations
	DWORD SuspendThread();
	DWORD ResumeThread();
	BOOL PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam);

// Overridables
	// thread initialization
	virtual BOOL InitInstance();

	// running and idle processing
	virtual int Run();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PumpMessage();     // low level message pump
	virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
	virtual BOOL IsIdleMessage(MSG* pMsg);  // checks for special messages

	// thread termination
	virtual int ExitInstance(); // default will 'delete this'

	// Advanced: exception handling
	virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

#ifndef _WIN32_WCE
	// Advanced: handling messages sent to message filter hook
	virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);
#endif // !_WIN32_WCE

	// Advanced: virtual access to m_pMainWnd
	virtual CWnd* GetMainWnd();

// Implementation
public:
	virtual ~CWinThread();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
	void CommonConstruct();
	virtual void Delete();
		// 'delete this' only if m_bAutoDelete == TRUE

public:
	// constructor used by implementation of AfxBeginThread
	CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam);

	// valid after construction
	LPVOID m_pThreadParams; // generic parameters passed to starting function
	AFX_THREADPROC m_pfnThreadProc;

	// set after OLE is initialized
	void (AFXAPI* m_lpfnOleTermOrFreeLib)(BOOL, BOOL);
#ifndef _WIN32_WCE
	COleMessageFilter* m_pMessageFilter;
#endif // !_WIN32_WCE
protected:
	BOOL DispatchThreadMessageEx(MSG* msg);  // helper
	void DispatchThreadMessage(MSG* msg);  // obsolete
};

// global helpers for threads

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AFXAPI AfxGetThread();
MSG* AFXAPI AfxGetCurrentMessage();

void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete = TRUE);

void AFXAPI AfxInitThread();
void AFXAPI AfxTermThread(HINSTANCE hInstTerm = NULL);

/////////////////////////////////////////////////////////////////////////////
// Global functions for access to the one and only CWinApp

#define afxCurrentWinApp    AfxGetModuleState()->m_pCurrentWinApp
#define afxCurrentInstanceHandle    AfxGetModuleState()->m_hCurrentInstanceHandle
#define afxCurrentResourceHandle    AfxGetModuleState()->m_hCurrentResourceHandle
#define afxCurrentAppName   AfxGetModuleState()->m_lpszCurrentAppName
#define afxContextIsDLL     AfxGetModuleState()->m_bDLL
#define afxRegisteredClasses    AfxGetModuleState()->m_fRegisteredClasses
#define afxAmbientActCtx    AfxGetModuleState()->m_bSetAmbientActCtx

#ifndef _AFX_NO_OCC_SUPPORT
#define afxOccManager   AfxGetModuleState()->m_pOccManager
#endif

#ifdef _WIN32_WCE

#ifndef _AFX_NO_AFXCMN_SUPPORT
#define afxComCtlWrapper AfxGetModuleState()->m_pComCtlWrapper
#endif

#else // _WIN32_WCE

//Fusion: Access macros for WinSxS dynamic wrappers.
#ifndef _AFX_NO_AFXCMN_SUPPORT
#define _AFX_COMCTL32_ISOLATION_WRAPPER_INDEX 0
#define afxComCtlWrapper static_cast<CComCtlWrapper*>(AfxGetModuleState()->m_pDllIsolationWrappers[_AFX_COMCTL32_ISOLATION_WRAPPER_INDEX])
#endif

#define _AFX_COMMDLG_ISOLATION_WRAPPER_INDEX 1
#define afxCommDlgWrapper static_cast<CCommDlgWrapper*>(AfxGetModuleState()->m_pDllIsolationWrappers[_AFX_COMMDLG_ISOLATION_WRAPPER_INDEX])

#endif // _WIN32_WCE


// Advanced initialization: for overriding default WinMain
BOOL AFXAPI AfxWinInit(__in HINSTANCE hInstance, __in HINSTANCE hPrevInstance,
	__in_z LPTSTR lpCmdLine, __in int nCmdShow);
void AFXAPI AfxWinTerm();

// Global Windows state data helper functions (inlines)
#ifdef _AFXDLL
ULONG AFXAPI AfxGetDllVersion();
#endif

CWinApp* AFXAPI AfxGetApp();
CWnd* AFXAPI AfxGetMainWnd();
HINSTANCE AFXAPI AfxGetInstanceHandle();
HINSTANCE AFXAPI AfxGetResourceHandle();
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
LPCTSTR AFXAPI AfxGetAppName();
HINSTANCE AFXAPI AfxLoadLangResourceDLL(LPCTSTR pszFormat);

// Use instead of PostQuitMessage in OLE server applications
void AFXAPI AfxPostQuitMessage(int nExitCode);

// Use AfxFindResourceHandle to find resource in chain of extension DLLs
#ifndef _AFXDLL
#define AfxFindResourceHandle(lpszResource, lpszType) AfxGetResourceHandle()
#else
HINSTANCE AFXAPI AfxFindResourceHandle(LPCTSTR lpszName, LPCTSTR lpszType);
#endif

LONG AFXAPI AfxDelRegTreeHelper(HKEY hParentKey, const CString& strKeyName);

class CRecentFileList;          // forward reference (see afxadv.h)

#ifndef _WIN32_WCE
// access to message filter in CWinApp
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// CCommandLineInfo

class CCommandLineInfo : public CObject
{
public:
	// Sets default values
	CCommandLineInfo();

	// plain char* version on UNICODE for source-code backwards compatibility
	virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);
#ifndef _WIN32_WCE
#ifdef _UNICODE
	virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
#endif
#endif // !_WIN32_WCE

	BOOL m_bShowSplash;
	BOOL m_bRunEmbedded;
	BOOL m_bRunAutomated;
	enum {	FileNew,
		FileOpen,
#ifndef _AFX_NO_PRINTING_SUPPORT
		FilePrint, 
		FilePrintTo,
#endif // !_AFX_NO_PRINTING_SUPPORT
		FileDDE, 
		AppRegister,
		AppUnregister, 
		FileNothing = -1 } m_nShellCommand;

	// not valid for FileNew
	CString m_strFileName;

#ifndef _AFX_NO_PRINTING_SUPPORT
	// valid only for FilePrintTo
	CString m_strPrinterName;
	CString m_strDriverName;
	CString m_strPortName;
#endif // !_AFX_NO_PRINTING_SUPPORT

	~CCommandLineInfo();
// Implementation
protected:
#ifndef _WIN32_WCE
	void ParseParamFlag(const char* pszParam);
#else
	void ParseParamFlag(const wchar_t* pszParam);
#endif // !_WIN32_WCE
	void ParseParamNotFlag(const TCHAR* pszParam);
#ifndef _WIN32_WCE
#ifdef _UNICODE
	void ParseParamNotFlag(const char* pszParam);
#endif
#endif // !_WIN32_WCE
	void ParseLast(BOOL bLast);
};

/////////////////////////////////////////////////////////////////////////////
// CDocManager

class CDocManager : public CObject
{
	DECLARE_DYNAMIC(CDocManager)
public:

// Constructor
	CDocManager();

	//Document functions
	virtual void AddDocTemplate(CDocTemplate* pTemplate);
	virtual POSITION GetFirstDocTemplatePosition() const;
	virtual CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
	virtual void RegisterShellFileTypes(BOOL bCompat);
	void UnregisterShellFileTypes();
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
	virtual BOOL SaveAllModified(); // save before exit
	virtual void CloseAllDocuments(BOOL bEndSession); // close documents before exiting
	virtual int GetOpenDocumentCount();

	// helper for standard commdlg dialogs
	virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
			DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);

//Commands
#ifndef _WIN32_WCE // DDE
	// Advanced: process async DDE request
	virtual BOOL OnDDECommand(__in_z LPTSTR lpszCommand);
	virtual BOOL OnDDECommand(__in __in_z LPTSTR lpszCommand);
#endif // !_WIN32_WCE
	virtual void OnFileNew();
	virtual void OnFileOpen();

// Implementation
protected:
	CPtrList m_templateList;
	int GetDocumentCount(); // helper to count number of total documents

public:
	static CPtrList* pStaticList;       // for static CDocTemplate objects
	static BOOL bStaticInit;            // TRUE during static initialization
	static CDocManager* pStaticDocManager;  // for static CDocTemplate objects

public:
	virtual ~CDocManager();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CWinApp - the root of all Windows applications

#define _AFX_MRU_COUNT   4      // default support for 4 entries in file MRU
#define _AFX_MRU_MAX_COUNT 16   // currently allocated id range supports 16

#define _AFX_SYSPOLICY_NOTINITIALIZED			0
#define _AFX_SYSPOLICY_NORUN					1 
#define _AFX_SYSPOLICY_NODRIVES					2
#define _AFX_SYSPOLICY_RESTRICTRUN				4
#define _AFX_SYSPOLICY_NONETCONNECTDISCONNECTD	8
#define _AFX_SYSPOLICY_NOENTIRENETWORK			16
#define _AFX_SYSPOLICY_NORECENTDOCHISTORY		32
#define _AFX_SYSPOLICY_NOCLOSE					64
#define _AFX_SYSPOLICY_NOPLACESBAR				128
#define _AFX_SYSPOLICY_NOBACKBUTTON				256
#define _AFX_SYSPOLICY_NOFILEMRU				512

struct _AfxSysPolicyData
{
	LPCTSTR szPolicyName;
	DWORD dwID;
};

struct _AfxSysPolicies
{
	LPCTSTR szPolicyKey;
	_AfxSysPolicyData *pData;
};

class CWinApp : public CWinThread
{
	DECLARE_DYNAMIC(CWinApp)
public:

// Constructor
	/* explicit */ CWinApp(LPCTSTR lpszAppName = NULL);     // app name defaults to EXE name

// Attributes
	// Startup args (do not change)

	// This module's hInstance.
	HINSTANCE m_hInstance;

	// Pointer to the command-line.
	LPTSTR m_lpCmdLine;

	// Initial state of the application's window; normally,
	// this is an argument to ShowWindow().
	int m_nCmdShow;

	// Running args (can be changed in InitInstance)

	// Human-redable name of the application. Normally set in
	// constructor or retreived from AFX_IDS_APP_TITLE.
	LPCTSTR m_pszAppName;

	// Name of registry key for this application. See
	// SetRegistryKey() member function.
	LPCTSTR m_pszRegistryKey;

	// Pointer to CDocManager used to manage document templates
	// for this application instance.
	CDocManager* m_pDocManager;

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// Support for Shift+F1 help mode.

	// TRUE if we're in SHIFT+F1 mode.
	BOOL m_bHelpMode;
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

public:
	// set in constructor to override default

	// Executable name (no spaces).
	LPCTSTR m_pszExeName;

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// Default based on this module's path.
	LPCTSTR m_pszHelpFilePath;
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

	// Default based on this application's name.
	LPCTSTR m_pszProfileName;

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// Sets and initializes usage of HtmlHelp instead of WinHelp.
	void EnableHtmlHelp();

	// Sets and initializes usage of HtmlHelp instead of WinHelp.
	void SetHelpMode( AFX_HELP_TYPE eHelpType );
	AFX_HELP_TYPE GetHelpMode();

	// help mode used by the app
	AFX_HELP_TYPE m_eHelpType;
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Initialization Operations - should be done in InitInstance
protected:
#ifndef _WIN32_WCE // Unsupported feature
	// Load MRU file list and last preview state.
	void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);
#endif // !_WIN32_WCE

	void EnableShellOpen();

	// SetDialogBkColor is no longer supported.
	// To change dialog background and text color, handle WM_CTLCOLORDLG instead.
	AFX_DEPRECATED("CWinApp::SetDialogBkColor is no longer supported. Instead, handle WM_CTLCOLORDLG in your dialog")
			void SetDialogBkColor(COLORREF clrCtlBk = RGB(192, 192, 192), COLORREF clrCtlText = RGB(0, 0, 0));

	// Set regsitry key name to be used by CWinApp's
	// profile member functions; prevents writing to an INI file.
	void SetRegistryKey(LPCTSTR lpszRegistryKey);
	void SetRegistryKey(UINT nIDRegistryKey);

	// Enable3dControls and Enable3dControlsStatic are no longer necessary.
	AFX_DEPRECATED("CWinApp::Enable3dControls is no longer needed. You should remove this call.")
			BOOL Enable3dControls();
#ifndef _AFXDLL
	AFX_DEPRECATED("CWinApp::Enable3dControlsStatic is no longer needed. You should remove this call.")
			BOOL Enable3dControlsStatic();
#endif

	void RegisterShellFileTypes(BOOL bCompat = FALSE);

	// call after all doc templates are registered
	void UnregisterShellFileTypes();

public:
	// Loads a cursor resource.
	HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;
	HCURSOR LoadCursor(UINT nIDResource) const;

	// Loads a stock cursor resource; for for IDC_* values.
	HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;

	// Loads an OEM cursor; for all OCR_* values.
	HCURSOR LoadOEMCursor(UINT nIDCursor) const;

	// Loads an icon resource.
	HICON LoadIcon(LPCTSTR lpszResourceName) const;
	HICON LoadIcon(UINT nIDResource) const;

	// Loads an icon resource; for stock IDI_ values.
	HICON LoadStandardIcon(LPCTSTR lpszIconName) const;

	// Loads an OEM icon resource; for all OIC_* values.
	HICON LoadOEMIcon(UINT nIDIcon) const;

	// Retrieve an integer value from INI file or registry.
	UINT GetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);

	// Sets an integer value to INI file or registry.
	BOOL WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nValue);

	// Retrieve a string value from INI file or registry.
	CString GetProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
				LPCTSTR lpszDefault = NULL);

	// Sets a string value to INI file or registry.
	BOOL WriteProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry,
				LPCTSTR lpszValue);

	// Retrieve an arbitrary binary value from INI file or registry.
	BOOL GetProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
				LPBYTE* ppData, UINT* pBytes);

	// Sets an arbitrary binary value to INI file or registry.
	BOOL WriteProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry,
				LPBYTE pData, UINT nBytes);

	// Override in derived class.
	virtual void InitLibId();

	// Register
	virtual BOOL Register();

	// Unregisters everything this app was known to register.
	virtual BOOL Unregister();

	// Delete a registry key entry (and all its subkeys, too).
	LONG DelRegTree(HKEY hParentKey, const CString& strKeyName);

// Running Operations - to be done on a running application
	// Dealing with document templates
	void AddDocTemplate(CDocTemplate* pTemplate);
	POSITION GetFirstDocTemplatePosition() const;
	CDocTemplate* GetNextDocTemplate(POSITION& pos) const;

	// Open named file, trying to match a regsitered
	// document template to it.
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);

	// Add a string to the recent file list. Remove oldest string,
	// if no space left.
#ifndef _WIN32_WCE // Unsupported feature
	virtual void AddToRecentFileList(LPCTSTR lpszPathName);
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT
	// Printer DC Setup routine, 'struct tagPD' is a PRINTDLG structure.
	void SelectPrinter(HANDLE hDevNames, HANDLE hDevMode,
		BOOL bFreeOld = TRUE);

	// Create a DC for the system default printer.
	BOOL CreatePrinterDC(CDC& dc);

#ifndef _UNICODE
	BOOL GetPrinterDeviceDefaults(struct tagPDA* pPrintDlg);
#else
	BOOL GetPrinterDeviceDefaults(struct tagPDW* pPrintDlg);
#endif
#endif // !_AFX_NO_PRINTING_SUPPORT

BOOL GetPrinterDeviceDefaults(PRINTDLG* pPrintDlg);

	// Run this app as an embedded object.
	BOOL RunEmbedded();

	// Run this app as an OLE automation server.
	BOOL RunAutomated();

	// Parse the command line for stock options and commands.
	void ParseCommandLine(CCommandLineInfo& rCmdInfo);

	// React to a shell-issued command line directive.
	BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);

// Overridables

	// Hooks for your initialization code
	virtual BOOL InitApplication();

	// exiting
	virtual BOOL SaveAllModified(); // save before exit
	void HideApplication();
	void CloseAllDocuments(BOOL bEndSession); // close documents before exiting

	// Advanced: to override message boxes and other hooks
	virtual int DoMessageBox(LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
	virtual void DoWaitCursor(int nCode); // 0 => restore, 1=> begin, -1=> end

#ifndef _WIN32_WCE // DDE
	// Advanced: process async DDE request
	virtual BOOL OnDDECommand(__in_z LPTSTR lpszCommand);
#endif // !_WIN32_WCE

	// Advanced: Help support
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual void WinHelpInternal(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Command Handlers
protected:
	// map to the following for file new/open
	afx_msg void OnFileNew();
	afx_msg void OnFileOpen();

#ifndef _AFX_NO_PRINTING_SUPPORT
	// map to the following to enable print setup
	afx_msg void OnFilePrintSetup();
#endif // !_AFX_NO_PRINTING_SUPPORT

#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	// map to the following to enable help
	afx_msg void OnContextHelp();   // shift-F1
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX
	afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING
#endif // !_WIN32_WCE_NO_HELP_SUPPORT

// Implementation
protected:
#ifndef _AFX_NO_PRINTING_SUPPORT
	HGLOBAL m_hDevMode;             // printer Dev Mode
	HGLOBAL m_hDevNames;            // printer Device Names
#endif // !_AFX_NO_PRINTING_SUPPORT
#ifndef _WIN32_WCE_NO_HELP_SUPPORT
	DWORD m_dwPromptContext;        // help context override for message box
#endif // !_WIN32_WCE_NO_HELP_SUPPORT
// LKG	
//	DWORD m_dwPolicies;				// block for storing boolean system policies

	HINSTANCE m_hLangResourceDLL;  // Satellite resource DLL

	int m_nWaitCursorCount;         // for wait cursor (>0 => waiting)
	HCURSOR m_hcurWaitCursorRestore; // old cursor to restore after wait cursor

#ifndef _WIN32_WCE // Unsupported feature
	CRecentFileList* m_pRecentFileList;
#endif // !_WIN32_WCE

#ifndef _AFX_NO_PRINTING_SUPPORT
	void UpdatePrinterSelection(BOOL bForceDefaults);
#endif // !_AFX_NO_PRINTING_SUPPORT
#ifndef _WIN32_WCE // Unsupported feature
	void SaveStdProfileSettings();  // save options to .INI file
#endif // !_WIN32_WCE

public: // public for implementation access
	CCommandLineInfo* m_pCmdInfo;

	ATOM m_atomApp, m_atomSystemTopic;   // for DDE open
#ifndef _AFX_NO_PRINTING_SUPPORT
	UINT m_nNumPreviewPages;        // number of default printed pages
#endif // !_AFX_NO_PRINTING_SUPPORT

	size_t  m_nSafetyPoolSize;      // ideal size

	void (AFXAPI* m_lpfnDaoTerm)();

#ifndef _AFX_NO_PRINTING_SUPPORT
	void DevModeChange(__in_z LPTSTR lpDeviceName);
#endif // !_AFX_NO_PRINTING_SUPPORT
	void SetCurrentHandles();

	// Finds number of opened CDocument items owned by templates
	// registered with the doc manager.
	int GetOpenDocumentCount();

	// helpers for standard commdlg dialogs
	BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
			DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
#ifndef _AFX_NO_PRINTING_SUPPORT
	INT_PTR DoPrintDialog(CPrintDialog* pPD);
#endif // !_AFX_NO_PRINTING_SUPPORT

	void EnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

	// overrides for implementation
	virtual BOOL InitInstance();
	virtual int ExitInstance(); // return app exit code
	virtual int Run();
	virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
	virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);
	virtual HINSTANCE LoadAppLangResourceDLL();

    // Helper for message boxes; can work when no CWinApp can be found
	static int ShowAppMessageBox(CWinApp *pApp, LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
	static void DoEnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

public:
	virtual ~CWinApp();
#ifdef _DEBUG
	virtual void AssertValid() const;
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext& dc) const;
#endif // !_WIN32_WCE
#endif

	// helpers for registration
	HKEY GetSectionKey(LPCTSTR lpszSection);
	HKEY GetAppRegistryKey();

protected:
	//{{AFX_MSG(CWinApp)
	afx_msg void OnAppExit();
#ifndef _WIN32_WCE // Unsupported feature
	afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnOpenRecentFile(UINT nID);
#endif // !_WIN32_WCE
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public :
	// System Policy Settings
	virtual BOOL LoadSysPolicies(); // Override to load policies other than the system policies that MFC loads.
	BOOL GetSysPolicyValue(DWORD dwPolicyID, BOOL *pbValue); // returns the policy's setting in the out parameter
protected :
	BOOL _LoadSysPolicies() throw(); // Implementation helper
	DWORD m_dwPolicies;				// block for storing boolean system policies
};

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor();
	~CWaitCursor();

// Operations
public:
	void Restore();
};

/////////////////////////////////////////////////////////////////////////////
// class CDocTemplate creates documents

class AFX_NOVTABLE CDocTemplate : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocTemplate)

// Constructors
protected:
	CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

public:
	virtual void LoadTemplate();

// Attributes
public:
#ifndef _WIN32_WCE // OLE
	// setup for OLE containers
	void SetContainerInfo(UINT nIDOleInPlaceContainer);

	// setup for OLE servers
	void SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer = 0,
		CRuntimeClass* pOleFrameClass = NULL, CRuntimeClass* pOleViewClass = NULL);
#endif // !_WIN32_WCE

	// iterating over open documents
	virtual POSITION GetFirstDocPosition() const = 0;
	virtual CDocument* GetNextDoc(POSITION& rPos) const = 0;

// Operations
public:
	virtual void AddDocument(CDocument* pDoc);      // must override
	virtual void RemoveDocument(CDocument* pDoc);   // must override

	enum DocStringIndex
	{
		windowTitle,        // default window title
		docName,            // user visible name for default document
		fileNewName,        // user visible name for FileNew
		// for file based documents:
		filterName,         // user visible name for FileOpen
		filterExt,          // user visible extension for FileOpen
		// for file based documents with Shell open support:
		regFileTypeId,      // REGEDIT visible registered file type identifier
		regFileTypeName,    // Shell visible registered file type name
	};
	virtual BOOL GetDocString(CString& rString,
		enum DocStringIndex index) const; // get one of the info strings
#ifndef _WIN32_WCE // OLE
	CFrameWnd* CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
		BOOL bCreateView);
#endif // !_WIN32_WCE

// Overridables
public:
	enum Confidence
	{
		noAttempt,
		maybeAttemptForeign,
		maybeAttemptNative,
		yesAttemptForeign,
		yesAttemptNative,
		yesAlreadyOpen
	};
	virtual Confidence MatchDocType(LPCTSTR lpszPathName,
					CDocument*& rpDocMatch);
	virtual CDocument* CreateNewDocument();
	virtual CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual BOOL SaveAllModified();     // for all documents
	virtual void CloseAllDocuments(BOOL bEndSession);
	virtual CDocument* OpenDocumentFile(
		LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE) = 0;
					// open named file
					// if lpszPathName == NULL => create new file with this type
	virtual void SetDefaultTitle(CDocument* pDocument) = 0;

// Implementation
public:
	BOOL m_bAutoDelete;
	virtual ~CDocTemplate() = 0;

#ifndef _WIN32_WCE // OLE
	// back pointer to OLE or other server (NULL if none or disabled)
	CObject* m_pAttachedFactory;

	// menu & accelerator resources for in-place container
	HMENU m_hMenuInPlace;
	HACCEL m_hAccelInPlace;

	// menu & accelerator resource for server editing embedding
	HMENU m_hMenuEmbedding;
	HACCEL m_hAccelEmbedding;

	// menu & accelerator resource for server editing in-place
	HMENU m_hMenuInPlaceServer;
	HACCEL m_hAccelInPlaceServer;
#endif // !_WIN32_WCE

#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif
	virtual void OnIdle();             // for all documents
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	UINT m_nIDResource;                 // IDR_ for frame/menu/accel as well
#ifndef _WIN32_WCE // OLE
	UINT m_nIDServerResource;           // IDR_ for OLE inplace frame/menu/accel
	UINT m_nIDEmbeddingResource;        // IDR_ for OLE open frame/menu/accel
	UINT m_nIDContainerResource;        // IDR_ for container frame/menu/accel
#endif // !_WIN32_WCE

	CRuntimeClass* m_pDocClass;         // class for creating new documents
	CRuntimeClass* m_pFrameClass;       // class for creating new frames
	CRuntimeClass* m_pViewClass;        // class for creating new views
#ifndef _WIN32_WCE // OLE
	CRuntimeClass* m_pOleFrameClass;    // class for creating in-place frame
	CRuntimeClass* m_pOleViewClass;     // class for creating in-place view
#endif // !_WIN32_WCE

	CString m_strDocStrings;    // '\n' separated names
		// The document names sub-strings are represented as _one_ string:
		// windowTitle\ndocName\n ... (see DocStringIndex enum)
};

// SDI support (1 document only)
class CSingleDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CSingleDocTemplate)

// Constructors
public:
	CSingleDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	virtual ~CSingleDocTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(
		LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
	virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CDocument* m_pOnlyDoc;
};

#ifdef _WIN32_WCE_DOCLIST_SUPPORT
#include <memory>
using namespace std;

class CDocList;
// SDI support, with zero-document, and CDocList support
class CDocListDocTemplate : public CSingleDocTemplate
{
	DECLARE_DYNAMIC(CDocListDocTemplate)

// Constructors
public:
	CDocListDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass,
		LPCTSTR lpszFilterList = NULL, LPCTSTR lpszFolder = NULL);
	virtual ~CDocListDocTemplate();

// Implementation
public:
	virtual CFrameWnd* CreateNewFrame(CDocument* pDoc = NULL, CFrameWnd* pOther = NULL);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual void ShowDocList();
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
	virtual void CloseAllDocuments(BOOL bEndSession);

protected:
	CString m_strFilterList;

// Implementation
public:
	CDocList* m_pWndDocList;
	CString m_crtFolder;	// current path for saving documents 
	CString m_strFolder;	// used for creating the doclist
};
#endif // _WIN32_WCE_DOCLIST_SUPPORT

#ifndef _WIN32_WCE
// MDI support (zero or more documents)
class CMultiDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CMultiDocTemplate)

// Constructors
public:
	CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	// Menu and accel table for MDI Child windows of this type
	HMENU m_hMenuShared;
	HACCEL m_hAccelTable;

	virtual ~CMultiDocTemplate();
	virtual void LoadTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(
		LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
	virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CPtrList m_docList;          // open documents of this type
	UINT m_nUntitledCount;   // start at 0, for "Document1" title
};
#endif // !_WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// class CDocument is the main document data abstraction

class AFX_NOVTABLE CDocument : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocument)

public:
// Constructors
	CDocument();

// Attributes
public:
	const CString& GetTitle() const;
	virtual void SetTitle(LPCTSTR lpszTitle);
	const CString& GetPathName() const;
#ifndef _WIN32_WCE // Unsupported feature
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
#else
	virtual void SetPathName(LPCTSTR lpszPathName);
#endif // !_WIN32_WCE

	CDocTemplate* GetDocTemplate() const;
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);

// Operations
	void AddView(CView* pView);
	void RemoveView(CView* pView);
	virtual POSITION GetFirstViewPosition() const;
	virtual CView* GetNextView(POSITION& rPosition) const;

	// Update Views (simple update - DAG only)
	void UpdateAllViews(CView* pSender, LPARAM lHint = 0L,
		CObject* pHint = NULL);

// Overridables
	// Special notifications
	virtual void OnChangedViewList(); // after Add or Remove view
	virtual void DeleteContents(); // delete doc items etc

	// File helpers
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
				CException* e, BOOL bSaving, UINT nIDPDefault);
	virtual CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError);
	virtual void ReleaseFile(CFile* pFile, BOOL bAbort);

	// advanced overridables, closing down frame/doc, etc.
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL SaveModified(); // return TRUE if ok to continue
	virtual void PreCloseFrame(CFrameWnd* pFrame);

// Implementation
protected:
	// default implementation
	CString m_strTitle;
	CString m_strPathName;
	CDocTemplate* m_pDocTemplate;
	CPtrList m_viewList;                // list of views
	BOOL m_bModified;                   // changed since last saved

public:
	BOOL m_bAutoDelete;     // TRUE => delete document when no more views
	BOOL m_bEmbedded;       // TRUE => document is being created by OLE
#ifdef _WIN32_WCE
	BOOL m_bTempDoc;	// TRUE => document is being created by CDocListDocTemplate 
	BOOL m_bAutoSave;	// TRUE => save file automically w/o any prompt for anything, TRUE by default.
#endif // _WIN32_WCE

#ifdef _DEBUG
#ifndef _WIN32_WCE
	virtual void Dump(CDumpContext&) const;
#endif // !_WIN32_WCE
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual ~CDocument() = 0;

	// implementation helpers
	virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
	virtual BOOL DoFileSave();
	virtual void UpdateFrameCounts();
	void DisconnectViews();
	void SendInitialUpdate();

	// overridables for implementation
	virtual HMENU GetDefaultMenu(); // get menu depending on state
	virtual HACCEL GetDefaultAccelerator();
	virtual void OnIdle();
	virtual void OnFinalRelease();

	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	friend class CDocTemplate;

protected:
	// file menu commands
	//{{AFX_MSG(CDocument)
	afx_msg void OnFileClose();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
#ifdef _WIN32_WCE_DOCLIST_SUPPORT
	afx_msg void OnOK();
#endif // _WIN32_WCE_DOCLIST_SUPPORT
	//}}AFX_MSG
#ifndef _WIN32_WCE
	// mail enabling
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateFileSendMail(CCmdUI* pCmdUI);
#endif // !_WIN32_WCE
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Extra diagnostic tracing options

#ifdef _DEBUG
extern AFX_DATA UINT afxTraceFlags;
#endif // _DEBUG

#ifdef _DEBUG
#define DECLARE_AFX_TRACE_CATEGORY( name ) extern AFX_DATA ATL::CTraceCategory name;
#else
#define DECLARE_AFX_TRACE_CATEGORY( name ) const DWORD_PTR name = 0;
#endif

DECLARE_AFX_TRACE_CATEGORY( traceAppMsg )        // main message pump trace (includes DDE)
DECLARE_AFX_TRACE_CATEGORY( traceWinMsg )        // Windows message tracing
DECLARE_AFX_TRACE_CATEGORY( traceCmdRouting )    // Windows command routing trace
DECLARE_AFX_TRACE_CATEGORY( traceOle )          // special OLE callback trace
#ifndef _AFX_NO_DB_SUPPORT
DECLARE_AFX_TRACE_CATEGORY( traceDatabase )     // special database trace
#endif // !_AFX_NO_DB_SUPPORT
#ifndef _AFX_NO_INET_SUPPORT
DECLARE_AFX_TRACE_CATEGORY( traceInternet )     // special Internet client trace
#endif // !_AFX_NO_INET_SUPPORT
#ifndef _WIN32_WCE
DECLARE_AFX_TRACE_CATEGORY( traceDumpContext )	// traces from CDumpContext
#endif // !_WIN32_WCE
DECLARE_AFX_TRACE_CATEGORY( traceMemory )		// generic non-kernel memory traces
#ifndef _AFX_NO_HTML_SUPPORT
DECLARE_AFX_TRACE_CATEGORY( traceHtml )			// Html traces
#endif // !_AFX_NO_HTML_SUPPORT
DECLARE_AFX_TRACE_CATEGORY( traceSocket )		// Socket traces

//////////////////////////////////////////////////////////////////////////////
// MENU API
#ifdef _WIN32_WCE

#ifdef GetMenu
#undef GetMenu
#endif 
inline HMENU GetMenu( HWND hWnd )
{
	CWnd* pWnd = CWnd::FromHandle(hWnd); 
	return (pWnd != NULL) ? pWnd->m_hMenu : NULL; 
}

#ifdef SetMenu
#undef SetMenu
#endif

inline BOOL SetMenu( HWND hWnd, HMENU hMenu )
{
	CWnd* pWnd = CWnd::FromHandle(hWnd);
	if (pWnd == NULL)
		return FALSE;
	
	pWnd->m_hMenu = hMenu;
	return TRUE;
}
#endif // _WIN32_WCE

//////////////////////////////////////////////////////////////////////////////
// MessageBox helpers

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AFXAPI AfxFormatString2(CString& rString, UINT nIDS,
				LPCTSTR lpsz1, LPCTSTR lpsz2);
int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
				UINT nIDHelp = 0);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType = MB_OK,
				UINT nIDHelp = (UINT)-1);

// Implementation string helpers
void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
				LPCTSTR const* rglpsz, int nString);
void AFXAPI AfxFormatStrings(CString& rString, LPCTSTR lpszFormat,
				LPCTSTR const* rglpsz, int nString);
BOOL AFXAPI AfxExtractSubString(CString& rString, LPCTSTR lpszFullString,
				int iSubString, TCHAR chSep = '\n');

/////////////////////////////////////////////////////////////////////////////
// Special target variant APIs

#ifdef _AFXDLL
	#include <afxdll_.h>
#endif

// Windows Version compatibility (obsolete)
#define AfxEnableWin30Compatibility()
#define AfxEnableWin31Compatibility()
#define AfxEnableWin40Compatibility()

// Temporary map management (locks temp map on current thread)
void AFXAPI AfxLockTempMaps();
BOOL AFXAPI AfxUnlockTempMaps(BOOL bDeleteTemps = TRUE);

/////////////////////////////////////////////////////////////////////////////
// Special OLE related functions (see OLELOCK.CPP)

void AFXAPI AfxOleOnReleaseAllObjects();
BOOL AFXAPI AfxOleCanExitApp();
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
BOOL AFXAPI AfxOleGetUserCtrl();

#ifndef _AFX_NO_OCC_SUPPORT
BOOL AFXAPI AfxOleLockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleUnlockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleLockControl(LPCTSTR lpszProgID);
BOOL AFXAPI AfxOleUnlockControl(LPCTSTR lpszProgID);
void AFXAPI AfxOleUnlockAllControls();
#endif

/////////////////////////////////////////////////////////////////////////////
// Use version 1.0 of the RichEdit control

#define _RICHEDIT_VER 0x0210

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#include <afxcomctl32.inl>

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#include <afxwin1.inl>
#include <afxwin2.inl>
#include <afxwin3.inl>
#endif

#include <afxwin4.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

/////////////////////////////////////////////////////////////////////////////

#else //RC_INVOKED
#include <afxres.h>     // standard resource IDs
#endif //RC_INVOKED

#pragma warning( pop )

#endif //__AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\afxwin4.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Always Inline. Functions only in Win98/Win2K or later

#pragma once

#if (_WIN32_WINNT >= 0x0500)

#ifndef _WIN32_WCE
AFX_INLINE COLORREF CDC::GetDCBrushColor() const
	{ ASSERT(m_hDC != NULL); return ::GetDCBrushColor(m_hDC); }
AFX_INLINE COLORREF CDC::SetDCBrushColor(COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetDCBrushColor(m_hDC, crColor); }

AFX_INLINE COLORREF CDC::GetDCPenColor() const
	{ ASSERT(m_hDC != NULL); return ::GetDCPenColor(m_hDC); }
AFX_INLINE COLORREF CDC::SetDCPenColor(COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetDCPenColor(m_hDC, crColor); }
#endif //!_WIN32_WCE

AFX_INLINE BOOL CDC::GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const
	{ ASSERT(m_hDC != NULL); return ::GetCharABCWidthsI(m_hDC, giFirst, cgi, pgi, lpabc); }
#ifndef _WIN32_WCE
AFX_INLINE BOOL CDC::GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const
	{ ASSERT(m_hDC != NULL); return ::GetCharWidthI(m_hDC, giFirst, cgi, pgi, lpBuffer); }

AFX_INLINE BOOL CDC::GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const
{ 
	ENSURE(lpSize != NULL); 
	ASSERT(m_hDC != NULL); 
	return ::GetTextExtentExPointI(m_hDC, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize); 
}
AFX_INLINE BOOL CDC::GetTextExtentPointI(LPWORD pgiIn, int cgi, LPSIZE lpSize) const
{
	ENSURE(lpSize != NULL); 
	ASSERT(m_hDC != NULL); 
	return ::GetTextExtentPointI(m_hDC, pgiIn, cgi, lpSize); 
}
#endif //!_WIN32_WCE

#endif

#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)

AFX_INLINE BOOL CWnd::GetWindowInfo(PWINDOWINFO pwi) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowInfo(m_hWnd, pwi); }

AFX_INLINE CWnd* CWnd::GetAncestor(UINT gaFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return  CWnd::FromHandle(::GetAncestor(m_hWnd, gaFlags)); }


AFX_INLINE BOOL CWnd::GetMenuBarInfo(LONG idObject, LONG idItem, PMENUBARINFO pmbi) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pmbi != NULL);
	return ::GetMenuBarInfo(m_hWnd, idObject, idItem, pmbi);
}

AFX_INLINE BOOL CWnd::GetScrollBarInfo(LONG idObject, PSCROLLBARINFO psbi) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(psbi != NULL);
	return ::GetScrollBarInfo(m_hWnd, idObject, psbi);
}

AFX_INLINE BOOL CWnd::GetTitleBarInfo(PTITLEBARINFO pti) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pti != NULL);
	return ::GetTitleBarInfo(m_hWnd, pti);
}

AFX_INLINE BOOL CWnd::AnimateWindow(DWORD dwTime, DWORD dwFlags) 
{
	ASSERT(::IsWindow(m_hWnd)); 
	return ::AnimateWindow(m_hWnd, dwTime, dwFlags);
}

AFX_INLINE BOOL CWnd::FlashWindowEx(DWORD dwFlags, UINT  uCount, DWORD dwTimeout)
{
	ASSERT(::IsWindow(m_hWnd)); 
	FLASHWINFO fwi;
	fwi.cbSize = sizeof(fwi);
	fwi.hwnd = m_hWnd;
	fwi.dwFlags = dwFlags;
	fwi.uCount = uCount;
	fwi.dwTimeout = dwTimeout;

	return ::FlashWindowEx(&fwi);
}

AFX_INLINE BOOL CComboBox::GetComboBoxInfo(PCOMBOBOXINFO pcbi) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pcbi != NULL);
	return ::GetComboBoxInfo(m_hWnd, pcbi);
}

AFX_INLINE DWORD CListBox::GetListBoxInfo() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetListBoxInfo(m_hWnd); }

AFX_INLINE BOOL CMenu::SetMenuInfo(LPCMENUINFO lpcmi)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuInfo(m_hMenu, lpcmi); }

AFX_INLINE BOOL CMenu::GetMenuInfo(LPMENUINFO lpcmi) const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuInfo(m_hMenu, lpcmi); }

#endif	// WINVER >= 0x0500 && !_WIN32_WCE

#if(_WIN32_WINNT >= 0x0500)

#ifndef _WIN32_WCE
AFX_INLINE BOOL CWnd::SetLayeredWindowAttributes(COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd)); 
	return ::SetLayeredWindowAttributes(m_hWnd, crKey, bAlpha, dwFlags);
}

AFX_INLINE BOOL CWnd::UpdateLayeredWindow(CDC* pDCDst, POINT *pptDst, SIZE *psize, 
		CDC* pDCSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd)); 
	return ::UpdateLayeredWindow(m_hWnd, pDCDst->GetSafeHdc(), pptDst, psize,
		pDCSrc->GetSafeHdc(), pptSrc, crKey, pblend, dwFlags);
}
#endif // !_WIN32_WCE

#endif	// _WIN32_WINNT >= 0x0500

#if(_WIN32_WINNT >= 0x0501)

AFX_INLINE BOOL CWnd::GetLayeredWindowAttributes(COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	return ::GetLayeredWindowAttributes(m_hWnd, pcrKey, pbAlpha, pdwFlags);
}

#ifndef _AFX_NO_PRINTING_SUPPORT
AFX_INLINE BOOL CWnd::PrintWindow(CDC* pDC, UINT nFlags) const
{
	ASSERT(::IsWindow(m_hWnd)); 
	return ::PrintWindow(m_hWnd, pDC->GetSafeHdc(), nFlags);
}
#endif // !_AFX_NO_PRINTING_SUPPORT

AFX_INLINE BOOL CScrollBar::GetScrollBarInfo(PSCROLLBARINFO pScrollInfo) const	
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, SBM_GETSCROLLBARINFO, NULL, (LPARAM)pScrollInfo); }

AFX_INLINE BOOL CEdit::SetCueBanner(LPCWSTR lpcwText)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	return Edit_SetCueBannerText(m_hWnd, lpcwText); 
}

AFX_INLINE BOOL CEdit::GetCueBanner(__out_ecount_z(cchText) LPWSTR lpwText, __in int cchText)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(lpwText != NULL);
	if(lpwText!=NULL)
	{
		lpwText[0]=L'\0';
	}
	return Edit_GetCueBannerText(m_hWnd, lpwText, cchText); 
}

AFX_INLINE BOOL CButton::GetIdealSize(SIZE* psize)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(psize != NULL);
	return Button_GetIdealSize(m_hWnd, psize); 
}

AFX_INLINE BOOL CButton::SetImageList(PBUTTON_IMAGELIST pbuttonImagelist)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pbuttonImagelist != NULL);
	return Button_SetImageList(m_hWnd, pbuttonImagelist); 
}

AFX_INLINE BOOL CButton::GetImageList(PBUTTON_IMAGELIST pbuttonImagelist)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pbuttonImagelist != NULL);
	return Button_GetImageList(m_hWnd, pbuttonImagelist); 
}

AFX_INLINE BOOL CButton::SetTextMargin(RECT* pmargin)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pmargin != NULL);
	return Button_SetTextMargin(m_hWnd, pmargin); 
}

AFX_INLINE BOOL CButton::GetTextMargin(RECT* pmargin)
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	ASSERT(pmargin != NULL);
	return Button_GetTextMargin(m_hWnd, pmargin); 
}

#endif	// _WIN32_WINNT >= 0x0501
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\dlgs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


/*++

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/


#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */






//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#ifndef _WIN32_WCE
#define WINVER 0x0500   // default to Windows Version 5.0
#else // _WIN32_WCE
#define WINVER 0x0400   // default appropriate value for Windows CE, although this is not strongly correlated to the OS version
#endif // _WIN32_WCE
#endif

#ifndef _WIN32_WCE
#include <winresrc.h>
#else // _WIN32_WCE
#include <dlgs.h>
#include <winbase.h>
#include <commctrl.h>
#include <resdefce.h>
#endif // _WIN32_WCE

// operation messages sent to DLGINIT
#ifndef LB_ADDSTRING 
#define LB_ADDSTRING    (WM_USER+1)
#endif
#ifndef CB_ADDSTRING
#define CB_ADDSTRING    (WM_USER+3)
#endif

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\mfc8\include\wceres.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// wceres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifndef __WCERES_H__
#define __WCERES_H__

#pragma warning(disable:4005)

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OCR_NO          32648
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#define OCR_APPSTARTING     32650
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE

#define WS_OVERLAPPED   0x00000000L
#define WS_EX_CAPTIONOKBTN      0x80000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00010000L
#define WS_MAXIMIZEBOX  0x00020000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L
#define WS_EX_CAPTIONOKBTN      0x80000000L
#define WS_EX_NODRAG            0x40000000L
#define WS_EX_ABOVESTARTUP		0x20000000L
#define WS_EX_INK				0x10000000L
#define WS_EX_NOANIMATION		0x04000000L
#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define VK_LSHIFT       0xA0
#define VK_RSHIFT       0xA1
#define VK_LCONTROL     0xA2
#define VK_RCONTROL     0xA3
#define VK_LMENU        0xA4
#define VK_RMENU        0xA5

#define VK_PROCESSKEY   0xE5

#define VK_ATTN         0xF6
#define VK_CRSEL        0xF7
#define VK_EXSEL        0xF8
#define VK_EREOF        0xF9
#define VK_PLAY         0xFA
#define VK_ZOOM         0xFB
#define VK_NONAME       0xFC
#define VK_PA1          0xFD
#define VK_OEM_CLEAR    0xFE

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L
#define DS_SETFOREGROUND 0x200L


#define DS_3DLOOK       0x0004L
#define DS_FIXEDSYS     0x0008L
#define DS_NOFAILCREATE 0x0010L
#define DS_CONTROL      0x0400L
#define DS_CENTER       0x0800L
#define DS_CENTERMOUSE  0x1000L
#define DS_CONTEXTHELP  0x2000L

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_BITMAP           0x0000000EL

#define SS_OWNERDRAW        0x0000000DL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L

#define SS_NOPREFIX     0x00000080L
#define SS_NOTIFY           0x00000100L
#define SS_CENTERIMAGE      0x00000200L
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L
#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L
#define ES_NUMBER       0x2000L

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L
#define SBS_SIZEGRIP    0x0010L

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#if !defined(_WIN32_WCE_NO_OWNERDRAW_LBS)
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#endif
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_NOSEL       0x4000L
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L
#define CBS_UPPERCASE   0x2000L
#define CBS_LOWERCASE   0x4000L

// operation messages sent to DLGINIT
#define WM_USER         0x0400

#ifndef HDS_HORZ
#define HDS_HORZ                0x00000000
#endif
#ifndef HDS_BUTTONS
#define HDS_BUTTONS             0x00000002
#endif
#ifndef HDS_HIDDEN
#define HDS_HIDDEN              0x00000008
#endif

#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02

#define SBARS_SIZEGRIP          0x0100

#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080

#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_NOHILITE            0x00000010L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_NOSCROLL            0x2000

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000

#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020

#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_SHAREIMAGELISTS     0x0040
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000

#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004

// 32-bit language/sub-language identifiers

#ifndef LANG_NEUTRAL
// Primary language IDs.
#define LANG_NEUTRAL                     0x00

#define LANG_BULGARIAN                   0x02
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_TURKISH                     0x1f
#endif //!LANG_NEUTRAL

#ifndef SUBLANG_NEUTRAL
// Sublanguage IDs.
#define SUBLANG_NEUTRAL                  0x00
#define SUBLANG_DEFAULT                  0x01
#define SUBLANG_SYS_DEFAULT              0x02

#define SUBLANG_CHINESE_TRADITIONAL      0x01
#define SUBLANG_CHINESE_SIMPLIFIED       0x02
#define SUBLANG_CHINESE_HONGKONG         0x03
#define SUBLANG_CHINESE_SINGAPORE        0x04
#define SUBLANG_DUTCH                    0x01
#define SUBLANG_DUTCH_BELGIAN            0x02
#define SUBLANG_ENGLISH_US               0x01
#define SUBLANG_ENGLISH_UK               0x02
#define SUBLANG_ENGLISH_AUS              0x03
#define SUBLANG_ENGLISH_CAN              0x04
#define SUBLANG_ENGLISH_NZ               0x05
#define SUBLANG_ENGLISH_EIRE             0x06
#define SUBLANG_FRENCH                   0x01
#define SUBLANG_FRENCH_BELGIAN           0x02
#define SUBLANG_FRENCH_CANADIAN          0x03
#define SUBLANG_FRENCH_SWISS             0x04
#define SUBLANG_GERMAN                   0x01
#define SUBLANG_GERMAN_SWISS             0x02
#define SUBLANG_GERMAN_AUSTRIAN          0x03
#define SUBLANG_ITALIAN                  0x01
#define SUBLANG_ITALIAN_SWISS            0x02
#define SUBLANG_NORWEGIAN_BOKMAL         0x01
#define SUBLANG_NORWEGIAN_NYNORSK        0x02
#define SUBLANG_PORTUGUESE               0x02
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01
#define SUBLANG_SPANISH                  0x01
#define SUBLANG_SPANISH_MEXICAN          0x02
#define SUBLANG_SPANISH_MODERN           0x03
#endif //!SUBLANG_NEUTRAL

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
#define IDCLOSE         8
#define IDHELP          9

#pragma warning(default:4005)

#endif // __WCERES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\acctid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
//  File:       AcctID.h
//
//  Contents:   ACCTID Definition
//
//----------------------------------------------------------------------------
#ifndef __ACCOUNTID_H__
#define __ACCOUNTID_H__




typedef DWORD         ACCTID;
typedef ACCTID       *PACCTID;
typedef ACCTID const *PCACCTID;





#endif // __ACCOUNTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\accctrl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       accctrl.h
//
//  Contents:   common includes for new style Win32 Access Control
//              APIs
//
//
//--------------------------------------------------------------------
#ifndef __ACCESS_CONTROL__
#define __ACCESS_CONTROL__

#ifndef __midl
#include <wtypes.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define AccFree LocalFree

//
// Definition: TRUSTEE_TYPE
// This enumerated type specifies the type of trustee account for the trustee
// returned by the API described in this document.
// TRUSTEE_IS_UNKNOWN - The trustee is an unknown, but not necessarily invalid
//                      type.  This field is not validated on input to the APIs
//                      that take Trustees.
// TRUSTEE_IS_USER      The trustee account is a user account.
// TRUSTEE_IS_GROUP     The trustee account is a group account.
//

typedef enum _TRUSTEE_TYPE
{
    TRUSTEE_IS_UNKNOWN,
    TRUSTEE_IS_USER,
    TRUSTEE_IS_GROUP,
    TRUSTEE_IS_DOMAIN,
    TRUSTEE_IS_ALIAS,
    TRUSTEE_IS_WELL_KNOWN_GROUP,
    TRUSTEE_IS_DELETED,
    TRUSTEE_IS_INVALID,
} TRUSTEE_TYPE;


//
// Definition: TRUSTEE_FORM
// This enumerated type specifies the form the trustee identifier is in for a
// particular trustee.
// TRUSTEE_IS_SID       The trustee is identified with a SID rather than with a name.
// TRUSTEE_IS_NAME      The trustee is identified with a name.
//

typedef enum _TRUSTEE_FORM
{
    TRUSTEE_IS_SID,
    TRUSTEE_IS_NAME,
    TRUSTEE_BAD_FORM
} TRUSTEE_FORM;


//
// Definition: MULTIPLE_TRUSTEE_OPERATION
// If the trustee is a multiple trustee, this enumerated type specifies the type.
// TRUSTEE_IS_IMPERSONATE       The trustee is an impersonate trustee and the multiple
//                          trustee field in the trustee points to another trustee
//                          that is a trustee for the server that will be doing the
//                          impersonation.
//

typedef enum _MULTIPLE_TRUSTEE_OPERATION
{
    NO_MULTIPLE_TRUSTEE,
    TRUSTEE_IS_IMPERSONATE,
} MULTIPLE_TRUSTEE_OPERATION;


//
// Definition: TRUSTEE
// This structure is used to pass account information into and out of the system
// using the API defined in this document.
// PMultipleTrustee     - if NON-NULL, points to another trustee structure, as
//                    defined by the multiple trustee operation field.
// MultipleTrusteeOperation - Defines the multiple trustee operation/type.
// TrusteeForm - defines if the trustee is defined by name or SID.
// TrusteeType - defines if the trustee type is unknown, a user or a group.
// PwcsName     - points to the trustee name or the trustee SID.
//

typedef struct _TRUSTEE_A
{
    struct _TRUSTEE_A          *pMultipleTrustee;
    MULTIPLE_TRUSTEE_OPERATION  MultipleTrusteeOperation;
    TRUSTEE_FORM                TrusteeForm;
    TRUSTEE_TYPE                TrusteeType;
#ifdef __midl
    [switch_is(TrusteeForm)]
    union
    {
    [case(TRUSTEE_IS_NAME)]
        LPSTR                   ptstrName;
    [case(TRUSTEE_IS_SID)]
        SID                    *pSid;
    };
#else
    LPSTR                       ptstrName;
#endif
} TRUSTEE_A, *PTRUSTEE_A, TRUSTEEA, *PTRUSTEEA;
typedef struct _TRUSTEE_W
{
    struct _TRUSTEE_W          *pMultipleTrustee;
    MULTIPLE_TRUSTEE_OPERATION  MultipleTrusteeOperation;
    TRUSTEE_FORM                TrusteeForm;
    TRUSTEE_TYPE                TrusteeType;
#ifdef __midl
    [switch_is(TrusteeForm)]
    union
    {
    [case(TRUSTEE_IS_NAME)]
        LPWSTR                  ptstrName;
    [case(TRUSTEE_IS_SID)]
        SID                    *pSid;
    };
#else
    LPWSTR                      ptstrName;
#endif
} TRUSTEE_W, *PTRUSTEE_W, TRUSTEEW, *PTRUSTEEW;
#ifdef UNICODE
typedef TRUSTEE_W TRUSTEE_;
typedef PTRUSTEE_W PTRUSTEE_;
typedef TRUSTEEW TRUSTEE;
typedef PTRUSTEEW PTRUSTEE;
#else
typedef TRUSTEE_A TRUSTEE_;
typedef PTRUSTEE_A PTRUSTEE_;
typedef TRUSTEEA TRUSTEE;
typedef PTRUSTEEA PTRUSTEE;
#endif // UNICODE


//
// Definition: ACCESS_MODE
// This enumerated type specifies how permissions are (requested)/to be applied
//  for the trustee by the access control entry.  On input this field can by any
//  of the values, although it is not meaningful to mix access control and audit
//  control entries.  On output this field will be either SET_ACCESS, DENY_ACCESS,
// SET_AUDIT_SUCCESS, SET_AUDIT_FAILURE.
// The following descriptions define how this type effects an explicit access
// request to apply access permissions to an object.
// GRANT_ACCESS - The trustee will have at least the requested permissions upon
//                successful completion of the command. (If the trustee has
//                additional permissions they will not be removed).
// SET_ACCESS - The trustee will have exactly the requested permissions upon
//              successful completion of the command.
// DENY_ACCESS - The trustee will be denied the specified permissions.
// REVOKE_ACCESS - Any explicit access rights the trustee has will be revoked.
// SET_AUDIT_SUCCESS - The trustee will be audited for successful opens of the
//                     object using the requested permissions.
// SET_AUDIT_FAILURE - The trustee will be audited for failed opens of the object
//                     using the requested permissions.
//

typedef enum _ACCESS_MODE
{
    NOT_USED_ACCESS = 0,
    GRANT_ACCESS,
    SET_ACCESS,
    DENY_ACCESS,
    REVOKE_ACCESS,
    SET_AUDIT_SUCCESS,
    SET_AUDIT_FAILURE
} ACCESS_MODE;

//
// Definition: Inheritance flags
// These bit masks are provided to allow simple application of inheritance in
// explicit access requests on containers.
// NO_INHERITANCE       The specific access permissions will only be applied to
//                  the container, and will not be inherited by objects created
//                  within the container.
// SUB_CONTAINERS_ONLY_INHERIT  The specific access permissions will be inherited
//                              and applied to sub containers created within the
//                              container, and will be applied to the container
//                              itself.
// SUB_OBJECTS_ONLY_INHERIT     The specific access permissions will only be inherited
//                              by objects created within the specific container.
//                              The access permissions will not be applied to the
//                              container itself.
// SUB_CONTAINERS_AND_OBJECTS_INHERIT   The specific access permissions will be
//                                      inherited by containers created within the
//                                      specific container, will be applied to
//                                      objects created within the container, but
//                                      will not be applied to the container itself.
//
#define NO_INHERITANCE 0x0
#define SUB_OBJECTS_ONLY_INHERIT            0x1
#define SUB_CONTAINERS_ONLY_INHERIT         0x2
#define SUB_CONTAINERS_AND_OBJECTS_INHERIT  0x3
#define INHERIT_NO_PROPAGATE                0x4
#define INHERIT_ONLY                        0x8

//
// Informational bit that is returned
//
#define INHERITED_ACCESS_ENTRY              0x10

//
// Informational bit that tells where a node was inherited from.  Valid only
// for NT 5 APIs
//
#define INHERITED_PARENT                    0x10000000
#define INHERITED_GRANDPARENT               0x20000000


//
// Definition:
// This enumerated type defines the objects supported by the get/set API within
// this document.  See section 3.1, Object Types for a detailed definition of the
// supported object types, and their name formats.
//
typedef enum _SE_OBJECT_TYPE
{
    SE_UNKNOWN_OBJECT_TYPE = 0,
    SE_FILE_OBJECT,
    SE_SERVICE,
    SE_PRINTER,
    SE_REGISTRY_KEY,
    SE_LMSHARE,
    SE_KERNEL_OBJECT,
    SE_WINDOW_OBJECT,
    SE_DS_OBJECT,
    SE_DS_OBJECT_ALL,
    SE_PROVIDER_DEFINED_OBJECT
} SE_OBJECT_TYPE;


//
// Definition: EXPLICIT_ACCESS
// This structure is used to pass access control entry information into and out
// of the system using the API defined in this document.
// grfAccessPermissions - This contains the access permissions to assign for the
//                     trustee.  It is in the form of an NT access mask.
// grfAccessMode - This field defines how the permissions are to be applied for
//                 the trustee.
// grfInheritance - For containers, this field defines how the access control
//                  entry is/(is requested) to be inherited on
//                  objects/sub-containers created within the container.
// Trustee - This field contains the definition of the trustee account the
//           explicit access applies to.
//

typedef struct _EXPLICIT_ACCESS_A
{
    DWORD        grfAccessPermissions;
    ACCESS_MODE  grfAccessMode;
    DWORD        grfInheritance;
    TRUSTEE_A    Trustee;
} EXPLICIT_ACCESS_A, *PEXPLICIT_ACCESS_A, EXPLICIT_ACCESSA, *PEXPLICIT_ACCESSA;
typedef struct _EXPLICIT_ACCESS_W
{
    DWORD        grfAccessPermissions;
    ACCESS_MODE  grfAccessMode;
    DWORD        grfInheritance;
    TRUSTEE_W    Trustee;
} EXPLICIT_ACCESS_W, *PEXPLICIT_ACCESS_W, EXPLICIT_ACCESSW, *PEXPLICIT_ACCESSW;
#ifdef UNICODE
typedef EXPLICIT_ACCESS_W EXPLICIT_ACCESS_;
typedef PEXPLICIT_ACCESS_W PEXPLICIT_ACCESS_;
typedef EXPLICIT_ACCESSW EXPLICIT_ACCESS;
typedef PEXPLICIT_ACCESSW PEXPLICIT_ACCESS;
#else
typedef EXPLICIT_ACCESS_A EXPLICIT_ACCESS_;
typedef PEXPLICIT_ACCESS_A PEXPLICIT_ACCESS_;
typedef EXPLICIT_ACCESSA EXPLICIT_ACCESS;
typedef PEXPLICIT_ACCESSA PEXPLICIT_ACCESS;
#endif // UNICODE



//----------------------------------------------------------------------------
//
//                                  NT5 APIs
//
//----------------------------------------------------------------------------

//
// Default provider
//
#define ACCCTRL_DEFAULT_PROVIDER  TEXT("Windows NT Access Provider")

//
/// Access rights
//
typedef     ULONG   ACCESS_RIGHTS, *PACCESS_RIGHTS;

//
// Inheritance flags
//
typedef ULONG INHERIT_FLAGS, *PINHERIT_FLAGS;


//
// Access / Audit structures
//
typedef struct _ACTRL_ACCESS_ENTRYA
{
    TRUSTEE_A       Trustee;
    ULONG           fAccessFlags;
    ACCESS_RIGHTS   Access;
    ACCESS_RIGHTS   ProvSpecificAccess;
    INHERIT_FLAGS   Inheritance;
    LPSTR           lpInheritProperty;
} ACTRL_ACCESS_ENTRYA, *PACTRL_ACCESS_ENTRYA;
//
// Access / Audit structures
//
typedef struct _ACTRL_ACCESS_ENTRYW
{
    TRUSTEE_W       Trustee;
    ULONG           fAccessFlags;
    ACCESS_RIGHTS   Access;
    ACCESS_RIGHTS   ProvSpecificAccess;
    INHERIT_FLAGS   Inheritance;
    LPWSTR          lpInheritProperty;
} ACTRL_ACCESS_ENTRYW, *PACTRL_ACCESS_ENTRYW;
#ifdef UNICODE
typedef ACTRL_ACCESS_ENTRYW ACTRL_ACCESS_ENTRY;
typedef PACTRL_ACCESS_ENTRYW PACTRL_ACCESS_ENTRY;
#else
typedef ACTRL_ACCESS_ENTRYA ACTRL_ACCESS_ENTRY;
typedef PACTRL_ACCESS_ENTRYA PACTRL_ACCESS_ENTRY;
#endif // UNICODE



typedef struct _ACTRL_ACCESS_ENTRY_LISTA
{
    ULONG                   cEntries;
#ifdef __midl
    [size_is(cEntries)]
#endif
    ACTRL_ACCESS_ENTRYA    *pAccessList;
} ACTRL_ACCESS_ENTRY_LISTA, *PACTRL_ACCESS_ENTRY_LISTA;
typedef struct _ACTRL_ACCESS_ENTRY_LISTW
{
    ULONG                   cEntries;
#ifdef __midl
    [size_is(cEntries)]
#endif
    ACTRL_ACCESS_ENTRYW    *pAccessList;
} ACTRL_ACCESS_ENTRY_LISTW, *PACTRL_ACCESS_ENTRY_LISTW;
#ifdef UNICODE
typedef ACTRL_ACCESS_ENTRY_LISTW ACTRL_ACCESS_ENTRY_LIST;
typedef PACTRL_ACCESS_ENTRY_LISTW PACTRL_ACCESS_ENTRY_LIST;
#else
typedef ACTRL_ACCESS_ENTRY_LISTA ACTRL_ACCESS_ENTRY_LIST;
typedef PACTRL_ACCESS_ENTRY_LISTA PACTRL_ACCESS_ENTRY_LIST;
#endif // UNICODE



typedef struct _ACTRL_PROPERTY_ENTRYA
{
    LPSTR                       lpProperty;
    PACTRL_ACCESS_ENTRY_LISTA   pAccessEntryList;
    ULONG                       fListFlags;
} ACTRL_PROPERTY_ENTRYA, *PACTRL_PROPERTY_ENTRYA;
typedef struct _ACTRL_PROPERTY_ENTRYW
{
    LPWSTR                      lpProperty;
    PACTRL_ACCESS_ENTRY_LISTW   pAccessEntryList;
    ULONG                       fListFlags;
} ACTRL_PROPERTY_ENTRYW, *PACTRL_PROPERTY_ENTRYW;
#ifdef UNICODE
typedef ACTRL_PROPERTY_ENTRYW ACTRL_PROPERTY_ENTRY;
typedef PACTRL_PROPERTY_ENTRYW PACTRL_PROPERTY_ENTRY;
#else
typedef ACTRL_PROPERTY_ENTRYA ACTRL_PROPERTY_ENTRY;
typedef PACTRL_PROPERTY_ENTRYA PACTRL_PROPERTY_ENTRY;
#endif // UNICODE



typedef struct _ACTRL_ALISTA
{
    ULONG                       cEntries;
#ifdef __midl
    [size_is(cEntries)]
#endif
    PACTRL_PROPERTY_ENTRYA      pPropertyAccessList;
} ACTRL_ACCESSA, *PACTRL_ACCESSA, ACTRL_AUDITA, *PACTRL_AUDITA;
typedef struct _ACTRL_ALISTW
{
    ULONG                       cEntries;
#ifdef __midl
    [size_is(cEntries)]
#endif
    PACTRL_PROPERTY_ENTRYW      pPropertyAccessList;
} ACTRL_ACCESSW, *PACTRL_ACCESSW, ACTRL_AUDITW, *PACTRL_AUDITW;
#ifdef UNICODE
typedef ACTRL_ACCESSW ACTRL_ACCESS;
typedef PACTRL_ACCESSW PACTRL_ACCESS;
typedef ACTRL_AUDITW ACTRL_AUDIT;
typedef PACTRL_AUDITW PACTRL_AUDIT;
#else
typedef ACTRL_ACCESSA ACTRL_ACCESS;
typedef PACTRL_ACCESSA PACTRL_ACCESS;
typedef ACTRL_AUDITA ACTRL_AUDIT;
typedef PACTRL_AUDITA PACTRL_AUDIT;
#endif // UNICODE



//
// TRUSTEE_ACCESS flags
//
#define TRUSTEE_ACCESS_ALLOWED      0x00000001L
#define TRUSTEE_ACCESS_READ         0x00000002L
#define TRUSTEE_ACCESS_WRITE        0x00000004L

#define TRUSTEE_ACCESS_EXPLICIT     0x00000001L
#define TRUSTEE_ACCESS_READ_WRITE   (TRUSTEE_ACCESS_READ |                  \
                                     TRUSTEE_ACCESS_WRITE)


#define TRUSTEE_ACCESS_ALL          0xFFFFFFFFL

typedef struct _TRUSTEE_ACCESSA
{
    LPSTR           lpProperty;
    ACCESS_RIGHTS   Access;
    ULONG           fAccessFlags;
    ULONG           fReturnedAccess;
} TRUSTEE_ACCESSA, *PTRUSTEE_ACCESSA;
typedef struct _TRUSTEE_ACCESSW
{
    LPWSTR          lpProperty;
    ACCESS_RIGHTS   Access;
    ULONG           fAccessFlags;
    ULONG           fReturnedAccess;
} TRUSTEE_ACCESSW, *PTRUSTEE_ACCESSW;
#ifdef UNICODE
typedef TRUSTEE_ACCESSW TRUSTEE_ACCESS;
typedef PTRUSTEE_ACCESSW PTRUSTEE_ACCESS;
#else
typedef TRUSTEE_ACCESSA TRUSTEE_ACCESS;
typedef PTRUSTEE_ACCESSA PTRUSTEE_ACCESS;
#endif // UNICODE



//
// Generic permission values
//
#define ACTRL_RESERVED          0x00000000
#define ACTRL_PERM_1            0x00000001
#define ACTRL_PERM_2            0x00000002
#define ACTRL_PERM_3            0x00000004
#define ACTRL_PERM_4            0x00000008
#define ACTRL_PERM_5            0x00000010
#define ACTRL_PERM_6            0x00000020
#define ACTRL_PERM_7            0x00000040
#define ACTRL_PERM_8            0x00000080
#define ACTRL_PERM_9            0x00000100
#define ACTRL_PERM_10           0x00000200
#define ACTRL_PERM_11           0x00000400
#define ACTRL_PERM_12           0x00000800
#define ACTRL_PERM_13           0x00001000
#define ACTRL_PERM_14           0x00002000
#define ACTRL_PERM_15           0x00004000
#define ACTRL_PERM_16           0x00008000
#define ACTRL_PERM_17           0x00010000
#define ACTRL_PERM_18           0x00020000
#define ACTRL_PERM_19           0x00040000
#define ACTRL_PERM_20           0x00080000

//
// Access permissions
//
#define ACTRL_ACCESS_ALLOWED        0x00000001
#define ACTRL_ACCESS_DENIED         0x00000002
#define ACTRL_AUDIT_SUCCESS         0x00000004
#define ACTRL_AUDIT_FAILURE         0x00000008

//
// Property list flags
//
#define ACTRL_ACCESS_PROTECTED      0x00000001

//
// Standard and object rights
//
#define ACTRL_SYSTEM_ACCESS         0x04000000
#define ACTRL_DELETE                0x08000000
#define ACTRL_READ_CONTROL          0x10000000
#define ACTRL_CHANGE_ACCESS         0x20000000
#define ACTRL_CHANGE_OWNER          0x40000000
#define ACTRL_SYNCHRONIZE           0x80000000
#define ACTRL_STD_RIGHTS_ALL        0xf8000000

#define ACTRL_DS_OPEN                           ACTRL_RESERVED
#define ACTRL_DS_CREATE_CHILD                   ACTRL_PERM_1
#define ACTRL_DS_DELETE_CHILD                   ACTRL_PERM_2
#define ACTRL_DS_LIST                           ACTRL_PERM_3
#define ACTRL_DS_SELF                           ACTRL_PERM_4
#define ACTRL_DS_READ_PROP                      ACTRL_PERM_5
#define ACTRL_DS_WRITE_PROP                     ACTRL_PERM_6
#define ACTRL_FILE_READ                         ACTRL_PERM_1
#define ACTRL_FILE_WRITE                        ACTRL_PERM_2
#define ACTRL_FILE_APPEND                       ACTRL_PERM_3
#define ACTRL_FILE_READ_PROP                    ACTRL_PERM_4
#define ACTRL_FILE_WRITE_PROP                   ACTRL_PERM_5
#define ACTRL_FILE_EXECUTE                      ACTRL_PERM_6
#define ACTRL_FILE_READ_ATTRIB                  ACTRL_PERM_7
#define ACTRL_FILE_WRITE_ATTRIB                 ACTRL_PERM_8
#define ACTRL_DIR_LIST                          ACTRL_PERM_1
#define ACTRL_DIR_CREATE_OBJECT                 ACTRL_PERM_2
#define ACTRL_DIR_CREATE_CHILD                  ACTRL_PERM_3
#define ACTRL_DIR_DELETE_CHILD                  ACTRL_PERM_4
#define ACTRL_DIR_TRAVERSE                      ACTRL_PERM_6
#define ACTRL_KERNEL_TERMINATE                  ACTRL_PERM_1
#define ACTRL_KERNEL_THREAD                     ACTRL_PERM_2
#define ACTRL_KERNEL_VM                         ACTRL_PERM_3
#define ACTRL_KERNEL_VM_READ                    ACTRL_PERM_4
#define ACTRL_KERNEL_VM_WRITE                   ACTRL_PERM_5
#define ACTRL_KERNEL_DUP_HANDLE                 ACTRL_PERM_6
#define ACTRL_KERNEL_PROCESS                    ACTRL_PERM_7
#define ACTRL_KERNEL_SET_INFO                   ACTRL_PERM_8
#define ACTRL_KERNEL_GET_INFO                   ACTRL_PERM_9
#define ACTRL_KERNEL_CONTROL                    ACTRL_PERM_10
#define ACTRL_KERNEL_ALERT                      ACTRL_PERM_11
#define ACTRL_KERNEL_GET_CONTEXT                ACTRL_PERM_12
#define ACTRL_KERNEL_SET_CONTEXT                ACTRL_PERM_13
#define ACTRL_KERNEL_TOKEN                      ACTRL_PERM_14
#define ACTRL_KERNEL_IMPERSONATE                ACTRL_PERM_15
#define ACTRL_KERNEL_DIMPERSONATE               ACTRL_PERM_16
#define ACTRL_PRINT_SADMIN                      ACTRL_PERM_1
#define ACTRL_PRINT_SLIST                       ACTRL_PERM_2
#define ACTRL_PRINT_PADMIN                      ACTRL_PERM_3
#define ACTRL_PRINT_PUSE                        ACTRL_PERM_4
#define ACTRL_PRINT_JADMIN                      ACTRL_PERM_5
#define ACTRL_SVC_GET_INFO                      ACTRL_PERM_1
#define ACTRL_SVC_SET_INFO                      ACTRL_PERM_2
#define ACTRL_SVC_STATUS                        ACTRL_PERM_3
#define ACTRL_SVC_LIST                          ACTRL_PERM_4
#define ACTRL_SVC_START                         ACTRL_PERM_5
#define ACTRL_SVC_STOP                          ACTRL_PERM_6
#define ACTRL_SVC_PAUSE                         ACTRL_PERM_7
#define ACTRL_SVC_INTERROGATE                   ACTRL_PERM_8
#define ACTRL_SVC_UCONTROL                      ACTRL_PERM_9
#define ACTRL_REG_QUERY                         ACTRL_PERM_1
#define ACTRL_REG_SET                           ACTRL_PERM_2
#define ACTRL_REG_CREATE_CHILD                  ACTRL_PERM_3
#define ACTRL_REG_LIST                          ACTRL_PERM_4
#define ACTRL_REG_NOTIFY                        ACTRL_PERM_5
#define ACTRL_REG_LINK                          ACTRL_PERM_6
#define ACTRL_WIN_CLIPBRD                       ACTRL_PERM_1
#define ACTRL_WIN_GLOBAL_ATOMS                  ACTRL_PERM_2
#define ACTRL_WIN_CREATE                        ACTRL_PERM_3
#define ACTRL_WIN_LIST_DESK                     ACTRL_PERM_4
#define ACTRL_WIN_LIST                          ACTRL_PERM_5
#define ACTRL_WIN_READ_ATTRIBS                  ACTRL_PERM_6
#define ACTRL_WIN_WRITE_ATTRIBS                 ACTRL_PERM_7
#define ACTRL_WIN_SCREEN                        ACTRL_PERM_8
#define ACTRL_WIN_EXIT                          ACTRL_PERM_9




typedef struct _ACTRL_OVERLAPPED
{
    ULONG       Reserved1;
    ULONG       Reserved2;
    HANDLE      hEvent;

} ACTRL_OVERLAPPED, *PACTRL_OVERLAPPED;

typedef struct _ACTRL_ACCESS_INFOA
{
    ULONG       fAccessPermission;
    LPSTR       lpAccessPermissionName;
} ACTRL_ACCESS_INFOA, *PACTRL_ACCESS_INFOA;
typedef struct _ACTRL_ACCESS_INFOW
{
    ULONG       fAccessPermission;
    LPWSTR      lpAccessPermissionName;
} ACTRL_ACCESS_INFOW, *PACTRL_ACCESS_INFOW;
#ifdef UNICODE
typedef ACTRL_ACCESS_INFOW ACTRL_ACCESS_INFO;
typedef PACTRL_ACCESS_INFOW PACTRL_ACCESS_INFO;
#else
typedef ACTRL_ACCESS_INFOA ACTRL_ACCESS_INFO;
typedef PACTRL_ACCESS_INFOA PACTRL_ACCESS_INFO;
#endif // UNICODE

typedef struct _ACTRL_CONTROL_INFOA
{
    LPSTR  	    lpControlId;
	LPSTR  	    lpControlName;
} ACTRL_CONTROL_INFOA, *PACTRL_CONTROL_INFOA;
typedef struct _ACTRL_CONTROL_INFOW
{
    LPWSTR 	    lpControlId;
	LPWSTR 	    lpControlName;
} ACTRL_CONTROL_INFOW, *PACTRL_CONTROL_INFOW;
#ifdef UNICODE
typedef ACTRL_CONTROL_INFOW ACTRL_CONTROL_INFO;
typedef PACTRL_CONTROL_INFOW PACTRL_CONTROL_INFO;
#else
typedef ACTRL_CONTROL_INFOA ACTRL_CONTROL_INFO;
typedef PACTRL_CONTROL_INFOA PACTRL_CONTROL_INFO;
#endif // UNICODE


#define ACTRL_ACCESS_NO_OPTIONS                 0x00000000
#define ACTRL_ACCESS_SUPPORTS_OBJECT_ENTRIES    0x00000001


#ifdef __cplusplus
}
#endif

#endif // __ACCESS_CONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\80211hdr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    80211hdr.h

Abstract:

    802.11


--*/

#ifndef __802_11_HDR_H__
#define __802_11_HDR_H__

#pragma once

//
// Definitions for IEEE 802.11 packet headers
//
#include <packon.h>

#ifndef __WINDOWS__
#include <windows.h>
#endif

#ifndef __WINDOT11_H__
#include <windot11.h>
#endif

#define DOT11_ADDRESS_SIZE 6

#define DOT11_CURRENT_VERSION  0

#define DOT11_MAX_MSDU_SIZE     (2346U)

typedef enum {
    DOT11_FRAME_TYPE_MANAGEMENT = 0,
    DOT11_FRAME_TYPE_CONTROL = 1,
    DOT11_FRAME_TYPE_DATA = 2,
    DOT11_FRAME_TYPE_RESERVED = 3,
} DOT11_FRAME_TYPE, * PDOT11_FRAME_TYPE;

typedef enum {
    DOT11_MGMT_SUBTYPE_ASSOCIATION_REQUEST = 0,    // Association Request
    DOT11_MGMT_SUBTYPE_ASSOCIATION_RESPONSE = 1,   // Association Response
    DOT11_MGMT_SUBTYPE_REASSOCIATION_REQUEST = 2,  // Ressociation Request
    DOT11_MGMT_SUBTYPE_REASSOCIATION_RESPONSE = 3, // Reassociation Response
    DOT11_MGMT_SUBTYPE_PROBE_REQUEST = 4,          // Probe Request
    DOT11_MGMT_SUBTYPE_PROBE_RESPONSE = 5,         // Probe Response

    DOT11_MGMT_SUBTYPE_BEACON = 8,                 // Beacon
    DOT11_MGMT_SUBTYPE_ATIM = 9,                   // Announcement Traffic Indication Message (ATIM)
    DOT11_MGMT_SUBTYPE_DISASSOCIATION = 10,        // Disassociation
    DOT11_MGMT_SUBTYPE_AUTHENTICATION = 11,        // Authentication
    DOT11_MGMT_SUBTYPE_DEAUTHENTICATION = 12,      // Deauthentication
    DOT11_MGMT_SUBTYPE_MANAGEMENT_ACTION = 13,     // Management Action
} DOT11_MGMT_SUBTYPE, * PDOT11_MGMT_SUBTYPE;

typedef enum {
    DOT11_CTRL_SUBTYPE_PS_POLL = 10,   // Power Save Poll
    DOT11_CTRL_SUBTYPE_RTS = 11,       // Request To Send
    DOT11_CTRL_SUBTYPE_CTS = 12,       // Clear To Send
    DOT11_CTRL_SUBTYPE_ACK = 13,       // Acknowledgement
    DOT11_CTRL_SUBTYPE_CFE = 14,       // Contention-Free-End
    DOT11_CTRL_SUBTYPE_CFE_CFA = 15    // CF-End + CF-Ack

} DOT11_CTRL_SUBTYPE, * PDOT11_CTRL_SUBTYPE;

typedef enum {
    DOT11_DATA_SUBTYPE_CFA_FLAG = 1,        // CF-ACK flag
    DOT11_DATA_SUBTYPE_CFP_FLAG = 2,        // CF-Poll flag
    DOT11_DATA_SUBTYPE_NULL_FLAG = 4,       // NULL data flag
    DOT11_DATA_SUBTYPE_QOS_FLAG = 8,        // QoS Flag

    // DATA:                                0 (0000)
    DOT11_DATA_SUBTYPE_DATA = 0,

    // DATA + CF-Ack                        1 (0001)
    DOT11_DATA_SUBTYPE_DATA_CFA = (DOT11_DATA_SUBTYPE_CFA_FLAG),

    // DATA + CF-Poll                       2 (0010)
    DOT11_DATA_SUBTYPE_DATA_CFP = (DOT11_DATA_SUBTYPE_CFP_FLAG),

    // Data + CF-Ack + CF-Poll              3 (0011)
    DOT11_DATA_SUBTYPE_DATA_CFA_CFP = (DOT11_DATA_SUBTYPE_CFA_FLAG | DOT11_DATA_SUBTYPE_CFP_FLAG),


    // NULL                                 4 (0100)
    DOT11_DATA_SUBTYPE_NULL = (DOT11_DATA_SUBTYPE_NULL_FLAG),

    // NULL + CF-Ack                        5 (0101)
    DOT11_DATA_SUBTYPE_NULL_CFA = (DOT11_DATA_SUBTYPE_NULL_FLAG | DOT11_DATA_SUBTYPE_CFA_FLAG),

    // NULL + CF-Poll                       6 (0110)
    DOT11_DATA_SUBTYPE_NULL_CFP = (DOT11_DATA_SUBTYPE_NULL_FLAG | DOT11_DATA_SUBTYPE_CFP_FLAG),

    // NULL + CF-Ack + CF-Poll              7 (0111)
    DOT11_DATA_SUBTYPE_NULL_CFA_CFP = (DOT11_DATA_SUBTYPE_NULL_FLAG | DOT11_DATA_SUBTYPE_DATA_CFA_CFP),

    // QOS Data                             8 (1000)
    DOT11_DATA_SUBTYPE_QOS_DATA = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_DATA),

    // QOS Data + CF-Ack                    9 (1001)
    DOT11_DATA_SUBTYPE_QOS_CFA = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_DATA_CFA),

    // QOS Data + CF-Poll                   a (1010)
    DOT11_DATA_SUBTYPE_QOS_DATA_CFP = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_DATA_CFP),

    // QOS Data + CF-Ack + CF-Poll          b (1011)
    DOT11_DATA_SUBTYPE_QOS_DATA_CFA_CFP = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_DATA_CFA_CFP),

    // QOS Null                             c (1100)
    DOT11_DATA_SUBTYPE_QOS_NULL = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_NULL),

    // Reserved                             d (1101)
    DOT11_DATA_SUBTYPE_RESERVED = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_NULL_CFA),

    // QOS Null + CF-Poll                   e (1110)
    DOT11_DATA_SUBTYPE_QOS_NULL_CFP = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_NULL_CFP),

    // QOS Null + CF-Ack + CF-Poll          f (1111)
    DOT11_DATA_SUBTYPE_QOS_NULL_CFA_CFP = (DOT11_DATA_SUBTYPE_QOS_FLAG | DOT11_DATA_SUBTYPE_NULL_CFA_CFP)
} DOT11_DATA_SUBTYPE, * PDOT11_DATA_SUBTYPE;

typedef struct {
    USHORT  Version: 2;     // Protocol Version
    USHORT  Type: 2;
    USHORT  Subtype: 4;
    USHORT  ToDS: 1;
    USHORT  FromDS: 1;
    USHORT  MoreFrag: 1;
    USHORT  Retry: 1;
    USHORT  PwrMgt: 1;
    USHORT  MoreData: 1;
    USHORT  WEP: 1;
    USHORT  Order: 1;
} DOT11_FRAME_CTRL, * PDOT11_FRAME_CTRL;

typedef union {
    struct {
        USHORT  FragmentNumber: 4;
        USHORT  SequenceNumber: 12;
    };
    USHORT usValue;
} DOT11_SEQUENCE_CONTROL, * PDOT11_SEQUENCE_CONTROL;

typedef struct {
    USHORT  Eight02OneDTag: 3;
    USHORT  Reserved1: 2;
    USHORT  AckPolicy: 2;
    USHORT  Reserved2: 9;
} DOT11_QOS_CONTROL, * PDOT11_QOS_CONTROL;

typedef struct {
    UCHAR TID: 4;
    UCHAR EOSP: 1;
    UCHAR AckPolicy: 2;
    UCHAR Reserved2: 1;
    union {
        UCHAR TXOPLimit;
        UCHAR QAPPSBufferState;
        UCHAR TXOPRequestedDuration;
        UCHAR QueueSize;
    };
} DOT11_80211E_CONTROL, * PDOT11_80211E_CONTROL;

#define DOT11_QOS_CONTROL_HEADER_SIZE    sizeof(DOT11_QOS_CONTROL)

// Generic 802.11 header
typedef struct DOT11_MAC_HEADER {
    DOT11_FRAME_CTRL    FrameControl;
    USHORT              DurationID;
    DOT11_MAC_ADDRESS   Address1;
} DOT11_MAC_HEADER, * PDOT11_MAC_HEADER;

// For data frames, short header should be used
// when either FromDS=0 or ToDS=0
typedef struct DOT11_DATA_SHORT_HEADER {
    DOT11_FRAME_CTRL        FrameControl;
    USHORT                  DurationID;
    DOT11_MAC_ADDRESS       Address1;
    DOT11_MAC_ADDRESS       Address2;
    DOT11_MAC_ADDRESS       Address3;
    DOT11_SEQUENCE_CONTROL  SequenceControl;
} DOT11_DATA_SHORT_HEADER, * PDOT11_DATA_SHORT_HEADER;
#define DOT11_DATA_SHORT_HEADER_SIZE    sizeof(DOT11_DATA_SHORT_HEADER)

#ifdef UNDER_CE
#define PDOT11_FRAGMENT_MAC_HEADER  PDOT11_DATA_SHORT_HEADER
#define DOT11_FRAGMENT_MAC_HEADER   DOT11_DATA_SHORT_HEADER
#endif

// For data frames, long header should be used
// when both FromDS=1 and ToDS=1
typedef struct DOT11_DATA_LONG_HEADER {
    DOT11_FRAME_CTRL        FrameControl;
    USHORT                  DurationID;
    DOT11_MAC_ADDRESS       Address1;
    DOT11_MAC_ADDRESS       Address2;
    DOT11_MAC_ADDRESS       Address3;
    DOT11_SEQUENCE_CONTROL  SequenceControl;
    DOT11_MAC_ADDRESS       Address4;
} DOT11_DATA_LONG_HEADER, * PDOT11_DATA_LONG_HEADER;
#define DOT11_DATA_LONG_HEADER_SIZE     sizeof(DOT11_DATA_LONG_HEADER)

// For data frames, short header should be used
// when either FromDS=0 or ToDS=0
typedef struct DOT11_QOS_DATA_SHORT_HEADER {
    DOT11_FRAME_CTRL        FrameControl;
    USHORT                  DurationID;
    DOT11_MAC_ADDRESS       Address1;
    DOT11_MAC_ADDRESS       Address2;
    DOT11_MAC_ADDRESS       Address3;
    DOT11_SEQUENCE_CONTROL  SequenceControl;
    DOT11_QOS_CONTROL       QoSControl;
} DOT11_QOS_DATA_SHORT_HEADER, * PDOT11_QOS_DATA_SHORT_HEADER;
#define DOT11_QOS_DATA_SHORT_HEADER_SIZE    sizeof(DOT11_QOS_DATA_SHORT_HEADER)

// For data frames, long header should be used
// when both FromDS=1 and ToDS=1
typedef struct DOT11_QOS_QOS_DATA_LONG_HEADER {
    DOT11_FRAME_CTRL        FrameControl;
    USHORT                  DurationID;
    DOT11_MAC_ADDRESS       Address1;
    DOT11_MAC_ADDRESS       Address2;
    DOT11_MAC_ADDRESS       Address3;
    DOT11_SEQUENCE_CONTROL  SequenceControl;
    DOT11_MAC_ADDRESS       Address4;
    DOT11_QOS_CONTROL       QoSControl;
} DOT11_QOS_DATA_LONG_HEADER, * PDOT11_QOS_DATA_LONG_HEADER;
#define DOT11_QOS_DATA_LONG_HEADER_SIZE     sizeof(DOT11_QOS_DATA_LONG_HEADER)

// Mgmt frame header
typedef struct DOT11_MGMT_HEADER {
    DOT11_FRAME_CTRL        FrameControl;
    USHORT                  DurationID;
    DOT11_MAC_ADDRESS       DA;
    DOT11_MAC_ADDRESS       SA;
    DOT11_MAC_ADDRESS       BSSID;
    DOT11_SEQUENCE_CONTROL  SequenceControl;
} DOT11_MGMT_HEADER, * PDOT11_MGMT_HEADER;
#define DOT11_MGMT_HEADER_SIZE          sizeof(DOT11_MGMT_HEADER)

#ifdef UNDER_CE
#define DOT11_MGMT_FRAME_MAC_HEADER     DOT11_MGMT_HEADER
#define PDOT11_MGMT_FRAME_MAC_HEADER    PDOT11_MGMT_HEADER
#endif

// Ctrl frame header
typedef struct DOT11_CTRL_HEADER {
    DOT11_FRAME_CTRL    FrameControl;
    USHORT              DurationID;
    DOT11_MAC_ADDRESS   Address1;
} DOT11_CTRL_HEADER, * PDOT11_CTRL_HEADER;
#define DOT11_CTRL_HEADER_SIZE          sizeof(DOT11_CTRL_HEADER)

//
// Management Frame
//

typedef union {
    struct {
        USHORT          ESS: 1;
        USHORT          IBSS: 1;
        USHORT          CFPollable: 1;
        USHORT          CFPollRequest: 1;
        USHORT          Privacy: 1;
        USHORT          ShortPreamble: 1;
        USHORT          PBCC: 1;
        USHORT          ChannelAgility: 1;
        USHORT          Reserved: 2;
        USHORT          ShortSlotTime:1;
        USHORT          Reserved2: 2;
        USHORT          DSSSOFDM: 1;
        USHORT          Reserved3: 2;
    };

    USHORT usValue;

} DOT11_CAPABILITY, * PDOT11_CAPABILITY;

//
// Management Notification Frame
//
#define DOT11_MGMT_NOTIF_CATEGORY_CODE_WME   17

typedef enum _DOT11_MGMT_NOTIF_ACTION {
    dot11_mgmt_notif_action_setup_request = 0,
    dot11_mgmt_notif_action_setup_response = 1,
    dot11_mgmt_notif_action_setup_teardown = 2,
} DOT11_MGMT_NOTIF_ACTION, * PDOT11_MGMT_NOTIF_ACTION;

typedef enum _DOT11_MGMT_NOTIF_STATUS {
    dot11_mgmt_notif_status_admission_accepted = 0,
    dot11_mgmt_notif_status_invalid_parameters = 1,
    dot11_mgmt_notif_status_refused = 3,
} DOT11_MGMT_NOTIF_STATUS, * PDOT11_MGMT_NOTIF_STATUS;

typedef struct _DOT11_MGMT_NOTIFICATION {
    UCHAR ucCategoryCode;
    UCHAR ucActionCode;
    UCHAR ucDialogToken;
    UCHAR ucStatusCode;
} DOT11_MGMT_NOTIFICATION, * PDOT11_MGMT_NOTIFICATION;
#define DOT11_MGMT_NOTIFICATION_SIZE          sizeof(DOT11_MGMT_NOTIFICATION)


#define DOT11_INFO_ELEMENT_ID_SSID                  0
#define DOT11_INFO_ELEMENT_ID_SUPPORTED_RATES       1
#define DOT11_INFO_ELEMENT_ID_FH_PARAM_SET          2
#define DOT11_INFO_ELEMENT_ID_DS_PARAM_SET          3
#define DOT11_INFO_ELEMENT_ID_CF_PARAM_SET          4
#define DOT11_INFO_ELEMENT_ID_TIM                   5
#define DOT11_INFO_ELEMENT_ID_IBSS_PARAM_SET        6
#define DOT11_INFO_ELEMENT_ID_COUNTRY_INFO          7
#define DOT11_INFO_ELEMENT_ID_FH_PARAM              8
#define DOT11_INFO_ELEMENT_ID_FH_PATTERN_TABLE      9
#define DOT11_INFO_ELEMENT_ID_REQUESTED             10
#define DOT11_INFO_ELEMENT_ID_CHALLENGE             16
#define DOT11_INFO_ELEMENT_ID_ERP                   42
#define DOT11_INFO_ELEMENT_ID_HT_CAPABILITIES       45
#define DOT11_INFO_ELEMENT_ID_RSN                   48
#define DOT11_INFO_ELEMENT_ID_EXTD_SUPPORTED_RATES  50
#define DOT11_INFO_ELEMENT_ID_HT_INFO               61
#define DOT11_INFO_ELEMENT_ID_SECONDARY_CHANNEL_OFFSET  62
#define DOT11_INFO_ELEMENT_ID_VENDOR_SPECIFIC       221

typedef struct {
    UCHAR   ElementID;      // Element Id
    UCHAR   Length;         // Length of SSID
} DOT11_INFO_ELEMENT, * PDOT11_INFO_ELEMENT;
#define DOT11_IE_SSID_MAX_LENGTH    (DOT11_SSID_MAX_LENGTH + sizeof(DOT11_INFO_ELEMENT))
#define DOT11_IE_RATES_MAX_LENGTH   (8 + sizeof(DOT11_INFO_ELEMENT))

typedef union _DOT11_ERP_IE {
    struct {
        UCHAR           NonERPPresent: 1;
        UCHAR           UseProtection: 1;
        UCHAR           BarkerPreambleMode: 1;
        UCHAR           Reserved: 5;
    };
} DOT11_ERP_IE, * PDOT11_ERP_IE;

typedef union DOT11_OUI_HEADER {
    struct {
        UCHAR OUI[3];
        UCHAR Type;
    };
    UNALIGNED ULONG uValue;
} DOT11_OUI_HEADER, * PDOT11_OUI_HEADER;

typedef struct _DOT11_SSN_IE_SUITE {
    UCHAR   OUI[3];
    UCHAR   Type;
} DOT11_SSN_IE_SUITE, * PDOT11_SSN_IE_SUITE;

typedef struct _DOT11_SSN_IE_COUNT_SUITE {
    USHORT  SuiteCount;
    DOT11_SSN_IE_SUITE  dot11SSNIESuite[1];
} DOT11_SSN_IE_COUNT_SUITE, *PDOT11_SSN_IE_COUNT_SUITE;

typedef struct _DOT11_SSN_IE_HEADER {
    UCHAR   OUI[3];
    UCHAR   OUIType;
    USHORT  Version;
} DOT11_SSN_IE_HEADER, * PDOT11_SSN_IE_HEADER;

typedef struct DOT11_RSN_IE_HEADER {
    USHORT  Version;
} DOT11_RSN_IE_HEADER, * PDOT11_RSN_IE_HEADER;

typedef struct {
    USHORT          Reserved1: 1;
    USHORT          UnicastUsingGroup: 1;
    USHORT          ReplayIndexBit: 2;
    USHORT          Reserved2: 12;
} DOT11_SSN_CAPABILITY, * PDOT11_SSN_CAPABILITY;


//
// WME IE Struct Begin
//
typedef struct {
    UCHAR ParamSetCount: 4;
    UCHAR ReservedACInfoField: 4;
} DOT11_AC_INFO_FIELD, * PDOT11_AC_INFO_FIELD;

typedef struct{
        UCHAR AIFSN: 4;
        UCHAR ACM: 1;
        UCHAR ACI: 2;
        UCHAR ReservedACIAIFSN: 1;
} DOT11_ACI_AIFSN, * PDOT11_ACI_AIFSN;

typedef struct {
    UCHAR ECWmin: 4;
    UCHAR ECWmax: 4;
} DOT11_ECW, * PDOT11_ECW;

typedef struct {
#ifdef __cplusplus
    DOT11_ACI_AIFSN aifsn;
    DOT11_ECW ecw;
#else
    DOT11_ACI_AIFSN;
    DOT11_ECW;
#endif
    USHORT TXOPLimit;
} DOT11_AC_PARAMETERS, * PDOT11_AC_PARAMETERS;

typedef struct {
#ifdef __cplusplus
    DOT11_OUI_HEADER OuiHdr;
#else
    DOT11_OUI_HEADER;
#endif
    UCHAR OUISubType;
    UCHAR Version;
#ifdef __cplusplus
    DOT11_AC_INFO_FIELD ACInfo;
#else
    DOT11_AC_INFO_FIELD;
#endif
} DOT11_WME_IE, * PDOT11_WME_IE;

typedef struct {
#ifdef __cplusplus
    DOT11_WME_IE wmeie;
#else
    DOT11_WME_IE;
#endif
    UCHAR ReservedWMEParamIE;
    DOT11_AC_PARAMETERS dot11ACParams[dot11_AC_param_max];
} DOT11_WME_PARAM_IE, * PDOT11_WME_PARAM_IE;

//
// QoS TSPEC
//
typedef struct _DOT11_WME_TS_INFO {
    USHORT Reserved1: 1;
    USHORT Eight021DTag1: 3;
    USHORT UnusedZero: 1;
    USHORT Direction: 2;
    USHORT ContentionBasedAccess: 1;
    USHORT Reserved2: 3;
    USHORT Eight021DTag2: 3;
    USHORT Reserved3: 2;
} DOT11_WME_TS_INFO, * PDOT11_WME_TS_INFO;

typedef struct _DOT11_WME_NOMINAL_MSDU_SIZE {
    USHORT Size: 15;
    USHORT Fixed: 1;
} DOT11_WME_NOMINAL_MSDU_SIZE, * PDOT11_WME_NOMINAL_MSDU_SIZE;

typedef union _DOT11_WME_SURPLUS_BANDWIDTH_ALLOWANCE_FACTOR {
    struct {
        USHORT Decimal: 13;
        USHORT Integer: 3;
    };
    USHORT usValue;
} DOT11_WME_SURPLUS_BANDWIDTH_ALLOWANCE_FACTOR, * PDOT11_WME_SURPLUS_BANDWIDTH_ALLOWANCE_FACTOR;

typedef struct _DOT11_WME_TSPEC {
    DOT11_OUI_HEADER dot11OUIHeader;
    UCHAR OUISubType;
    UCHAR Version;
    DOT11_WME_TS_INFO dot11TSInfo;
    DOT11_WME_NOMINAL_MSDU_SIZE dot11NominalMSDUSize;
    USHORT usMaxMSDUSize;
    ULONG uMinServiceInterval;
    ULONG uMaxServiceInternal;
    ULONG uInactivityInterval;
    ULONG uServiceStartTime;
    ULONG uMinimumDataRate;
    ULONG uMeanDataRate;
    ULONG uMaxBurstSize;
    ULONG uMinPhyRate;
    ULONG uPeakDataRate;
    ULONG uDelayBound;
    DOT11_WME_SURPLUS_BANDWIDTH_ALLOWANCE_FACTOR dot11WMESurplusBandwidthAllowance;
    USHORT usMediumTime;
} DOT11_WME_TSPEC, * PDOT11_WME_TSPEC;

typedef union DOT11_HT_CAPABILITIES_INFO {
    struct {
        USHORT LDPCCoding: 1;               // LDPC coding capabilities
        USHORT SupportedChannelWidth: 1;    // Supported channel width set
        USHORT SMPowerSave: 2;  // SM Power Save
        USHORT ShortGI_20: 1;   // short GI for 20 MHz
        USHORT ShortGI_40: 1;   // short GI for 40 MHz
        USHORT TxSTBC: 1;
        USHORT RxSTBC: 2;
        USHORT HTDelayedBlockAck: 1;
        USHORT MaxAMSDULength: 1;
        USHORT DSSSCCK_40: 1;
        USHORT PSMP: 1;
        USHORT Intolerant_40: 1;        // 40 MHz intolerant
        USHORT LSIGTXOPProtection: 1;
    };

    USHORT Value;
} DOT11_HT_CAPABILITIES_INFO, * PDOT11_HT_CAPABILITIES_INFO;

typedef struct DOT11_MCS_SET {
    ULONGLONG RxMCSBitmask00_63;

    ULONG RxMCSBitmask64_76: 13;
    ULONG Reserved_77: 3;
    ULONG HighestSupportedRate: 10;
    ULONG Reserved_90: 6;

    ULONG TxMCSSetDefined: 1;
    ULONG TxRxMCSSetNotEqual: 1;
    ULONG TxMaxNumSpatialStreamsSupported: 2;
    ULONG TxUnequalModulationSupported: 1;
    ULONG Reserved_101: 27;
} DOT11_MCS_SET, * PDOT11_MCS_SET;

typedef union DOT11_HT_EXT_CAPABILITIES {
    struct {
        USHORT PCO: 1;
        USHORT PCOTransTime: 2;
        USHORT Rserved_3: 5;
        USHORT MCSFeedback: 2;
        USHORT HTCSupport: 1;
        USHORT RDResponder: 1;
        USHORT Reserved_12: 4;
    };

    USHORT Value;
} DOT11_HT_EXT_CAPABILITIES, * PDOT11_HT_EXT_CAPABILITIES;

typedef union DOT11_TX_BEAMFORMING_CAPABILITIES {
    struct {
        ULONG ImplicitTxBFRxCapable: 1;

        ULONG RxStaggeredSoundingCapable: 1;
        ULONG TxStaggeredSoundingCapable: 1;

        ULONG RxNDPCapable: 1;
        ULONG TxNDPCapable: 1;

        ULONG ImplicitTxBFCapable: 1;
        ULONG Calibration: 2;

        ULONG ExplicitCSITxBFCapable: 1;
        ULONG ExplicitNonCompressedBFFeedbackMatrixCapable: 1;
        ULONG ExplicitCompressedBFFeedbackMatrixCapable: 1;

        ULONG ExplicitTxBFCSIFeedbackCapable: 1;

        ULONG ExplicitNonCompressedBFFeedbackMatrix: 2;
        ULONG ExplicitCompressedBFFeedbackMatrix: 2;

        ULONG MinimalGrouping: 2;

        ULONG CSINumBFAntennas: 2;
        ULONG NonCompressedBFFeedbackNumBFAntennas: 2;
        ULONG CompressedBFFeedbackNumBFAntennas: 2;

        ULONG CSIMaxNumRowsBFSupported: 2;

        ULONG ChannelEstimationCapability: 2;
        ULONG Reserved_29: 3;
    };

    ULONG Value;
} DOT11_TX_BEAMFORMING_CAPABILITIES, * PDOT11_TX_BEAMFORMING_CAPABILITIES;

typedef union DOT11_ANTENNA_SELECTION_CAPABILITIES {
    struct {
        UCHAR ASELCapable: 1;

        UCHAR ExplicitCSIFeedbackBasedTxASELCapable: 1;
        UCHAR AntennaIndicesFeedbackBasedTxASELCapable: 1;

        UCHAR ExplicitCSIFeedbackCapable: 1;
        UCHAR AntennaIndicesFeedbackCapable: 1;

        UCHAR RxASELCapable: 1;
        UCHAR TxSoundingPPDUCapable: 1;
        UCHAR Reserved_7: 1;
    };

    UCHAR Value;
} DOT11_ANTENNA_SELECTION_CAPABILITIES, * PDOT11_ANTENNA_SELECTION_CAPABILITIES;


typedef struct DOT11_HT_CAPABILITIES {
    DOT11_HT_CAPABILITIES_INFO Info;

    UCHAR AMSDUParam;

    DOT11_MCS_SET SupportedMCSSet;
    DOT11_HT_EXT_CAPABILITIES ExtendedCapabilities;
    DOT11_TX_BEAMFORMING_CAPABILITIES TxBFCapabilities;
    DOT11_ANTENNA_SELECTION_CAPABILITIES AntennaSelectionCapabilities;
} DOT11_HT_CAPABILITIES, * PDOT11_HT_CAPABILITIES;

//
//
//

typedef struct DOT11_BEACON_FRAME {
    ULONGLONG           Timestamp;      // the value of sender's TSFTIMER
    USHORT              BeaconInterval; // the number of time units between target beacon transmission times
    DOT11_CAPABILITY    Capability;
    DOT11_INFO_ELEMENT  InfoElements;
} DOT11_BEACON_FRAME, * PDOT11_BEACON_FRAME;

typedef ULONG DOT11_CRC, * PDOT11_CRC;

//
// Reason code
//

#define DOT11_MGMT_REASON_UPSPEC_REASON                 1
#define DOT11_MGMT_REASON_AUTH_NOT_VALID                2
#define DOT11_MGMT_REASON_DEAUTH_LEAVE_SS               3
#define DOT11_MGMT_REASON_INACTIVITY                    4
#define DOT11_MGMT_REASON_AP_OVERLOAD                   5
#define DOT11_MGMT_REASON_CLASS2_ERROR                  6
#define DOT11_MGMT_REASON_CLASS3_ERROR                  7
#define DOT11_MGMT_REASON_DISASSO_LEAVE_SS              8
#define DOT11_MGMT_REASON_ASSO_NOT_AUTH                 9
#define DOT11_MGMT_REASON_INVALID_IE                    13
#define DOT11_MGMT_REASON_MIC_FAILURE                   14
#define DOT11_MGMT_REASON_4WAY_HANDSHAKE_TIMEOUT        15
#define DOT11_MGMT_REASON_2WAY_HANDSHAKE_TIMEOUT        16
#define DOT11_MGMT_REASON_INCONSISTENT_IE               17
#define DOT11_MGMT_REASON_INVALID_GROUP_CIPHER          18
#define DOT11_MGMT_REASON_INVALID_PAIRWISE_CIPHER       19
#define DOT11_MGMT_REASON_INVALID_AKMP                  20
#define DOT11_MGMT_REASON_UNSUPPORTED_RSN_IE_VERSION    21
#define DOT11_MGMT_REASON_INVALID_RSN_IE_CAPABILITIES   22
#define DOT11_MGMT_REASON_1X_FAILURE                    23
#define DOT11_MGMT_REASON_CIPHER_SUITE_REJECTED         24

//
// The constants used in the Status Code fixed field in a frame
//

// Successful
#define DOT11_FRAME_STATUS_SUCCESSFUL                               0

// Unspecified Failure
#define DOT11_FRAME_STATUS_FAILURE                                  1

// Cannot support all requested capabilities in the Capability Information field
#define DOT11_FRAME_STATUS_UNSUPPORTED_CAPABILITIES                 10

// Reassociation denied due to inability to confirm that association exists
#define DOT11_FRAME_STATUS_REASSOC_DENIED                           11

// Association denied due to reason outside the scope of this standard
#define DOT11_FRAME_STATUS_ASSOC_DENIED                             12

// Responding station does not support the specified authentication algorithm
#define DOT11_FRAME_STATUS_UNSUPPORTED_AUTH_ALGO                    13

// Received an Authentication frame with authentication transaction
// sequence number out of expected sequence
#define DOT11_FRAME_STATUS_INVALID_AUTH_XID                         14

// Authentication rejected because of challenge failure
#define DOT11_FRAME_STATUS_INVALID_AUTH_CHALLENGE                   15

// Authenticaiton rejected due to timeout waiting for next frame in sequence
#define DOT11_FRAME_STATUS_AUTH_TIME_OUT                            16

// Association denied because AP is unable to handle additional associated stations
#define DOT11_FRAME_STATUS_ASSOC_DENIED_AP_BUSY                     17

// Association denied due to requesting station not supporting all of the data
// rates in the BSSBasicRateSet parameter
#define DOT11_FRAME_STATUS_ASSOC_DENIED_DATA_RATE_SET               18

// Association denied because short preamble not supported
#define DOT11_FRAME_STATUS_UNSUPPORTED_SHORT_PREAMBLE               19

// Association denied because PBCC not supported
#define DOT11_FRAME_STATUS_UNSUPPORTED_PBCC                         20

// Association denied because channel agility not supported
#define DOT11_FRAME_STATUS_UNSUPPORTED_CHANNEL_AGILITY              21

// Association denied because short slot time option not supported
#define DOT11_FRAME_STATUS_UNSUPPORTED_SHORT_SLOT_TIME              25

// Association denied because DSSS-OFDM option not supported
#define DOT11_FRAME_STATUS_UNSUPPORTED_DSSSOFDM                     26

// Invalid Information Element
#define DOT11_FRAME_STATUS_INVALID_IE                               40
#define DOT11_FRAME_STATUS_INVALID_GROUP_CIPHER                     41
#define DOT11_FRAME_STATUS_INVALID_PAIRWISE_CIPHER                  42
#define DOT11_FRAME_STATUS_INVALID_AKMP                             43
#define DOT11_FRAME_STATUS_UNSUPPORTED_RSN_IE_VERSION               44
#define DOT11_FRAME_STATUS_INVALID_RSN_IE_CAPABILITIES              45
#define DOT11_FRAME_STATUS_CIPHER_SUITE_REJECTED                    46

// Association denied because parent address list matching error (MSIE)
#define DOT11_FRAME_STATUS_PAL_ERROR                                30001


//
// The fixed part of an authentication frame
//

#define DOT11_AUTH_OPEN_SYSTEM  0
#define DOT11_AUTH_SHARED_KEY   1

typedef struct DOT11_AUTH_FRAME {
    USHORT usAlgorithmNumber;
    USHORT usXid;
    USHORT usStatusCode;
} DOT11_AUTH_FRAME, * PDOT11_AUTH_FRAME;

typedef struct _DOT11_DEAUTH_FRAME{
  USHORT    ReasonCode;
} DOT11_DEAUTH_FRAME, *PDOT11_DEAUTH_FRAME;

typedef struct DOT11_ASSOC_REQUEST_FRAME {
    DOT11_CAPABILITY Capability;
    USHORT usListenInterval;

    // SSID
    // Supported Rates

} DOT11_ASSOC_REQUEST_FRAME, * PDOT11_ASSOC_REQUEST_FRAME;

typedef struct DOT11_REASSOC_REQUEST_FRAME {
    DOT11_CAPABILITY Capability;
    USHORT usListenInterval;

    DOT11_MAC_ADDRESS CurrentAPAddress;

} DOT11_REASSOC_REQUEST_FRAME, * PDOT11_REASSOC_REQUEST_FRAME;

typedef struct DOT11_ASSOC_RESPONSE_FRAME {
    DOT11_CAPABILITY Capability;
    USHORT usStatusCode;
    USHORT usAID;

    // Supported Rates

} DOT11_ASSOC_RESPONSE_FRAME, * PDOT11_ASSOC_RESPONSE_FRAME;

typedef struct DOT11_REASSOC_RESPONSE_FRAME {
    DOT11_CAPABILITY Capability;
    USHORT usStatusCode;
    USHORT usAID;

    // Supported Rates

} DOT11_REASSOC_RESPONSE_FRAME, * PDOT11_REASSOC_RESPONSE_FRAME;

typedef struct DOT11_DISASSOC_FRAME {
    USHORT usReasonCode;
} DOT11_DISASSOC_FRAME, * PDOT11_DISASSOC_FRAME;


#include <packoff.h>


#endif // __802_11_HDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\activesync.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// ***************************************************************************
//  ActiveSync.h
//
//  Copyright 2004 Microsoft Corporation, All Rights Reserved
//
//  Public interface of the ActiveSync application
//
// ***************************************************************************

#ifndef __ACTIVE_SYNC_H__
#define __ACTIVE_SYNC_H__

#ifdef __cplusplus
extern "C" {
#endif

HRESULT ActiveSyncStart();
HRESULT ActiveSyncStop();

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\CePerf\Include\ceperf.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//------------------------------------------------------------------------------
//
//  Module Name:  
//  
//      ceperf.h
//  
//  Abstract:  
//
//      Windows CE Performance Measurement API
//      
//------------------------------------------------------------------------------


#ifndef _CEPERF_H_
#define _CEPERF_H_

#ifdef __cplusplus 
extern "C" { 
#endif 

    
#ifndef UNDER_CE
#ifndef GetProcAddressA
#define GetProcAddressA              GetProcAddress
#endif // GetProcAddressA
#endif // UNDER_CE

#ifndef ASSERT
#define ASSERT(x)
#endif // ASSERT


//==============================================================================
// CEPERF RETURN VALUES
//==============================================================================

// CEPERF is disabled
#define CEPERF_HR_DISABLED                  HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED)
// The CEPERF DLL is unavailable
#define CEPERF_HR_NO_DLL                    HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND)
// Unsupported feature: No CPU counter library or unimplemented feature
#define CEPERF_HR_NOT_SUPPORTED             HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)
// This HRESULT is returned when a CEPERF API call hits an exception, likely
// due to an invalid parameter
#define CEPERF_HR_EXCEPTION                 HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
// Invalid parameter passed to one of the APIs
#define CEPERF_HR_INVALID_PARAMETER         HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
// The session or item does not exist, or is of the wrong type
#define CEPERF_HR_INVALID_HANDLE            HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE)
// The session name is invalid, or no session by that name exists
#define CEPERF_HR_BAD_SESSION_NAME          HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME)
// QueryPerformanceCounter failed
#define CEPERF_HR_BAD_PERFCOUNT_DATA        HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
// LocalStatistic data is an unexpected size or could not be read
#define CEPERF_HR_BAD_LOCALSTATISTIC_DATA   HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
// CPU Performance Counter data is an unexpected size or could not be read
#define CEPERF_HR_BAD_CPUCOUNTER_DATA       HRESULT_FROM_WIN32(ERROR_INVALID_DATA)
// Failed to get a required lock: Necessary because all logging calls fail this
// case rather than block
#define CEPERF_HR_SHARING_VIOLATION         HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION)
// No data available because recording is disabled
#define CEPERF_HR_RECORDING_DISABLED        HRESULT_FROM_WIN32(ERROR_NO_DATA)
// No data available because storage is disabled
#define CEPERF_HR_STORAGE_DISABLED          HRESULT_FROM_WIN32(ERROR_CANCELLED)
// Out of space for holding session or item objects, or their discrete data.
#define CEPERF_HR_NOT_ENOUGH_MEMORY         HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)
// The Duration object doesn't have a begin recorded for this thread
#define CEPERF_HR_BEGIN_NOT_FOUND           HRESULT_FROM_WIN32(ERROR_INVALID_OWNER)
// A duplicate item already exists, with different settings
#define CEPERF_HR_ALREADY_EXISTS            HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)

// BACKWARD-COMPAT WITH OLD VALUES
#define CEPERF_HRDISABLED   CEPERF_HR_DISABLED
#define CEPERF_HRNODLL      CEPERF_HR_NO_DLL
#define CEPERF_HREXCEPTION  CEPERF_HR_EXCEPTION



//==============================================================================
// COMMON FLAGS
//==============================================================================

// Special flag used for session status flags, recording flags, storage flags.
// Used to default to settings in registry, or settings of parent session.
// Search algorithm is documented separately.
#define CEPERF_DEFAULT_FLAGS                0xFFFFFFFF


//------------------------------------------------------------------------------
// SESSION STATUS FLAGS

#define CEPERF_STATUS_RECORDING_ENABLED     0x00000001  // Record data as it is produced.  Discrete data will be recorded to RAM; continuous data will be recorded to storage location (if storage is enabled).
#define CEPERF_STATUS_RECORDING_DISABLED    0x00000002  // Don't record any data as it is produced.  No continuous or discrete data will be recorded, to RAM or to storage location.
#define CEPERF_STATUS_STORAGE_ENABLED       0x00000004  // Output data to storage location.  Discrete data will be output to storage during a flush; continuous data will be output to storage as it is recorded.
#define CEPERF_STATUS_STORAGE_DISABLED      0x00000008  // Don't output data to storage location.  Any continuous data will not be recorded.
#define CEPERF_STATUS_NOT_THREAD_SAFE       0x00000010  // Drop thread safety for extra performance boost


//------------------------------------------------------------------------------
// RECORDING FLAGS
// Divided into 16 bits of common flags and 16 bits of flags for each type of
// tracked item.

// Recording flags common to all tracked item types
#define CEPERF_RECORD_ABSOLUTE_TICKCOUNT    0x00010000  // Track overall running time in tick counts
#define CEPERF_RECORD_THREAD_TICKCOUNT      0x00020000  // Track thread running time in tick counts
#define CEPERF_RECORD_ABSOLUTE_PERFCOUNT    0x00040000  // Track overall running time in high-resolution performance counts
//#define CEPERF_RECORD_THREAD_PERFCOUNT      0x00080000  // Track thread running time in high-resolution performance counts
#define CEPERF_RECORD_ABSOLUTE_CPUPERFCTR   0x00100000  // Track overall change in CPU perf counters (eg. cache hits/misses, if available); may need to be configured before use
//#define CEPERF_RECORD_THREAD_CPUPERFCTR     0x00200000  // Track CPU perf counters while thread was running (eg. cache hits/misses, if available); may need to be configured before use

// Recording flags for Duration items - How to record performance counters
#define CEPERF_DURATION_RECORD_NONE         0x00000001  // Don't record any data
#define CEPERF_DURATION_RECORD_MIN          0x00000002  // (discrete) Record only min/max/average delta
//#define CEPERF_DURATION_RECORD_SHORT        0x00000004  // (continuous) Record list of deltas, to make it possible to calculate std.dev
#define CEPERF_DURATION_RECORD_FULL         0x00000008  // (continuous) Record all entry and exit events
//#define CEPERF_DURATION_RECORD_BUCKET       0x00000010  // (discrete) Record deltas in buckets (definition in extended info)
// Recording flags for Duration items - Begin/End semantics
#define CEPERF_DURATION_RECORD_UNLIMITED    0x00000020  // Unlimited number of "unended begins" at any time
#define CEPERF_DURATION_RECORD_SHARED       0x00000040  // All threads and processes share same "begin" instances,
                                                        // threads can end each other's begins.
#define CEPERF_DURATION_RECORD_TTRACKER     0x00000080  // Turn on the TTracker tool while this duration is in operation.
                                                        // It is only possible to have one TTracker duration in progress at once.
#define CEPERF_DURATION_RECORD_UNIQUE       0x00000100  // Only one active "unended begin" at a time.  Behavior modified by CEPERF_DURATION_UNIQUE_REPLACE_* flags.
#define CEPERF_DURATION_REPLACE_BEGIN       0x00000200  // When RECORD_UNIQUE is set: if REPLACE_BEGIN is set, a subsequent begin replaces the first one; if REPLACE_BEGIN is not set, the first begin is the only one that matters and all subsequent begins are ignored.
//#define CEPERF_DURATION_REPLACE_END         0x00000400  // When RECORD_UNIQUE is set: if REPLACE_END is set, a subsequent end replaces the first one; if REPLACE_END is not set, the first end is the only one that matters and all subsequent ends are ignored.

// Recording flags for Statistic items - How to record value changes
#define CEPERF_STATISTIC_RECORD_NONE        0x00000001  // Don't record any data
#define CEPERF_STATISTIC_RECORD_MIN         0x00000002  // (discrete) Record only current value
#define CEPERF_STATISTIC_RECORD_SHORT       0x00000004  // (discrete) Record min/max/average change
#define CEPERF_STATISTIC_RECORD_FULL        0x00000008  // (continuous) Record all modification events

// Recording flags for Local Statistic items - How to record value
#define CEPERF_LOCALSTATISTIC_RECORD_NONE   0x00000001  // Don't record any data
#define CEPERF_LOCALSTATISTIC_RECORD_MIN    0x00000002  // (discrete) Record only current value


//------------------------------------------------------------------------------
// STORAGE FLAGS

// Output locations.  Continuous data is written to the output location as it
// arrives; discrete data is written to the output location when data is flushed.
//#define CEPERF_STORE_RAM        0x00000001  // binary only; newest or oldest
#define CEPERF_STORE_FILE       0x00000002  // binary, text or CSV; oldest only
#define CEPERF_STORE_CELOG      0x00000004  // binary only; store!=newest
#define CEPERF_STORE_DEBUGOUT   0x00000008  // not binary; overflow=0
#define CEPERF_STORE_REGISTRY   0x00000010  // not binary; overflow=0
//#define CEPERF_STORE_PERFMON    0x00000020  // Remote Performance Monitor

// Output types
#define CEPERF_STORE_BINARY     0x00001000  // Store data in a compact data format (TBD)
#define CEPERF_STORE_TEXT       0x00002000  // Store data as human-readable text
#define CEPERF_STORE_CSV        0x00004000  // Store data as comma-separated text
    
// Control what happens when continuous data overflows the available storage in
// the output location.
//#define CEPERF_STORE_NEWEST     0x00010000  // Keep the newest data and discard the oldest
#define CEPERF_STORE_OLDEST     0x00020000  // Keep the oldest data and discard the newest
    

//------------------------------------------------------------------------------
// CONTROL FLAGS

// Session Control Flags
#define CEPERF_CONTROL_HIERARCHY        0x00000001  // Apply these settings to all sessions registered below the given session in the hierarchy

// CPU Status Flags
#define CEPERF_CPU_ENABLE               0x00000001  // Enable CPU performance counters
#define CEPERF_CPU_DISABLE              0x00000002  // Disable CPU performance counters

// CPU Recording Flags
#define CEPERF_CPU_TLB_MISSES           0x00010000  // Track TLB misses
//#define CEPERF_CPU_TLB_HITS             0x00020000  // Track TLB hits
#define CEPERF_CPU_ICACHE_MISSES        0x00040000  // Track instruction cache misses
#define CEPERF_CPU_ICACHE_HITS          0x00080000  // Track instruction cache hits
#define CEPERF_CPU_DCACHE_MISSES        0x00100000  // Track data cache misses
#define CEPERF_CPU_DCACHE_HITS          0x00200000  // Track data cache hits
#define CEPERF_CPU_INSTRUCTION_COUNT    0x00400000  // Track instruction count
#define CEPERF_CPU_CYCLE_COUNT          0x00800000  // Track cycle count

// Flush Flags
#define CEPERF_FLUSH_HIERARCHY          0x00000001  // Flush all sessions registered below the given session in the hierarchy
#define CEPERF_FLUSH_DESCRIPTORS        0x00000002  // Flush descriptors for all tracked items
//#define CEPERF_FLUSH_NEW_DESCRIPTORS    0x00000004  // Flush descriptors for tracked items that have changed since the previous flush
#define CEPERF_FLUSH_DATA               0x00000008  // Flush data for all tracked items
//#define CEPERF_FLUSH_NEW_DATA           0x00000010  // Flush data for tracked items that have changed since the previous flush
#define CEPERF_FLUSH_AND_CLEAR          0x00000020  // Clear data after it is flushed



//==============================================================================
// DATA TYPES
//==============================================================================

// Each tracked item has one of these types
typedef enum _CEPERF_ITEM_TYPE {
    CEPERF_TYPE_DURATION        = 0,
    CEPERF_TYPE_STATISTIC       = 1,
    CEPERF_TYPE_LOCALSTATISTIC  = 2,
//    CEPERF_TYPE_BUCKET          = 3,      // BUCKETS NYI
    
    //------------------------------------------------------------
    // IMPORTANT NOTE: Any time a new member is added to this
    // list, the version # for CEPERF_SESSION_INFO must be revved!
    //------------------------------------------------------------

    // This entry must always be last!
    CEPERF_NUMBER_OF_TYPES
} CEPERF_ITEM_TYPE;


// Extended control over a session's data production and storage.
typedef struct _CEPERF_SESSION_INFO {
    WORD   wVersion;            // Version of this struct, set to 1
    WORD   wReserved;
    DWORD  dwStorageFlags;      // Flags for controlling data storage
    LPWSTR lpszStoragePath;     // Pointer to path for storing data into, or NULL
    DWORD  rgdwRecordingFlags[CEPERF_NUMBER_OF_TYPES];  // Flags for 
                                // overriding recording mode for each type of 
                                // tracked item in the session (may be
                                // overridden by dynamic session control)
} CEPERF_SESSION_INFO;


#define CEPERF_MAX_ITEM_NAME_LEN  32

// This structure is used to bulk-register tracked items and makes it easy to 
// embed basic data within code.
// Only the most basic information is stored in this structure.
typedef struct _CEPERF_BASIC_ITEM_DESCRIPTOR {
    HANDLE hTrackedItem;        // Will be modified during bulk open/close
    CEPERF_ITEM_TYPE type;      // Type of item
    LPWSTR lpszItemName;        // Pointer to name of item
    DWORD  dwRecordingFlags;    // Flags for default recording mode (may be
                                // overridden by session defaults or dynamic
                                // session control)
} CEPERF_BASIC_ITEM_DESCRIPTOR;

// Helpful definitions for defining inline bulk items
#define CEPERF_DURATION_DESCRIPTOR(szName, dwRecordingFlags)                   \
    { INVALID_HANDLE_VALUE, CEPERF_TYPE_DURATION,  (szName), (dwRecordingFlags) }
#define CEPERF_STATISTIC_DESCRIPTOR(szName, dwRecordingFlags)                  \
    { INVALID_HANDLE_VALUE, CEPERF_TYPE_STATISTIC, (szName), (dwRecordingFlags) }


// Extended information about a tracked item
typedef struct _CEPERF_EXT_ITEM_DESCRIPTOR {
    WORD wVersion;           // Version of this struct, set to 1
    WORD wReserved;

    // Specific information for each item type
    union {
        struct {
            DWORD dwReserved1;  // Not used
            DWORD dwReserved2;  // Not used
        } Duration;

        struct {
            DWORD dwReserved1;  // Not used...  Maybe value size in bytes
            DWORD dwReserved2;  // Not used
        } Statistic;

        struct {
            LPVOID lpValue;     // Pointer to Local Statistic
            DWORD  dwValSize;   // Value size in bytes
        } LocalStatistic;
    
//        struct {              // BUCKETS NYI
//            DWORD dwLowVal;
//            DWORD dwHighVal;
//            DWORD dwNumIntervals;
//        } Bucket;
    };
} CEPERF_EXT_ITEM_DESCRIPTOR;


// Contains all data recorded for a tracked item, or for a single Duration period.
typedef struct _CEPERF_ITEM_DATA {
    WORD  wVersion;             // Version of this struct, set to 1
    WORD  wSize;                // Size of this struct and the CPU counter data following it
    
    union {
        struct {
            LARGE_INTEGER liPerfCount;  // Elapsed time delta from Begin call, in
                                        // high-frequency performance counter
                                        // ticks, if recorded
            LARGE_INTEGER liThreadTicks;// Thread run-time delta from Begin call,
                                        // in millisecond ticks, if recorded
            DWORD dwTickCount;          // Elapsed time delta from Begin call, in
                                        // millisecond ticks, if recorded
        
            // Followed by the CPU counter deltas, as defined in
            // pCPUCounterDescriptor, if the CPU counters are turned on and are
            // being recorded for this particular Duration item.  The item's
            // dwRecordingFlags say which counters are being tracked.  Only
            // those counters will be valid in this struct.
        } Duration;
        
        struct {
            ULARGE_INTEGER ulValue;     // Current value
        } Statistic;
        
        struct {
            DWORD dwReserved;           // Unused
        } LocalStatistic;
    };

} CEPERF_ITEM_DATA;



// Originally CePerf was designed so that you must specifically set CEPERF_ENABLE
// in order to add it to your code.  However as use became widespread, the flag
// was applied inconsistently across various deptrees.  To make usage more
// consistent, the necessity for that flag has been removed.  Now it is always
// enabled unless you explicitly define a new flag, CEPERF_DISABLE, to remove it.
// If you own code that still references CEPERF_ENABLE, you can now remove those
// references and expect the CePerf APIs to always be present.

#ifndef CEPERF_DISABLE

// Make sure CEPERF_ENABLE is defined for any code that includes this header,
// to support legacy code that has #ifdef's
#ifndef CEPERF_ENABLE
#define CEPERF_ENABLE
#endif


//==============================================================================
// GLOBALS
//==============================================================================

// Note: Should probably be "__declspec(selectany)" but that causes build breaks
// in various places - revisit in the future when we can clean the tree up.
extern LPVOID pCePerfInternal;



//==============================================================================
// EXCEPTION HANDLING
//==============================================================================

// You can set CEPERF_UNSAFE to disable exception handling, but do it with
// great caution -- you will be at risk of allowing CePerf.dll to bring your 
// logging application down!  Do not set CEPERF_UNSAFE in shipping code!

#ifdef CEPERF_UNSAFE
#define CEPERF_TRY
#define CEPERF_CATCH
#else
#define CEPERF_TRY      __try
#define CEPERF_CATCH    __except(EXCEPTION_EXECUTE_HANDLER) {;}
#endif // CEPERF_UNSAFE


//==============================================================================
// INTERNAL FUNCTIONS
//==============================================================================

typedef HRESULT (*PFN_CePerfOpenSession) (HANDLE, LPCWSTR, DWORD, const CEPERF_SESSION_INFO* lpInfo);
typedef HRESULT (*PFN_CePerfCloseSession) (HANDLE);
typedef HRESULT (*PFN_CePerfRegisterTrackedItem) (HANDLE, HANDLE*, CEPERF_ITEM_TYPE, LPCWSTR, DWORD, const CEPERF_EXT_ITEM_DESCRIPTOR*);
typedef HRESULT (*PFN_CePerfDeregisterTrackedItem) (HANDLE);
typedef HRESULT (*PFN_CePerfRegisterBulk) (HANDLE, CEPERF_BASIC_ITEM_DESCRIPTOR*, DWORD, DWORD);
typedef HRESULT (*PFN_CePerfDeregisterBulk) (CEPERF_BASIC_ITEM_DESCRIPTOR*, DWORD);
typedef HRESULT (*PFN_CePerfBeginDuration) (HANDLE);
typedef HRESULT (*PFN_CePerfIntermediateDuration) (HANDLE, CEPERF_ITEM_DATA*);
typedef HRESULT (*PFN_CePerfEndDurationWithInformation) (HANDLE, DWORD, const BYTE*, DWORD, CEPERF_ITEM_DATA*);
typedef HRESULT (*PFN_CePerfAddStatistic) (HANDLE, DWORD, CEPERF_ITEM_DATA*);
typedef HRESULT (*PFN_CePerfSetStatistic) (HANDLE, DWORD);
typedef HRESULT (*PFN_CePerfControlSession) (HANDLE, LPCWSTR, DWORD, DWORD, const CEPERF_SESSION_INFO*);
typedef HRESULT (*PFN_CePerfControlCPU) (DWORD, LPVOID, DWORD);
typedef HRESULT (*PFN_CePerfFlushSession) (HANDLE, LPCWSTR, DWORD, DWORD);


#define CEPERF_GLOBALS_VERSION 1

// Private struct that should not be used except within this header file
typedef struct _CePerfGlobals {
    DWORD   dwVersion;                      // Set to CEPERF_GLOBALS_VERSION
    DWORD   dwReserved;  // no longer used
    DWORD   dwCePerfDLLRefcount;

    PFN_CePerfOpenSession                   pCePerfOpenSession;
    PFN_CePerfCloseSession                  pCePerfCloseSession;
    PFN_CePerfRegisterTrackedItem           pCePerfRegisterTrackedItem;
    PFN_CePerfDeregisterTrackedItem         pCePerfDeregisterTrackedItem;
    PFN_CePerfRegisterBulk                  pCePerfRegisterBulk;
    PFN_CePerfDeregisterBulk                pCePerfDeregisterBulk;
    
    PFN_CePerfBeginDuration                 pCePerfBeginDuration;
    PFN_CePerfIntermediateDuration          pCePerfIntermediateDuration;
    PFN_CePerfEndDurationWithInformation    pCePerfEndDurationWithInformation;

    PFN_CePerfAddStatistic                  pCePerfAddStatistic;
    PFN_CePerfSetStatistic                  pCePerfSetStatistic;

    PFN_CePerfControlSession                pCePerfControlSession;
    PFN_CePerfControlCPU                    pCePerfControlCPU;
    PFN_CePerfFlushSession                  pCePerfFlushSession;
} CePerfGlobals;

typedef HRESULT (*PFN_CePerfInit) (CePerfGlobals**);
typedef HRESULT (*PFN_CePerfDeinit) (CePerfGlobals**);


// We only try to load ceperf.dll once per process.  When there are many files
// in ROM, load failures can be especially costly.  You can set
// CEPERF_ALWAYS_RELOAD to always retry the reload, but you take the perf hit
// into your own hands then.
#ifndef CEPERF_ALWAYS_RELOAD
  // Don't keep trying to load the DLL if it's missing
  #define CEPERF_RELOAD_FLAG FALSE
#else
  // If we fail to load, we'll try again next time someone opens a session
  #define CEPERF_RELOAD_FLAG TRUE
#endif

// Only returns non-NULL if the DLL is loaded
#define GetCePerfGlobals() ((CePerfGlobals*) pCePerfInternal)

// Coredll APIs - internal only, not to be called directly
CePerfGlobals* CePerfDLLSetup(LPVOID* ppCePerfInternal, BOOL AlwaysReload);
BOOL CePerfDLLCleanup(LPVOID* ppCePerfInternal);



//==============================================================================
// DATA LOGGING APIS
//==============================================================================

// Open an existing session or create a new one
_inline HRESULT CePerfOpenSession(
    HANDLE* lphSession,         // Will receive handle to open perf session on
                                // success, or INVALID_HANDLE_VALUE on failure
    LPCWSTR lpszSessionPath,    // Name of session (NULL-terminated, limit
                                // MAX_PATH, case-insensitive), or NULL. If two 
                                // applications open the same session name, 
                                // they will share the same session between 
                                // them.  NULL is the global "root" session.  
                                // Use "\\" to create hierarchy.
    DWORD   dwStatusFlags,      // CEPERF_STATUS_* flags, or 0 to default to
                                // settings of existing session (if present),
                                // or to settings of parent session
    const CEPERF_SESSION_INFO* lpInfo  // Pointer to extended information about
                                // session data recording and storage, or NULL
                                // to default to settings of existing session
                                // (if present), or to settings of parent session
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        // Load the DLL if necessary
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (!pGlobals) {
            pGlobals = CePerfDLLSetup(&pCePerfInternal, CEPERF_RELOAD_FLAG);
            
            // Version check
            if (pGlobals && (pGlobals->dwVersion != CEPERF_GLOBALS_VERSION)) {
                // The DLL was found but it's an incorrect version
                CePerfDLLCleanup(&pCePerfInternal);
                pGlobals = NULL;
            }
        }
        
        if (pGlobals) {
            InterlockedIncrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount));
            hr = pGlobals->pCePerfOpenSession(
                lphSession, lpszSessionPath, dwStatusFlags, lpInfo);
            if ((ERROR_SUCCESS != hr)
                && (InterlockedDecrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount)) == 0)) {
                CePerfDLLCleanup(&pCePerfInternal);
            }
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Helper wrapper to open a session with default settings.
// A data collector can always change these settings using CePerfControlSession.
_inline HRESULT CePerfOpenStandardSession(
    HANDLE *lphSession,
    LPCWSTR lpszSessionPath
    )
{
    CEPERF_SESSION_INFO info;

    // Session setup
    memset(&info, 0, sizeof(info));
    info.wVersion = 1;
    info.dwStorageFlags = CEPERF_STORE_REGISTRY;

    return CePerfOpenSession(lphSession, lpszSessionPath,
        CEPERF_STATUS_RECORDING_ENABLED | CEPERF_STATUS_STORAGE_ENABLED, &info);
}


// Close an open session handle
_inline HRESULT CePerfCloseSession(
    HANDLE hSession             // Perf session handle to close
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfCloseSession(hSession);
            if ((ERROR_SUCCESS == hr)
                && (InterlockedDecrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount)) == 0)) {
                CePerfDLLCleanup(&pCePerfInternal);
            }
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Register a perf item within an open session
_inline HRESULT CePerfRegisterTrackedItem(
    HANDLE  hSession,           // Perf session the tracked item belongs to
    HANDLE* lphTrackedItem,     // Will receive handle to identify item with, 
                                // can be NULL; if NULL the item will be tracked
                                // until the last session handle is closed, 
                                // since it cannot be deregistered
    CEPERF_ITEM_TYPE type,      // Type of tracked item
    LPCWSTR lpszItemName,       // Name of tracked item (NULL-terminated, limit
                                // 32 chars, case-insensitive). If the same name
                                // is registered twice in the same session, both
                                // instances will refer to the
                                // same item.
    DWORD   dwRecordingFlags,   // Flags for default recording mode (may be
                                // overridden by session defaults or dynamic
                                // session control)
    const CEPERF_EXT_ITEM_DESCRIPTOR* lpInfo  // Pointer to extended information 
                                // about tracked item, or NULL
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfRegisterTrackedItem(
                hSession, lphTrackedItem, type, lpszItemName, dwRecordingFlags,
                lpInfo);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Deregister a previously registered item
_inline HRESULT CePerfDeregisterTrackedItem(
    HANDLE hTrackedItem         // Handle of item being deregistered
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfDeregisterTrackedItem(hTrackedItem);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Bulk-register a set of very basic perf items within an open session.
// Handles for all items which succeed will be assigned to their structs.
// Only the most basic information can be registered in bulk.  Any item that
// requires extended settings must be registered individually.
_inline HRESULT CePerfRegisterBulk(
    HANDLE  hSession,           // Perf session the tracked items belong to
    CEPERF_BASIC_ITEM_DESCRIPTOR* lprgItemList, // Array of items to register
    DWORD   dwNumItems,         // Number of descriptors in array
    DWORD   dwReserved          // Not currently used; set to 0
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfRegisterBulk(
                hSession, lprgItemList, dwNumItems, dwReserved);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Bulk-deregister a set of very basic perf items.  Handles for all items will
// be set to INVALID_HANDLE_VALUE in their structs.
_inline HRESULT CePerfDeregisterBulk(
    CEPERF_BASIC_ITEM_DESCRIPTOR* lprgItemList, // Array of items to deregister
    DWORD   dwNumItems          // Number of descriptors in array
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfDeregisterBulk(lprgItemList, dwNumItems);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}



//------------------------------------------------------------------------------
// DURATION LOGGING: Records time (or other changes) between entry & exit

// Mark the beginning of the period of interest
_inline HRESULT CePerfBeginDuration(
    HANDLE hTrackedItem         // Handle of Duration item being entered
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfBeginDuration(hTrackedItem);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Mark an intermediate point during the period of interest
_inline HRESULT CePerfIntermediateDuration(
    HANDLE hTrackedItem,        // Handle of Duration item being marked
    CEPERF_ITEM_DATA* lpData    // Buffer to receive data changes since the
                                // the beginning of the Duration, or NULL.
                                // wVersion and wSize must be set in the struct.
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfIntermediateDuration(hTrackedItem, lpData);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Mark the end of the period of interest
_inline HRESULT CePerfEndDuration(
    HANDLE hTrackedItem,        // Handle of Duration item being exited
    CEPERF_ITEM_DATA* lpData    // Buffer to receive data changes since the
                                // the beginning of the Duration, or NULL.
                                // wVersion and wSize must be set in the struct.
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfEndDurationWithInformation(
                hTrackedItem, 0, NULL, 0, lpData);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Mark the end of the period of interest, with or without an error, and attach
// additional information.
// If a non-zero error code is passed:
//   * If the Duration is in minimum record mode, the period that is ending
//     will be regarded as an error and its data (time change, CPU perf counter
//     changes, etc.) will not be recorded.
//   * If the Duration is in short or full record mode, the error code will be
//     logged with the exit event in the data stream.
// If a buffer of additional information is passed:
//   * If the Duration is in minimum record mode, the additional information
//     will not be recorded.
//   * If the Duration is in short or maximum record mode, the end event and 
//     information will be added to the data stream.
_inline HRESULT CePerfEndDurationWithInformation(
    HANDLE hTrackedItem,        // Handle of Duration item being exited
    DWORD  dwErrorCode,         // Error code for the aborted Duration, or 0 for no error
    const BYTE* lpInfoBuf,      // Buffer of additional information to log, or NULL
    DWORD  dwInfoBufSize,       // Size of information buffer, in bytes
    CEPERF_ITEM_DATA* lpData    // Buffer to receive data changes since the
                                // the beginning of the Duration, or NULL.
                                // wVersion and wSize must be set in the struct.
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfEndDurationWithInformation(
                hTrackedItem, dwErrorCode, lpInfoBuf, dwInfoBufSize, lpData);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}



//------------------------------------------------------------------------------
// STATISTIC LOGGING: Maintains counters for important statistics

// Increment a Statistic by 1
_inline HRESULT CePerfIncrementStatistic(
    HANDLE hTrackedItem,        // Handle of Statistic item being incremented
    CEPERF_ITEM_DATA* lpData    // Buffer to receive new value of Statistic, or
                                // NULL (recommend set to NULL for best 
                                // performance).
                                // wVersion and wSize must be set in the struct.
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfAddStatistic(hTrackedItem, 1, lpData);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Add a value to a Statistic
_inline HRESULT CePerfAddStatistic(
    HANDLE hTrackedItem,        // Handle of Statistic item being added to
    DWORD  dwValue,             // Value to add to the Statistic
    CEPERF_ITEM_DATA* lpData    // Buffer to receive new value of Statistic, or
                                // NULL (recommend set to NULL for best 
                                // performance).
                                // wVersion and wSize must be set in the struct.
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfAddStatistic(hTrackedItem, dwValue, lpData);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Set a Statistic to a specific value
_inline HRESULT CePerfSetStatistic(
    HANDLE hTrackedItem,        // Handle of Statistic item being set
    DWORD  dwValue              // Value to set the Statistic to
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (pGlobals) {
            hr = pGlobals->pCePerfSetStatistic(hTrackedItem, dwValue);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}



//==============================================================================
// CONTROL APIS
//==============================================================================


// Change session recording and storage settings, or enable/disable recording.
_inline HRESULT CePerfControlSession(
    HANDLE  hSession,           // Handle of session, or INVALID_HANDLE_VALUE
                                // to refer to the session by name
    LPCWSTR lpszSessionPath,    // Name of session, or NULL to refer to the
                                // session by handle
    DWORD   dwControlFlags,     // CEPERF_CONTROL_* flags
    DWORD   dwStatusFlags,      // CEPERF_STATUS_* flags, or 0 to leave unchanged
    const CEPERF_SESSION_INFO* lpInfo  // Pointer to extended information about
                                // session data recording and storage, or NULL
                                // to leave unchanged
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        // Make it possible to call this API without having any sessions open
        // in this module.
        BOOL fNewInstance = FALSE;
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (!pGlobals) {
            pGlobals = CePerfDLLSetup(&pCePerfInternal, CEPERF_RELOAD_FLAG);
            if (pGlobals) {
                // Version check
                if (pGlobals->dwVersion != CEPERF_GLOBALS_VERSION) {
                    // The DLL was found but it's an incorrect version
                    CePerfDLLCleanup(&pCePerfInternal);
                    pGlobals = NULL;
                } else {
                    InterlockedIncrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount));
                    fNewInstance = TRUE;
                }
            }
        }

        if (pGlobals) {
            hr = pGlobals->pCePerfControlSession(
                hSession, lpszSessionPath, dwControlFlags, dwStatusFlags, lpInfo);

            // Clean up the instance data again if no session is open in this module
            if (fNewInstance
                && (InterlockedDecrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount)) == 0)) {
                CePerfDLLCleanup(&pCePerfInternal);
            }
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Re-program the perf counters for the CPU.
_inline HRESULT CePerfControlCPU(
    DWORD  dwCPUFlags,          // CEPERF_CPU_* flags
    LPVOID lpCPUControlStruct,  // Control structure defined for this CPU
    DWORD  dwCPUControlSize     // Size of control structure
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        // Make it possible to call this API without having any sessions open
        // in this module.
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (!pGlobals) {
            pGlobals = CePerfDLLSetup(&pCePerfInternal, CEPERF_RELOAD_FLAG);
            if (pGlobals) {
                // Version check
                if (pGlobals->dwVersion != CEPERF_GLOBALS_VERSION) {
                    // The DLL was found but it's an incorrect version
                    CePerfDLLCleanup(&pCePerfInternal);
                    pGlobals = NULL;
                } else {
                    InterlockedIncrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount));
                    // ... Now need to hold the DLL instance open to maintain these settings
                    // BUGBUG basically a leak, how to clean it up??
                }
            }
        }

        if (pGlobals) {
            hr = pGlobals->pCePerfControlCPU(
                dwCPUFlags, lpCPUControlStruct, dwCPUControlSize);
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


// Write data and/or descriptors of discrete tracked items, or descriptors of 
// continuous tracked items, to the storage location.
_inline HRESULT CePerfFlushSession(
    HANDLE  hSession,           // Handle of session, or INVALID_HANDLE_VALUE
                                // to refer to the session by name
    LPCWSTR lpszSessionPath,    // Name of session, or NULL to refer to the
                                // session by handle
    DWORD   dwFlushFlags,       // CEPERF_FLUSH_* flags
    DWORD   dwReserved          // Not currently used; set to 0
    )
{
    HRESULT hr = CEPERF_HR_EXCEPTION;

    CEPERF_TRY {
        // Make it possible to call this API without having any sessions open
        // in this module.
        BOOL fNewInstance = FALSE;
        CePerfGlobals* pGlobals = GetCePerfGlobals();
        if (!pGlobals) {
            pGlobals = CePerfDLLSetup(&pCePerfInternal, CEPERF_RELOAD_FLAG);
            if (pGlobals) {
                // Version check
                if (pGlobals->dwVersion != CEPERF_GLOBALS_VERSION) {
                    // The DLL was found but it's an incorrect version
                    CePerfDLLCleanup(&pCePerfInternal);
                    pGlobals = NULL;
                } else {
                    InterlockedIncrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount));
                    fNewInstance = TRUE;
                }
            }
        }

        if (pGlobals) {
            hr = pGlobals->pCePerfFlushSession(
                hSession, lpszSessionPath, dwFlushFlags, dwReserved);
        
            // Clean up the instance data again if no session is open in this module
            if (fNewInstance
                && (InterlockedDecrement((LPLONG)&(pGlobals->dwCePerfDLLRefcount)) == 0)) {
                CePerfDLLCleanup(&pCePerfInternal);
            }
        } else {
            hr = CEPERF_HR_NO_DLL;
        }
    } CEPERF_CATCH;

    return hr;
}


//==============================================================================


#else // CEPERF_DISABLE


#define CePerfOpenSession(lphSession, lpszSessionPath, dwStatusFlags, lpInfo)  \
    (CEPERF_HR_DISABLED)
#define CePerfCloseSession(hSession)                        (CEPERF_HR_DISABLED)
#define CePerfRegisterTrackedItem(hSession, lphTrackedItem, type, lpszItemName, dwRecordingFlags, lpInfo) \
    (CEPERF_HR_DISABLED)
#define CePerfDeregisterTrackedItem(hTrackedItem)           (CEPERF_HR_DISABLED)
#define CePerfRegisterBulk(hSession, lprgItemList, dwNumItems, dwReserved)     \
    (CEPERF_HR_DISABLED)
#define CePerfDeregisterBulk(lprgItemList, dwNumItems)      (CEPERF_HR_DISABLED)

#define CePerfBeginDuration(hTrackedItem)                   (CEPERF_HR_DISABLED)
#define CePerfIntermediateDuration(hTrackedItem, lpData)    (CEPERF_HR_DISABLED)
#define CePerfEndDuration(hTrackedItem, lpData)             (CEPERF_HR_DISABLED)
#define CePerfEndDurationWithInformation(hTrackedItem, dwErrorCode, lpInfoBuf, dwInfoBufSize, lpData) \
    (CEPERF_HR_DISABLED)

#define CePerfIncrementStatistic(hTrackedItem, lpData)      (CEPERF_HR_DISABLED)
#define CePerfAddStatistic(hTrackedItem, dwValue, lpData)   (CEPERF_HR_DISABLED)
#define CePerfSetStatistic(hTrackedItem, dwValue)           (CEPERF_HR_DISABLED)

#define CePerfControlSession(hSession, lpszSessionPath, dwControlFlags, dwStatusFlags, lpInfo) \
    (CEPERF_HR_DISABLED)
#define CePerfControlCPU(dwCPUFlags, lpCPUControlStruct, dwCPUControlSize)     \
    (CEPERF_HR_DISABLED)
#define CePerfFlushSession(hSession, lpszSessionPath, dwFlushFlags, lpInfo)    \
    (CEPERF_HR_DISABLED)


#endif // CEPERF_DISABLE


#ifdef __cplusplus 
}
#endif 

#endif // _CEPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\activdbg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:37 2007
 */
/* Compiler settings for ..\activdbg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activdbg_h__
#define __activdbg_h__

/* Forward Declarations */ 

#ifndef __IActiveScriptDebug32_FWD_DEFINED__
#define __IActiveScriptDebug32_FWD_DEFINED__
typedef interface IActiveScriptDebug32 IActiveScriptDebug32;
#endif  /* __IActiveScriptDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug64_FWD_DEFINED__
#define __IActiveScriptDebug64_FWD_DEFINED__
typedef interface IActiveScriptDebug64 IActiveScriptDebug64;
#endif  /* __IActiveScriptDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug32_FWD_DEFINED__
#define __IActiveScriptSiteDebug32_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug32 IActiveScriptSiteDebug32;
#endif  /* __IActiveScriptSiteDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_FWD_DEFINED__
#define __IActiveScriptSiteDebug64_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug64 IActiveScriptSiteDebug64;
#endif  /* __IActiveScriptSiteDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_FWD_DEFINED__
#define __IActiveScriptErrorDebug_FWD_DEFINED__
typedef interface IActiveScriptErrorDebug IActiveScriptErrorDebug;
#endif  /* __IActiveScriptErrorDebug_FWD_DEFINED__ */


#ifndef __IDebugCodeContext_FWD_DEFINED__
#define __IDebugCodeContext_FWD_DEFINED__
typedef interface IDebugCodeContext IDebugCodeContext;
#endif  /* __IDebugCodeContext_FWD_DEFINED__ */


#ifndef __IDebugExpression_FWD_DEFINED__
#define __IDebugExpression_FWD_DEFINED__
typedef interface IDebugExpression IDebugExpression;
#endif  /* __IDebugExpression_FWD_DEFINED__ */


#ifndef __IDebugExpressionContext_FWD_DEFINED__
#define __IDebugExpressionContext_FWD_DEFINED__
typedef interface IDebugExpressionContext IDebugExpressionContext;
#endif  /* __IDebugExpressionContext_FWD_DEFINED__ */


#ifndef __IDebugExpressionCallBack_FWD_DEFINED__
#define __IDebugExpressionCallBack_FWD_DEFINED__
typedef interface IDebugExpressionCallBack IDebugExpressionCallBack;
#endif  /* __IDebugExpressionCallBack_FWD_DEFINED__ */


#ifndef __IDebugStackFrame_FWD_DEFINED__
#define __IDebugStackFrame_FWD_DEFINED__
typedef interface IDebugStackFrame IDebugStackFrame;
#endif  /* __IDebugStackFrame_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_FWD_DEFINED__
#define __IDebugStackFrameSniffer_FWD_DEFINED__
typedef interface IDebugStackFrameSniffer IDebugStackFrameSniffer;
#endif  /* __IDebugStackFrameSniffer_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx32_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx32_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx32 IDebugStackFrameSnifferEx32;
#endif  /* __IDebugStackFrameSnifferEx32_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx64_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx64 IDebugStackFrameSnifferEx64;
#endif  /* __IDebugStackFrameSnifferEx64_FWD_DEFINED__ */


#ifndef __IDebugSyncOperation_FWD_DEFINED__
#define __IDebugSyncOperation_FWD_DEFINED__
typedef interface IDebugSyncOperation IDebugSyncOperation;
#endif  /* __IDebugSyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperation_FWD_DEFINED__
#define __IDebugAsyncOperation_FWD_DEFINED__
typedef interface IDebugAsyncOperation IDebugAsyncOperation;
#endif  /* __IDebugAsyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_FWD_DEFINED__
#define __IDebugAsyncOperationCallBack_FWD_DEFINED__
typedef interface IDebugAsyncOperationCallBack IDebugAsyncOperationCallBack;
#endif  /* __IDebugAsyncOperationCallBack_FWD_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_FWD_DEFINED__
#define __IEnumDebugCodeContexts_FWD_DEFINED__
typedef interface IEnumDebugCodeContexts IEnumDebugCodeContexts;
#endif  /* __IEnumDebugCodeContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames_FWD_DEFINED__
#define __IEnumDebugStackFrames_FWD_DEFINED__
typedef interface IEnumDebugStackFrames IEnumDebugStackFrames;
#endif  /* __IEnumDebugStackFrames_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_FWD_DEFINED__
#define __IEnumDebugStackFrames64_FWD_DEFINED__
typedef interface IEnumDebugStackFrames64 IEnumDebugStackFrames64;
#endif  /* __IEnumDebugStackFrames64_FWD_DEFINED__ */


#ifndef __IDebugDocumentInfo_FWD_DEFINED__
#define __IDebugDocumentInfo_FWD_DEFINED__
typedef interface IDebugDocumentInfo IDebugDocumentInfo;
#endif  /* __IDebugDocumentInfo_FWD_DEFINED__ */


#ifndef __IDebugDocumentProvider_FWD_DEFINED__
#define __IDebugDocumentProvider_FWD_DEFINED__
typedef interface IDebugDocumentProvider IDebugDocumentProvider;
#endif  /* __IDebugDocumentProvider_FWD_DEFINED__ */


#ifndef __IDebugDocument_FWD_DEFINED__
#define __IDebugDocument_FWD_DEFINED__
typedef interface IDebugDocument IDebugDocument;
#endif  /* __IDebugDocument_FWD_DEFINED__ */


#ifndef __IDebugDocumentText_FWD_DEFINED__
#define __IDebugDocumentText_FWD_DEFINED__
typedef interface IDebugDocumentText IDebugDocumentText;
#endif  /* __IDebugDocumentText_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextEvents_FWD_DEFINED__
#define __IDebugDocumentTextEvents_FWD_DEFINED__
typedef interface IDebugDocumentTextEvents IDebugDocumentTextEvents;
#endif  /* __IDebugDocumentTextEvents_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextAuthor_FWD_DEFINED__
#define __IDebugDocumentTextAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextAuthor IDebugDocumentTextAuthor;
#endif  /* __IDebugDocumentTextAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
#define __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextExternalAuthor IDebugDocumentTextExternalAuthor;
#endif  /* __IDebugDocumentTextExternalAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper32_FWD_DEFINED__
#define __IDebugDocumentHelper32_FWD_DEFINED__
typedef interface IDebugDocumentHelper32 IDebugDocumentHelper32;
#endif  /* __IDebugDocumentHelper32_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper64_FWD_DEFINED__
#define __IDebugDocumentHelper64_FWD_DEFINED__
typedef interface IDebugDocumentHelper64 IDebugDocumentHelper64;
#endif  /* __IDebugDocumentHelper64_FWD_DEFINED__ */


#ifndef __IDebugDocumentHost_FWD_DEFINED__
#define __IDebugDocumentHost_FWD_DEFINED__
typedef interface IDebugDocumentHost IDebugDocumentHost;
#endif  /* __IDebugDocumentHost_FWD_DEFINED__ */


#ifndef __IDebugDocumentContext_FWD_DEFINED__
#define __IDebugDocumentContext_FWD_DEFINED__
typedef interface IDebugDocumentContext IDebugDocumentContext;
#endif  /* __IDebugDocumentContext_FWD_DEFINED__ */


#ifndef __IDebugSessionProvider_FWD_DEFINED__
#define __IDebugSessionProvider_FWD_DEFINED__
typedef interface IDebugSessionProvider IDebugSessionProvider;
#endif  /* __IDebugSessionProvider_FWD_DEFINED__ */


#ifndef __IApplicationDebugger_FWD_DEFINED__
#define __IApplicationDebugger_FWD_DEFINED__
typedef interface IApplicationDebugger IApplicationDebugger;
#endif  /* __IApplicationDebugger_FWD_DEFINED__ */


#ifndef __IApplicationDebuggerUI_FWD_DEFINED__
#define __IApplicationDebuggerUI_FWD_DEFINED__
typedef interface IApplicationDebuggerUI IApplicationDebuggerUI;
#endif  /* __IApplicationDebuggerUI_FWD_DEFINED__ */


#ifndef __IMachineDebugManager_FWD_DEFINED__
#define __IMachineDebugManager_FWD_DEFINED__
typedef interface IMachineDebugManager IMachineDebugManager;
#endif  /* __IMachineDebugManager_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_FWD_DEFINED__
#define __IMachineDebugManagerCookie_FWD_DEFINED__
typedef interface IMachineDebugManagerCookie IMachineDebugManagerCookie;
#endif  /* __IMachineDebugManagerCookie_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_FWD_DEFINED__
#define __IMachineDebugManagerEvents_FWD_DEFINED__
typedef interface IMachineDebugManagerEvents IMachineDebugManagerEvents;
#endif  /* __IMachineDebugManagerEvents_FWD_DEFINED__ */


#ifndef __IProcessDebugManager32_FWD_DEFINED__
#define __IProcessDebugManager32_FWD_DEFINED__
typedef interface IProcessDebugManager32 IProcessDebugManager32;
#endif  /* __IProcessDebugManager32_FWD_DEFINED__ */


#ifndef __IProcessDebugManager64_FWD_DEFINED__
#define __IProcessDebugManager64_FWD_DEFINED__
typedef interface IProcessDebugManager64 IProcessDebugManager64;
#endif  /* __IProcessDebugManager64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplication_FWD_DEFINED__
#define __IRemoteDebugApplication_FWD_DEFINED__
typedef interface IRemoteDebugApplication IRemoteDebugApplication;
#endif  /* __IRemoteDebugApplication_FWD_DEFINED__ */


#ifndef __IDebugApplication32_FWD_DEFINED__
#define __IDebugApplication32_FWD_DEFINED__
typedef interface IDebugApplication32 IDebugApplication32;
#endif  /* __IDebugApplication32_FWD_DEFINED__ */


#ifndef __IDebugApplication64_FWD_DEFINED__
#define __IDebugApplication64_FWD_DEFINED__
typedef interface IDebugApplication64 IDebugApplication64;
#endif  /* __IDebugApplication64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_FWD_DEFINED__
#define __IRemoteDebugApplicationEvents_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEvents IRemoteDebugApplicationEvents;
#endif  /* __IRemoteDebugApplicationEvents_FWD_DEFINED__ */


#ifndef __IDebugApplicationNode_FWD_DEFINED__
#define __IDebugApplicationNode_FWD_DEFINED__
typedef interface IDebugApplicationNode IDebugApplicationNode;
#endif  /* __IDebugApplicationNode_FWD_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_FWD_DEFINED__
#define __IDebugApplicationNodeEvents_FWD_DEFINED__
typedef interface IDebugApplicationNodeEvents IDebugApplicationNodeEvents;
#endif  /* __IDebugApplicationNodeEvents_FWD_DEFINED__ */


#ifndef __IDebugThreadCall32_FWD_DEFINED__
#define __IDebugThreadCall32_FWD_DEFINED__
typedef interface IDebugThreadCall32 IDebugThreadCall32;
#endif  /* __IDebugThreadCall32_FWD_DEFINED__ */


#ifndef __IDebugThreadCall64_FWD_DEFINED__
#define __IDebugThreadCall64_FWD_DEFINED__
typedef interface IDebugThreadCall64 IDebugThreadCall64;
#endif  /* __IDebugThreadCall64_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_FWD_DEFINED__
#define __IRemoteDebugApplicationThread_FWD_DEFINED__
typedef interface IRemoteDebugApplicationThread IRemoteDebugApplicationThread;
#endif  /* __IRemoteDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread_FWD_DEFINED__
#define __IDebugApplicationThread_FWD_DEFINED__
typedef interface IDebugApplicationThread IDebugApplicationThread;
#endif  /* __IDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread64_FWD_DEFINED__
#define __IDebugApplicationThread64_FWD_DEFINED__
typedef interface IDebugApplicationThread64 IDebugApplicationThread64;
#endif  /* __IDebugApplicationThread64_FWD_DEFINED__ */


#ifndef __IDebugCookie_FWD_DEFINED__
#define __IDebugCookie_FWD_DEFINED__
typedef interface IDebugCookie IDebugCookie;
#endif  /* __IDebugCookie_FWD_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_FWD_DEFINED__
#define __IEnumDebugApplicationNodes_FWD_DEFINED__
typedef interface IEnumDebugApplicationNodes IEnumDebugApplicationNodes;
#endif  /* __IEnumDebugApplicationNodes_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_FWD_DEFINED__
#define __IEnumRemoteDebugApplications_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplications IEnumRemoteDebugApplications;
#endif  /* __IEnumRemoteDebugApplications_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplicationThreads IEnumRemoteDebugApplicationThreads;
#endif  /* __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__ */


#ifndef __IDebugFormatter_FWD_DEFINED__
#define __IDebugFormatter_FWD_DEFINED__
typedef interface IDebugFormatter IDebugFormatter;
#endif  /* __IDebugFormatter_FWD_DEFINED__ */


#ifndef __ISimpleConnectionPoint_FWD_DEFINED__
#define __ISimpleConnectionPoint_FWD_DEFINED__
typedef interface ISimpleConnectionPoint ISimpleConnectionPoint;
#endif  /* __ISimpleConnectionPoint_FWD_DEFINED__ */


#ifndef __IDebugHelper_FWD_DEFINED__
#define __IDebugHelper_FWD_DEFINED__
typedef interface IDebugHelper IDebugHelper;
#endif  /* __IDebugHelper_FWD_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_FWD_DEFINED__
#define __IEnumDebugExpressionContexts_FWD_DEFINED__
typedef interface IEnumDebugExpressionContexts IEnumDebugExpressionContexts;
#endif  /* __IEnumDebugExpressionContexts_FWD_DEFINED__ */


#ifndef __IProvideExpressionContexts_FWD_DEFINED__
#define __IProvideExpressionContexts_FWD_DEFINED__
typedef interface IProvideExpressionContexts IProvideExpressionContexts;
#endif  /* __IProvideExpressionContexts_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug32_FWD_DEFINED__
#define __IActiveScriptDebug32_FWD_DEFINED__
typedef interface IActiveScriptDebug32 IActiveScriptDebug32;
#endif  /* __IActiveScriptDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptDebug64_FWD_DEFINED__
#define __IActiveScriptDebug64_FWD_DEFINED__
typedef interface IActiveScriptDebug64 IActiveScriptDebug64;
#endif  /* __IActiveScriptDebug64_FWD_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_FWD_DEFINED__
#define __IActiveScriptErrorDebug_FWD_DEFINED__
typedef interface IActiveScriptErrorDebug IActiveScriptErrorDebug;
#endif  /* __IActiveScriptErrorDebug_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug32_FWD_DEFINED__
#define __IActiveScriptSiteDebug32_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug32 IActiveScriptSiteDebug32;
#endif  /* __IActiveScriptSiteDebug32_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_FWD_DEFINED__
#define __IActiveScriptSiteDebug64_FWD_DEFINED__
typedef interface IActiveScriptSiteDebug64 IActiveScriptSiteDebug64;
#endif  /* __IActiveScriptSiteDebug64_FWD_DEFINED__ */


#ifndef __IApplicationDebugger_FWD_DEFINED__
#define __IApplicationDebugger_FWD_DEFINED__
typedef interface IApplicationDebugger IApplicationDebugger;
#endif  /* __IApplicationDebugger_FWD_DEFINED__ */


#ifndef __IApplicationDebuggerUI_FWD_DEFINED__
#define __IApplicationDebuggerUI_FWD_DEFINED__
typedef interface IApplicationDebuggerUI IApplicationDebuggerUI;
#endif  /* __IApplicationDebuggerUI_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplication_FWD_DEFINED__
#define __IRemoteDebugApplication_FWD_DEFINED__
typedef interface IRemoteDebugApplication IRemoteDebugApplication;
#endif  /* __IRemoteDebugApplication_FWD_DEFINED__ */


#ifndef __IDebugApplication32_FWD_DEFINED__
#define __IDebugApplication32_FWD_DEFINED__
typedef interface IDebugApplication32 IDebugApplication32;
#endif  /* __IDebugApplication32_FWD_DEFINED__ */


#ifndef __IDebugApplication64_FWD_DEFINED__
#define __IDebugApplication64_FWD_DEFINED__
typedef interface IDebugApplication64 IDebugApplication64;
#endif  /* __IDebugApplication64_FWD_DEFINED__ */


#ifndef __IDebugDocumentInfo_FWD_DEFINED__
#define __IDebugDocumentInfo_FWD_DEFINED__
typedef interface IDebugDocumentInfo IDebugDocumentInfo;
#endif  /* __IDebugDocumentInfo_FWD_DEFINED__ */


#ifndef __IDebugDocumentProvider_FWD_DEFINED__
#define __IDebugDocumentProvider_FWD_DEFINED__
typedef interface IDebugDocumentProvider IDebugDocumentProvider;
#endif  /* __IDebugDocumentProvider_FWD_DEFINED__ */


#ifndef __IDebugApplicationNode_FWD_DEFINED__
#define __IDebugApplicationNode_FWD_DEFINED__
typedef interface IDebugApplicationNode IDebugApplicationNode;
#endif  /* __IDebugApplicationNode_FWD_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_FWD_DEFINED__
#define __IDebugApplicationNodeEvents_FWD_DEFINED__
typedef interface IDebugApplicationNodeEvents IDebugApplicationNodeEvents;
#endif  /* __IDebugApplicationNodeEvents_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_FWD_DEFINED__
#define __IRemoteDebugApplicationThread_FWD_DEFINED__
typedef interface IRemoteDebugApplicationThread IRemoteDebugApplicationThread;
#endif  /* __IRemoteDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugApplicationThread_FWD_DEFINED__
#define __IDebugApplicationThread_FWD_DEFINED__
typedef interface IDebugApplicationThread IDebugApplicationThread;
#endif  /* __IDebugApplicationThread_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperation_FWD_DEFINED__
#define __IDebugAsyncOperation_FWD_DEFINED__
typedef interface IDebugAsyncOperation IDebugAsyncOperation;
#endif  /* __IDebugAsyncOperation_FWD_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_FWD_DEFINED__
#define __IDebugAsyncOperationCallBack_FWD_DEFINED__
typedef interface IDebugAsyncOperationCallBack IDebugAsyncOperationCallBack;
#endif  /* __IDebugAsyncOperationCallBack_FWD_DEFINED__ */


#ifndef __IDebugCodeContext_FWD_DEFINED__
#define __IDebugCodeContext_FWD_DEFINED__
typedef interface IDebugCodeContext IDebugCodeContext;
#endif  /* __IDebugCodeContext_FWD_DEFINED__ */


#ifndef __IDebugCookie_FWD_DEFINED__
#define __IDebugCookie_FWD_DEFINED__
typedef interface IDebugCookie IDebugCookie;
#endif  /* __IDebugCookie_FWD_DEFINED__ */


#ifndef __IDebugDocument_FWD_DEFINED__
#define __IDebugDocument_FWD_DEFINED__
typedef interface IDebugDocument IDebugDocument;
#endif  /* __IDebugDocument_FWD_DEFINED__ */


#ifndef __IDebugDocumentContext_FWD_DEFINED__
#define __IDebugDocumentContext_FWD_DEFINED__
typedef interface IDebugDocumentContext IDebugDocumentContext;
#endif  /* __IDebugDocumentContext_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper32_FWD_DEFINED__
#define __IDebugDocumentHelper32_FWD_DEFINED__
typedef interface IDebugDocumentHelper32 IDebugDocumentHelper32;
#endif  /* __IDebugDocumentHelper32_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelper64_FWD_DEFINED__
#define __IDebugDocumentHelper64_FWD_DEFINED__
typedef interface IDebugDocumentHelper64 IDebugDocumentHelper64;
#endif  /* __IDebugDocumentHelper64_FWD_DEFINED__ */


#ifndef __IDebugDocumentHost_FWD_DEFINED__
#define __IDebugDocumentHost_FWD_DEFINED__
typedef interface IDebugDocumentHost IDebugDocumentHost;
#endif  /* __IDebugDocumentHost_FWD_DEFINED__ */


#ifndef __IDebugDocumentText_FWD_DEFINED__
#define __IDebugDocumentText_FWD_DEFINED__
typedef interface IDebugDocumentText IDebugDocumentText;
#endif  /* __IDebugDocumentText_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextAuthor_FWD_DEFINED__
#define __IDebugDocumentTextAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextAuthor IDebugDocumentTextAuthor;
#endif  /* __IDebugDocumentTextAuthor_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextEvents_FWD_DEFINED__
#define __IDebugDocumentTextEvents_FWD_DEFINED__
typedef interface IDebugDocumentTextEvents IDebugDocumentTextEvents;
#endif  /* __IDebugDocumentTextEvents_FWD_DEFINED__ */


#ifndef __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
#define __IDebugDocumentTextExternalAuthor_FWD_DEFINED__
typedef interface IDebugDocumentTextExternalAuthor IDebugDocumentTextExternalAuthor;
#endif  /* __IDebugDocumentTextExternalAuthor_FWD_DEFINED__ */


#ifndef __IDebugExpression_FWD_DEFINED__
#define __IDebugExpression_FWD_DEFINED__
typedef interface IDebugExpression IDebugExpression;
#endif  /* __IDebugExpression_FWD_DEFINED__ */


#ifndef __IDebugExpressionCallBack_FWD_DEFINED__
#define __IDebugExpressionCallBack_FWD_DEFINED__
typedef interface IDebugExpressionCallBack IDebugExpressionCallBack;
#endif  /* __IDebugExpressionCallBack_FWD_DEFINED__ */


#ifndef __IDebugExpressionContext_FWD_DEFINED__
#define __IDebugExpressionContext_FWD_DEFINED__
typedef interface IDebugExpressionContext IDebugExpressionContext;
#endif  /* __IDebugExpressionContext_FWD_DEFINED__ */


#ifndef __IDebugFormatter_FWD_DEFINED__
#define __IDebugFormatter_FWD_DEFINED__
typedef interface IDebugFormatter IDebugFormatter;
#endif  /* __IDebugFormatter_FWD_DEFINED__ */


#ifndef __IDebugHelper_FWD_DEFINED__
#define __IDebugHelper_FWD_DEFINED__
typedef interface IDebugHelper IDebugHelper;
#endif  /* __IDebugHelper_FWD_DEFINED__ */


#ifndef __IDebugSessionProvider_FWD_DEFINED__
#define __IDebugSessionProvider_FWD_DEFINED__
typedef interface IDebugSessionProvider IDebugSessionProvider;
#endif  /* __IDebugSessionProvider_FWD_DEFINED__ */


#ifndef __IDebugStackFrame_FWD_DEFINED__
#define __IDebugStackFrame_FWD_DEFINED__
typedef interface IDebugStackFrame IDebugStackFrame;
#endif  /* __IDebugStackFrame_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_FWD_DEFINED__
#define __IDebugStackFrameSniffer_FWD_DEFINED__
typedef interface IDebugStackFrameSniffer IDebugStackFrameSniffer;
#endif  /* __IDebugStackFrameSniffer_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx32_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx32_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx32 IDebugStackFrameSnifferEx32;
#endif  /* __IDebugStackFrameSnifferEx32_FWD_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_FWD_DEFINED__
#define __IDebugStackFrameSnifferEx64_FWD_DEFINED__
typedef interface IDebugStackFrameSnifferEx64 IDebugStackFrameSnifferEx64;
#endif  /* __IDebugStackFrameSnifferEx64_FWD_DEFINED__ */


#ifndef __IDebugSyncOperation_FWD_DEFINED__
#define __IDebugSyncOperation_FWD_DEFINED__
typedef interface IDebugSyncOperation IDebugSyncOperation;
#endif  /* __IDebugSyncOperation_FWD_DEFINED__ */


#ifndef __IDebugThreadCall32_FWD_DEFINED__
#define __IDebugThreadCall32_FWD_DEFINED__
typedef interface IDebugThreadCall32 IDebugThreadCall32;
#endif  /* __IDebugThreadCall32_FWD_DEFINED__ */


#ifndef __IDebugThreadCall64_FWD_DEFINED__
#define __IDebugThreadCall64_FWD_DEFINED__
typedef interface IDebugThreadCall64 IDebugThreadCall64;
#endif  /* __IDebugThreadCall64_FWD_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_FWD_DEFINED__
#define __IEnumDebugApplicationNodes_FWD_DEFINED__
typedef interface IEnumDebugApplicationNodes IEnumDebugApplicationNodes;
#endif  /* __IEnumDebugApplicationNodes_FWD_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_FWD_DEFINED__
#define __IEnumDebugCodeContexts_FWD_DEFINED__
typedef interface IEnumDebugCodeContexts IEnumDebugCodeContexts;
#endif  /* __IEnumDebugCodeContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_FWD_DEFINED__
#define __IEnumDebugExpressionContexts_FWD_DEFINED__
typedef interface IEnumDebugExpressionContexts IEnumDebugExpressionContexts;
#endif  /* __IEnumDebugExpressionContexts_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames_FWD_DEFINED__
#define __IEnumDebugStackFrames_FWD_DEFINED__
typedef interface IEnumDebugStackFrames IEnumDebugStackFrames;
#endif  /* __IEnumDebugStackFrames_FWD_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_FWD_DEFINED__
#define __IEnumDebugStackFrames64_FWD_DEFINED__
typedef interface IEnumDebugStackFrames64 IEnumDebugStackFrames64;
#endif  /* __IEnumDebugStackFrames64_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_FWD_DEFINED__
#define __IEnumRemoteDebugApplications_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplications IEnumRemoteDebugApplications;
#endif  /* __IEnumRemoteDebugApplications_FWD_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__
typedef interface IEnumRemoteDebugApplicationThreads IEnumRemoteDebugApplicationThreads;
#endif  /* __IEnumRemoteDebugApplicationThreads_FWD_DEFINED__ */


#ifndef __IProcessDebugManager32_FWD_DEFINED__
#define __IProcessDebugManager32_FWD_DEFINED__
typedef interface IProcessDebugManager32 IProcessDebugManager32;
#endif  /* __IProcessDebugManager32_FWD_DEFINED__ */


#ifndef __IProcessDebugManager64_FWD_DEFINED__
#define __IProcessDebugManager64_FWD_DEFINED__
typedef interface IProcessDebugManager64 IProcessDebugManager64;
#endif  /* __IProcessDebugManager64_FWD_DEFINED__ */


#ifndef __IProvideExpressionContexts_FWD_DEFINED__
#define __IProvideExpressionContexts_FWD_DEFINED__
typedef interface IProvideExpressionContexts IProvideExpressionContexts;
#endif  /* __IProvideExpressionContexts_FWD_DEFINED__ */


#ifndef __IMachineDebugManager_FWD_DEFINED__
#define __IMachineDebugManager_FWD_DEFINED__
typedef interface IMachineDebugManager IMachineDebugManager;
#endif  /* __IMachineDebugManager_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_FWD_DEFINED__
#define __IMachineDebugManagerCookie_FWD_DEFINED__
typedef interface IMachineDebugManagerCookie IMachineDebugManagerCookie;
#endif  /* __IMachineDebugManagerCookie_FWD_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_FWD_DEFINED__
#define __IMachineDebugManagerEvents_FWD_DEFINED__
typedef interface IMachineDebugManagerEvents IMachineDebugManagerEvents;
#endif  /* __IMachineDebugManagerEvents_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_FWD_DEFINED__
#define __IRemoteDebugApplicationEvents_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEvents IRemoteDebugApplicationEvents;
#endif  /* __IRemoteDebugApplicationEvents_FWD_DEFINED__ */


#ifndef __ISimpleConnectionPoint_FWD_DEFINED__
#define __ISimpleConnectionPoint_FWD_DEFINED__
typedef interface ISimpleConnectionPoint ISimpleConnectionPoint;
#endif  /* __ISimpleConnectionPoint_FWD_DEFINED__ */


#ifndef __ProcessDebugManager_FWD_DEFINED__
#define __ProcessDebugManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProcessDebugManager ProcessDebugManager;
#else
typedef struct ProcessDebugManager ProcessDebugManager;
#endif /* __cplusplus */

#endif  /* __ProcessDebugManager_FWD_DEFINED__ */


#ifndef __DebugHelper_FWD_DEFINED__
#define __DebugHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class DebugHelper DebugHelper;
#else
typedef struct DebugHelper DebugHelper;
#endif /* __cplusplus */

#endif  /* __DebugHelper_FWD_DEFINED__ */


#ifndef __CDebugDocumentHelper_FWD_DEFINED__
#define __CDebugDocumentHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDebugDocumentHelper CDebugDocumentHelper;
#else
typedef struct CDebugDocumentHelper CDebugDocumentHelper;
#endif /* __cplusplus */

#endif  /* __CDebugDocumentHelper_FWD_DEFINED__ */


#ifndef __MachineDebugManager_FWD_DEFINED__
#define __MachineDebugManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MachineDebugManager MachineDebugManager;
#else
typedef struct MachineDebugManager MachineDebugManager;
#endif /* __cplusplus */

#endif  /* __MachineDebugManager_FWD_DEFINED__ */


#ifndef __DefaultDebugSessionProvider_FWD_DEFINED__
#define __DefaultDebugSessionProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class DefaultDebugSessionProvider DefaultDebugSessionProvider;
#else
typedef struct DefaultDebugSessionProvider DefaultDebugSessionProvider;
#endif /* __cplusplus */

#endif  /* __DefaultDebugSessionProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "activscp.h"
#include "dbgprop.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_activdbg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ActivDbg.h
//=--------------------------------------------------------------------------=
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Scripting authoring/Debugging.
//

#ifndef __ActivDbg_h
#define __ActivDbg_h























































typedef 
enum tagBREAKPOINT_STATE
    {   BREAKPOINT_DELETED  = 0,
    BREAKPOINT_DISABLED = 1,
    BREAKPOINT_ENABLED  = 2
    }   BREAKPOINT_STATE;

typedef DWORD APPBREAKFLAGS;

#define APPBREAKFLAG_DEBUGGER_BLOCK ( 0x1 )

#define APPBREAKFLAG_DEBUGGER_HALT  ( 0x2 )

#define APPBREAKFLAG_STEP   ( 0x10000 )

#define APPBREAKFLAG_NESTED ( 0x20000 )

#define APPBREAKFLAG_STEPTYPE_SOURCE    ( 0 )

#define APPBREAKFLAG_STEPTYPE_BYTECODE  ( 0x100000 )

#define APPBREAKFLAG_STEPTYPE_MACHINE   ( 0x200000 )

#define APPBREAKFLAG_STEPTYPE_MASK  ( 0xf00000 )

#define APPBREAKFLAG_IN_BREAKPOINT  ( 0x80000000 )

typedef 
enum tagBREAKREASON
    {   BREAKREASON_STEP    = 0,
    BREAKREASON_BREAKPOINT  = BREAKREASON_STEP + 1,
    BREAKREASON_DEBUGGER_BLOCK  = BREAKREASON_BREAKPOINT + 1,
    BREAKREASON_HOST_INITIATED  = BREAKREASON_DEBUGGER_BLOCK + 1,
    BREAKREASON_LANGUAGE_INITIATED  = BREAKREASON_HOST_INITIATED + 1,
    BREAKREASON_DEBUGGER_HALT   = BREAKREASON_LANGUAGE_INITIATED + 1,
    BREAKREASON_ERROR   = BREAKREASON_DEBUGGER_HALT + 1,
    BREAKREASON_JIT = BREAKREASON_ERROR + 1
    }   BREAKREASON;

typedef 
enum tagBREAKRESUME_ACTION
    {   BREAKRESUMEACTION_ABORT = 0,
    BREAKRESUMEACTION_CONTINUE  = BREAKRESUMEACTION_ABORT + 1,
    BREAKRESUMEACTION_STEP_INTO = BREAKRESUMEACTION_CONTINUE + 1,
    BREAKRESUMEACTION_STEP_OVER = BREAKRESUMEACTION_STEP_INTO + 1,
    BREAKRESUMEACTION_STEP_OUT  = BREAKRESUMEACTION_STEP_OVER + 1,
    BREAKRESUMEACTION_IGNORE    = BREAKRESUMEACTION_STEP_OUT + 1
    }   BREAKRESUMEACTION;

typedef 
enum tagERRORRESUMEACTION
    {   ERRORRESUMEACTION_ReexecuteErrorStatement   = 0,
    ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller   = ERRORRESUMEACTION_ReexecuteErrorStatement + 1,
    ERRORRESUMEACTION_SkipErrorStatement    = ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller + 1
    }   ERRORRESUMEACTION;

typedef 
enum tagDOCUMENTNAMETYPE
    {   DOCUMENTNAMETYPE_APPNODE    = 0,
    DOCUMENTNAMETYPE_TITLE  = DOCUMENTNAMETYPE_APPNODE + 1,
    DOCUMENTNAMETYPE_FILE_TAIL  = DOCUMENTNAMETYPE_TITLE + 1,
    DOCUMENTNAMETYPE_URL    = DOCUMENTNAMETYPE_FILE_TAIL + 1
    }   DOCUMENTNAMETYPE;

typedef WORD SOURCE_TEXT_ATTR;

#define SOURCETEXT_ATTR_KEYWORD ( 0x1 )

#define SOURCETEXT_ATTR_COMMENT ( 0x2 )

#define SOURCETEXT_ATTR_NONSOURCE   ( 0x4 )

#define SOURCETEXT_ATTR_OPERATOR    ( 0x8 )

#define SOURCETEXT_ATTR_NUMBER  ( 0x10 )

#define SOURCETEXT_ATTR_STRING  ( 0x20 )

#define SOURCETEXT_ATTR_FUNCTION_START  ( 0x40 )

typedef DWORD TEXT_DOC_ATTR;

#define TEXT_DOC_ATTR_READONLY  ( 0x1 )

#define DEBUG_TEXT_ISEXPRESSION ( 0x1 )

#define DEBUG_TEXT_RETURNVALUE  ( 0x2 )

#define DEBUG_TEXT_NOSIDEEFFECTS    ( 0x4 )

#define DEBUG_TEXT_ALLOWBREAKPOINTS ( 0x8 )

#define DEBUG_TEXT_ALLOWERRORREPORT ( 0x10 )

#define DEBUG_TEXT_EVALUATETOCODECONTEXT    ( 0x20 )

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IActiveScriptDebug IActiveScriptDebug64
#define IID_IActiveScriptDebug IID_IActiveScriptDebug64
#else
#define IActiveScriptDebug IActiveScriptDebug32
#define IID_IActiveScriptDebug IID_IActiveScriptDebug32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0000_v0_0_s_ifspec;

#ifndef __IActiveScriptDebug32_INTERFACE_DEFINED__
#define __IActiveScriptDebug32_INTERFACE_DEFINED__

/* interface IActiveScriptDebug32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptDebug32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C10-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptDebug32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptletTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContextsOfPosition( 
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IActiveScriptDebug32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptDebug32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptDebug32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptDebug32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptTextAttributes )( 
            IActiveScriptDebug32 __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptletTextAttributes )( 
            IActiveScriptDebug32 __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodeContextsOfPosition )( 
            IActiveScriptDebug32 __RPC_FAR * This,
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);
        
        END_INTERFACE
    } IActiveScriptDebug32Vtbl;

    interface IActiveScriptDebug32
    {
        CONST_VTBL struct IActiveScriptDebug32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptDebug32_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptDebug32_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptDebug32_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptDebug32_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)   \
    (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)

#define IActiveScriptDebug32_GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)    \
    (This)->lpVtbl -> GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)

#define IActiveScriptDebug32_EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc) \
    (This)->lpVtbl -> EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptDebug32_GetScriptTextAttributes_Proxy( 
    IActiveScriptDebug32 __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pstrCode,
    /* [in] */ ULONG uNumCodeChars,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptDebug32_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptDebug32_GetScriptletTextAttributes_Proxy( 
    IActiveScriptDebug32 __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pstrCode,
    /* [in] */ ULONG uNumCodeChars,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptDebug32_GetScriptletTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptDebug32_EnumCodeContextsOfPosition_Proxy( 
    IActiveScriptDebug32 __RPC_FAR * This,
    /* [in] */ DWORD dwSourceContext,
    /* [in] */ ULONG uCharacterOffset,
    /* [in] */ ULONG uNumChars,
    /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);


void __RPC_STUB IActiveScriptDebug32_EnumCodeContextsOfPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptDebug32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptDebug64_INTERFACE_DEFINED__
#define __IActiveScriptDebug64_INTERFACE_DEFINED__

/* interface IActiveScriptDebug64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptDebug64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc437e23-f5b8-47f4-bb79-7d1ce5483b86")
    IActiveScriptDebug64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptletTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContextsOfPosition( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc) = 0;
        
    };
    
#else  /* C style interface */

    typedef struct IActiveScriptDebug64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptDebug64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptDebug64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptDebug64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptTextAttributes )( 
            IActiveScriptDebug64 __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptletTextAttributes )( 
            IActiveScriptDebug64 __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodeContextsOfPosition )( 
            IActiveScriptDebug64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);
        
        END_INTERFACE
    } IActiveScriptDebug64Vtbl;

    interface IActiveScriptDebug64
    {
        CONST_VTBL struct IActiveScriptDebug64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptDebug64_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptDebug64_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptDebug64_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptDebug64_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)   \
    (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)

#define IActiveScriptDebug64_GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)    \
    (This)->lpVtbl -> GetScriptletTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)

#define IActiveScriptDebug64_EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc) \
    (This)->lpVtbl -> EnumCodeContextsOfPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppescc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptDebug64_GetScriptTextAttributes_Proxy( 
    IActiveScriptDebug64 __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pstrCode,
    /* [in] */ ULONG uNumCodeChars,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptDebug64_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptDebug64_GetScriptletTextAttributes_Proxy( 
    IActiveScriptDebug64 __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pstrCode,
    /* [in] */ ULONG uNumCodeChars,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptDebug64_GetScriptletTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptDebug64_EnumCodeContextsOfPosition_Proxy( 
    IActiveScriptDebug64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwSourceContext,
    /* [in] */ ULONG uCharacterOffset,
    /* [in] */ ULONG uNumChars,
    /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);


void __RPC_STUB IActiveScriptDebug64_EnumCodeContextsOfPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptDebug64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0191 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IActiveScriptSiteDebug IActiveScriptSiteDebug64
#define IID_IActiveScriptSiteDebug IID_IActiveScriptSiteDebug64
#else
#define IActiveScriptSiteDebug IActiveScriptSiteDebug32
#define IID_IActiveScriptSiteDebug IID_IActiveScriptSiteDebug32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0191_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0191_v0_0_s_ifspec;

#ifndef __IActiveScriptSiteDebug32_INTERFACE_DEFINED__
#define __IActiveScriptSiteDebug32_INTERFACE_DEFINED__

/* interface IActiveScriptSiteDebug32 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteDebug32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C11-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptSiteDebug32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContextFromPosition( 
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptErrorDebug( 
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IActiveScriptSiteDebug32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentContextFromPosition )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This,
            /* [in] */ DWORD dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplication )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This,
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootApplicationNode )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnScriptErrorDebug )( 
            IActiveScriptSiteDebug32 __RPC_FAR * This,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing);
        
        END_INTERFACE
    } IActiveScriptSiteDebug32Vtbl;

    interface IActiveScriptSiteDebug32
    {
        CONST_VTBL struct IActiveScriptSiteDebug32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteDebug32_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteDebug32_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteDebug32_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteDebug32_GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)   \
    (This)->lpVtbl -> GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)

#define IActiveScriptSiteDebug32_GetApplication(This,ppda)  \
    (This)->lpVtbl -> GetApplication(This,ppda)

#define IActiveScriptSiteDebug32_GetRootApplicationNode(This,ppdanRoot) \
    (This)->lpVtbl -> GetRootApplicationNode(This,ppdanRoot)

#define IActiveScriptSiteDebug32_OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing) \
    (This)->lpVtbl -> OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug32_GetDocumentContextFromPosition_Proxy( 
    IActiveScriptSiteDebug32 __RPC_FAR * This,
    /* [in] */ DWORD dwSourceContext,
    /* [in] */ ULONG uCharacterOffset,
    /* [in] */ ULONG uNumChars,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);


void __RPC_STUB IActiveScriptSiteDebug32_GetDocumentContextFromPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug32_GetApplication_Proxy( 
    IActiveScriptSiteDebug32 __RPC_FAR * This,
    /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IActiveScriptSiteDebug32_GetApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug32_GetRootApplicationNode_Proxy( 
    IActiveScriptSiteDebug32 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);


void __RPC_STUB IActiveScriptSiteDebug32_GetRootApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug32_OnScriptErrorDebug_Proxy( 
    IActiveScriptSiteDebug32 __RPC_FAR * This,
    /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
    /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
    /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing);


void __RPC_STUB IActiveScriptSiteDebug32_OnScriptErrorDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptSiteDebug32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteDebug64_INTERFACE_DEFINED__
#define __IActiveScriptSiteDebug64_INTERFACE_DEFINED__

/* interface IActiveScriptSiteDebug64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteDebug64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d6b96b0a-7463-402c-92ac-89984226942f")
    IActiveScriptSiteDebug64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContextFromPosition( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptErrorDebug( 
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing) = 0;
        
    };
    
#else  /* C style interface */

    typedef struct IActiveScriptSiteDebug64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentContextFromPosition )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [in] */ ULONG uCharacterOffset,
            /* [in] */ ULONG uNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplication )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This,
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootApplicationNode )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnScriptErrorDebug )( 
            IActiveScriptSiteDebug64 __RPC_FAR * This,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing);
        
        END_INTERFACE
    } IActiveScriptSiteDebug64Vtbl;

    interface IActiveScriptSiteDebug64
    {
        CONST_VTBL struct IActiveScriptSiteDebug64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteDebug64_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptSiteDebug64_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptSiteDebug64_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptSiteDebug64_GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)   \
    (This)->lpVtbl -> GetDocumentContextFromPosition(This,dwSourceContext,uCharacterOffset,uNumChars,ppsc)

#define IActiveScriptSiteDebug64_GetApplication(This,ppda)  \
    (This)->lpVtbl -> GetApplication(This,ppda)

#define IActiveScriptSiteDebug64_GetRootApplicationNode(This,ppdanRoot) \
    (This)->lpVtbl -> GetRootApplicationNode(This,ppdanRoot)

#define IActiveScriptSiteDebug64_OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing) \
    (This)->lpVtbl -> OnScriptErrorDebug(This,pErrorDebug,pfEnterDebugger,pfCallOnScriptErrorWhenContinuing)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug64_GetDocumentContextFromPosition_Proxy( 
    IActiveScriptSiteDebug64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwSourceContext,
    /* [in] */ ULONG uCharacterOffset,
    /* [in] */ ULONG uNumChars,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);


void __RPC_STUB IActiveScriptSiteDebug64_GetDocumentContextFromPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug64_GetApplication_Proxy( 
    IActiveScriptSiteDebug64 __RPC_FAR * This,
    /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IActiveScriptSiteDebug64_GetApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug64_GetRootApplicationNode_Proxy( 
    IActiveScriptSiteDebug64 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);


void __RPC_STUB IActiveScriptSiteDebug64_GetRootApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptSiteDebug64_OnScriptErrorDebug_Proxy( 
    IActiveScriptSiteDebug64 __RPC_FAR * This,
    /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
    /* [out] */ BOOL __RPC_FAR *pfEnterDebugger,
    /* [out] */ BOOL __RPC_FAR *pfCallOnScriptErrorWhenContinuing);


void __RPC_STUB IActiveScriptSiteDebug64_OnScriptErrorDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptSiteDebug64_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptErrorDebug_INTERFACE_DEFINED__
#define __IActiveScriptErrorDebug_INTERFACE_DEFINED__

/* interface IActiveScriptErrorDebug */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptErrorDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C12-CB0C-11d0-B5C9-00A0244A0E7A")
    IActiveScriptErrorDebug : public IActiveScriptError
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppssc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackFrame( 
            /* [out] */ IDebugStackFrame __RPC_FAR *__RPC_FAR *ppdsf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IActiveScriptErrorDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptErrorDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptErrorDebug __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExceptionInfo )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [out] */ EXCEPINFO __RPC_FAR *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourcePosition )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSourceContext,
            /* [out] */ ULONG __RPC_FAR *pulLineNumber,
            /* [out] */ LONG __RPC_FAR *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSourceLineText )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSourceLine);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentContext )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppssc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStackFrame )( 
            IActiveScriptErrorDebug __RPC_FAR * This,
            /* [out] */ IDebugStackFrame __RPC_FAR *__RPC_FAR *ppdsf);
        
        END_INTERFACE
    } IActiveScriptErrorDebugVtbl;

    interface IActiveScriptErrorDebug
    {
        CONST_VTBL struct IActiveScriptErrorDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptErrorDebug_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptErrorDebug_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptErrorDebug_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptErrorDebug_GetExceptionInfo(This,pexcepinfo)   \
    (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo)

#define IActiveScriptErrorDebug_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)  \
    (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)

#define IActiveScriptErrorDebug_GetSourceLineText(This,pbstrSourceLine) \
    (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine)


#define IActiveScriptErrorDebug_GetDocumentContext(This,ppssc)  \
    (This)->lpVtbl -> GetDocumentContext(This,ppssc)

#define IActiveScriptErrorDebug_GetStackFrame(This,ppdsf)   \
    (This)->lpVtbl -> GetStackFrame(This,ppdsf)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptErrorDebug_GetDocumentContext_Proxy( 
    IActiveScriptErrorDebug __RPC_FAR * This,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppssc);


void __RPC_STUB IActiveScriptErrorDebug_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptErrorDebug_GetStackFrame_Proxy( 
    IActiveScriptErrorDebug __RPC_FAR * This,
    /* [out] */ IDebugStackFrame __RPC_FAR *__RPC_FAR *ppdsf);


void __RPC_STUB IActiveScriptErrorDebug_GetStackFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptErrorDebug_INTERFACE_DEFINED__ */


#ifndef __IDebugCodeContext_INTERFACE_DEFINED__
#define __IDebugCodeContext_INTERFACE_DEFINED__

/* interface IDebugCodeContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugCodeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C13-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugCodeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentContext( 
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBreakPoint( 
            /* [in] */ BREAKPOINT_STATE bps) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugCodeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugCodeContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugCodeContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugCodeContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentContext )( 
            IDebugCodeContext __RPC_FAR * This,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBreakPoint )( 
            IDebugCodeContext __RPC_FAR * This,
            /* [in] */ BREAKPOINT_STATE bps);
        
        END_INTERFACE
    } IDebugCodeContextVtbl;

    interface IDebugCodeContext
    {
        CONST_VTBL struct IDebugCodeContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCodeContext_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugCodeContext_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IDebugCodeContext_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IDebugCodeContext_GetDocumentContext(This,ppsc) \
    (This)->lpVtbl -> GetDocumentContext(This,ppsc)

#define IDebugCodeContext_SetBreakPoint(This,bps)   \
    (This)->lpVtbl -> SetBreakPoint(This,bps)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugCodeContext_GetDocumentContext_Proxy( 
    IDebugCodeContext __RPC_FAR * This,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);


void __RPC_STUB IDebugCodeContext_GetDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugCodeContext_SetBreakPoint_Proxy( 
    IDebugCodeContext __RPC_FAR * This,
    /* [in] */ BREAKPOINT_STATE bps);


void __RPC_STUB IDebugCodeContext_SetBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugCodeContext_INTERFACE_DEFINED__ */


#ifndef __IDebugExpression_INTERFACE_DEFINED__
#define __IDebugExpression_INTERFACE_DEFINED__

/* interface IDebugExpression */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpression;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C14-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpression : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ IDebugExpressionCallBack __RPC_FAR *pdecb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultAsString( 
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ BSTR __RPC_FAR *pbstrResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultAsDebugProperty( 
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdp) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugExpressionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExpression __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExpression __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExpression __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IDebugExpression __RPC_FAR * This,
            /* [in] */ IDebugExpressionCallBack __RPC_FAR *pdecb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IDebugExpression __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsComplete )( 
            IDebugExpression __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultAsString )( 
            IDebugExpression __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ BSTR __RPC_FAR *pbstrResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultAsDebugProperty )( 
            IDebugExpression __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdp);
        
        END_INTERFACE
    } IDebugExpressionVtbl;

    interface IDebugExpression
    {
        CONST_VTBL struct IDebugExpressionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpression_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpression_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpression_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugExpression_Start(This,pdecb)  \
    (This)->lpVtbl -> Start(This,pdecb)

#define IDebugExpression_Abort(This)    \
    (This)->lpVtbl -> Abort(This)

#define IDebugExpression_QueryIsComplete(This)  \
    (This)->lpVtbl -> QueryIsComplete(This)

#define IDebugExpression_GetResultAsString(This,phrResult,pbstrResult)  \
    (This)->lpVtbl -> GetResultAsString(This,phrResult,pbstrResult)

#define IDebugExpression_GetResultAsDebugProperty(This,phrResult,ppdp)  \
    (This)->lpVtbl -> GetResultAsDebugProperty(This,phrResult,ppdp)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpression_Start_Proxy( 
    IDebugExpression __RPC_FAR * This,
    /* [in] */ IDebugExpressionCallBack __RPC_FAR *pdecb);


void __RPC_STUB IDebugExpression_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression_Abort_Proxy( 
    IDebugExpression __RPC_FAR * This);


void __RPC_STUB IDebugExpression_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression_QueryIsComplete_Proxy( 
    IDebugExpression __RPC_FAR * This);


void __RPC_STUB IDebugExpression_QueryIsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression_GetResultAsString_Proxy( 
    IDebugExpression __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phrResult,
    /* [out] */ BSTR __RPC_FAR *pbstrResult);


void __RPC_STUB IDebugExpression_GetResultAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpression_GetResultAsDebugProperty_Proxy( 
    IDebugExpression __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phrResult,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdp);


void __RPC_STUB IDebugExpression_GetResultAsDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugExpression_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionContext_INTERFACE_DEFINED__
#define __IDebugExpressionContext_INTERFACE_DEFINED__

/* interface IDebugExpressionContext */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpressionContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C15-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpressionContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseLanguageText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ UINT nRadix,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDebugExpression __RPC_FAR *__RPC_FAR *ppe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrLanguageName,
            /* [out] */ GUID __RPC_FAR *pLanguageID) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugExpressionContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExpressionContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExpressionContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExpressionContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseLanguageText )( 
            IDebugExpressionContext __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ UINT nRadix,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDebugExpression __RPC_FAR *__RPC_FAR *ppe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageInfo )( 
            IDebugExpressionContext __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLanguageName,
            /* [out] */ GUID __RPC_FAR *pLanguageID);
        
        END_INTERFACE
    } IDebugExpressionContextVtbl;

    interface IDebugExpressionContext
    {
        CONST_VTBL struct IDebugExpressionContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionContext_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpressionContext_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpressionContext_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugExpressionContext_ParseLanguageText(This,pstrCode,nRadix,pstrDelimiter,dwFlags,ppe)   \
    (This)->lpVtbl -> ParseLanguageText(This,pstrCode,nRadix,pstrDelimiter,dwFlags,ppe)

#define IDebugExpressionContext_GetLanguageInfo(This,pbstrLanguageName,pLanguageID) \
    (This)->lpVtbl -> GetLanguageInfo(This,pbstrLanguageName,pLanguageID)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpressionContext_ParseLanguageText_Proxy( 
    IDebugExpressionContext __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrCode,
    /* [in] */ UINT nRadix,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDebugExpression __RPC_FAR *__RPC_FAR *ppe);


void __RPC_STUB IDebugExpressionContext_ParseLanguageText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExpressionContext_GetLanguageInfo_Proxy( 
    IDebugExpressionContext __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLanguageName,
    /* [out] */ GUID __RPC_FAR *pLanguageID);


void __RPC_STUB IDebugExpressionContext_GetLanguageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugExpressionContext_INTERFACE_DEFINED__ */


#ifndef __IDebugExpressionCallBack_INTERFACE_DEFINED__
#define __IDebugExpressionCallBack_INTERFACE_DEFINED__

/* interface IDebugExpressionCallBack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExpressionCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C16-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExpressionCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onComplete( void) = 0;
        
    };
    
#else  /* C style interface */

    typedef struct IDebugExpressionCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExpressionCallBack __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExpressionCallBack __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExpressionCallBack __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onComplete )( 
            IDebugExpressionCallBack __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugExpressionCallBackVtbl;

    interface IDebugExpressionCallBack
    {
        CONST_VTBL struct IDebugExpressionCallBackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExpressionCallBack_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExpressionCallBack_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugExpressionCallBack_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugExpressionCallBack_onComplete(This)   \
    (This)->lpVtbl -> onComplete(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExpressionCallBack_onComplete_Proxy( 
    IDebugExpressionCallBack __RPC_FAR * This);


void __RPC_STUB IDebugExpressionCallBack_onComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugExpressionCallBack_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrame_INTERFACE_DEFINED__
#define __IDebugStackFrame_INTERFACE_DEFINED__

/* interface IDebugStackFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C17-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodeContext( 
            /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *ppcc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionString( 
            /* [in] */ BOOL fLong,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageString( 
            /* [in] */ BOOL fLong,
            /* [out] */ BSTR __RPC_FAR *pbstrLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugProperty( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else  /* C style interface */

    typedef struct IDebugStackFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugStackFrame __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugStackFrame __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodeContext )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *ppcc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionString )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [in] */ BOOL fLong,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageString )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [in] */ BOOL fLong,
            /* [out] */ BSTR __RPC_FAR *pbstrLanguage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThread )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugProperty )( 
            IDebugStackFrame __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugStackFrameVtbl;

    interface IDebugStackFrame
    {
        CONST_VTBL struct IDebugStackFrameVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrame_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStackFrame_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugStackFrame_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugStackFrame_GetCodeContext(This,ppcc)  \
    (This)->lpVtbl -> GetCodeContext(This,ppcc)

#define IDebugStackFrame_GetDescriptionString(This,fLong,pbstrDescription)  \
    (This)->lpVtbl -> GetDescriptionString(This,fLong,pbstrDescription)

#define IDebugStackFrame_GetLanguageString(This,fLong,pbstrLanguage)    \
    (This)->lpVtbl -> GetLanguageString(This,fLong,pbstrLanguage)

#define IDebugStackFrame_GetThread(This,ppat)   \
    (This)->lpVtbl -> GetThread(This,ppat)

#define IDebugStackFrame_GetDebugProperty(This,ppDebugProp) \
    (This)->lpVtbl -> GetDebugProperty(This,ppDebugProp)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugStackFrame_GetCodeContext_Proxy( 
    IDebugStackFrame __RPC_FAR * This,
    /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *ppcc);


void __RPC_STUB IDebugStackFrame_GetCodeContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame_GetDescriptionString_Proxy( 
    IDebugStackFrame __RPC_FAR * This,
    /* [in] */ BOOL fLong,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IDebugStackFrame_GetDescriptionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame_GetLanguageString_Proxy( 
    IDebugStackFrame __RPC_FAR * This,
    /* [in] */ BOOL fLong,
    /* [out] */ BSTR __RPC_FAR *pbstrLanguage);


void __RPC_STUB IDebugStackFrame_GetLanguageString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame_GetThread_Proxy( 
    IDebugStackFrame __RPC_FAR * This,
    /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppat);


void __RPC_STUB IDebugStackFrame_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugStackFrame_GetDebugProperty_Proxy( 
    IDebugStackFrame __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugStackFrame_GetDebugProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugStackFrame_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrameSniffer_INTERFACE_DEFINED__
#define __IDebugStackFrameSniffer_INTERFACE_DEFINED__

/* interface IDebugStackFrameSniffer */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSniffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C18-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrameSniffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFrames( 
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugStackFrameSnifferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugStackFrameSniffer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugStackFrameSniffer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugStackFrameSniffer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IDebugStackFrameSniffer __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferVtbl;

    interface IDebugStackFrameSniffer
    {
        CONST_VTBL struct IDebugStackFrameSnifferVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSniffer_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStackFrameSniffer_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugStackFrameSniffer_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugStackFrameSniffer_EnumStackFrames(This,ppedsf)    \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugStackFrameSniffer_EnumStackFrames_Proxy( 
    IDebugStackFrameSniffer __RPC_FAR * This,
    /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);


void __RPC_STUB IDebugStackFrameSniffer_EnumStackFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugStackFrameSniffer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0200 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugStackFrameSnifferEx IDebugStackFrameSnifferEx64
#define IID_IDebugStackFrameSnifferEx IID_IDebugStackFrameSnifferEx64
#define EnumStackFramesEx EnumStackFramesEx64
#else
#define IDebugStackFrameSnifferEx IDebugStackFrameSnifferEx32
#define IID_IDebugStackFrameSnifferEx IID_IDebugStackFrameSnifferEx32
#define EnumStackFramesEx EnumStackFramesEx32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0200_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0200_v0_0_s_ifspec;

#ifndef __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__
#define __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__

/* interface IDebugStackFrameSnifferEx32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSnifferEx32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C19-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugStackFrameSnifferEx32 : public IDebugStackFrameSniffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFramesEx32( 
            /* [in] */ DWORD dwSpMin,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugStackFrameSnifferEx32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugStackFrameSnifferEx32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugStackFrameSnifferEx32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugStackFrameSnifferEx32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IDebugStackFrameSnifferEx32 __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFramesEx32 )( 
            IDebugStackFrameSnifferEx32 __RPC_FAR * This,
            /* [in] */ DWORD dwSpMin,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferEx32Vtbl;

    interface IDebugStackFrameSnifferEx32
    {
        CONST_VTBL struct IDebugStackFrameSnifferEx32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSnifferEx32_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStackFrameSnifferEx32_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugStackFrameSnifferEx32_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugStackFrameSnifferEx32_EnumStackFrames(This,ppedsf)    \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)


#define IDebugStackFrameSnifferEx32_EnumStackFramesEx32(This,dwSpMin,ppedsf)    \
    (This)->lpVtbl -> EnumStackFramesEx32(This,dwSpMin,ppedsf)

#endif /* COBJMACROS */


#endif   /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugStackFrameSnifferEx32_EnumStackFramesEx32_Proxy( 
    IDebugStackFrameSnifferEx32 __RPC_FAR * This,
    /* [in] */ DWORD dwSpMin,
    /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);


void __RPC_STUB IDebugStackFrameSnifferEx32_EnumStackFramesEx32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugStackFrameSnifferEx32_INTERFACE_DEFINED__ */


#ifndef __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__
#define __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__

/* interface IDebugStackFrameSnifferEx64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugStackFrameSnifferEx64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8cd12af4-49c1-4d52-8d8a-c146f47581aa")
    IDebugStackFrameSnifferEx64 : public IDebugStackFrameSniffer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumStackFramesEx64( 
            /* [in] */ DWORDLONG dwSpMin,
            /* [out] */ IEnumDebugStackFrames64 __RPC_FAR *__RPC_FAR *ppedsf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugStackFrameSnifferEx64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugStackFrameSnifferEx64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugStackFrameSnifferEx64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugStackFrameSnifferEx64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IDebugStackFrameSnifferEx64 __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFramesEx64 )( 
            IDebugStackFrameSnifferEx64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwSpMin,
            /* [out] */ IEnumDebugStackFrames64 __RPC_FAR *__RPC_FAR *ppedsf);
        
        END_INTERFACE
    } IDebugStackFrameSnifferEx64Vtbl;

    interface IDebugStackFrameSnifferEx64
    {
        CONST_VTBL struct IDebugStackFrameSnifferEx64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugStackFrameSnifferEx64_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugStackFrameSnifferEx64_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugStackFrameSnifferEx64_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugStackFrameSnifferEx64_EnumStackFrames(This,ppedsf)    \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)


#define IDebugStackFrameSnifferEx64_EnumStackFramesEx64(This,dwSpMin,ppedsf)    \
    (This)->lpVtbl -> EnumStackFramesEx64(This,dwSpMin,ppedsf)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugStackFrameSnifferEx64_EnumStackFramesEx64_Proxy( 
    IDebugStackFrameSnifferEx64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwSpMin,
    /* [out] */ IEnumDebugStackFrames64 __RPC_FAR *__RPC_FAR *ppedsf);


void __RPC_STUB IDebugStackFrameSnifferEx64_EnumStackFramesEx64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugStackFrameSnifferEx64_INTERFACE_DEFINED__ */


#ifndef __IDebugSyncOperation_INTERFACE_DEFINED__
#define __IDebugSyncOperation_INTERFACE_DEFINED__

/* interface IDebugSyncOperation */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugSyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1a-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetThread( 
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppatTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InProgressAbort( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugSyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugSyncOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugSyncOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugSyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetThread )( 
            IDebugSyncOperation __RPC_FAR * This,
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppatTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            IDebugSyncOperation __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InProgressAbort )( 
            IDebugSyncOperation __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugSyncOperationVtbl;

    interface IDebugSyncOperation
    {
        CONST_VTBL struct IDebugSyncOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSyncOperation_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugSyncOperation_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugSyncOperation_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugSyncOperation_GetTargetThread(This,ppatTarget)    \
    (This)->lpVtbl -> GetTargetThread(This,ppatTarget)

#define IDebugSyncOperation_Execute(This,ppunkResult)   \
    (This)->lpVtbl -> Execute(This,ppunkResult)

#define IDebugSyncOperation_InProgressAbort(This)   \
    (This)->lpVtbl -> InProgressAbort(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugSyncOperation_GetTargetThread_Proxy( 
    IDebugSyncOperation __RPC_FAR * This,
    /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *ppatTarget);


void __RPC_STUB IDebugSyncOperation_GetTargetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSyncOperation_Execute_Proxy( 
    IDebugSyncOperation __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);


void __RPC_STUB IDebugSyncOperation_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugSyncOperation_InProgressAbort_Proxy( 
    IDebugSyncOperation __RPC_FAR * This);


void __RPC_STUB IDebugSyncOperation_InProgressAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugSyncOperation_INTERFACE_DEFINED__ */


#ifndef __IDebugAsyncOperation_INTERFACE_DEFINED__
#define __IDebugAsyncOperation_INTERFACE_DEFINED__

/* interface IDebugAsyncOperation */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugAsyncOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1b-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugAsyncOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncDebugOperation( 
            /* [out] */ IDebugSyncOperation __RPC_FAR *__RPC_FAR *ppsdo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            IDebugAsyncOperationCallBack __RPC_FAR *padocb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugAsyncOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugAsyncOperation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugAsyncOperation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugAsyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncDebugOperation )( 
            IDebugAsyncOperation __RPC_FAR * This,
            /* [out] */ IDebugSyncOperation __RPC_FAR *__RPC_FAR *ppsdo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IDebugAsyncOperation __RPC_FAR * This,
            IDebugAsyncOperationCallBack __RPC_FAR *padocb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IDebugAsyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsComplete )( 
            IDebugAsyncOperation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResult )( 
            IDebugAsyncOperation __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phrResult,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);
        
        END_INTERFACE
    } IDebugAsyncOperationVtbl;

    interface IDebugAsyncOperation
    {
        CONST_VTBL struct IDebugAsyncOperationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugAsyncOperation_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugAsyncOperation_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugAsyncOperation_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugAsyncOperation_GetSyncDebugOperation(This,ppsdo)  \
    (This)->lpVtbl -> GetSyncDebugOperation(This,ppsdo)

#define IDebugAsyncOperation_Start(This,padocb) \
    (This)->lpVtbl -> Start(This,padocb)

#define IDebugAsyncOperation_Abort(This)    \
    (This)->lpVtbl -> Abort(This)

#define IDebugAsyncOperation_QueryIsComplete(This)  \
    (This)->lpVtbl -> QueryIsComplete(This)

#define IDebugAsyncOperation_GetResult(This,phrResult,ppunkResult)  \
    (This)->lpVtbl -> GetResult(This,phrResult,ppunkResult)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugAsyncOperation_GetSyncDebugOperation_Proxy( 
    IDebugAsyncOperation __RPC_FAR * This,
    /* [out] */ IDebugSyncOperation __RPC_FAR *__RPC_FAR *ppsdo);


void __RPC_STUB IDebugAsyncOperation_GetSyncDebugOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugAsyncOperation_Start_Proxy( 
    IDebugAsyncOperation __RPC_FAR * This,
    IDebugAsyncOperationCallBack __RPC_FAR *padocb);


void __RPC_STUB IDebugAsyncOperation_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugAsyncOperation_Abort_Proxy( 
    IDebugAsyncOperation __RPC_FAR * This);


void __RPC_STUB IDebugAsyncOperation_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugAsyncOperation_QueryIsComplete_Proxy( 
    IDebugAsyncOperation __RPC_FAR * This);


void __RPC_STUB IDebugAsyncOperation_QueryIsComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugAsyncOperation_GetResult_Proxy( 
    IDebugAsyncOperation __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phrResult,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkResult);


void __RPC_STUB IDebugAsyncOperation_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugAsyncOperation_INTERFACE_DEFINED__ */


#ifndef __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__
#define __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__

/* interface IDebugAsyncOperationCallBack */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugAsyncOperationCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1c-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugAsyncOperationCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onComplete( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugAsyncOperationCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugAsyncOperationCallBack __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugAsyncOperationCallBack __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugAsyncOperationCallBack __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onComplete )( 
            IDebugAsyncOperationCallBack __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugAsyncOperationCallBackVtbl;

    interface IDebugAsyncOperationCallBack
    {
        CONST_VTBL struct IDebugAsyncOperationCallBackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugAsyncOperationCallBack_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugAsyncOperationCallBack_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugAsyncOperationCallBack_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugAsyncOperationCallBack_onComplete(This)   \
    (This)->lpVtbl -> onComplete(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugAsyncOperationCallBack_onComplete_Proxy( 
    IDebugAsyncOperationCallBack __RPC_FAR * This);


void __RPC_STUB IDebugAsyncOperationCallBack_onComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugAsyncOperationCallBack_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugCodeContexts_INTERFACE_DEFINED__
#define __IEnumDebugCodeContexts_INTERFACE_DEFINED__

/* interface IEnumDebugCodeContexts */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugCodeContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1d-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugCodeContexts : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *pscc,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumDebugCodeContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugCodeContexts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugCodeContexts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugCodeContexts __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumDebugCodeContexts __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *pscc,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugCodeContexts __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugCodeContexts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugCodeContexts __RPC_FAR * This,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);
        
        END_INTERFACE
    } IEnumDebugCodeContextsVtbl;

    interface IEnumDebugCodeContexts
    {
        CONST_VTBL struct IEnumDebugCodeContextsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugCodeContexts_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugCodeContexts_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugCodeContexts_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumDebugCodeContexts_Next(This,celt,pscc,pceltFetched)    \
    (This)->lpVtbl -> Next(This,celt,pscc,pceltFetched)

#define IEnumDebugCodeContexts_Skip(This,celt)  \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugCodeContexts_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugCodeContexts_Clone(This,ppescc)   \
    (This)->lpVtbl -> Clone(This,ppescc)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugCodeContexts_RemoteNext_Proxy( 
    IEnumDebugCodeContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *pscc,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugCodeContexts_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts_Skip_Proxy( 
    IEnumDebugCodeContexts __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugCodeContexts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts_Reset_Proxy( 
    IEnumDebugCodeContexts __RPC_FAR * This);


void __RPC_STUB IEnumDebugCodeContexts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugCodeContexts_Clone_Proxy( 
    IEnumDebugCodeContexts __RPC_FAR * This,
    /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);


void __RPC_STUB IEnumDebugCodeContexts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumDebugCodeContexts_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0206 */
/* [local] */ 

typedef struct tagDebugStackFrameDescriptor
    {
    IDebugStackFrame __RPC_FAR *pdsf;
    DWORD dwMin;
    DWORD dwLim;
    BOOL fFinal;
    IUnknown __RPC_FAR *punkFinal;
    }   DebugStackFrameDescriptor;

typedef struct tagDebugStackFrameDescriptor64
    {
    IDebugStackFrame __RPC_FAR *pdsf;
    DWORDLONG dwMin;
    DWORDLONG dwLim;
    BOOL fFinal;
    IUnknown __RPC_FAR *punkFinal;
    }   DebugStackFrameDescriptor64;



extern RPC_IF_HANDLE __MIDL_itf_activdbg_0206_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0206_v0_0_s_ifspec;

#ifndef __IEnumDebugStackFrames_INTERFACE_DEFINED__
#define __IEnumDebugStackFrames_INTERFACE_DEFINED__

/* interface IEnumDebugStackFrames */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugStackFrames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1e-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugStackFrames : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumDebugStackFramesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugStackFrames __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugStackFrames __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugStackFrames __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumDebugStackFrames __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugStackFrames __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugStackFrames __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugStackFrames __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        END_INTERFACE
    } IEnumDebugStackFramesVtbl;

    interface IEnumDebugStackFrames
    {
        CONST_VTBL struct IEnumDebugStackFramesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugStackFrames_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugStackFrames_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugStackFrames_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IEnumDebugStackFrames_Next(This,celt,prgdsfd,pceltFetched)  \
    (This)->lpVtbl -> Next(This,celt,prgdsfd,pceltFetched)

#define IEnumDebugStackFrames_Skip(This,celt)   \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugStackFrames_Reset(This)   \
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugStackFrames_Clone(This,ppedsf)    \
    (This)->lpVtbl -> Clone(This,ppedsf)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames_RemoteNext_Proxy( 
    IEnumDebugStackFrames __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugStackFrames_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames_Skip_Proxy( 
    IEnumDebugStackFrames __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugStackFrames_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames_Reset_Proxy( 
    IEnumDebugStackFrames __RPC_FAR * This);


void __RPC_STUB IEnumDebugStackFrames_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugStackFrames_Clone_Proxy( 
    IEnumDebugStackFrames __RPC_FAR * This,
    /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);


void __RPC_STUB IEnumDebugStackFrames_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumDebugStackFrames_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugStackFrames64_INTERFACE_DEFINED__
#define __IEnumDebugStackFrames64_INTERFACE_DEFINED__

/* interface IEnumDebugStackFrames64 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugStackFrames64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0dc38853-c1b0-4176-a984-b298361027af")
    IEnumDebugStackFrames64 : public IEnumDebugStackFrames
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next64( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor64 __RPC_FAR *prgdsfd,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumDebugStackFrames64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugStackFrames64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugStackFrames64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugStackFrames64 __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumDebugStackFrames64 __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugStackFrames64 __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugStackFrames64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugStackFrames64 __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next64 )( 
            IEnumDebugStackFrames64 __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugStackFrameDescriptor64 __RPC_FAR *prgdsfd,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        END_INTERFACE
    } IEnumDebugStackFrames64Vtbl;

    interface IEnumDebugStackFrames64
    {
        CONST_VTBL struct IEnumDebugStackFrames64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugStackFrames64_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugStackFrames64_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugStackFrames64_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IEnumDebugStackFrames64_Next(This,celt,prgdsfd,pceltFetched)    \
    (This)->lpVtbl -> Next(This,celt,prgdsfd,pceltFetched)

#define IEnumDebugStackFrames64_Skip(This,celt) \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugStackFrames64_Reset(This) \
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugStackFrames64_Clone(This,ppedsf)  \
    (This)->lpVtbl -> Clone(This,ppedsf)


#define IEnumDebugStackFrames64_Next64(This,celt,prgdsfd,pceltFetched)  \
    (This)->lpVtbl -> Next64(This,celt,prgdsfd,pceltFetched)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames64_RemoteNext64_Proxy( 
    IEnumDebugStackFrames64 __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugStackFrameDescriptor64 __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugStackFrames64_RemoteNext64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumDebugStackFrames64_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentInfo_INTERFACE_DEFINED__
#define __IDebugDocumentInfo_INTERFACE_DEFINED__

/* interface IDebugDocumentInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C1f-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentClassId( 
            /* [out] */ CLSID __RPC_FAR *pclsidDocument) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugDocumentInfo __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugDocumentInfo __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        END_INTERFACE
    } IDebugDocumentInfoVtbl;

    interface IDebugDocumentInfo
    {
        CONST_VTBL struct IDebugDocumentInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentInfo_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentInfo_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentInfo_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentInfo_GetName(This,dnt,pbstrName)  \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugDocumentInfo_GetDocumentClassId(This,pclsidDocument)  \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentInfo_GetName_Proxy( 
    IDebugDocumentInfo __RPC_FAR * This,
    /* [in] */ DOCUMENTNAMETYPE dnt,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IDebugDocumentInfo_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentInfo_GetDocumentClassId_Proxy( 
    IDebugDocumentInfo __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidDocument);


void __RPC_STUB IDebugDocumentInfo_GetDocumentClassId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentProvider_INTERFACE_DEFINED__
#define __IDebugDocumentProvider_INTERFACE_DEFINED__

/* interface IDebugDocumentProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C20-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentProvider : public IDebugDocumentInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppssd) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugDocumentProvider __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugDocumentProvider __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocument )( 
            IDebugDocumentProvider __RPC_FAR * This,
            /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppssd);
        
        END_INTERFACE
    } IDebugDocumentProviderVtbl;

    interface IDebugDocumentProvider
    {
        CONST_VTBL struct IDebugDocumentProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentProvider_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentProvider_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentProvider_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentProvider_GetName(This,dnt,pbstrName)  \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugDocumentProvider_GetDocumentClassId(This,pclsidDocument)  \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)


#define IDebugDocumentProvider_GetDocument(This,ppssd)  \
    (This)->lpVtbl -> GetDocument(This,ppssd)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentProvider_GetDocument_Proxy( 
    IDebugDocumentProvider __RPC_FAR * This,
    /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppssd);


void __RPC_STUB IDebugDocumentProvider_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentProvider_INTERFACE_DEFINED__ */


#ifndef __IDebugDocument_INTERFACE_DEFINED__
#define __IDebugDocument_INTERFACE_DEFINED__

/* interface IDebugDocument */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C21-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocument : public IDebugDocumentInfo
    {
    public:
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugDocument __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugDocument __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        END_INTERFACE
    } IDebugDocumentVtbl;

    interface IDebugDocument
    {
        CONST_VTBL struct IDebugDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocument_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocument_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocument_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocument_GetName(This,dnt,pbstrName)  \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugDocument_GetDocumentClassId(This,pclsidDocument)  \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)


#endif /* COBJMACROS */


#endif  /* C style interface */




#endif  /* __IDebugDocument_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentText_INTERFACE_DEFINED__
#define __IDebugDocumentText_INTERFACE_DEFINED__

/* interface IDebugDocumentText */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C22-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentText : public IDebugDocument
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocumentAttributes( 
            /* [out] */ TEXT_DOC_ATTR __RPC_FAR *ptextdocattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcNumLines,
            /* [out] */ ULONG __RPC_FAR *pcNumChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionOfLine( 
            /* [in] */ ULONG cLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineOfPosition( 
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *pcLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterOffsetInLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
            /* [full][size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
            /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
            /* [in] */ ULONG cMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPositionOfContext( 
            /* [in] */ IDebugDocumentContext __RPC_FAR *psc,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *cNumChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextOfPosition( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentText __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentText __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentAttributes )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [out] */ TEXT_DOC_ATTR __RPC_FAR *ptextdocattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcNumLines,
            /* [out] */ ULONG __RPC_FAR *pcNumChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPositionOfLine )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ ULONG cLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineOfPosition )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *pcLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterOffsetInLine);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
            /* [full][size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
            /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPositionOfContext )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ IDebugDocumentContext __RPC_FAR *psc,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *cNumChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextOfPosition )( 
            IDebugDocumentText __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);
        
        END_INTERFACE
    } IDebugDocumentTextVtbl;

    interface IDebugDocumentText
    {
        CONST_VTBL struct IDebugDocumentTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentText_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentText_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentText_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentText_GetName(This,dnt,pbstrName)  \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugDocumentText_GetDocumentClassId(This,pclsidDocument)  \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)



#define IDebugDocumentText_GetDocumentAttributes(This,ptextdocattr) \
    (This)->lpVtbl -> GetDocumentAttributes(This,ptextdocattr)

#define IDebugDocumentText_GetSize(This,pcNumLines,pcNumChars)  \
    (This)->lpVtbl -> GetSize(This,pcNumLines,pcNumChars)

#define IDebugDocumentText_GetPositionOfLine(This,cLineNumber,pcCharacterPosition)  \
    (This)->lpVtbl -> GetPositionOfLine(This,cLineNumber,pcCharacterPosition)

#define IDebugDocumentText_GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)  \
    (This)->lpVtbl -> GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)

#define IDebugDocumentText_GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars) \
    (This)->lpVtbl -> GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars)

#define IDebugDocumentText_GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars) \
    (This)->lpVtbl -> GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars)

#define IDebugDocumentText_GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc) \
    (This)->lpVtbl -> GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetDocumentAttributes_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [out] */ TEXT_DOC_ATTR __RPC_FAR *ptextdocattr);


void __RPC_STUB IDebugDocumentText_GetDocumentAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetSize_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcNumLines,
    /* [out] */ ULONG __RPC_FAR *pcNumChars);


void __RPC_STUB IDebugDocumentText_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetPositionOfLine_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [in] */ ULONG cLineNumber,
    /* [out] */ ULONG __RPC_FAR *pcCharacterPosition);


void __RPC_STUB IDebugDocumentText_GetPositionOfLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetLineOfPosition_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [out] */ ULONG __RPC_FAR *pcLineNumber,
    /* [out] */ ULONG __RPC_FAR *pcCharacterOffsetInLine);


void __RPC_STUB IDebugDocumentText_GetLineOfPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetText_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
    /* [full][size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
    /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
    /* [in] */ ULONG cMaxChars);


void __RPC_STUB IDebugDocumentText_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetPositionOfContext_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [in] */ IDebugDocumentContext __RPC_FAR *psc,
    /* [out] */ ULONG __RPC_FAR *pcCharacterPosition,
    /* [out] */ ULONG __RPC_FAR *cNumChars);


void __RPC_STUB IDebugDocumentText_GetPositionOfContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentText_GetContextOfPosition_Proxy( 
    IDebugDocumentText __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumChars,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);


void __RPC_STUB IDebugDocumentText_GetContextOfPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentText_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentTextEvents_INTERFACE_DEFINED__
#define __IDebugDocumentTextEvents_INTERFACE_DEFINED__

/* interface IDebugDocumentTextEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C23-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onDestroy( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onInsertText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onReplaceText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateTextAttributes( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToUpdate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onUpdateDocumentAttributes( 
            /* [in] */ TEXT_DOC_ATTR textdocattr) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentTextEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentTextEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentTextEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onDestroy )( 
            IDebugDocumentTextEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onInsertText )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onRemoveText )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onReplaceText )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onUpdateTextAttributes )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToUpdate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onUpdateDocumentAttributes )( 
            IDebugDocumentTextEvents __RPC_FAR * This,
            /* [in] */ TEXT_DOC_ATTR textdocattr);
        
        END_INTERFACE
    } IDebugDocumentTextEventsVtbl;

    interface IDebugDocumentTextEvents
    {
        CONST_VTBL struct IDebugDocumentTextEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextEvents_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentTextEvents_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentTextEvents_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentTextEvents_onDestroy(This)    \
    (This)->lpVtbl -> onDestroy(This)

#define IDebugDocumentTextEvents_onInsertText(This,cCharacterPosition,cNumToInsert) \
    (This)->lpVtbl -> onInsertText(This,cCharacterPosition,cNumToInsert)

#define IDebugDocumentTextEvents_onRemoveText(This,cCharacterPosition,cNumToRemove) \
    (This)->lpVtbl -> onRemoveText(This,cCharacterPosition,cNumToRemove)

#define IDebugDocumentTextEvents_onReplaceText(This,cCharacterPosition,cNumToReplace)   \
    (This)->lpVtbl -> onReplaceText(This,cCharacterPosition,cNumToReplace)

#define IDebugDocumentTextEvents_onUpdateTextAttributes(This,cCharacterPosition,cNumToUpdate)   \
    (This)->lpVtbl -> onUpdateTextAttributes(This,cCharacterPosition,cNumToUpdate)

#define IDebugDocumentTextEvents_onUpdateDocumentAttributes(This,textdocattr)   \
    (This)->lpVtbl -> onUpdateDocumentAttributes(This,textdocattr)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onDestroy_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This);


void __RPC_STUB IDebugDocumentTextEvents_onDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onInsertText_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToInsert);


void __RPC_STUB IDebugDocumentTextEvents_onInsertText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onRemoveText_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToRemove);


void __RPC_STUB IDebugDocumentTextEvents_onRemoveText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onReplaceText_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToReplace);


void __RPC_STUB IDebugDocumentTextEvents_onReplaceText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onUpdateTextAttributes_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToUpdate);


void __RPC_STUB IDebugDocumentTextEvents_onUpdateTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextEvents_onUpdateDocumentAttributes_Proxy( 
    IDebugDocumentTextEvents __RPC_FAR * This,
    /* [in] */ TEXT_DOC_ATTR textdocattr);


void __RPC_STUB IDebugDocumentTextEvents_onUpdateDocumentAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentTextEvents_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentTextAuthor_INTERFACE_DEFINED__
#define __IDebugDocumentTextAuthor_INTERFACE_DEFINED__

/* interface IDebugDocumentTextAuthor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextAuthor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C24-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextAuthor : public IDebugDocumentText
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert,
            /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceText( 
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace,
            /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentTextAuthorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentTextAuthor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentTextAuthor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentAttributes )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [out] */ TEXT_DOC_ATTR __RPC_FAR *ptextdocattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcNumLines,
            /* [out] */ ULONG __RPC_FAR *pcNumChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPositionOfLine )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineOfPosition )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *pcLineNumber,
            /* [out] */ ULONG __RPC_FAR *pcCharacterOffsetInLine);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
            /* [full][size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
            /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPositionOfContext )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ IDebugDocumentContext __RPC_FAR *psc,
            /* [out] */ ULONG __RPC_FAR *pcCharacterPosition,
            /* [out] */ ULONG __RPC_FAR *cNumChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextOfPosition )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppsc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InsertText )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToInsert,
            /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveText )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToRemove);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReplaceText )( 
            IDebugDocumentTextAuthor __RPC_FAR * This,
            /* [in] */ ULONG cCharacterPosition,
            /* [in] */ ULONG cNumToReplace,
            /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]);
        
        END_INTERFACE
    } IDebugDocumentTextAuthorVtbl;

    interface IDebugDocumentTextAuthor
    {
        CONST_VTBL struct IDebugDocumentTextAuthorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextAuthor_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentTextAuthor_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentTextAuthor_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentTextAuthor_GetName(This,dnt,pbstrName)    \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugDocumentTextAuthor_GetDocumentClassId(This,pclsidDocument)    \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)



#define IDebugDocumentTextAuthor_GetDocumentAttributes(This,ptextdocattr)   \
    (This)->lpVtbl -> GetDocumentAttributes(This,ptextdocattr)

#define IDebugDocumentTextAuthor_GetSize(This,pcNumLines,pcNumChars)    \
    (This)->lpVtbl -> GetSize(This,pcNumLines,pcNumChars)

#define IDebugDocumentTextAuthor_GetPositionOfLine(This,cLineNumber,pcCharacterPosition)    \
    (This)->lpVtbl -> GetPositionOfLine(This,cLineNumber,pcCharacterPosition)

#define IDebugDocumentTextAuthor_GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)    \
    (This)->lpVtbl -> GetLineOfPosition(This,cCharacterPosition,pcLineNumber,pcCharacterOffsetInLine)

#define IDebugDocumentTextAuthor_GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars)   \
    (This)->lpVtbl -> GetText(This,cCharacterPosition,pcharText,pstaTextAttr,pcNumChars,cMaxChars)

#define IDebugDocumentTextAuthor_GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars)   \
    (This)->lpVtbl -> GetPositionOfContext(This,psc,pcCharacterPosition,cNumChars)

#define IDebugDocumentTextAuthor_GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc)   \
    (This)->lpVtbl -> GetContextOfPosition(This,cCharacterPosition,cNumChars,ppsc)


#define IDebugDocumentTextAuthor_InsertText(This,cCharacterPosition,cNumToInsert,pcharText) \
    (This)->lpVtbl -> InsertText(This,cCharacterPosition,cNumToInsert,pcharText)

#define IDebugDocumentTextAuthor_RemoveText(This,cCharacterPosition,cNumToRemove)   \
    (This)->lpVtbl -> RemoveText(This,cCharacterPosition,cNumToRemove)

#define IDebugDocumentTextAuthor_ReplaceText(This,cCharacterPosition,cNumToReplace,pcharText)   \
    (This)->lpVtbl -> ReplaceText(This,cCharacterPosition,cNumToReplace,pcharText)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentTextAuthor_InsertText_Proxy( 
    IDebugDocumentTextAuthor __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToInsert,
    /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]);


void __RPC_STUB IDebugDocumentTextAuthor_InsertText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextAuthor_RemoveText_Proxy( 
    IDebugDocumentTextAuthor __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToRemove);


void __RPC_STUB IDebugDocumentTextAuthor_RemoveText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextAuthor_ReplaceText_Proxy( 
    IDebugDocumentTextAuthor __RPC_FAR * This,
    /* [in] */ ULONG cCharacterPosition,
    /* [in] */ ULONG cNumToReplace,
    /* [size_is][in] */ OLECHAR __RPC_FAR pcharText[  ]);


void __RPC_STUB IDebugDocumentTextAuthor_ReplaceText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentTextAuthor_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__
#define __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__

/* interface IDebugDocumentTextExternalAuthor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentTextExternalAuthor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C25-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentTextExternalAuthor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPathName( 
            /* [out] */ BSTR __RPC_FAR *pbstrLongName,
            /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ BSTR __RPC_FAR *pbstrShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyChanged( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentTextExternalAuthorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathName )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLongName,
            /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileName )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrShortName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyChanged )( 
            IDebugDocumentTextExternalAuthor __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugDocumentTextExternalAuthorVtbl;

    interface IDebugDocumentTextExternalAuthor
    {
        CONST_VTBL struct IDebugDocumentTextExternalAuthorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentTextExternalAuthor_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentTextExternalAuthor_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentTextExternalAuthor_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentTextExternalAuthor_GetPathName(This,pbstrLongName,pfIsOriginalFile)   \
    (This)->lpVtbl -> GetPathName(This,pbstrLongName,pfIsOriginalFile)

#define IDebugDocumentTextExternalAuthor_GetFileName(This,pbstrShortName)   \
    (This)->lpVtbl -> GetFileName(This,pbstrShortName)

#define IDebugDocumentTextExternalAuthor_NotifyChanged(This)    \
    (This)->lpVtbl -> NotifyChanged(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentTextExternalAuthor_GetPathName_Proxy( 
    IDebugDocumentTextExternalAuthor __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLongName,
    /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile);


void __RPC_STUB IDebugDocumentTextExternalAuthor_GetPathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextExternalAuthor_GetFileName_Proxy( 
    IDebugDocumentTextExternalAuthor __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrShortName);


void __RPC_STUB IDebugDocumentTextExternalAuthor_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentTextExternalAuthor_NotifyChanged_Proxy( 
    IDebugDocumentTextExternalAuthor __RPC_FAR * This);


void __RPC_STUB IDebugDocumentTextExternalAuthor_NotifyChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentTextExternalAuthor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0215 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugDocumentHelper IDebugDocumentHelper64
#define IID_IDebugDocumentHelper IID_IDebugDocumentHelper64
#else
#define IDebugDocumentHelper IDebugDocumentHelper32
#define IID_IDebugDocumentHelper IID_IDebugDocumentHelper32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0215_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0215_v0_0_s_ifspec;

#ifndef __IDebugDocumentHelper32_INTERFACE_DEFINED__
#define __IDebugDocumentHelper32_INTERFACE_DEFINED__

/* interface IDebugDocumentHelper32 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHelper32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C26-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentHelper32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IDebugApplication32 __RPC_FAR *pda,
            /* [string][in] */ LPCOLESTR pszShortName,
            /* [string][in] */ LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugDocumentHelper32 __RPC_FAR *pddhParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUnicodeText( 
            /* [string][in] */ LPCOLESTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDBCSText( 
            /* [string][in] */ LPCSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugDocumentHost( 
            /* [in] */ IDebugDocumentHost __RPC_FAR *pddh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDeferredText( 
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineScriptBlock( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ IActiveScript __RPC_FAR *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ DWORD __RPC_FAR *pdwSourceContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTextAttr( 
            SOURCE_TEXT_ATTR staTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextAttributes( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLongName( 
            /* [string][in] */ LPCOLESTR pszLongName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortName( 
            /* [string][in] */ LPCOLESTR pszShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentAttr( 
            /* [in] */ TEXT_DOC_ATTR pszAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptBlockInfo( 
            /* [in] */ DWORD dwSourceContext,
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
            /* [out] */ ULONG __RPC_FAR *piCharPos,
            /* [out] */ ULONG __RPC_FAR *pcChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentContext( 
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            IDebugDocumentContext __RPC_FAR *pddc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentHelper32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentHelper32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentHelper32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ IDebugApplication32 __RPC_FAR *pda,
            /* [string][in] */ LPCOLESTR pszShortName,
            /* [string][in] */ LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ IDebugDocumentHelper32 __RPC_FAR *pddhParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IDebugDocumentHelper32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddUnicodeText )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDBCSText )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDebugDocumentHost )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ IDebugDocumentHost __RPC_FAR *pddh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDeferredText )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefineScriptBlock )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ IActiveScript __RPC_FAR *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ DWORD __RPC_FAR *pdwSourceContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTextAttr )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            SOURCE_TEXT_ATTR staTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextAttributes )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLongName )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszLongName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShortName )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszShortName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocumentAttr )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ TEXT_DOC_ATTR pszAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugApplicationNode )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptBlockInfo )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ DWORD dwSourceContext,
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
            /* [out] */ ULONG __RPC_FAR *piCharPos,
            /* [out] */ ULONG __RPC_FAR *pcChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDebugDocumentContext )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentToTop )( 
            IDebugDocumentHelper32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentContextToTop )( 
            IDebugDocumentHelper32 __RPC_FAR * This,
            IDebugDocumentContext __RPC_FAR *pddc);
        
        END_INTERFACE
    } IDebugDocumentHelper32Vtbl;

    interface IDebugDocumentHelper32
    {
        CONST_VTBL struct IDebugDocumentHelper32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHelper32_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentHelper32_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentHelper32_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentHelper32_Init(This,pda,pszShortName,pszLongName,docAttr)  \
    (This)->lpVtbl -> Init(This,pda,pszShortName,pszLongName,docAttr)

#define IDebugDocumentHelper32_Attach(This,pddhParent)  \
    (This)->lpVtbl -> Attach(This,pddhParent)

#define IDebugDocumentHelper32_Detach(This) \
    (This)->lpVtbl -> Detach(This)

#define IDebugDocumentHelper32_AddUnicodeText(This,pszText) \
    (This)->lpVtbl -> AddUnicodeText(This,pszText)

#define IDebugDocumentHelper32_AddDBCSText(This,pszText)    \
    (This)->lpVtbl -> AddDBCSText(This,pszText)

#define IDebugDocumentHelper32_SetDebugDocumentHost(This,pddh)  \
    (This)->lpVtbl -> SetDebugDocumentHost(This,pddh)

#define IDebugDocumentHelper32_AddDeferredText(This,cChars,dwTextStartCookie)   \
    (This)->lpVtbl -> AddDeferredText(This,cChars,dwTextStartCookie)

#define IDebugDocumentHelper32_DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)  \
    (This)->lpVtbl -> DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)

#define IDebugDocumentHelper32_SetDefaultTextAttr(This,staTextAttr) \
    (This)->lpVtbl -> SetDefaultTextAttr(This,staTextAttr)

#define IDebugDocumentHelper32_SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr) \
    (This)->lpVtbl -> SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr)

#define IDebugDocumentHelper32_SetLongName(This,pszLongName)    \
    (This)->lpVtbl -> SetLongName(This,pszLongName)

#define IDebugDocumentHelper32_SetShortName(This,pszShortName)  \
    (This)->lpVtbl -> SetShortName(This,pszShortName)

#define IDebugDocumentHelper32_SetDocumentAttr(This,pszAttributes)  \
    (This)->lpVtbl -> SetDocumentAttr(This,pszAttributes)

#define IDebugDocumentHelper32_GetDebugApplicationNode(This,ppdan)  \
    (This)->lpVtbl -> GetDebugApplicationNode(This,ppdan)

#define IDebugDocumentHelper32_GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars) \
    (This)->lpVtbl -> GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars)

#define IDebugDocumentHelper32_CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)   \
    (This)->lpVtbl -> CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)

#define IDebugDocumentHelper32_BringDocumentToTop(This) \
    (This)->lpVtbl -> BringDocumentToTop(This)

#define IDebugDocumentHelper32_BringDocumentContextToTop(This,pddc) \
    (This)->lpVtbl -> BringDocumentContextToTop(This,pddc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_Init_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ IDebugApplication32 __RPC_FAR *pda,
    /* [string][in] */ LPCOLESTR pszShortName,
    /* [string][in] */ LPCOLESTR pszLongName,
    /* [in] */ TEXT_DOC_ATTR docAttr);


void __RPC_STUB IDebugDocumentHelper32_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_Attach_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ IDebugDocumentHelper32 __RPC_FAR *pddhParent);


void __RPC_STUB IDebugDocumentHelper32_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_Detach_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This);


void __RPC_STUB IDebugDocumentHelper32_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_AddUnicodeText_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszText);


void __RPC_STUB IDebugDocumentHelper32_AddUnicodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_AddDBCSText_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszText);


void __RPC_STUB IDebugDocumentHelper32_AddDBCSText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetDebugDocumentHost_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ IDebugDocumentHost __RPC_FAR *pddh);


void __RPC_STUB IDebugDocumentHelper32_SetDebugDocumentHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_AddDeferredText_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ ULONG cChars,
    /* [in] */ DWORD dwTextStartCookie);


void __RPC_STUB IDebugDocumentHelper32_AddDeferredText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_DefineScriptBlock_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ ULONG ulCharOffset,
    /* [in] */ ULONG cChars,
    /* [in] */ IActiveScript __RPC_FAR *pas,
    /* [in] */ BOOL fScriptlet,
    /* [out] */ DWORD __RPC_FAR *pdwSourceContext);


void __RPC_STUB IDebugDocumentHelper32_DefineScriptBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetDefaultTextAttr_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    SOURCE_TEXT_ATTR staTextAttr);


void __RPC_STUB IDebugDocumentHelper32_SetDefaultTextAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetTextAttributes_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ ULONG ulCharOffset,
    /* [in] */ ULONG cChars,
    /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr);


void __RPC_STUB IDebugDocumentHelper32_SetTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetLongName_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszLongName);


void __RPC_STUB IDebugDocumentHelper32_SetLongName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetShortName_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszShortName);


void __RPC_STUB IDebugDocumentHelper32_SetShortName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_SetDocumentAttr_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ TEXT_DOC_ATTR pszAttributes);


void __RPC_STUB IDebugDocumentHelper32_SetDocumentAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_GetDebugApplicationNode_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan);


void __RPC_STUB IDebugDocumentHelper32_GetDebugApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_GetScriptBlockInfo_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ DWORD dwSourceContext,
    /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
    /* [out] */ ULONG __RPC_FAR *piCharPos,
    /* [out] */ ULONG __RPC_FAR *pcChars);


void __RPC_STUB IDebugDocumentHelper32_GetScriptBlockInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_CreateDebugDocumentContext_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    /* [in] */ ULONG iCharPos,
    /* [in] */ ULONG cChars,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc);


void __RPC_STUB IDebugDocumentHelper32_CreateDebugDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_BringDocumentToTop_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This);


void __RPC_STUB IDebugDocumentHelper32_BringDocumentToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper32_BringDocumentContextToTop_Proxy( 
    IDebugDocumentHelper32 __RPC_FAR * This,
    IDebugDocumentContext __RPC_FAR *pddc);


void __RPC_STUB IDebugDocumentHelper32_BringDocumentContextToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentHelper32_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentHelper64_INTERFACE_DEFINED__
#define __IDebugDocumentHelper64_INTERFACE_DEFINED__

/* interface IDebugDocumentHelper64 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHelper64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c4c7363c-20fd-47f9-bd82-4855e0150871")
    IDebugDocumentHelper64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IDebugApplication64 __RPC_FAR *pda,
            /* [string][in] */ LPCOLESTR pszShortName,
            /* [string][in] */ LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugDocumentHelper64 __RPC_FAR *pddhParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddUnicodeText( 
            /* [string][in] */ LPCOLESTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDBCSText( 
            /* [string][in] */ LPCSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugDocumentHost( 
            /* [in] */ IDebugDocumentHost __RPC_FAR *pddh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDeferredText( 
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineScriptBlock( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ IActiveScript __RPC_FAR *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ DWORDLONG __RPC_FAR *pdwSourceContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultTextAttr( 
            SOURCE_TEXT_ATTR staTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextAttributes( 
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLongName( 
            /* [string][in] */ LPCOLESTR pszLongName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShortName( 
            /* [string][in] */ LPCOLESTR pszShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentAttr( 
            /* [in] */ TEXT_DOC_ATTR pszAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptBlockInfo( 
            /* [in] */ DWORDLONG dwSourceContext,
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
            /* [out] */ ULONG __RPC_FAR *piCharPos,
            /* [out] */ ULONG __RPC_FAR *pcChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentContext( 
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            IDebugDocumentContext __RPC_FAR *pddc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentHelper64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentHelper64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentHelper64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ IDebugApplication64 __RPC_FAR *pda,
            /* [string][in] */ LPCOLESTR pszShortName,
            /* [string][in] */ LPCOLESTR pszLongName,
            /* [in] */ TEXT_DOC_ATTR docAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ IDebugDocumentHelper64 __RPC_FAR *pddhParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IDebugDocumentHelper64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddUnicodeText )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDBCSText )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [string][in] */ LPCSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDebugDocumentHost )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ IDebugDocumentHost __RPC_FAR *pddh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDeferredText )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ ULONG cChars,
            /* [in] */ DWORD dwTextStartCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefineScriptBlock )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [in] */ IActiveScript __RPC_FAR *pas,
            /* [in] */ BOOL fScriptlet,
            /* [out] */ DWORDLONG __RPC_FAR *pdwSourceContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTextAttr )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            SOURCE_TEXT_ATTR staTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextAttributes )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ ULONG ulCharOffset,
            /* [in] */ ULONG cChars,
            /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLongName )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszLongName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShortName )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [string][in] */ LPCOLESTR pszShortName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocumentAttr )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ TEXT_DOC_ATTR pszAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugApplicationNode )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptBlockInfo )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwSourceContext,
            /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
            /* [out] */ ULONG __RPC_FAR *piCharPos,
            /* [out] */ ULONG __RPC_FAR *pcChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDebugDocumentContext )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            /* [in] */ ULONG iCharPos,
            /* [in] */ ULONG cChars,
            /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentToTop )( 
            IDebugDocumentHelper64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentContextToTop )( 
            IDebugDocumentHelper64 __RPC_FAR * This,
            IDebugDocumentContext __RPC_FAR *pddc);
        
        END_INTERFACE
    } IDebugDocumentHelper64Vtbl;

    interface IDebugDocumentHelper64
    {
        CONST_VTBL struct IDebugDocumentHelper64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHelper64_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentHelper64_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentHelper64_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentHelper64_Init(This,pda,pszShortName,pszLongName,docAttr)  \
    (This)->lpVtbl -> Init(This,pda,pszShortName,pszLongName,docAttr)

#define IDebugDocumentHelper64_Attach(This,pddhParent)  \
    (This)->lpVtbl -> Attach(This,pddhParent)

#define IDebugDocumentHelper64_Detach(This) \
    (This)->lpVtbl -> Detach(This)

#define IDebugDocumentHelper64_AddUnicodeText(This,pszText) \
    (This)->lpVtbl -> AddUnicodeText(This,pszText)

#define IDebugDocumentHelper64_AddDBCSText(This,pszText)    \
    (This)->lpVtbl -> AddDBCSText(This,pszText)

#define IDebugDocumentHelper64_SetDebugDocumentHost(This,pddh)  \
    (This)->lpVtbl -> SetDebugDocumentHost(This,pddh)

#define IDebugDocumentHelper64_AddDeferredText(This,cChars,dwTextStartCookie)   \
    (This)->lpVtbl -> AddDeferredText(This,cChars,dwTextStartCookie)

#define IDebugDocumentHelper64_DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)  \
    (This)->lpVtbl -> DefineScriptBlock(This,ulCharOffset,cChars,pas,fScriptlet,pdwSourceContext)

#define IDebugDocumentHelper64_SetDefaultTextAttr(This,staTextAttr) \
    (This)->lpVtbl -> SetDefaultTextAttr(This,staTextAttr)

#define IDebugDocumentHelper64_SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr) \
    (This)->lpVtbl -> SetTextAttributes(This,ulCharOffset,cChars,pstaTextAttr)

#define IDebugDocumentHelper64_SetLongName(This,pszLongName)    \
    (This)->lpVtbl -> SetLongName(This,pszLongName)

#define IDebugDocumentHelper64_SetShortName(This,pszShortName)  \
    (This)->lpVtbl -> SetShortName(This,pszShortName)

#define IDebugDocumentHelper64_SetDocumentAttr(This,pszAttributes)  \
    (This)->lpVtbl -> SetDocumentAttr(This,pszAttributes)

#define IDebugDocumentHelper64_GetDebugApplicationNode(This,ppdan)  \
    (This)->lpVtbl -> GetDebugApplicationNode(This,ppdan)

#define IDebugDocumentHelper64_GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars) \
    (This)->lpVtbl -> GetScriptBlockInfo(This,dwSourceContext,ppasd,piCharPos,pcChars)

#define IDebugDocumentHelper64_CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)   \
    (This)->lpVtbl -> CreateDebugDocumentContext(This,iCharPos,cChars,ppddc)

#define IDebugDocumentHelper64_BringDocumentToTop(This) \
    (This)->lpVtbl -> BringDocumentToTop(This)

#define IDebugDocumentHelper64_BringDocumentContextToTop(This,pddc) \
    (This)->lpVtbl -> BringDocumentContextToTop(This,pddc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_Init_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ IDebugApplication64 __RPC_FAR *pda,
    /* [string][in] */ LPCOLESTR pszShortName,
    /* [string][in] */ LPCOLESTR pszLongName,
    /* [in] */ TEXT_DOC_ATTR docAttr);


void __RPC_STUB IDebugDocumentHelper64_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_Attach_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ IDebugDocumentHelper64 __RPC_FAR *pddhParent);


void __RPC_STUB IDebugDocumentHelper64_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_Detach_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This);


void __RPC_STUB IDebugDocumentHelper64_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_AddUnicodeText_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszText);


void __RPC_STUB IDebugDocumentHelper64_AddUnicodeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_AddDBCSText_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [string][in] */ LPCSTR pszText);


void __RPC_STUB IDebugDocumentHelper64_AddDBCSText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetDebugDocumentHost_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ IDebugDocumentHost __RPC_FAR *pddh);


void __RPC_STUB IDebugDocumentHelper64_SetDebugDocumentHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_AddDeferredText_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ ULONG cChars,
    /* [in] */ DWORD dwTextStartCookie);


void __RPC_STUB IDebugDocumentHelper64_AddDeferredText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_DefineScriptBlock_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ ULONG ulCharOffset,
    /* [in] */ ULONG cChars,
    /* [in] */ IActiveScript __RPC_FAR *pas,
    /* [in] */ BOOL fScriptlet,
    /* [out] */ DWORDLONG __RPC_FAR *pdwSourceContext);


void __RPC_STUB IDebugDocumentHelper64_DefineScriptBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetDefaultTextAttr_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    SOURCE_TEXT_ATTR staTextAttr);


void __RPC_STUB IDebugDocumentHelper64_SetDefaultTextAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetTextAttributes_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ ULONG ulCharOffset,
    /* [in] */ ULONG cChars,
    /* [size_is][length_is][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr);


void __RPC_STUB IDebugDocumentHelper64_SetTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetLongName_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszLongName);


void __RPC_STUB IDebugDocumentHelper64_SetLongName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetShortName_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [string][in] */ LPCOLESTR pszShortName);


void __RPC_STUB IDebugDocumentHelper64_SetShortName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_SetDocumentAttr_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ TEXT_DOC_ATTR pszAttributes);


void __RPC_STUB IDebugDocumentHelper64_SetDocumentAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_GetDebugApplicationNode_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdan);


void __RPC_STUB IDebugDocumentHelper64_GetDebugApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_GetScriptBlockInfo_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwSourceContext,
    /* [out] */ IActiveScript __RPC_FAR *__RPC_FAR *ppasd,
    /* [out] */ ULONG __RPC_FAR *piCharPos,
    /* [out] */ ULONG __RPC_FAR *pcChars);


void __RPC_STUB IDebugDocumentHelper64_GetScriptBlockInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_CreateDebugDocumentContext_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    /* [in] */ ULONG iCharPos,
    /* [in] */ ULONG cChars,
    /* [out] */ IDebugDocumentContext __RPC_FAR *__RPC_FAR *ppddc);


void __RPC_STUB IDebugDocumentHelper64_CreateDebugDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_BringDocumentToTop_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This);


void __RPC_STUB IDebugDocumentHelper64_BringDocumentToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHelper64_BringDocumentContextToTop_Proxy( 
    IDebugDocumentHelper64 __RPC_FAR * This,
    IDebugDocumentContext __RPC_FAR *pddc);


void __RPC_STUB IDebugDocumentHelper64_BringDocumentContextToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentHelper64_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentHost_INTERFACE_DEFINED__
#define __IDebugDocumentHost_INTERFACE_DEFINED__

/* interface IDebugDocumentHost */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C27-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeferredText( 
            /* [in] */ DWORD dwTextStartCookie,
            /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
            /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
            /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
            /* [in] */ ULONG cMaxChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCreateDocumentContext( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkOuter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathName( 
            /* [out] */ BSTR __RPC_FAR *pbstrLongName,
            /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileName( 
            /* [out] */ BSTR __RPC_FAR *pbstrShortName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyChanged( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeferredText )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [in] */ DWORD dwTextStartCookie,
            /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
            /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
            /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
            /* [in] */ ULONG cMaxChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptTextAttributes )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pstrCode,
            /* [in] */ ULONG uNumCodeChars,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreateDocumentContext )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkOuter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathName )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrLongName,
            /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileName )( 
            IDebugDocumentHost __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrShortName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyChanged )( 
            IDebugDocumentHost __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugDocumentHostVtbl;

    interface IDebugDocumentHost
    {
        CONST_VTBL struct IDebugDocumentHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHost_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentHost_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentHost_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentHost_GetDeferredText(This,dwTextStartCookie,pcharText,pstaTextAttr,pcNumChars,cMaxChars)  \
    (This)->lpVtbl -> GetDeferredText(This,dwTextStartCookie,pcharText,pstaTextAttr,pcNumChars,cMaxChars)

#define IDebugDocumentHost_GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr) \
    (This)->lpVtbl -> GetScriptTextAttributes(This,pstrCode,uNumCodeChars,pstrDelimiter,dwFlags,pattr)

#define IDebugDocumentHost_OnCreateDocumentContext(This,ppunkOuter) \
    (This)->lpVtbl -> OnCreateDocumentContext(This,ppunkOuter)

#define IDebugDocumentHost_GetPathName(This,pbstrLongName,pfIsOriginalFile) \
    (This)->lpVtbl -> GetPathName(This,pbstrLongName,pfIsOriginalFile)

#define IDebugDocumentHost_GetFileName(This,pbstrShortName) \
    (This)->lpVtbl -> GetFileName(This,pbstrShortName)

#define IDebugDocumentHost_NotifyChanged(This)  \
    (This)->lpVtbl -> NotifyChanged(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentHost_GetDeferredText_Proxy( 
    IDebugDocumentHost __RPC_FAR * This,
    /* [in] */ DWORD dwTextStartCookie,
    /* [size_is][length_is][out][in] */ WCHAR __RPC_FAR *pcharText,
    /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pstaTextAttr,
    /* [out][in] */ ULONG __RPC_FAR *pcNumChars,
    /* [in] */ ULONG cMaxChars);


void __RPC_STUB IDebugDocumentHost_GetDeferredText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHost_GetScriptTextAttributes_Proxy( 
    IDebugDocumentHost __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pstrCode,
    /* [in] */ ULONG uNumCodeChars,
    /* [in] */ LPCOLESTR pstrDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IDebugDocumentHost_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHost_OnCreateDocumentContext_Proxy( 
    IDebugDocumentHost __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkOuter);


void __RPC_STUB IDebugDocumentHost_OnCreateDocumentContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHost_GetPathName_Proxy( 
    IDebugDocumentHost __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrLongName,
    /* [out] */ BOOL __RPC_FAR *pfIsOriginalFile);


void __RPC_STUB IDebugDocumentHost_GetPathName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHost_GetFileName_Proxy( 
    IDebugDocumentHost __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrShortName);


void __RPC_STUB IDebugDocumentHost_GetFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentHost_NotifyChanged_Proxy( 
    IDebugDocumentHost __RPC_FAR * This);


void __RPC_STUB IDebugDocumentHost_NotifyChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentHost_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentContext_INTERFACE_DEFINED__
#define __IDebugDocumentContext_INTERFACE_DEFINED__

/* interface IDebugDocumentContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C28-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppsd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts( 
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugDocumentContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugDocumentContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugDocumentContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugDocumentContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocument )( 
            IDebugDocumentContext __RPC_FAR * This,
            /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppsd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodeContexts )( 
            IDebugDocumentContext __RPC_FAR * This,
            /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);
        
        END_INTERFACE
    } IDebugDocumentContextVtbl;

    interface IDebugDocumentContext
    {
        CONST_VTBL struct IDebugDocumentContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentContext_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugDocumentContext_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IDebugDocumentContext_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IDebugDocumentContext_GetDocument(This,ppsd)    \
    (This)->lpVtbl -> GetDocument(This,ppsd)

#define IDebugDocumentContext_EnumCodeContexts(This,ppescc) \
    (This)->lpVtbl -> EnumCodeContexts(This,ppescc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugDocumentContext_GetDocument_Proxy( 
    IDebugDocumentContext __RPC_FAR * This,
    /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppsd);


void __RPC_STUB IDebugDocumentContext_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugDocumentContext_EnumCodeContexts_Proxy( 
    IDebugDocumentContext __RPC_FAR * This,
    /* [out] */ IEnumDebugCodeContexts __RPC_FAR *__RPC_FAR *ppescc);


void __RPC_STUB IDebugDocumentContext_EnumCodeContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugDocumentContext_INTERFACE_DEFINED__ */


#ifndef __IDebugSessionProvider_INTERFACE_DEFINED__
#define __IDebugSessionProvider_INTERFACE_DEFINED__

/* interface IDebugSessionProvider */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugSessionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C29-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSessionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( 
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugSessionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugSessionProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugSessionProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugSessionProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartDebugSession )( 
            IDebugSessionProvider __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda);
        
        END_INTERFACE
    } IDebugSessionProviderVtbl;

    interface IDebugSessionProvider
    {
        CONST_VTBL struct IDebugSessionProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSessionProvider_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugSessionProvider_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IDebugSessionProvider_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IDebugSessionProvider_StartDebugSession(This,pda)   \
    (This)->lpVtbl -> StartDebugSession(This,pda)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugSessionProvider_StartDebugSession_Proxy( 
    IDebugSessionProvider __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplication __RPC_FAR *pda);


void __RPC_STUB IDebugSessionProvider_StartDebugSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugSessionProvider_INTERFACE_DEFINED__ */


#ifndef __IApplicationDebugger_INTERFACE_DEFINED__
#define __IApplicationDebugger_INTERFACE_DEFINED__

/* interface IApplicationDebugger */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IApplicationDebugger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2a-CB0C-11d0-B5C9-00A0244A0E7A")
    IApplicationDebugger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAlive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceAtDebugger( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onHandleBreakPoint( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prpt,
            /* [in] */ BREAKREASON br,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDebuggerEvent( 
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IApplicationDebuggerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationDebugger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationDebugger __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationDebugger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAlive )( 
            IApplicationDebugger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceAtDebugger )( 
            IApplicationDebugger __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onDebugOutput )( 
            IApplicationDebugger __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onHandleBreakPoint )( 
            IApplicationDebugger __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prpt,
            /* [in] */ BREAKREASON br,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pError);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onClose )( 
            IApplicationDebugger __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onDebuggerEvent )( 
            IApplicationDebugger __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        END_INTERFACE
    } IApplicationDebuggerVtbl;

    interface IApplicationDebugger
    {
        CONST_VTBL struct IApplicationDebuggerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDebugger_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationDebugger_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IApplicationDebugger_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IApplicationDebugger_QueryAlive(This)   \
    (This)->lpVtbl -> QueryAlive(This)

#define IApplicationDebugger_CreateInstanceAtDebugger(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)    \
    (This)->lpVtbl -> CreateInstanceAtDebugger(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)

#define IApplicationDebugger_onDebugOutput(This,pstr)   \
    (This)->lpVtbl -> onDebugOutput(This,pstr)

#define IApplicationDebugger_onHandleBreakPoint(This,prpt,br,pError)    \
    (This)->lpVtbl -> onHandleBreakPoint(This,prpt,br,pError)

#define IApplicationDebugger_onClose(This)  \
    (This)->lpVtbl -> onClose(This)

#define IApplicationDebugger_onDebuggerEvent(This,riid,punk)    \
    (This)->lpVtbl -> onDebuggerEvent(This,riid,punk)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IApplicationDebugger_QueryAlive_Proxy( 
    IApplicationDebugger __RPC_FAR * This);


void __RPC_STUB IApplicationDebugger_QueryAlive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebugger_CreateInstanceAtDebugger_Proxy( 
    IApplicationDebugger __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IApplicationDebugger_CreateInstanceAtDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebugger_onDebugOutput_Proxy( 
    IApplicationDebugger __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstr);


void __RPC_STUB IApplicationDebugger_onDebugOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebugger_onHandleBreakPoint_Proxy( 
    IApplicationDebugger __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prpt,
    /* [in] */ BREAKREASON br,
    /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pError);


void __RPC_STUB IApplicationDebugger_onHandleBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebugger_onClose_Proxy( 
    IApplicationDebugger __RPC_FAR * This);


void __RPC_STUB IApplicationDebugger_onClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebugger_onDebuggerEvent_Proxy( 
    IApplicationDebugger __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IApplicationDebugger_onDebuggerEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IApplicationDebugger_INTERFACE_DEFINED__ */


#ifndef __IApplicationDebuggerUI_INTERFACE_DEFINED__
#define __IApplicationDebuggerUI_INTERFACE_DEFINED__

/* interface IApplicationDebuggerUI */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IApplicationDebuggerUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2b-CB0C-11d0-B5C9-00A0244A0E7A")
    IApplicationDebuggerUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BringDocumentToTop( 
            /* [in] */ IDebugDocumentText __RPC_FAR *pddt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BringDocumentContextToTop( 
            /* [in] */ IDebugDocumentContext __RPC_FAR *pddc) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IApplicationDebuggerUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationDebuggerUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationDebuggerUI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationDebuggerUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentToTop )( 
            IApplicationDebuggerUI __RPC_FAR * This,
            /* [in] */ IDebugDocumentText __RPC_FAR *pddt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BringDocumentContextToTop )( 
            IApplicationDebuggerUI __RPC_FAR * This,
            /* [in] */ IDebugDocumentContext __RPC_FAR *pddc);
        
        END_INTERFACE
    } IApplicationDebuggerUIVtbl;

    interface IApplicationDebuggerUI
    {
        CONST_VTBL struct IApplicationDebuggerUIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationDebuggerUI_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationDebuggerUI_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IApplicationDebuggerUI_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IApplicationDebuggerUI_BringDocumentToTop(This,pddt)    \
    (This)->lpVtbl -> BringDocumentToTop(This,pddt)

#define IApplicationDebuggerUI_BringDocumentContextToTop(This,pddc) \
    (This)->lpVtbl -> BringDocumentContextToTop(This,pddc)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IApplicationDebuggerUI_BringDocumentToTop_Proxy( 
    IApplicationDebuggerUI __RPC_FAR * This,
    /* [in] */ IDebugDocumentText __RPC_FAR *pddt);


void __RPC_STUB IApplicationDebuggerUI_BringDocumentToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationDebuggerUI_BringDocumentContextToTop_Proxy( 
    IApplicationDebuggerUI __RPC_FAR * This,
    /* [in] */ IDebugDocumentContext __RPC_FAR *pddc);


void __RPC_STUB IApplicationDebuggerUI_BringDocumentContextToTop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IApplicationDebuggerUI_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0222 */
/* [local] */ 

EXTERN_C const CLSID CLSID_MachineDebugManager;


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0222_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0222_v0_0_s_ifspec;

#ifndef __IMachineDebugManager_INTERFACE_DEFINED__
#define __IMachineDebugManager_INTERFACE_DEFINED__

/* interface IMachineDebugManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2c-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IMachineDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMachineDebugManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMachineDebugManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMachineDebugManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddApplication )( 
            IMachineDebugManager __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveApplication )( 
            IMachineDebugManager __RPC_FAR * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumApplications )( 
            IMachineDebugManager __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda);
        
        END_INTERFACE
    } IMachineDebugManagerVtbl;

    interface IMachineDebugManager
    {
        CONST_VTBL struct IMachineDebugManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManager_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMachineDebugManager_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IMachineDebugManager_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IMachineDebugManager_AddApplication(This,pda,pdwAppCookie)  \
    (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie)

#define IMachineDebugManager_RemoveApplication(This,dwAppCookie)    \
    (This)->lpVtbl -> RemoveApplication(This,dwAppCookie)

#define IMachineDebugManager_EnumApplications(This,ppeda)   \
    (This)->lpVtbl -> EnumApplications(This,ppeda)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IMachineDebugManager_AddApplication_Proxy( 
    IMachineDebugManager __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
    /* [out] */ DWORD __RPC_FAR *pdwAppCookie);


void __RPC_STUB IMachineDebugManager_AddApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMachineDebugManager_RemoveApplication_Proxy( 
    IMachineDebugManager __RPC_FAR * This,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IMachineDebugManager_RemoveApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMachineDebugManager_EnumApplications_Proxy( 
    IMachineDebugManager __RPC_FAR * This,
    /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda);


void __RPC_STUB IMachineDebugManager_EnumApplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IMachineDebugManager_INTERFACE_DEFINED__ */


#ifndef __IMachineDebugManagerCookie_INTERFACE_DEFINED__
#define __IMachineDebugManagerCookie_INTERFACE_DEFINED__

/* interface IMachineDebugManagerCookie */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManagerCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2d-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManagerCookie : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwDebugAppCookie,
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumApplications( 
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IMachineDebugManagerCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMachineDebugManagerCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMachineDebugManagerCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMachineDebugManagerCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddApplication )( 
            IMachineDebugManagerCookie __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveApplication )( 
            IMachineDebugManagerCookie __RPC_FAR * This,
            /* [in] */ DWORD dwDebugAppCookie,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumApplications )( 
            IMachineDebugManagerCookie __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda);
        
        END_INTERFACE
    } IMachineDebugManagerCookieVtbl;

    interface IMachineDebugManagerCookie
    {
        CONST_VTBL struct IMachineDebugManagerCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManagerCookie_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMachineDebugManagerCookie_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IMachineDebugManagerCookie_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IMachineDebugManagerCookie_AddApplication(This,pda,dwDebugAppCookie,pdwAppCookie)   \
    (This)->lpVtbl -> AddApplication(This,pda,dwDebugAppCookie,pdwAppCookie)

#define IMachineDebugManagerCookie_RemoveApplication(This,dwDebugAppCookie,dwAppCookie) \
    (This)->lpVtbl -> RemoveApplication(This,dwDebugAppCookie,dwAppCookie)

#define IMachineDebugManagerCookie_EnumApplications(This,ppeda) \
    (This)->lpVtbl -> EnumApplications(This,ppeda)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IMachineDebugManagerCookie_AddApplication_Proxy( 
    IMachineDebugManagerCookie __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
    /* [in] */ DWORD dwDebugAppCookie,
    /* [out] */ DWORD __RPC_FAR *pdwAppCookie);


void __RPC_STUB IMachineDebugManagerCookie_AddApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMachineDebugManagerCookie_RemoveApplication_Proxy( 
    IMachineDebugManagerCookie __RPC_FAR * This,
    /* [in] */ DWORD dwDebugAppCookie,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IMachineDebugManagerCookie_RemoveApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMachineDebugManagerCookie_EnumApplications_Proxy( 
    IMachineDebugManagerCookie __RPC_FAR * This,
    /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppeda);


void __RPC_STUB IMachineDebugManagerCookie_EnumApplications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IMachineDebugManagerCookie_INTERFACE_DEFINED__ */


#ifndef __IMachineDebugManagerEvents_INTERFACE_DEFINED__
#define __IMachineDebugManagerEvents_INTERFACE_DEFINED__

/* interface IMachineDebugManagerEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IMachineDebugManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2e-CB0C-11d0-B5C9-00A0244A0E7A")
    IMachineDebugManagerEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onAddApplication( 
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveApplication( 
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwAppCookie) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IMachineDebugManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMachineDebugManagerEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMachineDebugManagerEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMachineDebugManagerEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onAddApplication )( 
            IMachineDebugManagerEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onRemoveApplication )( 
            IMachineDebugManagerEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
            /* [in] */ DWORD dwAppCookie);
        
        END_INTERFACE
    } IMachineDebugManagerEventsVtbl;

    interface IMachineDebugManagerEvents
    {
        CONST_VTBL struct IMachineDebugManagerEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMachineDebugManagerEvents_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMachineDebugManagerEvents_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IMachineDebugManagerEvents_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IMachineDebugManagerEvents_onAddApplication(This,pda,dwAppCookie)   \
    (This)->lpVtbl -> onAddApplication(This,pda,dwAppCookie)

#define IMachineDebugManagerEvents_onRemoveApplication(This,pda,dwAppCookie)    \
    (This)->lpVtbl -> onRemoveApplication(This,pda,dwAppCookie)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IMachineDebugManagerEvents_onAddApplication_Proxy( 
    IMachineDebugManagerEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IMachineDebugManagerEvents_onAddApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMachineDebugManagerEvents_onRemoveApplication_Proxy( 
    IMachineDebugManagerEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplication __RPC_FAR *pda,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IMachineDebugManagerEvents_onRemoveApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IMachineDebugManagerEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0225 */
/* [local] */ 

EXTERN_C const CLSID CLSID_ProcessDebugManager;
#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IProcessDebugManager IProcessDebugManager64
#define IID_IProcessDebugManager IID_IProcessDebugManager64
#else
#define IProcessDebugManager IProcessDebugManager32
#define IID_IProcessDebugManager IID_IProcessDebugManager32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0225_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0225_v0_0_s_ifspec;

#ifndef __IProcessDebugManager32_INTERFACE_DEFINED__
#define __IProcessDebugManager32_INTERFACE_DEFINED__

/* interface IProcessDebugManager32 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProcessDebugManager32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C2f-CB0C-11d0-B5C9-00A0244A0E7A")
    IProcessDebugManager32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultApplication( 
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IDebugApplication32 __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentHelper( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [out] */ IDebugDocumentHelper32 __RPC_FAR *__RPC_FAR *pddh) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IProcessDebugManager32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProcessDebugManager32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProcessDebugManager32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateApplication )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultApplication )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddApplication )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [in] */ IDebugApplication32 __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveApplication )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDebugDocumentHelper )( 
            IProcessDebugManager32 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [out] */ IDebugDocumentHelper32 __RPC_FAR *__RPC_FAR *pddh);
        
        END_INTERFACE
    } IProcessDebugManager32Vtbl;

    interface IProcessDebugManager32
    {
        CONST_VTBL struct IProcessDebugManager32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessDebugManager32_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessDebugManager32_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IProcessDebugManager32_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IProcessDebugManager32_CreateApplication(This,ppda) \
    (This)->lpVtbl -> CreateApplication(This,ppda)

#define IProcessDebugManager32_GetDefaultApplication(This,ppda) \
    (This)->lpVtbl -> GetDefaultApplication(This,ppda)

#define IProcessDebugManager32_AddApplication(This,pda,pdwAppCookie)    \
    (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie)

#define IProcessDebugManager32_RemoveApplication(This,dwAppCookie)  \
    (This)->lpVtbl -> RemoveApplication(This,dwAppCookie)

#define IProcessDebugManager32_CreateDebugDocumentHelper(This,punkOuter,pddh)   \
    (This)->lpVtbl -> CreateDebugDocumentHelper(This,punkOuter,pddh)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IProcessDebugManager32_CreateApplication_Proxy( 
    IProcessDebugManager32 __RPC_FAR * This,
    /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IProcessDebugManager32_CreateApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager32_GetDefaultApplication_Proxy( 
    IProcessDebugManager32 __RPC_FAR * This,
    /* [out] */ IDebugApplication32 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IProcessDebugManager32_GetDefaultApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager32_AddApplication_Proxy( 
    IProcessDebugManager32 __RPC_FAR * This,
    /* [in] */ IDebugApplication32 __RPC_FAR *pda,
    /* [out] */ DWORD __RPC_FAR *pdwAppCookie);


void __RPC_STUB IProcessDebugManager32_AddApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager32_RemoveApplication_Proxy( 
    IProcessDebugManager32 __RPC_FAR * This,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IProcessDebugManager32_RemoveApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager32_CreateDebugDocumentHelper_Proxy( 
    IProcessDebugManager32 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [out] */ IDebugDocumentHelper32 __RPC_FAR *__RPC_FAR *pddh);


void __RPC_STUB IProcessDebugManager32_CreateDebugDocumentHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IProcessDebugManager32_INTERFACE_DEFINED__ */


#ifndef __IProcessDebugManager64_INTERFACE_DEFINED__
#define __IProcessDebugManager64_INTERFACE_DEFINED__

/* interface IProcessDebugManager64 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IProcessDebugManager64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b9fc1c-63a9-4cc1-ac21-087d69a17fab")
    IProcessDebugManager64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultApplication( 
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddApplication( 
            /* [in] */ IDebugApplication64 __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveApplication( 
            /* [in] */ DWORD dwAppCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDebugDocumentHelper( 
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [out] */ IDebugDocumentHelper64 __RPC_FAR *__RPC_FAR *pddh) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IProcessDebugManager64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProcessDebugManager64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProcessDebugManager64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateApplication )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultApplication )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddApplication )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [in] */ IDebugApplication64 __RPC_FAR *pda,
            /* [out] */ DWORD __RPC_FAR *pdwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveApplication )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [in] */ DWORD dwAppCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateDebugDocumentHelper )( 
            IProcessDebugManager64 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [out] */ IDebugDocumentHelper64 __RPC_FAR *__RPC_FAR *pddh);
        
        END_INTERFACE
    } IProcessDebugManager64Vtbl;

    interface IProcessDebugManager64
    {
        CONST_VTBL struct IProcessDebugManager64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProcessDebugManager64_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProcessDebugManager64_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IProcessDebugManager64_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IProcessDebugManager64_CreateApplication(This,ppda) \
    (This)->lpVtbl -> CreateApplication(This,ppda)

#define IProcessDebugManager64_GetDefaultApplication(This,ppda) \
    (This)->lpVtbl -> GetDefaultApplication(This,ppda)

#define IProcessDebugManager64_AddApplication(This,pda,pdwAppCookie)    \
    (This)->lpVtbl -> AddApplication(This,pda,pdwAppCookie)

#define IProcessDebugManager64_RemoveApplication(This,dwAppCookie)  \
    (This)->lpVtbl -> RemoveApplication(This,dwAppCookie)

#define IProcessDebugManager64_CreateDebugDocumentHelper(This,punkOuter,pddh)   \
    (This)->lpVtbl -> CreateDebugDocumentHelper(This,punkOuter,pddh)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IProcessDebugManager64_CreateApplication_Proxy( 
    IProcessDebugManager64 __RPC_FAR * This,
    /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IProcessDebugManager64_CreateApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager64_GetDefaultApplication_Proxy( 
    IProcessDebugManager64 __RPC_FAR * This,
    /* [out] */ IDebugApplication64 __RPC_FAR *__RPC_FAR *ppda);


void __RPC_STUB IProcessDebugManager64_GetDefaultApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager64_AddApplication_Proxy( 
    IProcessDebugManager64 __RPC_FAR * This,
    /* [in] */ IDebugApplication64 __RPC_FAR *pda,
    /* [out] */ DWORD __RPC_FAR *pdwAppCookie);


void __RPC_STUB IProcessDebugManager64_AddApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager64_RemoveApplication_Proxy( 
    IProcessDebugManager64 __RPC_FAR * This,
    /* [in] */ DWORD dwAppCookie);


void __RPC_STUB IProcessDebugManager64_RemoveApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProcessDebugManager64_CreateDebugDocumentHelper_Proxy( 
    IProcessDebugManager64 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [out] */ IDebugDocumentHelper64 __RPC_FAR *__RPC_FAR *pddh);


void __RPC_STUB IProcessDebugManager64_CreateDebugDocumentHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IProcessDebugManager64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplication_INTERFACE_DEFINED__
#define __IRemoteDebugApplication_INTERFACE_DEFINED__

/* interface IRemoteDebugApplication */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C30-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplication : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResumeFromBreakPoint( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CauseBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConnectDebugger( 
            /* [in] */ IApplicationDebugger __RPC_FAR *pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisconnectDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugger( 
            /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceAtApplication( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAlive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumThreads( 
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumGlobalExpressionContexts( 
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IRemoteDebugApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugApplication __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeFromBreakPoint )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CauseBreak )( 
            IRemoteDebugApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectDebugger )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [in] */ IApplicationDebugger __RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisconnectDebugger )( 
            IRemoteDebugApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugger )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceAtApplication )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAlive )( 
            IRemoteDebugApplication __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumThreads )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNode )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumGlobalExpressionContexts )( 
            IRemoteDebugApplication __RPC_FAR * This,
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);
        
        END_INTERFACE
    } IRemoteDebugApplicationVtbl;

    interface IRemoteDebugApplication
    {
        CONST_VTBL struct IRemoteDebugApplicationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplication_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugApplication_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugApplication_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugApplication_ResumeFromBreakPoint(This,prptFocus,bra,era)    \
    (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era)

#define IRemoteDebugApplication_CauseBreak(This)    \
    (This)->lpVtbl -> CauseBreak(This)

#define IRemoteDebugApplication_ConnectDebugger(This,pad)   \
    (This)->lpVtbl -> ConnectDebugger(This,pad)

#define IRemoteDebugApplication_DisconnectDebugger(This)    \
    (This)->lpVtbl -> DisconnectDebugger(This)

#define IRemoteDebugApplication_GetDebugger(This,pad)   \
    (This)->lpVtbl -> GetDebugger(This,pad)

#define IRemoteDebugApplication_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)  \
    (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)

#define IRemoteDebugApplication_QueryAlive(This)    \
    (This)->lpVtbl -> QueryAlive(This)

#define IRemoteDebugApplication_EnumThreads(This,pperdat)   \
    (This)->lpVtbl -> EnumThreads(This,pperdat)

#define IRemoteDebugApplication_GetName(This,pbstrName) \
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IRemoteDebugApplication_GetRootNode(This,ppdanRoot) \
    (This)->lpVtbl -> GetRootNode(This,ppdanRoot)

#define IRemoteDebugApplication_EnumGlobalExpressionContexts(This,ppedec)   \
    (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_ResumeFromBreakPoint_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
    /* [in] */ BREAKRESUMEACTION bra,
    /* [in] */ ERRORRESUMEACTION era);


void __RPC_STUB IRemoteDebugApplication_ResumeFromBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_CauseBreak_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This);


void __RPC_STUB IRemoteDebugApplication_CauseBreak_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_ConnectDebugger_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [in] */ IApplicationDebugger __RPC_FAR *pad);


void __RPC_STUB IRemoteDebugApplication_ConnectDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_DisconnectDebugger_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This);


void __RPC_STUB IRemoteDebugApplication_DisconnectDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_GetDebugger_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad);


void __RPC_STUB IRemoteDebugApplication_GetDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_CreateInstanceAtApplication_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IRemoteDebugApplication_CreateInstanceAtApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_QueryAlive_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This);


void __RPC_STUB IRemoteDebugApplication_QueryAlive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_EnumThreads_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);


void __RPC_STUB IRemoteDebugApplication_EnumThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_GetName_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IRemoteDebugApplication_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_GetRootNode_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);


void __RPC_STUB IRemoteDebugApplication_GetRootNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplication_EnumGlobalExpressionContexts_Proxy( 
    IRemoteDebugApplication __RPC_FAR * This,
    /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);


void __RPC_STUB IRemoteDebugApplication_EnumGlobalExpressionContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IRemoteDebugApplication_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0228 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugApplication IDebugApplication64
#define IID_IDebugApplication IID_IDebugApplication64
#else
#define IDebugApplication IDebugApplication32
#define IID_IDebugApplication IID_IDebugApplication32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0228_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0228_v0_0_s_ifspec;

#ifndef __IDebugApplication32_INTERFACE_DEFINED__
#define __IDebugApplication32_INTERFACE_DEFINED__

/* interface IDebugApplication32 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplication32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C32-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplication32 : public IRemoteDebugApplication
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOutComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleBreakPoint( 
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakFlags( 
            /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThread( 
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAsyncDebugOperation( 
            /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
            /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStackFrameSniffer( 
            /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStackFrameSniffer( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentThreadIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallInDebuggerThread( 
            /* [in] */ IDebugThreadCall32 __RPC_FAR *pptc,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDebuggerEvent( 
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRuntimeError( 
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
            /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FCanJitDebug( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FIsAutoJitDebugEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGlobalExpressionContextProvider( 
            /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveGlobalExpressionContextProvider( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplication32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplication32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeFromBreakPoint )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CauseBreak )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectDebugger )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IApplicationDebugger __RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisconnectDebugger )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugger )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceAtApplication )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAlive )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumThreads )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNode )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumGlobalExpressionContexts )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepOutComplete )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugOutput )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartDebugSession )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleBreakPoint )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBreakFlags )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentThread )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAsyncDebugOperation )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
            /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStackFrameSniffer )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStackFrameSniffer )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryCurrentThreadIsDebuggerThread )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCallInDebuggerThread )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IDebugThreadCall32 __RPC_FAR *pptc,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateApplicationNode )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireDebuggerEvent )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleRuntimeError )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
            /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *FCanJitDebug )( 
            IDebugApplication32 __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *FIsAutoJitDebugEnabled )( 
            IDebugApplication32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddGlobalExpressionContextProvider )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveGlobalExpressionContextProvider )( 
            IDebugApplication32 __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IDebugApplication32Vtbl;

    interface IDebugApplication32
    {
        CONST_VTBL struct IDebugApplication32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplication32_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplication32_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplication32_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugApplication32_ResumeFromBreakPoint(This,prptFocus,bra,era)    \
    (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era)

#define IDebugApplication32_CauseBreak(This)    \
    (This)->lpVtbl -> CauseBreak(This)

#define IDebugApplication32_ConnectDebugger(This,pad)   \
    (This)->lpVtbl -> ConnectDebugger(This,pad)

#define IDebugApplication32_DisconnectDebugger(This)    \
    (This)->lpVtbl -> DisconnectDebugger(This)

#define IDebugApplication32_GetDebugger(This,pad)   \
    (This)->lpVtbl -> GetDebugger(This,pad)

#define IDebugApplication32_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)  \
    (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)

#define IDebugApplication32_QueryAlive(This)    \
    (This)->lpVtbl -> QueryAlive(This)

#define IDebugApplication32_EnumThreads(This,pperdat)   \
    (This)->lpVtbl -> EnumThreads(This,pperdat)

#define IDebugApplication32_GetName(This,pbstrName) \
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugApplication32_GetRootNode(This,ppdanRoot) \
    (This)->lpVtbl -> GetRootNode(This,ppdanRoot)

#define IDebugApplication32_EnumGlobalExpressionContexts(This,ppedec)   \
    (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec)


#define IDebugApplication32_SetName(This,pstrName)  \
    (This)->lpVtbl -> SetName(This,pstrName)

#define IDebugApplication32_StepOutComplete(This)   \
    (This)->lpVtbl -> StepOutComplete(This)

#define IDebugApplication32_DebugOutput(This,pstr)  \
    (This)->lpVtbl -> DebugOutput(This,pstr)

#define IDebugApplication32_StartDebugSession(This) \
    (This)->lpVtbl -> StartDebugSession(This)

#define IDebugApplication32_HandleBreakPoint(This,br,pbra)  \
    (This)->lpVtbl -> HandleBreakPoint(This,br,pbra)

#define IDebugApplication32_Close(This) \
    (This)->lpVtbl -> Close(This)

#define IDebugApplication32_GetBreakFlags(This,pabf,pprdatSteppingThread)   \
    (This)->lpVtbl -> GetBreakFlags(This,pabf,pprdatSteppingThread)

#define IDebugApplication32_GetCurrentThread(This,pat)  \
    (This)->lpVtbl -> GetCurrentThread(This,pat)

#define IDebugApplication32_CreateAsyncDebugOperation(This,psdo,ppado)  \
    (This)->lpVtbl -> CreateAsyncDebugOperation(This,psdo,ppado)

#define IDebugApplication32_AddStackFrameSniffer(This,pdsfs,pdwCookie)  \
    (This)->lpVtbl -> AddStackFrameSniffer(This,pdsfs,pdwCookie)

#define IDebugApplication32_RemoveStackFrameSniffer(This,dwCookie)  \
    (This)->lpVtbl -> RemoveStackFrameSniffer(This,dwCookie)

#define IDebugApplication32_QueryCurrentThreadIsDebuggerThread(This)    \
    (This)->lpVtbl -> QueryCurrentThreadIsDebuggerThread(This)

#define IDebugApplication32_SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)   \
    (This)->lpVtbl -> SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)

#define IDebugApplication32_CreateApplicationNode(This,ppdanNew)    \
    (This)->lpVtbl -> CreateApplicationNode(This,ppdanNew)

#define IDebugApplication32_FireDebuggerEvent(This,riid,punk)   \
    (This)->lpVtbl -> FireDebuggerEvent(This,riid,punk)

#define IDebugApplication32_HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError) \
    (This)->lpVtbl -> HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError)

#define IDebugApplication32_FCanJitDebug(This)  \
    (This)->lpVtbl -> FCanJitDebug(This)

#define IDebugApplication32_FIsAutoJitDebugEnabled(This)    \
    (This)->lpVtbl -> FIsAutoJitDebugEnabled(This)

#define IDebugApplication32_AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)    \
    (This)->lpVtbl -> AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)

#define IDebugApplication32_RemoveGlobalExpressionContextProvider(This,dwCookie)    \
    (This)->lpVtbl -> RemoveGlobalExpressionContextProvider(This,dwCookie)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplication32_SetName_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrName);


void __RPC_STUB IDebugApplication32_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_StepOutComplete_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_StepOutComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_DebugOutput_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstr);


void __RPC_STUB IDebugApplication32_DebugOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_StartDebugSession_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_StartDebugSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_HandleBreakPoint_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ BREAKREASON br,
    /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra);


void __RPC_STUB IDebugApplication32_HandleBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_Close_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_GetBreakFlags_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
    /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread);


void __RPC_STUB IDebugApplication32_GetBreakFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_GetCurrentThread_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat);


void __RPC_STUB IDebugApplication32_GetCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_CreateAsyncDebugOperation_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
    /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado);


void __RPC_STUB IDebugApplication32_CreateAsyncDebugOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_AddStackFrameSniffer_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IDebugApplication32_AddStackFrameSniffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_RemoveStackFrameSniffer_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IDebugApplication32_RemoveStackFrameSniffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_QueryCurrentThreadIsDebuggerThread_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_QueryCurrentThreadIsDebuggerThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_SynchronousCallInDebuggerThread_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ IDebugThreadCall32 __RPC_FAR *pptc,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2,
    /* [in] */ DWORD dwParam3);


void __RPC_STUB IDebugApplication32_SynchronousCallInDebuggerThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_CreateApplicationNode_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew);


void __RPC_STUB IDebugApplication32_CreateApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_FireDebuggerEvent_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ REFGUID riid,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IDebugApplication32_FireDebuggerEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_HandleRuntimeError_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
    /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
    /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
    /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
    /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError);


void __RPC_STUB IDebugApplication32_HandleRuntimeError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDebugApplication32_FCanJitDebug_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_FCanJitDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDebugApplication32_FIsAutoJitDebugEnabled_Proxy( 
    IDebugApplication32 __RPC_FAR * This);


void __RPC_STUB IDebugApplication32_FIsAutoJitDebugEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_AddGlobalExpressionContextProvider_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IDebugApplication32_AddGlobalExpressionContextProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication32_RemoveGlobalExpressionContextProvider_Proxy( 
    IDebugApplication32 __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IDebugApplication32_RemoveGlobalExpressionContextProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplication32_INTERFACE_DEFINED__ */


#ifndef __IDebugApplication64_INTERFACE_DEFINED__
#define __IDebugApplication64_INTERFACE_DEFINED__

/* interface IDebugApplication64 */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplication64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4dedc754-04c7-4f10-9e60-16a390fe6e62")
    IDebugApplication64 : public IRemoteDebugApplication
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOutComplete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleBreakPoint( 
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBreakFlags( 
            /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThread( 
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAsyncDebugOperation( 
            /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
            /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStackFrameSniffer( 
            /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStackFrameSniffer( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryCurrentThreadIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallInDebuggerThread( 
            /* [in] */ IDebugThreadCall64 __RPC_FAR *pptc,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationNode( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireDebuggerEvent( 
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleRuntimeError( 
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
            /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FCanJitDebug( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE FIsAutoJitDebugEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddGlobalExpressionContextProvider( 
            /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
            /* [out] */ DWORDLONG __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveGlobalExpressionContextProvider( 
            /* [in] */ DWORDLONG dwCookie) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplication64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplication64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResumeFromBreakPoint )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prptFocus,
            /* [in] */ BREAKRESUMEACTION bra,
            /* [in] */ ERRORRESUMEACTION era);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CauseBreak )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectDebugger )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IApplicationDebugger __RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisconnectDebugger )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDebugger )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IApplicationDebugger __RPC_FAR *__RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceAtApplication )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryAlive )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumThreads )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNode )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumGlobalExpressionContexts )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StepOutComplete )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DebugOutput )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartDebugSession )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleBreakPoint )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ BREAKREASON br,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBreakFlags )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentThread )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAsyncDebugOperation )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
            /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddStackFrameSniffer )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStackFrameSniffer )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryCurrentThreadIsDebuggerThread )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCallInDebuggerThread )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IDebugThreadCall64 __RPC_FAR *pptc,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateApplicationNode )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireDebuggerEvent )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ REFGUID riid,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleRuntimeError )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
            /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
            /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
            /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
            /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *FCanJitDebug )( 
            IDebugApplication64 __RPC_FAR * This);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *FIsAutoJitDebugEnabled )( 
            IDebugApplication64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddGlobalExpressionContextProvider )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
            /* [out] */ DWORDLONG __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveGlobalExpressionContextProvider )( 
            IDebugApplication64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwCookie);
        
        END_INTERFACE
    } IDebugApplication64Vtbl;

    interface IDebugApplication64
    {
        CONST_VTBL struct IDebugApplication64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplication64_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplication64_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplication64_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugApplication64_ResumeFromBreakPoint(This,prptFocus,bra,era)    \
    (This)->lpVtbl -> ResumeFromBreakPoint(This,prptFocus,bra,era)

#define IDebugApplication64_CauseBreak(This)    \
    (This)->lpVtbl -> CauseBreak(This)

#define IDebugApplication64_ConnectDebugger(This,pad)   \
    (This)->lpVtbl -> ConnectDebugger(This,pad)

#define IDebugApplication64_DisconnectDebugger(This)    \
    (This)->lpVtbl -> DisconnectDebugger(This)

#define IDebugApplication64_GetDebugger(This,pad)   \
    (This)->lpVtbl -> GetDebugger(This,pad)

#define IDebugApplication64_CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)  \
    (This)->lpVtbl -> CreateInstanceAtApplication(This,rclsid,pUnkOuter,dwClsContext,riid,ppvObject)

#define IDebugApplication64_QueryAlive(This)    \
    (This)->lpVtbl -> QueryAlive(This)

#define IDebugApplication64_EnumThreads(This,pperdat)   \
    (This)->lpVtbl -> EnumThreads(This,pperdat)

#define IDebugApplication64_GetName(This,pbstrName) \
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IDebugApplication64_GetRootNode(This,ppdanRoot) \
    (This)->lpVtbl -> GetRootNode(This,ppdanRoot)

#define IDebugApplication64_EnumGlobalExpressionContexts(This,ppedec)   \
    (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppedec)


#define IDebugApplication64_SetName(This,pstrName)  \
    (This)->lpVtbl -> SetName(This,pstrName)

#define IDebugApplication64_StepOutComplete(This)   \
    (This)->lpVtbl -> StepOutComplete(This)

#define IDebugApplication64_DebugOutput(This,pstr)  \
    (This)->lpVtbl -> DebugOutput(This,pstr)

#define IDebugApplication64_StartDebugSession(This) \
    (This)->lpVtbl -> StartDebugSession(This)

#define IDebugApplication64_HandleBreakPoint(This,br,pbra)  \
    (This)->lpVtbl -> HandleBreakPoint(This,br,pbra)

#define IDebugApplication64_Close(This) \
    (This)->lpVtbl -> Close(This)

#define IDebugApplication64_GetBreakFlags(This,pabf,pprdatSteppingThread)   \
    (This)->lpVtbl -> GetBreakFlags(This,pabf,pprdatSteppingThread)

#define IDebugApplication64_GetCurrentThread(This,pat)  \
    (This)->lpVtbl -> GetCurrentThread(This,pat)

#define IDebugApplication64_CreateAsyncDebugOperation(This,psdo,ppado)  \
    (This)->lpVtbl -> CreateAsyncDebugOperation(This,psdo,ppado)

#define IDebugApplication64_AddStackFrameSniffer(This,pdsfs,pdwCookie)  \
    (This)->lpVtbl -> AddStackFrameSniffer(This,pdsfs,pdwCookie)

#define IDebugApplication64_RemoveStackFrameSniffer(This,dwCookie)  \
    (This)->lpVtbl -> RemoveStackFrameSniffer(This,dwCookie)

#define IDebugApplication64_QueryCurrentThreadIsDebuggerThread(This)    \
    (This)->lpVtbl -> QueryCurrentThreadIsDebuggerThread(This)

#define IDebugApplication64_SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)   \
    (This)->lpVtbl -> SynchronousCallInDebuggerThread(This,pptc,dwParam1,dwParam2,dwParam3)

#define IDebugApplication64_CreateApplicationNode(This,ppdanNew)    \
    (This)->lpVtbl -> CreateApplicationNode(This,ppdanNew)

#define IDebugApplication64_FireDebuggerEvent(This,riid,punk)   \
    (This)->lpVtbl -> FireDebuggerEvent(This,riid,punk)

#define IDebugApplication64_HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError) \
    (This)->lpVtbl -> HandleRuntimeError(This,pErrorDebug,pScriptSite,pbra,perra,pfCallOnScriptError)

#define IDebugApplication64_FCanJitDebug(This)  \
    (This)->lpVtbl -> FCanJitDebug(This)

#define IDebugApplication64_FIsAutoJitDebugEnabled(This)    \
    (This)->lpVtbl -> FIsAutoJitDebugEnabled(This)

#define IDebugApplication64_AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)    \
    (This)->lpVtbl -> AddGlobalExpressionContextProvider(This,pdsfs,pdwCookie)

#define IDebugApplication64_RemoveGlobalExpressionContextProvider(This,dwCookie)    \
    (This)->lpVtbl -> RemoveGlobalExpressionContextProvider(This,dwCookie)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplication64_SetName_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrName);


void __RPC_STUB IDebugApplication64_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_StepOutComplete_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_StepOutComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_DebugOutput_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstr);


void __RPC_STUB IDebugApplication64_DebugOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_StartDebugSession_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_StartDebugSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_HandleBreakPoint_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ BREAKREASON br,
    /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra);


void __RPC_STUB IDebugApplication64_HandleBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_Close_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_GetBreakFlags_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [out] */ APPBREAKFLAGS __RPC_FAR *pabf,
    /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdatSteppingThread);


void __RPC_STUB IDebugApplication64_GetBreakFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_GetCurrentThread_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [out] */ IDebugApplicationThread __RPC_FAR *__RPC_FAR *pat);


void __RPC_STUB IDebugApplication64_GetCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_CreateAsyncDebugOperation_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ IDebugSyncOperation __RPC_FAR *psdo,
    /* [out] */ IDebugAsyncOperation __RPC_FAR *__RPC_FAR *ppado);


void __RPC_STUB IDebugApplication64_CreateAsyncDebugOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_AddStackFrameSniffer_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ IDebugStackFrameSniffer __RPC_FAR *pdsfs,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IDebugApplication64_AddStackFrameSniffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_RemoveStackFrameSniffer_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IDebugApplication64_RemoveStackFrameSniffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_QueryCurrentThreadIsDebuggerThread_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_QueryCurrentThreadIsDebuggerThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_SynchronousCallInDebuggerThread_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ IDebugThreadCall64 __RPC_FAR *pptc,
    /* [in] */ DWORDLONG dwParam1,
    /* [in] */ DWORDLONG dwParam2,
    /* [in] */ DWORDLONG dwParam3);


void __RPC_STUB IDebugApplication64_SynchronousCallInDebuggerThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_CreateApplicationNode_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *ppdanNew);


void __RPC_STUB IDebugApplication64_CreateApplicationNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_FireDebuggerEvent_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ REFGUID riid,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IDebugApplication64_FireDebuggerEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_HandleRuntimeError_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ IActiveScriptErrorDebug __RPC_FAR *pErrorDebug,
    /* [in] */ IActiveScriptSite __RPC_FAR *pScriptSite,
    /* [out] */ BREAKRESUMEACTION __RPC_FAR *pbra,
    /* [out] */ ERRORRESUMEACTION __RPC_FAR *perra,
    /* [out] */ BOOL __RPC_FAR *pfCallOnScriptError);


void __RPC_STUB IDebugApplication64_HandleRuntimeError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDebugApplication64_FCanJitDebug_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_FCanJitDebug_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDebugApplication64_FIsAutoJitDebugEnabled_Proxy( 
    IDebugApplication64 __RPC_FAR * This);


void __RPC_STUB IDebugApplication64_FIsAutoJitDebugEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_AddGlobalExpressionContextProvider_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ IProvideExpressionContexts __RPC_FAR *pdsfs,
    /* [out] */ DWORDLONG __RPC_FAR *pdwCookie);


void __RPC_STUB IDebugApplication64_AddGlobalExpressionContextProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplication64_RemoveGlobalExpressionContextProvider_Proxy( 
    IDebugApplication64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwCookie);


void __RPC_STUB IDebugApplication64_RemoveGlobalExpressionContextProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplication64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplicationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C33-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplicationEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnConnectDebugger( 
            /* [in] */ IApplicationDebugger __RPC_FAR *pad) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDisconnectDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSetName( 
            /* [in] */ LPCOLESTR pstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDebugOutput( 
            /* [in] */ LPCOLESTR pstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnClose( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnterBreakPoint( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeaveBreakPoint( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCreateThread( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDestroyThread( 
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnBreakFlagChange( 
            /* [in] */ APPBREAKFLAGS abf,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdatSteppingThread) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IRemoteDebugApplicationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnConnectDebugger )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ IApplicationDebugger __RPC_FAR *pad);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDisconnectDebugger )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnSetName )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDebugOutput )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnClose )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnEnterBreakPoint )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnLeaveBreakPoint )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnCreateThread )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDestroyThread )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnBreakFlagChange )( 
            IRemoteDebugApplicationEvents __RPC_FAR * This,
            /* [in] */ APPBREAKFLAGS abf,
            /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdatSteppingThread);
        
        END_INTERFACE
    } IRemoteDebugApplicationEventsVtbl;

    interface IRemoteDebugApplicationEvents
    {
        CONST_VTBL struct IRemoteDebugApplicationEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationEvents_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugApplicationEvents_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugApplicationEvents_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugApplicationEvents_OnConnectDebugger(This,pad)   \
    (This)->lpVtbl -> OnConnectDebugger(This,pad)

#define IRemoteDebugApplicationEvents_OnDisconnectDebugger(This)    \
    (This)->lpVtbl -> OnDisconnectDebugger(This)

#define IRemoteDebugApplicationEvents_OnSetName(This,pstrName)  \
    (This)->lpVtbl -> OnSetName(This,pstrName)

#define IRemoteDebugApplicationEvents_OnDebugOutput(This,pstr)  \
    (This)->lpVtbl -> OnDebugOutput(This,pstr)

#define IRemoteDebugApplicationEvents_OnClose(This) \
    (This)->lpVtbl -> OnClose(This)

#define IRemoteDebugApplicationEvents_OnEnterBreakPoint(This,prdat) \
    (This)->lpVtbl -> OnEnterBreakPoint(This,prdat)

#define IRemoteDebugApplicationEvents_OnLeaveBreakPoint(This,prdat) \
    (This)->lpVtbl -> OnLeaveBreakPoint(This,prdat)

#define IRemoteDebugApplicationEvents_OnCreateThread(This,prdat)    \
    (This)->lpVtbl -> OnCreateThread(This,prdat)

#define IRemoteDebugApplicationEvents_OnDestroyThread(This,prdat)   \
    (This)->lpVtbl -> OnDestroyThread(This,prdat)

#define IRemoteDebugApplicationEvents_OnBreakFlagChange(This,abf,prdatSteppingThread)   \
    (This)->lpVtbl -> OnBreakFlagChange(This,abf,prdatSteppingThread)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnConnectDebugger_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ IApplicationDebugger __RPC_FAR *pad);


void __RPC_STUB IRemoteDebugApplicationEvents_OnConnectDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnDisconnectDebugger_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This);


void __RPC_STUB IRemoteDebugApplicationEvents_OnDisconnectDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnSetName_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrName);


void __RPC_STUB IRemoteDebugApplicationEvents_OnSetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnDebugOutput_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstr);


void __RPC_STUB IRemoteDebugApplicationEvents_OnDebugOutput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnClose_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This);


void __RPC_STUB IRemoteDebugApplicationEvents_OnClose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnEnterBreakPoint_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);


void __RPC_STUB IRemoteDebugApplicationEvents_OnEnterBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnLeaveBreakPoint_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);


void __RPC_STUB IRemoteDebugApplicationEvents_OnLeaveBreakPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnCreateThread_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);


void __RPC_STUB IRemoteDebugApplicationEvents_OnCreateThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnDestroyThread_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdat);


void __RPC_STUB IRemoteDebugApplicationEvents_OnDestroyThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationEvents_OnBreakFlagChange_Proxy( 
    IRemoteDebugApplicationEvents __RPC_FAR * This,
    /* [in] */ APPBREAKFLAGS abf,
    /* [in] */ IRemoteDebugApplicationThread __RPC_FAR *prdatSteppingThread);


void __RPC_STUB IRemoteDebugApplicationEvents_OnBreakFlagChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IRemoteDebugApplicationEvents_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationNode_INTERFACE_DEFINED__
#define __IDebugApplicationNode_INTERFACE_DEFINED__

/* interface IDebugApplicationNode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C34-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationNode : public IDebugDocumentProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumChildren( 
            /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocumentProvider( 
            /* [in] */ IDebugDocumentProvider __RPC_FAR *pddp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( 
            /* [in] */ IDebugApplicationNode __RPC_FAR *pdanParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplicationNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplicationNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplicationNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [in] */ DOCUMENTNAMETYPE dnt,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentClassId )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [out] */ CLSID __RPC_FAR *pclsidDocument);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocument )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [out] */ IDebugDocument __RPC_FAR *__RPC_FAR *ppssd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumChildren )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocumentProvider )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [in] */ IDebugDocumentProvider __RPC_FAR *pddp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IDebugApplicationNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Attach )( 
            IDebugApplicationNode __RPC_FAR * This,
            /* [in] */ IDebugApplicationNode __RPC_FAR *pdanParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Detach )( 
            IDebugApplicationNode __RPC_FAR * This);
        
        END_INTERFACE
    } IDebugApplicationNodeVtbl;

    interface IDebugApplicationNode
    {
        CONST_VTBL struct IDebugApplicationNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationNode_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplicationNode_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplicationNode_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IDebugApplicationNode_GetName(This,dnt,pbstrName)   \
    (This)->lpVtbl -> GetName(This,dnt,pbstrName)

#define IDebugApplicationNode_GetDocumentClassId(This,pclsidDocument)   \
    (This)->lpVtbl -> GetDocumentClassId(This,pclsidDocument)


#define IDebugApplicationNode_GetDocument(This,ppssd)   \
    (This)->lpVtbl -> GetDocument(This,ppssd)


#define IDebugApplicationNode_EnumChildren(This,pperddp)    \
    (This)->lpVtbl -> EnumChildren(This,pperddp)

#define IDebugApplicationNode_GetParent(This,pprddp)    \
    (This)->lpVtbl -> GetParent(This,pprddp)

#define IDebugApplicationNode_SetDocumentProvider(This,pddp)    \
    (This)->lpVtbl -> SetDocumentProvider(This,pddp)

#define IDebugApplicationNode_Close(This)   \
    (This)->lpVtbl -> Close(This)

#define IDebugApplicationNode_Attach(This,pdanParent)   \
    (This)->lpVtbl -> Attach(This,pdanParent)

#define IDebugApplicationNode_Detach(This)  \
    (This)->lpVtbl -> Detach(This)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplicationNode_EnumChildren_Proxy( 
    IDebugApplicationNode __RPC_FAR * This,
    /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp);


void __RPC_STUB IDebugApplicationNode_EnumChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNode_GetParent_Proxy( 
    IDebugApplicationNode __RPC_FAR * This,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp);


void __RPC_STUB IDebugApplicationNode_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNode_SetDocumentProvider_Proxy( 
    IDebugApplicationNode __RPC_FAR * This,
    /* [in] */ IDebugDocumentProvider __RPC_FAR *pddp);


void __RPC_STUB IDebugApplicationNode_SetDocumentProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNode_Close_Proxy( 
    IDebugApplicationNode __RPC_FAR * This);


void __RPC_STUB IDebugApplicationNode_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNode_Attach_Proxy( 
    IDebugApplicationNode __RPC_FAR * This,
    /* [in] */ IDebugApplicationNode __RPC_FAR *pdanParent);


void __RPC_STUB IDebugApplicationNode_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNode_Detach_Proxy( 
    IDebugApplicationNode __RPC_FAR * This);


void __RPC_STUB IDebugApplicationNode_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplicationNode_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationNodeEvents_INTERFACE_DEFINED__
#define __IDebugApplicationNodeEvents_INTERFACE_DEFINED__

/* interface IDebugApplicationNodeEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationNodeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C35-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationNodeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onAddChild( 
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onRemoveChild( 
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onDetach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onAttach( 
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpParent) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplicationNodeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplicationNodeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplicationNodeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplicationNodeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onAddChild )( 
            IDebugApplicationNodeEvents __RPC_FAR * This,
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onRemoveChild )( 
            IDebugApplicationNodeEvents __RPC_FAR * This,
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onDetach )( 
            IDebugApplicationNodeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *onAttach )( 
            IDebugApplicationNodeEvents __RPC_FAR * This,
            /* [in] */ IDebugApplicationNode __RPC_FAR *prddpParent);
        
        END_INTERFACE
    } IDebugApplicationNodeEventsVtbl;

    interface IDebugApplicationNodeEvents
    {
        CONST_VTBL struct IDebugApplicationNodeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationNodeEvents_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplicationNodeEvents_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplicationNodeEvents_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugApplicationNodeEvents_onAddChild(This,prddpChild) \
    (This)->lpVtbl -> onAddChild(This,prddpChild)

#define IDebugApplicationNodeEvents_onRemoveChild(This,prddpChild)  \
    (This)->lpVtbl -> onRemoveChild(This,prddpChild)

#define IDebugApplicationNodeEvents_onDetach(This)  \
    (This)->lpVtbl -> onDetach(This)

#define IDebugApplicationNodeEvents_onAttach(This,prddpParent)  \
    (This)->lpVtbl -> onAttach(This,prddpParent)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplicationNodeEvents_onAddChild_Proxy( 
    IDebugApplicationNodeEvents __RPC_FAR * This,
    /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild);


void __RPC_STUB IDebugApplicationNodeEvents_onAddChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNodeEvents_onRemoveChild_Proxy( 
    IDebugApplicationNodeEvents __RPC_FAR * This,
    /* [in] */ IDebugApplicationNode __RPC_FAR *prddpChild);


void __RPC_STUB IDebugApplicationNodeEvents_onRemoveChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNodeEvents_onDetach_Proxy( 
    IDebugApplicationNodeEvents __RPC_FAR * This);


void __RPC_STUB IDebugApplicationNodeEvents_onDetach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationNodeEvents_onAttach_Proxy( 
    IDebugApplicationNodeEvents __RPC_FAR * This,
    /* [in] */ IDebugApplicationNode __RPC_FAR *prddpParent);


void __RPC_STUB IDebugApplicationNodeEvents_onAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplicationNodeEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0233 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define IDebugThreadCall IDebugThreadCall64
#define IID_IDebugThreadCall IID_IDebugThreadCall64
#else
#define IDebugThreadCall IDebugThreadCall32
#define IID_IDebugThreadCall IID_IDebugThreadCall32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0233_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0233_v0_0_s_ifspec;

#ifndef __IDebugThreadCall32_INTERFACE_DEFINED__
#define __IDebugThreadCall32_INTERFACE_DEFINED__

/* interface IDebugThreadCall32 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadCall32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C36-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugThreadCall32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadCallHandler( 
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugThreadCall32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugThreadCall32 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugThreadCall32 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugThreadCall32 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadCallHandler )( 
            IDebugThreadCall32 __RPC_FAR * This,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        END_INTERFACE
    } IDebugThreadCall32Vtbl;

    interface IDebugThreadCall32
    {
        CONST_VTBL struct IDebugThreadCall32Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadCall32_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThreadCall32_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugThreadCall32_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugThreadCall32_ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)   \
    (This)->lpVtbl -> ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugThreadCall32_ThreadCallHandler_Proxy( 
    IDebugThreadCall32 __RPC_FAR * This,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2,
    /* [in] */ DWORD dwParam3);


void __RPC_STUB IDebugThreadCall32_ThreadCallHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugThreadCall32_INTERFACE_DEFINED__ */


#ifndef __IDebugThreadCall64_INTERFACE_DEFINED__
#define __IDebugThreadCall64_INTERFACE_DEFINED__

/* interface IDebugThreadCall64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugThreadCall64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cb3fa335-e979-42fd-9fcf-a7546a0f3905")
    IDebugThreadCall64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadCallHandler( 
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugThreadCall64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugThreadCall64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugThreadCall64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugThreadCall64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ThreadCallHandler )( 
            IDebugThreadCall64 __RPC_FAR * This,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        END_INTERFACE
    } IDebugThreadCall64Vtbl;

    interface IDebugThreadCall64
    {
        CONST_VTBL struct IDebugThreadCall64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugThreadCall64_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugThreadCall64_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IDebugThreadCall64_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IDebugThreadCall64_ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)   \
    (This)->lpVtbl -> ThreadCallHandler(This,dwParam1,dwParam2,dwParam3)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugThreadCall64_ThreadCallHandler_Proxy( 
    IDebugThreadCall64 __RPC_FAR * This,
    /* [in] */ DWORDLONG dwParam1,
    /* [in] */ DWORDLONG dwParam2,
    /* [in] */ DWORDLONG dwParam3);


void __RPC_STUB IDebugThreadCall64_ThreadCallHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugThreadCall64_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationThread_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationThread_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationThread */
/* [unique][uuid][object] */ 

typedef DWORD THREAD_STATE;

#define THREAD_STATE_RUNNING    ( 0x1 )

#define THREAD_STATE_SUSPENDED  ( 0x2 )

#define THREAD_BLOCKED  ( 0x4 )

#define THREAD_OUT_OF_CONTEXT   ( 0x8 )


EXTERN_C const IID IID_IRemoteDebugApplicationThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C37-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplicationThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSystemThreadId( 
            /* [out] */ DWORD __RPC_FAR *dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplication( 
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *pprda) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStackFrames( 
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription,
            /* [out] */ BSTR __RPC_FAR *pbstrState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement( 
            /* [in] */ IDebugStackFrame __RPC_FAR *pStackFrame,
            /* [in] */ IDebugCodeContext __RPC_FAR *pCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ DWORD __RPC_FAR *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSuspendCount( 
            /* [out] */ DWORD __RPC_FAR *pdwCount) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IRemoteDebugApplicationThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteDebugApplicationThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteDebugApplicationThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemThreadId )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplication )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *pprda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription,
            /* [out] */ BSTR __RPC_FAR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNextStatement )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [in] */ IDebugStackFrame __RPC_FAR *pStackFrame,
            /* [in] */ IDebugCodeContext __RPC_FAR *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuspendCount )( 
            IRemoteDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        END_INTERFACE
    } IRemoteDebugApplicationThreadVtbl;

    interface IRemoteDebugApplicationThread
    {
        CONST_VTBL struct IRemoteDebugApplicationThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationThread_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDebugApplicationThread_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDebugApplicationThread_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IRemoteDebugApplicationThread_GetSystemThreadId(This,dwThreadId)    \
    (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId)

#define IRemoteDebugApplicationThread_GetApplication(This,pprda)    \
    (This)->lpVtbl -> GetApplication(This,pprda)

#define IRemoteDebugApplicationThread_EnumStackFrames(This,ppedsf)  \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)

#define IRemoteDebugApplicationThread_GetDescription(This,pbstrDescription,pbstrState)  \
    (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState)

#define IRemoteDebugApplicationThread_SetNextStatement(This,pStackFrame,pCodeContext)   \
    (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext)

#define IRemoteDebugApplicationThread_GetState(This,pState) \
    (This)->lpVtbl -> GetState(This,pState)

#define IRemoteDebugApplicationThread_Suspend(This,pdwCount)    \
    (This)->lpVtbl -> Suspend(This,pdwCount)

#define IRemoteDebugApplicationThread_Resume(This,pdwCount) \
    (This)->lpVtbl -> Resume(This,pdwCount)

#define IRemoteDebugApplicationThread_GetSuspendCount(This,pdwCount)    \
    (This)->lpVtbl -> GetSuspendCount(This,pdwCount)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_GetSystemThreadId_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwThreadId);


void __RPC_STUB IRemoteDebugApplicationThread_GetSystemThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_GetApplication_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *pprda);


void __RPC_STUB IRemoteDebugApplicationThread_GetApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_EnumStackFrames_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);


void __RPC_STUB IRemoteDebugApplicationThread_EnumStackFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_GetDescription_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription,
    /* [out] */ BSTR __RPC_FAR *pbstrState);


void __RPC_STUB IRemoteDebugApplicationThread_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_SetNextStatement_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [in] */ IDebugStackFrame __RPC_FAR *pStackFrame,
    /* [in] */ IDebugCodeContext __RPC_FAR *pCodeContext);


void __RPC_STUB IRemoteDebugApplicationThread_SetNextStatement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_GetState_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pState);


void __RPC_STUB IRemoteDebugApplicationThread_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_Suspend_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IRemoteDebugApplicationThread_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_Resume_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IRemoteDebugApplicationThread_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteDebugApplicationThread_GetSuspendCount_Proxy( 
    IRemoteDebugApplicationThread __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCount);


void __RPC_STUB IRemoteDebugApplicationThread_GetSuspendCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IRemoteDebugApplicationThread_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0236 */
/* [local] */ 

#ifndef DISABLE_ACTIVDBG_INTERFACE_WRAPPERS
#ifdef _WIN64
#define SynchronousCallIntoThread SynchronousCallIntoThread64
#else
#define SynchronousCallIntoThread SynchronousCallIntoThread32
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0236_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0236_v0_0_s_ifspec;

#ifndef __IDebugApplicationThread_INTERFACE_DEFINED__
#define __IDebugApplicationThread_INTERFACE_DEFINED__

/* interface IDebugApplicationThread */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C38-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationThread : public IRemoteDebugApplicationThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallIntoThread32( 
            /* [in] */ IDebugThreadCall32 __RPC_FAR *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsCurrentThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryIsDebuggerThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPCOLESTR pstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStateString( 
            /* [in] */ LPCOLESTR pstrState) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplicationThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplicationThread __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplicationThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemThreadId )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplication )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *pprda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription,
            /* [out] */ BSTR __RPC_FAR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNextStatement )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [in] */ IDebugStackFrame __RPC_FAR *pStackFrame,
            /* [in] */ IDebugCodeContext __RPC_FAR *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuspendCount )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCallIntoThread32 )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [in] */ IDebugThreadCall32 __RPC_FAR *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsCurrentThread )( 
            IDebugApplicationThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsDebuggerThread )( 
            IDebugApplicationThread __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStateString )( 
            IDebugApplicationThread __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrState);
        
        END_INTERFACE
    } IDebugApplicationThreadVtbl;

    interface IDebugApplicationThread
    {
        CONST_VTBL struct IDebugApplicationThreadVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationThread_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplicationThread_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplicationThread_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugApplicationThread_GetSystemThreadId(This,dwThreadId)  \
    (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId)

#define IDebugApplicationThread_GetApplication(This,pprda)  \
    (This)->lpVtbl -> GetApplication(This,pprda)

#define IDebugApplicationThread_EnumStackFrames(This,ppedsf)    \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)

#define IDebugApplicationThread_GetDescription(This,pbstrDescription,pbstrState)    \
    (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState)

#define IDebugApplicationThread_SetNextStatement(This,pStackFrame,pCodeContext) \
    (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext)

#define IDebugApplicationThread_GetState(This,pState)   \
    (This)->lpVtbl -> GetState(This,pState)

#define IDebugApplicationThread_Suspend(This,pdwCount)  \
    (This)->lpVtbl -> Suspend(This,pdwCount)

#define IDebugApplicationThread_Resume(This,pdwCount)   \
    (This)->lpVtbl -> Resume(This,pdwCount)

#define IDebugApplicationThread_GetSuspendCount(This,pdwCount)  \
    (This)->lpVtbl -> GetSuspendCount(This,pdwCount)


#define IDebugApplicationThread_SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)  \
    (This)->lpVtbl -> SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)

#define IDebugApplicationThread_QueryIsCurrentThread(This)  \
    (This)->lpVtbl -> QueryIsCurrentThread(This)

#define IDebugApplicationThread_QueryIsDebuggerThread(This) \
    (This)->lpVtbl -> QueryIsDebuggerThread(This)

#define IDebugApplicationThread_SetDescription(This,pstrDescription)    \
    (This)->lpVtbl -> SetDescription(This,pstrDescription)

#define IDebugApplicationThread_SetStateString(This,pstrState)  \
    (This)->lpVtbl -> SetStateString(This,pstrState)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplicationThread_SynchronousCallIntoThread32_Proxy( 
    IDebugApplicationThread __RPC_FAR * This,
    /* [in] */ IDebugThreadCall32 __RPC_FAR *pstcb,
    /* [in] */ DWORD dwParam1,
    /* [in] */ DWORD dwParam2,
    /* [in] */ DWORD dwParam3);


void __RPC_STUB IDebugApplicationThread_SynchronousCallIntoThread32_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationThread_QueryIsCurrentThread_Proxy( 
    IDebugApplicationThread __RPC_FAR * This);


void __RPC_STUB IDebugApplicationThread_QueryIsCurrentThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationThread_QueryIsDebuggerThread_Proxy( 
    IDebugApplicationThread __RPC_FAR * This);


void __RPC_STUB IDebugApplicationThread_QueryIsDebuggerThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationThread_SetDescription_Proxy( 
    IDebugApplicationThread __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrDescription);


void __RPC_STUB IDebugApplicationThread_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugApplicationThread_SetStateString_Proxy( 
    IDebugApplicationThread __RPC_FAR * This,
    /* [in] */ LPCOLESTR pstrState);


void __RPC_STUB IDebugApplicationThread_SetStateString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplicationThread_INTERFACE_DEFINED__ */


#ifndef __IDebugApplicationThread64_INTERFACE_DEFINED__
#define __IDebugApplicationThread64_INTERFACE_DEFINED__

/* interface IDebugApplicationThread64 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationThread64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9dac5886-dbad-456d-9dee-5dec39ab3dda")
    IDebugApplicationThread64 : public IDebugApplicationThread
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SynchronousCallIntoThread64( 
            /* [in] */ IDebugThreadCall64 __RPC_FAR *pstcb,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugApplicationThread64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugApplicationThread64 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugApplicationThread64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemThreadId )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetApplication )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *pprda);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumStackFrames )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ IEnumDebugStackFrames __RPC_FAR *__RPC_FAR *ppedsf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription,
            /* [out] */ BSTR __RPC_FAR *pbstrState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNextStatement )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ IDebugStackFrame __RPC_FAR *pStackFrame,
            /* [in] */ IDebugCodeContext __RPC_FAR *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuspendCount )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCallIntoThread32 )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ IDebugThreadCall32 __RPC_FAR *pstcb,
            /* [in] */ DWORD dwParam1,
            /* [in] */ DWORD dwParam2,
            /* [in] */ DWORD dwParam3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsCurrentThread )( 
            IDebugApplicationThread64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryIsDebuggerThread )( 
            IDebugApplicationThread64 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStateString )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ LPCOLESTR pstrState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SynchronousCallIntoThread64 )( 
            IDebugApplicationThread64 __RPC_FAR * This,
            /* [in] */ IDebugThreadCall64 __RPC_FAR *pstcb,
            /* [in] */ DWORDLONG dwParam1,
            /* [in] */ DWORDLONG dwParam2,
            /* [in] */ DWORDLONG dwParam3);
        
        END_INTERFACE
    } IDebugApplicationThread64Vtbl;

    interface IDebugApplicationThread64
    {
        CONST_VTBL struct IDebugApplicationThread64Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationThread64_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugApplicationThread64_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IDebugApplicationThread64_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IDebugApplicationThread64_GetSystemThreadId(This,dwThreadId)    \
    (This)->lpVtbl -> GetSystemThreadId(This,dwThreadId)

#define IDebugApplicationThread64_GetApplication(This,pprda)    \
    (This)->lpVtbl -> GetApplication(This,pprda)

#define IDebugApplicationThread64_EnumStackFrames(This,ppedsf)  \
    (This)->lpVtbl -> EnumStackFrames(This,ppedsf)

#define IDebugApplicationThread64_GetDescription(This,pbstrDescription,pbstrState)  \
    (This)->lpVtbl -> GetDescription(This,pbstrDescription,pbstrState)

#define IDebugApplicationThread64_SetNextStatement(This,pStackFrame,pCodeContext)   \
    (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext)

#define IDebugApplicationThread64_GetState(This,pState) \
    (This)->lpVtbl -> GetState(This,pState)

#define IDebugApplicationThread64_Suspend(This,pdwCount)    \
    (This)->lpVtbl -> Suspend(This,pdwCount)

#define IDebugApplicationThread64_Resume(This,pdwCount) \
    (This)->lpVtbl -> Resume(This,pdwCount)

#define IDebugApplicationThread64_GetSuspendCount(This,pdwCount)    \
    (This)->lpVtbl -> GetSuspendCount(This,pdwCount)


#define IDebugApplicationThread64_SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)    \
    (This)->lpVtbl -> SynchronousCallIntoThread32(This,pstcb,dwParam1,dwParam2,dwParam3)

#define IDebugApplicationThread64_QueryIsCurrentThread(This)    \
    (This)->lpVtbl -> QueryIsCurrentThread(This)

#define IDebugApplicationThread64_QueryIsDebuggerThread(This)   \
    (This)->lpVtbl -> QueryIsDebuggerThread(This)

#define IDebugApplicationThread64_SetDescription(This,pstrDescription)  \
    (This)->lpVtbl -> SetDescription(This,pstrDescription)

#define IDebugApplicationThread64_SetStateString(This,pstrState)    \
    (This)->lpVtbl -> SetStateString(This,pstrState)


#define IDebugApplicationThread64_SynchronousCallIntoThread64(This,pstcb,dwParam1,dwParam2,dwParam3)    \
    (This)->lpVtbl -> SynchronousCallIntoThread64(This,pstcb,dwParam1,dwParam2,dwParam3)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugApplicationThread64_SynchronousCallIntoThread64_Proxy( 
    IDebugApplicationThread64 __RPC_FAR * This,
    /* [in] */ IDebugThreadCall64 __RPC_FAR *pstcb,
    /* [in] */ DWORDLONG dwParam1,
    /* [in] */ DWORDLONG dwParam2,
    /* [in] */ DWORDLONG dwParam3);


void __RPC_STUB IDebugApplicationThread64_SynchronousCallIntoThread64_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugApplicationThread64_INTERFACE_DEFINED__ */


#ifndef __IDebugCookie_INTERFACE_DEFINED__
#define __IDebugCookie_INTERFACE_DEFINED__

/* interface IDebugCookie */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDebugCookie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C39-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugCookie : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDebugCookie( 
            /* [in] */ DWORD dwDebugAppCookie) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDebugCookie )( 
            IDebugCookie __RPC_FAR * This,
            /* [in] */ DWORD dwDebugAppCookie);
        
        END_INTERFACE
    } IDebugCookieVtbl;

    interface IDebugCookie
    {
        CONST_VTBL struct IDebugCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugCookie_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugCookie_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugCookie_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugCookie_SetDebugCookie(This,dwDebugAppCookie)  \
    (This)->lpVtbl -> SetDebugCookie(This,dwDebugAppCookie)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugCookie_SetDebugCookie_Proxy( 
    IDebugCookie __RPC_FAR * This,
    /* [in] */ DWORD dwDebugAppCookie);


void __RPC_STUB IDebugCookie_SetDebugCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugCookie_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugApplicationNodes_INTERFACE_DEFINED__
#define __IEnumDebugApplicationNodes_INTERFACE_DEFINED__

/* interface IEnumDebugApplicationNodes */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugApplicationNodes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3a-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugApplicationNodes : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumDebugApplicationNodesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugApplicationNodes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugApplicationNodes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugApplicationNodes __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumDebugApplicationNodes __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugApplicationNodes __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugApplicationNodes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugApplicationNodes __RPC_FAR * This,
            /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp);
        
        END_INTERFACE
    } IEnumDebugApplicationNodesVtbl;

    interface IEnumDebugApplicationNodes
    {
        CONST_VTBL struct IEnumDebugApplicationNodesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugApplicationNodes_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugApplicationNodes_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugApplicationNodes_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumDebugApplicationNodes_Next(This,celt,pprddp,pceltFetched)  \
    (This)->lpVtbl -> Next(This,celt,pprddp,pceltFetched)

#define IEnumDebugApplicationNodes_Skip(This,celt)  \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugApplicationNodes_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugApplicationNodes_Clone(This,pperddp)  \
    (This)->lpVtbl -> Clone(This,pperddp)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugApplicationNodes_RemoteNext_Proxy( 
    IEnumDebugApplicationNodes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugApplicationNodes_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugApplicationNodes_Skip_Proxy( 
    IEnumDebugApplicationNodes __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugApplicationNodes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugApplicationNodes_Reset_Proxy( 
    IEnumDebugApplicationNodes __RPC_FAR * This);


void __RPC_STUB IEnumDebugApplicationNodes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugApplicationNodes_Clone_Proxy( 
    IEnumDebugApplicationNodes __RPC_FAR * This,
    /* [out] */ IEnumDebugApplicationNodes __RPC_FAR *__RPC_FAR *pperddp);


void __RPC_STUB IEnumDebugApplicationNodes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumDebugApplicationNodes_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDebugApplications_INTERFACE_DEFINED__
#define __IEnumRemoteDebugApplications_INTERFACE_DEFINED__

/* interface IEnumRemoteDebugApplications */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumRemoteDebugApplications;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3b-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumRemoteDebugApplications : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *ppda,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppessd) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumRemoteDebugApplicationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteDebugApplications __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteDebugApplications __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteDebugApplications __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumRemoteDebugApplications __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *ppda,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteDebugApplications __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteDebugApplications __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteDebugApplications __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppessd);
        
        END_INTERFACE
    } IEnumRemoteDebugApplicationsVtbl;

    interface IEnumRemoteDebugApplications
    {
        CONST_VTBL struct IEnumRemoteDebugApplicationsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDebugApplications_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteDebugApplications_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteDebugApplications_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteDebugApplications_Next(This,celt,ppda,pceltFetched)  \
    (This)->lpVtbl -> Next(This,celt,ppda,pceltFetched)

#define IEnumRemoteDebugApplications_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteDebugApplications_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteDebugApplications_Clone(This,ppessd) \
    (This)->lpVtbl -> Clone(This,ppessd)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplications_RemoteNext_Proxy( 
    IEnumRemoteDebugApplications __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *ppda,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteDebugApplications_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplications_Skip_Proxy( 
    IEnumRemoteDebugApplications __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteDebugApplications_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplications_Reset_Proxy( 
    IEnumRemoteDebugApplications __RPC_FAR * This);


void __RPC_STUB IEnumRemoteDebugApplications_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplications_Clone_Proxy( 
    IEnumRemoteDebugApplications __RPC_FAR * This,
    /* [out] */ IEnumRemoteDebugApplications __RPC_FAR *__RPC_FAR *ppessd);


void __RPC_STUB IEnumRemoteDebugApplications_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumRemoteDebugApplications_INTERFACE_DEFINED__ */


#ifndef __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__
#define __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__

/* interface IEnumRemoteDebugApplicationThreads */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumRemoteDebugApplicationThreads;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3c-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumRemoteDebugApplicationThreads : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdat,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumRemoteDebugApplicationThreadsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdat,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
            /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);
        
        END_INTERFACE
    } IEnumRemoteDebugApplicationThreadsVtbl;

    interface IEnumRemoteDebugApplicationThreads
    {
        CONST_VTBL struct IEnumRemoteDebugApplicationThreadsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRemoteDebugApplicationThreads_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRemoteDebugApplicationThreads_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IEnumRemoteDebugApplicationThreads_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IEnumRemoteDebugApplicationThreads_Next(This,celt,pprdat,pceltFetched)  \
    (This)->lpVtbl -> Next(This,celt,pprdat,pceltFetched)

#define IEnumRemoteDebugApplicationThreads_Skip(This,celt)  \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumRemoteDebugApplicationThreads_Reset(This)  \
    (This)->lpVtbl -> Reset(This)

#define IEnumRemoteDebugApplicationThreads_Clone(This,pperdat)  \
    (This)->lpVtbl -> Clone(This,pperdat)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_RemoteNext_Proxy( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *ppdat,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumRemoteDebugApplicationThreads_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplicationThreads_Skip_Proxy( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumRemoteDebugApplicationThreads_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplicationThreads_Reset_Proxy( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This);


void __RPC_STUB IEnumRemoteDebugApplicationThreads_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRemoteDebugApplicationThreads_Clone_Proxy( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
    /* [out] */ IEnumRemoteDebugApplicationThreads __RPC_FAR *__RPC_FAR *pperdat);


void __RPC_STUB IEnumRemoteDebugApplicationThreads_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumRemoteDebugApplicationThreads_INTERFACE_DEFINED__ */


#ifndef __IDebugFormatter_INTERFACE_DEFINED__
#define __IDebugFormatter_INTERFACE_DEFINED__

/* interface IDebugFormatter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugFormatter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C05-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugFormatter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStringForVariant( 
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ ULONG nRadix,
            /* [out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariantForString( 
            /* [in] */ LPCOLESTR pwstrValue,
            /* [out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringForVarType( 
            /* [in] */ VARTYPE vt,
            /* [in] */ TYPEDESC __RPC_FAR *ptdescArrayType,
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugFormatterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugFormatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugFormatter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugFormatter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringForVariant )( 
            IDebugFormatter __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ ULONG nRadix,
            /* [out] */ BSTR __RPC_FAR *pbstrValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVariantForString )( 
            IDebugFormatter __RPC_FAR * This,
            /* [in] */ LPCOLESTR pwstrValue,
            /* [out] */ VARIANT __RPC_FAR *pvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringForVarType )( 
            IDebugFormatter __RPC_FAR * This,
            /* [in] */ VARTYPE vt,
            /* [in] */ TYPEDESC __RPC_FAR *ptdescArrayType,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        END_INTERFACE
    } IDebugFormatterVtbl;

    interface IDebugFormatter
    {
        CONST_VTBL struct IDebugFormatterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugFormatter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugFormatter_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IDebugFormatter_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IDebugFormatter_GetStringForVariant(This,pvar,nRadix,pbstrValue)    \
    (This)->lpVtbl -> GetStringForVariant(This,pvar,nRadix,pbstrValue)

#define IDebugFormatter_GetVariantForString(This,pwstrValue,pvar)   \
    (This)->lpVtbl -> GetVariantForString(This,pwstrValue,pvar)

#define IDebugFormatter_GetStringForVarType(This,vt,ptdescArrayType,pbstr)  \
    (This)->lpVtbl -> GetStringForVarType(This,vt,ptdescArrayType,pbstr)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugFormatter_GetStringForVariant_Proxy( 
    IDebugFormatter __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvar,
    /* [in] */ ULONG nRadix,
    /* [out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB IDebugFormatter_GetStringForVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugFormatter_GetVariantForString_Proxy( 
    IDebugFormatter __RPC_FAR * This,
    /* [in] */ LPCOLESTR pwstrValue,
    /* [out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IDebugFormatter_GetVariantForString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugFormatter_GetStringForVarType_Proxy( 
    IDebugFormatter __RPC_FAR * This,
    /* [in] */ VARTYPE vt,
    /* [in] */ TYPEDESC __RPC_FAR *ptdescArrayType,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDebugFormatter_GetStringForVarType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugFormatter_INTERFACE_DEFINED__ */


#ifndef __ISimpleConnectionPoint_INTERFACE_DEFINED__
#define __ISimpleConnectionPoint_INTERFACE_DEFINED__

/* interface ISimpleConnectionPoint */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISimpleConnectionPoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3e-CB0C-11d0-B5C9-00A0244A0E7A")
    ISimpleConnectionPoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventCount( 
            /* [out] */ ULONG __RPC_FAR *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DescribeEvents( 
            /* [in] */ ULONG iEvent,
            /* [in] */ ULONG cEvents,
            /* [length_is][size_is][out] */ DISPID __RPC_FAR *prgid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *prgbstr,
            /* [out] */ ULONG __RPC_FAR *pcEventsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct ISimpleConnectionPointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleConnectionPoint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleConnectionPoint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleConnectionPoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventCount )( 
            ISimpleConnectionPoint __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DescribeEvents )( 
            ISimpleConnectionPoint __RPC_FAR * This,
            /* [in] */ ULONG iEvent,
            /* [in] */ ULONG cEvents,
            /* [length_is][size_is][out] */ DISPID __RPC_FAR *prgid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *prgbstr,
            /* [out] */ ULONG __RPC_FAR *pcEventsFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            ISimpleConnectionPoint __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            ISimpleConnectionPoint __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ISimpleConnectionPointVtbl;

    interface ISimpleConnectionPoint
    {
        CONST_VTBL struct ISimpleConnectionPointVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleConnectionPoint_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleConnectionPoint_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define ISimpleConnectionPoint_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define ISimpleConnectionPoint_GetEventCount(This,pulCount) \
    (This)->lpVtbl -> GetEventCount(This,pulCount)

#define ISimpleConnectionPoint_DescribeEvents(This,iEvent,cEvents,prgid,prgbstr,pcEventsFetched)    \
    (This)->lpVtbl -> DescribeEvents(This,iEvent,cEvents,prgid,prgbstr,pcEventsFetched)

#define ISimpleConnectionPoint_Advise(This,pdisp,pdwCookie) \
    (This)->lpVtbl -> Advise(This,pdisp,pdwCookie)

#define ISimpleConnectionPoint_Unadvise(This,dwCookie)  \
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE ISimpleConnectionPoint_GetEventCount_Proxy( 
    ISimpleConnectionPoint __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulCount);


void __RPC_STUB ISimpleConnectionPoint_GetEventCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleConnectionPoint_DescribeEvents_Proxy( 
    ISimpleConnectionPoint __RPC_FAR * This,
    /* [in] */ ULONG iEvent,
    /* [in] */ ULONG cEvents,
    /* [length_is][size_is][out] */ DISPID __RPC_FAR *prgid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *prgbstr,
    /* [out] */ ULONG __RPC_FAR *pcEventsFetched);


void __RPC_STUB ISimpleConnectionPoint_DescribeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleConnectionPoint_Advise_Proxy( 
    ISimpleConnectionPoint __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB ISimpleConnectionPoint_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISimpleConnectionPoint_Unadvise_Proxy( 
    ISimpleConnectionPoint __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ISimpleConnectionPoint_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __ISimpleConnectionPoint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activdbg_0244 */
/* [local] */ 

EXTERN_C const CLSID CLSID_DebugHelper;


extern RPC_IF_HANDLE __MIDL_itf_activdbg_0244_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0244_v0_0_s_ifspec;

#ifndef __IDebugHelper_INTERFACE_DEFINED__
#define __IDebugHelper_INTERFACE_DEFINED__

/* interface IDebugHelper */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C3f-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowser( 
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowserEx( 
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
            /* [in] */ IDebugFormatter __RPC_FAR *pdf,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSimpleConnectionPoint( 
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [out] */ ISimpleConnectionPoint __RPC_FAR *__RPC_FAR *ppscp) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IDebugHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugHelper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugHelper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugHelper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyBrowser )( 
            IDebugHelper __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreatePropertyBrowserEx )( 
            IDebugHelper __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
            /* [in] */ IDebugFormatter __RPC_FAR *pdf,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSimpleConnectionPoint )( 
            IDebugHelper __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [out] */ ISimpleConnectionPoint __RPC_FAR *__RPC_FAR *ppscp);
        
        END_INTERFACE
    } IDebugHelperVtbl;

    interface IDebugHelper
    {
        CONST_VTBL struct IDebugHelperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugHelper_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugHelper_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IDebugHelper_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IDebugHelper_CreatePropertyBrowser(This,pvar,bstrName,pdat,ppdob)   \
    (This)->lpVtbl -> CreatePropertyBrowser(This,pvar,bstrName,pdat,ppdob)

#define IDebugHelper_CreatePropertyBrowserEx(This,pvar,bstrName,pdat,pdf,ppdob) \
    (This)->lpVtbl -> CreatePropertyBrowserEx(This,pvar,bstrName,pdat,pdf,ppdob)

#define IDebugHelper_CreateSimpleConnectionPoint(This,pdisp,ppscp)  \
    (This)->lpVtbl -> CreateSimpleConnectionPoint(This,pdisp,ppscp)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IDebugHelper_CreatePropertyBrowser_Proxy( 
    IDebugHelper __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvar,
    /* [in] */ LPCOLESTR bstrName,
    /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob);


void __RPC_STUB IDebugHelper_CreatePropertyBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugHelper_CreatePropertyBrowserEx_Proxy( 
    IDebugHelper __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pvar,
    /* [in] */ LPCOLESTR bstrName,
    /* [in] */ IDebugApplicationThread __RPC_FAR *pdat,
    /* [in] */ IDebugFormatter __RPC_FAR *pdf,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppdob);


void __RPC_STUB IDebugHelper_CreatePropertyBrowserEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugHelper_CreateSimpleConnectionPoint_Proxy( 
    IDebugHelper __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp,
    /* [out] */ ISimpleConnectionPoint __RPC_FAR *__RPC_FAR *ppscp);


void __RPC_STUB IDebugHelper_CreateSimpleConnectionPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IDebugHelper_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExpressionContexts_INTERFACE_DEFINED__
#define __IEnumDebugExpressionContexts_INTERFACE_DEFINED__

/* interface IEnumDebugExpressionContexts */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugExpressionContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C40-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExpressionContexts : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IDebugExpressionContext __RPC_FAR *__RPC_FAR *ppdec,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumDebugExpressionContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExpressionContexts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExpressionContexts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExpressionContexts __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumDebugExpressionContexts __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IDebugExpressionContext __RPC_FAR *__RPC_FAR *ppdec,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExpressionContexts __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExpressionContexts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExpressionContexts __RPC_FAR * This,
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);
        
        END_INTERFACE
    } IEnumDebugExpressionContextsVtbl;

    interface IEnumDebugExpressionContexts
    {
        CONST_VTBL struct IEnumDebugExpressionContextsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExpressionContexts_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExpressionContexts_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExpressionContexts_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExpressionContexts_Next(This,celt,ppdec,pceltFetched) \
    (This)->lpVtbl -> Next(This,celt,ppdec,pceltFetched)

#define IEnumDebugExpressionContexts_Skip(This,celt)    \
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExpressionContexts_Reset(This)    \
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExpressionContexts_Clone(This,ppedec) \
    (This)->lpVtbl -> Clone(This,ppedec)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugExpressionContexts_RemoteNext_Proxy( 
    IEnumDebugExpressionContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugExpressionContext __RPC_FAR *__RPC_FAR *pprgdec,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExpressionContexts_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExpressionContexts_Skip_Proxy( 
    IEnumDebugExpressionContexts __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExpressionContexts_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExpressionContexts_Reset_Proxy( 
    IEnumDebugExpressionContexts __RPC_FAR * This);


void __RPC_STUB IEnumDebugExpressionContexts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExpressionContexts_Clone_Proxy( 
    IEnumDebugExpressionContexts __RPC_FAR * This,
    /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);


void __RPC_STUB IEnumDebugExpressionContexts_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumDebugExpressionContexts_INTERFACE_DEFINED__ */


#ifndef __IProvideExpressionContexts_INTERFACE_DEFINED__
#define __IProvideExpressionContexts_INTERFACE_DEFINED__

/* interface IProvideExpressionContexts */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvideExpressionContexts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C41-CB0C-11d0-B5C9-00A0244A0E7A")
    IProvideExpressionContexts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumExpressionContexts( 
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IProvideExpressionContextsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideExpressionContexts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideExpressionContexts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideExpressionContexts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExpressionContexts )( 
            IProvideExpressionContexts __RPC_FAR * This,
            /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);
        
        END_INTERFACE
    } IProvideExpressionContextsVtbl;

    interface IProvideExpressionContexts
    {
        CONST_VTBL struct IProvideExpressionContextsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideExpressionContexts_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideExpressionContexts_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IProvideExpressionContexts_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IProvideExpressionContexts_EnumExpressionContexts(This,ppedec)  \
    (This)->lpVtbl -> EnumExpressionContexts(This,ppedec)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IProvideExpressionContexts_EnumExpressionContexts_Proxy( 
    IProvideExpressionContexts __RPC_FAR * This,
    /* [out] */ IEnumDebugExpressionContexts __RPC_FAR *__RPC_FAR *ppedec);


void __RPC_STUB IProvideExpressionContexts_EnumExpressionContexts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IProvideExpressionContexts_INTERFACE_DEFINED__ */



#ifndef __ProcessDebugManagerLib_LIBRARY_DEFINED__
#define __ProcessDebugManagerLib_LIBRARY_DEFINED__

/* library ProcessDebugManagerLib */
/* [helpstring][version][uuid] */ 


























































EXTERN_C const CLSID CLSID_CDebugDocumentHelper;

EXTERN_C const IID LIBID_ProcessDebugManagerLib;

EXTERN_C const CLSID CLSID_ProcessDebugManager;

#ifdef __cplusplus

class DECLSPEC_UUID("78a51822-51f4-11d0-8f20-00805f2cd064")
ProcessDebugManager;
#endif

EXTERN_C const CLSID CLSID_DebugHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("0BFCC060-8C1D-11d0-ACCD-00AA0060275C")
DebugHelper;
#endif

EXTERN_C const CLSID CLSID_CDebugDocumentHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("83B8BCA6-687C-11D0-A405-00AA0060275C")
CDebugDocumentHelper;
#endif

EXTERN_C const CLSID CLSID_MachineDebugManager;

#ifdef __cplusplus

class DECLSPEC_UUID("49769CEC-3A55-4bb0-B697-88FEDE77E8EA")
MachineDebugManager;
#endif

EXTERN_C const CLSID CLSID_DefaultDebugSessionProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("834128a2-51f4-11d0-8f20-00805f2cd064")
DefaultDebugSessionProvider;
#endif
#endif /* __ProcessDebugManagerLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_activdbg_0247 */
/* [local] */ 


#endif  // __ActivDbg_h



extern RPC_IF_HANDLE __MIDL_itf_activdbg_0247_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activdbg_0247_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* [local] */ HRESULT __stdcall IEnumDebugCodeContexts_Next_Proxy( 
    IEnumDebugCodeContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *pscc,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugCodeContexts_Next_Stub( 
    IEnumDebugCodeContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugCodeContext __RPC_FAR *__RPC_FAR *pscc,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugStackFrames_Next_Proxy( 
    IEnumDebugStackFrames __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames_Next_Stub( 
    IEnumDebugStackFrames __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugStackFrameDescriptor __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugStackFrames64_Next64_Proxy( 
    IEnumDebugStackFrames64 __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugStackFrameDescriptor64 __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugStackFrames64_Next64_Stub( 
    IEnumDebugStackFrames64 __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ DebugStackFrameDescriptor64 __RPC_FAR *prgdsfd,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugApplicationNodes_Next_Proxy( 
    IEnumDebugApplicationNodes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugApplicationNodes_Next_Stub( 
    IEnumDebugApplicationNodes __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugApplicationNode __RPC_FAR *__RPC_FAR *pprddp,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumRemoteDebugApplications_Next_Proxy( 
    IEnumRemoteDebugApplications __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *ppda,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplications_Next_Stub( 
    IEnumRemoteDebugApplications __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteDebugApplication __RPC_FAR *__RPC_FAR *ppda,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_Next_Proxy( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *pprdat,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumRemoteDebugApplicationThreads_Next_Stub( 
    IEnumRemoteDebugApplicationThreads __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IRemoteDebugApplicationThread __RPC_FAR *__RPC_FAR *ppdat,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT __stdcall IEnumDebugExpressionContexts_Next_Proxy( 
    IEnumDebugExpressionContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ IDebugExpressionContext __RPC_FAR *__RPC_FAR *ppdec,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugExpressionContexts_Next_Stub( 
    IEnumDebugExpressionContexts __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDebugExpressionContext __RPC_FAR *__RPC_FAR *pprgdec,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\activaut.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:33 2007
 */
/* Compiler settings for ..\activaut.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activaut_h__
#define __activaut_h__

/* Forward Declarations */ 

#ifndef __IScriptNode_FWD_DEFINED__
#define __IScriptNode_FWD_DEFINED__
typedef interface IScriptNode IScriptNode;
#endif  /* __IScriptNode_FWD_DEFINED__ */


#ifndef __IScriptEntry_FWD_DEFINED__
#define __IScriptEntry_FWD_DEFINED__
typedef interface IScriptEntry IScriptEntry;
#endif  /* __IScriptEntry_FWD_DEFINED__ */


#ifndef __IScriptScriptlet_FWD_DEFINED__
#define __IScriptScriptlet_FWD_DEFINED__
typedef interface IScriptScriptlet IScriptScriptlet;
#endif  /* __IScriptScriptlet_FWD_DEFINED__ */


#ifndef __IActiveScriptAuthor_FWD_DEFINED__
#define __IActiveScriptAuthor_FWD_DEFINED__
typedef interface IActiveScriptAuthor IActiveScriptAuthor;
#endif  /* __IActiveScriptAuthor_FWD_DEFINED__ */


#ifndef __IActiveScriptAuthorProcedure_FWD_DEFINED__
#define __IActiveScriptAuthorProcedure_FWD_DEFINED__
typedef interface IActiveScriptAuthorProcedure IActiveScriptAuthorProcedure;
#endif  /* __IActiveScriptAuthorProcedure_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/* interface __MIDL_itf_activaut_0000 */
/* [local] */

//=--------------------------------------------------------------------------=
// ActivAut.h
//=--------------------------------------------------------------------------=
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Script Authoring.
//

#ifndef __ActivAut_h
#define __ActivAut_h

/* GUIDs
 ********/

#ifndef _NO_AUTHOR_GUIDS
// {0AEE2A92-BCBB-11d0-8C72-00C04FC2B085}
DEFINE_GUID(CATID_ActiveScriptAuthor, 0xaee2a92, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {9C109DA0-7006-11d1-B36C-00A0C911E8B2}
DEFINE_GUID(IID_IActiveScriptAuthor, 0x9c109da0, 0x7006, 0x11d1, 0xb3, 0x6c, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

// {0AEE2A94-BCBB-11d0-8C72-00C04FC2B085}
DEFINE_GUID(IID_IScriptNode, 0xaee2a94, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {0AEE2A95-BCBB-11d0-8C72-00C04FC2B085}
DEFINE_GUID(IID_IScriptEntry, 0xaee2a95, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {0AEE2A96-BCBB-11d0-8C72-00C04FC2B085}
DEFINE_GUID(IID_IScriptScriptlet, 0xaee2a96, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {7E2D4B70-BD9A-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptAuthorProcedure, 0x7e2d4b70, 0xbd9a, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

#endif // _NO_AUTHOR_GUIDS

/* Interfaces
 *************/


// Output flags for GetLanguageFlags
const DWORD fasaPreferInternalHandler = 0x0001;
const DWORD fasaSupportInternalHandler = 0x0002;
const DWORD fasaCaseSensitive = 0x0004;

// Flags for statement completion
const DWORD SCRIPT_CMPL_NOLIST     = 0x0000;
const DWORD SCRIPT_CMPL_MEMBERLIST = 0x0001;
const DWORD SCRIPT_CMPL_ENUMLIST   = 0x0002;
const DWORD SCRIPT_CMPL_PARAMTIP   = 0x0004;
const DWORD SCRIPT_CMPL_GLOBALLIST = 0x0008;

const DWORD SCRIPT_CMPL_ENUM_TRIGGER   = 0x0001;
const DWORD SCRIPT_CMPL_MEMBER_TRIGGER = 0x0002;
const DWORD SCRIPT_CMPL_PARAM_TRIGGER  = 0x0003;
const DWORD SCRIPT_CMPL_COMMIT         = 0x0004;

// Flags for getting attributes
const DWORD GETATTRTYPE_NORMAL    = 0x0000;
const DWORD GETATTRTYPE_DEPSCAN   = 0x0001;

// GETATTRFLAG_THIS can be used with either GETATTRTYPE_NORMAL or GETATTRTYPE_DEPSCAN
const DWORD GETATTRFLAG_THIS        = 0x0100;
const DWORD GETATTRFLAG_HUMANTEXT = 0x8000;

// When the GETATTR_LOCALIZE flag is set the following bit will be
// set for source attributes that should be considered localized
const DWORD SOURCETEXT_ATTR_HUMANTEXT = 0x8000;

// Valid attributes returned for GETATTR_DEPSCAN
const DWORD SOURCETEXT_ATTR_IDENTIFIER     = 0x0100;
const DWORD SOURCETEXT_ATTR_MEMBERLOOKUP   = 0x0200;

// When the GETATTRFLAG_THIS flag is set the following bit will be
// set for the this pointer (JS) or me pointer (VBS)
const DWORD SOURCETEXT_ATTR_THIS           = 0x0400;




typedef WORD SOURCE_TEXT_ATTR;



extern RPC_IF_HANDLE __MIDL_itf_activaut_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activaut_0000_v0_0_s_ifspec;

#ifndef __IScriptNode_INTERFACE_DEFINED__
#define __IScriptNode_INTERFACE_DEFINED__

/* interface IScriptNode */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IScriptNode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AEE2A94-BCBB-11d0-8C72-00C04FC2B085")
    IScriptNode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Alive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsnParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexInParent( 
            /* [out] */ ULONG __RPC_FAR *pisn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCookie( 
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChildren( 
            /* [out] */ ULONG __RPC_FAR *pcsn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChild( 
            /* [in] */ ULONG isn,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateChildEntry( 
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateChildHandler( 
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [size_is][in] */ LPCOLESTR __RPC_FAR *prgpszNames,
            /* [in] */ ULONG cpszNames,
            /* [in] */ LPCOLESTR pszEvent,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ ITypeInfo __RPC_FAR *ptiSignature,
            /* [in] */ ULONG iMethodSignature,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IScriptNodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptNode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptNode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alive )( 
            IScriptNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IScriptNode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IScriptNode __RPC_FAR * This,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsnParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexInParent )( 
            IScriptNode __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pisn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCookie )( 
            IScriptNode __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfChildren )( 
            IScriptNode __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            IScriptNode __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguage )( 
            IScriptNode __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildEntry )( 
            IScriptNode __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildHandler )( 
            IScriptNode __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [size_is][in] */ LPCOLESTR __RPC_FAR *prgpszNames,
            /* [in] */ ULONG cpszNames,
            /* [in] */ LPCOLESTR pszEvent,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ ITypeInfo __RPC_FAR *ptiSignature,
            /* [in] */ ULONG iMethodSignature,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        END_INTERFACE
    } IScriptNodeVtbl;

    interface IScriptNode
    {
        CONST_VTBL struct IScriptNodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptNode_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptNode_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IScriptNode_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IScriptNode_Alive(This) \
    (This)->lpVtbl -> Alive(This)

#define IScriptNode_Delete(This)    \
    (This)->lpVtbl -> Delete(This)

#define IScriptNode_GetParent(This,ppsnParent)  \
    (This)->lpVtbl -> GetParent(This,ppsnParent)

#define IScriptNode_GetIndexInParent(This,pisn) \
    (This)->lpVtbl -> GetIndexInParent(This,pisn)

#define IScriptNode_GetCookie(This,pdwCookie)   \
    (This)->lpVtbl -> GetCookie(This,pdwCookie)

#define IScriptNode_GetNumberOfChildren(This,pcsn)  \
    (This)->lpVtbl -> GetNumberOfChildren(This,pcsn)

#define IScriptNode_GetChild(This,isn,ppsn) \
    (This)->lpVtbl -> GetChild(This,isn,ppsn)

#define IScriptNode_GetLanguage(This,pbstr) \
    (This)->lpVtbl -> GetLanguage(This,pbstr)

#define IScriptNode_CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)   \
    (This)->lpVtbl -> CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)

#define IScriptNode_CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse) \
    (This)->lpVtbl -> CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IScriptNode_Alive_Proxy( 
    IScriptNode __RPC_FAR * This);


void __RPC_STUB IScriptNode_Alive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_Delete_Proxy( 
    IScriptNode __RPC_FAR * This);


void __RPC_STUB IScriptNode_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetParent_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsnParent);


void __RPC_STUB IScriptNode_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetIndexInParent_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pisn);


void __RPC_STUB IScriptNode_GetIndexInParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetCookie_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IScriptNode_GetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetNumberOfChildren_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcsn);


void __RPC_STUB IScriptNode_GetNumberOfChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetChild_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [in] */ ULONG isn,
    /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsn);


void __RPC_STUB IScriptNode_GetChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_GetLanguage_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptNode_GetLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_CreateChildEntry_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [in] */ ULONG isn,
    /* [in] */ DWORD dwCookie,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);


void __RPC_STUB IScriptNode_CreateChildEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptNode_CreateChildHandler_Proxy( 
    IScriptNode __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszDefaultName,
    /* [size_is][in] */ LPCOLESTR __RPC_FAR *prgpszNames,
    /* [in] */ ULONG cpszNames,
    /* [in] */ LPCOLESTR pszEvent,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ ITypeInfo __RPC_FAR *ptiSignature,
    /* [in] */ ULONG iMethodSignature,
    /* [in] */ ULONG isn,
    /* [in] */ DWORD dwCookie,
    /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);


void __RPC_STUB IScriptNode_CreateChildHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IScriptNode_INTERFACE_DEFINED__ */


#ifndef __IScriptEntry_INTERFACE_DEFINED__
#define __IScriptEntry_INTERFACE_DEFINED__

/* interface IScriptEntry */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IScriptEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AEE2A95-BCBB-11d0-8C72-00C04FC2B085")
    IScriptEntry : public IScriptNode
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBody( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBody( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemName( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemName( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignature( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti,
            /* [out] */ ULONG __RPC_FAR *piMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignature( 
            /* [in] */ ITypeInfo __RPC_FAR *pti,
            /* [in] */ ULONG iMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRange( 
            /* [out] */ ULONG __RPC_FAR *pichMin,
            /* [out] */ ULONG __RPC_FAR *pcch) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IScriptEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alive )( 
            IScriptEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IScriptEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsnParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexInParent )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pisn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCookie )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfChildren )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguage )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildEntry )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildHandler )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [size_is][in] */ LPCOLESTR __RPC_FAR *prgpszNames,
            /* [in] */ ULONG cpszNames,
            /* [in] */ LPCOLESTR pszEvent,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ ITypeInfo __RPC_FAR *ptiSignature,
            /* [in] */ ULONG iMethodSignature,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBody )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemName )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemName )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSignature )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti,
            /* [out] */ ULONG __RPC_FAR *piMethod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSignature )( 
            IScriptEntry __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *pti,
            /* [in] */ ULONG iMethod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRange )( 
            IScriptEntry __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pichMin,
            /* [out] */ ULONG __RPC_FAR *pcch);
        
        END_INTERFACE
    } IScriptEntryVtbl;

    interface IScriptEntry
    {
        CONST_VTBL struct IScriptEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptEntry_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptEntry_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IScriptEntry_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IScriptEntry_Alive(This)    \
    (This)->lpVtbl -> Alive(This)

#define IScriptEntry_Delete(This)   \
    (This)->lpVtbl -> Delete(This)

#define IScriptEntry_GetParent(This,ppsnParent) \
    (This)->lpVtbl -> GetParent(This,ppsnParent)

#define IScriptEntry_GetIndexInParent(This,pisn)    \
    (This)->lpVtbl -> GetIndexInParent(This,pisn)

#define IScriptEntry_GetCookie(This,pdwCookie)  \
    (This)->lpVtbl -> GetCookie(This,pdwCookie)

#define IScriptEntry_GetNumberOfChildren(This,pcsn) \
    (This)->lpVtbl -> GetNumberOfChildren(This,pcsn)

#define IScriptEntry_GetChild(This,isn,ppsn)    \
    (This)->lpVtbl -> GetChild(This,isn,ppsn)

#define IScriptEntry_GetLanguage(This,pbstr)    \
    (This)->lpVtbl -> GetLanguage(This,pbstr)

#define IScriptEntry_CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)  \
    (This)->lpVtbl -> CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)

#define IScriptEntry_CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse)    \
    (This)->lpVtbl -> CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse)


#define IScriptEntry_GetText(This,pbstr)    \
    (This)->lpVtbl -> GetText(This,pbstr)

#define IScriptEntry_SetText(This,psz)  \
    (This)->lpVtbl -> SetText(This,psz)

#define IScriptEntry_GetBody(This,pbstr)    \
    (This)->lpVtbl -> GetBody(This,pbstr)

#define IScriptEntry_SetBody(This,psz)  \
    (This)->lpVtbl -> SetBody(This,psz)

#define IScriptEntry_GetName(This,pbstr)    \
    (This)->lpVtbl -> GetName(This,pbstr)

#define IScriptEntry_SetName(This,psz)  \
    (This)->lpVtbl -> SetName(This,psz)

#define IScriptEntry_GetItemName(This,pbstr)    \
    (This)->lpVtbl -> GetItemName(This,pbstr)

#define IScriptEntry_SetItemName(This,psz)  \
    (This)->lpVtbl -> SetItemName(This,psz)

#define IScriptEntry_GetSignature(This,ppti,piMethod)   \
    (This)->lpVtbl -> GetSignature(This,ppti,piMethod)

#define IScriptEntry_SetSignature(This,pti,iMethod) \
    (This)->lpVtbl -> SetSignature(This,pti,iMethod)

#define IScriptEntry_GetRange(This,pichMin,pcch)    \
    (This)->lpVtbl -> GetRange(This,pichMin,pcch)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IScriptEntry_GetText_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptEntry_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_SetText_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptEntry_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_GetBody_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptEntry_GetBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_SetBody_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptEntry_SetBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_GetName_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptEntry_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_SetName_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptEntry_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_GetItemName_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptEntry_GetItemName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_SetItemName_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptEntry_SetItemName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_GetSignature_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti,
    /* [out] */ ULONG __RPC_FAR *piMethod);


void __RPC_STUB IScriptEntry_GetSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_SetSignature_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [in] */ ITypeInfo __RPC_FAR *pti,
    /* [in] */ ULONG iMethod);


void __RPC_STUB IScriptEntry_SetSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptEntry_GetRange_Proxy( 
    IScriptEntry __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pichMin,
    /* [out] */ ULONG __RPC_FAR *pcch);


void __RPC_STUB IScriptEntry_GetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IScriptEntry_INTERFACE_DEFINED__ */


#ifndef __IScriptScriptlet_INTERFACE_DEFINED__
#define __IScriptScriptlet_INTERFACE_DEFINED__

/* interface IScriptScriptlet */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IScriptScriptlet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AEE2A96-BCBB-11d0-8C72-00C04FC2B085")
    IScriptScriptlet : public IScriptEntry
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubItemName( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubItemName( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventName( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventName( 
            /* [in] */ LPCOLESTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSimpleEventName( 
            /* [out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSimpleEventName( 
            /* [in] */ LPCOLESTR psz) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IScriptScriptletVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptScriptlet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptScriptlet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alive )( 
            IScriptScriptlet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IScriptScriptlet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsnParent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexInParent )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pisn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCookie )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfChildren )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChild )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguage )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildEntry )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateChildHandler )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [size_is][in] */ LPCOLESTR __RPC_FAR *prgpszNames,
            /* [in] */ ULONG cpszNames,
            /* [in] */ LPCOLESTR pszEvent,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ ITypeInfo __RPC_FAR *ptiSignature,
            /* [in] */ ULONG iMethodSignature,
            /* [in] */ ULONG isn,
            /* [in] */ DWORD dwCookie,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBody )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBody )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItemName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItemName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSignature )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti,
            /* [out] */ ULONG __RPC_FAR *piMethod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSignature )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *pti,
            /* [in] */ ULONG iMethod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRange )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pichMin,
            /* [out] */ ULONG __RPC_FAR *pcch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubItemName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSubItemName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSimpleEventName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSimpleEventName )( 
            IScriptScriptlet __RPC_FAR * This,
            /* [in] */ LPCOLESTR psz);
        
        END_INTERFACE
    } IScriptScriptletVtbl;

    interface IScriptScriptlet
    {
        CONST_VTBL struct IScriptScriptletVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptScriptlet_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptScriptlet_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IScriptScriptlet_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IScriptScriptlet_Alive(This)    \
    (This)->lpVtbl -> Alive(This)

#define IScriptScriptlet_Delete(This)   \
    (This)->lpVtbl -> Delete(This)

#define IScriptScriptlet_GetParent(This,ppsnParent) \
    (This)->lpVtbl -> GetParent(This,ppsnParent)

#define IScriptScriptlet_GetIndexInParent(This,pisn)    \
    (This)->lpVtbl -> GetIndexInParent(This,pisn)

#define IScriptScriptlet_GetCookie(This,pdwCookie)  \
    (This)->lpVtbl -> GetCookie(This,pdwCookie)

#define IScriptScriptlet_GetNumberOfChildren(This,pcsn) \
    (This)->lpVtbl -> GetNumberOfChildren(This,pcsn)

#define IScriptScriptlet_GetChild(This,isn,ppsn)    \
    (This)->lpVtbl -> GetChild(This,isn,ppsn)

#define IScriptScriptlet_GetLanguage(This,pbstr)    \
    (This)->lpVtbl -> GetLanguage(This,pbstr)

#define IScriptScriptlet_CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)  \
    (This)->lpVtbl -> CreateChildEntry(This,isn,dwCookie,pszDelimiter,ppse)

#define IScriptScriptlet_CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse)    \
    (This)->lpVtbl -> CreateChildHandler(This,pszDefaultName,prgpszNames,cpszNames,pszEvent,pszDelimiter,ptiSignature,iMethodSignature,isn,dwCookie,ppse)


#define IScriptScriptlet_GetText(This,pbstr)    \
    (This)->lpVtbl -> GetText(This,pbstr)

#define IScriptScriptlet_SetText(This,psz)  \
    (This)->lpVtbl -> SetText(This,psz)

#define IScriptScriptlet_GetBody(This,pbstr)    \
    (This)->lpVtbl -> GetBody(This,pbstr)

#define IScriptScriptlet_SetBody(This,psz)  \
    (This)->lpVtbl -> SetBody(This,psz)

#define IScriptScriptlet_GetName(This,pbstr)    \
    (This)->lpVtbl -> GetName(This,pbstr)

#define IScriptScriptlet_SetName(This,psz)  \
    (This)->lpVtbl -> SetName(This,psz)

#define IScriptScriptlet_GetItemName(This,pbstr)    \
    (This)->lpVtbl -> GetItemName(This,pbstr)

#define IScriptScriptlet_SetItemName(This,psz)  \
    (This)->lpVtbl -> SetItemName(This,psz)

#define IScriptScriptlet_GetSignature(This,ppti,piMethod)   \
    (This)->lpVtbl -> GetSignature(This,ppti,piMethod)

#define IScriptScriptlet_SetSignature(This,pti,iMethod) \
    (This)->lpVtbl -> SetSignature(This,pti,iMethod)

#define IScriptScriptlet_GetRange(This,pichMin,pcch)    \
    (This)->lpVtbl -> GetRange(This,pichMin,pcch)


#define IScriptScriptlet_GetSubItemName(This,pbstr) \
    (This)->lpVtbl -> GetSubItemName(This,pbstr)

#define IScriptScriptlet_SetSubItemName(This,psz)   \
    (This)->lpVtbl -> SetSubItemName(This,psz)

#define IScriptScriptlet_GetEventName(This,pbstr)   \
    (This)->lpVtbl -> GetEventName(This,pbstr)

#define IScriptScriptlet_SetEventName(This,psz) \
    (This)->lpVtbl -> SetEventName(This,psz)

#define IScriptScriptlet_GetSimpleEventName(This,pbstr) \
    (This)->lpVtbl -> GetSimpleEventName(This,pbstr)

#define IScriptScriptlet_SetSimpleEventName(This,psz)   \
    (This)->lpVtbl -> SetSimpleEventName(This,psz)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IScriptScriptlet_GetSubItemName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptScriptlet_GetSubItemName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptScriptlet_SetSubItemName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptScriptlet_SetSubItemName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptScriptlet_GetEventName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptScriptlet_GetEventName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptScriptlet_SetEventName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptScriptlet_SetEventName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptScriptlet_GetSimpleEventName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IScriptScriptlet_GetSimpleEventName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IScriptScriptlet_SetSimpleEventName_Proxy( 
    IScriptScriptlet __RPC_FAR * This,
    /* [in] */ LPCOLESTR psz);


void __RPC_STUB IScriptScriptlet_SetSimpleEventName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IScriptScriptlet_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptAuthor_INTERFACE_DEFINED__
#define __IActiveScriptAuthor_INTERFACE_DEFINED__

/* interface IActiveScriptAuthor */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IActiveScriptAuthor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C109DA0-7006-11d1-B36C-00A0C911E8B2")
    IActiveScriptAuthor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddNamedItem( 
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDispatch __RPC_FAR *pdisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszSubItemName,
            /* [in] */ LPCOLESTR pszEventName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cch,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptletTextAttributes( 
            /* [size_is][in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cch,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageFlags( 
            /* [out] */ DWORD __RPC_FAR *pgrfasa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventHandler( 
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [in] */ LPCOLESTR pszItem,
            /* [in] */ LPCOLESTR pszSubItem,
            /* [in] */ LPCOLESTR pszEvent,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveNamedItem( 
            /* [in] */ LPCOLESTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTypeLib( 
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveTypeLib( 
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChars( 
            /* [in] */ DWORD fRequestedList,
            /* [out] */ BSTR __RPC_FAR *pbstrChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInfoFromContext( 
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ ULONG ichCurrentPosition,
            /* [in] */ DWORD dwListTypesRequested,
            /* [out] */ DWORD __RPC_FAR *pdwListTypesProvided,
            /* [out] */ ULONG __RPC_FAR *pichListAnchorPosition,
            /* [out] */ ULONG __RPC_FAR *pichFuncAnchorPosition,
            /* [out] */ MEMBERID __RPC_FAR *pmemid,
            /* [out] */ LONG __RPC_FAR *piCurrentParameter,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsCommitChar( 
            /* [in] */ OLECHAR ch,
            /* [out] */ BOOL __RPC_FAR *pfcommit) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IActiveScriptAuthorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptAuthor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptAuthor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddNamedItem )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDispatch __RPC_FAR *pdisp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddScriptlet )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszDefaultName,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszSubItemName,
            /* [in] */ LPCOLESTR pszEventName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseScriptText )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptTextAttributes )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cch,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScriptletTextAttributes )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [size_is][in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cch,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageFlags )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pgrfasa);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventHandler )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pdisp,
            /* [in] */ LPCOLESTR pszItem,
            /* [in] */ LPCOLESTR pszSubItem,
            /* [in] */ LPCOLESTR pszEvent,
            /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveNamedItem )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTypeLib )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveTypeLib )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChars )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ DWORD fRequestedList,
            /* [out] */ BSTR __RPC_FAR *pbstrChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfoFromContext )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ ULONG cchCode,
            /* [in] */ ULONG ichCurrentPosition,
            /* [in] */ DWORD dwListTypesRequested,
            /* [out] */ DWORD __RPC_FAR *pdwListTypesProvided,
            /* [out] */ ULONG __RPC_FAR *pichListAnchorPosition,
            /* [out] */ ULONG __RPC_FAR *pichFuncAnchorPosition,
            /* [out] */ MEMBERID __RPC_FAR *pmemid,
            /* [out] */ LONG __RPC_FAR *piCurrentParameter,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsCommitChar )( 
            IActiveScriptAuthor __RPC_FAR * This,
            /* [in] */ OLECHAR ch,
            /* [out] */ BOOL __RPC_FAR *pfcommit);
        
        END_INTERFACE
    } IActiveScriptAuthorVtbl;

    interface IActiveScriptAuthor
    {
        CONST_VTBL struct IActiveScriptAuthorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptAuthor_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptAuthor_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptAuthor_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptAuthor_AddNamedItem(This,pszName,dwFlags,pdisp)    \
    (This)->lpVtbl -> AddNamedItem(This,pszName,dwFlags,pdisp)

#define IActiveScriptAuthor_AddScriptlet(This,pszDefaultName,pszCode,pszItemName,pszSubItemName,pszEventName,pszDelimiter,dwCookie,dwFlags) \
    (This)->lpVtbl -> AddScriptlet(This,pszDefaultName,pszCode,pszItemName,pszSubItemName,pszEventName,pszDelimiter,dwCookie,dwFlags)

#define IActiveScriptAuthor_ParseScriptText(This,pszCode,pszItemName,pszDelimiter,dwCookie,dwFlags) \
    (This)->lpVtbl -> ParseScriptText(This,pszCode,pszItemName,pszDelimiter,dwCookie,dwFlags)

#define IActiveScriptAuthor_GetScriptTextAttributes(This,pszCode,cch,pszDelimiter,dwFlags,pattr)    \
    (This)->lpVtbl -> GetScriptTextAttributes(This,pszCode,cch,pszDelimiter,dwFlags,pattr)

#define IActiveScriptAuthor_GetScriptletTextAttributes(This,pszCode,cch,pszDelimiter,dwFlags,pattr) \
    (This)->lpVtbl -> GetScriptletTextAttributes(This,pszCode,cch,pszDelimiter,dwFlags,pattr)

#define IActiveScriptAuthor_GetRoot(This,ppsp)  \
    (This)->lpVtbl -> GetRoot(This,ppsp)

#define IActiveScriptAuthor_GetLanguageFlags(This,pgrfasa)  \
    (This)->lpVtbl -> GetLanguageFlags(This,pgrfasa)

#define IActiveScriptAuthor_GetEventHandler(This,pdisp,pszItem,pszSubItem,pszEvent,ppse)    \
    (This)->lpVtbl -> GetEventHandler(This,pdisp,pszItem,pszSubItem,pszEvent,ppse)

#define IActiveScriptAuthor_RemoveNamedItem(This,pszName)   \
    (This)->lpVtbl -> RemoveNamedItem(This,pszName)

#define IActiveScriptAuthor_AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)   \
    (This)->lpVtbl -> AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)

#define IActiveScriptAuthor_RemoveTypeLib(This,rguidTypeLib,dwMajor,dwMinor)    \
    (This)->lpVtbl -> RemoveTypeLib(This,rguidTypeLib,dwMajor,dwMinor)

#define IActiveScriptAuthor_GetChars(This,fRequestedList,pbstrChars)    \
    (This)->lpVtbl -> GetChars(This,fRequestedList,pbstrChars)

#define IActiveScriptAuthor_GetInfoFromContext(This,pszCode,cchCode,ichCurrentPosition,dwListTypesRequested,pdwListTypesProvided,pichListAnchorPosition,pichFuncAnchorPosition,pmemid,piCurrentParameter,ppunk) \
    (This)->lpVtbl -> GetInfoFromContext(This,pszCode,cchCode,ichCurrentPosition,dwListTypesRequested,pdwListTypesProvided,pichListAnchorPosition,pichFuncAnchorPosition,pmemid,piCurrentParameter,ppunk)

#define IActiveScriptAuthor_IsCommitChar(This,ch,pfcommit)  \
    (This)->lpVtbl -> IsCommitChar(This,ch,pfcommit)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_AddNamedItem_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDispatch __RPC_FAR *pdisp);


void __RPC_STUB IActiveScriptAuthor_AddNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_AddScriptlet_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszDefaultName,
    /* [in] */ LPCOLESTR pszCode,
    /* [in] */ LPCOLESTR pszItemName,
    /* [in] */ LPCOLESTR pszSubItemName,
    /* [in] */ LPCOLESTR pszEventName,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ DWORD dwCookie,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScriptAuthor_AddScriptlet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_ParseScriptText_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszCode,
    /* [in] */ LPCOLESTR pszItemName,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ DWORD dwCookie,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScriptAuthor_ParseScriptText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetScriptTextAttributes_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pszCode,
    /* [in] */ ULONG cch,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptAuthor_GetScriptTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetScriptletTextAttributes_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [size_is][in] */ LPCOLESTR pszCode,
    /* [in] */ ULONG cch,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out][in] */ SOURCE_TEXT_ATTR __RPC_FAR *pattr);


void __RPC_STUB IActiveScriptAuthor_GetScriptletTextAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetRoot_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [out] */ IScriptNode __RPC_FAR *__RPC_FAR *ppsp);


void __RPC_STUB IActiveScriptAuthor_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetLanguageFlags_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pgrfasa);


void __RPC_STUB IActiveScriptAuthor_GetLanguageFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetEventHandler_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pdisp,
    /* [in] */ LPCOLESTR pszItem,
    /* [in] */ LPCOLESTR pszSubItem,
    /* [in] */ LPCOLESTR pszEvent,
    /* [out] */ IScriptEntry __RPC_FAR *__RPC_FAR *ppse);


void __RPC_STUB IActiveScriptAuthor_GetEventHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_RemoveNamedItem_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszName);


void __RPC_STUB IActiveScriptAuthor_RemoveNamedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_AddTypeLib_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ REFGUID rguidTypeLib,
    /* [in] */ DWORD dwMajor,
    /* [in] */ DWORD dwMinor,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveScriptAuthor_AddTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_RemoveTypeLib_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ REFGUID rguidTypeLib,
    /* [in] */ DWORD dwMajor,
    /* [in] */ DWORD dwMinor);


void __RPC_STUB IActiveScriptAuthor_RemoveTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetChars_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ DWORD fRequestedList,
    /* [out] */ BSTR __RPC_FAR *pbstrChars);


void __RPC_STUB IActiveScriptAuthor_GetChars_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_GetInfoFromContext_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszCode,
    /* [in] */ ULONG cchCode,
    /* [in] */ ULONG ichCurrentPosition,
    /* [in] */ DWORD dwListTypesRequested,
    /* [out] */ DWORD __RPC_FAR *pdwListTypesProvided,
    /* [out] */ ULONG __RPC_FAR *pichListAnchorPosition,
    /* [out] */ ULONG __RPC_FAR *pichFuncAnchorPosition,
    /* [out] */ MEMBERID __RPC_FAR *pmemid,
    /* [out] */ LONG __RPC_FAR *piCurrentParameter,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IActiveScriptAuthor_GetInfoFromContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveScriptAuthor_IsCommitChar_Proxy( 
    IActiveScriptAuthor __RPC_FAR * This,
    /* [in] */ OLECHAR ch,
    /* [out] */ BOOL __RPC_FAR *pfcommit);


void __RPC_STUB IActiveScriptAuthor_IsCommitChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptAuthor_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptAuthorProcedure_INTERFACE_DEFINED__
#define __IActiveScriptAuthorProcedure_INTERFACE_DEFINED__

/* interface IActiveScriptAuthorProcedure */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IActiveScriptAuthorProcedure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E2D4B70-BD9A-11d0-9336-00A0C90DCAA9")
    IActiveScriptAuthorProcedure : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszFormalParams,
            /* [in] */ LPCOLESTR pszProcedureName,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDispatch __RPC_FAR *pdispFor) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IActiveScriptAuthorProcedureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveScriptAuthorProcedure __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveScriptAuthorProcedure __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveScriptAuthorProcedure __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseProcedureText )( 
            IActiveScriptAuthorProcedure __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszCode,
            /* [in] */ LPCOLESTR pszFormalParams,
            /* [in] */ LPCOLESTR pszProcedureName,
            /* [in] */ LPCOLESTR pszItemName,
            /* [in] */ LPCOLESTR pszDelimiter,
            /* [in] */ DWORD dwCookie,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDispatch __RPC_FAR *pdispFor);
        
        END_INTERFACE
    } IActiveScriptAuthorProcedureVtbl;

    interface IActiveScriptAuthorProcedure
    {
        CONST_VTBL struct IActiveScriptAuthorProcedureVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptAuthorProcedure_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveScriptAuthorProcedure_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IActiveScriptAuthorProcedure_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IActiveScriptAuthorProcedure_ParseProcedureText(This,pszCode,pszFormalParams,pszProcedureName,pszItemName,pszDelimiter,dwCookie,dwFlags,pdispFor)   \
    (This)->lpVtbl -> ParseProcedureText(This,pszCode,pszFormalParams,pszProcedureName,pszItemName,pszDelimiter,dwCookie,dwFlags,pdispFor)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IActiveScriptAuthorProcedure_ParseProcedureText_Proxy( 
    IActiveScriptAuthorProcedure __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszCode,
    /* [in] */ LPCOLESTR pszFormalParams,
    /* [in] */ LPCOLESTR pszProcedureName,
    /* [in] */ LPCOLESTR pszItemName,
    /* [in] */ LPCOLESTR pszDelimiter,
    /* [in] */ DWORD dwCookie,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDispatch __RPC_FAR *pdispFor);


void __RPC_STUB IActiveScriptAuthorProcedure_ParseProcedureText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IActiveScriptAuthorProcedure_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activaut_0152 */
/* [local] */ 


#endif  // __ActivAut_h



extern RPC_IF_HANDLE __MIDL_itf_activaut_0152_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activaut_0152_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\addrmapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
/*++

Module Name:

    addrmapi.h

Purpose:

    List of properties used in the address book database.

--*/

#ifndef _ADDRMAPI_
#define _ADDRMAPI_

#ifndef HHPR_TAG_ONLY

// Here are the MAPI property types, taken from MAPIDEFS.H.
#define MV_FLAG         0x1000                                                  // multi-value flag
#define PT_UNSPECIFIED  ((ULONG)  0)  // (reserved for interface use) type doesn't matter to caller
#define PT_NULL         ((ULONG)  1)                                         // NULL property value
#define PT_I2           ((ULONG)  2)                                         // signed 16-bit value
#define PT_LONG         ((ULONG)  3)                                         // signed 32-bit value
#define PT_R4           ((ULONG)  4)                                       // 4-byte floating point
#define PT_DOUBLE       ((ULONG)  5)                                       // floating point double
#define PT_CURRENCY     ((ULONG)  6) // signed 64-bit int (decimal w/ 4 digits right of decimal pt)
#define PT_APPTIME      ((ULONG)  7)                                            // application time
#define PT_ERROR        ((ULONG) 10)                                          // 32-bit error value
// our store doesn't understand PT_BOOLEAN
//#define PT_BOOLEAN      ((ULONG) 11)                              // 16-bit boolean (non-zero true)
#define PT_OBJECT       ((ULONG) 13)                               // embedded object in a property
#define PT_I8           ((ULONG) 20)                                       // 8-byte signed integer
#define PT_STRING8      ((ULONG) 30)                      // null terminated 8-bit character string
#define PT_UNICODE      ((ULONG) 31)                              // null terminated Unicode string
#define PT_SYSTIME      ((ULONG) 64) // FILETIME 64-bit int (num of 100ns periods since Jan 1,1601)
#define PT_CLSID        ((ULONG) 72)                                                    // OLE GUID
#define PT_BINARY       ((ULONG) 258)                         // uninterpreted (counted byte array)

// Alternate property type names for ease of use.
#define PT_BOOLEAN  PT_I2
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

// Property Tags.  By convention, MAPI never uses 0 or FFFF as a property ID.  Use as null values,
// initializers, sentinels, or what have you.
#define PROP_TYPE_MASK        ((ULONG)0x0000FFFF)  /* Mask for Property type */
#define PROP_TYPE(ulPropTag)  (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)    (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)  ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL       0
#define PROP_ID_INVALID       0xFFFF
#define PR_NULL               PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)

// Here are properties defined by MAPI, taken from MAPITAGS.H.
#define PR_BODY_W                             PROP_TAG( PT_UNICODE,   0x1000)
#define PR_BUSINESS_FAX_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_TELEPHONE_NUMBER_W        PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_CALLBACK_TELEPHONE_NUMBER_W        PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CAR_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_COMPANY_NAME_W                     PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_CONTENT_UNREAD                     PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATION_TIME                      PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_DEPARTMENT_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DISPLAY_BCC_W                      PROP_TAG( PT_UNICODE,   0x0E02)
#define PR_DISPLAY_CC_W                       PROP_TAG( PT_UNICODE,   0x0E03)
#define PR_DISPLAY_TO_W                       PROP_TAG( PT_UNICODE,   0x0E04)
#define PR_GENERATION_W                       PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GIVEN_NAME_W                       PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_HOME2_TELEPHONE_NUMBER_W           PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME_FAX_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_TELEPHONE_NUMBER_W            PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_IMPORTANCE                         PROP_TAG( PT_LONG,      0x0017)
#define PR_KEYWORD_W                          PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_LAST_MODIFICATION_TIME             PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_MESSAGE_DELIVERY_TIME              PROP_TAG( PT_SYSTIME,   0x0E06)
#define PR_MESSAGE_FLAGS                      PROP_TAG( PT_LONG,      0x0E07)
#define PR_MESSAGE_SIZE                       PROP_TAG( PT_LONG,      0x0E08)
#define PR_MOBILE_TELEPHONE_NUMBER_W          PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER_W        PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_RADIO_TELEPHONE_NUMBER_W           PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_OFFICE_LOCATION_W                  PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_TELEPHONE_NUMBER_W          PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OTHER_TELEPHONE_NUMBER_W           PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_PRIMARY_FAX_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_TELEPHONE_NUMBER_W         PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIORITY                           PROP_TAG( PT_LONG,      0x0026)
#define PR_REPLY_RECIPIENT_NAMES_W            PROP_TAG( PT_UNICODE,   0x0050)
#define PR_REPLY_REQUESTED                    PROP_TAG( PT_BOOLEAN,   0x0C17)
#define PR_REPLY_TIME                         PROP_TAG( PT_SYSTIME,   0x0030)
#define PR_RESPONSE_REQUESTED                 PROP_TAG( PT_BOOLEAN,   0x0063)
#define PR_SECURITY                           PROP_TAG( PT_LONG,      0x0034)
#define PR_SENSITIVITY                        PROP_TAG( PT_LONG,      0x0036)
#define PR_SUBJECT_W                          PROP_TAG( PT_UNICODE,   0x0037)
#define PR_SURNAME_W                          PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_TELEX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TITLE_W                            PROP_TAG( PT_UNICODE,   0x3A17)

#define PR_YOMI_FIRSTNAME_W                   PROP_TAG( PT_UNICODE,   0x4011)
#define PR_YOMI_LASTNAME_W                    PROP_TAG( PT_UNICODE,   0x4010)

#endif  // HHPR_TAG_ONLY

// Here are our property tags.  Note that we use the MAPI tags when they are defined, otherwise we
// use the MAPI dispid's, which are store-specific.  The numbers used here (8xxx) were obtained by
// examining the MAPI database entries created by Ren.  For these we rely on replication to do the
// appropriate conversions.  Note also that we use the _W form of their string properties, as we
// are a unicode system.  Your mileage may vary.

typedef ULONG HHPRTAG;                                                    // this is a property tag

// Please do NOT use PT_BOOLEAN, use PEGVT_I2 instead. because this file is shared by both
// pegasus and desktop (which uses MAPI with a different valued PT_BOOLEAN) replication.

// DO NOT use property tags 0x4950 to 0x49ff -- they are reserved for future usage

#define HHPR_ANNIVERSARY                      PROP_TAG(PT_SYSTIME, 0x4003)
#define HHPR_ASSISTANT_NAME                   PROP_TAG(PT_UNICODE, 0x4002)
#define HHPR_ASSISTANT_TELEPHONE_NUMBER       PROP_TAG(PT_UNICODE, 0x4004)
#define HHPR_BIRTHDAY                         PROP_TAG(PT_SYSTIME, 0x4001)
#define HHPR_BUSINESS_FAX_NUMBER              PR_BUSINESS_FAX_NUMBER_W
#define HHPR_CAR_TELEPHONE_NUMBER             PR_CAR_TELEPHONE_NUMBER_W
#define HHPR_CATEGORY                         PROP_TAG(PT_UNICODE, 0x4005)
#define HHPR_CHILDREN_NAME                    PROP_TAG(PT_UNICODE, 0x4006)
#define HHPR_COMPANY_NAME                     PR_COMPANY_NAME_W
#define HHPR_CUSTOM_DISPLAY_FIELDS            PROP_TAG(PT_UNICODE, 0x4317)  //$$BUGBUG -- this should stay 4317, not 8317
// 10 so far
#define HHPR_DEPARTMENT_NAME                  PR_DEPARTMENT_NAME_W
#define HHPR_EMAIL1_EMAIL_ADDRESS             PROP_TAG(PT_UNICODE, 0x4083)
#define HHPR_EMAIL2_EMAIL_ADDRESS             PROP_TAG(PT_UNICODE, 0x4093)
#define HHPR_EMAIL3_EMAIL_ADDRESS             PROP_TAG(PT_UNICODE, 0x40A3)
#define HHPR_GENERATION                       PR_GENERATION_W
#define HHPR_GIVEN_NAME                       PR_GIVEN_NAME_W
#define HHPR_HOME2_TELEPHONE_NUMBER           PR_HOME2_TELEPHONE_NUMBER_W
#define HHPR_HOME_ADDRESS_CITY                PROP_TAG(PT_UNICODE, 0x4041)
#define HHPR_HOME_ADDRESS_COUNTRY             PROP_TAG(PT_UNICODE, 0x4044)
#define HHPR_HOME_ADDRESS_POSTAL_CODE         PROP_TAG(PT_UNICODE, 0x4043)
// 20 so far
#define HHPR_HOME_ADDRESS_STATE               PROP_TAG(PT_UNICODE, 0x4042)
#define HHPR_HOME_ADDRESS_STREET              PROP_TAG(PT_UNICODE, 0x4040)
#define HHPR_HOME_FAX_NUMBER                  PR_HOME_FAX_NUMBER_W
#define HHPR_HOME_TELEPHONE_NUMBER            PR_HOME_TELEPHONE_NUMBER_W
#define HHPR_MIDDLE_NAME                      PROP_TAG(PT_UNICODE, 0x4024)
#define HHPR_MOBILE_TELEPHONE_NUMBER          PR_MOBILE_TELEPHONE_NUMBER_W
#define HHPR_NAME_PREFIX                      PROP_TAG(PT_UNICODE, 0x4023)
#define HHPR_NOTES                            PR_BODY_W
#define HHPR_OFFICE_ADDRESS_CITY              PROP_TAG(PT_UNICODE, 0x4046)
#define HHPR_OFFICE_ADDRESS_COUNTRY           PROP_TAG(PT_UNICODE, 0x4049)
// 30 so far
#define HHPR_OFFICE_ADDRESS_POSTAL_CODE       PROP_TAG(PT_UNICODE, 0x4048)
#define HHPR_OFFICE_ADDRESS_STATE             PROP_TAG(PT_UNICODE, 0x4047)
#define HHPR_OFFICE_ADDRESS_STREET            PROP_TAG(PT_UNICODE, 0x4045)
#define HHPR_OFFICE_LOCATION                  PR_OFFICE_LOCATION_W
#define HHPR_OFFICE_TELEPHONE_NUMBER          PR_OFFICE_TELEPHONE_NUMBER_W
#define HHPR_OFFICE2_TELEPHONE_NUMBER         PROP_TAG(PT_UNICODE, 0x4007)
#define HHPR_OTHER_ADDRESS_CITY               PROP_TAG(PT_UNICODE, 0x404B)
#define HHPR_OTHER_ADDRESS_COUNTRY            PROP_TAG(PT_UNICODE, 0x404E)
#define HHPR_OTHER_ADDRESS_POSTAL_CODE        PROP_TAG(PT_UNICODE, 0x404D)
#define HHPR_OTHER_ADDRESS_STATE              PROP_TAG(PT_UNICODE, 0x404C)
// 40 so far
#define HHPR_OTHER_ADDRESS_STREET             PROP_TAG(PT_UNICODE, 0x404A)
#define HHPR_PAGER_NUMBER                     PROP_TAG(PT_UNICODE, 0x4009)
#define HHPR_SPOUSE_NAME                      PROP_TAG(PT_UNICODE, 0x400a)
#define HHPR_SURNAME                          PR_SURNAME_W
#define HHPR_TITLE                            PR_TITLE_W
#define HHPR_WEB_PAGE                         PROP_TAG(PT_UNICODE, 0x4008)
#define HHPR_RADIO_TELEPHONE_NUMBER           PR_RADIO_TELEPHONE_NUMBER_W
#define HHPR_FILEAS                           PROP_TAG(PT_UNICODE, 0x4013)

#define HHPR_YOMI_FIRSTNAME                   PR_YOMI_FIRSTNAME_W
#define HHPR_YOMI_LASTNAME                    PR_YOMI_LASTNAME_W

#define HHPR_YOMI_NAME 						  PROP_TAG(PT_UNICODE, 0x8319)
#define HHPR_YOMI_COMPANY					  PROP_TAG(PT_UNICODE, 0x4012)
#define HHPR_YOMI_SORT						  PROP_TAG(PT_UNICODE, 0x8318)
#define HHPR_YOMICOMPANY_SORT				  PROP_TAG(PT_UNICODE, 0x8320)

// How many address card properties were there?
#define HHAB_CARD_NUMPROPS          55

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\activscp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* at Mon May 12 13:40:50 2008
 */
/* Compiler settings for ..\activscp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __activscp_h__
#define __activscp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveScriptSite_FWD_DEFINED__
#define __IActiveScriptSite_FWD_DEFINED__
typedef interface IActiveScriptSite IActiveScriptSite;
#endif 	/* __IActiveScriptSite_FWD_DEFINED__ */


#ifndef __IActiveScriptError_FWD_DEFINED__
#define __IActiveScriptError_FWD_DEFINED__
typedef interface IActiveScriptError IActiveScriptError;
#endif 	/* __IActiveScriptError_FWD_DEFINED__ */


#ifndef __IActiveScriptError64_FWD_DEFINED__
#define __IActiveScriptError64_FWD_DEFINED__
typedef interface IActiveScriptError64 IActiveScriptError64;
#endif 	/* __IActiveScriptError64_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_FWD_DEFINED__
#define __IActiveScriptSiteWindow_FWD_DEFINED__
typedef interface IActiveScriptSiteWindow IActiveScriptSiteWindow;
#endif 	/* __IActiveScriptSiteWindow_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteUIControl_FWD_DEFINED__
#define __IActiveScriptSiteUIControl_FWD_DEFINED__
typedef interface IActiveScriptSiteUIControl IActiveScriptSiteUIControl;
#endif 	/* __IActiveScriptSiteUIControl_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
#define __IActiveScriptSiteInterruptPoll_FWD_DEFINED__
typedef interface IActiveScriptSiteInterruptPoll IActiveScriptSiteInterruptPoll;
#endif 	/* __IActiveScriptSiteInterruptPoll_FWD_DEFINED__ */


#ifndef __IActiveScript_FWD_DEFINED__
#define __IActiveScript_FWD_DEFINED__
typedef interface IActiveScript IActiveScript;
#endif 	/* __IActiveScript_FWD_DEFINED__ */


#ifndef __IActiveScriptParse32_FWD_DEFINED__
#define __IActiveScriptParse32_FWD_DEFINED__
typedef interface IActiveScriptParse32 IActiveScriptParse32;
#endif 	/* __IActiveScriptParse32_FWD_DEFINED__ */


#ifndef __IActiveScriptParse64_FWD_DEFINED__
#define __IActiveScriptParse64_FWD_DEFINED__
typedef interface IActiveScriptParse64 IActiveScriptParse64;
#endif 	/* __IActiveScriptParse64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld32_FWD_DEFINED__
#define __IActiveScriptParseProcedureOld32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedureOld32 IActiveScriptParseProcedureOld32;
#endif 	/* __IActiveScriptParseProcedureOld32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld64_FWD_DEFINED__
#define __IActiveScriptParseProcedureOld64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedureOld64 IActiveScriptParseProcedureOld64;
#endif 	/* __IActiveScriptParseProcedureOld64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure32_FWD_DEFINED__
#define __IActiveScriptParseProcedure32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure32 IActiveScriptParseProcedure32;
#endif 	/* __IActiveScriptParseProcedure32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure64_FWD_DEFINED__
#define __IActiveScriptParseProcedure64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure64 IActiveScriptParseProcedure64;
#endif 	/* __IActiveScriptParseProcedure64_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_32_FWD_DEFINED__
#define __IActiveScriptParseProcedure2_32_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure2_32 IActiveScriptParseProcedure2_32;
#endif 	/* __IActiveScriptParseProcedure2_32_FWD_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_64_FWD_DEFINED__
#define __IActiveScriptParseProcedure2_64_FWD_DEFINED__
typedef interface IActiveScriptParseProcedure2_64 IActiveScriptParseProcedure2_64;
#endif 	/* __IActiveScriptParseProcedure2_64_FWD_DEFINED__ */


#ifndef __IActiveScriptEncode_FWD_DEFINED__
#define __IActiveScriptEncode_FWD_DEFINED__
typedef interface IActiveScriptEncode IActiveScriptEncode;
#endif 	/* __IActiveScriptEncode_FWD_DEFINED__ */


#ifndef __IActiveScriptHostEncode_FWD_DEFINED__
#define __IActiveScriptHostEncode_FWD_DEFINED__
typedef interface IActiveScriptHostEncode IActiveScriptHostEncode;
#endif 	/* __IActiveScriptHostEncode_FWD_DEFINED__ */


#ifndef __IBindEventHandler_FWD_DEFINED__
#define __IBindEventHandler_FWD_DEFINED__
typedef interface IBindEventHandler IBindEventHandler;
#endif 	/* __IBindEventHandler_FWD_DEFINED__ */


#ifndef __IActiveScriptStats_FWD_DEFINED__
#define __IActiveScriptStats_FWD_DEFINED__
typedef interface IActiveScriptStats IActiveScriptStats;
#endif 	/* __IActiveScriptStats_FWD_DEFINED__ */


#ifndef __IActiveScriptProperty_FWD_DEFINED__
#define __IActiveScriptProperty_FWD_DEFINED__
typedef interface IActiveScriptProperty IActiveScriptProperty;
#endif 	/* __IActiveScriptProperty_FWD_DEFINED__ */


#ifndef __ITridentEventSink_FWD_DEFINED__
#define __ITridentEventSink_FWD_DEFINED__
typedef interface ITridentEventSink ITridentEventSink;
#endif 	/* __ITridentEventSink_FWD_DEFINED__ */


#ifndef __IActiveScriptGarbageCollector_FWD_DEFINED__
#define __IActiveScriptGarbageCollector_FWD_DEFINED__
typedef interface IActiveScriptGarbageCollector IActiveScriptGarbageCollector;
#endif 	/* __IActiveScriptGarbageCollector_FWD_DEFINED__ */


#ifndef __IActiveScriptSIPInfo_FWD_DEFINED__
#define __IActiveScriptSIPInfo_FWD_DEFINED__
typedef interface IActiveScriptSIPInfo IActiveScriptSIPInfo;
#endif 	/* __IActiveScriptSIPInfo_FWD_DEFINED__ */


#ifndef __IActiveScriptSiteTraceInfo_FWD_DEFINED__
#define __IActiveScriptSiteTraceInfo_FWD_DEFINED__
typedef interface IActiveScriptSiteTraceInfo IActiveScriptSiteTraceInfo;
#endif 	/* __IActiveScriptSiteTraceInfo_FWD_DEFINED__ */


#ifndef __IActiveScriptTraceInfo_FWD_DEFINED__
#define __IActiveScriptTraceInfo_FWD_DEFINED__
typedef interface IActiveScriptTraceInfo IActiveScriptTraceInfo;
#endif 	/* __IActiveScriptTraceInfo_FWD_DEFINED__ */


#ifndef __IActiveScriptStringCompare_FWD_DEFINED__
#define __IActiveScriptStringCompare_FWD_DEFINED__
typedef interface IActiveScriptStringCompare IActiveScriptStringCompare;
#endif 	/* __IActiveScriptStringCompare_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_activscp_0000_0000 */
/* [local] */ 

//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//=--------------------------------------------------------------------------=
// ActivScp.h
//
#pragma comment(lib,"uuid.lib")
//
// Declarations for ActiveX Scripting host applications and script engines.
//

#ifndef __ActivScp_h
#define __ActivScp_h

/* GUIDs
 ********/

#ifndef _NO_SCRIPT_GUIDS
// {F0B7A1A1-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScript, 0xf0b7a1a1, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A2-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptParse, 0xf0b7a1a2, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {F0B7A1A3-9847-11cf-8F20-00805F2CD064}
DEFINE_GUID(CATID_ActiveScriptEncode, 0xf0b7a1a3, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE1-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScript, 0xbb1a2ae1, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BB1A2AE2-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptParse32, 0xbb1a2ae2, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
// {C7EF7658-E1EE-480E-97EA-D52CB4D76D17}
DEFINE_GUID(IID_IActiveScriptParse64, 0xc7ef7658, 0xe1ee, 0x480e, 0x97, 0xea, 0xd5, 0x2c, 0xb4, 0xd7, 0x6d, 0x17);

// {BB1A2AE3-A4F9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptEncode, 0xbb1a2ae3, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {BEE9B76E-CFE3-11d1-B747-00C04FC2B085}
DEFINE_GUID(IID_IActiveScriptHostEncode, 0xbee9b76e, 0xcfe3, 0x11d1, 0xb7, 0x47, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

// {1CFF0050-6FDD-11d0-9328-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedureOld32, 0x1cff0050, 0x6fdd, 0x11d0, 0x93, 0x28, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
// {21F57128-08C9-4638-BA12-22D15D88DC5C}
DEFINE_GUID(IID_IActiveScriptParseProcedureOld64, 0x21f57128, 0x08c9, 0x4638, 0xba, 0x12, 0x22, 0xd1, 0x5d, 0x88, 0xdc, 0x5c);

// {AA5B6A80-B834-11d0-932F-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptParseProcedure32, 0xaa5b6a80, 0xb834, 0x11d0, 0x93, 0x2f, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
// {C64713B6-E029-4CC5-9200-438B72890B6A}
DEFINE_GUID(IID_IActiveScriptParseProcedure64, 0xc64713b6, 0xe029, 0x4cc5, 0x92, 0x00, 0x43, 0x8b, 0x72, 0x89, 0x0b, 0x6a);

// {71EE5B20-FB04-11d1-B3A8-00A0C911E8B2}
DEFINE_GUID(IID_IActiveScriptParseProcedure2_32, 0x71ee5b20, 0xfb04, 0x11d1, 0xb3, 0xa8, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);
// {FE7C4271-210C-448D-9F54-76DAB7047B28}
DEFINE_GUID(IID_IActiveScriptParseProcedure2_64, 0xfe7c4271, 0x210c, 0x448d, 0x9f, 0x54, 0x76, 0xda, 0xb7, 0x04, 0x7b, 0x28);

// {DB01A1E3-A42B-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSite, 0xdb01a1e3, 0xa42b, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {4B7272AE-1955-4bfe-98B0-780621888569}
DEFINE_GUID(IID_IActiveScriptSiteTraceInfo, 0x4b7272ae, 0x1955, 0x4bfe, 0x98, 0xb0, 0x78, 0x6, 0x21, 0x88, 0x85, 0x69);

// {D10F6761-83E9-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptSiteWindow, 0xd10f6761, 0x83e9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);

// {539698A0-CDCA-11CF-A5EB-00AA0047A063}
DEFINE_GUID(IID_IActiveScriptSiteInterruptPoll, 0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);

// {AEDAE97E-D7EE-4796-B960-7F092AE844AB}
DEFINE_GUID(IID_IActiveScriptSiteUIControl, 0xaedae97e, 0xd7ee, 0x4796, 0xb9, 0x60, 0x7f, 0x9, 0x2a, 0xe8, 0x44, 0xab);

// {EAE1BA61-A4ED-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IActiveScriptError,   0xeae1ba61, 0xa4ed, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
// {B21FB2A1-5B8F-4963-8C21-21450F84ED7F}
DEFINE_GUID(IID_IActiveScriptError64, 0xb21fb2a1, 0x5b8f, 0x4963, 0x8c, 0x21, 0x21, 0x45, 0x0f, 0x84, 0xed, 0x7f);

// {63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(IID_IBindEventHandler, 0x63cdbcb0, 0xc1b1, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);

// {B8DA6310-E19B-11d0-933C-00A0C90DCAA9}
DEFINE_GUID(IID_IActiveScriptStats, 0xb8da6310, 0xe19b, 0x11d0, 0x93, 0x3c, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);

// {4954E0D0-FBC7-11D1-8410-006008C3FBFC}
DEFINE_GUID(IID_IActiveScriptProperty, 0x4954E0D0, 0xFBC7, 0x11D1, 0x84, 0x10, 0x00, 0x60, 0x08, 0xC3, 0xFB, 0xFC);

// {1DC9CA50-06EF-11d2-8415-006008C3FBFC}
DEFINE_GUID(IID_ITridentEventSink, 0x1dc9ca50, 0x6ef, 0x11d2, 0x84, 0x15, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc);

// {6AA2C4A0-2B53-11d4-A2A0-00104BD35090}
DEFINE_GUID(IID_IActiveScriptGarbageCollector, 0x6aa2c4a0, 0x2b53, 0x11d4, 0xa2, 0xa0, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {764651D0-38DE-11d4-A2A3-00104BD35090}
DEFINE_GUID(IID_IActiveScriptSIPInfo, 0x764651d0, 0x38de, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {C35456E7-BEBF-4a1b-86A9-24D56BE8B369}
DEFINE_GUID(IID_IActiveScriptTraceInfo, 0xC35456E7, 0xBEBF, 0x4a1b, 0x86, 0xA9, 0x24, 0xD5, 0x6B, 0xE8, 0xB3, 0x69);

// {1629F04E-2799-4db5-8FE5-ACE10F17EBAB}
DEFINE_GUID(OID_VBSSIP, 0x1629f04e, 0x2799, 0x4db5, 0x8f, 0xe5, 0xac, 0xe1, 0x0f, 0x17, 0xeb, 0xab);

// {06C9E010-38CE-11d4-A2A3-00104BD35090}
DEFINE_GUID(OID_JSSIP,  0x6c9e010, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {1A610570-38CE-11d4-A2A3-00104BD35090}
DEFINE_GUID(OID_WSFSIP, 0x1a610570, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);

// {58562769-ED52-42f7-8403-4963514E1F11}
DEFINE_GUID(IID_IActiveScriptStringCompare, 0x58562769, 0xED52, 0x42f7, 0x84, 0x03, 0x49, 0x63, 0x51, 0x4E, 0x1F, 0x11);

#endif // _NO_SCRIPT_GUIDS

// Constants used by ActiveX Scripting:
//

/* IActiveScript::AddNamedItem() input flags */

#define SCRIPTITEM_ISVISIBLE            0x00000002
#define SCRIPTITEM_ISSOURCE             0x00000004
#define SCRIPTITEM_GLOBALMEMBERS        0x00000008
#define SCRIPTITEM_ISPERSISTENT         0x00000040
#define SCRIPTITEM_CODEONLY             0x00000200
#define SCRIPTITEM_NOCODE               0x00000400

#define SCRIPTITEM_ALL_FLAGS            (SCRIPTITEM_ISSOURCE | \
                                         SCRIPTITEM_ISVISIBLE | \
                                         SCRIPTITEM_ISPERSISTENT | \
                                         SCRIPTITEM_GLOBALMEMBERS | \
                                         SCRIPTITEM_NOCODE | \
                                         SCRIPTITEM_CODEONLY)

/* IActiveScript::AddTypeLib() input flags */

#define SCRIPTTYPELIB_ISCONTROL         0x00000010
#define SCRIPTTYPELIB_ISPERSISTENT      0x00000040
#define SCRIPTTYPELIB_ALL_FLAGS         (SCRIPTTYPELIB_ISCONTROL | SCRIPTTYPELIB_ISPERSISTENT)

/* IActiveScriptParse::AddScriptlet() and IActiveScriptParse::ParseScriptText() input flags */

#define SCRIPTTEXT_DELAYEXECUTION       0x00000001
#define SCRIPTTEXT_ISVISIBLE            0x00000002
#define SCRIPTTEXT_ISEXPRESSION         0x00000020
#define SCRIPTTEXT_ISPERSISTENT         0x00000040
#define SCRIPTTEXT_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTTEXT_ALL_FLAGS            (SCRIPTTEXT_DELAYEXECUTION | \
                                         SCRIPTTEXT_ISVISIBLE | \
                                         SCRIPTTEXT_ISEXPRESSION | \
                                         SCRIPTTEXT_ISPERSISTENT | \
                                         SCRIPTTEXT_HOSTMANAGESSOURCE)

/* IActiveScriptParseProcedure::ParseProcedureText() input flags */

#define SCRIPTPROC_ISEXPRESSION         0x00000020
#define SCRIPTPROC_HOSTMANAGESSOURCE    0x00000080
#define SCRIPTPROC_IMPLICIT_THIS        0x00000100
#define SCRIPTPROC_IMPLICIT_PARENTS     0x00000200
#define SCRIPTPROC_ALL_FLAGS            (SCRIPTPROC_HOSTMANAGESSOURCE | \
                                         SCRIPTPROC_ISEXPRESSION | \
                                         SCRIPTPROC_IMPLICIT_THIS | \
                                         SCRIPTPROC_IMPLICIT_PARENTS)

/* IActiveScriptSite::GetItemInfo() input flags */

#define SCRIPTINFO_IUNKNOWN             0x00000001
#define SCRIPTINFO_ITYPEINFO            0x00000002
#define SCRIPTINFO_ALL_FLAGS            (SCRIPTINFO_IUNKNOWN | \
                                         SCRIPTINFO_ITYPEINFO)

/* IActiveScript::Interrupt() Flags */

#define SCRIPTINTERRUPT_DEBUG           0x00000001
#define SCRIPTINTERRUPT_RAISEEXCEPTION  0x00000002
#define SCRIPTINTERRUPT_ALL_FLAGS       (SCRIPTINTERRUPT_DEBUG | \
                                         SCRIPTINTERRUPT_RAISEEXCEPTION)

/* IActiveScriptStats::GetStat() values */

#define SCRIPTSTAT_STATEMENT_COUNT       1
#define SCRIPTSTAT_INSTRUCTION_COUNT     2
#define SCRIPTSTAT_INTSTRUCTION_TIME     3
#define SCRIPTSTAT_TOTAL_TIME            4

/* IActiveScriptEncode::AddSection() input flags */

#define SCRIPT_ENCODE_SECTION         0x00000001

#define SCRIPT_ENCODE_DEFAULT_LANGUAGE        0x00000001
#define SCRIPT_ENCODE_NO_ASP_LANGUAGE         0x00000002

/* Properties for IActiveScriptProperty */
#define SCRIPTPROP_NAME                     0x00000000
#define SCRIPTPROP_MAJORVERSION             0x00000001
#define SCRIPTPROP_MINORVERSION             0x00000002
#define SCRIPTPROP_BUILDNUMBER              0x00000003

#define SCRIPTPROP_DELAYEDEVENTSINKING      0x00001000
#define SCRIPTPROP_CATCHEXCEPTION           0x00001001
#define SCRIPTPROP_CONVERSIONLCID           0x00001002
#define SCRIPTPROP_HOSTSTACKREQUIRED        0x00001003

#define SCRIPTPROP_DEBUGGER                 0x00001100
#define SCRIPTPROP_JITDEBUG                 0x00001101

#define SCRIPTPROP_GCCONTROLSOFTCLOSE       0x00002000

#define SCRIPTPROP_INTEGERMODE              0x00003000
#define SCRIPTPROP_STRINGCOMPAREINSTANCE    0x00003001

// These properties are defined and available, but are not
// officially supported.
#define SCRIPTPROP_HACK_FIBERSUPPORT        0x70000000
#define SCRIPTPROP_HACK_TRIDENTEVENTSINK    0x70000001
#define SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION  0x70000002

typedef 
enum tagSCRIPTSTATE
    {	SCRIPTSTATE_UNINITIALIZED	= 0,
	SCRIPTSTATE_INITIALIZED	= 5,
	SCRIPTSTATE_STARTED	= 1,
	SCRIPTSTATE_CONNECTED	= 2,
	SCRIPTSTATE_DISCONNECTED	= 3,
	SCRIPTSTATE_CLOSED	= 4
    } 	SCRIPTSTATE;

typedef 
enum tagSCRIPTTRACEINFO
    {	SCRIPTTRACEINFO_SCRIPTSTART	= 0,
	SCRIPTTRACEINFO_SCRIPTEND	= 1,
	SCRIPTTRACEINFO_COMCALLSTART	= 2,
	SCRIPTTRACEINFO_COMCALLEND	= 3,
	SCRIPTTRACEINFO_CREATEOBJSTART	= 4,
	SCRIPTTRACEINFO_CREATEOBJEND	= 5,
	SCRIPTTRACEINFO_GETOBJSTART	= 6,
	SCRIPTTRACEINFO_GETOBJEND	= 7
    } 	SCRIPTTRACEINFO;


/* script thread state values */

typedef 
enum tagSCRIPTTHREADSTATE
    {	SCRIPTTHREADSTATE_NOTINSCRIPT	= 0,
	SCRIPTTHREADSTATE_RUNNING	= 1
    } 	SCRIPTTHREADSTATE;


/* IActiveScriptCollectGarbage constants */

typedef 
enum tagSCRIPTGCTYPE
    {	SCRIPTGCTYPE_NORMAL	= 0,
	SCRIPTGCTYPE_EXHAUSTIVE	= 1
    } 	SCRIPTGCTYPE;


/* IActiveScriptSiteUIControl constants*/

typedef 
enum tagSCRIPTUICITEM
    {	SCRIPTUICITEM_INPUTBOX	= 1,
	SCRIPTUICITEM_MSGBOX	= 2
    } 	SCRIPTUICITEM;


typedef 
enum tagSCRIPTUICHANDLING
    {	SCRIPTUICHANDLING_ALLOW	= 0,
	SCRIPTUICHANDLING_NOUIERROR	= 1,
	SCRIPTUICHANDLING_NOUIDEFAULT	= 2
    } 	SCRIPTUICHANDLING;


/* Thread IDs */

typedef DWORD SCRIPTTHREADID;


#define SCRIPTTHREADID_CURRENT  ((SCRIPTTHREADID)-1)
#define SCRIPTTHREADID_BASE     ((SCRIPTTHREADID)-2)
#define SCRIPTTHREADID_ALL      ((SCRIPTTHREADID)-3)

/* Structures */

/* Interfaces
 *************/




























extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0000_v0_0_s_ifspec;

#ifndef __IActiveScriptSite_INTERFACE_DEFINED__
#define __IActiveScriptSite_INTERFACE_DEFINED__

/* interface IActiveScriptSite */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB01A1E3-A42B-11cf-8F20-00805F2CD064")
    IActiveScriptSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLCID( 
            /* [out] */ LCID *plcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown **ppiunkItem,
            /* [out] */ ITypeInfo **ppti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocVersionString( 
            /* [out] */ BSTR *pbstrVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate( 
            /* [in] */ const VARIANT *pvarResult,
            /* [in] */ const EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
            /* [in] */ SCRIPTSTATE ssScriptState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnScriptError( 
            /* [in] */ IActiveScriptError *pscripterror) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLCID )( 
            IActiveScriptSite * This,
            /* [out] */ LCID *plcid);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemInfo )( 
            IActiveScriptSite * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwReturnMask,
            /* [out] */ IUnknown **ppiunkItem,
            /* [out] */ ITypeInfo **ppti);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocVersionString )( 
            IActiveScriptSite * This,
            /* [out] */ BSTR *pbstrVersion);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptTerminate )( 
            IActiveScriptSite * This,
            /* [in] */ const VARIANT *pvarResult,
            /* [in] */ const EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *OnStateChange )( 
            IActiveScriptSite * This,
            /* [in] */ SCRIPTSTATE ssScriptState);
        
        HRESULT ( STDMETHODCALLTYPE *OnScriptError )( 
            IActiveScriptSite * This,
            /* [in] */ IActiveScriptError *pscripterror);
        
        HRESULT ( STDMETHODCALLTYPE *OnEnterScript )( 
            IActiveScriptSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLeaveScript )( 
            IActiveScriptSite * This);
        
        END_INTERFACE
    } IActiveScriptSiteVtbl;

    interface IActiveScriptSite
    {
        CONST_VTBL struct IActiveScriptSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSite_GetLCID(This,plcid)	\
    ( (This)->lpVtbl -> GetLCID(This,plcid) ) 

#define IActiveScriptSite_GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti)	\
    ( (This)->lpVtbl -> GetItemInfo(This,pstrName,dwReturnMask,ppiunkItem,ppti) ) 

#define IActiveScriptSite_GetDocVersionString(This,pbstrVersion)	\
    ( (This)->lpVtbl -> GetDocVersionString(This,pbstrVersion) ) 

#define IActiveScriptSite_OnScriptTerminate(This,pvarResult,pexcepinfo)	\
    ( (This)->lpVtbl -> OnScriptTerminate(This,pvarResult,pexcepinfo) ) 

#define IActiveScriptSite_OnStateChange(This,ssScriptState)	\
    ( (This)->lpVtbl -> OnStateChange(This,ssScriptState) ) 

#define IActiveScriptSite_OnScriptError(This,pscripterror)	\
    ( (This)->lpVtbl -> OnScriptError(This,pscripterror) ) 

#define IActiveScriptSite_OnEnterScript(This)	\
    ( (This)->lpVtbl -> OnEnterScript(This) ) 

#define IActiveScriptSite_OnLeaveScript(This)	\
    ( (This)->lpVtbl -> OnLeaveScript(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSite_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptError_INTERFACE_DEFINED__
#define __IActiveScriptError_INTERFACE_DEFINED__

/* interface IActiveScriptError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAE1BA61-A4ED-11cf-8F20-00805F2CD064")
    IActiveScriptError : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetExceptionInfo( 
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition( 
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceLineText( 
            /* [out] */ BSTR *pbstrSourceLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptError * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptError * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptError * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExceptionInfo )( 
            IActiveScriptError * This,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IActiveScriptError * This,
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLineText )( 
            IActiveScriptError * This,
            /* [out] */ BSTR *pbstrSourceLine);
        
        END_INTERFACE
    } IActiveScriptErrorVtbl;

    interface IActiveScriptError
    {
        CONST_VTBL struct IActiveScriptErrorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptError_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptError_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptError_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptError_GetExceptionInfo(This,pexcepinfo)	\
    ( (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo) ) 

#define IActiveScriptError_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition) ) 

#define IActiveScriptError_GetSourceLineText(This,pbstrSourceLine)	\
    ( (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_RemoteGetExceptionInfo_Proxy( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);


void __RPC_STUB IActiveScriptError_RemoteGetExceptionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveScriptError_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptError64_INTERFACE_DEFINED__
#define __IActiveScriptError64_INTERFACE_DEFINED__

/* interface IActiveScriptError64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptError64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B21FB2A1-5B8F-4963-8C21-21450F84ED7F")
    IActiveScriptError64 : public IActiveScriptError
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourcePosition64( 
            /* [out] */ DWORDLONG *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptError64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptError64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptError64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptError64 * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetExceptionInfo )( 
            IActiveScriptError64 * This,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition )( 
            IActiveScriptError64 * This,
            /* [out] */ DWORD *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLineText )( 
            IActiveScriptError64 * This,
            /* [out] */ BSTR *pbstrSourceLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourcePosition64 )( 
            IActiveScriptError64 * This,
            /* [out] */ DWORDLONG *pdwSourceContext,
            /* [out] */ ULONG *pulLineNumber,
            /* [out] */ LONG *plCharacterPosition);
        
        END_INTERFACE
    } IActiveScriptError64Vtbl;

    interface IActiveScriptError64
    {
        CONST_VTBL struct IActiveScriptError64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptError64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptError64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptError64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptError64_GetExceptionInfo(This,pexcepinfo)	\
    ( (This)->lpVtbl -> GetExceptionInfo(This,pexcepinfo) ) 

#define IActiveScriptError64_GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    ( (This)->lpVtbl -> GetSourcePosition(This,pdwSourceContext,pulLineNumber,plCharacterPosition) ) 

#define IActiveScriptError64_GetSourceLineText(This,pbstrSourceLine)	\
    ( (This)->lpVtbl -> GetSourceLineText(This,pbstrSourceLine) ) 


#define IActiveScriptError64_GetSourcePosition64(This,pdwSourceContext,pulLineNumber,plCharacterPosition)	\
    ( (This)->lpVtbl -> GetSourcePosition64(This,pdwSourceContext,pulLineNumber,plCharacterPosition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptError64_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteWindow_INTERFACE_DEFINED__
#define __IActiveScriptSiteWindow_INTERFACE_DEFINED__

/* interface IActiveScriptSiteWindow */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D10F6761-83E9-11cf-8F20-00805F2CD064")
    IActiveScriptSiteWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindow( 
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindow )( 
            IActiveScriptSiteWindow * This,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IActiveScriptSiteWindow * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IActiveScriptSiteWindowVtbl;

    interface IActiveScriptSiteWindow
    {
        CONST_VTBL struct IActiveScriptSiteWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteWindow_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteWindow_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteWindow_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteWindow_GetWindow(This,phwnd)	\
    ( (This)->lpVtbl -> GetWindow(This,phwnd) ) 

#define IActiveScriptSiteWindow_EnableModeless(This,fEnable)	\
    ( (This)->lpVtbl -> EnableModeless(This,fEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteWindow_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteUIControl_INTERFACE_DEFINED__
#define __IActiveScriptSiteUIControl_INTERFACE_DEFINED__

/* interface IActiveScriptSiteUIControl */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteUIControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AEDAE97E-D7EE-4796-B960-7F092AE844AB")
    IActiveScriptSiteUIControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUIBehavior( 
            /* [in] */ SCRIPTUICITEM UicItem,
            /* [out] */ SCRIPTUICHANDLING *pUicHandling) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteUIControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteUIControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteUIControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteUIControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIBehavior )( 
            IActiveScriptSiteUIControl * This,
            /* [in] */ SCRIPTUICITEM UicItem,
            /* [out] */ SCRIPTUICHANDLING *pUicHandling);
        
        END_INTERFACE
    } IActiveScriptSiteUIControlVtbl;

    interface IActiveScriptSiteUIControl
    {
        CONST_VTBL struct IActiveScriptSiteUIControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteUIControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteUIControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteUIControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteUIControl_GetUIBehavior(This,UicItem,pUicHandling)	\
    ( (This)->lpVtbl -> GetUIBehavior(This,UicItem,pUicHandling) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteUIControl_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__
#define __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__

/* interface IActiveScriptSiteInterruptPoll */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteInterruptPoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("539698A0-CDCA-11CF-A5EB-00AA0047A063")
    IActiveScriptSiteInterruptPoll : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryContinue( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteInterruptPollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteInterruptPoll * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteInterruptPoll * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteInterruptPoll * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            IActiveScriptSiteInterruptPoll * This);
        
        END_INTERFACE
    } IActiveScriptSiteInterruptPollVtbl;

    interface IActiveScriptSiteInterruptPoll
    {
        CONST_VTBL struct IActiveScriptSiteInterruptPollVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteInterruptPoll_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteInterruptPoll_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteInterruptPoll_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteInterruptPoll_QueryContinue(This)	\
    ( (This)->lpVtbl -> QueryContinue(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteInterruptPoll_INTERFACE_DEFINED__ */


#ifndef __IActiveScript_INTERFACE_DEFINED__
#define __IActiveScript_INTERFACE_DEFINED__

/* interface IActiveScript */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScript;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE1-A4F9-11cf-8F20-00805F2CD064")
    IActiveScript : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScriptSite( 
            /* [in] */ IActiveScriptSite *pass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptSite( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScriptState( 
            /* [in] */ SCRIPTSTATE ss) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptState( 
            /* [out] */ SCRIPTSTATE *pssState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddNamedItem( 
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddTypeLib( 
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptDispatch( 
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch **ppdisp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentScriptThreadID( 
            /* [out] */ SCRIPTTHREADID *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadID( 
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID *pstidThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScriptThreadState( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE *pstsState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterruptScriptThread( 
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO *pexcepinfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IActiveScript **ppscript) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScript * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetScriptSite )( 
            IActiveScript * This,
            /* [in] */ IActiveScriptSite *pass);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptSite )( 
            IActiveScript * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetScriptState )( 
            IActiveScript * This,
            /* [in] */ SCRIPTSTATE ss);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptState )( 
            IActiveScript * This,
            /* [out] */ SCRIPTSTATE *pssState);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            IActiveScript * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddNamedItem )( 
            IActiveScript * This,
            /* [in] */ LPCOLESTR pstrName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddTypeLib )( 
            IActiveScript * This,
            /* [in] */ REFGUID rguidTypeLib,
            /* [in] */ DWORD dwMajor,
            /* [in] */ DWORD dwMinor,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptDispatch )( 
            IActiveScript * This,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [out] */ IDispatch **ppdisp);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentScriptThreadID )( 
            IActiveScript * This,
            /* [out] */ SCRIPTTHREADID *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptThreadID )( 
            IActiveScript * This,
            /* [in] */ DWORD dwWin32ThreadId,
            /* [out] */ SCRIPTTHREADID *pstidThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetScriptThreadState )( 
            IActiveScript * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [out] */ SCRIPTTHREADSTATE *pstsState);
        
        HRESULT ( STDMETHODCALLTYPE *InterruptScriptThread )( 
            IActiveScript * This,
            /* [in] */ SCRIPTTHREADID stidThread,
            /* [in] */ const EXCEPINFO *pexcepinfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IActiveScript * This,
            /* [out] */ IActiveScript **ppscript);
        
        END_INTERFACE
    } IActiveScriptVtbl;

    interface IActiveScript
    {
        CONST_VTBL struct IActiveScriptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScript_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScript_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScript_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScript_SetScriptSite(This,pass)	\
    ( (This)->lpVtbl -> SetScriptSite(This,pass) ) 

#define IActiveScript_GetScriptSite(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> GetScriptSite(This,riid,ppvObject) ) 

#define IActiveScript_SetScriptState(This,ss)	\
    ( (This)->lpVtbl -> SetScriptState(This,ss) ) 

#define IActiveScript_GetScriptState(This,pssState)	\
    ( (This)->lpVtbl -> GetScriptState(This,pssState) ) 

#define IActiveScript_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IActiveScript_AddNamedItem(This,pstrName,dwFlags)	\
    ( (This)->lpVtbl -> AddNamedItem(This,pstrName,dwFlags) ) 

#define IActiveScript_AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags)	\
    ( (This)->lpVtbl -> AddTypeLib(This,rguidTypeLib,dwMajor,dwMinor,dwFlags) ) 

#define IActiveScript_GetScriptDispatch(This,pstrItemName,ppdisp)	\
    ( (This)->lpVtbl -> GetScriptDispatch(This,pstrItemName,ppdisp) ) 

#define IActiveScript_GetCurrentScriptThreadID(This,pstidThread)	\
    ( (This)->lpVtbl -> GetCurrentScriptThreadID(This,pstidThread) ) 

#define IActiveScript_GetScriptThreadID(This,dwWin32ThreadId,pstidThread)	\
    ( (This)->lpVtbl -> GetScriptThreadID(This,dwWin32ThreadId,pstidThread) ) 

#define IActiveScript_GetScriptThreadState(This,stidThread,pstsState)	\
    ( (This)->lpVtbl -> GetScriptThreadState(This,stidThread,pstsState) ) 

#define IActiveScript_InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags)	\
    ( (This)->lpVtbl -> InterruptScriptThread(This,stidThread,pexcepinfo,dwFlags) ) 

#define IActiveScript_Clone(This,ppscript)	\
    ( (This)->lpVtbl -> Clone(This,ppscript) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScript_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParse32_INTERFACE_DEFINED__
#define __IActiveScriptParse32_INTERFACE_DEFINED__

/* interface IActiveScriptParse32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParse32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE2-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptParse32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParse32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParse32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParse32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParse32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IActiveScriptParse32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddScriptlet )( 
            IActiveScriptParse32 * This,
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *ParseScriptText )( 
            IActiveScriptParse32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        END_INTERFACE
    } IActiveScriptParse32Vtbl;

    interface IActiveScriptParse32
    {
        CONST_VTBL struct IActiveScriptParse32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParse32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParse32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParse32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParse32_InitNew(This)	\
    ( (This)->lpVtbl -> InitNew(This) ) 

#define IActiveScriptParse32_AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)	\
    ( (This)->lpVtbl -> AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo) ) 

#define IActiveScriptParse32_ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)	\
    ( (This)->lpVtbl -> ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParse32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParse64_INTERFACE_DEFINED__
#define __IActiveScriptParse64_INTERFACE_DEFINED__

/* interface IActiveScriptParse64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParse64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C7EF7658-E1EE-480E-97EA-D52CB4D76D17")
    IActiveScriptParse64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitNew( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddScriptlet( 
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseScriptText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParse64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParse64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParse64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParse64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitNew )( 
            IActiveScriptParse64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddScriptlet )( 
            IActiveScriptParse64 * This,
            /* [in] */ LPCOLESTR pstrDefaultName,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ LPCOLESTR pstrSubItemName,
            /* [in] */ LPCOLESTR pstrEventName,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BSTR *pbstrName,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        HRESULT ( STDMETHODCALLTYPE *ParseScriptText )( 
            IActiveScriptParse64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ VARIANT *pvarResult,
            /* [out] */ EXCEPINFO *pexcepinfo);
        
        END_INTERFACE
    } IActiveScriptParse64Vtbl;

    interface IActiveScriptParse64
    {
        CONST_VTBL struct IActiveScriptParse64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParse64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParse64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParse64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParse64_InitNew(This)	\
    ( (This)->lpVtbl -> InitNew(This) ) 

#define IActiveScriptParse64_AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo)	\
    ( (This)->lpVtbl -> AddScriptlet(This,pstrDefaultName,pstrCode,pstrItemName,pstrSubItemName,pstrEventName,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pbstrName,pexcepinfo) ) 

#define IActiveScriptParse64_ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo)	\
    ( (This)->lpVtbl -> ParseScriptText(This,pstrCode,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,pvarResult,pexcepinfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParse64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0000_0009 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParse     IActiveScriptParse64
#define IID_IActiveScriptParse IID_IActiveScriptParse64
#else
#define     IActiveScriptParse     IActiveScriptParse32
#define IID_IActiveScriptParse IID_IActiveScriptParse32
#endif
typedef IActiveScriptParse *PIActiveScriptParse;



extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0009_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedureOld32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedureOld32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CFF0050-6FDD-11d0-9328-00A0C90DCAA9")
    IActiveScriptParseProcedureOld32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureOld32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedureOld32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedureOld32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedureOld32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedureOld32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureOld32Vtbl;

    interface IActiveScriptParseProcedureOld32
    {
        CONST_VTBL struct IActiveScriptParseProcedureOld32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedureOld32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedureOld32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedureOld32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedureOld32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedureOld32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedureOld64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedureOld64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21F57128-08C9-4638-BA12-22D15D88DC5C")
    IActiveScriptParseProcedureOld64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedureOld64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedureOld64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedureOld64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedureOld64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedureOld64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedureOld64Vtbl;

    interface IActiveScriptParseProcedureOld64
    {
        CONST_VTBL struct IActiveScriptParseProcedureOld64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedureOld64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedureOld64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedureOld64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedureOld64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedureOld64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0000_0011 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedureOld     IActiveScriptParseProcedureOld64
#define IID_IActiveScriptParseProcedureOld IID_IActiveScriptParseProcedureOld64
#else
#define     IActiveScriptParseProcedureOld     IActiveScriptParseProcedureOld32
#define IID_IActiveScriptParseProcedureOld IID_IActiveScriptParseProcedureOld32
#endif
typedef IActiveScriptParseProcedureOld *PIActiveScriptParseProcedureOld;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0011_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedure32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA5B6A80-B834-11d0-932F-00A0C90DCAA9")
    IActiveScriptParseProcedure32 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure32Vtbl;

    interface IActiveScriptParseProcedure32
    {
        CONST_VTBL struct IActiveScriptParseProcedure32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedure32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedure32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedure32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C64713B6-E029-4CC5-9200-438B72890B6A")
    IActiveScriptParseProcedure64 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseProcedureText( 
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure64Vtbl;

    interface IActiveScriptParseProcedure64
    {
        CONST_VTBL struct IActiveScriptParseProcedure64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedure64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedure64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedure64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0000_0013 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedure     IActiveScriptParseProcedure64
#define IID_IActiveScriptParseProcedure IID_IActiveScriptParseProcedure64
#else
#define     IActiveScriptParseProcedure     IActiveScriptParseProcedure32
#define IID_IActiveScriptParseProcedure IID_IActiveScriptParseProcedure32
#endif
typedef IActiveScriptParseProcedure *PIActiveScriptParseProcedure;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0013_v0_0_s_ifspec;

#ifndef __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure2_32 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure2_32;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EE5B20-FB04-11d1-B3A8-00A0C911E8B2")
    IActiveScriptParseProcedure2_32 : public IActiveScriptParseProcedure32
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure2_32Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure2_32 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure2_32 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure2_32 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure2_32 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORD dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure2_32Vtbl;

    interface IActiveScriptParseProcedure2_32
    {
        CONST_VTBL struct IActiveScriptParseProcedure2_32Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure2_32_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedure2_32_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedure2_32_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedure2_32_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure2_32_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__
#define __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__

/* interface IActiveScriptParseProcedure2_64 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptParseProcedure2_64;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE7C4271-210C-448D-9F54-76DAB7047B28")
    IActiveScriptParseProcedure2_64 : public IActiveScriptParseProcedure64
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptParseProcedure2_64Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptParseProcedure2_64 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptParseProcedure2_64 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptParseProcedure2_64 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseProcedureText )( 
            IActiveScriptParseProcedure2_64 * This,
            /* [in] */ LPCOLESTR pstrCode,
            /* [in] */ LPCOLESTR pstrFormalParams,
            /* [in] */ LPCOLESTR pstrProcedureName,
            /* [in] */ LPCOLESTR pstrItemName,
            /* [in] */ IUnknown *punkContext,
            /* [in] */ LPCOLESTR pstrDelimiter,
            /* [in] */ DWORDLONG dwSourceContextCookie,
            /* [in] */ ULONG ulStartingLineNumber,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDispatch **ppdisp);
        
        END_INTERFACE
    } IActiveScriptParseProcedure2_64Vtbl;

    interface IActiveScriptParseProcedure2_64
    {
        CONST_VTBL struct IActiveScriptParseProcedure2_64Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptParseProcedure2_64_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptParseProcedure2_64_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptParseProcedure2_64_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptParseProcedure2_64_ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp)	\
    ( (This)->lpVtbl -> ParseProcedureText(This,pstrCode,pstrFormalParams,pstrProcedureName,pstrItemName,punkContext,pstrDelimiter,dwSourceContextCookie,ulStartingLineNumber,dwFlags,ppdisp) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptParseProcedure2_64_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0000_0015 */
/* [local] */ 

#ifdef _WIN64
#define     IActiveScriptParseProcedure2     IActiveScriptParseProcedure2_64
#define IID_IActiveScriptParseProcedure2 IID_IActiveScriptParseProcedure2_64
#else
#define     IActiveScriptParseProcedure2     IActiveScriptParseProcedure2_32
#define IID_IActiveScriptParseProcedure2 IID_IActiveScriptParseProcedure2_32
#endif
typedef IActiveScriptParseProcedure2 *PIActiveScriptParseProcedure2;


extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0015_v0_0_s_ifspec;

#ifndef __IActiveScriptEncode_INTERFACE_DEFINED__
#define __IActiveScriptEncode_INTERFACE_DEFINED__

/* interface IActiveScriptEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BB1A2AE3-A4F9-11cf-8F20-00805F2CD064")
    IActiveScriptEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeSection( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DecodeScript( 
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncodeProgId( 
            /* [out][in] */ BSTR *pbstrOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptEncode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptEncode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *EncodeSection )( 
            IActiveScriptEncode * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE *DecodeScript )( 
            IActiveScriptEncode * This,
            /* [in] */ LPCOLESTR pchIn,
            /* [in] */ DWORD cchIn,
            /* [out][in] */ LPOLESTR pchOut,
            /* [in] */ DWORD cchOut,
            /* [out][in] */ DWORD *pcchRet);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncodeProgId )( 
            IActiveScriptEncode * This,
            /* [out][in] */ BSTR *pbstrOut);
        
        END_INTERFACE
    } IActiveScriptEncodeVtbl;

    interface IActiveScriptEncode
    {
        CONST_VTBL struct IActiveScriptEncodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptEncode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptEncode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptEncode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptEncode_EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    ( (This)->lpVtbl -> EncodeSection(This,pchIn,cchIn,pchOut,cchOut,pcchRet) ) 

#define IActiveScriptEncode_DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet)	\
    ( (This)->lpVtbl -> DecodeScript(This,pchIn,cchIn,pchOut,cchOut,pcchRet) ) 

#define IActiveScriptEncode_GetEncodeProgId(This,pbstrOut)	\
    ( (This)->lpVtbl -> GetEncodeProgId(This,pbstrOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptEncode_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptHostEncode_INTERFACE_DEFINED__
#define __IActiveScriptHostEncode_INTERFACE_DEFINED__

/* interface IActiveScriptHostEncode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptHostEncode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEE9B76E-CFE3-11d1-B747-00C04FC2B085")
    IActiveScriptHostEncode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EncodeScriptHostFile( 
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptHostEncodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptHostEncode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptHostEncode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptHostEncode * This);
        
        HRESULT ( STDMETHODCALLTYPE *EncodeScriptHostFile )( 
            IActiveScriptHostEncode * This,
            /* [in] */ BSTR bstrInFile,
            /* [out][in] */ BSTR *pbstrOutFile,
            /* [in] */ unsigned long cFlags,
            /* [in] */ BSTR bstrDefaultLang);
        
        END_INTERFACE
    } IActiveScriptHostEncodeVtbl;

    interface IActiveScriptHostEncode
    {
        CONST_VTBL struct IActiveScriptHostEncodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptHostEncode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptHostEncode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptHostEncode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptHostEncode_EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang)	\
    ( (This)->lpVtbl -> EncodeScriptHostFile(This,bstrInFile,pbstrOutFile,cFlags,bstrDefaultLang) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptHostEncode_INTERFACE_DEFINED__ */


#ifndef __IBindEventHandler_INTERFACE_DEFINED__
#define __IBindEventHandler_INTERFACE_DEFINED__

/* interface IBindEventHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IBindEventHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63CDBCB0-C1B1-11d0-9336-00A0C90DCAA9")
    IBindEventHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindHandler( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch *pdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindEventHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBindEventHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBindEventHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBindEventHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindHandler )( 
            IBindEventHandler * This,
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ IDispatch *pdisp);
        
        END_INTERFACE
    } IBindEventHandlerVtbl;

    interface IBindEventHandler
    {
        CONST_VTBL struct IBindEventHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindEventHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBindEventHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBindEventHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBindEventHandler_BindHandler(This,pstrEvent,pdisp)	\
    ( (This)->lpVtbl -> BindHandler(This,pstrEvent,pdisp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBindEventHandler_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptStats_INTERFACE_DEFINED__
#define __IActiveScriptStats_INTERFACE_DEFINED__

/* interface IActiveScriptStats */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8DA6310-E19B-11d0-933C-00A0C90DCAA9")
    IActiveScriptStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStat( 
            /* [in] */ DWORD stid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatEx( 
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetStats( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStat )( 
            IActiveScriptStats * This,
            /* [in] */ DWORD stid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatEx )( 
            IActiveScriptStats * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ULONG *pluHi,
            /* [out] */ ULONG *pluLo);
        
        HRESULT ( STDMETHODCALLTYPE *ResetStats )( 
            IActiveScriptStats * This);
        
        END_INTERFACE
    } IActiveScriptStatsVtbl;

    interface IActiveScriptStats
    {
        CONST_VTBL struct IActiveScriptStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptStats_GetStat(This,stid,pluHi,pluLo)	\
    ( (This)->lpVtbl -> GetStat(This,stid,pluHi,pluLo) ) 

#define IActiveScriptStats_GetStatEx(This,guid,pluHi,pluLo)	\
    ( (This)->lpVtbl -> GetStatEx(This,guid,pluHi,pluLo) ) 

#define IActiveScriptStats_ResetStats(This)	\
    ( (This)->lpVtbl -> ResetStats(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptStats_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptProperty_INTERFACE_DEFINED__
#define __IActiveScriptProperty_INTERFACE_DEFINED__

/* interface IActiveScriptProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4954E0D0-FBC7-11D1-8410-006008C3FBFC")
    IActiveScriptProperty : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [in] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveScriptProperty * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IActiveScriptProperty * This,
            /* [in] */ DWORD dwProperty,
            /* [in] */ VARIANT *pvarIndex,
            /* [in] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } IActiveScriptPropertyVtbl;

    interface IActiveScriptProperty
    {
        CONST_VTBL struct IActiveScriptPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptProperty_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptProperty_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptProperty_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptProperty_GetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    ( (This)->lpVtbl -> GetProperty(This,dwProperty,pvarIndex,pvarValue) ) 

#define IActiveScriptProperty_SetProperty(This,dwProperty,pvarIndex,pvarValue)	\
    ( (This)->lpVtbl -> SetProperty(This,dwProperty,pvarIndex,pvarValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptProperty_INTERFACE_DEFINED__ */


#ifndef __ITridentEventSink_INTERFACE_DEFINED__
#define __ITridentEventSink_INTERFACE_DEFINED__

/* interface ITridentEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITridentEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1DC9CA50-06EF-11d2-8415-006008C3FBFC")
    ITridentEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FireEvent( 
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITridentEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITridentEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITridentEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITridentEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireEvent )( 
            ITridentEventSink * This,
            /* [in] */ LPCOLESTR pstrEvent,
            /* [in] */ DISPPARAMS *pdp,
            /* [out] */ VARIANT *pvarRes,
            /* [out] */ EXCEPINFO *pei);
        
        END_INTERFACE
    } ITridentEventSinkVtbl;

    interface ITridentEventSink
    {
        CONST_VTBL struct ITridentEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITridentEventSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITridentEventSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITridentEventSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITridentEventSink_FireEvent(This,pstrEvent,pdp,pvarRes,pei)	\
    ( (This)->lpVtbl -> FireEvent(This,pstrEvent,pdp,pvarRes,pei) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITridentEventSink_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptGarbageCollector_INTERFACE_DEFINED__
#define __IActiveScriptGarbageCollector_INTERFACE_DEFINED__

/* interface IActiveScriptGarbageCollector */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptGarbageCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AA2C4A0-2B53-11d4-A2A0-00104BD35090")
    IActiveScriptGarbageCollector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CollectGarbage( 
            SCRIPTGCTYPE scriptgctype) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptGarbageCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptGarbageCollector * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptGarbageCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptGarbageCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *CollectGarbage )( 
            IActiveScriptGarbageCollector * This,
            SCRIPTGCTYPE scriptgctype);
        
        END_INTERFACE
    } IActiveScriptGarbageCollectorVtbl;

    interface IActiveScriptGarbageCollector
    {
        CONST_VTBL struct IActiveScriptGarbageCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptGarbageCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptGarbageCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptGarbageCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptGarbageCollector_CollectGarbage(This,scriptgctype)	\
    ( (This)->lpVtbl -> CollectGarbage(This,scriptgctype) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptGarbageCollector_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSIPInfo_INTERFACE_DEFINED__
#define __IActiveScriptSIPInfo_INTERFACE_DEFINED__

/* interface IActiveScriptSIPInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSIPInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("764651D0-38DE-11d4-A2A3-00104BD35090")
    IActiveScriptSIPInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSIPOID( 
            /* [out] */ GUID *poid_sip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSIPInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSIPInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSIPInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSIPInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSIPOID )( 
            IActiveScriptSIPInfo * This,
            /* [out] */ GUID *poid_sip);
        
        END_INTERFACE
    } IActiveScriptSIPInfoVtbl;

    interface IActiveScriptSIPInfo
    {
        CONST_VTBL struct IActiveScriptSIPInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSIPInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSIPInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSIPInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSIPInfo_GetSIPOID(This,poid_sip)	\
    ( (This)->lpVtbl -> GetSIPOID(This,poid_sip) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSIPInfo_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptSiteTraceInfo_INTERFACE_DEFINED__
#define __IActiveScriptSiteTraceInfo_INTERFACE_DEFINED__

/* interface IActiveScriptSiteTraceInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptSiteTraceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4B7272AE-1955-4bfe-98B0-780621888569")
    IActiveScriptSiteTraceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendScriptTraceInfo( 
            /* [in] */ SCRIPTTRACEINFO stiEventType,
            /* [in] */ GUID guidContextID,
            /* [in] */ DWORD dwScriptContextCookie,
            /* [in] */ LONG lScriptStatementStart,
            /* [in] */ LONG lScriptStatementEnd,
            /* [in] */ DWORD64 dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptSiteTraceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptSiteTraceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptSiteTraceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptSiteTraceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendScriptTraceInfo )( 
            IActiveScriptSiteTraceInfo * This,
            /* [in] */ SCRIPTTRACEINFO stiEventType,
            /* [in] */ GUID guidContextID,
            /* [in] */ DWORD dwScriptContextCookie,
            /* [in] */ LONG lScriptStatementStart,
            /* [in] */ LONG lScriptStatementEnd,
            /* [in] */ DWORD64 dwReserved);
        
        END_INTERFACE
    } IActiveScriptSiteTraceInfoVtbl;

    interface IActiveScriptSiteTraceInfo
    {
        CONST_VTBL struct IActiveScriptSiteTraceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptSiteTraceInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptSiteTraceInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptSiteTraceInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptSiteTraceInfo_SendScriptTraceInfo(This,stiEventType,guidContextID,dwScriptContextCookie,lScriptStatementStart,lScriptStatementEnd,dwReserved)	\
    ( (This)->lpVtbl -> SendScriptTraceInfo(This,stiEventType,guidContextID,dwScriptContextCookie,lScriptStatementStart,lScriptStatementEnd,dwReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptSiteTraceInfo_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptTraceInfo_INTERFACE_DEFINED__
#define __IActiveScriptTraceInfo_INTERFACE_DEFINED__

/* interface IActiveScriptTraceInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptTraceInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C35456E7-BEBF-4a1b-86A9-24D56BE8B369")
    IActiveScriptTraceInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartScriptTracing( 
            /* [in] */ IActiveScriptSiteTraceInfo *pSiteTraceInfo,
            /* [in] */ GUID guidContextID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopScriptTracing( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptTraceInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptTraceInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptTraceInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptTraceInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartScriptTracing )( 
            IActiveScriptTraceInfo * This,
            /* [in] */ IActiveScriptSiteTraceInfo *pSiteTraceInfo,
            /* [in] */ GUID guidContextID);
        
        HRESULT ( STDMETHODCALLTYPE *StopScriptTracing )( 
            IActiveScriptTraceInfo * This);
        
        END_INTERFACE
    } IActiveScriptTraceInfoVtbl;

    interface IActiveScriptTraceInfo
    {
        CONST_VTBL struct IActiveScriptTraceInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptTraceInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptTraceInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptTraceInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptTraceInfo_StartScriptTracing(This,pSiteTraceInfo,guidContextID)	\
    ( (This)->lpVtbl -> StartScriptTracing(This,pSiteTraceInfo,guidContextID) ) 

#define IActiveScriptTraceInfo_StopScriptTracing(This)	\
    ( (This)->lpVtbl -> StopScriptTracing(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptTraceInfo_INTERFACE_DEFINED__ */


#ifndef __IActiveScriptStringCompare_INTERFACE_DEFINED__
#define __IActiveScriptStringCompare_INTERFACE_DEFINED__

/* interface IActiveScriptStringCompare */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveScriptStringCompare;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58562769-ED52-42f7-8403-4963514E1F11")
    IActiveScriptStringCompare : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StrComp( 
            /* [in] */ BSTR bszStr1,
            /* [in] */ BSTR bszStr2,
            /* [retval][out] */ LONG *iRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveScriptStringCompareVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveScriptStringCompare * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveScriptStringCompare * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveScriptStringCompare * This);
        
        HRESULT ( STDMETHODCALLTYPE *StrComp )( 
            IActiveScriptStringCompare * This,
            /* [in] */ BSTR bszStr1,
            /* [in] */ BSTR bszStr2,
            /* [retval][out] */ LONG *iRet);
        
        END_INTERFACE
    } IActiveScriptStringCompareVtbl;

    interface IActiveScriptStringCompare
    {
        CONST_VTBL struct IActiveScriptStringCompareVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveScriptStringCompare_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveScriptStringCompare_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveScriptStringCompare_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveScriptStringCompare_StrComp(This,bszStr1,bszStr2,iRet)	\
    ( (This)->lpVtbl -> StrComp(This,bszStr1,bszStr2,iRet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveScriptStringCompare_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_activscp_0000_0026 */
/* [local] */ 


#endif  // __ActivScp_h



extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0026_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_activscp_0000_0026_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_GetExceptionInfo_Proxy( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IActiveScriptError_GetExceptionInfo_Stub( 
    IActiveScriptError * This,
    /* [out] */ EXCEPINFO *pexcepinfo);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ad1ex.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* at Mon May 12 13:48:02 2008
 */
/* Compiler settings for ..\ad1ex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ad1ex_h__
#define __ad1ex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDebugApplicationEx_FWD_DEFINED__
#define __IDebugApplicationEx_FWD_DEFINED__
typedef interface IDebugApplicationEx IDebugApplicationEx;
#endif 	/* __IDebugApplicationEx_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEx_FWD_DEFINED__
#define __IRemoteDebugApplicationEx_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEx IRemoteDebugApplicationEx;
#endif 	/* __IRemoteDebugApplicationEx_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationEx7_FWD_DEFINED__
#define __IRemoteDebugApplicationEx7_FWD_DEFINED__
typedef interface IRemoteDebugApplicationEx7 IRemoteDebugApplicationEx7;
#endif 	/* __IRemoteDebugApplicationEx7_FWD_DEFINED__ */


#ifndef __IRemoteDebugApplicationThreadEx_FWD_DEFINED__
#define __IRemoteDebugApplicationThreadEx_FWD_DEFINED__
typedef interface IRemoteDebugApplicationThreadEx IRemoteDebugApplicationThreadEx;
#endif 	/* __IRemoteDebugApplicationThreadEx_FWD_DEFINED__ */


#ifndef __IDebugDocumentHelperEx_FWD_DEFINED__
#define __IDebugDocumentHelperEx_FWD_DEFINED__
typedef interface IDebugDocumentHelperEx IDebugDocumentHelperEx;
#endif 	/* __IDebugDocumentHelperEx_FWD_DEFINED__ */


#ifndef __IDebugHelperEx_FWD_DEFINED__
#define __IDebugHelperEx_FWD_DEFINED__
typedef interface IDebugHelperEx IDebugHelperEx;
#endif 	/* __IDebugHelperEx_FWD_DEFINED__ */


#ifndef __IDebugSetValueCallback_FWD_DEFINED__
#define __IDebugSetValueCallback_FWD_DEFINED__
typedef interface IDebugSetValueCallback IDebugSetValueCallback;
#endif 	/* __IDebugSetValueCallback_FWD_DEFINED__ */


#ifndef __ISetNextStatement_FWD_DEFINED__
#define __ISetNextStatement_FWD_DEFINED__
typedef interface ISetNextStatement ISetNextStatement;
#endif 	/* __ISetNextStatement_FWD_DEFINED__ */


#ifndef __IDebugSessionProviderEx_FWD_DEFINED__
#define __IDebugSessionProviderEx_FWD_DEFINED__
typedef interface IDebugSessionProviderEx IDebugSessionProviderEx;
#endif 	/* __IDebugSessionProviderEx_FWD_DEFINED__ */


/* header files for imported files */
#include "activdbg.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ad1ex_0000_0000 */
/* [local] */ 








DEFINE_GUID(IID_IDebugHelperExOld, 0xE0284F00, 0xEDA1, 0x11d0, 0xB4, 0x52, 0x00, 0xA0, 0x24, 0x4A, 0x1D, 0xD2);


extern RPC_IF_HANDLE __MIDL_itf_ad1ex_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ad1ex_0000_0000_v0_0_s_ifspec;

#ifndef __IDebugApplicationEx_INTERFACE_DEFINED__
#define __IDebugApplicationEx_INTERFACE_DEFINED__

/* interface IDebugApplicationEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugApplicationEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C00-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugApplicationEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onCallEnter( 
            /* [in] */ DWORD dwLim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onCallOut( 
            /* [in] */ DWORD dwLim,
            /* [in] */ DWORD dwAddrDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onCallReturn( 
            /* [in] */ DWORD dwLim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE onCallExit( 
            /* [in] */ DWORD dwLim,
            /* [in] */ DWORD dwAddrDest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugApplicationExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugApplicationEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugApplicationEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugApplicationEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *onCallEnter )( 
            IDebugApplicationEx * This,
            /* [in] */ DWORD dwLim);
        
        HRESULT ( STDMETHODCALLTYPE *onCallOut )( 
            IDebugApplicationEx * This,
            /* [in] */ DWORD dwLim,
            /* [in] */ DWORD dwAddrDest);
        
        HRESULT ( STDMETHODCALLTYPE *onCallReturn )( 
            IDebugApplicationEx * This,
            /* [in] */ DWORD dwLim);
        
        HRESULT ( STDMETHODCALLTYPE *onCallExit )( 
            IDebugApplicationEx * This,
            /* [in] */ DWORD dwLim,
            /* [in] */ DWORD dwAddrDest);
        
        END_INTERFACE
    } IDebugApplicationExVtbl;

    interface IDebugApplicationEx
    {
        CONST_VTBL struct IDebugApplicationExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugApplicationEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugApplicationEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugApplicationEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugApplicationEx_onCallEnter(This,dwLim)	\
    ( (This)->lpVtbl -> onCallEnter(This,dwLim) ) 

#define IDebugApplicationEx_onCallOut(This,dwLim,dwAddrDest)	\
    ( (This)->lpVtbl -> onCallOut(This,dwLim,dwAddrDest) ) 

#define IDebugApplicationEx_onCallReturn(This,dwLim)	\
    ( (This)->lpVtbl -> onCallReturn(This,dwLim) ) 

#define IDebugApplicationEx_onCallExit(This,dwLim,dwAddrDest)	\
    ( (This)->lpVtbl -> onCallExit(This,dwLim,dwAddrDest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugApplicationEx_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationEx_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationEx_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplicationEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C01-CB0C-11d0-B5C9-00A0244A0E7A")
    IRemoteDebugApplicationEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHostPid( 
            /* [out] */ DWORD *dwHostPid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostMachineName( 
            /* [out] */ BSTR *pbstrHostMachineName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ DWORD dwLangID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeBreak( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProxyBlanketAndAddRef( 
            /* [in] */ IUnknown *pUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseFromSetProxyBlanket( 
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplicationEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplicationEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplicationEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostPid )( 
            IRemoteDebugApplicationEx * This,
            /* [out] */ DWORD *dwHostPid);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostMachineName )( 
            IRemoteDebugApplicationEx * This,
            /* [out] */ BSTR *pbstrHostMachineName);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocale )( 
            IRemoteDebugApplicationEx * This,
            /* [in] */ DWORD dwLangID);
        
        HRESULT ( STDMETHODCALLTYPE *RevokeBreak )( 
            IRemoteDebugApplicationEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProxyBlanketAndAddRef )( 
            IRemoteDebugApplicationEx * This,
            /* [in] */ IUnknown *pUnk);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseFromSetProxyBlanket )( 
            IRemoteDebugApplicationEx * This,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IRemoteDebugApplicationExVtbl;

    interface IRemoteDebugApplicationEx
    {
        CONST_VTBL struct IRemoteDebugApplicationExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplicationEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplicationEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplicationEx_GetHostPid(This,dwHostPid)	\
    ( (This)->lpVtbl -> GetHostPid(This,dwHostPid) ) 

#define IRemoteDebugApplicationEx_GetHostMachineName(This,pbstrHostMachineName)	\
    ( (This)->lpVtbl -> GetHostMachineName(This,pbstrHostMachineName) ) 

#define IRemoteDebugApplicationEx_SetLocale(This,dwLangID)	\
    ( (This)->lpVtbl -> SetLocale(This,dwLangID) ) 

#define IRemoteDebugApplicationEx_RevokeBreak(This)	\
    ( (This)->lpVtbl -> RevokeBreak(This) ) 

#define IRemoteDebugApplicationEx_SetProxyBlanketAndAddRef(This,pUnk)	\
    ( (This)->lpVtbl -> SetProxyBlanketAndAddRef(This,pUnk) ) 

#define IRemoteDebugApplicationEx_ReleaseFromSetProxyBlanket(This,pUnk)	\
    ( (This)->lpVtbl -> ReleaseFromSetProxyBlanket(This,pUnk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplicationEx_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationEx7_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationEx7_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationEx7 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplicationEx7;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF718CD4-3738-498d-8E15-8029A11BDFA8")
    IRemoteDebugApplicationEx7 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetApartmentThreadId( 
            /* [out] */ DWORD *pdwAptThreadId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationEx7Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplicationEx7 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplicationEx7 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplicationEx7 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetApartmentThreadId )( 
            IRemoteDebugApplicationEx7 * This,
            /* [out] */ DWORD *pdwAptThreadId);
        
        END_INTERFACE
    } IRemoteDebugApplicationEx7Vtbl;

    interface IRemoteDebugApplicationEx7
    {
        CONST_VTBL struct IRemoteDebugApplicationEx7Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationEx7_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplicationEx7_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplicationEx7_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplicationEx7_GetApartmentThreadId(This,pdwAptThreadId)	\
    ( (This)->lpVtbl -> GetApartmentThreadId(This,pdwAptThreadId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplicationEx7_INTERFACE_DEFINED__ */


#ifndef __IRemoteDebugApplicationThreadEx_INTERFACE_DEFINED__
#define __IRemoteDebugApplicationThreadEx_INTERFACE_DEFINED__

/* interface IRemoteDebugApplicationThreadEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRemoteDebugApplicationThreadEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B9B32B0C-9147-11d1-94EA-00C04FA302A1")
    IRemoteDebugApplicationThreadEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumGlobalExpressionContexts( 
            /* [out] */ IEnumDebugExpressionContexts **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDebugApplicationThreadExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDebugApplicationThreadEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDebugApplicationThreadEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDebugApplicationThreadEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumGlobalExpressionContexts )( 
            IRemoteDebugApplicationThreadEx * This,
            /* [out] */ IEnumDebugExpressionContexts **ppEnum);
        
        END_INTERFACE
    } IRemoteDebugApplicationThreadExVtbl;

    interface IRemoteDebugApplicationThreadEx
    {
        CONST_VTBL struct IRemoteDebugApplicationThreadExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDebugApplicationThreadEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRemoteDebugApplicationThreadEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRemoteDebugApplicationThreadEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRemoteDebugApplicationThreadEx_EnumGlobalExpressionContexts(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumGlobalExpressionContexts(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRemoteDebugApplicationThreadEx_INTERFACE_DEFINED__ */


#ifndef __IDebugDocumentHelperEx_INTERFACE_DEFINED__
#define __IDebugDocumentHelperEx_INTERFACE_DEFINED__

/* interface IDebugDocumentHelperEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugDocumentHelperEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C02-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugDocumentHelperEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDocumentClassId( 
            /* [in] */ CLSID clsidDocument) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugDocumentHelperExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugDocumentHelperEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugDocumentHelperEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugDocumentHelperEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDocumentClassId )( 
            IDebugDocumentHelperEx * This,
            /* [in] */ CLSID clsidDocument);
        
        END_INTERFACE
    } IDebugDocumentHelperExVtbl;

    interface IDebugDocumentHelperEx
    {
        CONST_VTBL struct IDebugDocumentHelperExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugDocumentHelperEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugDocumentHelperEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugDocumentHelperEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugDocumentHelperEx_SetDocumentClassId(This,clsidDocument)	\
    ( (This)->lpVtbl -> SetDocumentClassId(This,clsidDocument) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugDocumentHelperEx_INTERFACE_DEFINED__ */


#ifndef __IDebugHelperEx_INTERFACE_DEFINED__
#define __IDebugHelperEx_INTERFACE_DEFINED__

/* interface IDebugHelperEx */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugHelperEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C08-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugHelperEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowserFromError( 
            /* [in] */ IActiveScriptError *pase,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [out] */ IDebugProperty **ppdp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateWriteablePropertyBrowser( 
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [in] */ IDebugSetValueCallback *pdsvcb,
            /* [out] */ IDebugProperty **ppdob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePropertyBrowserFromCodeContext( 
            /* [in] */ IDebugCodeContext *pdcc,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [out] */ IDebugProperty **ppdp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugHelperExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugHelperEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugHelperEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugHelperEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyBrowserFromError )( 
            IDebugHelperEx * This,
            /* [in] */ IActiveScriptError *pase,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [out] */ IDebugProperty **ppdp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateWriteablePropertyBrowser )( 
            IDebugHelperEx * This,
            /* [in] */ VARIANT *pvar,
            /* [in] */ LPCOLESTR bstrName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [in] */ IDebugFormatter *pdf,
            /* [in] */ IDebugSetValueCallback *pdsvcb,
            /* [out] */ IDebugProperty **ppdob);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePropertyBrowserFromCodeContext )( 
            IDebugHelperEx * This,
            /* [in] */ IDebugCodeContext *pdcc,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ IDebugApplicationThread *pdat,
            /* [out] */ IDebugProperty **ppdp);
        
        END_INTERFACE
    } IDebugHelperExVtbl;

    interface IDebugHelperEx
    {
        CONST_VTBL struct IDebugHelperExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugHelperEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugHelperEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugHelperEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugHelperEx_CreatePropertyBrowserFromError(This,pase,pszName,pdat,pdf,ppdp)	\
    ( (This)->lpVtbl -> CreatePropertyBrowserFromError(This,pase,pszName,pdat,pdf,ppdp) ) 

#define IDebugHelperEx_CreateWriteablePropertyBrowser(This,pvar,bstrName,pdat,pdf,pdsvcb,ppdob)	\
    ( (This)->lpVtbl -> CreateWriteablePropertyBrowser(This,pvar,bstrName,pdat,pdf,pdsvcb,ppdob) ) 

#define IDebugHelperEx_CreatePropertyBrowserFromCodeContext(This,pdcc,pszName,pdat,ppdp)	\
    ( (This)->lpVtbl -> CreatePropertyBrowserFromCodeContext(This,pdcc,pszName,pdat,ppdp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugHelperEx_INTERFACE_DEFINED__ */


#ifndef __IDebugSetValueCallback_INTERFACE_DEFINED__
#define __IDebugSetValueCallback_INTERFACE_DEFINED__

/* interface IDebugSetValueCallback */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugSetValueCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C06-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSetValueCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ VARIANT *pvarNode,
            /* [in] */ DISPID dispid,
            /* [in] */ ULONG cIndices,
            /* [size_is][in] */ LONG *rgIndices,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix,
            /* [out] */ BSTR *pbstrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugSetValueCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSetValueCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSetValueCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSetValueCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IDebugSetValueCallback * This,
            /* [in] */ VARIANT *pvarNode,
            /* [in] */ DISPID dispid,
            /* [in] */ ULONG cIndices,
            /* [size_is][in] */ LONG *rgIndices,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix,
            /* [out] */ BSTR *pbstrError);
        
        END_INTERFACE
    } IDebugSetValueCallbackVtbl;

    interface IDebugSetValueCallback
    {
        CONST_VTBL struct IDebugSetValueCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSetValueCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugSetValueCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugSetValueCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugSetValueCallback_SetValue(This,pvarNode,dispid,cIndices,rgIndices,pszValue,nRadix,pbstrError)	\
    ( (This)->lpVtbl -> SetValue(This,pvarNode,dispid,cIndices,rgIndices,pszValue,nRadix,pbstrError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSetValueCallback_INTERFACE_DEFINED__ */


#ifndef __ISetNextStatement_INTERFACE_DEFINED__
#define __ISetNextStatement_INTERFACE_DEFINED__

/* interface ISetNextStatement */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ISetNextStatement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C03-CB0C-11d0-B5C9-00A0244A0E7A")
    ISetNextStatement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CanSetNextStatement( 
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNextStatement( 
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISetNextStatementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISetNextStatement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISetNextStatement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISetNextStatement * This);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetNextStatement )( 
            ISetNextStatement * This,
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetNextStatement )( 
            ISetNextStatement * This,
            /* [in] */ IDebugStackFrame *pStackFrame,
            /* [in] */ IDebugCodeContext *pCodeContext);
        
        END_INTERFACE
    } ISetNextStatementVtbl;

    interface ISetNextStatement
    {
        CONST_VTBL struct ISetNextStatementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISetNextStatement_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISetNextStatement_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISetNextStatement_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISetNextStatement_CanSetNextStatement(This,pStackFrame,pCodeContext)	\
    ( (This)->lpVtbl -> CanSetNextStatement(This,pStackFrame,pCodeContext) ) 

#define ISetNextStatement_SetNextStatement(This,pStackFrame,pCodeContext)	\
    ( (This)->lpVtbl -> SetNextStatement(This,pStackFrame,pCodeContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISetNextStatement_INTERFACE_DEFINED__ */


#ifndef __IDebugSessionProviderEx_INTERFACE_DEFINED__
#define __IDebugSessionProviderEx_INTERFACE_DEFINED__

/* interface IDebugSessionProviderEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDebugSessionProviderEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C09-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugSessionProviderEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartDebugSession( 
            /* [in] */ IRemoteDebugApplication *pda,
            /* [in] */ BOOL fQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanJITDebug( 
            /* [in] */ DWORD pid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugSessionProviderExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebugSessionProviderEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebugSessionProviderEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebugSessionProviderEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartDebugSession )( 
            IDebugSessionProviderEx * This,
            /* [in] */ IRemoteDebugApplication *pda,
            /* [in] */ BOOL fQuery);
        
        HRESULT ( STDMETHODCALLTYPE *CanJITDebug )( 
            IDebugSessionProviderEx * This,
            /* [in] */ DWORD pid);
        
        END_INTERFACE
    } IDebugSessionProviderExVtbl;

    interface IDebugSessionProviderEx
    {
        CONST_VTBL struct IDebugSessionProviderExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugSessionProviderEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDebugSessionProviderEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDebugSessionProviderEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDebugSessionProviderEx_StartDebugSession(This,pda,fQuery)	\
    ( (This)->lpVtbl -> StartDebugSession(This,pda,fQuery) ) 

#define IDebugSessionProviderEx_CanJITDebug(This,pid)	\
    ( (This)->lpVtbl -> CanJITDebug(This,pid) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugSessionProviderEx_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\af_irda.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:

af_irda.h

Abstract:

Support for the address family AF_IRDA for use with winsock.

Notes:

//
// Winsock1.1, IrDA1.1, WindowsNT5.0, Windows98 and WindowsCE.
// Define one of _WIN32_WINNT, _WIN32_WINDOWS, _WIN32_WCE.
//

--*/

// @CESYSGEN IF CE_MODULES_WINSOCK

#ifndef __AFIRDA__
#define __AFIRDA__

#include <winsock.h>

#ifndef _WINSOCKAPI_
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;
#endif

#define WINDOWS_AF_IRDA         26
#define WINDOWS_PF_IRDA         WINDOWS_AF_IRDA

#define WCE_AF_IRDA             22
#define WCE_PF_IRDA             WCE_AF_IRDA


#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
#define AF_IRDA	                WINDOWS_AF_IRDA
#define IRDA_PROTO_SOCK_STREAM  1
#elif defined(_WIN32_WCE)
#ifndef AF_IRDA
#define AF_IRDA	                WCE_AF_IRDA
#endif
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

#define PF_IRDA                 AF_IRDA

                            // WINNT, WIN98, WINCE
#define SOL_IRLMP		        0x00FF                        
                        
#define IRLMP_ENUMDEVICES       0x00000010
#define IRLMP_IAS_SET           0x00000011
#define IRLMP_IAS_QUERY         0x00000012

                            // WINNT, WINCE
#define IRLMP_SEND_PDU_LEN      0x00000013
#define IRLMP_EXCLUSIVE_MODE    0x00000014
#define IRLMP_IRLPT_MODE        0x00000015
#define IRLMP_9WIRE_MODE        0x00000016

                            // WIN98
#define IRLMP_TINYTP_MODE       0x00000017
#define IRLMP_PARAMETERS		0x00000018
#define	IRLMP_DISCOVERY_MODE	0x00000019

                            // WINCE
#define IRLMP_SHARP_MODE        0x00000020
                            
                            // WINNT
#define IRLMP_LAZY_DISCOVERY    0x00000030

#define IAS_ATTRIB_NO_CLASS     0x00000010
#define IAS_ATTRIB_NO_ATTRIB    0x00000000
#define IAS_ATTRIB_INT          0x00000001
#define IAS_ATTRIB_OCTETSEQ     0x00000002
#define IAS_ATTRIB_STR          0x00000003

#define	IAS_MAX_USER_STRING		256
#define	IAS_MAX_OCTET_STRING	1024
#define IAS_MAX_CLASSNAME		64
#define IAS_MAX_ATTRIBNAME		256
                    
#define IRDA_MAX_SERVICE_NAME   25
#define IRDA_MAX_DEVICE_NAME    22

                            // WINNT, WIN98
enum 
{
  LM_HB_Extension =             128,    // Any hint byte
  
  LM_HB1_PnP =                  1,      // First hint byte
  LM_HB1_PDA_Palmtop =          2,
  LM_HB1_Computer =             4,
  LM_HB1_Printer =              8,
  LM_HB1_Modem =                16,
  LM_HB1_Fax =                  32,
  LM_HB1_LANAccess =            64,

  LM_HB2_Telephony =            1,      // Second hint byte
  LM_HB2_FileServer =           2,
};

#define LmCharSetASCII          0
#define LmCharSetISO_8859_1     1
#define LmCharSetISO_8859_2     2
#define LmCharSetISO_8859_3     3
#define LmCharSetISO_8859_4     4
#define LmCharSetISO_8859_5     5
#define LmCharSetISO_8859_6     6
#define LmCharSetISO_8859_7     7
#define LmCharSetISO_8859_8     8
#define LmCharSetISO_8859_9     9
#define LmCharSetUNICODE        0xff
    
                            // WIN98
typedef u_long LM_BAUD_RATE;

#define  LM_BAUD_1200           1200
#define  LM_BAUD_2400           2400
#define  LM_BAUD_9600           9600
#define  LM_BAUD_19200          19200
#define  LM_BAUD_38400          38400
#define  LM_BAUD_57600          57600
#define  LM_BAUD_115200         115200
#define  LM_BAUD_576K           576000
#define  LM_BAUD_1152K          1152000
#define  LM_BAUD_4M             4000000

typedef struct 
{
    u_long          nTXDataBytes;   // Max tx data bytes per packet 
    u_long          nRXDataBytes;   // Max rx data bytes per packet
    LM_BAUD_RATE    nBaudRate;      // Negotiated baud rate
    u_long          thresholdTime;  // Threshold (ms)
    u_long          discTime;       // Disconnect (ms)
    u_short         nMSLinkTurn;    // Link turn around (ms) 
    u_char          nTXPackets;     // Number packets in transmit window
    u_char          nRXPackets;     // Number packets in receive window
} LM_IRPARMS,*PLM_IRPARMS;

typedef struct _SOCKADDR_IRDA
{
	u_short irdaAddressFamily;
	u_char  irdaDeviceID[4];
	char	irdaServiceName[IRDA_MAX_SERVICE_NAME];
} SOCKADDR_IRDA, *PSOCKADDR_IRDA, FAR *LPSOCKADDR_IRDA;

typedef struct _WINDOWS_IRDA_DEVICE_INFO
{
	u_char  irdaDeviceID[4];
	char	irdaDeviceName[IRDA_MAX_DEVICE_NAME];
	u_char	irdaDeviceHints1;
	u_char  irdaDeviceHints2;
	u_char  irdaCharSet;
} WINDOWS_IRDA_DEVICE_INFO, *PWINDOWS_IRDA_DEVICE_INFO, FAR *LPWINDOWS_IRDA_DEVICE_INFO;

typedef struct _WCE_IRDA_DEVICE_INFO
{
	u_char  irdaDeviceID[4];
	char	irdaDeviceName[IRDA_MAX_DEVICE_NAME];
    u_char  Reserved[2];
} WCE_IRDA_DEVICE_INFO, *PWCE_IRDA_DEVICE_INFO;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_IRDA_DEVICE_INFO    IRDA_DEVICE_INFO, *PIRDA_DEVICE_INFO, FAR *LPIRDA_DEVICE_INFO;
#elif defined(_WIN32_WCE)
typedef WCE_IRDA_DEVICE_INFO        IRDA_DEVICE_INFO, *PIRDA_DEVICE_INFO;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

typedef struct _WINDOWS_DEVICELIST
{
	ULONG                       numDevice;
	WINDOWS_IRDA_DEVICE_INFO    Device[1];
} WINDOWS_DEVICELIST, *PWINDOWS_DEVICELIST, FAR *LPWINDOWS_DEVICELIST;

typedef struct _WCE_DEVICELIST
{
	ULONG                       numDevice;
	WCE_IRDA_DEVICE_INFO        Device[1];
} WCE_DEVICELIST, *PWCE_DEVICELIST;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_DEVICELIST      DEVICELIST, *PDEVICELIST, FAR *LPDEVICELIST;
#elif defined(_WIN32_WCE)
typedef WCE_DEVICELIST          DEVICELIST, *PDEVICELIST;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

typedef struct _WINDOWS_IAS_SET
{
    char    irdaClassName[IAS_MAX_CLASSNAME];
    char    irdaAttribName[IAS_MAX_ATTRIBNAME];
    u_long	irdaAttribType;
    union
    {
        LONG irdaAttribInt;
        struct
        {
            u_short	Len;
            u_char	OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_char	Len;
            u_char	CharSet;
            u_char	UsrStr[IAS_MAX_USER_STRING];
		} irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_SET, *PWINDOWS_IAS_SET, FAR *LPWINDOWS_IAS_SET;

typedef struct _WINDOWS_IAS_QUERY
{
	u_char	irdaDeviceID[4];
    char    irdaClassName[IAS_MAX_CLASSNAME];
    char    irdaAttribName[IAS_MAX_ATTRIBNAME];
    u_long	irdaAttribType;
    union
    {
        LONG irdaAttribInt;
        struct
        {
            u_long  Len;
            u_char  OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_long  Len;
            u_long	CharSet;
            u_char	UsrStr[IAS_MAX_USER_STRING];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_QUERY, *PWINDOWS_IAS_QUERY, FAR *LPWINDOWS_IAS_QUERY;

typedef struct _WCE_IAS_SET
{
    char    irdaClassName[61];
    char    irdaAttribName[61];
    u_short irdaAttribType;
    union
    {
        int irdaAttribInt;
        struct
        {
            int     Len;
            u_char  OctetSeq[1];
            u_char  Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int     Len;
            u_char  CharSet;
            u_char  UsrStr[1];
            u_char  Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_SET, *PWCE_IAS_SET;

typedef struct _WCE_IAS_QUERY
{
	u_char  irdaDeviceID[4];
    char    irdaClassName[61];
    char    irdaAttribName[61];
    u_short irdaAttribType;
    union
    {
        int irdaAttribInt;
        struct
        {
            int     Len;
            u_char  OctetSeq[1];
            u_char  Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int     Len;
            u_char  CharSet;
            u_char  UsrStr[1];
            u_char  Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_QUERY, *PWCE_IAS_QUERY;

#if   defined(_WIN32_WINNT) || defined(_WIN32_WINDOWS)
typedef WINDOWS_IAS_SET         IAS_SET, *PIAS_SET, FAR *LPIASSET;
typedef WINDOWS_IAS_QUERY       IAS_QUERY, *PIAS_QUERY, FAR *LPIASQUERY;
#elif defined(_WIN32_WCE)
typedef WCE_IAS_SET             IAS_SET, *PIAS_SET;
typedef WCE_IAS_QUERY           IAS_QUERY, *PIAS_QUERY, FAR *LPIASQUERY;
#else
#pragma message("One of _WIN32_WINNT | _WIN32_WINDOWS | _WIN32_WCE must be defined.")
#endif

#endif // __AFIRDA__
// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\advpub.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//***************************************************************************
//*                                                                         *
//* ADVPUB.H - Specify the Interface for ADVPACK.DLL                        *
//*                                                                         *
//* Copyright (c) Microsoft Corporation. All rights reserved.               *
//*                                                                         *
//***************************************************************************

#ifndef _ADVPUB_H_
#define _ADVPUB_H_

//# ifndef IEMOBILE
#ifndef UNDER_CE

#include <setupapi.h>
#include <cfgmgr32.h>

#endif // UNDER_CE
//#endif //IEMOBILE

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RunSetupCommand
//
// SYNOPSIS:    Execute an install section in an INF file, or execute a
//              program.  Advanced INF files are supported.
//
// RETURN CODES:
//
//      S_OK                                 Everything OK, no reboot needed.
//                                           No EXE to wait for.
//      S_ASYNCHRONOUS                       Please wait on phEXE.
//      ERROR_SUCCESS_REBOOT_REQUIRED        Reboot required.
//      E_INVALIDARG                         NULL specified in szCmdName or szDir
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION) INF's not supported on this OS version
//      E_UNEXPECTED                         Catastrophic failure(should never happen).
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
/////////////////////////////////////////////////////////////////////////////

#ifndef S_ASYNCHRONOUS
#define S_ASYNCHRONOUS  _HRESULT_TYPEDEF_(0x401e8L)
#endif

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI RunSetupCommandA(HWND hWnd, LPCSTR szCmdName, LPCSTR szInfSection, LPCSTR szDir, LPCSTR lpszTitle, HANDLE* phEXE, DWORD dwFlags, LPVOID pvReserved);
HRESULT WINAPI RunSetupCommandW(HWND hWnd, LPCWSTR szCmdName, LPCWSTR szInfSection, LPCWSTR szDir, LPCWSTR lpszTitle, HANDLE* phEXE, DWORD dwFlags, LPVOID pvReserved);
#ifdef UNICODE
#define RunSetupCommand  RunSetupCommandW
#else
#define RunSetupCommand  RunSetupCommandA
#endif // !UNICODE
#else
HRESULT WINAPI RunSetupCommand(HWND hWnd, LPCSTR szCmdName, LPCSTR szInfSection, LPCSTR szDir, LPCSTR lpszTitle, HANDLE* phEXE, DWORD dwFlags, LPVOID pvReserved);
#endif  // (_WIN32_IE >= 0x0605)

// FLAGS:
#define RSC_FLAG_INF                1       // exxcute INF install
#define RSC_FLAG_SKIPDISKSPACECHECK 2       // Currently does nothing
#define RSC_FLAG_QUIET              4       // quiet mode, no UI
#define RSC_FLAG_NGCONV             8       // don't run groupConv
#define RSC_FLAG_UPDHLPDLLS         16      // force to self-updating on user's system
#define RSC_FLAG_DELAYREGISTEROCX   512     // force delay of ocx registration
#define RSC_FLAG_SETUPAPI           1024    // use setupapi.dll
// don't add new RSC_FLAG_XXX flags! add LaunchINFSectionEx() flags instead.


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedRebootInit
//
// SYNOPSIS:    Initializes state for reboot checking.  Call this function
//              before calling RunSetupCommand.
// RETURNS:     value required to be passed to NeedReboot()
/////////////////////////////////////////////////////////////////////////////

DWORD WINAPI NeedRebootInit();


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: NeedReboot
//
// SYNOPSIS:    Compares stored state with current state to determine if a
//              reboot is required.
//      dwRebootCheck   the return value from NeedRebootInit
//
// RETURNS:
//      TRUE            if a reboot is required;
//      FALSE           otherwise.
/////////////////////////////////////////////////////////////////////////////

BOOL WINAPI NeedReboot(DWORD dwRebootCheck);


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RebootCheckOnInstall
//
// SYNOPSIS:    Check reboot condition if the given INF section is installed.
//      hwnd    windows handle
//      pszINF  INF filename with fully qualified path
//      pszSec  INF section.  NULL is translated as DefaultInstall or DefaultInstall.NT.
//      dwReserved Not used.
// RETURN:
//      S_OK    Reboot needed if INF section is installed.
//      S_FALSE Reboot is not needed if INF section is installed.
//      HRESULT of Win 32 errors
//
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI RebootCheckOnInstallA(HWND hwnd, LPCSTR pszINF, LPCSTR pszSec, DWORD dwReserved);
HRESULT WINAPI RebootCheckOnInstallW(HWND hwnd, LPCWSTR pszINF, LPCWSTR pszSec, DWORD dwReserved);
#ifdef UNICODE
#define RebootCheckOnInstall  RebootCheckOnInstallW
#else
#define RebootCheckOnInstall  RebootCheckOnInstallA
#endif // !UNICODE
#else
HRESULT WINAPI RebootCheckOnInstall(HWND hwnd, LPCSTR pszINF, LPCSTR pszSec, DWORD dwReserved);
#endif  // (_WIN32_IE >= 0x0605)

//////////////////////////////////////////////////////////////////////////
// ENTRY POINT: TranslateInfString
//
// SYNOPSIS:    Translates a key value in an INF file, using advanced INF
//              syntax.
// RETURN CODES:
//      S_OK                                 Everything OK.
//      HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//                                      The buffer size is too small to hold the
//                                      translated string.  Required size is in *pdwRequiredSize.
//      E_INVALIDARG                         NULL specified in pszInfFilename, pszTranslateSection,
//                                      pszTranslateKey, pdwRequiredSize.
//      HRESULT_FROM_WIN32(ERROR_OLD_WIN_VERSION)
//                                      OS not supported.
//      E_UNEXPECTED                         Catastrophic failure -- should never happen.
//      HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
//                                      The section or key specified does not exist.
//      HRESULT_FROM_WIN32(GetLastError())   Anything else
//
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI TranslateInfStringA(
    __in LPCSTR pszInfFilename,
    __in LPCSTR pszInstallSection,
    __in LPCSTR pszTranslateSection,
    __in LPCSTR pszTranslateKey,
    __out_ecount_opt(cchBuffer) LPSTR pszBuffer,
    __in DWORD cchBuffer,
    __out PDWORD pdwRequiredSize,
    __reserved PVOID pvReserved
    );
HRESULT WINAPI TranslateInfStringW(
    __in LPCWSTR pszInfFilename,
    __in LPCWSTR pszInstallSection,
    __in LPCWSTR pszTranslateSection,
    __in LPCWSTR pszTranslateKey,
    __out_ecount_opt(cchBuffer) LPWSTR pszBuffer,
    __in DWORD cchBuffer,
    __out PDWORD pdwRequiredSize,
    __reserved PVOID pvReserved
    );
#ifdef UNICODE
#define TranslateInfString  TranslateInfStringW
#else
#define TranslateInfString  TranslateInfStringA
#endif // !UNICODE
#else
HRESULT WINAPI TranslateInfString(
    __in LPCSTR pszInfFilename,
    __in LPCSTR pszInstallSection,
    __in LPCSTR pszTranslateSection,
    __in LPCSTR pszTranslateKey,
    __out_ecount_opt(cchBuffer) LPSTR pszBuffer,
    __in DWORD cchBuffer,
    __out PDWORD pdwRequiredSize,
    __reserved PVOID pvReserved
    );
#endif  // (_WIN32_IE >= 0x0605)

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegInstall
//
// SYNOPSIS:    Loads an INF from a string resource, adds some entries to the
//              INF string substitution table, and executes the INF.
// RETURNS:
//      S_OK    success.
//      E_FAIL  failure,
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
typedef struct _StrEntryA {
    LPSTR   pszName;        // String to substitute
    LPSTR   pszValue;       // Replacement string or string resource
} STRENTRYA, *LPSTRENTRYA;
typedef struct _StrEntryW {
    LPWSTR  pszName;        // String to substitute
    LPWSTR  pszValue;       // Replacement string or string resource
} STRENTRYW, *LPSTRENTRYW;
#ifdef UNICODE
typedef STRENTRYW STRENTRY;
typedef LPSTRENTRYW LPSTRENTRY;
#else
typedef STRENTRYA STRENTRY;
typedef LPSTRENTRYA LPSTRENTRY;
#endif // UNICODE

typedef struct _StrTableA {
    DWORD       cEntries;   // Number of entries in the table
    STRENTRYA*   pse;       // Array of entries
} STRTABLEA, *LPSTRTABLEA;
typedef struct _StrTableW {
    DWORD       cEntries;   // Number of entries in the table
    STRENTRYW*   pse;       // Array of entries
} STRTABLEW, *LPSTRTABLEW;
#ifdef UNICODE
typedef STRTABLEW STRTABLE;
typedef LPSTRTABLEW LPSTRTABLE;
#else
typedef STRTABLEA STRTABLE;
typedef LPSTRTABLEA LPSTRTABLE;
#endif // UNICODE

typedef const STRTABLEA CSTRTABLEA;
typedef const STRTABLEW CSTRTABLEW;
#ifdef UNICODE
typedef STRTABLEW STRTABLE;
typedef CSTRTABLEW CSTRTABLE;
#else
typedef STRTABLEA STRTABLE;
typedef CSTRTABLEA CSTRTABLE;
#endif // UNICODE
typedef const STRTABLEA *LPCSTRTABLEA;
typedef const STRTABLEW *LPCSTRTABLEW;
#ifdef UNICODE
typedef STRTABLEW STRTABLE;
typedef LPCSTRTABLEW LPCSTRTABLE;
#else
typedef STRTABLEA STRTABLE;
typedef LPCSTRTABLEA LPCSTRTABLE;
#endif // UNICODE

HRESULT WINAPI RegInstallA(HMODULE hmod, LPCSTR pszSection, const STRTABLEA* pstTable);
HRESULT WINAPI RegInstallW(HMODULE hmod, LPCWSTR pszSection, const STRTABLEW* pstTable);
#ifdef UNICODE
#define RegInstall  RegInstallW
#else
#define RegInstall  RegInstallA
#endif // !UNICODE

#else

typedef struct _StrEntryA {
    LPSTR pszName;          // String to substitute
    LPSTR pszValue;         // Replacement string or string resource
} STRENTRYA, *LPSTRENTRYA;

typedef struct _StrTableA {
    DWORD       cEntries;   // Number of entries in the table
    STRENTRYA*  pse;        // Array of entries
} STRTABLEA, *LPSTRTABLEA;

typedef STRENTRYA STRENTRY;
typedef LPSTRENTRYA LPSTRENTRY;

typedef STRTABLEA STRTABLE;
typedef const STRTABLEA CSTRTABLE;
typedef const STRTABLEA *LPCSTRTABLEA;

HRESULT WINAPI RegInstall(HMODULE hmod, LPCSTR pszSection, const STRTABLEA* pstTable);
#endif  // (_WIN32_IE >= 0x0605)

//
// For people whos minds are too addled to use DELAYLOAD (or UNICODE for that matter)
//
#define REGINSTALL  REGINSTALLA
typedef HRESULT (WINAPI *REGINSTALLA)(
    HMODULE hm,                         // Module that contains REGINST resource
    LPCSTR pszSection,                  // Section of INF to execute
    LPCSTRTABLEA pstTable               // Additional string substitutions
);

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSectionEx
//
// SYNOPSIS:    Install INF section with BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI LaunchINFSectionExA(
    __in_opt HWND hwnd,
    __in_opt HINSTANCE hInstance,
    __in LPSTR pszParms,
    __in INT nShow
    );
HRESULT WINAPI LaunchINFSectionExW(
    __in_opt HWND hwnd,
    __in_opt HINSTANCE hInstance,
    __in LPWSTR pszParms,
    __in INT nShow
    );
#ifdef UNICODE
#define LaunchINFSectionEx  LaunchINFSectionExW
#else
#define LaunchINFSectionEx  LaunchINFSectionExA
#endif // !UNICODE
#else
HRESULT WINAPI LaunchINFSectionEx(
    __in_opt HWND hwnd,
    __in_opt HINSTANCE hInstance,
    __in LPSTR pszParms,
    __in INT nShow
    );
#endif  // (_WIN32_IE >= 0x0605)


// FLAGS: - need to stay this way is for compatibility. Don't change them (but ok to add new ones).
//
#define ALINF_QUIET              4      // quiet mode, no UI
#define ALINF_NGCONV             8      // don't run groupConv
#define ALINF_UPDHLPDLLS         16     // force to self-updating on user's system
#define ALINF_BKINSTALL          32     // backup data before install
#define ALINF_ROLLBACK           64     // rollback to previous state
#define ALINF_CHECKBKDATA        128    // validate the backup data
#define ALINF_ROLLBKDOALL        256    // bypass building file list
#define ALINF_DELAYREGISTEROCX   512    // force delay of ocx registration


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: ExecuteCab
//
// SYNOPSIS:    Extract the an INF from the CAB file, and do INF install on it.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
typedef struct _CabInfoA {
    LPSTR   pszCab;
    LPSTR   pszInf;
    LPSTR   pszSection;
    CHAR    szSrcPath[MAX_PATH];
    DWORD   dwFlags;
} CABINFOA, *PCABINFOA;
typedef struct _CabInfoW {
    LPWSTR  pszCab;
    LPWSTR  pszInf;
    LPWSTR  pszSection;
    WCHAR   szSrcPath[MAX_PATH];
    DWORD   dwFlags;
} CABINFOW, *PCABINFOW;
#ifdef UNICODE
typedef CABINFOW CABINFO;
typedef PCABINFOW PCABINFO;
#else
typedef CABINFOA CABINFO;
typedef PCABINFOA PCABINFO;
#endif // UNICODE

HRESULT WINAPI ExecuteCabA(HWND hwnd, CABINFOA* pCab, LPVOID pReserved);
HRESULT WINAPI ExecuteCabW(HWND hwnd, CABINFOW* pCab, LPVOID pReserved);
#ifdef UNICODE
#define ExecuteCab  ExecuteCabW
#else
#define ExecuteCab  ExecuteCabA
#endif // !UNICODE

#else

typedef struct _CabInfoA {
    LPSTR   pszCab;
    LPSTR   pszInf;
    LPSTR   pszSection;
    CHAR    szSrcPath[MAX_PATH];
    DWORD   dwFlags;
} CABINFOA, *PCABINFOA;

typedef CABINFOA CABINFO;
typedef PCABINFOA PCABINFO;

HRESULT WINAPI ExecuteCab(HWND hwnd, CABINFOA* pCab, LPVOID pReserved);
#endif  // (_WIN32_IE >= 0x0605)


// flag as LaunchINFSectionEx's flag defines

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AdvInstallFile
//
// SYNOPSIS:    To copy a file from the source to a destination
//              Basicly a wrapper around the setupapi file copy engine
/////////////////////////////////////////////////////////////////////////////

// Flags which can be passed to AdvInstallFile
//
// Here is a copy of the flags defined in setupapi.h for reference below.
//      #define COPYFLG_WARN_IF_SKIP            0x00000001   // warn if user tries to skip file
//      #define COPYFLG_NOSKIP                  0x00000002   // disallow skipping this file
//      #define COPYFLG_NOVERSIONCHECK          0x00000004   // ignore versions and overwrite target
//      #define COPYFLG_FORCE_FILE_IN_USE       0x00000008   // force file-in-use behavior
//      #define COPYFLG_NO_OVERWRITE            0x00000010   // do not copy if file exists on target
//      #define COPYFLG_NO_VERSION_DIALOG       0x00000020   // do not copy if target is newer
//      #define COPYFLG_REPLACEONLY             0x00000400   // copy only if file exists on target

#define AIF_WARNIFSKIP          0x00000001              // system critical file: warn if user tries to skip
#define AIF_NOSKIP              0x00000002              // Skip is disallowed for this file
#define AIF_NOVERSIONCHECK      0x00000004              // don't check the version number of the file overwrite
#define AIF_FORCE_FILE_IN_USE   0x00000008              // force file-in-use behavior
#define AIF_NOOVERWRITE         0x00000010              // copy only if target doesn't exist
                                                        // if AIF_QUIET, the file is not copied and
                                                        // the user is not notified
#define AIF_NO_VERSION_DIALOG   0x00000020              // do not copy if target is newer
#define AIF_REPLACEONLY         0x00000400              // copy only if target file already present

// Flags only known to AdvInstallFile
#define AIF_NOLANGUAGECHECK     0x10000000              // don't check the language of the file
                                                        // if the flags is NOT specified and AIF_QUIET
                                                        // the file is not copied and the user is not notified
#define AIF_QUIET               0x20000000              // No UI to the user

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI AdvInstallFileA(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile, LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved);
HRESULT WINAPI AdvInstallFileW(HWND hwnd, LPCWSTR lpszSourceDir, LPCWSTR lpszSourceFile, LPCWSTR lpszDestDir, LPCWSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved);
#ifdef UNICODE
#define AdvInstallFile  AdvInstallFileW
#else
#define AdvInstallFile  AdvInstallFileA
#endif // !UNICODE
#else
HRESULT WINAPI AdvInstallFile(HWND hwnd, LPCSTR lpszSourceDir, LPCSTR lpszSourceFile, LPCSTR lpszDestDir, LPCSTR lpszDestFile, DWORD dwFlags, DWORD dwReserved);
#endif  // (_WIN32_IE >= 0x0605)

//////////////////////////////////////////////////////////////////
// the following flags are for backwards compatiable.  No API user
// should reference them directly now.
//
#define  IE4_RESTORE        0x00000001      // if this bit is off, save the registries.
#define  IE4_BACKNEW        0x00000002      // backup all files which are not backed up before
#define  IE4_NODELETENEW    0x00000004      // don't delete files we don't backed up before
#define  IE4_NOMESSAGES     0x00000008      // No message display in any events.
#define  IE4_NOPROGRESS     0x00000010      // this bit on: No file backup progressbar
#define  IE4_NOENUMKEY      0x00000020      // this bit on: Don't Enum sub key even there is no given valuename
#define  IE4_NO_CRC_MAPPING 0x00000040      // Normally you should not turn on this bit, advpack creates
                                            // internal mapping for all the entries backed up.
#define  IE4_REGSECTION     0x00000080      // INF AddReg/DelReg section
#define  IE4_FRDOALL        0x00000100      // FileRestore DoAll
#define  IE4_UPDREFCNT      0x00000200      // Update the ref count in .ini backup file list
#define  IE4_USEREFCNT      0x00000400      // use ref count to determin if the backup file should be put back
#define  IE4_EXTRAINCREFCNT 0x00000800      // if increase the ref cnt if it has been updated before

#define  IE4_REMOVREGBKDATA 0x00001000      // This bit should be used with restore bit


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegSaveRestore
//
// SYNOPSIS:    Save or Restore the given register value or given INF reg section.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI RegSaveRestoreA(HWND hWnd, LPCSTR pszTitleString, HKEY hkBckupKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey, LPCSTR pcszValueName, DWORD dwFlags);
HRESULT WINAPI RegSaveRestoreW(HWND hWnd, LPCWSTR pszTitleString, HKEY hkBckupKey, LPCWSTR pcszRootKey, LPCWSTR pcszSubKey, LPCWSTR pcszValueName, DWORD dwFlags);
#ifdef UNICODE
#define RegSaveRestore  RegSaveRestoreW
#else
#define RegSaveRestore  RegSaveRestoreA
#endif // !UNICODE
#else
HRESULT WINAPI RegSaveRestore(HWND hWnd, LPCSTR pszTitleString, HKEY hkBckupKey, LPCSTR pcszRootKey, LPCSTR pcszSubKey, LPCSTR pcszValueName, DWORD dwFlags);
#endif   // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegSaveRestoreOnINF
//
// SYNOPSIS:    Save or Restore the given INF Reg Section. At restore, if INF and Section pointers are NULL,
//              restore all from the given backup key handle.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI RegSaveRestoreOnINFA(HWND hWnd, LPCSTR pszTitle, LPCSTR pszINF, LPCSTR pszSection, HKEY hHKLMBackKey, HKEY hHKCUBackKey, DWORD dwFlags);
HRESULT WINAPI RegSaveRestoreOnINFW(HWND hWnd, LPCWSTR pszTitle, LPCWSTR pszINF, LPCWSTR pszSection, HKEY hHKLMBackKey, HKEY hHKCUBackKey, DWORD dwFlags);
#ifdef UNICODE
#define RegSaveRestoreOnINF  RegSaveRestoreOnINFW
#else
#define RegSaveRestoreOnINF  RegSaveRestoreOnINFA
#endif // !UNICODE
#else
HRESULT WINAPI RegSaveRestoreOnINF(HWND hWnd, LPCSTR pszTitle, LPCSTR pszINF, LPCSTR pszSection, HKEY hHKLMBackKey, HKEY hHKCUBackKey, DWORD dwFlags);
#endif  // (_WIN32_IE >= 0x0605)


// FLAGS:
#define ARSR_RESTORE    IE4_RESTORE       // if this bit is off, means Save. Otherwise, restore.
#define ARSR_NOMESSAGES IE4_NOMESSAGES    // Quiet no messages in any event.
#define ARSR_REGSECTION IE4_REGSECTION    // if this bit is off, the given section is GenInstall Section
#define ARSR_REMOVREGBKDATA IE4_REMOVREGBKDATA // if both this bit and restore bit on, remove the backup reg data without restore it

// Turn on the logging by add these RegVale in HKLM\software\microsoft\IE4
#define  REG_SAVE_LOG_KEY       TEXT("RegSaveLogFile")
#define  REG_RESTORE_LOG_KEY    TEXT("RegRestoreLogFile")


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: RegRestoreAll
//
// SYNOPSIS:    
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI RegRestoreAllA(
    __in_opt HWND hWnd,
    __in_opt LPCSTR pszTitleString,
    __in HKEY hkBckupKey
    );
HRESULT WINAPI RegRestoreAllW(
    __in_opt HWND hWnd,
    __in_opt LPCWSTR pszTitleString,
    __in HKEY hkBckupKey
    );
#ifdef UNICODE
#define RegRestoreAll  RegRestoreAllW
#else
#define RegRestoreAll  RegRestoreAllA
#endif // !UNICODE
#else
HRESULT WINAPI RegRestoreAll(
    __in_opt HWND hWnd,
    __in_opt LPCSTR pszTitleString,
    __in HKEY hkBckupKey
    );
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveRestore
//
// SYNOPSIS:    Save or Restore the files on the list lpFileList.
//              If lpFileList is NULL at restore time, the function will restore
//              all based on INI index file.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI FileSaveRestoreA(
    HWND hDlg,
    __in_opt LPSTR lpFileList,
    LPCSTR lpDir,
    LPCSTR lpBaseName,
    DWORD dwFlags);
HRESULT WINAPI FileSaveRestoreW(
    HWND hDlg,
    __in_opt LPWSTR lpFileList,
    LPCWSTR lpDir,
    LPCWSTR lpBaseName,
    DWORD dwFlags);
#ifdef UNICODE
#define FileSaveRestore  FileSaveRestoreW
#else
#define FileSaveRestore  FileSaveRestoreA
#endif // !UNICODE
#else
HRESULT WINAPI FileSaveRestore(
    HWND hDlg, 
    __in_opt LPSTR lpFileList,
    LPCSTR lpDir,
    LPCSTR lpBaseName,
    DWORD dwFlags);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveRestoreOnINF
//
// SYNOPSIS:    
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI FileSaveRestoreOnINFA(HWND hWnd, LPCSTR pszTitle, LPCSTR pszINF, LPCSTR pszSection, LPCSTR pszBackupDir, LPCSTR pszBaseBackupFile, DWORD dwFlags);
HRESULT WINAPI FileSaveRestoreOnINFW(HWND hWnd, LPCWSTR pszTitle, LPCWSTR pszINF, LPCWSTR pszSection, LPCWSTR pszBackupDir, LPCWSTR pszBaseBackupFile, DWORD dwFlags);
#ifdef UNICODE
#define FileSaveRestoreOnINF  FileSaveRestoreOnINFW
#else
#define FileSaveRestoreOnINF  FileSaveRestoreOnINFA
#endif // !UNICODE
#else
HRESULT WINAPI FileSaveRestoreOnINF(HWND hWnd, LPCSTR pszTitle, LPCSTR pszINF, LPCSTR pszSection, LPCSTR pszBackupDir, LPCSTR pszBaseBackupFile, DWORD dwFlags);
#endif  // (_WIN32_IE >= 0x0605)

// FLAGS:
#define  AFSR_RESTORE        IE4_RESTORE      // if this bit is off, save the file.
#define  AFSR_BACKNEW        IE4_BACKNEW      // backup all files which are not backed up before
#define  AFSR_NODELETENEW    IE4_NODELETENEW  // don't delete files we don't backed up before
#define  AFSR_NOMESSAGES     IE4_NOMESSAGES   // No message display in any events.
#define  AFSR_NOPROGRESS     IE4_NOPROGRESS   // this bit on: No file backup progressbar
#define  AFSR_UPDREFCNT      IE4_UPDREFCNT    // update the reference count for the files
#define  AFSR_USEREFCNT      IE4_USEREFCNT    // use the ref count to guide the restore file
#define  AFSR_EXTRAINCREFCNT IE4_EXTRAINCREFCNT


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: AddDelBackupEntry
//
// SYNOPSIS:    If AADBE_ADD_ENTRY is specified, mark the file in the File list as not existing
//              during file save in the INI file.  This can be used to mark additional files that
//              they did not exist during backup to avoid having them backup the next time the
//              FileSaveRestore is called to save files.
//              If AADBE_DEL_ENTRY is specified, delete the entry from the INI.  This mechanism can
//              be used to leave files permanently on the system.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI AddDelBackupEntryA(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags);
HRESULT WINAPI AddDelBackupEntryW(LPCWSTR lpcszFileList, LPCWSTR lpcszBackupDir, LPCWSTR lpcszBaseName, DWORD dwFlags);
#ifdef UNICODE
#define AddDelBackupEntry  AddDelBackupEntryW
#else
#define AddDelBackupEntry  AddDelBackupEntryA
#endif // !UNICODE
#else
HRESULT WINAPI AddDelBackupEntry(LPCSTR lpcszFileList, LPCSTR lpcszBackupDir, LPCSTR lpcszBaseName, DWORD dwFlags);
#endif  // (_WIN32_IE >= 0x0605)

#define  AADBE_ADD_ENTRY    0x01            // add entries to the INI file
#define  AADBE_DEL_ENTRY    0x02            // delete entries from the INI file

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: FileSaveMarkNotExist
//
// SYNOPSIS:    Mark the file in the File list as not existing during file save in the INI file
//              This can be used to mark additional files that they did not exist during backup
//              to avoid having them backup the next time the FileSaveRestore is called to save
//              files
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI FileSaveMarkNotExistA(
    __in_opt LPCSTR lpFileList,
    __in_opt LPCSTR lpDir,
    __in_opt LPCSTR lpBaseName);
HRESULT WINAPI FileSaveMarkNotExistW(
    __in_opt LPCWSTR lpFileList,
    __in_opt LPCWSTR lpDir,
    __in_opt LPCWSTR lpBaseName);
#ifdef UNICODE
#define FileSaveMarkNotExist  FileSaveMarkNotExistW
#else
#define FileSaveMarkNotExist  FileSaveMarkNotExistA
#endif // !UNICODE
#else
HRESULT WINAPI FileSaveMarkNotExist(
    __in_opt LPCSTR lpFileList,
    __in_opt LPCSTR lpDir,
    __in_opt LPCSTR lpBaseName);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFile
//
// SYNOPSIS:    Get the given file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI GetVersionFromFileA(LPCSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
HRESULT WINAPI GetVersionFromFileW(LPCWSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
#ifdef UNICODE
#define GetVersionFromFile  GetVersionFromFileW
#else
#define GetVersionFromFile  GetVersionFromFileA
#endif // !UNICODE
#else
HRESULT WINAPI GetVersionFromFile(LPCSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
#endif // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: GetVersionFromFileEx
//
// SYNOPSIS:    Get the given disk file's version and lang information.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI GetVersionFromFileExA(LPCSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
HRESULT WINAPI GetVersionFromFileExW(LPCWSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
#ifdef UNICODE
#define GetVersionFromFileEx  GetVersionFromFileExW
#else
#define GetVersionFromFileEx  GetVersionFromFileExA
#endif // !UNICODE
#else
HRESULT WINAPI GetVersionFromFileEx(LPCSTR lpszFilename, LPDWORD pdwMSVer, LPDWORD pdwLSVer, BOOL bVersion);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: IsNTAdmin
//
// SYNOPSIS:    On NT, check if user has admin right.
//
// RETURNS:     TURE  has admin right; FLSE  no admin right.
/////////////////////////////////////////////////////////////////////////////

BOOL WINAPI IsNTAdmin(DWORD dwReserved, DWORD *lpdwReserved);


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNode
//
// SYNOPSIS:    Deletes a file or directory
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI DelNodeA(LPCSTR pszFileOrDirName, DWORD dwFlags);
HRESULT WINAPI DelNodeW(LPCWSTR pszFileOrDirName, DWORD dwFlags);
#ifdef UNICODE
#define DelNode  DelNodeW
#else
#define DelNode  DelNodeA
#endif // !UNICODE
#else
HRESULT WINAPI DelNode(LPCSTR pszFileOrDirName, DWORD dwFlags);
#endif  // (_WIN32_IE >= 0x0605)

// FLAGS:
#define ADN_DEL_IF_EMPTY        0x00000001  // delete the directory only if it's empty
#define ADN_DONT_DEL_SUBDIRS    0x00000002  // don't delete any sub-dirs; delete only the files
#define ADN_DONT_DEL_DIR        0x00000004  // don't delete the dir itself
#define ADN_DEL_UNC_PATHS       0x00000008  // delete UNC paths


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: DelNodeRunDLL32
//
// SYNOPSIS:    Deletes a file or directory; the parameters to this API are of
//              WinMain type
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI DelNodeRunDLL32A(HWND hwnd, HINSTANCE hInstance, LPSTR pszParms, INT nShow);
HRESULT WINAPI DelNodeRunDLL32W(HWND hwnd, HINSTANCE hInstance, LPWSTR pszParms, INT nShow);
#ifdef UNICODE
#define DelNodeRunDLL32  DelNodeRunDLL32W
#else
#define DelNodeRunDLL32  DelNodeRunDLL32A
#endif // !UNICODE
#else
HRESULT WINAPI DelNodeRunDLL32(HWND hwnd, HINSTANCE hInstance, LPSTR pszParms, INT nShow);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    Three APIs give the caller the option to be more efficient when need
//              Advpack to translate INF file in a continue fashion.
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI OpenINFEngineA(LPCSTR pszInfFilename, LPCSTR pszInstallSection, DWORD dwFlags, HINF* phInf, PVOID pvReserved);
HRESULT WINAPI OpenINFEngineW(LPCWSTR pszInfFilename, LPCWSTR pszInstallSection, DWORD dwFlags, HINF* phInf, PVOID pvReserved);
#ifdef UNICODE
#define OpenINFEngine  OpenINFEngineW
#else
#define OpenINFEngine  OpenINFEngineA
#endif // !UNICODE
#else
HRESULT WINAPI OpenINFEngine(LPCSTR pszInfFilename, LPCSTR pszInstallSection, DWORD dwFlags, HINF* phInf, PVOID pvReserved);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI TranslateInfStringExA(HINF hInf, LPCSTR pszInfFilename, LPCSTR pszTranslateSection, LPCSTR pszTranslateKey, LPSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize, PVOID pvReserved);
HRESULT WINAPI TranslateInfStringExW(HINF hInf, LPCWSTR pszInfFilename, LPCWSTR pszTranslateSection, LPCWSTR pszTranslateKey, LPWSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize, PVOID pvReserved);
#ifdef UNICODE
#define TranslateInfStringEx  TranslateInfStringExW
#else
#define TranslateInfStringEx  TranslateInfStringExA
#endif // !UNICODE
#else
HRESULT WINAPI TranslateInfStringEx(HINF hInf, LPCSTR pszInfFilename, LPCSTR pszTranslateSection, LPCSTR pszTranslateKey, LPSTR pszBuffer, DWORD dwBufferSize, PDWORD pdwRequiredSize, PVOID pvReserved);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI CloseINFEngine(HINF hInf);


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: OpenINFEngine, TranslateINFStringEx, CloseINFEngine
//
// SYNOPSIS:    
//
// RETURNS:
//      S_OK    success
//      E_FAIL  failure
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI ExtractFilesA(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags, LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
HRESULT WINAPI ExtractFilesW(LPCWSTR pszCabName, LPCWSTR pszExpandDir, DWORD dwFlags, LPCWSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
#ifdef UNICODE
#define ExtractFiles  ExtractFilesW
#else
#define ExtractFiles  ExtractFilesA
#endif // !UNICODE
#else
HRESULT WINAPI ExtractFiles(LPCSTR pszCabName, LPCSTR pszExpandDir, DWORD dwFlags, LPCSTR pszFileList, LPVOID lpReserved, DWORD dwReserved);
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: LaunchINFSection
//
// SYNOPSIS:    Install INF section WITHOUT BACKUP/ROLLBACK capabilities.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
INT     WINAPI LaunchINFSectionA(HWND hwndOwner, HINSTANCE hInstance, LPSTR pszParams, INT nShow);
INT     WINAPI LaunchINFSectionW(HWND hwndOwner, HINSTANCE hInstance, LPWSTR pszParams, INT nShow);
#ifdef UNICODE
#define LaunchINFSection  LaunchINFSectionW
#else
#define LaunchINFSection  LaunchINFSectionA
#endif // !UNICODE
#else
INT     WINAPI LaunchINFSection(HWND hwndOwner, HINSTANCE hInstance, LPSTR pszParams, INT nShow);
#endif  // (_WIN32_IE >= 0x0605)

// LaunchINFSection flags
#define LIS_QUIET               0x0001      // Bit 0
#define LIS_NOGRPCONV           0x0002      // Bit 1

// Flags in Advanced INF RunPreSetupCommands and RunPostSetupCommands of the Install section
// Those flags can tell advpack how to run those commands, quiet or not quiet, wait or not wait.
// The Default for runing those commands are:  Not Quiet and Wait for finish before return the caller.
// I.E>  RunPostSetupCommands = MyCmdsSecA:1, MyCmdsSecB:2, MyCmdsSecC
#define RUNCMDS_QUIET       0x00000001
#define RUNCMDS_NOWAIT      0x00000002
#define RUNCMDS_DELAYPOSTCMD    0x00000004

/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: UserStubWrapper
//
// SYNOPSIS:    The function wrapper around the real per-user restore stub to 
//              do some generic/intelligent function on behalf of every component.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI UserInstStubWrapperA(HWND hwnd, HINSTANCE hInstance, LPCSTR pszParms, INT nShow); 
HRESULT WINAPI UserInstStubWrapperW(HWND hwnd, HINSTANCE hInstance, LPCWSTR pszParms, INT nShow); 
#ifdef UNICODE
#define UserInstStubWrapper  UserInstStubWrapperW
#else
#define UserInstStubWrapper  UserInstStubWrapperA
#endif // !UNICODE
#else
HRESULT WINAPI UserInstStubWrapper(HWND hwnd, HINSTANCE hInstance, LPCSTR pszParms, INT nShow); 
#endif  // (_WIN32_IE >= 0x0605)


// ENTRY POINT: UserUnInstStubWrapper
//
// SYNOPSIS:    The function wrapper around the real per-user restore stub to 
//              do some generic/intelligent function on behalf of every component.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
HRESULT WINAPI UserUnInstStubWrapperA(HWND hwnd, HINSTANCE hInstance, LPCSTR pszParms, INT nShow); 
HRESULT WINAPI UserUnInstStubWrapperW(HWND hwnd, HINSTANCE hInstance, LPCWSTR pszParms, INT nShow); 
#ifdef UNICODE
#define UserUnInstStubWrapper  UserUnInstStubWrapperW
#else
#define UserUnInstStubWrapper  UserUnInstStubWrapperA
#endif // !UNICODE
#else
HRESULT WINAPI UserUnInstStubWrapper(HWND hwnd, HINSTANCE hInstance, LPCSTR pszParms, INT nShow); 
#endif  // (_WIN32_IE >= 0x0605)


/////////////////////////////////////////////////////////////////////////////
// ENTRY POINT: SetPerUserInstValues
//
// SYNOPSIS:    The function set the per-user stub reg values under IsInstalled\{GUID} 
//              related key to ensure the later per-user process correctly.
//
// RETURNS:     E_FAIL on failure, S_OK on success.
/////////////////////////////////////////////////////////////////////////////

#if (_WIN32_IE >= 0x0605)
typedef struct _PERUSERSECTIONA {
    CHAR   szGUID[MAX_GUID_STRING_LEN + 20];
    CHAR   szDispName[128];
    CHAR   szLocale[10];
    CHAR   szStub[MAX_PATH*4];
    CHAR   szVersion[32];
    CHAR   szCompID[128]; 
    DWORD dwIsInstalled;
    BOOL  bRollback;
} PERUSERSECTIONA, *PPERUSERSECTIONA;
typedef struct _PERUSERSECTIONW {
    WCHAR  szGUID[MAX_GUID_STRING_LEN + 20];
    WCHAR  szDispName[128];
    WCHAR  szLocale[10];
    WCHAR  szStub[MAX_PATH*4];
    WCHAR  szVersion[32];
    WCHAR  szCompID[128]; 
    DWORD dwIsInstalled;
    BOOL  bRollback;
} PERUSERSECTIONW, *PPERUSERSECTIONW;
#ifdef UNICODE
typedef PERUSERSECTIONW PERUSERSECTION;
typedef PPERUSERSECTIONW PPERUSERSECTION;
#else
typedef PERUSERSECTIONA PERUSERSECTION;
typedef PPERUSERSECTIONA PPERUSERSECTION;
#endif // UNICODE

HRESULT WINAPI SetPerUserSecValuesA(PERUSERSECTIONA* pPerUser);
HRESULT WINAPI SetPerUserSecValuesW(PERUSERSECTIONW* pPerUser);
#ifdef UNICODE
#define SetPerUserSecValues  SetPerUserSecValuesW
#else
#define SetPerUserSecValues  SetPerUserSecValuesA
#endif // !UNICODE

#else

typedef struct _PERUSERSECTIONA {
    CHAR   szGUID[MAX_GUID_STRING_LEN + 20];
    CHAR   szDispName[128];
    CHAR   szLocale[10];
    CHAR   szStub[MAX_PATH*4];
    CHAR   szVersion[32];
    CHAR   szCompID[128];
    DWORD dwIsInstalled;
    BOOL  bRollback;
} PERUSERSECTIONA, *PPERUSERSECTIONA;

typedef PERUSERSECTIONA PERUSERSECTION;
typedef PPERUSERSECTIONA PPERUSERSECTION;

HRESULT WINAPI SetPerUserSecValues(PERUSERSECTIONA* pPerUser);
#endif  // (_WIN32_IE >= 0x0605)


#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif // _ADVPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amaudio.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Audio related definitions and interfaces for ActiveMovie

#ifndef __AMAUDIO__
#define __AMAUDIO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <mmsystem.h>
#include <dsound.h>

// This is the interface the audio renderer supports to give the application
// access to the direct sound object and buffers it is using, to allow the
// application to use things like the 3D features of Direct Sound for the
// soundtrack of a movie being played with Active Movie

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IAMDirectSound

DECLARE_INTERFACE_(IAMDirectSound,IUnknown)
{
    /* IUnknown methods */

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /* IAMDirectSound methods */

    STDMETHOD(GetDirectSoundInterface)(THIS_ LPDIRECTSOUND *lplpds) PURE;
    STDMETHOD(GetPrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(GetSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER *lplpdsb) PURE;
    STDMETHOD(ReleaseDirectSoundInterface)(THIS_ LPDIRECTSOUND lpds) PURE;
    STDMETHOD(ReleasePrimaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(ReleaseSecondaryBufferInterface)(THIS_ LPDIRECTSOUNDBUFFER lpdsb) PURE;
    STDMETHOD(SetFocusWindow)(THIS_ HWND, BOOL) PURE ;
    STDMETHOD(GetFocusWindow)(THIS_ HWND *, BOOL*) PURE ;
};


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMAUDIO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\afdfunc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

afdfunc.h

Abstract:

Functions exposed from the AFD system process

Notes: 


--*/

// @CESYSGEN IF CE_MODULES_AFD

#ifndef _AFDFUNC_H_
#define _AFDFUNC_H_

#ifndef _AFD_NO_WS2

#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _SOCK_LIST_DEF
#define _SOCK_LIST_DEF

typedef struct _SOCK_LIST {
	DWORD				hSocket;			// handle to socket passed in from dll layer
	struct _SOCK_INFO	*Socket;             // the target socket
	DWORD				EventMask;          // events the client is interested in
	DWORD				Context;            // user-defined context value (handle?)
	struct _SOCK_INFO	*pSock;			// ptr to real socket
				// no need to confuse people Context is just a SOCKET
    HANDLE				hHandleLock;
	
} SOCK_LIST, *LPSOCK_LIST, *PSOCK_LIST;

#endif	// _SOCK_LIST_DEF


#ifndef SOCKHAND_DEFINED
DECLARE_HANDLE(SOCKHAND);
typedef SOCKHAND *PSOCKHAND;
#define SOCKHAND_DEFINED
#endif

#include "ras.h"
#include "tapi.h"
			    
#ifdef __cplusplus
}
#endif

#ifdef WINCEOEM

#if defined(WINCEMACRO) || defined(WINCEAFDMACRO) || defined(WINCEWSPMMACRO)
#include <mafdfunc.h>	// macros
#endif

#if defined(WINCEWSPMMACRO)
SOCKHAND AFDSocket(DWORD AddressFamily, DWORD SocketType, DWORD Protocol,
				DWORD CatId, GUID *pProvId);





DWORD 
AFDSelect(UINT ReadCount, PSOCK_LIST ReadList,
	UINT WriteCount, PSOCK_LIST WriteList,
	UINT ExceptCount, PSOCK_LIST ExceptList,
	const struct timeval *timeout);

#endif

#endif

#endif  // _AFDFUNC_H_

// @CESYSGEN ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amextra.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __AMEXTRA__
#define __AMEXTRA__

// Simple rendered input pin
//
// NOTE if your filter queues stuff before rendering then it may not be
// appropriate to use this class
//
// In that case queue the end of stream condition until the last sample
// is actually rendered and flush the condition appropriately

class CRenderedInputPin : public CBaseInputPin
{
public:

    CRenderedInputPin(TCHAR *pObjectName,
                      CBaseFilter *pFilter,
                      CCritSec *pLock,
                      HRESULT *phr,
                      LPCWSTR pName);

    // Override methods to track end of stream state
    STDMETHODIMP EndOfStream();
    STDMETHODIMP EndFlush();

    HRESULT Active();
    HRESULT Run(REFERENCE_TIME tStart);

protected:

    // Member variables to track state
    BOOL m_bAtEndOfStream;      // Set by EndOfStream
    BOOL m_bCompleteNotified;   // Set when we notify for EC_COMPLETE

private:
    void DoCompleteHandling();
};

#endif // __AMEXTRA__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amfilter.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Base class hierarchy for streams architecture, December 1994

#ifndef __FILTER__
#define __FILTER__

/* The following classes are declared in this header: */

class CBaseMediaFilter;     // IMediaFilter support
class CBaseFilter;          // IBaseFilter,IMediaFilter support
class CBasePin;             // Abstract base class for IPin interface
class CEnumPins;            // Enumerate input and output pins
class CEnumMediaTypes;      // Enumerate the pin's preferred formats
class CBaseOutputPin;       // Adds data provider member functions
class CBaseInputPin;        // Implements IMemInputPin interface
class CMediaSample;         // Basic transport unit for IMemInputPin
class CBaseAllocator;       // General list guff for most allocators
class CMemAllocator;        // Implements memory buffer allocation


//=====================================================================
//=====================================================================
//
// QueryFilterInfo and QueryPinInfo AddRef the interface pointers
// they return.  You can use the macro below to release the interface.
//
//=====================================================================
//=====================================================================

#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

//=====================================================================
//=====================================================================
// Defines CBaseMediaFilter
//
// Abstract base class implementing IMediaFilter.
//
// Typically you will derive your filter from CBaseFilter rather than
// this,  unless you are implementing an object such as a plug-in
// distributor that needs to support IMediaFilter but not IBaseFilter.
//
// Note that IMediaFilter is derived from IPersist to allow query of
// class id.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseMediaFilter : public CUnknown,
public IMediaFilter
{
    
protected:
    
    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this filter's reference clock
    // note: all filters in a filter graph use the same clock
    
    // offset from stream time to reference time
    CRefTime        m_tStart;
    
    CLSID       m_clsid;            // This filters clsid
    // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking

    DWORD       m_dwReporterTag;
    
public:
    
    CBaseMediaFilter(
        const TCHAR     *pName,
        LPUNKNOWN pUnk,
        CCritSec  *pLock,
        REFCLSID   clsid);

    CBaseMediaFilter(
        const TCHAR     *pName,
        LPUNKNOWN pUnk,
        CCritSec  *pLock,
        REFCLSID   clsid,
        DWORD      dwReporterTag);
    
    virtual ~CBaseMediaFilter();
    
    DECLARE_IUNKNOWN
        
        // override this to say what interfaces we support where
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    
    //
    // --- IPersist method ---
    //
    
    STDMETHODIMP GetClassID(CLSID *pClsID);
    
    // --- IMediaFilter methods ---
    
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
    
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    
    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);
    
    // default implementation of Stop and Pause just record the
    // state. Override to activate or de-activate your filter.
    // Note that Run when called from Stopped state will call Pause
    // to ensure activation, so if you are a source or transform
    // you will probably not need to override Run.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    
    
    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    
    // --- helper methods ---
    
    DWORD GetReporterTag( void ) const
    {
        return m_dwReporterTag;
    }

    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);
    
    // Is the filter currently active? (running or paused)
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };
};

//=====================================================================
//=====================================================================
// Defines CBaseFilter
//
// An abstract class providing basic IBaseFilter support for pin
// enumeration and filter information reading.
//
// We cannot derive from CBaseMediaFilter since methods in IMediaFilter
// are also in IBaseFilter and would be ambiguous. Since much of the code
// assumes that they derive from a class that has m_State and other state
// directly available, we duplicate code from CBaseMediaFilter rather than
// having a member variable.
//
// Derive your filter from this, or from a derived object such as
// CTransformFilter.
//=====================================================================
//=====================================================================


class AM_NOVTABLE CBaseFilter : public CUnknown,        // Handles an IUnknown
public IBaseFilter        // The Filter Interface
, public IAMovieSetup     // For un/registration
{
    
    friend class CBasePin;
    
protected:
    FILTER_STATE    m_State;            // current state: running, paused
    IReferenceClock *m_pClock;          // this graph's ref clock
    CRefTime        m_tStart;           // offset from stream time to reference time
    CLSID       m_clsid;            // This filters clsid
    // used for serialization
    CCritSec        *m_pLock;           // Object we use for locking
    
    WCHAR           *m_pName;           // Full filter name
    IFilterGraph    *m_pGraph;          // Graph we belong to
    IMediaEventSink *m_pSink;           // Called with notify events
    LONG            m_PinVersion;       // Current pin version
    DWORD            m_dwReporterTag;   // Reporter tag for WMI logging
    
public:
    
    CBaseFilter(
        const TCHAR *pName,     // Object description
        LPUNKNOWN    pUnk,      // IUnknown of delegating object
        CCritSec    *pLock,     // Object who maintains lock
        REFCLSID     clsid);     // The clsid to be used to serialize this filter
    
    CBaseFilter(
        const TCHAR *pName,     // Object description
        LPUNKNOWN    pUnk,      // IUnknown of delegating object
        CCritSec    *pLock,     // Object who maintains lock
        REFCLSID     clsid,     // The clsid to be used to serialize this filter
        DWORD        dwReporterTag);       // The reporter tag for WMI logging

    CBaseFilter(
        TCHAR     *pName,       // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
        REFCLSID   clsid,       // The clsid to be used to serialize this filter
        HRESULT   *phr);        // General OLE return code

    CBaseFilter(
        TCHAR     *pName,       // Object description
        LPUNKNOWN pUnk,         // IUnknown of delegating object
        CCritSec  *pLock,       // Object who maintains lock
        REFCLSID   clsid,       // The clsid to be used to serialize this filter
        HRESULT   *phr,         // General OLE return code
        DWORD      dwReporterTag);       // The reporter tag for WMI logging
    
    ~CBaseFilter();
    
    DECLARE_IUNKNOWN
        
        // override this to say what interfaces we support where
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
#ifdef DEBUG
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
#endif
    
    //
    // --- IPersist method ---
    //
    
    STDMETHODIMP GetClassID(CLSID *pClsID);
    
    // --- IMediaFilter methods ---
    
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
    
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    
    STDMETHODIMP GetSyncSource(IReferenceClock **pClock);
    
    
    // override Stop and Pause so we can activate the pins.
    // Note that Run will call Pause first if activation needed.
    // Override these if you want to activate your filter rather than
    // your pins.
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    
    // the start parameter is the difference to be added to the
    // sample's stream time to get the reference time for
    // its presentation
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    
    // --- helper methods ---
    
    // return the current stream time - ie find out what
    // stream time should be appearing now
    virtual HRESULT StreamTime(CRefTime& rtStream);
    
    // Is the filter currently active?
    BOOL IsActive() {
        CAutoLock cObjectLock(m_pLock);
        return ((m_State == State_Paused) || (m_State == State_Running));
    };
    
    // Is this filter stopped (without locking)
    BOOL IsStopped() {
        return (m_State == State_Stopped);
    };
    
    //
    // --- IBaseFilter methods ---
    //
    
    // pin enumerator
    STDMETHODIMP EnumPins(
        IEnumPins ** ppEnum);
    
    
    // default behaviour of FindPin assumes pin ids are their names
    STDMETHODIMP FindPin(
        LPCWSTR Id,
        IPin ** ppPin
        );
    
    STDMETHODIMP QueryFilterInfo(
        FILTER_INFO * pInfo);
    
    STDMETHODIMP JoinFilterGraph(
        IFilterGraph * pGraph,
        LPCWSTR pName);
    
    // return a Vendor information string. Optional - may return E_NOTIMPL.
    // memory returned should be freed using CoTaskMemFree
    // default implementation returns E_NOTIMPL
    STDMETHODIMP QueryVendorInfo(
        LPWSTR* pVendorInfo
        );
    
    // --- helper methods ---
    
    // send an event notification to the filter graph if we know about it.
    // returns S_OK if delivered, S_FALSE if the filter graph does not sink
    // events, or an error otherwise.
    HRESULT NotifyEvent(
        long EventCode,
        LONG_PTR EventParam1,
        LONG_PTR EventParam2);
    
    // return the filter graph we belong to
    IFilterGraph *GetFilterGraph() {
        return m_pGraph;
    }
    
    // Request reconnect
    // pPin is the pin to reconnect
    // pmt is the type to reconnect with - can be NULL
    // Calls ReconnectEx on the filter graph
    HRESULT ReconnectPin(IPin *pPin, AM_MEDIA_TYPE const *pmt);
    
    // find out the current pin version (used by enumerators)
    virtual LONG GetPinVersion();
    void IncrementPinVersion();
    
    // you need to supply these to access the pins from the enumerator
    // and for default Stop and Pause/Run activation.
    virtual int GetPinCount() PURE;
    virtual CBasePin *GetPin(int n) PURE;

    DWORD GetReporterTag( void ) const
    {
        return m_dwReporterTag;
    }

    //Return the current Action from the Filter Graph
    HRESULT GetFilterGraphAction(UINT *puiAction);

    // --- IAMovieSetup methods ---
    
    STDMETHODIMP Register();    // ask filter to register itself
    STDMETHODIMP Unregister();  // and unregister itself
    
    // --- setup helper methods ---
    // (override to return filters setup data)
    
    virtual LPAMOVIESETUP_FILTER GetSetupData(){ return NULL; }
    
};


//=====================================================================
//=====================================================================
// Defines CBasePin
//
// Abstract class that supports the basics of IPin
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBasePin : public CUnknown, public IPin, public IQualityControl
{
    
protected:
    
    WCHAR *         m_pName;                // This pin's name
    IPin            *m_Connected;               // Pin we have connected to
    CMediaType      m_mt;                       // Media type of connection
    PIN_DIRECTION   m_dir;                      // Direction of this pin
    CCritSec        *m_pLock;                   // Object we use for locking
    BOOL            m_bRunTimeError;            // Run time error generated
    CBaseFilter    *m_pFilter;                  // Filter we were created by
    IQualityControl *m_pQSink;                  // Target for Quality messages
    LONG            m_TypeVersion;              // Holds current type version
    
    CRefTime        m_tStart;                   // time from NewSegment call
    CRefTime        m_tStop;                    // time from NewSegment
    double          m_dRate;                    // rate from NewSegment
    
#ifdef DEBUG
    LONG            m_cRef;                     // Ref count tracing
#endif
    
    // displays pin connection information
    
#ifdef DEBUG
    void DisplayPinInfo(IPin *pReceivePin);
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt);
#else
    void DisplayPinInfo(IPin *pReceivePin) {};
    void DisplayTypeInfo(IPin *pPin, const CMediaType *pmt) {};
#endif
    
    // used to agree a media type for a pin connection
    
    // given a specific media type, attempt a connection (includes
    // checking that the type is acceptable to this pin)
    HRESULT
        AttemptConnection(
        IPin* pReceivePin,      // connect to this pin
        const CMediaType* pmt   // using this type
        );
    
    // try all the media types in this enumerator - for each that
    // we accept, try to connect using ReceiveConnection.
    HRESULT TryMediaTypes(
        IPin *pReceivePin,      // connect to this pin
        const CMediaType *pmt,        // proposed type from Connect
        IEnumMediaTypes *pEnum);    // try this enumerator
    
    // establish a connection with a suitable mediatype. Needs to
    // propose a media type if the pmt pointer is null or partially
    // specified - use TryMediaTypes on both our and then the other pin's
    // enumerator until we find one that works.
    HRESULT AgreeMediaType(
        IPin *pReceivePin,      // connect to this pin
        const CMediaType *pmt);       // proposed type from Connect
    
public:
    
    CBasePin(
        TCHAR *pObjectName,         // Object description
        CBaseFilter *pFilter,       // Owning filter who knows about pins
        CCritSec *pLock,            // Object who implements the lock
        HRESULT *phr,               // General OLE return code
        LPCWSTR pName,              // Pin name for us
        PIN_DIRECTION dir);         // Either PINDIR_INPUT or PINDIR_OUTPUT
    
    virtual ~CBasePin();
    
    DECLARE_IUNKNOWN
        
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    
    // --- IPin methods ---
    
    // take lead role in establishing a connection. Media type pointer
    // may be null, or may point to partially-specified mediatype
    // (subtype or format type may be GUID_NULL).
    STDMETHODIMP Connect(
        IPin * pReceivePin,
        const AM_MEDIA_TYPE *pmt   // optional media type
        );
    
    // (passive) accept a connection from another pin
    STDMETHODIMP ReceiveConnection(
        IPin * pConnector,      // this is the initiating connecting pin
        const AM_MEDIA_TYPE *pmt   // this is the media type we will exchange
        );
    
    STDMETHODIMP Disconnect();
    
    STDMETHODIMP ConnectedTo(IPin **pPin);
    
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);
    
    STDMETHODIMP QueryPinInfo(
        PIN_INFO * pInfo
        );
    
    STDMETHODIMP QueryDirection(
        PIN_DIRECTION * pPinDir
        );
    
    STDMETHODIMP QueryId(
        LPWSTR * Id
        );
    
    // does the pin support this media type
    STDMETHODIMP QueryAccept(
        const AM_MEDIA_TYPE *pmt
        );
    
    // return an enumerator for this pins preferred media types
    STDMETHODIMP EnumMediaTypes(
        IEnumMediaTypes **ppEnum
        );
    
    // return an array of IPin* - the pins that this pin internally connects to
    // All pins put in the array must be AddReffed (but no others)
    // Errors: "Can't say" - FAIL, not enough slots - return S_FALSE
    // Default: return E_NOTIMPL
    // The filter graph will interpret NOT_IMPL as any input pin connects to
    // all visible output pins and vice versa.
    // apPin can be NULL if nPin==0 (not otherwise).
    STDMETHODIMP QueryInternalConnections(
        __in_ecount(*nPin) IPin* *apPin,     // array of IPin*
        ULONG *nPin       // on input, the number of slots
        // on output  the number of pins
        ) { return E_NOTIMPL; }
    
    // Called when no more data will be sent
    STDMETHODIMP EndOfStream(void);
    
    // Begin/EndFlush still PURE
    
    // NewSegment notifies of the start/stop/rate applying to the data
    // about to be received. Default implementation records data and
    // returns S_OK.
    // Override this to pass downstream.
    STDMETHODIMP NewSegment(
        REFERENCE_TIME tStart,
        REFERENCE_TIME tStop,
        double dRate);
    
    //================================================================================
    // IQualityControl methods
    //================================================================================
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    
    STDMETHODIMP SetSink(IQualityControl * piqc);
    
    // --- helper methods ---
    
    // Returns true if the pin is connected. false otherwise.
    BOOL IsConnected(void) {return (m_Connected != NULL); };
    // Return the pin this is connected to (if any)
    IPin * GetConnected() { return m_Connected; };
    
    // Check if our filter is currently stopped
    BOOL IsStopped() {
        return (m_pFilter->m_State == State_Stopped);
    };
    
    // find out the current type version (used by enumerators)
    virtual LONG GetMediaTypeVersion();
    void IncrementTypeVersion();
    
    // switch the pin to active (paused or running) mode
    // not an error to call this if already active
    virtual HRESULT Active(void);
    
    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);
    
    // Notify of Run() from filter
    virtual HRESULT Run(REFERENCE_TIME tStart);
    
    // check if the pin can support this specific proposed type and format
    virtual HRESULT CheckMediaType(const CMediaType *) PURE;
    
    // set the connection to use this format (previously agreed)
    virtual HRESULT SetMediaType(const CMediaType *);
    
    // check that the connection is ok before verifying it
    // can be overridden eg to check what interfaces will be supported.
    virtual HRESULT CheckConnect(IPin *);
    
    // Set and release resources required for a connection
    virtual HRESULT BreakConnect();
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    
    // returns the preferred formats for a pin
    virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);
    
    // access to NewSegment values
    REFERENCE_TIME CurrentStopTime() {
        return m_tStop;
    }
    REFERENCE_TIME CurrentStartTime() {
        return m_tStart;
    }
    double CurrentRate() {
        return m_dRate;
    }
    
    //  Access name
    LPWSTR Name() { return m_pName; };
    
};


//=====================================================================
//=====================================================================
// Defines CEnumPins
//
// Pin enumerator class that works by calling CBaseFilter. This interface
// is provided by CBaseFilter::EnumPins and calls GetPinCount() and
// GetPin() to enumerate existing pins. Needs to be a separate object so
// that it can be cloned (creating an existing object at the same
// position in the enumeration)
//
// NOTE It overrides the non delegating IUnknown so that it can not
// only keep it's own reference counting lifetime but it will also still
// delegate to the outer owner. This ensures the owner is around all the
// time we are
//=====================================================================
//=====================================================================

class CEnumPins : public IEnumPins      // The interface we support
{
    int m_Position;                 // Current ordinal position
    int m_PinCount;                 // Number of pins available
    CBaseFilter *m_pFilter;         // The filter who owns us
    LONG m_Version;                 // Pin version information
    LONG m_cRef;
    
    typedef CGenericList<CBasePin> CPinList;
    
    CPinList m_PinCache;        // These pointers have not been AddRef'ed and
    // so they should not be dereferenced.  They are
    // merely kept to ID which pins have been enumerated.
    
#ifdef DEBUG
    DWORD m_dwCookie;
#endif
    
    /* If while we are retrieving a pin for example from the filter an error
    occurs we assume that our internal state is stale with respect to the
    filter (someone may have deleted all the pins). We can check before
    starting whether or not the operation is likely to fail by asking the
    filter what it's current version number is. If the filter has not
    overriden the GetPinVersion method then this will always match */
    
    BOOL AreWeOutOfSync() {
        return (m_pFilter->GetPinVersion() == m_Version ? FALSE : TRUE);
    };
    
    /* This method performs the same operations as Reset, except is does not clear
    the cache of pins already enumerated. */
    
    STDMETHODIMP Refresh();
    
public:
    
    CEnumPins(
        CBaseFilter *pFilter,
        CEnumPins *pEnumPins);
    
    virtual ~CEnumPins();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IEnumPins
    STDMETHODIMP Next(
        ULONG cPins,         // place this many pins...
        IPin ** ppPins,      // ...in this array of IPin*
        ULONG * pcFetched    // actual count passed returned here
        );
    
    STDMETHODIMP Skip(ULONG cPins);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumPins **ppEnum);
    
    
};


//=====================================================================
//=====================================================================
// Defines CEnumMediaTypes
//
// Enumerates the preferred formats for input and output pins
//=====================================================================
//=====================================================================

class CEnumMediaTypes : public IEnumMediaTypes    // The interface we support
{
    int m_Position;           // Current ordinal position
    CBasePin *m_pPin;         // The pin who owns us
    LONG m_Version;           // Media type version value
    LONG m_cRef;
#ifdef DEBUG
    DWORD m_dwCookie;
#endif
    
    /* The media types a filter supports can be quite dynamic so we add to
    the general IEnumXXXX interface the ability to be signaled when they
    change via an event handle the connected filter supplies. Until the
    Reset method is called after the state changes all further calls to
    the enumerator (except Reset) will return E_UNEXPECTED error code */
    
    BOOL AreWeOutOfSync() {
        return (m_pPin->GetMediaTypeVersion() == m_Version ? FALSE : TRUE);
    };
    
public:
    
    CEnumMediaTypes(
        CBasePin *pPin,
        CEnumMediaTypes *pEnumMediaTypes);
    
    virtual ~CEnumMediaTypes();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // IEnumMediaTypes
    STDMETHODIMP Next(
        ULONG cMediaTypes,          // place this many pins...
        AM_MEDIA_TYPE ** ppMediaTypes,  // ...in this array
        ULONG * pcFetched           // actual count passed
        );
    
    STDMETHODIMP Skip(ULONG cMediaTypes);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumMediaTypes **ppEnum);
};




//=====================================================================
//=====================================================================
// Defines CBaseOutputPin
//
// class derived from CBasePin that can pass buffers to a connected pin
// that supports IMemInputPin. Supports IPin.
//
// Derive your output pin from this.
//
//=====================================================================
//=====================================================================

class  AM_NOVTABLE CBaseOutputPin : public CBasePin
{
    
protected:
    
    IMemAllocator *m_pAllocator;
    IMemInputPin *m_pInputPin;        // interface on the downstreaminput pin
    // set up in CheckConnect when we connect.
    
public:
    
    CBaseOutputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);
    
    // override CompleteConnect() so we can negotiate an allocator
    virtual HRESULT CompleteConnect(IPin *pReceivePin);
    
    // negotiate the allocator and its buffer size/count and other properties
    // Calls DecideBufferSize to set properties
    virtual HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);
    
    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking.
    // The allocator properties passed in are those requested by the
    // input pin - use eg the alignment and prefix members if you have
    // no preference on these.
    virtual HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
        ) PURE;
    
    // returns an empty sample buffer from the allocator
    virtual HRESULT GetDeliveryBuffer(IMediaSample ** ppSample,
        REFERENCE_TIME * pStartTime,
        REFERENCE_TIME * pEndTime,
        DWORD dwFlags);
    
    // deliver a filled-in sample to the connected input pin
    // note - you need to release it after calling this. The receiving
    // pin will addref the sample if it needs to hold it beyond the
    // call.
    virtual HRESULT Deliver(IMediaSample *);
    
    // override this to control the connection
    virtual HRESULT InitAllocator(IMemAllocator **ppAlloc);
    HRESULT CheckConnect(IPin *pPin);
    HRESULT BreakConnect();
    
    // override to call Commit and Decommit
    HRESULT Active(void);
    HRESULT Inactive(void);
    
    // we have a default handling of EndOfStream which is to return
    // an error, since this should be called on input pins only
    STDMETHODIMP EndOfStream(void);
    
    // called from elsewhere in our filter to pass EOS downstream to
    // our connected input pin
    virtual HRESULT DeliverEndOfStream(void);
    
    // same for Begin/EndFlush - we handle Begin/EndFlush since it
    // is an error on an output pin, and we have Deliver methods to
    // call the methods on the connected pin
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
    virtual HRESULT DeliverBeginFlush(void);
    virtual HRESULT DeliverEndFlush(void);
    
    // deliver NewSegment to connected pin - you will need to
    // override this if you queue any data in your output pin.
    virtual HRESULT DeliverNewSegment(
        REFERENCE_TIME tStart,
        REFERENCE_TIME tStop,
        double dRate);
    
    //================================================================================
    // IQualityControl methods
    //================================================================================
    
    // All inherited from CBasePin and not overridden here.
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    // STDMETHODIMP SetSink(IQualityControl * piqc);
};


//=====================================================================
//=====================================================================
// Defines CBaseInputPin
//
// derive your standard input pin from this.
// you need to supply GetMediaType and CheckConnect etc (see CBasePin),
// and you need to supply Receive to do something more useful.
//
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseInputPin : public CBasePin,
public IMemInputPin
{
    
protected:
    
    IMemAllocator *m_pAllocator;    // Default memory allocator
    
    // allocator is read-only, so received samples
    // cannot be modified (probably only relevant to in-place
    // transforms
    BYTE m_bReadOnly;
    
    //private:  this should really be private... only the MPEG code
    // currently looks at it directly and it should use IsFlushing().
    // in flushing state (between BeginFlush and EndFlush)
    // if TRUE, all Receives are returned with S_FALSE
    BYTE m_bFlushing;
    
    // Sample properties - initalized in Receive
    AM_SAMPLE2_PROPERTIES m_SampleProps;
    
public:
    
    CBaseInputPin(
        TCHAR *pObjectName,
        CBaseFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr,
        LPCWSTR pName);
    
    virtual ~CBaseInputPin();
    
    DECLARE_IUNKNOWN
        
        // override this to publicise our interfaces
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    
    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
    
    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(
        IMemAllocator * pAllocator,
        BOOL bReadOnly);
    
    // override to release our stored allocator
    STDMETHODIMP Disconnect();
    
    // do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);
    
    // do something with these media samples
    STDMETHODIMP ReceiveMultiple (
        IMediaSample **pSamples,
        long nSamples,
        long *nSamplesProcessed);
    
    // See if Receive() blocks
    STDMETHODIMP ReceiveCanBlock();
    
    // Default handling for BeginFlush - call at the beginning
    // of your implementation (makes sure that all Receive calls
    // fail). After calling this, you need to free any queued data
    // and then call downstream.
    STDMETHODIMP BeginFlush(void);
    
    // default handling for EndFlush - call at end of your implementation
    // - before calling this, ensure that there is no queued data and no thread
    // pushing any more without a further receive, then call downstream,
    // then call this method to clear the m_bFlushing flag and re-enable
    // receives
    STDMETHODIMP EndFlush(void);
    
    // this method is optional (can return E_NOTIMPL).
    // default implementation returns E_NOTIMPL. Override if you have
    // specific alignment or prefix needs, but could use an upstream
    // allocator
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
    
    // helper method to check the read-only flag
    BOOL IsReadOnly() {
        return m_bReadOnly;
    };
    
    // helper method to see if we are flushing
    BOOL IsFlushing() {
        return m_bFlushing;
    };
    
    //  Override this for checking whether it's OK to process samples
    //  Also call this from EndOfStream.
    virtual HRESULT CheckStreaming();
    
    // Pass a Quality notification on to the appropriate sink
    HRESULT PassNotify(Quality& q);
    
    
    //================================================================================
    // IQualityControl methods (from CBasePin)
    //================================================================================
    
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    
    // no need to override:
    // STDMETHODIMP SetSink(IQualityControl * piqc);
    
    
    // switch the pin to inactive state - may already be inactive
    virtual HRESULT Inactive(void);
    
    // Return sample properties pointer
    AM_SAMPLE2_PROPERTIES * SampleProps() {
        ASSERT(m_SampleProps.cbData != 0);
        return &m_SampleProps;
    }
};



//=====================================================================
//=====================================================================
// Memory allocators
//
// the shared memory transport between pins requires the input pin
// to provide a memory allocator that can provide sample objects. A
// sample object supports the IMediaSample interface.
//
// CBaseAllocator handles the management of free and busy samples. It
// allocates CMediaSample objects. CBaseAllocator is an abstract class:
// in particular it has no method of initializing the list of free
// samples. CMemAllocator is derived from CBaseAllocator and initializes
// the list of samples using memory from the standard IMalloc interface.
//
// If you want your buffers to live in some special area of memory,
// derive your allocator object from CBaseAllocator. If you derive your
// IMemInputPin interface object from CBaseMemInputPin, you will get
// CMemAllocator-based allocation etc for free and will just need to
// supply the Receive handling, and media type / format negotiation.
//=====================================================================
//=====================================================================


//=====================================================================
//=====================================================================
// Defines CMediaSample
//
// an object of this class supports IMediaSample and represents a buffer
// for media data with some associated properties. Releasing it returns
// it to a freelist managed by a CBaseAllocator derived object.
//=====================================================================
//=====================================================================

class CMediaSample : public IMediaSample2    // The interface we support
{
    
protected:
    
    friend class CBaseAllocator;
    
    /*  Values for dwFlags - these are used for backward compatiblity
    only now - use AM_SAMPLE_xxx
    */
    enum { Sample_SyncPoint       = 0x01,   /* Is this a sync point */
        Sample_Preroll         = 0x02,   /* Is this a preroll sample */
        Sample_Discontinuity   = 0x04,   /* Set if start of new segment */
        Sample_TypeChanged     = 0x08,   /* Has the type changed */
        Sample_TimeValid       = 0x10,   /* Set if time is valid */
        Sample_MediaTimeValid  = 0x20,   /* Is the media time valid */
        Sample_TimeDiscontinuity = 0x40, /* Time discontinuity */
        Sample_StopValid       = 0x100,  /* Stop time valid */
        Sample_ValidFlags      = 0x1FF
    };
    
    /* Properties, the media sample class can be a container for a format
    change in which case we take a copy of a type through the SetMediaType
    interface function and then return it when GetMediaType is called. As
    we do no internal processing on it we leave it as a pointer */
    
    DWORD            m_dwFlags;         /* Flags for this sample */
                                        /* Type specific flags are packed
                                        into the top word
    */
    DWORD            m_dwTypeSpecificFlags; /* Media type specific flags */
    LPBYTE           m_pBuffer;         /* Pointer to the complete buffer */
    LONG             m_lActual;         /* Length of data in this sample */
    LONG             m_cbBuffer;        /* Size of the buffer */
    CBaseAllocator  *m_pAllocator;      /* The allocator who owns us */
    CMediaSample     *m_pNext;          /* Chaining in free list */
    REFERENCE_TIME   m_Start;           /* Start sample time */
    REFERENCE_TIME   m_End;             /* End sample time */
    LONGLONG         m_MediaStart;      /* Real media start position */
    LONG             m_MediaEnd;        /* A difference to get the end */
    AM_MEDIA_TYPE    *m_pMediaType;     /* Media type change data */
    DWORD            m_dwStreamId;      /* Stream id */
public:
    LONG             m_cRef;            /* Reference count */
    
    
public:
    
    CMediaSample(
        TCHAR *pName,
        CBaseAllocator *pAllocator,
        HRESULT *phr,
        LPBYTE pBuffer = NULL,
        LONG length = 0);
    
    virtual ~CMediaSample();
    
    /* Note the media sample does not delegate to its owner */
    
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // set the buffer pointer and length. Used by allocators that
    // want variable sized pointers or pointers into already-read data.
    // This is only available through a CMediaSample* not an IMediaSample*
    // and so cannot be changed by clients.
    HRESULT SetPointer(BYTE * ptr, LONG cBytes);
    
    // Get me a read/write pointer to this buffer's memory.
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    
    STDMETHODIMP_(LONG) GetSize(void);
    
    // get the stream time at which this sample should start and finish.
    STDMETHODIMP GetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
        );
    
    // Set the stream time at which this sample should start and finish.
    STDMETHODIMP SetTime(
        REFERENCE_TIME * pTimeStart,     // put time here
        REFERENCE_TIME * pTimeEnd
        );
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    
    // these allow for limited format changes in band
    
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    
    // returns S_OK if there is a discontinuity in the data (this same is
    // not a continuation of the previous stream of data
    // - there has been a seek).
    STDMETHODIMP IsDiscontinuity(void);
    // set the discontinuity property - TRUE if this sample is not a
    // continuation, but a new sample after a seek.
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    
    // get the media times for this sample
    STDMETHODIMP GetMediaTime(
        LONGLONG * pTimeStart,
        LONGLONG * pTimeEnd
        );
    
    // Set the media times for this sample
    STDMETHODIMP SetMediaTime(
        LONGLONG * pTimeStart,
        LONGLONG * pTimeEnd
        );
    
    // Set and get properties (IMediaSample2)
    STDMETHODIMP GetProperties(
        DWORD cbProperties,
        BYTE * pbProperties
        );
    
    STDMETHODIMP SetProperties(
        DWORD cbProperties,
        const BYTE * pbProperties
        );
};


//=====================================================================
//=====================================================================
// Defines CBaseAllocator
//
// Abstract base class that manages a list of media samples
//
// This class provides support for getting buffers from the free list,
// including handling of commit and (asynchronous) decommit.
//
// Derive from this class and override the Alloc and Free functions to
// allocate your CMediaSample (or derived) objects and add them to the
// free list, preparing them as necessary.
//=====================================================================
//=====================================================================

class AM_NOVTABLE CBaseAllocator : public CUnknown,         // A non delegating IUnknown
#ifndef UNDER_CE
public IMemAllocator,    // The interface we support
#else
public IMemAllocator2,    // The interface we support
#endif
public CCritSec          // Provides object locking
{
    class CSampleList;
    friend class CSampleList;
    
    /*  how we get at protected member in CMediaSample */
    static CMediaSample * &NextSample(CMediaSample *pSample)
    {
        return pSample->m_pNext;
    };
    
    /*  Mini list class for the free list */
    class CSampleList
    {
    public:
        CSampleList() : m_List(NULL), m_nOnList(0) {};
#ifdef DEBUG
        ~CSampleList()
        {
            ASSERT(m_nOnList == 0);
        };
#endif
        CMediaSample *Head() const { return m_List; };
        CMediaSample *Next(CMediaSample *pSample) const { return CBaseAllocator::NextSample(pSample); };
        int GetCount() const { return m_nOnList; };
        void Add(CMediaSample *pSample)
        {
            ASSERT(pSample != NULL);
            CBaseAllocator::NextSample(pSample) = m_List;
            m_List = pSample;
            m_nOnList++;
        };
        CMediaSample *RemoveHead()
        {
            CMediaSample *pSample = m_List;
            if (pSample != NULL) {
                m_List = CBaseAllocator::NextSample(m_List);
                m_nOnList--;
            }
            return pSample;
        };
        void Remove(CMediaSample *pSample);
        
    public:
        CMediaSample *m_List;
        int           m_nOnList;
    };
    protected:
        
        CSampleList m_lFree;        // Free list
        
                                    /*  Note to overriders of CBaseAllocator.
                                    
                                      We use a lazy signalling mechanism for waiting for samples.
                                      This means we don't call the OS if no waits occur.
                                      
                                        In order to implement this:
                                        
                                          1. When a new sample is added to m_lFree call NotifySample() which
                                          calls ReleaseSemaphore on m_hSem with a count of m_lWaiting and
                                          sets m_lWaiting to 0.
                                          This must all be done holding the allocator's critical section.
                                          
                                            2. When waiting for a sample call SetWaiting() which increments
                                            m_lWaiting BEFORE leaving the allocator's critical section.
                                            
                                              3. Actually wait by calling WaitForSingleObject(m_hSem, INFINITE)
                                              having left the allocator's critical section.  The effect of
                                              this is to remove 1 from the semaphore's count.  You MUST call
                                              this once having incremented m_lWaiting.
                                              
                                                The following are then true when the critical section is not held :
                                                (let nWaiting = number about to wait or waiting)
                                                
                                                  (1) if (m_lFree.GetCount() != 0) then (m_lWaiting == 0)
                                                  (2) m_lWaiting + Semaphore count == nWaiting
                                                  
                                                    We would deadlock if
                                                    nWaiting != 0 &&
                                                    m_lFree.GetCount() != 0 &&
                                                    Semaphore count == 0
                                                    
                                                      But from (1) if m_lFree.GetCount() != 0 then m_lWaiting == 0 so
                                                      from (2) Semaphore count == nWaiting (which is non-0) so the
                                                      deadlock can't happen.
        */
        
        HANDLE m_hSem;              // For signalling
        long m_lWaiting;            // Waiting for a free element
        long m_lCount;              // how many buffers we have agreed to provide
        long m_lAllocated;          // how many buffers are currently allocated
        long m_lSize;               // agreed size of each buffer
        long m_lAlignment;          // agreed alignment
        long m_lPrefix;             // agreed prefix (preceeds GetPointer() value)
        BOOL m_bChanged;            // Have the buffer requirements changed
        
        // if true, we are decommitted and can't allocate memory
        BOOL m_bCommitted;
        // if true, the decommit has happened, but we haven't called Free yet
        // as there are still outstanding buffers
        BOOL m_bDecommitInProgress;
        
        // called to decommit the memory when the last buffer is freed
        // pure virtual - need to override this
        virtual void Free(void) PURE;
        
        // override to allocate the memory when commit called
        virtual HRESULT Alloc(void);
        
    public:
        
        CBaseAllocator(TCHAR *, LPUNKNOWN, HRESULT *, BOOL bEvent = TRUE);
        virtual ~CBaseAllocator();
        
        DECLARE_IUNKNOWN
            
            // override this to publicise our interfaces
            STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
        
        STDMETHODIMP SetProperties(
            ALLOCATOR_PROPERTIES* pRequest,
            ALLOCATOR_PROPERTIES* pActual);
        
        // return the properties actually being used on this allocator
        STDMETHODIMP GetProperties(
            ALLOCATOR_PROPERTIES* pProps);
        
        // override Commit to allocate memory. We handle the GetBuffer
        //state changes
        STDMETHODIMP Commit();
        
        // override this to handle the memory freeing. We handle any outstanding
        // GetBuffer calls
        STDMETHODIMP Decommit();
        
        // get container for a sample. Blocking, synchronous call to get the
        // next free buffer (as represented by an IMediaSample interface).
        // on return, the time etc properties will be invalid, but the buffer
        // pointer and size will be correct. The two time parameters are
        // optional and either may be NULL, they may alternatively be set to
        // the start and end times the sample will have attached to it
        // bPrevFramesSkipped is not used (used only by the video renderer's
        // allocator where it affects quality management in direct draw).
        
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
            REFERENCE_TIME * pStartTime,
            REFERENCE_TIME * pEndTime,
            DWORD dwFlags);
        
        // final release of a CMediaSample will call this
        STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
        // obsolete:: virtual void PutOnFreeList(CMediaSample * pSample);
        
#ifdef UNDER_CE
        //From IMemAllocator2
        //get current number of busy samples in the pool
        STDMETHODIMP GetBusyCount(DWORD *pdwBusyCount);
        
        //get current number of free samples
        STDMETHODIMP GetFreeCount(DWORD *pdwFreeCount);
#endif
        
        // Notify that a sample is available
        void NotifySample();
        
        // Notify that we're waiting for a sample
        void SetWaiting() { m_lWaiting++; };
};


//=====================================================================
//=====================================================================
// Defines CMemAllocator
//
// this is an allocator based on CBaseAllocator that allocates sample
// buffers in main memory (from 'new'). You must call SetProperties
// before calling Commit.
//
// we don't free the memory when going into Decommit state. The simplest
// way to implement this without complicating CBaseAllocator is to
// have a Free() function, called to go into decommit state, that does
// nothing and a ReallyFree function called from our destructor that
// actually frees the memory.
//=====================================================================
//=====================================================================

//  Make me one from quartz.dll
STDAPI CreateMemoryAllocator(IMemAllocator **ppAllocator);

class CMemAllocator : public CBaseAllocator
{
    
protected:
    
    LPBYTE m_pBuffer;           // combined memory for all buffers
    
    // override to free the memory when decommit completes
    // - we actually do nothing, and save the memory until deletion.
    void Free(void);
    
    // called from the destructor (and from Alloc if changing size/count) to
    // actually free up the memory
    void ReallyFree(void);
    
    // overriden to allocate the memory when commit called
    HRESULT Alloc(void);
    
public:
    /* This goes in the factory template table to create new instances */
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    
    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest,
        ALLOCATOR_PROPERTIES* pActual);
    
    CMemAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMemAllocator();
};

// helper used by IAMovieSetup implementation
STDAPI
AMovieSetupRegisterFilter( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper *                  pIFM
                          , BOOL                             bRegister  );


#endif /* __FILTER__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amovie.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for amovie.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __amovie_h__
#define __amovie_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveMovie_FWD_DEFINED__
#define __IActiveMovie_FWD_DEFINED__
typedef interface IActiveMovie IActiveMovie;
#endif 	/* __IActiveMovie_FWD_DEFINED__ */


#ifndef __IActiveMovie2_FWD_DEFINED__
#define __IActiveMovie2_FWD_DEFINED__
typedef interface IActiveMovie2 IActiveMovie2;
#endif 	/* __IActiveMovie2_FWD_DEFINED__ */


#ifndef __IActiveMovie3_FWD_DEFINED__
#define __IActiveMovie3_FWD_DEFINED__
typedef interface IActiveMovie3 IActiveMovie3;
#endif 	/* __IActiveMovie3_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "enums.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_amovie_0000_0000 */
/* [local] */ 

typedef /* [public] */ 
enum WindowSizeConstants
    {	amvOriginalSize	= 0,
	amvDoubleOriginalSize	= ( amvOriginalSize + 1 ) ,
	amvOneSixteenthScreen	= ( amvDoubleOriginalSize + 1 ) ,
	amvOneFourthScreen	= ( amvOneSixteenthScreen + 1 ) ,
	amvOneHalfScreen	= ( amvOneFourthScreen + 1 ) 
    } 	WindowSizeConstants;

typedef /* [public] */ 
enum StateConstants
    {	amvNotLoaded	= -1,
	amvStopped	= ( amvNotLoaded + 1 ) ,
	amvPaused	= ( amvStopped + 1 ) ,
	amvRunning	= ( amvPaused + 1 ) 
    } 	StateConstants;

typedef /* [public] */ 
enum DisplayModeConstants
    {	amvTime	= 0,
	amvFrames	= ( amvTime + 1 ) 
    } 	DisplayModeConstants;

typedef /* [public] */ 
enum AppearanceConstants
    {	amvFlat	= 0,
	amv3D	= ( amvFlat + 1 ) 
    } 	AppearanceConstants;

typedef /* [public] */ 
enum BorderStyleConstants
    {	amvNone	= 0,
	amvFixedSingle	= ( amvNone + 1 ) 
    } 	BorderStyleConstants;



extern RPC_IF_HANDLE __MIDL_itf_amovie_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_amovie_0000_0000_v0_0_s_ifspec;

#ifndef __IActiveMovie_INTERFACE_DEFINED__
#define __IActiveMovie_INTERFACE_DEFINED__

/* interface IActiveMovie */
/* [unique][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IActiveMovie;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05589fa2-c356-11ce-bf01-00aa0055595a")
    IActiveMovie : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceWidth( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceHeight( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Author( 
            /* [retval][out] */ BSTR *pbstrAuthor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pbstrCopyright) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rating( 
            /* [retval][out] */ BSTR *pbstrRating) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayCount( 
            /* [retval][out] */ long *pPlayCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PlayCount( 
            /* [in] */ long PlayCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionStart( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionStart( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionEnd( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionEnd( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentState( 
            /* [retval][out] */ StateConstants *pState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableContextMenu( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowDisplay( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowDisplay( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowPositionControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowPositionControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowSelectionControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowSelectionControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTracker( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTracker( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnablePositionControls( 
            /* [retval][out] */ VARIANT_BOOL *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnablePositionControls( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableSelectionControls( 
            /* [retval][out] */ VARIANT_BOOL *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableSelectionControls( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableTracker( 
            /* [retval][out] */ VARIANT_BOOL *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableTracker( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowHideDisplay( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowHideDisplay( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowHideControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowHideControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayMode( 
            /* [retval][out] */ DisplayModeConstants *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayMode( 
            /* [in] */ DisplayModeConstants Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowChangeDisplayMode( 
            /* [retval][out] */ VARIANT_BOOL *fAllow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowChangeDisplayMode( 
            /* [in] */ VARIANT_BOOL Allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FilterGraph( 
            /* [retval][out] */ IUnknown **ppFilterGraph) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FilterGraph( 
            /* [in] */ IUnknown *pFilterGraph) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FilterGraphDispatch( 
            /* [retval][out] */ IDispatch **pDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayForeColor( 
            /* [retval][out] */ OLE_COLOR *ForeColor) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayForeColor( 
            /* [in] */ OLE_COLOR ForeColor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayBackColor( 
            /* [retval][out] */ OLE_COLOR *BackColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayBackColor( 
            /* [in] */ OLE_COLOR BackColor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MovieWindowSize( 
            /* [retval][out] */ WindowSizeConstants *WindowSize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_MovieWindowSize( 
            /* [in] */ WindowSizeConstants WindowSize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FullScreenMode( 
            /* [retval][out] */ VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FullScreenMode( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoStart( 
            /* [retval][out] */ VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoStart( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoRewind( 
            /* [retval][out] */ VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoRewind( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_hWnd( 
            /* [retval][out] */ long *hWnd) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ AppearanceConstants *pAppearance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants Appearance) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ BorderStyleConstants *pBorderStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants BorderStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL Enabled) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_Info( 
            /* [retval][out] */ long *ppInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveMovieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveMovie * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveMovie * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveMovie * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IActiveMovie * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IActiveMovie * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IActiveMovie * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IActiveMovie * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IActiveMovie * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IActiveMovie * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveMovie * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IActiveMovie * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            IActiveMovie * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            IActiveMovie * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IActiveMovie * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IActiveMovie * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IActiveMovie * This,
            /* [retval][out] */ double *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IActiveMovie * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IActiveMovie * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            IActiveMovie * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            IActiveMovie * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionStart )( 
            IActiveMovie * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionStart )( 
            IActiveMovie * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionEnd )( 
            IActiveMovie * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionEnd )( 
            IActiveMovie * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            IActiveMovie * This,
            /* [retval][out] */ StateConstants *pState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IActiveMovie * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IActiveMovie * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IActiveMovie * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IActiveMovie * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IActiveMovie * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IActiveMovie * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowDisplay )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowDisplay )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPositionControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowPositionControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowSelectionControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowSelectionControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTracker )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTracker )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePositionControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePositionControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSelectionControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSelectionControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTracker )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTracker )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideDisplay )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideDisplay )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideControls )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideControls )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            IActiveMovie * This,
            /* [retval][out] */ DisplayModeConstants *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            IActiveMovie * This,
            /* [in] */ DisplayModeConstants Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplayMode )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *fAllow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplayMode )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraph )( 
            IActiveMovie * This,
            /* [retval][out] */ IUnknown **ppFilterGraph);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FilterGraph )( 
            IActiveMovie * This,
            /* [in] */ IUnknown *pFilterGraph);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraphDispatch )( 
            IActiveMovie * This,
            /* [retval][out] */ IDispatch **pDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayForeColor )( 
            IActiveMovie * This,
            /* [retval][out] */ OLE_COLOR *ForeColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayForeColor )( 
            IActiveMovie * This,
            /* [in] */ OLE_COLOR ForeColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayBackColor )( 
            IActiveMovie * This,
            /* [retval][out] */ OLE_COLOR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayBackColor )( 
            IActiveMovie * This,
            /* [in] */ OLE_COLOR BackColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MovieWindowSize )( 
            IActiveMovie * This,
            /* [retval][out] */ WindowSizeConstants *WindowSize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MovieWindowSize )( 
            IActiveMovie * This,
            /* [in] */ WindowSizeConstants WindowSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IActiveMovie * This,
            /* [retval][out] */ long *hWnd);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IActiveMovie * This,
            /* [retval][out] */ AppearanceConstants *pAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IActiveMovie * This,
            /* [in] */ AppearanceConstants Appearance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IActiveMovie * This,
            /* [retval][out] */ BorderStyleConstants *pBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IActiveMovie * This,
            /* [in] */ BorderStyleConstants BorderStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IActiveMovie * This,
            /* [retval][out] */ VARIANT_BOOL *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IActiveMovie * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            IActiveMovie * This,
            /* [retval][out] */ long *ppInfo);
        
        END_INTERFACE
    } IActiveMovieVtbl;

    interface IActiveMovie
    {
        CONST_VTBL struct IActiveMovieVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveMovie_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveMovie_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveMovie_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveMovie_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IActiveMovie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IActiveMovie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IActiveMovie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IActiveMovie_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define IActiveMovie_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IActiveMovie_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IActiveMovie_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IActiveMovie_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define IActiveMovie_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define IActiveMovie_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define IActiveMovie_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define IActiveMovie_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define IActiveMovie_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define IActiveMovie_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define IActiveMovie_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define IActiveMovie_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define IActiveMovie_get_Duration(This,pValue)	\
    ( (This)->lpVtbl -> get_Duration(This,pValue) ) 

#define IActiveMovie_get_CurrentPosition(This,pValue)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pValue) ) 

#define IActiveMovie_put_CurrentPosition(This,Value)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,Value) ) 

#define IActiveMovie_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define IActiveMovie_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define IActiveMovie_get_SelectionStart(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionStart(This,pValue) ) 

#define IActiveMovie_put_SelectionStart(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionStart(This,Value) ) 

#define IActiveMovie_get_SelectionEnd(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionEnd(This,pValue) ) 

#define IActiveMovie_put_SelectionEnd(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionEnd(This,Value) ) 

#define IActiveMovie_get_CurrentState(This,pState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pState) ) 

#define IActiveMovie_get_Rate(This,pValue)	\
    ( (This)->lpVtbl -> get_Rate(This,pValue) ) 

#define IActiveMovie_put_Rate(This,Value)	\
    ( (This)->lpVtbl -> put_Rate(This,Value) ) 

#define IActiveMovie_get_Volume(This,pValue)	\
    ( (This)->lpVtbl -> get_Volume(This,pValue) ) 

#define IActiveMovie_put_Volume(This,Value)	\
    ( (This)->lpVtbl -> put_Volume(This,Value) ) 

#define IActiveMovie_get_Balance(This,pValue)	\
    ( (This)->lpVtbl -> get_Balance(This,pValue) ) 

#define IActiveMovie_put_Balance(This,Value)	\
    ( (This)->lpVtbl -> put_Balance(This,Value) ) 

#define IActiveMovie_get_EnableContextMenu(This,pEnable)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnable) ) 

#define IActiveMovie_put_EnableContextMenu(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,Enable) ) 

#define IActiveMovie_get_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_ShowDisplay(This,Show) ) 

#define IActiveMovie_put_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_ShowDisplay(This,Show) ) 

#define IActiveMovie_get_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowControls(This,Show) ) 

#define IActiveMovie_put_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowControls(This,Show) ) 

#define IActiveMovie_get_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowPositionControls(This,Show) ) 

#define IActiveMovie_put_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowPositionControls(This,Show) ) 

#define IActiveMovie_get_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowSelectionControls(This,Show) ) 

#define IActiveMovie_put_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowSelectionControls(This,Show) ) 

#define IActiveMovie_get_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> get_ShowTracker(This,Show) ) 

#define IActiveMovie_put_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> put_ShowTracker(This,Show) ) 

#define IActiveMovie_get_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnablePositionControls(This,Enable) ) 

#define IActiveMovie_put_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnablePositionControls(This,Enable) ) 

#define IActiveMovie_get_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie_put_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie_get_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableTracker(This,Enable) ) 

#define IActiveMovie_put_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableTracker(This,Enable) ) 

#define IActiveMovie_get_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideDisplay(This,Show) ) 

#define IActiveMovie_put_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideDisplay(This,Show) ) 

#define IActiveMovie_get_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideControls(This,Show) ) 

#define IActiveMovie_put_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideControls(This,Show) ) 

#define IActiveMovie_get_DisplayMode(This,pValue)	\
    ( (This)->lpVtbl -> get_DisplayMode(This,pValue) ) 

#define IActiveMovie_put_DisplayMode(This,Value)	\
    ( (This)->lpVtbl -> put_DisplayMode(This,Value) ) 

#define IActiveMovie_get_AllowChangeDisplayMode(This,fAllow)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplayMode(This,fAllow) ) 

#define IActiveMovie_put_AllowChangeDisplayMode(This,Allow)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplayMode(This,Allow) ) 

#define IActiveMovie_get_FilterGraph(This,ppFilterGraph)	\
    ( (This)->lpVtbl -> get_FilterGraph(This,ppFilterGraph) ) 

#define IActiveMovie_put_FilterGraph(This,pFilterGraph)	\
    ( (This)->lpVtbl -> put_FilterGraph(This,pFilterGraph) ) 

#define IActiveMovie_get_FilterGraphDispatch(This,pDispatch)	\
    ( (This)->lpVtbl -> get_FilterGraphDispatch(This,pDispatch) ) 

#define IActiveMovie_get_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie_put_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie_get_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> get_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie_put_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> put_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie_get_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> get_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie_put_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> put_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie_get_FullScreenMode(This,pEnable)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,pEnable) ) 

#define IActiveMovie_put_FullScreenMode(This,Enable)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,Enable) ) 

#define IActiveMovie_get_AutoStart(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pEnable) ) 

#define IActiveMovie_put_AutoStart(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoStart(This,Enable) ) 

#define IActiveMovie_get_AutoRewind(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pEnable) ) 

#define IActiveMovie_put_AutoRewind(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,Enable) ) 

#define IActiveMovie_get_hWnd(This,hWnd)	\
    ( (This)->lpVtbl -> get_hWnd(This,hWnd) ) 

#define IActiveMovie_get_Appearance(This,pAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,pAppearance) ) 

#define IActiveMovie_put_Appearance(This,Appearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,Appearance) ) 

#define IActiveMovie_get_BorderStyle(This,pBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,pBorderStyle) ) 

#define IActiveMovie_put_BorderStyle(This,BorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,BorderStyle) ) 

#define IActiveMovie_get_Enabled(This,pEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pEnabled) ) 

#define IActiveMovie_put_Enabled(This,Enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,Enabled) ) 

#define IActiveMovie_get_Info(This,ppInfo)	\
    ( (This)->lpVtbl -> get_Info(This,ppInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveMovie_INTERFACE_DEFINED__ */


#ifndef __IActiveMovie2_INTERFACE_DEFINED__
#define __IActiveMovie2_INTERFACE_DEFINED__

/* interface IActiveMovie2 */
/* [unique][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_IActiveMovie2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6CD6554-E9CB-11d0-821F-00A0C91F9CA0")
    IActiveMovie2 : public IActiveMovie
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSoundCardEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ ReadyStateConstants *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveMovie2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveMovie2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveMovie2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveMovie2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IActiveMovie2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IActiveMovie2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IActiveMovie2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IActiveMovie2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IActiveMovie2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IActiveMovie2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveMovie2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IActiveMovie2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IActiveMovie2 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IActiveMovie2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IActiveMovie2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IActiveMovie2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            IActiveMovie2 * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionStart )( 
            IActiveMovie2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionStart )( 
            IActiveMovie2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionEnd )( 
            IActiveMovie2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionEnd )( 
            IActiveMovie2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            IActiveMovie2 * This,
            /* [retval][out] */ StateConstants *pState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IActiveMovie2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IActiveMovie2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IActiveMovie2 * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IActiveMovie2 * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowDisplay )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowDisplay )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPositionControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowPositionControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowSelectionControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowSelectionControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTracker )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTracker )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePositionControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePositionControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSelectionControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSelectionControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTracker )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTracker )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideDisplay )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideDisplay )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideControls )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideControls )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            IActiveMovie2 * This,
            /* [retval][out] */ DisplayModeConstants *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            IActiveMovie2 * This,
            /* [in] */ DisplayModeConstants Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplayMode )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *fAllow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplayMode )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraph )( 
            IActiveMovie2 * This,
            /* [retval][out] */ IUnknown **ppFilterGraph);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FilterGraph )( 
            IActiveMovie2 * This,
            /* [in] */ IUnknown *pFilterGraph);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraphDispatch )( 
            IActiveMovie2 * This,
            /* [retval][out] */ IDispatch **pDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayForeColor )( 
            IActiveMovie2 * This,
            /* [retval][out] */ OLE_COLOR *ForeColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayForeColor )( 
            IActiveMovie2 * This,
            /* [in] */ OLE_COLOR ForeColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayBackColor )( 
            IActiveMovie2 * This,
            /* [retval][out] */ OLE_COLOR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayBackColor )( 
            IActiveMovie2 * This,
            /* [in] */ OLE_COLOR BackColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MovieWindowSize )( 
            IActiveMovie2 * This,
            /* [retval][out] */ WindowSizeConstants *WindowSize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MovieWindowSize )( 
            IActiveMovie2 * This,
            /* [in] */ WindowSizeConstants WindowSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *hWnd);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IActiveMovie2 * This,
            /* [retval][out] */ AppearanceConstants *pAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IActiveMovie2 * This,
            /* [in] */ AppearanceConstants Appearance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IActiveMovie2 * This,
            /* [retval][out] */ BorderStyleConstants *pBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IActiveMovie2 * This,
            /* [in] */ BorderStyleConstants BorderStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IActiveMovie2 * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            IActiveMovie2 * This,
            /* [retval][out] */ long *ppInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsSoundCardEnabled )( 
            IActiveMovie2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            IActiveMovie2 * This,
            /* [retval][out] */ ReadyStateConstants *pValue);
        
        END_INTERFACE
    } IActiveMovie2Vtbl;

    interface IActiveMovie2
    {
        CONST_VTBL struct IActiveMovie2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveMovie2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveMovie2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveMovie2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveMovie2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IActiveMovie2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IActiveMovie2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IActiveMovie2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IActiveMovie2_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define IActiveMovie2_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IActiveMovie2_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IActiveMovie2_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IActiveMovie2_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define IActiveMovie2_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define IActiveMovie2_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define IActiveMovie2_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define IActiveMovie2_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define IActiveMovie2_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define IActiveMovie2_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define IActiveMovie2_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define IActiveMovie2_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define IActiveMovie2_get_Duration(This,pValue)	\
    ( (This)->lpVtbl -> get_Duration(This,pValue) ) 

#define IActiveMovie2_get_CurrentPosition(This,pValue)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pValue) ) 

#define IActiveMovie2_put_CurrentPosition(This,Value)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,Value) ) 

#define IActiveMovie2_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define IActiveMovie2_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define IActiveMovie2_get_SelectionStart(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionStart(This,pValue) ) 

#define IActiveMovie2_put_SelectionStart(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionStart(This,Value) ) 

#define IActiveMovie2_get_SelectionEnd(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionEnd(This,pValue) ) 

#define IActiveMovie2_put_SelectionEnd(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionEnd(This,Value) ) 

#define IActiveMovie2_get_CurrentState(This,pState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pState) ) 

#define IActiveMovie2_get_Rate(This,pValue)	\
    ( (This)->lpVtbl -> get_Rate(This,pValue) ) 

#define IActiveMovie2_put_Rate(This,Value)	\
    ( (This)->lpVtbl -> put_Rate(This,Value) ) 

#define IActiveMovie2_get_Volume(This,pValue)	\
    ( (This)->lpVtbl -> get_Volume(This,pValue) ) 

#define IActiveMovie2_put_Volume(This,Value)	\
    ( (This)->lpVtbl -> put_Volume(This,Value) ) 

#define IActiveMovie2_get_Balance(This,pValue)	\
    ( (This)->lpVtbl -> get_Balance(This,pValue) ) 

#define IActiveMovie2_put_Balance(This,Value)	\
    ( (This)->lpVtbl -> put_Balance(This,Value) ) 

#define IActiveMovie2_get_EnableContextMenu(This,pEnable)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnable) ) 

#define IActiveMovie2_put_EnableContextMenu(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,Enable) ) 

#define IActiveMovie2_get_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_ShowDisplay(This,Show) ) 

#define IActiveMovie2_put_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_ShowDisplay(This,Show) ) 

#define IActiveMovie2_get_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowControls(This,Show) ) 

#define IActiveMovie2_put_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowControls(This,Show) ) 

#define IActiveMovie2_get_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowPositionControls(This,Show) ) 

#define IActiveMovie2_put_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowPositionControls(This,Show) ) 

#define IActiveMovie2_get_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowSelectionControls(This,Show) ) 

#define IActiveMovie2_put_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowSelectionControls(This,Show) ) 

#define IActiveMovie2_get_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> get_ShowTracker(This,Show) ) 

#define IActiveMovie2_put_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> put_ShowTracker(This,Show) ) 

#define IActiveMovie2_get_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnablePositionControls(This,Enable) ) 

#define IActiveMovie2_put_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnablePositionControls(This,Enable) ) 

#define IActiveMovie2_get_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie2_put_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie2_get_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableTracker(This,Enable) ) 

#define IActiveMovie2_put_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableTracker(This,Enable) ) 

#define IActiveMovie2_get_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideDisplay(This,Show) ) 

#define IActiveMovie2_put_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideDisplay(This,Show) ) 

#define IActiveMovie2_get_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideControls(This,Show) ) 

#define IActiveMovie2_put_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideControls(This,Show) ) 

#define IActiveMovie2_get_DisplayMode(This,pValue)	\
    ( (This)->lpVtbl -> get_DisplayMode(This,pValue) ) 

#define IActiveMovie2_put_DisplayMode(This,Value)	\
    ( (This)->lpVtbl -> put_DisplayMode(This,Value) ) 

#define IActiveMovie2_get_AllowChangeDisplayMode(This,fAllow)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplayMode(This,fAllow) ) 

#define IActiveMovie2_put_AllowChangeDisplayMode(This,Allow)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplayMode(This,Allow) ) 

#define IActiveMovie2_get_FilterGraph(This,ppFilterGraph)	\
    ( (This)->lpVtbl -> get_FilterGraph(This,ppFilterGraph) ) 

#define IActiveMovie2_put_FilterGraph(This,pFilterGraph)	\
    ( (This)->lpVtbl -> put_FilterGraph(This,pFilterGraph) ) 

#define IActiveMovie2_get_FilterGraphDispatch(This,pDispatch)	\
    ( (This)->lpVtbl -> get_FilterGraphDispatch(This,pDispatch) ) 

#define IActiveMovie2_get_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie2_put_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie2_get_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> get_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie2_put_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> put_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie2_get_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> get_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie2_put_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> put_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie2_get_FullScreenMode(This,pEnable)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,pEnable) ) 

#define IActiveMovie2_put_FullScreenMode(This,Enable)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,Enable) ) 

#define IActiveMovie2_get_AutoStart(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pEnable) ) 

#define IActiveMovie2_put_AutoStart(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoStart(This,Enable) ) 

#define IActiveMovie2_get_AutoRewind(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pEnable) ) 

#define IActiveMovie2_put_AutoRewind(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,Enable) ) 

#define IActiveMovie2_get_hWnd(This,hWnd)	\
    ( (This)->lpVtbl -> get_hWnd(This,hWnd) ) 

#define IActiveMovie2_get_Appearance(This,pAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,pAppearance) ) 

#define IActiveMovie2_put_Appearance(This,Appearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,Appearance) ) 

#define IActiveMovie2_get_BorderStyle(This,pBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,pBorderStyle) ) 

#define IActiveMovie2_put_BorderStyle(This,BorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,BorderStyle) ) 

#define IActiveMovie2_get_Enabled(This,pEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pEnabled) ) 

#define IActiveMovie2_put_Enabled(This,Enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,Enabled) ) 

#define IActiveMovie2_get_Info(This,ppInfo)	\
    ( (This)->lpVtbl -> get_Info(This,ppInfo) ) 


#define IActiveMovie2_IsSoundCardEnabled(This,pbSoundCard)	\
    ( (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard) ) 

#define IActiveMovie2_get_ReadyState(This,pValue)	\
    ( (This)->lpVtbl -> get_ReadyState(This,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveMovie2_INTERFACE_DEFINED__ */


#ifndef __IActiveMovie3_INTERFACE_DEFINED__
#define __IActiveMovie3_INTERFACE_DEFINED__

/* interface IActiveMovie3 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IActiveMovie3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("265EC140-AE62-11d1-8500-00A0C91F9CA0")
    IActiveMovie3 : public IActiveMovie2
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaPlayer( 
            /* [retval][out] */ IDispatch **ppDispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveMovie3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveMovie3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveMovie3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveMovie3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IActiveMovie3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IActiveMovie3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IActiveMovie3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IActiveMovie3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IActiveMovie3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Run )( 
            IActiveMovie3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveMovie3 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IActiveMovie3 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IActiveMovie3 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IActiveMovie3 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IActiveMovie3 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IActiveMovie3 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            IActiveMovie3 * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionStart )( 
            IActiveMovie3 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionStart )( 
            IActiveMovie3 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionEnd )( 
            IActiveMovie3 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionEnd )( 
            IActiveMovie3 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            IActiveMovie3 * This,
            /* [retval][out] */ StateConstants *pState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IActiveMovie3 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IActiveMovie3 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IActiveMovie3 * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IActiveMovie3 * This,
            /* [in] */ long Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowDisplay )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowDisplay )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPositionControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowPositionControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowSelectionControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowSelectionControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTracker )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTracker )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePositionControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePositionControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSelectionControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSelectionControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTracker )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTracker )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideDisplay )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideDisplay )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowHideControls )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowHideControls )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            IActiveMovie3 * This,
            /* [retval][out] */ DisplayModeConstants *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            IActiveMovie3 * This,
            /* [in] */ DisplayModeConstants Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplayMode )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *fAllow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplayMode )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraph )( 
            IActiveMovie3 * This,
            /* [retval][out] */ IUnknown **ppFilterGraph);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FilterGraph )( 
            IActiveMovie3 * This,
            /* [in] */ IUnknown *pFilterGraph);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FilterGraphDispatch )( 
            IActiveMovie3 * This,
            /* [retval][out] */ IDispatch **pDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayForeColor )( 
            IActiveMovie3 * This,
            /* [retval][out] */ OLE_COLOR *ForeColor);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayForeColor )( 
            IActiveMovie3 * This,
            /* [in] */ OLE_COLOR ForeColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayBackColor )( 
            IActiveMovie3 * This,
            /* [retval][out] */ OLE_COLOR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayBackColor )( 
            IActiveMovie3 * This,
            /* [in] */ OLE_COLOR BackColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MovieWindowSize )( 
            IActiveMovie3 * This,
            /* [retval][out] */ WindowSizeConstants *WindowSize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MovieWindowSize )( 
            IActiveMovie3 * This,
            /* [in] */ WindowSizeConstants WindowSize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FullScreenMode )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FullScreenMode )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_hWnd )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *hWnd);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            IActiveMovie3 * This,
            /* [retval][out] */ AppearanceConstants *pAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            IActiveMovie3 * This,
            /* [in] */ AppearanceConstants Appearance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            IActiveMovie3 * This,
            /* [retval][out] */ BorderStyleConstants *pBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            IActiveMovie3 * This,
            /* [in] */ BorderStyleConstants BorderStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IActiveMovie3 * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Info )( 
            IActiveMovie3 * This,
            /* [retval][out] */ long *ppInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsSoundCardEnabled )( 
            IActiveMovie3 * This,
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            IActiveMovie3 * This,
            /* [retval][out] */ ReadyStateConstants *pValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPlayer )( 
            IActiveMovie3 * This,
            /* [retval][out] */ IDispatch **ppDispatch);
        
        END_INTERFACE
    } IActiveMovie3Vtbl;

    interface IActiveMovie3
    {
        CONST_VTBL struct IActiveMovie3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveMovie3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IActiveMovie3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IActiveMovie3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IActiveMovie3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IActiveMovie3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IActiveMovie3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IActiveMovie3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IActiveMovie3_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define IActiveMovie3_Run(This)	\
    ( (This)->lpVtbl -> Run(This) ) 

#define IActiveMovie3_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IActiveMovie3_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IActiveMovie3_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define IActiveMovie3_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define IActiveMovie3_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define IActiveMovie3_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define IActiveMovie3_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define IActiveMovie3_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define IActiveMovie3_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define IActiveMovie3_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define IActiveMovie3_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define IActiveMovie3_get_Duration(This,pValue)	\
    ( (This)->lpVtbl -> get_Duration(This,pValue) ) 

#define IActiveMovie3_get_CurrentPosition(This,pValue)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pValue) ) 

#define IActiveMovie3_put_CurrentPosition(This,Value)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,Value) ) 

#define IActiveMovie3_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define IActiveMovie3_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define IActiveMovie3_get_SelectionStart(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionStart(This,pValue) ) 

#define IActiveMovie3_put_SelectionStart(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionStart(This,Value) ) 

#define IActiveMovie3_get_SelectionEnd(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionEnd(This,pValue) ) 

#define IActiveMovie3_put_SelectionEnd(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionEnd(This,Value) ) 

#define IActiveMovie3_get_CurrentState(This,pState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pState) ) 

#define IActiveMovie3_get_Rate(This,pValue)	\
    ( (This)->lpVtbl -> get_Rate(This,pValue) ) 

#define IActiveMovie3_put_Rate(This,Value)	\
    ( (This)->lpVtbl -> put_Rate(This,Value) ) 

#define IActiveMovie3_get_Volume(This,pValue)	\
    ( (This)->lpVtbl -> get_Volume(This,pValue) ) 

#define IActiveMovie3_put_Volume(This,Value)	\
    ( (This)->lpVtbl -> put_Volume(This,Value) ) 

#define IActiveMovie3_get_Balance(This,pValue)	\
    ( (This)->lpVtbl -> get_Balance(This,pValue) ) 

#define IActiveMovie3_put_Balance(This,Value)	\
    ( (This)->lpVtbl -> put_Balance(This,Value) ) 

#define IActiveMovie3_get_EnableContextMenu(This,pEnable)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnable) ) 

#define IActiveMovie3_put_EnableContextMenu(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,Enable) ) 

#define IActiveMovie3_get_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_ShowDisplay(This,Show) ) 

#define IActiveMovie3_put_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_ShowDisplay(This,Show) ) 

#define IActiveMovie3_get_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowControls(This,Show) ) 

#define IActiveMovie3_put_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowControls(This,Show) ) 

#define IActiveMovie3_get_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowPositionControls(This,Show) ) 

#define IActiveMovie3_put_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowPositionControls(This,Show) ) 

#define IActiveMovie3_get_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowSelectionControls(This,Show) ) 

#define IActiveMovie3_put_ShowSelectionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowSelectionControls(This,Show) ) 

#define IActiveMovie3_get_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> get_ShowTracker(This,Show) ) 

#define IActiveMovie3_put_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> put_ShowTracker(This,Show) ) 

#define IActiveMovie3_get_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnablePositionControls(This,Enable) ) 

#define IActiveMovie3_put_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnablePositionControls(This,Enable) ) 

#define IActiveMovie3_get_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie3_put_EnableSelectionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableSelectionControls(This,Enable) ) 

#define IActiveMovie3_get_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableTracker(This,Enable) ) 

#define IActiveMovie3_put_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableTracker(This,Enable) ) 

#define IActiveMovie3_get_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideDisplay(This,Show) ) 

#define IActiveMovie3_put_AllowHideDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideDisplay(This,Show) ) 

#define IActiveMovie3_get_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> get_AllowHideControls(This,Show) ) 

#define IActiveMovie3_put_AllowHideControls(This,Show)	\
    ( (This)->lpVtbl -> put_AllowHideControls(This,Show) ) 

#define IActiveMovie3_get_DisplayMode(This,pValue)	\
    ( (This)->lpVtbl -> get_DisplayMode(This,pValue) ) 

#define IActiveMovie3_put_DisplayMode(This,Value)	\
    ( (This)->lpVtbl -> put_DisplayMode(This,Value) ) 

#define IActiveMovie3_get_AllowChangeDisplayMode(This,fAllow)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplayMode(This,fAllow) ) 

#define IActiveMovie3_put_AllowChangeDisplayMode(This,Allow)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplayMode(This,Allow) ) 

#define IActiveMovie3_get_FilterGraph(This,ppFilterGraph)	\
    ( (This)->lpVtbl -> get_FilterGraph(This,ppFilterGraph) ) 

#define IActiveMovie3_put_FilterGraph(This,pFilterGraph)	\
    ( (This)->lpVtbl -> put_FilterGraph(This,pFilterGraph) ) 

#define IActiveMovie3_get_FilterGraphDispatch(This,pDispatch)	\
    ( (This)->lpVtbl -> get_FilterGraphDispatch(This,pDispatch) ) 

#define IActiveMovie3_get_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie3_put_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor) ) 

#define IActiveMovie3_get_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> get_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie3_put_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> put_DisplayBackColor(This,BackColor) ) 

#define IActiveMovie3_get_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> get_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie3_put_MovieWindowSize(This,WindowSize)	\
    ( (This)->lpVtbl -> put_MovieWindowSize(This,WindowSize) ) 

#define IActiveMovie3_get_FullScreenMode(This,pEnable)	\
    ( (This)->lpVtbl -> get_FullScreenMode(This,pEnable) ) 

#define IActiveMovie3_put_FullScreenMode(This,Enable)	\
    ( (This)->lpVtbl -> put_FullScreenMode(This,Enable) ) 

#define IActiveMovie3_get_AutoStart(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pEnable) ) 

#define IActiveMovie3_put_AutoStart(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoStart(This,Enable) ) 

#define IActiveMovie3_get_AutoRewind(This,pEnable)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pEnable) ) 

#define IActiveMovie3_put_AutoRewind(This,Enable)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,Enable) ) 

#define IActiveMovie3_get_hWnd(This,hWnd)	\
    ( (This)->lpVtbl -> get_hWnd(This,hWnd) ) 

#define IActiveMovie3_get_Appearance(This,pAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,pAppearance) ) 

#define IActiveMovie3_put_Appearance(This,Appearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,Appearance) ) 

#define IActiveMovie3_get_BorderStyle(This,pBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,pBorderStyle) ) 

#define IActiveMovie3_put_BorderStyle(This,BorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,BorderStyle) ) 

#define IActiveMovie3_get_Enabled(This,pEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pEnabled) ) 

#define IActiveMovie3_put_Enabled(This,Enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,Enabled) ) 

#define IActiveMovie3_get_Info(This,ppInfo)	\
    ( (This)->lpVtbl -> get_Info(This,ppInfo) ) 


#define IActiveMovie3_IsSoundCardEnabled(This,pbSoundCard)	\
    ( (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard) ) 

#define IActiveMovie3_get_ReadyState(This,pValue)	\
    ( (This)->lpVtbl -> get_ReadyState(This,pValue) ) 


#define IActiveMovie3_get_MediaPlayer(This,ppDispatch)	\
    ( (This)->lpVtbl -> get_MediaPlayer(This,ppDispatch) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IActiveMovie3_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amvideo.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Video related definitions and interfaces for ActiveMovie

#ifndef __AMVIDEO__
#define __AMVIDEO__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <ddraw.h>


// This is an interface on the video renderer that provides information about
// DirectDraw with respect to its use by the renderer. For example it allows
// an application to get details of the surface and any hardware capabilities
// that are available. It also allows someone to adjust the surfaces that the
// renderer should use and furthermore even set the DirectDraw instance. We
// allow someone to set the DirectDraw instance because DirectDraw can only
// be opened once per process so it helps resolve conflicts. There is some
// duplication in this interface as the hardware/emulated/FOURCCs available
// can all be found through the IDirectDraw interface, this interface allows
// simple access to that information without calling the DirectDraw provider
// itself. The AMDDS prefix is ActiveMovie DirectDraw Switches abbreviated.

#define AMDDS_NONE 0x00             // No use for DCI/DirectDraw
#define AMDDS_DCIPS 0x01            // Use DCI primary surface
#define AMDDS_PS 0x02               // Use DirectDraw primary
#define AMDDS_RGBOVR 0x04           // RGB overlay surfaces
#define AMDDS_YUVOVR 0x08           // YUV overlay surfaces
#define AMDDS_RGBOFF 0x10           // RGB offscreen surfaces
#define AMDDS_YUVOFF 0x20           // YUV offscreen surfaces
#define AMDDS_RGBFLP 0x40           // RGB flipping surfaces
#define AMDDS_YUVFLP 0x80           // YUV flipping surfaces
#define AMDDS_ALL 0xFF              // ALL the previous flags
#define AMDDS_DEFAULT AMDDS_ALL     // Use all available surfaces

#define AMDDS_YUV (AMDDS_YUVOFF | AMDDS_YUVOVR | AMDDS_YUVFLP)
#define AMDDS_RGB (AMDDS_RGBOFF | AMDDS_RGBOVR | AMDDS_RGBFLP)
#define AMDDS_PRIMARY (AMDDS_DCIPS | AMDDS_PS)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IDirectDrawVideo

DECLARE_INTERFACE_(IDirectDrawVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDirectDrawVideo methods

    STDMETHOD(GetSwitches)(THIS_ DWORD *pSwitches) PURE;
    STDMETHOD(SetSwitches)(THIS_ DWORD Switches) PURE;
    STDMETHOD(GetCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetEmulatedCaps)(THIS_ DDCAPS *pCaps) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ DDSURFACEDESC *pSurfaceDesc) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_ DWORD *pCount,DWORD *pCodes) PURE;
    STDMETHOD(SetDirectDraw)(THIS_ LPDIRECTDRAW pDirectDraw) PURE;
    STDMETHOD(GetDirectDraw)(THIS_ LPDIRECTDRAW *ppDirectDraw) PURE;
    STDMETHOD(GetSurfaceType)(THIS_ DWORD *pSurfaceType) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
    STDMETHOD(UseScanLine)(THIS_ long UseScanLine) PURE;
    STDMETHOD(CanUseScanLine)(THIS_ long *UseScanLine) PURE;
    STDMETHOD(UseOverlayStretch)(THIS_ long UseOverlayStretch) PURE;
    STDMETHOD(CanUseOverlayStretch)(THIS_ long *UseOverlayStretch) PURE;
    STDMETHOD(UseWhenFullScreen)(THIS_ long UseWhenFullScreen) PURE;
    STDMETHOD(WillUseFullScreen)(THIS_ long *UseWhenFullScreen) PURE;
};


// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IQualProp

DECLARE_INTERFACE_(IQualProp, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // Compare these with the functions in class CGargle in gargle.h

    STDMETHOD(get_FramesDroppedInRenderer)(THIS_ int *pcFrames) PURE;  // Out
    STDMETHOD(get_FramesDrawn)(THIS_ int *pcFramesDrawn) PURE;         // Out
    STDMETHOD(get_AvgFrameRate)(THIS_ int *piAvgFrameRate) PURE;       // Out
    STDMETHOD(get_Jitter)(THIS_ int *iJitter) PURE;                    // Out
    STDMETHOD(get_AvgSyncOffset)(THIS_ int *piAvg) PURE;               // Out
    STDMETHOD(get_DevSyncOffset)(THIS_ int *piDev) PURE;               // Out
};


// This interface allows an application or plug in distributor to control a
// full screen renderer. The Modex renderer supports this interface. When
// connected a renderer should load the display modes it has available
// The number of modes available can be obtained through CountModes. Then
// information on each individual mode is available by calling GetModeInfo
// and IsModeAvailable. An application may enable and disable any modes
// by calling the SetEnabled flag with OATRUE or OAFALSE (not C/C++ TRUE
// and FALSE values) - the current value may be queried by IsModeEnabled

// A more generic way of setting the modes enabled that is easier to use
// when writing applications is the clip loss factor. This defines the
// amount of video that can be lost when deciding which display mode to
// use. Assuming the decoder cannot compress the video then playing an
// MPEG file (say 352x288) into a 320x200 display will lose about 25% of
// the image. The clip loss factor specifies the upper range permissible.
// To allow typical MPEG video to be played in 320x200 it defaults to 25%

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideo

DECLARE_INTERFACE_(IFullScreenVideo, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;
};


// This adds the accelerator table capabilities in fullscreen. This is being
// added between the original runtime release and the full SDK release. We
// cannot just add the method to IFullScreenVideo as we don't want to force
// applications to have to ship the ActiveMovie support DLLs - this is very
// important to applications that plan on being downloaded over the Internet

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IFullScreenVideoEx

DECLARE_INTERFACE_(IFullScreenVideoEx, IFullScreenVideo)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IFullScreenVideo methods

    STDMETHOD(CountModes)(THIS_ long *pModes) PURE;
    STDMETHOD(GetModeInfo)(THIS_ long Mode,long *pWidth,long *pHeight,long *pDepth) PURE;
    STDMETHOD(GetCurrentMode)(THIS_ long *pMode) PURE;
    STDMETHOD(IsModeAvailable)(THIS_ long Mode) PURE;
    STDMETHOD(IsModeEnabled)(THIS_ long Mode) PURE;
    STDMETHOD(SetEnabled)(THIS_ long Mode,long bEnabled) PURE;
    STDMETHOD(GetClipFactor)(THIS_ long *pClipFactor) PURE;
    STDMETHOD(SetClipFactor)(THIS_ long ClipFactor) PURE;
    STDMETHOD(SetMessageDrain)(THIS_ HWND hwnd) PURE;
    STDMETHOD(GetMessageDrain)(THIS_ HWND *hwnd) PURE;
    STDMETHOD(SetMonitor)(THIS_ long Monitor) PURE;
    STDMETHOD(GetMonitor)(THIS_ long *Monitor) PURE;
    STDMETHOD(HideOnDeactivate)(THIS_ long Hide) PURE;
    STDMETHOD(IsHideOnDeactivate)(THIS) PURE;
    STDMETHOD(SetCaption)(THIS_ BSTR strCaption) PURE;
    STDMETHOD(GetCaption)(THIS_ BSTR *pstrCaption) PURE;
    STDMETHOD(SetDefault)(THIS) PURE;

    // IFullScreenVideoEx

    STDMETHOD(SetAcceleratorTable)(THIS_ HWND hwnd,HACCEL hAccel) PURE;
    STDMETHOD(GetAcceleratorTable)(THIS_ HWND *phwnd,HACCEL *phAccel) PURE;
    STDMETHOD(KeepPixelAspectRatio)(THIS_ long KeepAspect) PURE;
    STDMETHOD(IsKeepPixelAspectRatio)(THIS_ long *pKeepAspect) PURE;
};


// The SDK base classes contain a base video mixer class. Video mixing in a
// software environment is tricky because we typically have multiple streams
// each sending data at unpredictable times. To work with this we defined a
// pin that is the lead pin, when data arrives on this pin we do a mix. As
// an alternative we may not want to have a lead pin but output samples at
// predefined spaces, like one every 1/15 of a second, this interfaces also
// supports that mode of operations (there is a working video mixer sample)

// be nice to our friends in C
#undef INTERFACE
#define INTERFACE IBaseVideoMixer

DECLARE_INTERFACE_(IBaseVideoMixer, IUnknown)
{
    STDMETHOD(SetLeadPin)(THIS_ int iPin) PURE;
    STDMETHOD(GetLeadPin)(THIS_ int *piPin) PURE;
    STDMETHOD(GetInputPinCount)(THIS_ int *piPinCount) PURE;
    STDMETHOD(IsUsingClock)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetUsingClock)(THIS_ int bValue) PURE;
    STDMETHOD(GetClockPeriod)(THIS_ int *pbValue) PURE;
    STDMETHOD(SetClockPeriod)(THIS_ int bValue) PURE;
};

#define iPALETTE_COLORS 256     // Maximum colours in palette
#define iEGA_COLORS 16          // Number colours in EGA palette
#define iMASK_COLORS 3          // Maximum three components
#define iTRUECOLOR 16           // Minimum true colour device
#define iRED 0                  // Index position for RED mask
#define iGREEN 1                // Index position for GREEN mask
#define iBLUE 2                 // Index position for BLUE mask
#define iPALETTE 8              // Maximum colour depth using a palette
#define iMAXBITS 8              // Maximum bits per colour component


// Used for true colour images that also have a palette

typedef struct tag_TRUECOLORINFO {
    DWORD   dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;


// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagVIDEOINFOHEADER {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

} VIDEOINFOHEADER;

#define AMINTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define AMINTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define AMINTERLACE_UNUSED                  0x00000008  //
#define AMINTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define AMINTERLACE_FieldPatField1Only      0x00000000  // stream never contains a Field2
#define AMINTERLACE_FieldPatField2Only      0x00000010  // stream never contains a Field1
#define AMINTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define AMINTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define AMINTERLACE_DisplayModeMask         0x000000c0
#define AMINTERLACE_DisplayModeBobOnly      0x00000000
#define AMINTERLACE_DisplayModeWeaveOnly    0x00000040
#define AMINTERLACE_DisplayModeBobOrWeave   0x00000080

#define AMCOPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted


#define AMCONTROL_USED                      0x00000001
#define AMCONTROL_PAD_TO_4x3                0x00000002
#define AMCONTROL_PAD_TO_16x9               0x00000004

typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines
    DWORD               dwCopyProtectFlags; // use AMCOPYPROTECT_* defines
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display 
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD           dwControlFlags;
        DWORD           dwReserved1;
    };
    DWORD               dwReserved2;        // must be 0
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;


// make sure the pbmi is initialized before using these macros
#define TRUECOLOR(pbmi)  ((TRUECOLORINFO *)(((LPBYTE)&((pbmi)->bmiHeader)) \
                        + (pbmi)->bmiHeader.biSize))
#define COLORS(pbmi)    ((RGBQUAD *)(((LPBYTE)&((pbmi)->bmiHeader))     \
                        + (pbmi)->bmiHeader.biSize))
#define BITMASKS(pbmi)  ((DWORD *)(((LPBYTE)&((pbmi)->bmiHeader))   \
                        + (pbmi)->bmiHeader.biSize))

// All the image based filters use this to communicate their media types. It's
// centred principally around the BITMAPINFO. This structure always contains a
// BITMAPINFOHEADER followed by a number of other fields depending on what the
// BITMAPINFOHEADER contains. If it contains details of a palettised format it
// will be followed by one or more RGBQUADs defining the palette. If it holds
// details of a true colour format then it may be followed by a set of three
// DWORD bit masks that specify where the RGB data can be found in the image
// (For more information regarding BITMAPINFOs see the Win32 documentation)

// The rcSource and rcTarget fields are not for use by filters supplying the
// data. The destination (target) rectangle should be set to all zeroes. The
// source may also be zero filled or set with the dimensions of the video. So
// if the video is 352x288 pixels then set it to (0,0,352,288). These fields
// are mainly used by downstream filters that want to ask the source filter
// to place the image in a different position in an output buffer. So when
// using for example the primary surface the video renderer may ask a filter
// to place the video images in a destination position of (100,100,452,388)
// on the display since that's where the window is positioned on the display

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO;

// !!! WARNING !!!
// DO NOT use this structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagVIDEOINFO2 {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)
    DWORD           dwInterlaceFlags;
    DWORD           dwCopyProtectFlags;
    DWORD           dwPictAspectRatioX;
    DWORD           dwPictAspectRatioY; 
    DWORD           dwReserved1;
    DWORD           dwReserved2;

    BITMAPINFOHEADER bmiHeader;

    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];     // Colour palette
        DWORD           dwBitMasks[iMASK_COLORS];       // True colour masks
        TRUECOLORINFO   TrueColorInfo;                  // Both of the above
    };

} VIDEOINFO2;

// These macros define some standard bitmap format sizes

#define SIZE_EGA_PALETTE (iEGA_COLORS * sizeof(RGBQUAD))
#define SIZE_PALETTE (iPALETTE_COLORS * sizeof(RGBQUAD))
#define SIZE_MASKS (iMASK_COLORS * sizeof(DWORD))
#define SIZE_PREHEADER (FIELD_OFFSET(VIDEOINFOHEADER,bmiHeader))
#define SIZE_VIDEOHEADER (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER)
#define SIZE_PREHEADER2 (FIELD_OFFSET(VIDEOINFOHEADER2,bmiHeader))
#define SIZE_VIDEOHEADER2 (sizeof(BITMAPINFOHEADER) + SIZE_PREHEADER2)

// !!! for abnormal biSizes
// #define SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + SIZE_PREHEADER)

// DIBSIZE calculates the number of bytes required by an image

#define WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define _DIBSIZE(bi) (DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(_DIBSIZE(bi)) : _DIBSIZE(bi))

// This compares the bit masks between two VIDEOINFOHEADERs

#define BIT_MASKS_MATCH(pbmi1,pbmi2)                                \
    (((pbmi1)->dwBitMasks[iRED] == (pbmi2)->dwBitMasks[iRED]) &&        \
     ((pbmi1)->dwBitMasks[iGREEN] == (pbmi2)->dwBitMasks[iGREEN]) &&    \
     ((pbmi1)->dwBitMasks[iBLUE] == (pbmi2)->dwBitMasks[iBLUE]))

// These zero fill different parts of the VIDEOINFOHEADER structure

// Only use these macros for pbmi's with a normal BITMAPINFOHEADER biSize
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(pbmi)->dwBitFields,SIZE_MASKS))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi),SIZE_VIDEOHEADER))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(pbmi)->bmiColors,SIZE_PALETTE));

#if 0
// !!! This is the right way to do it, but may break existing code
#define RESET_MASKS(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
                            (pbmi)->bmiHeader.biSize,SIZE_MASKS)))
#define RESET_HEADER(pbmi) (ZeroMemory((PVOID)(pbmi), SIZE_PREHEADER +      \
                            sizeof(BITMAPINFOHEADER)))
#define RESET_PALETTE(pbmi) (ZeroMemory((PVOID)(((LPBYTE)(pbmi)->bmiHeader) + \
                            (pbmi)->bmiHeader.biSize,SIZE_PALETTE))
#endif

// Other (hopefully) useful bits and bobs

#define PALETTISED(pbmi) ((pbmi)->bmiHeader.biBitCount <= iPALETTE)
#define PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->bmiHeader.biBitCount)

#define BMI_PALETTISED(pbmi) ((pbmi)->biBitCount <= iPALETTE)
#define BMI_PALETTE_ENTRIES(pbmi) ((DWORD) 1 << (pbmi)->biBitCount)

// Returns the address of the BITMAPINFOHEADER from the VIDEOINFOHEADER/VIDEOINFOHEADER2
#define HEADER(pVideoInfo) (&(((VIDEOINFOHEADER *) (pVideoInfo))->bmiHeader))
#define HEADER2(pVideoInfo2) (&(((VIDEOINFOHEADER2 *) (pVideoInfo2))->bmiHeader))

// MPEG variant - includes a DWORD length followed by the
// video sequence header after the video header.
//
// The sequence header includes the sequence header start code and the
// quantization matrices associated with the first sequence header in the
// stream so is a maximum of 140 bytes long.

typedef struct tagMPEG1VIDEOINFO {

    VIDEOINFOHEADER hdr;                    // Compatible with VIDEOINFO
    DWORD           dwStartTimeCode;        // 25-bit Group of pictures time code
                                            // at start of data
    DWORD           cbSequenceHeader;       // Length in bytes of bSequenceHeader
    BYTE            bSequenceHeader[1];     // Sequence header including
                                            // quantization matrices if any
} MPEG1VIDEOINFO;

#define MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} ANALOGVIDEOINFO;

//
// AM_KSPROPSETID_FrameStep property set definitions
//
typedef enum {
        //  Step
    AM_PROPERTY_FRAMESTEP_STEP   = 0x01,
    AM_PROPERTY_FRAMESTEP_CANCEL = 0x02,

        //  S_OK for these 2 means we can - S_FALSE if we can't
        AM_PROPERTY_FRAMESTEP_CANSTEP = 0x03,
        AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE = 0x04
} AM_PROPERTY_FRAMESTEP;

typedef struct _AM_FRAMESTEP_STEP
{
    //  1 means step 1 frame forward
    //  0 is invalid
    //  n (n > 1) means skip n - 1 frames and show the nth
    DWORD dwFramesToStep;
} AM_FRAMESTEP_STEP;


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __AMVIDEO__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\appext.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************

    File: AppExt.h

    Some applications that support context menu extensions expose their
    object abstraction as an IDataObject.  The following definitions can be 
    used to describe the contents of that IDataObject.

    For example, the Contacts application exposes an IDataObject that contains
    a CEOID.  The CEOID can then be used in calls to Pocket Outlook Object Model
    (POOM) function calls, which are declared in the header file pimstore.h. 

    For example:

    #include "appext.h"
    #include "pimstore.h"
    
    FORMATETC fmt;
    STGMEDIUM stgmed;
    ItemRefArray *pira;
    CEOID oid;
    GUID * pguidObjectType;

    fmt.cfFormat = RegisterClipboardFormat(CFNAME_ITEMREFARRAY);
    fmt.lindex = -1;
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.tymed = TYMED_HGLOBAL;

    ((IDataObject*)GetSite())->GetData(&fmt, &stgmed);
    pira = (ItemRefArray*) stgmed->hGlobal;
    pguidObjectType = (GUID*) pira->rgRefs[0].pType;
    assert(*pguidObjectType == ITI_PimItemRef);
    oid = (CEOID)pira->rgRefs[0].pRef;

*/


#pragma once


typedef GUID ITEM_TYPE_ID;

struct ItemRef
{
    ITEM_TYPE_ID* pType; // identifies the type of object, and therefore the type of pRef
    void* pRef;
};

struct ItemRefArray
{
    int cRefs;
    ItemRef rgRefs[1]; // rgRefs has cRefs entries
};

#define CFNAME_ITEMREFARRAY TEXT("ItemRefArray")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\armintr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*armintr.h - definitions and declarations for ARM specific intrinsics
*
*Purpose:
*       This file contains constant definitions and external subroutine
*       declarations for the ARM specific intriniscs
*
****/

#ifndef _INC_ARMINTR
#define _INC_ARMINTR

#if defined(_M_ARM)

#ifdef __cplusplus
extern "C" {
#endif

int _AddSatInt(int, int);                           //qadd
int _DAddSatInt(int, int);                          //qdadd
int _DSubSatInt(int, int);                          //qsub
int _SubSatInt(int, int);                           //qdsub

int _SmulAddLo_SW_SL(int, int,int);                 //smlabb
int _SmulAddHi_SW_SL(int, int, int);                //smlatt
int _SmulAddHiLo_SW_SL(int, int, int);              //smlatb
int _SmulAddLoHi_SW_SL(int, int, int);              //smlabt

int _SmulLo_SW_SL(int, int);                        //smulbb
int _SmulHi_SW_SL(int, int);                        //smultt
int _SmulHiLo_SW_SL(int, int);                      //smultb
int _SmulLoHi_SW_SL(int, int);                      //sumlbt

__int64 _SmulAddLo_SW_SQ(__int64, int, int);        //smlalbb
__int64 _SmulAddHi_SW_SQ(__int64, int, int);        //smlaltt
__int64 _SmulAddHiLo_SW_SQ(__int64,int,int);        //smlaltb
__int64 _SmulAddLoHi_SW_SQ(__int64,int,int);        //smlalbt

int _SmulAddWLo_SW_SL(int, int, int);               //smlawb
int _SmulAddWHi_SW_SL(int, int, int);               //smlawt

int _SmulWLo_SW_SL(int, int);                       //smulwb
int _SmulWHi_SW_SL(int, int);                       //smulwt

void _PreLoad(unsigned long *addr);                 //pld

void _WriteCoProcessor(__int64,int);                //mrrc/mar
__int64 _ReadCoProcessor(int);                      //mcrr/mra
int  _MoveFromCoprocessor(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);              //mrc
int  _MoveFromCoprocessor2(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);             //mrc2
void _MoveToCoprocessor(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int);  //mcr
void _MoveToCoprocessor2(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int); //mcr2

void _SmulAdd_SL_ACC(int,int);                       //mia
void _SmulAddPack_2SW_ACC(int,int);                  //miaph
void _SmulAddLo_SW_ACC(int, int);                    //miabb
void _SmulAddHi_SW_ACC(int, int);                    //miatt
void _SmulAddHiLo_SW_ACC(int, int);                  //miatb
void _SmulAddLoHi_SW_ACC(int, int);                  //miabt

void __emit(const unsigned __int32);
unsigned int __gregister_get(const unsigned int);
void __gregister_set(const unsigned int, unsigned int);

int _ReadStatusReg(int);
unsigned int __swi(unsigned, ...);
void _WriteStatusReg(int,int,int);

#ifdef __cplusplus
}
#endif

#endif //defined(_M_ARM)

#endif //_INC_ARMINTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\amstream.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for amstream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __amstream_h__
#define __amstream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirectShowStream_FWD_DEFINED__
#define __IDirectShowStream_FWD_DEFINED__
typedef interface IDirectShowStream IDirectShowStream;
#endif 	/* __IDirectShowStream_FWD_DEFINED__ */


#ifndef __IAMMultiMediaStream_FWD_DEFINED__
#define __IAMMultiMediaStream_FWD_DEFINED__
typedef interface IAMMultiMediaStream IAMMultiMediaStream;
#endif 	/* __IAMMultiMediaStream_FWD_DEFINED__ */


#ifndef __IAMMediaStream_FWD_DEFINED__
#define __IAMMediaStream_FWD_DEFINED__
typedef interface IAMMediaStream IAMMediaStream;
#endif 	/* __IAMMediaStream_FWD_DEFINED__ */


#ifndef __IMediaStreamFilter_FWD_DEFINED__
#define __IMediaStreamFilter_FWD_DEFINED__
typedef interface IMediaStreamFilter IMediaStreamFilter;
#endif 	/* __IMediaStreamFilter_FWD_DEFINED__ */


#ifndef __IDirectDrawMediaSampleAllocator_FWD_DEFINED__
#define __IDirectDrawMediaSampleAllocator_FWD_DEFINED__
typedef interface IDirectDrawMediaSampleAllocator IDirectDrawMediaSampleAllocator;
#endif 	/* __IDirectDrawMediaSampleAllocator_FWD_DEFINED__ */


#ifndef __IDirectDrawMediaSample_FWD_DEFINED__
#define __IDirectDrawMediaSample_FWD_DEFINED__
typedef interface IDirectDrawMediaSample IDirectDrawMediaSample;
#endif 	/* __IDirectDrawMediaSample_FWD_DEFINED__ */


#ifndef __IAMMediaTypeStream_FWD_DEFINED__
#define __IAMMediaTypeStream_FWD_DEFINED__
typedef interface IAMMediaTypeStream IAMMediaTypeStream;
#endif 	/* __IAMMediaTypeStream_FWD_DEFINED__ */


#ifndef __IAMMediaTypeSample_FWD_DEFINED__
#define __IAMMediaTypeSample_FWD_DEFINED__
typedef interface IAMMediaTypeSample IAMMediaTypeSample;
#endif 	/* __IAMMediaTypeSample_FWD_DEFINED__ */


#ifndef __AMMultiMediaStream_FWD_DEFINED__
#define __AMMultiMediaStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class AMMultiMediaStream AMMultiMediaStream;
#else
typedef struct AMMultiMediaStream AMMultiMediaStream;
#endif /* __cplusplus */

#endif 	/* __AMMultiMediaStream_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_amstream_0000_0000 */
/* [local] */ 

#include <ddraw.h>
#include <mmstream.h>
#include <ddstream.h>
#include <austream.h>








enum __MIDL___MIDL_itf_amstream_0000_0000_0001
    {	AMMSF_NOGRAPHTHREAD	= 0x1
    } ;

enum __MIDL___MIDL_itf_amstream_0000_0000_0002
    {	AMMSF_ADDDEFAULTRENDERER	= 0x1,
	AMMSF_CREATEPEER	= 0x2
    } ;

enum __MIDL___MIDL_itf_amstream_0000_0000_0003
    {	AMMSF_RENDERTYPEMASK	= 0x3,
	AMMSF_RENDERTOEXISTING	= 0,
	AMMSF_RENDERALLSTREAMS	= 0x1,
	AMMSF_NORENDER	= 0x2,
	AMMSF_NOCLOCK	= 0x4,
	AMMSF_RUN	= 0x8
    } ;
typedef /* [public][public][public][public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_amstream_0000_0000_0004
    {	Disabled	= 0,
	ReadData	= 1,
	RenderData	= 2
    } 	OUTPUT_STATE;



extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_0000_v0_0_s_ifspec;

#ifndef __IDirectShowStream_INTERFACE_DEFINED__
#define __IDirectShowStream_INTERFACE_DEFINED__

/* interface IDirectShowStream */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDirectShowStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7DB01C96-C0C3-11d0-8FF1-00C04FD9189D")
    IDirectShowStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Video( 
            /* [retval][out] */ OUTPUT_STATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Video( 
            /* [in] */ OUTPUT_STATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Audio( 
            /* [retval][out] */ OUTPUT_STATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Audio( 
            /* [in] */ OUTPUT_STATE newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectShowStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectShowStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectShowStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectShowStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDirectShowStream * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDirectShowStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDirectShowStream * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDirectShowStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IDirectShowStream * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IDirectShowStream * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Video )( 
            IDirectShowStream * This,
            /* [retval][out] */ OUTPUT_STATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Video )( 
            IDirectShowStream * This,
            /* [in] */ OUTPUT_STATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Audio )( 
            IDirectShowStream * This,
            /* [retval][out] */ OUTPUT_STATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Audio )( 
            IDirectShowStream * This,
            /* [in] */ OUTPUT_STATE newVal);
        
        END_INTERFACE
    } IDirectShowStreamVtbl;

    interface IDirectShowStream
    {
        CONST_VTBL struct IDirectShowStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectShowStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectShowStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectShowStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectShowStream_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDirectShowStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDirectShowStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDirectShowStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDirectShowStream_get_FileName(This,pVal)	\
    ( (This)->lpVtbl -> get_FileName(This,pVal) ) 

#define IDirectShowStream_put_FileName(This,newVal)	\
    ( (This)->lpVtbl -> put_FileName(This,newVal) ) 

#define IDirectShowStream_get_Video(This,pVal)	\
    ( (This)->lpVtbl -> get_Video(This,pVal) ) 

#define IDirectShowStream_put_Video(This,newVal)	\
    ( (This)->lpVtbl -> put_Video(This,newVal) ) 

#define IDirectShowStream_get_Audio(This,pVal)	\
    ( (This)->lpVtbl -> get_Audio(This,pVal) ) 

#define IDirectShowStream_put_Audio(This,newVal)	\
    ( (This)->lpVtbl -> put_Audio(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectShowStream_INTERFACE_DEFINED__ */


#ifndef __IAMMultiMediaStream_INTERFACE_DEFINED__
#define __IAMMultiMediaStream_INTERFACE_DEFINED__

/* interface IAMMultiMediaStream */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMMultiMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595C-9A6F-11d0-8FDE-00C04FD9189D")
    IAMMultiMediaStream : public IMultiMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ STREAM_TYPE StreamType,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ IGraphBuilder *pFilterGraph) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterGraph( 
            /* [out] */ IGraphBuilder **ppGraphBuilder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilter( 
            /* [out] */ IMediaStreamFilter **ppFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMediaStream( 
            /* [in] */ IUnknown *pStreamObject,
            /* [in] */ const MSPID *PurposeId,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ IMediaStream **ppNewStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ LPCWSTR pszFileName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenMoniker( 
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Render( 
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMultiMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMultiMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMultiMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMultiMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMultiMediaStream * This,
            /* [optional][out] */ DWORD *pdwFlags,
            /* [optional][out] */ STREAM_TYPE *pStreamType);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAMMultiMediaStream * This,
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaStreams )( 
            IAMMultiMediaStream * This,
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_STATE *pCurrentState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_STATE NewState);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IAMMultiMediaStream * This,
            /* [out] */ STREAM_TIME *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_TIME SeekTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOfStreamEventHandle )( 
            IAMMultiMediaStream * This,
            /* [out] */ HANDLE *phEOS);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAMMultiMediaStream * This,
            /* [in] */ STREAM_TYPE StreamType,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ IGraphBuilder *pFilterGraph);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterGraph )( 
            IAMMultiMediaStream * This,
            /* [out] */ IGraphBuilder **ppGraphBuilder);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilter )( 
            IAMMultiMediaStream * This,
            /* [out] */ IMediaStreamFilter **ppFilter);
        
        HRESULT ( STDMETHODCALLTYPE *AddMediaStream )( 
            IAMMultiMediaStream * This,
            /* [in] */ IUnknown *pStreamObject,
            /* [in] */ const MSPID *PurposeId,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ IMediaStream **ppNewStream);
        
        HRESULT ( STDMETHODCALLTYPE *OpenFile )( 
            IAMMultiMediaStream * This,
            /* [in] */ LPCWSTR pszFileName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMoniker )( 
            IAMMultiMediaStream * This,
            /* [in] */ IBindCtx *pCtx,
            /* [in] */ IMoniker *pMoniker,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Render )( 
            IAMMultiMediaStream * This,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAMMultiMediaStreamVtbl;

    interface IAMMultiMediaStream
    {
        CONST_VTBL struct IAMMultiMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMultiMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMultiMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMultiMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMultiMediaStream_GetInformation(This,pdwFlags,pStreamType)	\
    ( (This)->lpVtbl -> GetInformation(This,pdwFlags,pStreamType) ) 

#define IAMMultiMediaStream_GetMediaStream(This,idPurpose,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,idPurpose,ppMediaStream) ) 

#define IAMMultiMediaStream_EnumMediaStreams(This,Index,ppMediaStream)	\
    ( (This)->lpVtbl -> EnumMediaStreams(This,Index,ppMediaStream) ) 

#define IAMMultiMediaStream_GetState(This,pCurrentState)	\
    ( (This)->lpVtbl -> GetState(This,pCurrentState) ) 

#define IAMMultiMediaStream_SetState(This,NewState)	\
    ( (This)->lpVtbl -> SetState(This,NewState) ) 

#define IAMMultiMediaStream_GetTime(This,pCurrentTime)	\
    ( (This)->lpVtbl -> GetTime(This,pCurrentTime) ) 

#define IAMMultiMediaStream_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IAMMultiMediaStream_Seek(This,SeekTime)	\
    ( (This)->lpVtbl -> Seek(This,SeekTime) ) 

#define IAMMultiMediaStream_GetEndOfStreamEventHandle(This,phEOS)	\
    ( (This)->lpVtbl -> GetEndOfStreamEventHandle(This,phEOS) ) 


#define IAMMultiMediaStream_Initialize(This,StreamType,dwFlags,pFilterGraph)	\
    ( (This)->lpVtbl -> Initialize(This,StreamType,dwFlags,pFilterGraph) ) 

#define IAMMultiMediaStream_GetFilterGraph(This,ppGraphBuilder)	\
    ( (This)->lpVtbl -> GetFilterGraph(This,ppGraphBuilder) ) 

#define IAMMultiMediaStream_GetFilter(This,ppFilter)	\
    ( (This)->lpVtbl -> GetFilter(This,ppFilter) ) 

#define IAMMultiMediaStream_AddMediaStream(This,pStreamObject,PurposeId,dwFlags,ppNewStream)	\
    ( (This)->lpVtbl -> AddMediaStream(This,pStreamObject,PurposeId,dwFlags,ppNewStream) ) 

#define IAMMultiMediaStream_OpenFile(This,pszFileName,dwFlags)	\
    ( (This)->lpVtbl -> OpenFile(This,pszFileName,dwFlags) ) 

#define IAMMultiMediaStream_OpenMoniker(This,pCtx,pMoniker,dwFlags)	\
    ( (This)->lpVtbl -> OpenMoniker(This,pCtx,pMoniker,dwFlags) ) 

#define IAMMultiMediaStream_Render(This,dwFlags)	\
    ( (This)->lpVtbl -> Render(This,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMultiMediaStream_INTERFACE_DEFINED__ */


#ifndef __IAMMediaStream_INTERFACE_DEFINED__
#define __IAMMediaStream_INTERFACE_DEFINED__

/* interface IAMMediaStream */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595D-9A6F-11d0-8FDE-00C04FD9189D")
    IAMMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pSourceObject,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ FILTER_STATE State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinAMMultiMediaStream( 
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilter( 
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JoinFilterGraph( 
            /* [in] */ IFilterGraph *pFilterGraph) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAMMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMediaStream * This,
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAMMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAMMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAMMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAMMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IAMMediaStream * This,
            /* [in] */ IUnknown *pSourceObject,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IAMMediaStream * This,
            /* [in] */ FILTER_STATE State);
        
        HRESULT ( STDMETHODCALLTYPE *JoinAMMultiMediaStream )( 
            IAMMediaStream * This,
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilter )( 
            IAMMediaStream * This,
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IAMMediaStream * This,
            /* [in] */ IFilterGraph *pFilterGraph);
        
        END_INTERFACE
    } IAMMediaStreamVtbl;

    interface IAMMediaStream
    {
        CONST_VTBL struct IAMMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    ( (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream) ) 

#define IAMMediaStream_GetInformation(This,pPurposeId,pType)	\
    ( (This)->lpVtbl -> GetInformation(This,pPurposeId,pType) ) 

#define IAMMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    ( (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags) ) 

#define IAMMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample) ) 

#define IAMMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    ( (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample) ) 

#define IAMMediaStream_SendEndOfStream(This,dwFlags)	\
    ( (This)->lpVtbl -> SendEndOfStream(This,dwFlags) ) 


#define IAMMediaStream_Initialize(This,pSourceObject,dwFlags,PurposeId,StreamType)	\
    ( (This)->lpVtbl -> Initialize(This,pSourceObject,dwFlags,PurposeId,StreamType) ) 

#define IAMMediaStream_SetState(This,State)	\
    ( (This)->lpVtbl -> SetState(This,State) ) 

#define IAMMediaStream_JoinAMMultiMediaStream(This,pAMMultiMediaStream)	\
    ( (This)->lpVtbl -> JoinAMMultiMediaStream(This,pAMMultiMediaStream) ) 

#define IAMMediaStream_JoinFilter(This,pMediaStreamFilter)	\
    ( (This)->lpVtbl -> JoinFilter(This,pMediaStreamFilter) ) 

#define IAMMediaStream_JoinFilterGraph(This,pFilterGraph)	\
    ( (This)->lpVtbl -> JoinFilterGraph(This,pFilterGraph) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaStream_INTERFACE_DEFINED__ */


#ifndef __IMediaStreamFilter_INTERFACE_DEFINED__
#define __IMediaStreamFilter_INTERFACE_DEFINED__

/* interface IMediaStreamFilter */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMediaStreamFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BEBE595E-9A6F-11d0-8FDE-00C04FD9189D")
    IMediaStreamFilter : public IBaseFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddMediaStream( 
            /* [in] */ IAMMediaStream *pAMMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaStream( 
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMediaStreams( 
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportSeeking( 
            /* [in] */ BOOL bRenderer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceTimeToStreamTime( 
            /* [out][in] */ REFERENCE_TIME *pTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentStreamTime( 
            /* [out] */ REFERENCE_TIME *pCurrentStreamTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitUntil( 
            /* [in] */ REFERENCE_TIME WaitStreamTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( 
            /* [in] */ BOOL bCancelEOS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndOfStream( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaStreamFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaStreamFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaStreamFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IMediaStreamFilter * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaStreamFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IMediaStreamFilter * This,
            REFERENCE_TIME tStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMediaStreamFilter * This,
            /* [in] */ DWORD dwMilliSecsTimeout,
            /* [out] */ FILTER_STATE *State);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncSource )( 
            IMediaStreamFilter * This,
            /* [in] */ IReferenceClock *pClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSource )( 
            IMediaStreamFilter * This,
            /* [out] */ IReferenceClock **pClock);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPins )( 
            IMediaStreamFilter * This,
            /* [out] */ IEnumPins **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindPin )( 
            IMediaStreamFilter * This,
            /* [string][in] */ LPCWSTR Id,
            /* [out] */ IPin **ppPin);
        
        HRESULT ( STDMETHODCALLTYPE *QueryFilterInfo )( 
            IMediaStreamFilter * This,
            /* [out] */ FILTER_INFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *JoinFilterGraph )( 
            IMediaStreamFilter * This,
            /* [in] */ IFilterGraph *pGraph,
            /* [string][in] */ LPCWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryVendorInfo )( 
            IMediaStreamFilter * This,
            /* [string][out] */ LPWSTR *pVendorInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddMediaStream )( 
            IMediaStreamFilter * This,
            /* [in] */ IAMMediaStream *pAMMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IMediaStreamFilter * This,
            /* [in] */ REFMSPID idPurpose,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMediaStreams )( 
            IMediaStreamFilter * This,
            /* [in] */ long Index,
            /* [out] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *SupportSeeking )( 
            IMediaStreamFilter * This,
            /* [in] */ BOOL bRenderer);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceTimeToStreamTime )( 
            IMediaStreamFilter * This,
            /* [out][in] */ REFERENCE_TIME *pTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentStreamTime )( 
            IMediaStreamFilter * This,
            /* [out] */ REFERENCE_TIME *pCurrentStreamTime);
        
        HRESULT ( STDMETHODCALLTYPE *WaitUntil )( 
            IMediaStreamFilter * This,
            /* [in] */ REFERENCE_TIME WaitStreamTime);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMediaStreamFilter * This,
            /* [in] */ BOOL bCancelEOS);
        
        HRESULT ( STDMETHODCALLTYPE *EndOfStream )( 
            IMediaStreamFilter * This);
        
        END_INTERFACE
    } IMediaStreamFilterVtbl;

    interface IMediaStreamFilter
    {
        CONST_VTBL struct IMediaStreamFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaStreamFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaStreamFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaStreamFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaStreamFilter_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define IMediaStreamFilter_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaStreamFilter_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaStreamFilter_Run(This,tStart)	\
    ( (This)->lpVtbl -> Run(This,tStart) ) 

#define IMediaStreamFilter_GetState(This,dwMilliSecsTimeout,State)	\
    ( (This)->lpVtbl -> GetState(This,dwMilliSecsTimeout,State) ) 

#define IMediaStreamFilter_SetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> SetSyncSource(This,pClock) ) 

#define IMediaStreamFilter_GetSyncSource(This,pClock)	\
    ( (This)->lpVtbl -> GetSyncSource(This,pClock) ) 


#define IMediaStreamFilter_EnumPins(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumPins(This,ppEnum) ) 

#define IMediaStreamFilter_FindPin(This,Id,ppPin)	\
    ( (This)->lpVtbl -> FindPin(This,Id,ppPin) ) 

#define IMediaStreamFilter_QueryFilterInfo(This,pInfo)	\
    ( (This)->lpVtbl -> QueryFilterInfo(This,pInfo) ) 

#define IMediaStreamFilter_JoinFilterGraph(This,pGraph,pName)	\
    ( (This)->lpVtbl -> JoinFilterGraph(This,pGraph,pName) ) 

#define IMediaStreamFilter_QueryVendorInfo(This,pVendorInfo)	\
    ( (This)->lpVtbl -> QueryVendorInfo(This,pVendorInfo) ) 


#define IMediaStreamFilter_AddMediaStream(This,pAMMediaStream)	\
    ( (This)->lpVtbl -> AddMediaStream(This,pAMMediaStream) ) 

#define IMediaStreamFilter_GetMediaStream(This,idPurpose,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,idPurpose,ppMediaStream) ) 

#define IMediaStreamFilter_EnumMediaStreams(This,Index,ppMediaStream)	\
    ( (This)->lpVtbl -> EnumMediaStreams(This,Index,ppMediaStream) ) 

#define IMediaStreamFilter_SupportSeeking(This,bRenderer)	\
    ( (This)->lpVtbl -> SupportSeeking(This,bRenderer) ) 

#define IMediaStreamFilter_ReferenceTimeToStreamTime(This,pTime)	\
    ( (This)->lpVtbl -> ReferenceTimeToStreamTime(This,pTime) ) 

#define IMediaStreamFilter_GetCurrentStreamTime(This,pCurrentStreamTime)	\
    ( (This)->lpVtbl -> GetCurrentStreamTime(This,pCurrentStreamTime) ) 

#define IMediaStreamFilter_WaitUntil(This,WaitStreamTime)	\
    ( (This)->lpVtbl -> WaitUntil(This,WaitStreamTime) ) 

#define IMediaStreamFilter_Flush(This,bCancelEOS)	\
    ( (This)->lpVtbl -> Flush(This,bCancelEOS) ) 

#define IMediaStreamFilter_EndOfStream(This)	\
    ( (This)->lpVtbl -> EndOfStream(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaStreamFilter_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__
#define __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__

/* interface IDirectDrawMediaSampleAllocator */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaSampleAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFC-F6E4-11d0-900D-00C04FD9189D")
    IDirectDrawMediaSampleAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            IDirectDraw **ppDirectDraw) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaSampleAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaSampleAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaSampleAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaSampleAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IDirectDrawMediaSampleAllocator * This,
            IDirectDraw **ppDirectDraw);
        
        END_INTERFACE
    } IDirectDrawMediaSampleAllocatorVtbl;

    interface IDirectDrawMediaSampleAllocator
    {
        CONST_VTBL struct IDirectDrawMediaSampleAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaSampleAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawMediaSampleAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawMediaSampleAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawMediaSampleAllocator_GetDirectDraw(This,ppDirectDraw)	\
    ( (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawMediaSampleAllocator_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawMediaSample_INTERFACE_DEFINED__
#define __IDirectDrawMediaSample_INTERFACE_DEFINED__

/* interface IDirectDrawMediaSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFE-F6E4-11d0-900D-00C04FD9189D")
    IDirectDrawMediaSample : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceAndReleaseLock( 
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockMediaSamplePointer( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurfaceAndReleaseLock )( 
            IDirectDrawMediaSample * This,
            /* [out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *LockMediaSamplePointer )( 
            IDirectDrawMediaSample * This);
        
        END_INTERFACE
    } IDirectDrawMediaSampleVtbl;

    interface IDirectDrawMediaSample
    {
        CONST_VTBL struct IDirectDrawMediaSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawMediaSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawMediaSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawMediaSample_GetSurfaceAndReleaseLock(This,ppDirectDrawSurface,pRect)	\
    ( (This)->lpVtbl -> GetSurfaceAndReleaseLock(This,ppDirectDrawSurface,pRect) ) 

#define IDirectDrawMediaSample_LockMediaSamplePointer(This)	\
    ( (This)->lpVtbl -> LockMediaSamplePointer(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawMediaSample_INTERFACE_DEFINED__ */


#ifndef __IAMMediaTypeStream_INTERFACE_DEFINED__
#define __IAMMediaTypeStream_INTERFACE_DEFINED__

/* interface IAMMediaTypeStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMMediaTypeStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFA-F6E4-11d0-900D-00C04FD9189D")
    IAMMediaTypeStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [out] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ long lSampleSize,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample **ppAMMediaTypeSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamAllocatorRequirements( 
            /* [out] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamAllocatorRequirements( 
            /* [in] */ ALLOCATOR_PROPERTIES *pProps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaTypeStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaTypeStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaTypeStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaTypeStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IAMMediaTypeStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IAMMediaTypeStream * This,
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IAMMediaTypeStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IAMMediaTypeStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IAMMediaTypeStream * This,
            /* [out] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IAMMediaTypeStream * This,
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IAMMediaTypeStream * This,
            /* [in] */ long lSampleSize,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample **ppAMMediaTypeSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamAllocatorRequirements )( 
            IAMMediaTypeStream * This,
            /* [out] */ ALLOCATOR_PROPERTIES *pProps);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamAllocatorRequirements )( 
            IAMMediaTypeStream * This,
            /* [in] */ ALLOCATOR_PROPERTIES *pProps);
        
        END_INTERFACE
    } IAMMediaTypeStreamVtbl;

    interface IAMMediaTypeStream
    {
        CONST_VTBL struct IAMMediaTypeStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaTypeStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaTypeStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaTypeStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaTypeStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    ( (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream) ) 

#define IAMMediaTypeStream_GetInformation(This,pPurposeId,pType)	\
    ( (This)->lpVtbl -> GetInformation(This,pPurposeId,pType) ) 

#define IAMMediaTypeStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    ( (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags) ) 

#define IAMMediaTypeStream_AllocateSample(This,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample) ) 

#define IAMMediaTypeStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    ( (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample) ) 

#define IAMMediaTypeStream_SendEndOfStream(This,dwFlags)	\
    ( (This)->lpVtbl -> SendEndOfStream(This,dwFlags) ) 


#define IAMMediaTypeStream_GetFormat(This,pMediaType,dwFlags)	\
    ( (This)->lpVtbl -> GetFormat(This,pMediaType,dwFlags) ) 

#define IAMMediaTypeStream_SetFormat(This,pMediaType,dwFlags)	\
    ( (This)->lpVtbl -> SetFormat(This,pMediaType,dwFlags) ) 

#define IAMMediaTypeStream_CreateSample(This,lSampleSize,pbBuffer,dwFlags,pUnkOuter,ppAMMediaTypeSample)	\
    ( (This)->lpVtbl -> CreateSample(This,lSampleSize,pbBuffer,dwFlags,pUnkOuter,ppAMMediaTypeSample) ) 

#define IAMMediaTypeStream_GetStreamAllocatorRequirements(This,pProps)	\
    ( (This)->lpVtbl -> GetStreamAllocatorRequirements(This,pProps) ) 

#define IAMMediaTypeStream_SetStreamAllocatorRequirements(This,pProps)	\
    ( (This)->lpVtbl -> SetStreamAllocatorRequirements(This,pProps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaTypeStream_INTERFACE_DEFINED__ */


#ifndef __IAMMediaTypeSample_INTERFACE_DEFINED__
#define __IAMMediaTypeSample_INTERFACE_DEFINED__

/* interface IAMMediaTypeSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMMediaTypeSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB6B4AFB-F6E4-11d0-900D-00C04FD9189D")
    IAMMediaTypeSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPointer( 
            /* [in] */ BYTE *pBuffer,
            /* [in] */ long lSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointer( 
            /* [out] */ BYTE **ppBuffer) = 0;
        
        virtual long STDMETHODCALLTYPE GetSize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTime( 
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSyncPoint( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSyncPoint( 
            BOOL bIsSyncPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPreroll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreroll( 
            BOOL bIsPreroll) = 0;
        
        virtual long STDMETHODCALLTYPE GetActualDataLength( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActualDataLength( 
            long __MIDL__IAMMediaTypeSample0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaType( 
            AM_MEDIA_TYPE **ppMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaType( 
            AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDiscontinuity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDiscontinuity( 
            BOOL bDiscontinuity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTime( 
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMediaTime( 
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMMediaTypeSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMMediaTypeSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMMediaTypeSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IAMMediaTypeSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IAMMediaTypeSample * This,
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IAMMediaTypeSample * This,
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IAMMediaTypeSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IAMMediaTypeSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetPointer )( 
            IAMMediaTypeSample * This,
            /* [in] */ BYTE *pBuffer,
            /* [in] */ long lSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointer )( 
            IAMMediaTypeSample * This,
            /* [out] */ BYTE **ppBuffer);
        
        long ( STDMETHODCALLTYPE *GetSize )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            IAMMediaTypeSample * This,
            /* [out] */ REFERENCE_TIME *pTimeStart,
            /* [out] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTime )( 
            IAMMediaTypeSample * This,
            /* [in] */ REFERENCE_TIME *pTimeStart,
            /* [in] */ REFERENCE_TIME *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *IsSyncPoint )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSyncPoint )( 
            IAMMediaTypeSample * This,
            BOOL bIsSyncPoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreroll )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreroll )( 
            IAMMediaTypeSample * This,
            BOOL bIsPreroll);
        
        long ( STDMETHODCALLTYPE *GetActualDataLength )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetActualDataLength )( 
            IAMMediaTypeSample * This,
            long __MIDL__IAMMediaTypeSample0000);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaType )( 
            IAMMediaTypeSample * This,
            AM_MEDIA_TYPE **ppMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            IAMMediaTypeSample * This,
            AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *IsDiscontinuity )( 
            IAMMediaTypeSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDiscontinuity )( 
            IAMMediaTypeSample * This,
            BOOL bDiscontinuity);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTime )( 
            IAMMediaTypeSample * This,
            /* [out] */ LONGLONG *pTimeStart,
            /* [out] */ LONGLONG *pTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMediaTime )( 
            IAMMediaTypeSample * This,
            /* [in] */ LONGLONG *pTimeStart,
            /* [in] */ LONGLONG *pTimeEnd);
        
        END_INTERFACE
    } IAMMediaTypeSampleVtbl;

    interface IAMMediaTypeSample
    {
        CONST_VTBL struct IAMMediaTypeSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMMediaTypeSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMMediaTypeSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMMediaTypeSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMMediaTypeSample_GetMediaStream(This,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,ppMediaStream) ) 

#define IAMMediaTypeSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    ( (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime) ) 

#define IAMMediaTypeSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    ( (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime) ) 

#define IAMMediaTypeSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    ( (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData) ) 

#define IAMMediaTypeSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    ( (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds) ) 


#define IAMMediaTypeSample_SetPointer(This,pBuffer,lSize)	\
    ( (This)->lpVtbl -> SetPointer(This,pBuffer,lSize) ) 

#define IAMMediaTypeSample_GetPointer(This,ppBuffer)	\
    ( (This)->lpVtbl -> GetPointer(This,ppBuffer) ) 

#define IAMMediaTypeSample_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 

#define IAMMediaTypeSample_GetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetTime(This,pTimeStart,pTimeEnd) ) 

#define IAMMediaTypeSample_SetTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetTime(This,pTimeStart,pTimeEnd) ) 

#define IAMMediaTypeSample_IsSyncPoint(This)	\
    ( (This)->lpVtbl -> IsSyncPoint(This) ) 

#define IAMMediaTypeSample_SetSyncPoint(This,bIsSyncPoint)	\
    ( (This)->lpVtbl -> SetSyncPoint(This,bIsSyncPoint) ) 

#define IAMMediaTypeSample_IsPreroll(This)	\
    ( (This)->lpVtbl -> IsPreroll(This) ) 

#define IAMMediaTypeSample_SetPreroll(This,bIsPreroll)	\
    ( (This)->lpVtbl -> SetPreroll(This,bIsPreroll) ) 

#define IAMMediaTypeSample_GetActualDataLength(This)	\
    ( (This)->lpVtbl -> GetActualDataLength(This) ) 

#define IAMMediaTypeSample_SetActualDataLength(This,__MIDL__IAMMediaTypeSample0000)	\
    ( (This)->lpVtbl -> SetActualDataLength(This,__MIDL__IAMMediaTypeSample0000) ) 

#define IAMMediaTypeSample_GetMediaType(This,ppMediaType)	\
    ( (This)->lpVtbl -> GetMediaType(This,ppMediaType) ) 

#define IAMMediaTypeSample_SetMediaType(This,pMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,pMediaType) ) 

#define IAMMediaTypeSample_IsDiscontinuity(This)	\
    ( (This)->lpVtbl -> IsDiscontinuity(This) ) 

#define IAMMediaTypeSample_SetDiscontinuity(This,bDiscontinuity)	\
    ( (This)->lpVtbl -> SetDiscontinuity(This,bDiscontinuity) ) 

#define IAMMediaTypeSample_GetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> GetMediaTime(This,pTimeStart,pTimeEnd) ) 

#define IAMMediaTypeSample_SetMediaTime(This,pTimeStart,pTimeEnd)	\
    ( (This)->lpVtbl -> SetMediaTime(This,pTimeStart,pTimeEnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMMediaTypeSample_INTERFACE_DEFINED__ */



#ifndef __DirectShowStreamLib_LIBRARY_DEFINED__
#define __DirectShowStreamLib_LIBRARY_DEFINED__

/* library DirectShowStreamLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DirectShowStreamLib;

EXTERN_C const CLSID CLSID_AMMultiMediaStream;

#ifdef __cplusplus

class DECLSPEC_UUID("49c47ce5-9ba4-11d0-8212-00c04fc32c45")
AMMultiMediaStream;
#endif
#endif /* __DirectShowStreamLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_amstream_0000_0008 */
/* [local] */ 

#ifndef __cplusplus
EXTERN_C const CLSID CLSID_AMMultiMediaStream;
#endif
DEFINE_GUID(CLSID_AMDirectDrawStream, /* 49c47ce4-9ba4-11d0-8212-00c04fc32c45 */
0x49c47ce4, 0x9ba4, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioStream, /* 8496e040-af4c-11d0-8212-00c04fc32c45 */
0x8496e040, 0xaf4c, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMAudioData, /* f2468580-af8a-11d0-8212-00c04fc32c45 */
0xf2468580, 0xaf8a, 0x11d0, 0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45);
DEFINE_GUID(CLSID_AMMediaTypeStream, /* CF0F2F7C-F7BF-11d0-900D-00C04FD9189D */
0xcf0f2f7c, 0xf7bf, 0x11d0, 0x90, 0xd, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);


extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_amstream_0000_0008_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\armmacros.s ===
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Use of this sample source code is subject to the terms of the Microsoft
; license agreement under which you licensed this sample source code. If
; you did not accept the terms of the license agreement, you are not
; authorized to use this sample source code. For the terms of the license,
; please see the license agreement between you and Microsoft or, if applicable,
; see the LICENSE.RTF on your install media or the root of your tools installation.
; THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
;

;/***********************************************************************
;  Copyright (c) ARM Limited 1998.  All rights reserved.
;
; NOTE: The CALL and CALLEQ macros shouldn't be used in OS startup code
;       before the MMU is enabled since in the Thumbing case it relies
;       on an absolute address which will be virtual in the case of the
;       OS code and if the MMU isn't enabled, all branches should be
;       relative (or a computed physical address).
;
;***********************************************************************/

  IF Interworking :LOR: Thumbing

    MACRO
    CALL $Fn
    ldr     r12, =$Fn
    mov     lr, pc
    bx      r12
    MEND

    MACRO
    CALLEQ $Fn
    ldreq   r12, =$Fn
    moveq   lr, pc
    bxeq    r12
    MEND

    MACRO
    RETURN
    bx      lr
    MEND

    MACRO
    RETURN_EQ
    bxeq    lr
    MEND

    MACRO
    RETURN_NE
    bxne    lr
    MEND

  ELSE

    MACRO
    CALL $Fn
    bl      $Fn
    MEND

    MACRO
    CALLEQ $Fn
    bleq    $Fn
    MEND

    MACRO
    RETURN
    mov     pc, lr
    MEND

    MACRO
    RETURN_EQ
    moveq   pc, lr
    MEND

    MACRO
    RETURN_NE
    movne   pc, lr
    MEND

  ENDIF

    END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\assert.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/****
*
* assert.h - define the assert macro
*
* Purpose:
*   Defines the assert(exp) macro.
*   If the DEBUG compiler directive is set, assert(exp) where exp
*   evaluates to a false condition will result in a debug message
*   being printed to the debug console, followed by a DebugBreak().
*   The debug message will be in the form:
*
*   *** ASSERTION FAILED in <file>(<line>):
*   <expression>
*
* Note:
*   If the DEBUG directive is set, winbase.h will be included
*   by this file.
*
****/

#pragma once

#ifndef _INC_ASSERT
#define _INC_ASSERT

#include <crtdefs.h>

/* Define __cdecl for non-Microsoft compilers */

/* If DEBUG is not defined, make sure NDEBUG is defined */
#if !defined(DEBUG) && !defined(NDEBUG)
#define NDEBUG 1
#endif // !defined(DEBUG) && !defined(NDEBUG)

#ifdef NDEBUG

#define assert(exp) ((void)0)

#else /* NDEBUG */

#include <windef.h>
#include <types.h>
#include <winbase.h>
/* Multi-level macro needed to launder __LINE__ */
#define ASSERT_PRINT(exp,file,line) OutputDebugString(TEXT("\r\n*** ASSERTION FAILED in ") TEXT(file) TEXT("(") TEXT(#line) TEXT("):\r\n") TEXT(#exp) TEXT("\r\n"))
#define ASSERT_AT(exp,file,line) (void)( (exp) || (ASSERT_PRINT(exp,file,line), DebugBreak(), 0 ) )
#define assert(exp) ASSERT_AT(exp,__FILE__,__LINE__)

#endif /* NDEBUG */

#endif /* _INC_ASSERT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\astdtapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

// The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
// granted  a royalty free worldwide, unlimited license to make copies, and use
// the   API/SPI  for  making  applications/drivers  that  interface  with  the
// specification provided that this paragraph and the Intel/Microsoft copyright
// statement is maintained as is in the text and source code files.

#ifndef __ASTDTAPI_H__
#define __ASTDTAPI_H__

#include <tapi.h>

#ifdef __cplusplus
extern "C" {
#endif

LONG
tapiRequestMakeCallW(
    LPCWSTR              lpszDestAddress,
    LPCWSTR              lpszAppName,
    LPCWSTR              lpszCalledParty,
    LPCWSTR              lpszComment
    );

#define tapiRequestMakeCall tapiRequestMakeCallW


#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L

#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L


LONG tapiGetCellularLineDevices(
    const HLINEAPP hLineApp, 
    const DWORD dwNumberDevices, 
    DWORD *lpdwLineDeviceIDs, 
    DWORD *lpdwNumberCelluarDevices
);

LONG tapiGetCellularPhoneDevices(
    const HPHONEAPP hPhoneApp, 
    const DWORD dwNumberDevices, 
    DWORD *lpdwPhoneDeviceIDs, 
    DWORD *lpdwNumberCelluarDevices
);


#ifdef __cplusplus
}
#endif
                        
#endif //!__ASTDTAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\asfparse.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for asfparse.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __asfparse_h__
#define __asfparse_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IASFLibrary_FWD_DEFINED__
#define __IASFLibrary_FWD_DEFINED__
typedef interface IASFLibrary IASFLibrary;
#endif 	/* __IASFLibrary_FWD_DEFINED__ */


#ifndef __IASFUnknownContainer_FWD_DEFINED__
#define __IASFUnknownContainer_FWD_DEFINED__
typedef interface IASFUnknownContainer IASFUnknownContainer;
#endif 	/* __IASFUnknownContainer_FWD_DEFINED__ */


#ifndef __IASFEnumASFUnknown_FWD_DEFINED__
#define __IASFEnumASFUnknown_FWD_DEFINED__
typedef interface IASFEnumASFUnknown IASFEnumASFUnknown;
#endif 	/* __IASFEnumASFUnknown_FWD_DEFINED__ */


#ifndef __IASFReadCallback_FWD_DEFINED__
#define __IASFReadCallback_FWD_DEFINED__
typedef interface IASFReadCallback IASFReadCallback;
#endif 	/* __IASFReadCallback_FWD_DEFINED__ */


#ifndef __IASFUnknown_FWD_DEFINED__
#define __IASFUnknown_FWD_DEFINED__
typedef interface IASFUnknown IASFUnknown;
#endif 	/* __IASFUnknown_FWD_DEFINED__ */


#ifndef __IASFHeaderObject_FWD_DEFINED__
#define __IASFHeaderObject_FWD_DEFINED__
typedef interface IASFHeaderObject IASFHeaderObject;
#endif 	/* __IASFHeaderObject_FWD_DEFINED__ */


#ifndef __IASFDataObject_FWD_DEFINED__
#define __IASFDataObject_FWD_DEFINED__
typedef interface IASFDataObject IASFDataObject;
#endif 	/* __IASFDataObject_FWD_DEFINED__ */


#ifndef __IASFPacketParser_FWD_DEFINED__
#define __IASFPacketParser_FWD_DEFINED__
typedef interface IASFPacketParser IASFPacketParser;
#endif 	/* __IASFPacketParser_FWD_DEFINED__ */


#ifndef __IASFSimpleIndexObject_FWD_DEFINED__
#define __IASFSimpleIndexObject_FWD_DEFINED__
typedef interface IASFSimpleIndexObject IASFSimpleIndexObject;
#endif 	/* __IASFSimpleIndexObject_FWD_DEFINED__ */


#ifndef __IASFIndexObject_FWD_DEFINED__
#define __IASFIndexObject_FWD_DEFINED__
typedef interface IASFIndexObject IASFIndexObject;
#endif 	/* __IASFIndexObject_FWD_DEFINED__ */


#ifndef __IASFIndexBlock_FWD_DEFINED__
#define __IASFIndexBlock_FWD_DEFINED__
typedef interface IASFIndexBlock IASFIndexBlock;
#endif 	/* __IASFIndexBlock_FWD_DEFINED__ */


/* header files for imported files */
#include "mfobjects.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_asfparse_0000_0000 */
/* [local] */ 

#pragma pack(push, enter_asfparse)
#pragma pack(1)
const DWORD ASF_MIN_OBJECT_SIZE = sizeof( GUID ) + sizeof( QWORD );
#define ASF_CONTAINER_APPEND        0xFFFFFFFF
#define ASF_VARIABLE_SIZE_PACKET            0xffffffff
#define ASF_MAX_PACKET_SIZE                 64000

extern "C" const GUID CLSID_ASFBandwidthSharingObject;
extern "C" const GUID CLSID_ASFClockObject;
extern "C" const GUID CLSID_ASFCodecListObject;
extern "C" const GUID CLSID_ASFContentDescriptionObject;
extern "C" const GUID CLSID_ASFContentBrandingObject;
extern "C" const GUID CLSID_ASFDataObject;
extern "C" const GUID CLSID_ASFExtendedContentDescriptionObject;
extern "C" const GUID CLSID_ASFGenericObject;
extern "C" const GUID CLSID_ASFGroupMutualExclusionObject;
extern "C" const GUID CLSID_ASFHeaderObject;
extern "C" const GUID CLSID_WMPHeaderObject;
extern "C" const GUID CLSID_ASFIndexParametersObject;
extern "C" const GUID CLSID_ASFMediaObjectIndexParametersObject;
extern "C" const GUID CLSID_ASFTimecodeIndexParametersObject;
extern "C" const GUID CLSID_ASFIndexParametersPlaceholderObject;
extern "C" const GUID CLSID_ASFMarkerObject;
extern "C" const GUID CLSID_ASFMetadataObject;
extern "C" const GUID CLSID_ASFMetadataLibraryObject;
extern "C" const GUID CLSID_ASFEncryptedMetadataLibraryObject;
extern "C" const GUID CLSID_ASFLanguageListObject;
extern "C" const GUID CLSID_ASFMutualExclusionObject;
extern "C" const GUID CLSID_ASFMutualExclusionObjectEx;
extern "C" const GUID CLSID_ASFPaddingObject;
extern "C" const GUID CLSID_ASFPrioritizationObject;
extern "C" const GUID CLSID_ASFPropertiesObject;
extern "C" const GUID CLSID_ASFScriptCommandObject;
extern "C" const GUID CLSID_ASFSimpleIndexObject;
extern "C" const GUID CLSID_ASFIndexObject;
extern "C" const GUID CLSID_ASFMediaObjectIndexObject;
extern "C" const GUID CLSID_ASFTimecodeIndexObject;
extern "C" const GUID CLSID_ASFStreamBitratePropertiesObject;
extern "C" const GUID CLSID_ASFStreamPropertiesObject;
extern "C" const GUID CLSID_ASFStreamPropertiesObjectEx;
extern "C" const GUID CLSID_ASFContentEncryptionObject;
extern "C" const GUID CLSID_ASFContentEncryptionObjectEx;
extern "C" const GUID CLSID_ASFAdvancedContentEncryptionObject;
extern "C" const GUID CLSID_ASFDigitalSignatureObject;


extern "C" const GUID CLSID_ASFMutexLanguage;
extern "C" const GUID CLSID_ASFMutexBitrate;
extern "C" const GUID CLSID_ASFMutexUnknown;

extern "C" const GUID CLSID_ASFBandwidthSharingExclusive;
extern "C" const GUID CLSID_ASFBandwidthSharingPartial;

extern "C" const GUID CLSID_ASFPacketClock;

extern "C" const GUID CLSID_ASFMarkerIndex;
extern "C" const GUID CLSID_ASFScriptCommandIndex;

extern "C" const GUID CLSID_ASFExtensionGUID_OutputCleanPoint;
extern "C" const GUID CLSID_ASFExtensionGUID_Timecode;
extern "C" const GUID CLSID_ASFExtensionGUID_FileName;
extern "C" const GUID CLSID_ASFExtensionGUID_ContentType;
extern "C" const GUID CLSID_ASFExtensionGUID_PixelAspectRatio;
extern "C" const GUID CLSID_ASFExtensionGUID_SampleDuration;
extern "C" const GUID CLSID_ASFExtensionGUID_DegradableJPEG;
#define ASFExtension_ContentType_Size      1
#define ASFExtension_PixelAspectRatio_Size 2
#define ASFExtension_Timecode_Size            14
#define ASFExtension_SampleDuration_Size   2

extern "C" const GUID CLSID_AsfXStreamTypeAcmAudio;
extern "C" const GUID CLSID_AsfXStreamTypeUncompressedDibVideo;
extern "C" const GUID CLSID_AsfXStreamTypeIcmVideo;
extern "C" const GUID CLSID_AsfXStreamTypeJpegJfifVideo;
extern "C" const GUID CLSID_AsfXStreamTypeAnsiUrl;
extern "C" const GUID CLSID_AsfXStreamTypeDegradableJpeg;
extern "C" const GUID CLSID_AsfXStreamTypeScriptCommand;
extern "C" const GUID CLSID_AsfXStreamTypeFileTransfer;
extern "C" const GUID CLSID_AsfXStreamTypeDRMAuxData;
extern "C" const GUID CLSID_AsfXStreamTypeArbitraryData;

////////////////////////////////////////////////////////////
// ASF parsing helper functions                             
////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE ASFCreateLibrary(                 
            IASFLibrary**       ppASFLib );                 
HRESULT STDMETHODCALLTYPE ASFFindRootObject(                
            IASFLibrary* pASFLibrary,                       
            REFGUID guidObjectType,                         
            REFGUID guidInterface,                          
            void** ppObject );                              
HRESULT STDMETHODCALLTYPE ASFGetStreamDataBitrate(          
            IASFHeaderObject* pASFHeaderObject,             
            WORD wStreamNumber,                             
            BOOL fAverageBitrate,                             
            DWORD *pdwDataBitrate );                        
typedef struct _ASF_PACKET_INFO
    {
    BOOL fOpaquePacket;
    DWORD dwSendTime;
    WORD wDuration;
    WORD cPayloads;
    DWORD cbPacketLength;
    } 	ASF_PACKET_INFO;

typedef struct _ASF_PAYLOAD_INFO
    {
    WORD wStreamNumber;
    BOOL fIsKeyFrame;
    BYTE bObjectID;
    DWORD cbObjectOffset;
    DWORD cbObjectSize;
    DWORD msObjectPresTime;
    DWORD cbPacketOffset;
    DWORD cbTotalSize;
    DWORD cbPayloadDataSize;
    WORD cbReplicatedData;
    DWORD cbReplicatedDataOffset;
    BYTE ReplicatedData[ 256 ];
    } 	ASF_PAYLOAD_INFO;

typedef struct _ASF_EXTENSION_SYSTEM
    {
    GUID guidExtensionType;
    WORD cbExtensionData;
    } 	ASF_EXTENSION_SYSTEM;

typedef struct _ASF_EXTENSION_SYSTEM_WITH_DEFAULT
    {
    GUID guidExtensionType;
    WORD cbExtensionData;
    BYTE *pbDefaultExtensionData;
    UINT32 cbDefaultExtensionData;
    } 	ASF_EXTENSION_SYSTEM_WITH_DEFAULT;

typedef struct _ASF_DEGRADABLE_JPEG_EXT_DATA
    {
    WORD wWidth;
    WORD wHeight;
    WORD wRestartInterval;
    WORD wcRestarts;
    WORD wFirstInterval;
    WORD wFirstTotSize;
    WORD wFirstOffsetToEnd;
    WORD wLastInterval;
    WORD wLastTotSize;
    WORD wLastOffsetToStart;
    } 	ASF_DEGRADABLE_JPEG_EXT_DATA;

typedef 
enum _ASF_INTERNAL_INDEX_TYPE
    {	ASF_INTERNAL_INDEX_TYPE_NEAREST_PACKET	= 1,
	ASF_INTERNAL_INDEX_TYPE_NEAREST_OBJECT	= 2,
	ASF_INTERNAL_INDEX_TYPE_NEAREST_CLEANPOINT	= 3,
	ASF_INTERNAL_INDEX_TYPE_MAX	= 4,
	ASF_INTERNAL_INDEX_TYPE_FRAME_NUMBER_OFFSET	= 255
    } 	ASF_INTERNAL_INDEX_TYPE;

typedef 
enum _ASF_INDEX_FLAGS
    {	ASF_INDEX_LOAD_ENTRIES	= 0x1
    } 	ASF_INDEX_FLAGS;





extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0000_v0_0_s_ifspec;

#ifndef __IASFLibrary_INTERFACE_DEFINED__
#define __IASFLibrary_INTERFACE_DEFINED__

/* interface IASFLibrary */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFLibrary;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3FDD9868-D3A9-4ff2-9E45-E5DFB6E13A01")
    IASFLibrary : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinObjectSize( 
            /* [out] */ DWORD *pcbMinObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectInfo( 
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ GUID *pguidObjectType,
            /* [out] */ QWORD *pqwObjectSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ REFGUID clsid,
            /* [out] */ IASFUnknown **ppASFUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReadCallback( 
            /* [in] */ IASFReadCallback *pASFReadCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFLibraryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFLibrary * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFLibrary * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFLibrary * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IASFLibrary * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IASFLibrary * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinObjectSize )( 
            IASFLibrary * This,
            /* [out] */ DWORD *pcbMinObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectInfo )( 
            IASFLibrary * This,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ GUID *pguidObjectType,
            /* [out] */ QWORD *pqwObjectSize);
        
        HRESULT ( STDMETHODCALLTYPE *CreateObject )( 
            IASFLibrary * This,
            /* [in] */ REFGUID clsid,
            /* [out] */ IASFUnknown **ppASFUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetReadCallback )( 
            IASFLibrary * This,
            /* [in] */ IASFReadCallback *pASFReadCallback);
        
        END_INTERFACE
    } IASFLibraryVtbl;

    interface IASFLibrary
    {
        CONST_VTBL struct IASFLibraryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFLibrary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFLibrary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFLibrary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFLibrary_Init(This)	\
    ( (This)->lpVtbl -> Init(This) ) 

#define IASFLibrary_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IASFLibrary_GetMinObjectSize(This,pcbMinObject)	\
    ( (This)->lpVtbl -> GetMinObjectSize(This,pcbMinObject) ) 

#define IASFLibrary_GetObjectInfo(This,pbBuffer,cbBuffer,pguidObjectType,pqwObjectSize)	\
    ( (This)->lpVtbl -> GetObjectInfo(This,pbBuffer,cbBuffer,pguidObjectType,pqwObjectSize) ) 

#define IASFLibrary_CreateObject(This,clsid,ppASFUnk)	\
    ( (This)->lpVtbl -> CreateObject(This,clsid,ppASFUnk) ) 

#define IASFLibrary_SetReadCallback(This,pASFReadCallback)	\
    ( (This)->lpVtbl -> SetReadCallback(This,pASFReadCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFLibrary_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_asfparse_0000_0001 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0001_v0_0_s_ifspec;

#ifndef __IASFUnknownContainer_INTERFACE_DEFINED__
#define __IASFUnknownContainer_INTERFACE_DEFINED__

/* interface IASFUnknownContainer */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFUnknownContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FF2F2C4-AE47-4b5a-A95B-A1E51A0BCEC6")
    IASFUnknownContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectCount( 
            /* [in] */ REFGUID guidObjectType,
            /* [out] */ DWORD *pcObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ DWORD dwObjectIndex,
            /* [out] */ IASFUnknown **ppASFUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertObject( 
            /* [in] */ IASFUnknown *pASFUnk,
            /* [out] */ DWORD *pdwObjectIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObject( 
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ DWORD dwObjectIndex,
            /* [out] */ IASFUnknown **ppRemovedObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjectByPointer( 
            /* [in] */ IASFUnknown *pASFUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveObjects( 
            /* [in] */ REFGUID guidObjectType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [in] */ REFGUID guidObjectType,
            /* [out] */ IASFEnumASFUnknown **ppIEnumASFUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadObjects( 
            /* [in] */ IASFLibrary *pASFLibrary,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWriteSpace( 
            /* [out] */ QWORD *pqwWriteSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteObjects( 
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFUnknownContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFUnknownContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFUnknownContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFUnknownContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectCount )( 
            IASFUnknownContainer * This,
            /* [in] */ REFGUID guidObjectType,
            /* [out] */ DWORD *pcObjects);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IASFUnknownContainer * This,
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ DWORD dwObjectIndex,
            /* [out] */ IASFUnknown **ppASFUnk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertObject )( 
            IASFUnknownContainer * This,
            /* [in] */ IASFUnknown *pASFUnk,
            /* [out] */ DWORD *pdwObjectIndex);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObject )( 
            IASFUnknownContainer * This,
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ DWORD dwObjectIndex,
            /* [out] */ IASFUnknown **ppRemovedObject);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjectByPointer )( 
            IASFUnknownContainer * This,
            /* [in] */ IASFUnknown *pASFUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveObjects )( 
            IASFUnknownContainer * This,
            /* [in] */ REFGUID guidObjectType);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IASFUnknownContainer * This,
            /* [in] */ REFGUID guidObjectType,
            /* [out] */ IASFEnumASFUnknown **ppIEnumASFUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *ReadObjects )( 
            IASFUnknownContainer * This,
            /* [in] */ IASFLibrary *pASFLibrary,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *GetWriteSpace )( 
            IASFUnknownContainer * This,
            /* [out] */ QWORD *pqwWriteSpace);
        
        HRESULT ( STDMETHODCALLTYPE *WriteObjects )( 
            IASFUnknownContainer * This,
            /* [in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        END_INTERFACE
    } IASFUnknownContainerVtbl;

    interface IASFUnknownContainer
    {
        CONST_VTBL struct IASFUnknownContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFUnknownContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFUnknownContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFUnknownContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFUnknownContainer_GetObjectCount(This,guidObjectType,pcObjects)	\
    ( (This)->lpVtbl -> GetObjectCount(This,guidObjectType,pcObjects) ) 

#define IASFUnknownContainer_GetObject(This,guidObjectType,dwObjectIndex,ppASFUnk)	\
    ( (This)->lpVtbl -> GetObject(This,guidObjectType,dwObjectIndex,ppASFUnk) ) 

#define IASFUnknownContainer_InsertObject(This,pASFUnk,pdwObjectIndex)	\
    ( (This)->lpVtbl -> InsertObject(This,pASFUnk,pdwObjectIndex) ) 

#define IASFUnknownContainer_RemoveObject(This,guidObjectType,dwObjectIndex,ppRemovedObject)	\
    ( (This)->lpVtbl -> RemoveObject(This,guidObjectType,dwObjectIndex,ppRemovedObject) ) 

#define IASFUnknownContainer_RemoveObjectByPointer(This,pASFUnknown)	\
    ( (This)->lpVtbl -> RemoveObjectByPointer(This,pASFUnknown) ) 

#define IASFUnknownContainer_RemoveObjects(This,guidObjectType)	\
    ( (This)->lpVtbl -> RemoveObjects(This,guidObjectType) ) 

#define IASFUnknownContainer_EnumObjects(This,guidObjectType,ppIEnumASFUnknown)	\
    ( (This)->lpVtbl -> EnumObjects(This,guidObjectType,ppIEnumASFUnknown) ) 

#define IASFUnknownContainer_ReadObjects(This,pASFLibrary,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> ReadObjects(This,pASFLibrary,pBuffer,pcbUsed) ) 

#define IASFUnknownContainer_GetWriteSpace(This,pqwWriteSpace)	\
    ( (This)->lpVtbl -> GetWriteSpace(This,pqwWriteSpace) ) 

#define IASFUnknownContainer_WriteObjects(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> WriteObjects(This,pbBuffer,cbBuffer,pcbUsed) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFUnknownContainer_INTERFACE_DEFINED__ */


#ifndef __IASFEnumASFUnknown_INTERFACE_DEFINED__
#define __IASFEnumASFUnknown_INTERFACE_DEFINED__

/* interface IASFEnumASFUnknown */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFEnumASFUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADC78E1B-7EFC-4f9b-8B1B-3C42A25AC7D2")
    IASFEnumASFUnknown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IASFUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IASFEnumASFUnknown **ppIASFEnumASFUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFEnumASFUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFEnumASFUnknown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFEnumASFUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFEnumASFUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IASFEnumASFUnknown * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IASFUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IASFEnumASFUnknown * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IASFEnumASFUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IASFEnumASFUnknown * This,
            /* [out] */ IASFEnumASFUnknown **ppIASFEnumASFUnknown);
        
        END_INTERFACE
    } IASFEnumASFUnknownVtbl;

    interface IASFEnumASFUnknown
    {
        CONST_VTBL struct IASFEnumASFUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFEnumASFUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFEnumASFUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFEnumASFUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFEnumASFUnknown_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IASFEnumASFUnknown_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IASFEnumASFUnknown_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IASFEnumASFUnknown_Clone(This,ppIASFEnumASFUnknown)	\
    ( (This)->lpVtbl -> Clone(This,ppIASFEnumASFUnknown) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFEnumASFUnknown_INTERFACE_DEFINED__ */


#ifndef __IASFReadCallback_INTERFACE_DEFINED__
#define __IASFReadCallback_INTERFACE_DEFINED__

/* interface IASFReadCallback */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFReadCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6ECE1EF-3B9C-4392-8A74-262ACA75B874")
    IASFReadCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnObjectRead( 
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ QWORD qwObjectSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFReadCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFReadCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFReadCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFReadCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnObjectRead )( 
            IASFReadCallback * This,
            /* [in] */ REFGUID guidObjectType,
            /* [in] */ QWORD qwObjectSize);
        
        END_INTERFACE
    } IASFReadCallbackVtbl;

    interface IASFReadCallback
    {
        CONST_VTBL struct IASFReadCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFReadCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFReadCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFReadCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFReadCallback_OnObjectRead(This,guidObjectType,qwObjectSize)	\
    ( (This)->lpVtbl -> OnObjectRead(This,guidObjectType,qwObjectSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFReadCallback_INTERFACE_DEFINED__ */


#ifndef __IASFUnknown_INTERFACE_DEFINED__
#define __IASFUnknown_INTERFACE_DEFINED__

/* interface IASFUnknown */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2AEA5EC-4D32-4f53-BCD1-A54536DB22CA")
    IASFUnknown : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObjectID( 
            /* [out] */ GUID *pguidID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLibrary( 
            /* [out] */ IASFLibrary **ppASFLibrary) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Space( 
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Read( 
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Write( 
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsHeaderExtensionObject( 
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFUnknown * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFUnknown * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFUnknown * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IASFUnknown * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLibrary )( 
            IASFUnknown * This,
            /* [out] */ IASFLibrary **ppASFLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *Space )( 
            IASFUnknown * This,
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IASFUnknown * This,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IASFUnknown * This,
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsHeaderExtensionObject )( 
            IASFUnknown * This,
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject);
        
        END_INTERFACE
    } IASFUnknownVtbl;

    interface IASFUnknown
    {
        CONST_VTBL struct IASFUnknownVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFUnknown_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFUnknown_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFUnknown_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFUnknown_GetObjectID(This,pguidID)	\
    ( (This)->lpVtbl -> GetObjectID(This,pguidID) ) 

#define IASFUnknown_GetLibrary(This,ppASFLibrary)	\
    ( (This)->lpVtbl -> GetLibrary(This,ppASFLibrary) ) 

#define IASFUnknown_Space(This,pqwInternalSpace,pqwExternalSpace)	\
    ( (This)->lpVtbl -> Space(This,pqwInternalSpace,pqwExternalSpace) ) 

#define IASFUnknown_Read(This,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,pcbUsed) ) 

#define IASFUnknown_Write(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,cbBuffer,pcbUsed) ) 

#define IASFUnknown_NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject)	\
    ( (This)->lpVtbl -> NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFUnknown_INTERFACE_DEFINED__ */


#ifndef __IASFHeaderObject_INTERFACE_DEFINED__
#define __IASFHeaderObject_INTERFACE_DEFINED__

/* interface IASFHeaderObject */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFHeaderObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4C2133C9-EDA9-446d-93D8-54E7E1F32D8E")
    IASFHeaderObject : public IASFUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAlignment( 
            /* [out] */ BYTE *pbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArchitecture( 
            /* [out] */ BYTE *pbArchitecture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumObjects( 
            /* [out] */ DWORD *pcObjects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFHeaderObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFHeaderObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFHeaderObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFHeaderObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IASFHeaderObject * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLibrary )( 
            IASFHeaderObject * This,
            /* [out] */ IASFLibrary **ppASFLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *Space )( 
            IASFHeaderObject * This,
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IASFHeaderObject * This,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IASFHeaderObject * This,
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsHeaderExtensionObject )( 
            IASFHeaderObject * This,
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlignment )( 
            IASFHeaderObject * This,
            /* [out] */ BYTE *pbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE *GetArchitecture )( 
            IASFHeaderObject * This,
            /* [out] */ BYTE *pbArchitecture);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumObjects )( 
            IASFHeaderObject * This,
            /* [out] */ DWORD *pcObjects);
        
        END_INTERFACE
    } IASFHeaderObjectVtbl;

    interface IASFHeaderObject
    {
        CONST_VTBL struct IASFHeaderObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFHeaderObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFHeaderObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFHeaderObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFHeaderObject_GetObjectID(This,pguidID)	\
    ( (This)->lpVtbl -> GetObjectID(This,pguidID) ) 

#define IASFHeaderObject_GetLibrary(This,ppASFLibrary)	\
    ( (This)->lpVtbl -> GetLibrary(This,ppASFLibrary) ) 

#define IASFHeaderObject_Space(This,pqwInternalSpace,pqwExternalSpace)	\
    ( (This)->lpVtbl -> Space(This,pqwInternalSpace,pqwExternalSpace) ) 

#define IASFHeaderObject_Read(This,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,pcbUsed) ) 

#define IASFHeaderObject_Write(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,cbBuffer,pcbUsed) ) 

#define IASFHeaderObject_NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject)	\
    ( (This)->lpVtbl -> NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject) ) 


#define IASFHeaderObject_GetAlignment(This,pbAlignment)	\
    ( (This)->lpVtbl -> GetAlignment(This,pbAlignment) ) 

#define IASFHeaderObject_GetArchitecture(This,pbArchitecture)	\
    ( (This)->lpVtbl -> GetArchitecture(This,pbArchitecture) ) 

#define IASFHeaderObject_GetNumObjects(This,pcObjects)	\
    ( (This)->lpVtbl -> GetNumObjects(This,pcObjects) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFHeaderObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_asfparse_0000_0006 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0006_v0_0_s_ifspec;

#ifndef __IASFDataObject_INTERFACE_DEFINED__
#define __IASFDataObject_INTERFACE_DEFINED__

/* interface IASFDataObject */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFDataObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EABAF5B1-FE37-4917-B1AB-628DEB3A09FF")
    IASFDataObject : public IASFUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetExternalSize( 
            /* [in] */ QWORD qwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileID( 
            /* [out] */ GUID *pguidFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileID( 
            /* [in] */ GUID guidFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPacketCount( 
            /* [out] */ QWORD *pcPackets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPacketCount( 
            /* [in] */ QWORD cPackets) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatePacketParser( 
            /* [out] */ IASFPacketParser **ppIASFPacketParser) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFDataObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFDataObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFDataObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFDataObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IASFDataObject * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLibrary )( 
            IASFDataObject * This,
            /* [out] */ IASFLibrary **ppASFLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *Space )( 
            IASFDataObject * This,
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IASFDataObject * This,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IASFDataObject * This,
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsHeaderExtensionObject )( 
            IASFDataObject * This,
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetExternalSize )( 
            IASFDataObject * This,
            /* [in] */ QWORD qwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileID )( 
            IASFDataObject * This,
            /* [out] */ GUID *pguidFileID);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileID )( 
            IASFDataObject * This,
            /* [in] */ GUID guidFileID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPacketCount )( 
            IASFDataObject * This,
            /* [out] */ QWORD *pcPackets);
        
        HRESULT ( STDMETHODCALLTYPE *SetPacketCount )( 
            IASFDataObject * This,
            /* [in] */ QWORD cPackets);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePacketParser )( 
            IASFDataObject * This,
            /* [out] */ IASFPacketParser **ppIASFPacketParser);
        
        END_INTERFACE
    } IASFDataObjectVtbl;

    interface IASFDataObject
    {
        CONST_VTBL struct IASFDataObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFDataObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFDataObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFDataObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFDataObject_GetObjectID(This,pguidID)	\
    ( (This)->lpVtbl -> GetObjectID(This,pguidID) ) 

#define IASFDataObject_GetLibrary(This,ppASFLibrary)	\
    ( (This)->lpVtbl -> GetLibrary(This,ppASFLibrary) ) 

#define IASFDataObject_Space(This,pqwInternalSpace,pqwExternalSpace)	\
    ( (This)->lpVtbl -> Space(This,pqwInternalSpace,pqwExternalSpace) ) 

#define IASFDataObject_Read(This,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,pcbUsed) ) 

#define IASFDataObject_Write(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,cbBuffer,pcbUsed) ) 

#define IASFDataObject_NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject)	\
    ( (This)->lpVtbl -> NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject) ) 


#define IASFDataObject_SetExternalSize(This,qwSize)	\
    ( (This)->lpVtbl -> SetExternalSize(This,qwSize) ) 

#define IASFDataObject_GetFileID(This,pguidFileID)	\
    ( (This)->lpVtbl -> GetFileID(This,pguidFileID) ) 

#define IASFDataObject_SetFileID(This,guidFileID)	\
    ( (This)->lpVtbl -> SetFileID(This,guidFileID) ) 

#define IASFDataObject_GetPacketCount(This,pcPackets)	\
    ( (This)->lpVtbl -> GetPacketCount(This,pcPackets) ) 

#define IASFDataObject_SetPacketCount(This,cPackets)	\
    ( (This)->lpVtbl -> SetPacketCount(This,cPackets) ) 

#define IASFDataObject_CreatePacketParser(This,ppIASFPacketParser)	\
    ( (This)->lpVtbl -> CreatePacketParser(This,ppIASFPacketParser) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFDataObject_INTERFACE_DEFINED__ */


#ifndef __IASFPacketParser_INTERFACE_DEFINED__
#define __IASFPacketParser_INTERFACE_DEFINED__

/* interface IASFPacketParser */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFPacketParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD177A30-3E5C-4b60-99ED-2D8BD0454642")
    IASFPacketParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamExtensionSystems( 
            /* [in] */ WORD wStreamNumber,
            /* [out] */ ASF_EXTENSION_SYSTEM *pExtensionSystems,
            /* [out] */ WORD *pcExtensionSystems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataSpaceAvailable( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BYTE bObjectID,
            /* [in] */ IMFSample *pMediaObjectWithAttributes,
            /* [out] */ DWORD *pcbDataSpaceAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPacketInfo( 
            /* [in] */ ASF_PACKET_INFO *pPacketInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPayload( 
            /* [in] */ ASF_PAYLOAD_INFO *pPayloadInfo,
            /* [in] */ IMFSample *pMFSample,
            /* [in] */ BOOL fSampleIsCompleteObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdatePayloadExtensionData( 
            /* [in] */ WORD wPayloadIndex,
            /* [in] */ REFGUID guidExtensionSystem,
            /* [in] */ BYTE *pbNewValue,
            /* [in] */ WORD cbNewValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePacket( 
            /* [out] */ IMFSample **ppASFPacket) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParsePacket( 
            /* [in] */ IMediaBuffer *pASFPacket,
            /* [in] */ DWORD cbBufferOffset,
            /* [in] */ DWORD cbBufferLength,
            /* [in] */ DWORD cbOffsetWithinPacket,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPacketInfo( 
            /* [out] */ ASF_PACKET_INFO *pPacketInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPayload( 
            /* [in] */ WORD wPayloadIndex,
            /* [out] */ ASF_PAYLOAD_INFO *pPayloadInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseReplicatedData( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BYTE *pbReplicatedData,
            /* [in] */ DWORD cbReplicatedData,
            /* [in] */ IMFSample *pMFSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFPacketParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFPacketParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFPacketParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFPacketParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamExtensionSystems )( 
            IASFPacketParser * This,
            /* [in] */ WORD wStreamNumber,
            /* [out] */ ASF_EXTENSION_SYSTEM *pExtensionSystems,
            /* [out] */ WORD *pcExtensionSystems);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataSpaceAvailable )( 
            IASFPacketParser * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BYTE bObjectID,
            /* [in] */ IMFSample *pMediaObjectWithAttributes,
            /* [out] */ DWORD *pcbDataSpaceAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *SetPacketInfo )( 
            IASFPacketParser * This,
            /* [in] */ ASF_PACKET_INFO *pPacketInfo);
        
        HRESULT ( STDMETHODCALLTYPE *AddPayload )( 
            IASFPacketParser * This,
            /* [in] */ ASF_PAYLOAD_INFO *pPayloadInfo,
            /* [in] */ IMFSample *pMFSample,
            /* [in] */ BOOL fSampleIsCompleteObject);
        
        HRESULT ( STDMETHODCALLTYPE *UpdatePayloadExtensionData )( 
            IASFPacketParser * This,
            /* [in] */ WORD wPayloadIndex,
            /* [in] */ REFGUID guidExtensionSystem,
            /* [in] */ BYTE *pbNewValue,
            /* [in] */ WORD cbNewValue);
        
        HRESULT ( STDMETHODCALLTYPE *WritePacket )( 
            IASFPacketParser * This,
            /* [out] */ IMFSample **ppASFPacket);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePacket )( 
            IASFPacketParser * This,
            /* [in] */ IMediaBuffer *pASFPacket,
            /* [in] */ DWORD cbBufferOffset,
            /* [in] */ DWORD cbBufferLength,
            /* [in] */ DWORD cbOffsetWithinPacket,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *GetPacketInfo )( 
            IASFPacketParser * This,
            /* [out] */ ASF_PACKET_INFO *pPacketInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPayload )( 
            IASFPacketParser * This,
            /* [in] */ WORD wPayloadIndex,
            /* [out] */ ASF_PAYLOAD_INFO *pPayloadInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ParseReplicatedData )( 
            IASFPacketParser * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ BYTE *pbReplicatedData,
            /* [in] */ DWORD cbReplicatedData,
            /* [in] */ IMFSample *pMFSample);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IASFPacketParser * This);
        
        END_INTERFACE
    } IASFPacketParserVtbl;

    interface IASFPacketParser
    {
        CONST_VTBL struct IASFPacketParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFPacketParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFPacketParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFPacketParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFPacketParser_GetStreamExtensionSystems(This,wStreamNumber,pExtensionSystems,pcExtensionSystems)	\
    ( (This)->lpVtbl -> GetStreamExtensionSystems(This,wStreamNumber,pExtensionSystems,pcExtensionSystems) ) 

#define IASFPacketParser_GetDataSpaceAvailable(This,wStreamNumber,bObjectID,pMediaObjectWithAttributes,pcbDataSpaceAvailable)	\
    ( (This)->lpVtbl -> GetDataSpaceAvailable(This,wStreamNumber,bObjectID,pMediaObjectWithAttributes,pcbDataSpaceAvailable) ) 

#define IASFPacketParser_SetPacketInfo(This,pPacketInfo)	\
    ( (This)->lpVtbl -> SetPacketInfo(This,pPacketInfo) ) 

#define IASFPacketParser_AddPayload(This,pPayloadInfo,pMFSample,fSampleIsCompleteObject)	\
    ( (This)->lpVtbl -> AddPayload(This,pPayloadInfo,pMFSample,fSampleIsCompleteObject) ) 

#define IASFPacketParser_UpdatePayloadExtensionData(This,wPayloadIndex,guidExtensionSystem,pbNewValue,cbNewValue)	\
    ( (This)->lpVtbl -> UpdatePayloadExtensionData(This,wPayloadIndex,guidExtensionSystem,pbNewValue,cbNewValue) ) 

#define IASFPacketParser_WritePacket(This,ppASFPacket)	\
    ( (This)->lpVtbl -> WritePacket(This,ppASFPacket) ) 

#define IASFPacketParser_ParsePacket(This,pASFPacket,cbBufferOffset,cbBufferLength,cbOffsetWithinPacket,pcbUsed)	\
    ( (This)->lpVtbl -> ParsePacket(This,pASFPacket,cbBufferOffset,cbBufferLength,cbOffsetWithinPacket,pcbUsed) ) 

#define IASFPacketParser_GetPacketInfo(This,pPacketInfo)	\
    ( (This)->lpVtbl -> GetPacketInfo(This,pPacketInfo) ) 

#define IASFPacketParser_GetPayload(This,wPayloadIndex,pPayloadInfo)	\
    ( (This)->lpVtbl -> GetPayload(This,wPayloadIndex,pPayloadInfo) ) 

#define IASFPacketParser_ParseReplicatedData(This,wStreamNumber,pbReplicatedData,cbReplicatedData,pMFSample)	\
    ( (This)->lpVtbl -> ParseReplicatedData(This,wStreamNumber,pbReplicatedData,cbReplicatedData,pMFSample) ) 

#define IASFPacketParser_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFPacketParser_INTERFACE_DEFINED__ */


#ifndef __IASFSimpleIndexObject_INTERFACE_DEFINED__
#define __IASFSimpleIndexObject_INTERFACE_DEFINED__

/* interface IASFSimpleIndexObject */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFSimpleIndexObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6B78229-4821-4347-9F3A-B66EF332B389")
    IASFSimpleIndexObject : public IASFUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIndexFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileID( 
            /* [out] */ GUID *pguidFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeInterval( 
            /* [out] */ QWORD *phnsTimeInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxPacketCount( 
            /* [out] */ DWORD *pdwMaxPacketCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryCount( 
            /* [out] */ DWORD *pcEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntry( 
            /* [in] */ DWORD dwEntry,
            /* [out] */ DWORD *pdwPacketNum,
            /* [out] */ WORD *pwPacketCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHeaderSize( 
            /* [out] */ DWORD *pcbHeaderSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntryLocation( 
            /* [in] */ DWORD dwEntry,
            /* [out] */ QWORD *pcbLocationOfPacketNumDWORD,
            /* [out] */ QWORD *pcbLocationOfPacketCountWORD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFileID( 
            /* [in] */ GUID guidFileID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeInterval( 
            /* [in] */ QWORD hnsTimeInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEntryCount( 
            /* [in] */ DWORD cEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEntry( 
            /* [in] */ DWORD dwEntry,
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ WORD wPacketCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFSimpleIndexObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFSimpleIndexObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFSimpleIndexObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFSimpleIndexObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IASFSimpleIndexObject * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLibrary )( 
            IASFSimpleIndexObject * This,
            /* [out] */ IASFLibrary **ppASFLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *Space )( 
            IASFSimpleIndexObject * This,
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IASFSimpleIndexObject * This,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IASFSimpleIndexObject * This,
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsHeaderExtensionObject )( 
            IASFSimpleIndexObject * This,
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexFlags )( 
            IASFSimpleIndexObject * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexFlags )( 
            IASFSimpleIndexObject * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileID )( 
            IASFSimpleIndexObject * This,
            /* [out] */ GUID *pguidFileID);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeInterval )( 
            IASFSimpleIndexObject * This,
            /* [out] */ QWORD *phnsTimeInterval);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxPacketCount )( 
            IASFSimpleIndexObject * This,
            /* [out] */ DWORD *pdwMaxPacketCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryCount )( 
            IASFSimpleIndexObject * This,
            /* [out] */ DWORD *pcEntries);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntry )( 
            IASFSimpleIndexObject * This,
            /* [in] */ DWORD dwEntry,
            /* [out] */ DWORD *pdwPacketNum,
            /* [out] */ WORD *pwPacketCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHeaderSize )( 
            IASFSimpleIndexObject * This,
            /* [out] */ DWORD *pcbHeaderSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntryLocation )( 
            IASFSimpleIndexObject * This,
            /* [in] */ DWORD dwEntry,
            /* [out] */ QWORD *pcbLocationOfPacketNumDWORD,
            /* [out] */ QWORD *pcbLocationOfPacketCountWORD);
        
        HRESULT ( STDMETHODCALLTYPE *SetFileID )( 
            IASFSimpleIndexObject * This,
            /* [in] */ GUID guidFileID);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeInterval )( 
            IASFSimpleIndexObject * This,
            /* [in] */ QWORD hnsTimeInterval);
        
        HRESULT ( STDMETHODCALLTYPE *SetEntryCount )( 
            IASFSimpleIndexObject * This,
            /* [in] */ DWORD cEntries);
        
        HRESULT ( STDMETHODCALLTYPE *SetEntry )( 
            IASFSimpleIndexObject * This,
            /* [in] */ DWORD dwEntry,
            /* [in] */ DWORD dwPacketNum,
            /* [in] */ WORD wPacketCount);
        
        END_INTERFACE
    } IASFSimpleIndexObjectVtbl;

    interface IASFSimpleIndexObject
    {
        CONST_VTBL struct IASFSimpleIndexObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFSimpleIndexObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFSimpleIndexObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFSimpleIndexObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFSimpleIndexObject_GetObjectID(This,pguidID)	\
    ( (This)->lpVtbl -> GetObjectID(This,pguidID) ) 

#define IASFSimpleIndexObject_GetLibrary(This,ppASFLibrary)	\
    ( (This)->lpVtbl -> GetLibrary(This,ppASFLibrary) ) 

#define IASFSimpleIndexObject_Space(This,pqwInternalSpace,pqwExternalSpace)	\
    ( (This)->lpVtbl -> Space(This,pqwInternalSpace,pqwExternalSpace) ) 

#define IASFSimpleIndexObject_Read(This,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,pcbUsed) ) 

#define IASFSimpleIndexObject_Write(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,cbBuffer,pcbUsed) ) 

#define IASFSimpleIndexObject_NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject)	\
    ( (This)->lpVtbl -> NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject) ) 


#define IASFSimpleIndexObject_SetIndexFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetIndexFlags(This,dwFlags) ) 

#define IASFSimpleIndexObject_GetIndexFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetIndexFlags(This,pdwFlags) ) 

#define IASFSimpleIndexObject_GetFileID(This,pguidFileID)	\
    ( (This)->lpVtbl -> GetFileID(This,pguidFileID) ) 

#define IASFSimpleIndexObject_GetTimeInterval(This,phnsTimeInterval)	\
    ( (This)->lpVtbl -> GetTimeInterval(This,phnsTimeInterval) ) 

#define IASFSimpleIndexObject_GetMaxPacketCount(This,pdwMaxPacketCount)	\
    ( (This)->lpVtbl -> GetMaxPacketCount(This,pdwMaxPacketCount) ) 

#define IASFSimpleIndexObject_GetEntryCount(This,pcEntries)	\
    ( (This)->lpVtbl -> GetEntryCount(This,pcEntries) ) 

#define IASFSimpleIndexObject_GetEntry(This,dwEntry,pdwPacketNum,pwPacketCount)	\
    ( (This)->lpVtbl -> GetEntry(This,dwEntry,pdwPacketNum,pwPacketCount) ) 

#define IASFSimpleIndexObject_GetHeaderSize(This,pcbHeaderSize)	\
    ( (This)->lpVtbl -> GetHeaderSize(This,pcbHeaderSize) ) 

#define IASFSimpleIndexObject_GetEntryLocation(This,dwEntry,pcbLocationOfPacketNumDWORD,pcbLocationOfPacketCountWORD)	\
    ( (This)->lpVtbl -> GetEntryLocation(This,dwEntry,pcbLocationOfPacketNumDWORD,pcbLocationOfPacketCountWORD) ) 

#define IASFSimpleIndexObject_SetFileID(This,guidFileID)	\
    ( (This)->lpVtbl -> SetFileID(This,guidFileID) ) 

#define IASFSimpleIndexObject_SetTimeInterval(This,hnsTimeInterval)	\
    ( (This)->lpVtbl -> SetTimeInterval(This,hnsTimeInterval) ) 

#define IASFSimpleIndexObject_SetEntryCount(This,cEntries)	\
    ( (This)->lpVtbl -> SetEntryCount(This,cEntries) ) 

#define IASFSimpleIndexObject_SetEntry(This,dwEntry,dwPacketNum,wPacketCount)	\
    ( (This)->lpVtbl -> SetEntry(This,dwEntry,dwPacketNum,wPacketCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFSimpleIndexObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_asfparse_0000_0009 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0009_v0_0_s_ifspec;

#ifndef __IASFIndexObject_INTERFACE_DEFINED__
#define __IASFIndexObject_INTERFACE_DEFINED__

/* interface IASFIndexObject */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFIndexObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1B069C0-652B-45b1-B56E-C22C992C7E64")
    IASFIndexObject : public IASFUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIndexFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterval( 
            /* [out] */ DWORD *pdwInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexSpecifierCount( 
            /* [out] */ WORD *pcIndexSpecifiers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexSpecifier( 
            /* [in] */ WORD wIndexSpecifier,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ ASF_INTERNAL_INDEX_TYPE *pIndexType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecifierForStream( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ WORD *pwSpecifierNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexBlockCount( 
            /* [out] */ DWORD *pcBlocks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexBlock( 
            /* [in] */ DWORD dwBlock,
            /* [out] */ IASFIndexBlock **ppIndexBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexBlockHeaderSize( 
            /* [out] */ DWORD *pcbIndexBlockHeaderSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindIndexBlockContainingValue( 
            /* [in] */ QWORD qwValue,
            /* [out] */ IASFIndexBlock **ppIndexBlock,
            /* [out] */ DWORD *pdwBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffsetToStartOfBlock( 
            /* [in] */ IASFIndexBlock *pIndexBlock,
            /* [out] */ QWORD *pcbOffsetWithinIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreviousEntryCount( 
            /* [in] */ IASFIndexBlock *pIndexBlock,
            /* [out] */ QWORD *pcEntriesUpToThisBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterval( 
            /* [in] */ DWORD dwInterval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIndexSpecifier( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllIndexSpecifiers( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIndexBlock( 
            /* [out] */ IASFIndexBlock **ppIndexBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveIndexBlock( 
            /* [in] */ DWORD dwBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllIndexBlocks( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFIndexObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFIndexObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFIndexObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFIndexObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectID )( 
            IASFIndexObject * This,
            /* [out] */ GUID *pguidID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLibrary )( 
            IASFIndexObject * This,
            /* [out] */ IASFLibrary **ppASFLibrary);
        
        HRESULT ( STDMETHODCALLTYPE *Space )( 
            IASFIndexObject * This,
            /* [out] */ QWORD *pqwInternalSpace,
            /* [out] */ QWORD *pqwExternalSpace);
        
        HRESULT ( STDMETHODCALLTYPE *Read )( 
            IASFIndexObject * This,
            /* [in] */ IMediaBuffer *pBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Write )( 
            IASFIndexObject * This,
            /* [size_is][in] */ BYTE *pbBuffer,
            /* [in] */ DWORD cbBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsHeaderExtensionObject )( 
            IASFIndexObject * This,
            /* [out] */ BOOL *pfNeedsHeaderExtensionObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexFlags )( 
            IASFIndexObject * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexFlags )( 
            IASFIndexObject * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterval )( 
            IASFIndexObject * This,
            /* [out] */ DWORD *pdwInterval);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexSpecifierCount )( 
            IASFIndexObject * This,
            /* [out] */ WORD *pcIndexSpecifiers);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexSpecifier )( 
            IASFIndexObject * This,
            /* [in] */ WORD wIndexSpecifier,
            /* [out] */ WORD *pwStreamNumber,
            /* [out] */ ASF_INTERNAL_INDEX_TYPE *pIndexType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecifierForStream )( 
            IASFIndexObject * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ WORD *pwSpecifierNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexBlockCount )( 
            IASFIndexObject * This,
            /* [out] */ DWORD *pcBlocks);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexBlock )( 
            IASFIndexObject * This,
            /* [in] */ DWORD dwBlock,
            /* [out] */ IASFIndexBlock **ppIndexBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexBlockHeaderSize )( 
            IASFIndexObject * This,
            /* [out] */ DWORD *pcbIndexBlockHeaderSize);
        
        HRESULT ( STDMETHODCALLTYPE *FindIndexBlockContainingValue )( 
            IASFIndexObject * This,
            /* [in] */ QWORD qwValue,
            /* [out] */ IASFIndexBlock **ppIndexBlock,
            /* [out] */ DWORD *pdwBlock);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffsetToStartOfBlock )( 
            IASFIndexObject * This,
            /* [in] */ IASFIndexBlock *pIndexBlock,
            /* [out] */ QWORD *pcbOffsetWithinIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreviousEntryCount )( 
            IASFIndexObject * This,
            /* [in] */ IASFIndexBlock *pIndexBlock,
            /* [out] */ QWORD *pcEntriesUpToThisBlock);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterval )( 
            IASFIndexObject * This,
            /* [in] */ DWORD dwInterval);
        
        HRESULT ( STDMETHODCALLTYPE *AddIndexSpecifier )( 
            IASFIndexObject * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllIndexSpecifiers )( 
            IASFIndexObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIndexBlock )( 
            IASFIndexObject * This,
            /* [out] */ IASFIndexBlock **ppIndexBlock);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveIndexBlock )( 
            IASFIndexObject * This,
            /* [in] */ DWORD dwBlock);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAllIndexBlocks )( 
            IASFIndexObject * This);
        
        END_INTERFACE
    } IASFIndexObjectVtbl;

    interface IASFIndexObject
    {
        CONST_VTBL struct IASFIndexObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFIndexObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFIndexObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFIndexObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFIndexObject_GetObjectID(This,pguidID)	\
    ( (This)->lpVtbl -> GetObjectID(This,pguidID) ) 

#define IASFIndexObject_GetLibrary(This,ppASFLibrary)	\
    ( (This)->lpVtbl -> GetLibrary(This,ppASFLibrary) ) 

#define IASFIndexObject_Space(This,pqwInternalSpace,pqwExternalSpace)	\
    ( (This)->lpVtbl -> Space(This,pqwInternalSpace,pqwExternalSpace) ) 

#define IASFIndexObject_Read(This,pBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Read(This,pBuffer,pcbUsed) ) 

#define IASFIndexObject_Write(This,pbBuffer,cbBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> Write(This,pbBuffer,cbBuffer,pcbUsed) ) 

#define IASFIndexObject_NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject)	\
    ( (This)->lpVtbl -> NeedsHeaderExtensionObject(This,pfNeedsHeaderExtensionObject) ) 


#define IASFIndexObject_SetIndexFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetIndexFlags(This,dwFlags) ) 

#define IASFIndexObject_GetIndexFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetIndexFlags(This,pdwFlags) ) 

#define IASFIndexObject_GetInterval(This,pdwInterval)	\
    ( (This)->lpVtbl -> GetInterval(This,pdwInterval) ) 

#define IASFIndexObject_GetIndexSpecifierCount(This,pcIndexSpecifiers)	\
    ( (This)->lpVtbl -> GetIndexSpecifierCount(This,pcIndexSpecifiers) ) 

#define IASFIndexObject_GetIndexSpecifier(This,wIndexSpecifier,pwStreamNumber,pIndexType)	\
    ( (This)->lpVtbl -> GetIndexSpecifier(This,wIndexSpecifier,pwStreamNumber,pIndexType) ) 

#define IASFIndexObject_GetSpecifierForStream(This,wStreamNumber,IndexType,pwSpecifierNumber)	\
    ( (This)->lpVtbl -> GetSpecifierForStream(This,wStreamNumber,IndexType,pwSpecifierNumber) ) 

#define IASFIndexObject_GetIndexBlockCount(This,pcBlocks)	\
    ( (This)->lpVtbl -> GetIndexBlockCount(This,pcBlocks) ) 

#define IASFIndexObject_GetIndexBlock(This,dwBlock,ppIndexBlock)	\
    ( (This)->lpVtbl -> GetIndexBlock(This,dwBlock,ppIndexBlock) ) 

#define IASFIndexObject_GetIndexBlockHeaderSize(This,pcbIndexBlockHeaderSize)	\
    ( (This)->lpVtbl -> GetIndexBlockHeaderSize(This,pcbIndexBlockHeaderSize) ) 

#define IASFIndexObject_FindIndexBlockContainingValue(This,qwValue,ppIndexBlock,pdwBlock)	\
    ( (This)->lpVtbl -> FindIndexBlockContainingValue(This,qwValue,ppIndexBlock,pdwBlock) ) 

#define IASFIndexObject_GetOffsetToStartOfBlock(This,pIndexBlock,pcbOffsetWithinIndex)	\
    ( (This)->lpVtbl -> GetOffsetToStartOfBlock(This,pIndexBlock,pcbOffsetWithinIndex) ) 

#define IASFIndexObject_GetPreviousEntryCount(This,pIndexBlock,pcEntriesUpToThisBlock)	\
    ( (This)->lpVtbl -> GetPreviousEntryCount(This,pIndexBlock,pcEntriesUpToThisBlock) ) 

#define IASFIndexObject_SetInterval(This,dwInterval)	\
    ( (This)->lpVtbl -> SetInterval(This,dwInterval) ) 

#define IASFIndexObject_AddIndexSpecifier(This,wStreamNumber,IndexType)	\
    ( (This)->lpVtbl -> AddIndexSpecifier(This,wStreamNumber,IndexType) ) 

#define IASFIndexObject_RemoveAllIndexSpecifiers(This)	\
    ( (This)->lpVtbl -> RemoveAllIndexSpecifiers(This) ) 

#define IASFIndexObject_CreateIndexBlock(This,ppIndexBlock)	\
    ( (This)->lpVtbl -> CreateIndexBlock(This,ppIndexBlock) ) 

#define IASFIndexObject_RemoveIndexBlock(This,dwBlock)	\
    ( (This)->lpVtbl -> RemoveIndexBlock(This,dwBlock) ) 

#define IASFIndexObject_RemoveAllIndexBlocks(This)	\
    ( (This)->lpVtbl -> RemoveAllIndexBlocks(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFIndexObject_INTERFACE_DEFINED__ */


#ifndef __IASFIndexBlock_INTERFACE_DEFINED__
#define __IASFIndexBlock_INTERFACE_DEFINED__

/* interface IASFIndexBlock */
/* [unique][version][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IASFIndexBlock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82C3E681-A69A-4e0a-8C82-2FA9FBEA280F")
    IASFIndexBlock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIndexBlockFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexBlockFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadIndexBlock( 
            /* [in] */ IMediaBuffer *pIndexBuffer,
            /* [in] */ DWORD cbOffsetWithinBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBlockSize( 
            /* [out] */ QWORD *pcbIndexBlockSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPerEntrySize( 
            /* [out] */ DWORD *pcbPerEntrySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBlockBaseOffset( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ QWORD *pcbBlockBaseOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexEntryCount( 
            /* [out] */ DWORD *pcIndexEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexEntry( 
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ DWORD *pcbOffsetFromBlockBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexEntryLocation( 
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ QWORD *pcbLocationOfIndexEntryDWORD) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteIndexBlock( 
            /* [in] */ BYTE *pbIndexBuffer,
            /* [in] */ DWORD cbIndexBuffer,
            /* [out] */ DWORD *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBlockBaseOffset( 
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [in] */ QWORD cbBlockBaseOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexEntryCount( 
            /* [in] */ DWORD cIndexEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIndexEntry( 
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [in] */ DWORD cbOffsetFromBlockBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimecodeRange( 
            /* [in] */ WORD wRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecodeRange( 
            /* [out] */ WORD *pwRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [in] */ DWORD dwIndexEntry,
            /* [out] */ DWORD *pTimecode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LocateTimecode( 
            /* [in] */ DWORD dwTimecode,
            /* [out] */ DWORD *pEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IASFIndexBlockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IASFIndexBlock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IASFIndexBlock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IASFIndexBlock * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexBlockFlags )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexBlockFlags )( 
            IASFIndexBlock * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ReadIndexBlock )( 
            IASFIndexBlock * This,
            /* [in] */ IMediaBuffer *pIndexBuffer,
            /* [in] */ DWORD cbOffsetWithinBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlockSize )( 
            IASFIndexBlock * This,
            /* [out] */ QWORD *pcbIndexBlockSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPerEntrySize )( 
            IASFIndexBlock * This,
            /* [out] */ DWORD *pcbPerEntrySize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlockBaseOffset )( 
            IASFIndexBlock * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ QWORD *pcbBlockBaseOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexEntryCount )( 
            IASFIndexBlock * This,
            /* [out] */ DWORD *pcIndexEntries);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexEntry )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ DWORD *pcbOffsetFromBlockBase);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndexEntryLocation )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [out] */ QWORD *pcbLocationOfIndexEntryDWORD);
        
        HRESULT ( STDMETHODCALLTYPE *WriteIndexBlock )( 
            IASFIndexBlock * This,
            /* [in] */ BYTE *pbIndexBuffer,
            /* [in] */ DWORD cbIndexBuffer,
            /* [out] */ DWORD *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *SetBlockBaseOffset )( 
            IASFIndexBlock * This,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [in] */ QWORD cbBlockBaseOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexEntryCount )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD cIndexEntries);
        
        HRESULT ( STDMETHODCALLTYPE *SetIndexEntry )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwEntry,
            /* [in] */ WORD wStreamNumber,
            /* [in] */ ASF_INTERNAL_INDEX_TYPE IndexType,
            /* [in] */ DWORD cbOffsetFromBlockBase);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimecodeRange )( 
            IASFIndexBlock * This,
            /* [in] */ WORD wRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecodeRange )( 
            IASFIndexBlock * This,
            /* [out] */ WORD *pwRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwIndexEntry,
            /* [out] */ DWORD *pTimecode);
        
        HRESULT ( STDMETHODCALLTYPE *LocateTimecode )( 
            IASFIndexBlock * This,
            /* [in] */ DWORD dwTimecode,
            /* [out] */ DWORD *pEntry);
        
        END_INTERFACE
    } IASFIndexBlockVtbl;

    interface IASFIndexBlock
    {
        CONST_VTBL struct IASFIndexBlockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IASFIndexBlock_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IASFIndexBlock_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IASFIndexBlock_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IASFIndexBlock_SetIndexBlockFlags(This,dwFlags)	\
    ( (This)->lpVtbl -> SetIndexBlockFlags(This,dwFlags) ) 

#define IASFIndexBlock_GetIndexBlockFlags(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetIndexBlockFlags(This,pdwFlags) ) 

#define IASFIndexBlock_ReadIndexBlock(This,pIndexBuffer,cbOffsetWithinBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> ReadIndexBlock(This,pIndexBuffer,cbOffsetWithinBuffer,pcbUsed) ) 

#define IASFIndexBlock_GetBlockSize(This,pcbIndexBlockSize)	\
    ( (This)->lpVtbl -> GetBlockSize(This,pcbIndexBlockSize) ) 

#define IASFIndexBlock_GetPerEntrySize(This,pcbPerEntrySize)	\
    ( (This)->lpVtbl -> GetPerEntrySize(This,pcbPerEntrySize) ) 

#define IASFIndexBlock_GetBlockBaseOffset(This,wStreamNumber,IndexType,pcbBlockBaseOffset)	\
    ( (This)->lpVtbl -> GetBlockBaseOffset(This,wStreamNumber,IndexType,pcbBlockBaseOffset) ) 

#define IASFIndexBlock_GetIndexEntryCount(This,pcIndexEntries)	\
    ( (This)->lpVtbl -> GetIndexEntryCount(This,pcIndexEntries) ) 

#define IASFIndexBlock_GetIndexEntry(This,dwEntry,wStreamNumber,IndexType,pcbOffsetFromBlockBase)	\
    ( (This)->lpVtbl -> GetIndexEntry(This,dwEntry,wStreamNumber,IndexType,pcbOffsetFromBlockBase) ) 

#define IASFIndexBlock_GetIndexEntryLocation(This,dwEntry,wStreamNumber,IndexType,pcbLocationOfIndexEntryDWORD)	\
    ( (This)->lpVtbl -> GetIndexEntryLocation(This,dwEntry,wStreamNumber,IndexType,pcbLocationOfIndexEntryDWORD) ) 

#define IASFIndexBlock_WriteIndexBlock(This,pbIndexBuffer,cbIndexBuffer,pcbUsed)	\
    ( (This)->lpVtbl -> WriteIndexBlock(This,pbIndexBuffer,cbIndexBuffer,pcbUsed) ) 

#define IASFIndexBlock_SetBlockBaseOffset(This,wStreamNumber,IndexType,cbBlockBaseOffset)	\
    ( (This)->lpVtbl -> SetBlockBaseOffset(This,wStreamNumber,IndexType,cbBlockBaseOffset) ) 

#define IASFIndexBlock_SetIndexEntryCount(This,cIndexEntries)	\
    ( (This)->lpVtbl -> SetIndexEntryCount(This,cIndexEntries) ) 

#define IASFIndexBlock_SetIndexEntry(This,dwEntry,wStreamNumber,IndexType,cbOffsetFromBlockBase)	\
    ( (This)->lpVtbl -> SetIndexEntry(This,dwEntry,wStreamNumber,IndexType,cbOffsetFromBlockBase) ) 

#define IASFIndexBlock_SetTimecodeRange(This,wRange)	\
    ( (This)->lpVtbl -> SetTimecodeRange(This,wRange) ) 

#define IASFIndexBlock_GetTimecodeRange(This,pwRange)	\
    ( (This)->lpVtbl -> GetTimecodeRange(This,pwRange) ) 

#define IASFIndexBlock_GetTimecode(This,dwIndexEntry,pTimecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,dwIndexEntry,pTimecode) ) 

#define IASFIndexBlock_LocateTimecode(This,dwTimecode,pEntry)	\
    ( (This)->lpVtbl -> LocateTimecode(This,dwTimecode,pEntry) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IASFIndexBlock_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_asfparse_0000_0011 */
/* [local] */ 

typedef struct _ASF_EXTENSION_DATA_SMPTE
    {
    BYTE wRange[ 2 ];
    BYTE Timecode[ 4 ];
    BYTE dwUserbits[ 4 ];
    BYTE dwAmFlags[ 4 ];
    } 	ASF_EXTENSION_DATA_SMPTE;

#pragma pack(pop, enter_asfparse)


extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_asfparse_0000_0011_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\autodiscovery.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 15:48:06 2007
 */
/* Compiler settings for ..\AutoDiscovery.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __AutoDiscovery_h__
#define __AutoDiscovery_h__

/* Forward Declarations */ 

#ifndef __IAutoDiscoveryProvider_FWD_DEFINED__
#define __IAutoDiscoveryProvider_FWD_DEFINED__
typedef interface IAutoDiscoveryProvider IAutoDiscoveryProvider;
#endif 	/* __IAutoDiscoveryProvider_FWD_DEFINED__ */


#ifndef __AutoDiscoveryProvider_FWD_DEFINED__
#define __AutoDiscoveryProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class AutoDiscoveryProvider AutoDiscoveryProvider;
#else
typedef struct AutoDiscoveryProvider AutoDiscoveryProvider;
#endif /* __cplusplus */

#endif 	/* __AutoDiscoveryProvider_FWD_DEFINED__ */


#ifndef __IMailAutoDiscovery_FWD_DEFINED__
#define __IMailAutoDiscovery_FWD_DEFINED__
typedef interface IMailAutoDiscovery IMailAutoDiscovery;
#endif 	/* __IMailAutoDiscovery_FWD_DEFINED__ */


#ifndef __IAccountDiscovery_FWD_DEFINED__
#define __IAccountDiscovery_FWD_DEFINED__
typedef interface IAccountDiscovery IAccountDiscovery;
#endif 	/* __IAccountDiscovery_FWD_DEFINED__ */


#ifndef __AccountDiscovery_FWD_DEFINED__
#define __AccountDiscovery_FWD_DEFINED__

#ifdef __cplusplus
typedef class AccountDiscovery AccountDiscovery;
#else
typedef struct AccountDiscovery AccountDiscovery;
#endif /* __cplusplus */

#endif 	/* __AccountDiscovery_FWD_DEFINED__ */


#ifndef __IMailProtocolADEntry_FWD_DEFINED__
#define __IMailProtocolADEntry_FWD_DEFINED__
typedef interface IMailProtocolADEntry IMailProtocolADEntry;
#endif 	/* __IMailProtocolADEntry_FWD_DEFINED__ */


#ifndef __MailProtocolADEntry_FWD_DEFINED__
#define __MailProtocolADEntry_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailProtocolADEntry MailProtocolADEntry;
#else
typedef struct MailProtocolADEntry MailProtocolADEntry;
#endif /* __cplusplus */

#endif 	/* __MailProtocolADEntry_FWD_DEFINED__ */


#ifndef __MailAutoDiscovery_FWD_DEFINED__
#define __MailAutoDiscovery_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailAutoDiscovery MailAutoDiscovery;
#else
typedef struct MailAutoDiscovery MailAutoDiscovery;
#endif /* __cplusplus */

#endif 	/* __MailAutoDiscovery_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_AutoDiscovery_0000 */
/* [local] */ 

#ifndef _AUTODISCOVERY_IDL_H_
#define _AUTODISCOVERY_IDL_H_
// This API started shipping in IE 6
#if (_WIN32_IE >= 0x0600)



extern RPC_IF_HANDLE __MIDL_itf_AutoDiscovery_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_AutoDiscovery_0000_v0_0_s_ifspec;


#ifndef __AutoDiscovery_LIBRARY_DEFINED__
#define __AutoDiscovery_LIBRARY_DEFINED__

/* library AutoDiscovery */
/* [version][helpstring][uuid] */ 


#ifndef __LPAUTODISCOVERYPROVIDER_DEFINED
#define __LPAUTODISCOVERYPROVIDER_DEFINED
//===================================================================
//DESCRIPTION:
//   This object will list the servers that will be tried when attempting
//to download results.
//
//METHODS:
//length: The number of servers.
//item: Fetch the host name of the server that will be contacted.
//===================================================================
#endif //  __LPAUTODISCOVERYPROVIDER_DEFINED

#ifndef __LPACCOUNTDISCOVERY_DEFINED
#define __LPACCOUNTDISCOVERY_DEFINED
//===================================================================
//DESCRIPTION:
//  This interface can be used by simply calling ::DiscoverNow().  It
//will synchronously:
//1. use bstrEmailAddress to find the domain name to contact.  For example
//   for JoeUser@yahoo.com, it will contact http://_AutoDiscovery.yahoo.com/_AutoDiscovery/default.asp
//   and that fails, it will contact then http://yahoo.com/_AutoDiscovery/default.asp.
//2. The bstrXMLRequest XML will be put into the HTTP headers so it can
//   be parsed by the server.
//3. The response from the server will be returned in ppXMLResponse
//
//METHODS:
//If you want the operation to happen asynchronously, first call
//::WorkAsync().  A subsequent call to ::DiscoverNow() will start the operation and return
//  immediately and ppXMLResponse will be NULL.  The wMsg passed to WorkAsync() will allow
//  the async thread to send status to the forground window/thread.  AutoDiscovery is allowed
//  to send messages with ID wMsg through wMsg+10.  Callers normally will want to pass
//  (WM_USER + n) for this message ID.  These are the messages that the async thread will send:
//  [wMsg+0]: Means AutoDiscovery ended.  The LPARAM will contain the XML normally returned in ppXMLResponse,
//            except it will be in a BSTR.  The wndproc needs to free the LPARAM with SysFreeString()
//            if it isn't NULL.  The WPARAM will contain the HRESULT error value.
//  [wMsg+1]: Status String.  The WPARAM will contain a UNICODE string containing status that can be displayed
//            to the user.  The wndproc needs to call LocalFree() on the WPARAM when done using it.  The LPARAM will be NULL.
//  Calling ::WorkAsync() with a NULL hwnd will indicate that the call should be synchronous,
//  which is also the default behavior.
//===================================================================
#endif //  __LPACCOUNTDISCOVERY_DEFINED

#ifndef __LPMAILPROTOCOLADENTRY_DEFINED
#define __LPMAILPROTOCOLADENTRY_DEFINED
//===================================================================
//DESCRIPTION:
//   Methods will return HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if the
//information could not be found in the XML results.  This will
//very often happen with LoginName() and ServerPort().
//
//METHODS:
//Protocol: The name of this protocol.  See STR_PT_*.
//ServerName: This will be the name of the server to contact.
//         For DAVMail and WEB, this will be an URL.
//         For most other protocols, this will be an IP address
//         or the hostname of the server.
//ServerPort: This is the port number on the server to use.
//LoginName: The username to log into the email server if a username
//         other than the username in the email address (<username>@<domainname>)
//         is needed.
//PostHTML: Reserved for future use.
//UseSSL: If TRUE, use SSL when connecting to ServerName.
//UseSPA: If TRUE, SPA (Secure Password Authenication) should
//         be used when contacting the server.
//IsAuthRequired: This is only applicable to the SMTP protocol.
//         If TRUE, the SMTP server requires the client to authenticate
//         when logging in.
//SMTPUsesPOP3Auth: This is only applicable to the SMTP protocol.
//         If TRUE, the login name and password for the POP3 or IMAP
//         server can be used to log into the SMTP server.
//===================================================================
#endif //  __LPMAILPROTOCOLADENTRY_DEFINED

#ifndef __LPMAILAUTODISCOVERY_DEFINED
#define __LPMAILAUTODISCOVERY_DEFINED
//===================================================================
//DESCRIPTION:
//   Methods will return HRESULT_FROM_WIN32(ERROR_NOT_FOUND) if the
//information could not be found in the XML results.  This will
//very often happen with DisplayName() and ServerPort().
//
//METHODS:
//DisplayName: This is the display name or the user's full name that
//             may or may not be specified by the server.
//InfoURL: This is an URL that the server or service can provide
//         for the user to learn more about the email service
//         or how to access their email.  Email clients that don't
//         support any of the protocols offered by the server can
//         launch this URL.  The URL can then tell users which
//         email clients to use or how to configure the email client.
//         email clients to use or how to configure the email client.
//PreferedProtocolType: This will return the server's prefered protocol.
//             The string will be one of STR_PT_* and can be passed to.
//             item() to get more information.
//length: The number of protocols the server supports.
//item: The caller can pass the index of the protocol to access or
//      ask for a particular protocol (by STR_PT_*).
//xml: The caller can get the AutoDiscovery XML from the server.
//      This will allow email clients to get properties not currently
//      exposed throught this interface.
//PrimaryProviders: Get the list of primary servers that will be
//         contacted in order to download the results.  This will
//         allow the application to display this list to the user.
//         The full email password will be uploaded to these servers
//         in some cases.
//SecondaryProviders: This will also list servers that will be contacted
//         except, as secondary servers, only the user's email hostname
//         will be uploaded (not the username part of the email address.
//
//DiscoverMail: Use the email address provided to download the 
//      AutoDiscovery XML file.  This object can then be used to
//      get information from that XML file.
//PurgeCache: If the downloaded settings are cached, purge the
//      cache so the next call to DiscoverMail() is guaranteed
//      to get the most current settings from the server.
//WorkAsync: See WorkAsync's documentation in IAutoDiscovery.
//===================================================================
#endif //  __LPMAILAUTODISCOVERY_DEFINED

EXTERN_C const IID LIBID_AutoDiscovery;

#ifndef __IAutoDiscoveryProvider_INTERFACE_DEFINED__
#define __IAutoDiscoveryProvider_INTERFACE_DEFINED__

/* interface IAutoDiscoveryProvider */
/* [uuid][nonextensible][dual][oleautomation][object] */ 

typedef /* [unique] */ IAutoDiscoveryProvider __RPC_FAR *LPAUTODISCOVERYPROVIDER;


EXTERN_C const IID IID_IAutoDiscoveryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DCF4A37-01DE-4549-A9CB-3AC31EC23C4F")
    IAutoDiscoveryProvider : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *pnLength) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ VARIANT varIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoDiscoveryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAutoDiscoveryProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAutoDiscoveryProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pnLength);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IAutoDiscoveryProvider __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        END_INTERFACE
    } IAutoDiscoveryProviderVtbl;

    interface IAutoDiscoveryProvider
    {
        CONST_VTBL struct IAutoDiscoveryProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoDiscoveryProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoDiscoveryProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoDiscoveryProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoDiscoveryProvider_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAutoDiscoveryProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAutoDiscoveryProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAutoDiscoveryProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAutoDiscoveryProvider_get_length(This,pnLength)	\
    (This)->lpVtbl -> get_length(This,pnLength)

#define IAutoDiscoveryProvider_get_item(This,varIndex,pbstr)	\
    (This)->lpVtbl -> get_item(This,varIndex,pbstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAutoDiscoveryProvider_get_length_Proxy( 
    IAutoDiscoveryProvider __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pnLength);


void __RPC_STUB IAutoDiscoveryProvider_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IAutoDiscoveryProvider_get_item_Proxy( 
    IAutoDiscoveryProvider __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IAutoDiscoveryProvider_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoDiscoveryProvider_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AutoDiscoveryProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("C4F3D5BF-4809-44e3-84A4-368B6B33B0B4")
AutoDiscoveryProvider;
#endif

#ifndef __IMailAutoDiscovery_INTERFACE_DEFINED__
#define __IMailAutoDiscovery_INTERFACE_DEFINED__

/* interface IMailAutoDiscovery */
/* [uuid][nonextensible][dual][oleautomation][object] */ 

typedef /* [unique] */ IMailAutoDiscovery __RPC_FAR *LPMAILAUTODISCOVERY;

// Protocol Types for ServerName(bstrServerType))
#define STR_PT_POP                   L"POP3"
#define STR_PT_SMTP                  L"SMTP"
#define STR_PT_IMAP                  L"IMAP"
#define STR_PT_MAPI                  L"MAPI"
#define STR_PT_DAVMAIL               L"DAVMail"
#define STR_PT_SMTP                  L"SMTP"
#define STR_PT_WEBBASED              L"WEB"        // Web pages are used to receive and send mail.

EXTERN_C const IID IID_IMailAutoDiscovery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80402DEE-B114-4d32-B44E-82FD8234C92A")
    IMailAutoDiscovery : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InfoURL( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstrURL) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PreferedProtocolType( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProtocolType) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *pnLength) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_item( 
            /* [in] */ VARIANT varIndex,
            /* [out][retval] */ IMailProtocolADEntry __RPC_FAR *__RPC_FAR *ppMailProtocol) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_XML( 
            /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLDoc) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_XML( 
            /* [in] */ IXMLDOMDocument __RPC_FAR *pXMLDoc) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE getPrimaryProviders( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE getSecondaryProviders( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE DiscoverMail( 
            /* [in] */ BSTR bstrEmailAddress) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE PurgeCache( void) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE WorkAsync( 
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailAutoDiscoveryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailAutoDiscovery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailAutoDiscovery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InfoURL )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrURL);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreferedProtocolType )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstrProtocolType);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pnLength);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ VARIANT varIndex,
            /* [out][retval] */ IMailProtocolADEntry __RPC_FAR *__RPC_FAR *ppMailProtocol);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XML )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLDoc);
        
        /* [bindable][displaybind][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XML )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ IXMLDOMDocument __RPC_FAR *pXMLDoc);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getPrimaryProviders )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSecondaryProviders )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscoverMail )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PurgeCache )( 
            IMailAutoDiscovery __RPC_FAR * This);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WorkAsync )( 
            IMailAutoDiscovery __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsg);
        
        END_INTERFACE
    } IMailAutoDiscoveryVtbl;

    interface IMailAutoDiscovery
    {
        CONST_VTBL struct IMailAutoDiscoveryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailAutoDiscovery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailAutoDiscovery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailAutoDiscovery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailAutoDiscovery_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailAutoDiscovery_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailAutoDiscovery_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailAutoDiscovery_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailAutoDiscovery_get_DisplayName(This,pbstr)	\
    (This)->lpVtbl -> get_DisplayName(This,pbstr)

#define IMailAutoDiscovery_get_InfoURL(This,pbstrURL)	\
    (This)->lpVtbl -> get_InfoURL(This,pbstrURL)

#define IMailAutoDiscovery_get_PreferedProtocolType(This,pbstrProtocolType)	\
    (This)->lpVtbl -> get_PreferedProtocolType(This,pbstrProtocolType)

#define IMailAutoDiscovery_get_length(This,pnLength)	\
    (This)->lpVtbl -> get_length(This,pnLength)

#define IMailAutoDiscovery_get_item(This,varIndex,ppMailProtocol)	\
    (This)->lpVtbl -> get_item(This,varIndex,ppMailProtocol)

#define IMailAutoDiscovery_get_XML(This,ppXMLDoc)	\
    (This)->lpVtbl -> get_XML(This,ppXMLDoc)

#define IMailAutoDiscovery_put_XML(This,pXMLDoc)	\
    (This)->lpVtbl -> put_XML(This,pXMLDoc)

#define IMailAutoDiscovery_getPrimaryProviders(This,bstrEmailAddress,ppProviders)	\
    (This)->lpVtbl -> getPrimaryProviders(This,bstrEmailAddress,ppProviders)

#define IMailAutoDiscovery_getSecondaryProviders(This,bstrEmailAddress,ppProviders)	\
    (This)->lpVtbl -> getSecondaryProviders(This,bstrEmailAddress,ppProviders)

#define IMailAutoDiscovery_DiscoverMail(This,bstrEmailAddress)	\
    (This)->lpVtbl -> DiscoverMail(This,bstrEmailAddress)

#define IMailAutoDiscovery_PurgeCache(This)	\
    (This)->lpVtbl -> PurgeCache(This)

#define IMailAutoDiscovery_WorkAsync(This,hwnd,wMsg)	\
    (This)->lpVtbl -> WorkAsync(This,hwnd,wMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_DisplayName_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailAutoDiscovery_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_InfoURL_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstrURL);


void __RPC_STUB IMailAutoDiscovery_get_InfoURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_PreferedProtocolType_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstrProtocolType);


void __RPC_STUB IMailAutoDiscovery_get_PreferedProtocolType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_length_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pnLength);


void __RPC_STUB IMailAutoDiscovery_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_item_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ VARIANT varIndex,
    /* [out][retval] */ IMailProtocolADEntry __RPC_FAR *__RPC_FAR *ppMailProtocol);


void __RPC_STUB IMailAutoDiscovery_get_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_get_XML_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLDoc);


void __RPC_STUB IMailAutoDiscovery_get_XML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_put_XML_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ IXMLDOMDocument __RPC_FAR *pXMLDoc);


void __RPC_STUB IMailAutoDiscovery_put_XML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_getPrimaryProviders_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders);


void __RPC_STUB IMailAutoDiscovery_getPrimaryProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_getSecondaryProviders_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [out][retval] */ IAutoDiscoveryProvider __RPC_FAR *__RPC_FAR *ppProviders);


void __RPC_STUB IMailAutoDiscovery_getSecondaryProviders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_DiscoverMail_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress);


void __RPC_STUB IMailAutoDiscovery_DiscoverMail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_PurgeCache_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This);


void __RPC_STUB IMailAutoDiscovery_PurgeCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IMailAutoDiscovery_WorkAsync_Proxy( 
    IMailAutoDiscovery __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsg);


void __RPC_STUB IMailAutoDiscovery_WorkAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailAutoDiscovery_INTERFACE_DEFINED__ */


#ifndef __IAccountDiscovery_INTERFACE_DEFINED__
#define __IAccountDiscovery_INTERFACE_DEFINED__

/* interface IAccountDiscovery */
/* [uuid][nonextensible][dual][oleautomation][object] */ 

typedef /* [unique] */ IAccountDiscovery __RPC_FAR *LPACCOUNTDISCOVERY;

// IAccountDiscovery::DiscoverNow() flags
#define ADDN_DEFAULT                     0x00000000
#define ADDN_CONFIGURE_EMAIL_FALLBACK    0x00000001  // We are attempting to configure an email account so contact public servers offering email settings.
                                                     // For Example, Microsoft may provide _AutoDiscovery.microsoft.com that can provide email configuration settings for common servers.
#define ADDN_SKIP_CACHEDRESULTS          0x00000002  // Download the settings, even if they are already cached.
#define ADDN_FILTER_EMAIL                0x00000100  // Some users may want the username part of the email address removed if we need to fall
                                                     // back to a public service to get the settings to protect their privacy.

EXTERN_C const IID IID_IAccountDiscovery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FA202BBC-6ABE-4c17-B184-570B6CF256A6")
    IAccountDiscovery : public IDispatch
    {
    public:
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE DiscoverNow( 
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BSTR bstrXMLRequest,
            /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLResponse) = 0;
        
        virtual /* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE WorkAsync( 
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAccountDiscoveryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAccountDiscovery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAccountDiscovery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscoverNow )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ BSTR bstrEmailAddress,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BSTR bstrXMLRequest,
            /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLResponse);
        
        /* [displaybind][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WorkAsync )( 
            IAccountDiscovery __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT wMsg);
        
        END_INTERFACE
    } IAccountDiscoveryVtbl;

    interface IAccountDiscovery
    {
        CONST_VTBL struct IAccountDiscoveryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAccountDiscovery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAccountDiscovery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAccountDiscovery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAccountDiscovery_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IAccountDiscovery_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IAccountDiscovery_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IAccountDiscovery_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IAccountDiscovery_DiscoverNow(This,bstrEmailAddress,dwFlags,bstrXMLRequest,ppXMLResponse)	\
    (This)->lpVtbl -> DiscoverNow(This,bstrEmailAddress,dwFlags,bstrXMLRequest,ppXMLResponse)

#define IAccountDiscovery_WorkAsync(This,hwnd,wMsg)	\
    (This)->lpVtbl -> WorkAsync(This,hwnd,wMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAccountDiscovery_DiscoverNow_Proxy( 
    IAccountDiscovery __RPC_FAR * This,
    /* [in] */ BSTR bstrEmailAddress,
    /* [in] */ DWORD dwFlags,
    /* [in] */ BSTR bstrXMLRequest,
    /* [out][retval] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppXMLResponse);


void __RPC_STUB IAccountDiscovery_DiscoverNow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [displaybind][helpstring][id] */ HRESULT STDMETHODCALLTYPE IAccountDiscovery_WorkAsync_Proxy( 
    IAccountDiscovery __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT wMsg);


void __RPC_STUB IAccountDiscovery_WorkAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAccountDiscovery_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_AccountDiscovery;

#ifdef __cplusplus

class DECLSPEC_UUID("3DAB30ED-8132-40bf-A8BA-7B5057F0CD10")
AccountDiscovery;
#endif

#ifndef __IMailProtocolADEntry_INTERFACE_DEFINED__
#define __IMailProtocolADEntry_INTERFACE_DEFINED__

/* interface IMailProtocolADEntry */
/* [uuid][nonextensible][dual][oleautomation][object] */ 

typedef /* [unique] */ IMailProtocolADEntry __RPC_FAR *LPMAILPROTOCOLADENTRY;


EXTERN_C const IID IID_IMailProtocolADEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40EF8C68-D554-47ed-AA37-E5FB6BC91075")
    IMailProtocolADEntry : public IDispatch
    {
    public:
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerPort( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LoginName( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PostHTML( 
            /* [out][retval] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UseSSL( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSSL) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsAuthRequired( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfIsAuthRequired) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UseSPA( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSPA) = 0;
        
        virtual /* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SMTPUsesPOP3Auth( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUsePOP3Auth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMailProtocolADEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMailProtocolADEntry __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMailProtocolADEntry __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Protocol )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerName )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerPort )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LoginName )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PostHTML )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *pbstr);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseSSL )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSSL);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsAuthRequired )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfIsAuthRequired);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UseSPA )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSPA);
        
        /* [bindable][displaybind][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SMTPUsesPOP3Auth )( 
            IMailProtocolADEntry __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUsePOP3Auth);
        
        END_INTERFACE
    } IMailProtocolADEntryVtbl;

    interface IMailProtocolADEntry
    {
        CONST_VTBL struct IMailProtocolADEntryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMailProtocolADEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMailProtocolADEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMailProtocolADEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMailProtocolADEntry_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMailProtocolADEntry_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMailProtocolADEntry_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMailProtocolADEntry_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMailProtocolADEntry_get_Protocol(This,pbstr)	\
    (This)->lpVtbl -> get_Protocol(This,pbstr)

#define IMailProtocolADEntry_get_ServerName(This,pbstr)	\
    (This)->lpVtbl -> get_ServerName(This,pbstr)

#define IMailProtocolADEntry_get_ServerPort(This,pbstr)	\
    (This)->lpVtbl -> get_ServerPort(This,pbstr)

#define IMailProtocolADEntry_get_LoginName(This,pbstr)	\
    (This)->lpVtbl -> get_LoginName(This,pbstr)

#define IMailProtocolADEntry_get_PostHTML(This,pbstr)	\
    (This)->lpVtbl -> get_PostHTML(This,pbstr)

#define IMailProtocolADEntry_get_UseSSL(This,pfUseSSL)	\
    (This)->lpVtbl -> get_UseSSL(This,pfUseSSL)

#define IMailProtocolADEntry_get_IsAuthRequired(This,pfIsAuthRequired)	\
    (This)->lpVtbl -> get_IsAuthRequired(This,pfIsAuthRequired)

#define IMailProtocolADEntry_get_UseSPA(This,pfUseSPA)	\
    (This)->lpVtbl -> get_UseSPA(This,pfUseSPA)

#define IMailProtocolADEntry_get_SMTPUsesPOP3Auth(This,pfUsePOP3Auth)	\
    (This)->lpVtbl -> get_SMTPUsesPOP3Auth(This,pfUsePOP3Auth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_Protocol_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailProtocolADEntry_get_Protocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_ServerName_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailProtocolADEntry_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_ServerPort_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailProtocolADEntry_get_ServerPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_LoginName_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailProtocolADEntry_get_LoginName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_PostHTML_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IMailProtocolADEntry_get_PostHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_UseSSL_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSSL);


void __RPC_STUB IMailProtocolADEntry_get_UseSSL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_IsAuthRequired_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfIsAuthRequired);


void __RPC_STUB IMailProtocolADEntry_get_IsAuthRequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_UseSPA_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUseSPA);


void __RPC_STUB IMailProtocolADEntry_get_UseSPA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [bindable][displaybind][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMailProtocolADEntry_get_SMTPUsesPOP3Auth_Proxy( 
    IMailProtocolADEntry __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pfUsePOP3Auth);


void __RPC_STUB IMailProtocolADEntry_get_SMTPUsesPOP3Auth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMailProtocolADEntry_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MailProtocolADEntry;

#ifdef __cplusplus

class DECLSPEC_UUID("61A5D6F3-C131-4c35-BF40-90A50F214122")
MailProtocolADEntry;
#endif

EXTERN_C const CLSID CLSID_MailAutoDiscovery;

#ifdef __cplusplus

class DECLSPEC_UUID("008FD5DD-6DBB-48e3-991B-2D3ED658516A")
MailAutoDiscovery;
#endif
#endif /* __AutoDiscovery_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_AutoDiscovery_0267 */
/* [local] */ 

#endif // (_WIN32_IE >= 0x0600)
#endif // _AUTODISCOVERY_IDL_H_


extern RPC_IF_HANDLE __MIDL_itf_AutoDiscovery_0267_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_AutoDiscovery_0267_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\authhlp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*--
Module Name: AUTHHLP
Abstract: NTLM Authentication for telnetd.
--*/

/****************************************************************************
 USAGE

 Call AuthHelpValidateUser(A/W), depending on whether the user name and 
 password are in ANSI or UNICODE strings.  The ACL is always in UNICODE
 in CE because it is typically read from the registry.  The function will
 return TRUE if access is allowed and FALSE if it is not allowed.

 Access may be denied if the user is not a valid user on the domain, or 
 if they are not in the Access Control List (ACL).  
 The ACL is a string, each element separeted by a semicolon, that specifies
 the name of a group or user to either allow or deny service to.  To specify
 a group, put a "@" immediatly before it.  To specify either a user or a group
 is to be denied access, put a "-" before it.  

 
 For instance, ACL = "good_user1; @good_group1; -bad_user1; -@bad_group1; good_user2"
 will allow users named good_user1, good_user2, and anyone who is a member of
 the group good_group1 access (assuming they've succesfully been authenticated
 by NTLM).  It will deny access to anyone named bad_user1 and in bad_group1.

 The checks are made from left to right, and the check will stop being made
 as soon as a match (either positive or negative) is made.

 In the above example, if good_user1 is also a member of bad_group1, they will
 receive access because good_user1 came before bad_group1.  However, if
 good_user2 is a member of bad_group1, they will be denied access because 
 bad_group1 came before good_user2.
 
 A "*" in the ACL list means that all users are granted access, provided they 
 have not been disqualified by any of the arguments to the left of the arg
 list.

 For instance, if ACL = "-bad_user1; *" then all users will be granted
 access, except for bad_user1.
 

 IMPORTANT SECURITY CONSIDERATIONS

 Note that there is some danger in using this API set over a public network
 such as the Internet if the passwords are not encrypted by the calling 
 application.  It is possible for a malicious user to intercept packets sent 
 to  your network application and to learn the password, either on the 
 Domain or on the CE device, depending on which options are used.  Use
 this with care.


 See the telnetd sample for an example of how to use this API.

****************************************************************************/


#ifndef _AUTH_H_
#define _AUTH_H_

#ifndef UNDER_CE
#define SECURITY_WIN32
#endif

#include <windows.h>
#include <sspi.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

BOOL AuthHelpValidateUserA(PSTR pszRemoteUser, PSTR pszPassword, TCHAR *pszACL, DWORD dwFlags);
BOOL AuthHelpValidateUserW(PWSTR wszRemoteUser, PWSTR wszPassword, TCHAR *pszACL, DWORD dwFlags);
BOOL AuthHelpValidateUser(TCHAR *pszRemoteUser, TCHAR *pszPassword, TCHAR * pszACL, DWORD dwFlags);
BOOL IsAccessAllowed(TCHAR *pszRemoteUser, TCHAR *pszRemoteUserGroups, TCHAR *pszACL, BOOL fPeek);

#if defined (UNICODE)
#define IsAccessAllowedEx  IsAccessAllowedExW
#else
#define IsAccessAllowedEx  IsAccessAllowedExA
#endif

BOOL IsAccessAllowedExA(const CHAR *pszRemoteUser, const CHAR *pszRemoteUserGroups, const CHAR *pszACL, DWORD dwFlags);
BOOL IsAccessAllowedExW(const WCHAR *pszRemoteUser, const WCHAR *pszRemoteUserGroups, const WCHAR *pszACL, DWORD dwFlags);

BOOL AuthHelpUnload();
BOOL AuthHelpInitialize(); //NOTE: this will always return TRUE, use AuthIsNTLM() 
			   // to discover if NTLM is being used 

BOOL AuthIsNTLM();

HKEY AuthHelpOpenUserKeyA(PSTR pszApp, PSTR pszRemoteUser);
HKEY AuthHelpOpenUserKeyW(PWSTR pszApp, PWSTR pszRemoteUser);

#if defined (UNICODE)
#define AuthHelpOpenUserKey  AuthHelpOpenUserKeyW
#else
#define AuthHelpOpenUserKey  AuthHelpOpenUserKeyA
#endif


// Set to skip NTLM checking during AuthHelpValidateUser().
#define AUTH_HELP_FLAGS_NO_NTLM             0x01

// In call to IsAccessAllowedEx(), setting this flag will cause function to
// succeed if a group has been set "@", assuming the user name passed in was not
// explicitly denied.  This is used to make sure that a user name was not 
// explicitly denied before beginning a potentially long running NTLM query.
#define AUTH_HELP_FLAGS_PRESCAN             0x02

// Set to ignore group "@" sign, treats it like another character.  This is 
// useful when using authhlp IsAccessAllowedEx() to see if a string is in 
// an allowed-list where the string may legally start with a @.
#define AUTH_HELP_FLAGS_IGNORE_GROUP        0x04


// If a user is not explicitly denied (i.e there is no '-' preceeding their name)
// then IsAccessAllowedEx will return TRUE.  This is the functional equivalent 
// of putting a '*' on the end of a list.
#define AUTH_HELP_FLAGS_CHECK_NOT_DENIED    0x08

// '*' is wildcard allowing everyone access
#define AUTH_HELP_C_ALLOW_ALL        '*'
#define AUTH_HELP_WC_ALLOW_ALL      L'*'

// '-' denies access to entry to the immediate right of it
#define AUTH_HELP_C_DENY             '-'
#define AUTH_HELP_WC_DENY           L'-'

// ';' is delimiter
#define AUTH_HELP_C_DELIMITER        ';'
#define AUTH_HELP_WC_DELIMITER      L';'

// '@' is group character
#define AUTH_HELP_C_GROUP            '@'
#define AUTH_HELP_WC_GROUP          L'@'


#ifdef __cplusplus
}
#endif

#endif // _AUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\audiortgapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _AUDIORTGAPI_H_
#define _AUDIORTGAPI_H_

#if (_MSC_VER >= 1000)
#pragma once
#endif

#include <mmsystem.h>

#ifdef __cplusplus
extern "C" {
#endif

// Indicates the Wave API direction.
typedef enum _WAPIDIR
{
    WAPIDIR_OUT = 0,
    WAPIDIR_IN,
    WAPIDIR_MAX
} WAPIDIR;

//
// GetMappedDeviceId returns the mapped physical audio device ID from
// WAVE_MAPPER or a device ID specifier created from WAVE_MAKE_DEVICEID.  The
// mapped device ID is valid at the moment GetMappedDeviceId is called and may
// change at any time.  The caller should not cache this value.  To receive
// notifications when the mapped device ID changes, register for the
// AUDIOEVT_WAVEOUT_DEVICEID_CHANGE or AUDIOEVT_WAVEIN_DEVICEID_CHANGE
// notification types using RequestAudioNotifications.
//

HRESULT
GetMappedDeviceId(
    WAPIDIR wapidir,                // Wave API direction.
    UINT uDeviceId,                 // Device ID specifier to map.
    __out PUINT puDeviceIdMapped    // Pointer to the buffer to receive the mapped device ID.
    );

//
// Stream class gain functions.  The gain value applies to all audio devices.
//

HRESULT
GetStreamClassGain(
    WAPIDIR wapidir,                // Wave API direction.
    DWORD dwStreamClassId,          // Stream class ID.
    __out PDWORD pdwStreamClassGain // Pointer to the buffer to receive the class gain.
    );

HRESULT
SetStreamClassGain(
    WAPIDIR wapidir,                // Wave API direction.
    DWORD dwStreamClassId,          // Stream class ID.
    DWORD dwStreamClassGain         // Stream class gain to set.
    );

#define STREAMCLASS_CLASSGAIN_MAX   0xFFFF

//
// Returns the number of currently opened audio streams of a stream class.
//

HRESULT
GetNumOpenedStreams(
    WAPIDIR wapidir,                // Wave API direction.
    DWORD dwStreamClassId,          // Stream class ID of the opened streams.
    __out PDWORD pcOpenedStreams    // Pointer to the buffer to receive the opened stream count.
    );

//
// Returns the number of currently active audio streams of a stream class.
// Active streams are streams in running state (not paused or stopped).
//

HRESULT
GetNumActiveStreams(
    WAPIDIR wapidir,                // Wave API direction.
    DWORD dwStreamClassId,          // Stream class ID of the active streams.
    __out PDWORD pcActiveStreams    // Pointer to the buffer to receive the active stream count.
    );

//
// Audio notifications.
//

DECLARE_HANDLE(HAUDIONOTIFICATION);

// Requests audio notificat