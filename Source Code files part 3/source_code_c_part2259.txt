 \
        DEBUGCHK(exp); \
    }

#define PREFAST_ASSERT(exp) \
    { \
        PREFAST_ASSUME(exp); \
        ASSERT(exp); \
    }

// macro to tell Prefast to not issue a specific warning for the following line of code
// use to suppress false positives from Prefast
// e.g.
// if( fPointerNotNull )
//    PREFAST_SUPPRESS( 11, "pointer access is guarded by 'fPointerNotNull'" )
//    p->Foo();
#ifdef _PREFAST_
#define PREFAST_SUPPRESS( cWarning, comment) __pragma ( prefast(suppress: cWarning, comment) )
#else
#define PREFAST_SUPPRESS( cWarning, comment)
#endif

// Helpful DBG macros that tighten up code.
// They prepend __FUNCTION__ to your debug msg and add a \n to the end.

#define DEB_0(ZONE,STR) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__))
#define DEB_1(ZONE,STR,ARG1) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__,ARG1))
#define DEB_2(ZONE,STR,ARG1,ARG2) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__,ARG1,ARG2))
#define DEB_3(ZONE,STR,ARG1,ARG2,ARG3) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__,ARG1,ARG2,ARG3))
#define DEB_4(ZONE,STR,ARG1,ARG2,ARG3,ARG4) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__,ARG1,ARG2,ARG3,ARG4))
#define DEB_5(ZONE,STR,ARG1,ARG2,ARG3,ARG4,ARG5) DEBUGMSG(ZONE,(L"%S:"STR L"\n",__FUNCTION__,ARG1,ARG2,ARG3,ARG4,ARG5))

// 
//  The _A version of the above are identical, except they call assert  after the  DEB_*.  
//  It's highly recommend that you use DEB_*_A with ZONE_ERROR so the user can always see the error.
//  printed with the assert.
//  NOTE: The assert is not conditioned on the ZONE. 

#define DEB_0_A(ZONE,STR) { DEB_0(ZONE,STR);ASSERT(FALSE); }
#define DEB_1_A(ZONE,STR,ARG1) { DEB_1(ZONE,STR,ARG1); ASSERT(FALSE);}
#define DEB_2_A(ZONE,STR,ARG1,ARG2) { DEB_2(ZONE,STR,ARG1,ARG2); ASSERT(FALSE);}
#define DEB_3_A(ZONE,STR,ARG1,ARG2,ARG3) { DEB_3(ZONE,STR,ARG1,ARG2,ARG3); ASSERT(FALSE);}
#define DEB_4_A(ZONE,STR,ARG1,ARG2,ARG3,ARG4) {  DEB_4(ZONE,STR,ARG1,ARG2,ARG3,ARG4); ASSERT(FALSE);}
#define DEB_5_A(ZONE,STR,ARG1,ARG2,ARG3,ARG4,ARG5) {DEB_5(ZONE,STR,ARG1,ARG2,ARG3,ARG4,ARG5); ASSERT(FALSE);}


#ifdef __cplusplus
}
#endif
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\datamodel.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for datamodel.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __datamodel_h__
#define __datamodel_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "vrtldata.h"
#include "searchobj.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __DataModel_LIBRARY_DEFINED__
#define __DataModel_LIBRARY_DEFINED__

/* library DataModel */
/* [version][helpstring][uuid] */ 














EXTERN_C const IID LIBID_DataModel;
#endif /* __DataModel_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\datamodelschema.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

///<file_doc_scope tref="datacatreg" visibility="sdk"/>

#ifdef __cplusplus
extern "C" {
#endif

///<topic name="datacatspecial" displayname="Special Data Category Names">
///<summary>
///  Data categories that are not explicitly registered and/or provide special
///  meanings or behavior.
///</summary>
///</topic>
///<topic_scope tref="datacatspecial">

///<topic name="datacatobject" displayname="object">
///<summary>
///  <para>
///    CATEGORYNAME_OBJECT
///  </para>
///  <para>
///    Supercategory of all other categories.
///    It can't be redefined or modified.
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_OBJECT TEXT("object")


// Minimum ID value used for global verbs
#define VERBID_RESERVEDMIN      0xFFFFFF00

// Verb used for opening the verb target object (e.g., a virtual item)
#define VERBID_OPEN             (VERBID_RESERVEDMIN + 0x00)

// Maximum ID value used for global verbs
#define VERBID_RESERVEDMAX      (VERBID_OPEN)

///<topic name="datacatempty" displayname="empty">
///<summary>
///  <para>
///    CATEGORYNAME_EMPTY
///  </para>
///  <para>
///    Represents the absence of a category and as such it does not have
///    "object" as a supercategory.
///    It can't be redefined or modified.
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_EMPTY TEXT("empty")

///</topic_scope> datacatspecial

///<topic name="datacatpredefined" displayname="Predefined Data Category Names">
///<summary>
///  Data categories that are natively supported by the system.
///</summary>
///</topic>
///<topic_scope tref="datacatpredefined">

#define DATAMODEL_SCHEMA_SPECIALSORT_BASE       0x0101
#define DATAMODEL_SCHEMA_SPECIALSORT(ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(DATAMODEL_SCHEMA_SPECIALSORT_BASE)))

#define DATAMODEL_SCHEMA_RESTRICTION_BASE       0x0102
#define DATAMODEL_SCHEMA_RESTRICTION(ulPropID)  ((((ULONG)(ulPropID))<<16)|((ULONG)(DATAMODEL_SCHEMA_RESTRICTION_BASE)))

///<topic name="datacatphone" displayname="phonenumber">
///<summary>
///  <para>
///    CATEGORYNAME_PHONENUMBER
///  </para>
///  <para>
///    Encompasses text strings that represent a phone number or dial string
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_PHONENUMBER TEXT("phonenumber")

///<topic name="datacataddress" displayname="streetaddress">
///<summary>
///  <para>
///    CATEGORYNAME_STREETADDRESS
///  </para>
///  <para>
///    Encompasses text strings that represent a street address
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_STREETADDRESS TEXT("streetaddress")

///<topic name="datacatemail" displayname="emailaddress">
///<summary>
///  <para>
///    CATEGORYNAME_EMAILADDRESS
///  </para>
///  <para>
///    Encompasses text strings that represent an email address
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_EMAILADDRESS TEXT("emailaddress")

///<topic name="datacaturl" displayname="url">
///<summary>
///  <para>
///    CATEGORYNAME_URI, CATEGORYNAME_URL
///  </para>
///  <para>
///    Encompasses text strings that represent an HTTP 
///    Uniform Resource Identifier/Locator (URI/URL)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_URI TEXT("uri")
#define CATEGORYNAME_URL CATEGORYNAME_URI

///<topic name="datacatmessage" displayname="message">
///<summary>
///  <para>
///    CATEGORYNAME_MESSAGE
///  </para>
///  <para>
///    Represents a kind of message (e.g., email, SMS, etc.)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_MESSAGE TEXT("message")

// Property has VT_LPWSTR type
#define PROPID_MESSAGE_SENDER           0x0001
// Property has (VT_VECTOR|VT_LPWSTR) type
#define PROPID_MESSAGE_RECIPIENTS       0x0002
// Property has VT_FILETIME type
#define PROPID_MESSAGE_TIME             0x0003
// Property has VT_BOOL type
#define PROPID_MESSAGE_HASATTACHMENT    0x0004
// Property has VT_I4 type
#define PROPID_MESSAGE_PRIORITY         0x0005
// Property has VT_I4 type
#define PROPID_MESSAGE_FLAG             0x0006
// Property had VT_I4 type
#define PROPID_MESSAGE_READ             0x0007
// Property has VT_LPWSTR type
#define PROPID_MESSAGE_INDEX            0x0008
// Property has VT_LPWSTR type
#define PROPID_MESSAGE_SENDEREMAIL      0x0009
// Property has VT_LPWSTR type
#define PROPID_MESSAGE_SUBJECT          0x000a

#define PROPID_MESSAGE_LASTID           0x0200

// Sort orders
#define ORDER_MESSAGE_SENDER            PROPID_MESSAGE_SENDER
#define ORDER_MESSAGE_TIME              PROPID_MESSAGE_TIME

// Restrictions

// Restriction has VT_BLOB type, representing a MAPI ENTRYID
#define RESTRICT_MESSAGE_FOLDER         DATAMODEL_SCHEMA_RESTRICTION(0x0001)
// Restriction has either VT_BLOB type, representing a MAPI ENTRYID,
// or a VT_LPWSTR representing the store name.
#define RESTRICT_MESSAGE_STORE          DATAMODEL_SCHEMA_RESTRICTION(0x0002)

///<topic name="datacatemailmessage" displayname="emailmessage">
///<summary>
///  <para>
///    CATEGORYNAME_EMAILMESSAGE
///  </para>
///  <para>
///    Represents an email message, which is a subcategory of message
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_EMAILMESSAGE TEXT("EmailMessage")

// Property has VT_LPWSTR type
#define PROPID_EMAILMESSAGE_SUBJECT           (PROPID_MESSAGE_LASTID + 0x0001)

// Sort orders
#define ORDER_EMAILMESSAGE_SUBJECT          PROPID_EMAILMESSAGE_SUBJECT   


///<topic name="datacatsmsmessage" displayname="smsmessage">
///<summary>
///  <para>
///    CATEGORYNAME_SMSMESSAGE
///  </para>
///  <para>
///    Represents an SMS message, which is a subcategory of message
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_SMSMESSAGE TEXT("SMSMessage")

// Property has VT_LPWSTR type
#define PROPID_SMSMESSAGE_BODY          (PROPID_MESSAGE_LASTID + 0x0001)


///<topic name="datacatdialable" displayname="dialable">
///<summary>
///  <para>
///    CATEGORYNAME_DIALABLE
///  </para>
///  <para>
///    Represents an item that can be dialed (e.g., contact, call history entry)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_DIALABLE TEXT("dialable")


///<topic name="datacatcallhistory" displayname="callhistory">
///<summary>
///  <para>
///    CATEGORYNAME_CALLHISTORY
///  </para>
///  <para>
///    Represents a call history entry
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_CALLHISTORY TEXT("CallHistory")
#define CATEGORYNAME_CALLHISTORY_UNIQUE TEXT("CallHistoryUnique")


// Property has VT_LPWSTR type
#define PROPID_CALL_OTHERPARTY          0x0001
// Property has VT_FILETIME type
#define PROPID_CALL_TIME                0x0002

// Sort orders
#define ORDER_CALL_OTHERPARTY           PROPID_CALL_OTHERPARTY
#define ORDER_CALL_TIME                 PROPID_CALL_TIME


///<topic name="datacatspeeddial" displayname="speeddial">
///<summary>
///  <para>
///    CATEGORYNAME_SPEEDDIAL
///  </para>
///  <para>
///    Represents a speed dial entry
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_SPEEDDIAL  TEXT("SpeedDialEntry")

// Property has VT_I4 type
#define PROPID_SPEEDDIAL_KEYCUT         0x0001


///<topic name="datacatcontact" displayname="contact">
///<summary>
///  <para>
///    CATEGORYNAME_CONTACT
///  </para>
///  <para>
///    Represents a person/contact card
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_CONTACT TEXT("contact")

// Property has VT_LPWSTR type
#define PROPID_CONTACT_TITLE            0x0001
// Property has VT_LPWSTR type
#define PROPID_CONTACT_FIRSTNAME        0x0002
// Property has VT_LPWSTR type
#define PROPID_CONTACT_MIDDLENAME       0x0003
// Property has VT_LPWSTR type
#define PROPID_CONTACT_LASTNAME         0x0004 
// Property has VT_LPWSTR type
#define PROPID_CONTACT_SUFFIX           0x0005
// Property has VT_LPWSTR type
#define PROPID_CONTACT_FILEAS           0x0006
// Property has VT_LPWSTR type
#define PROPID_CONTACT_COMPANY          0x0007
// Property has VT_LPWSTR type
#define PROPID_CONTACT_JOBTITLE         0x0008
// Property has VT_LPWSTR type
#define PROPID_CONTACT_EMAIL            0x0009
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSINESSPHONE    0x000a
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEPHONE        0x000b
// Property has VT_LPWSTR type
#define PROPID_CONTACT_MOBILEPHONE      0x000c
// Property has VT_LPWSTR type
#define PROPID_CONTACT_FAX              0x000d
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSADDSTREET     0x000e
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSADDCITY       0x000f
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSADDSTATE      0x0010
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSADDPOSTAL     0x0011
// Property has VT_LPWSTR type
#define PROPID_CONTACT_BUSADDCOUNTRY    0x0012
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEADDSTREET    0x0013
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEADDCITY      0x0014
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEADDSTATE     0x0015
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEADDPOSTAL    0x0016
// Property has VT_LPWSTR type
#define PROPID_CONTACT_HOMEADDCOUNTRY   0x0017
// Property has VT_LPWSTR type
#define PROPID_CONTACT_CATEGORIES       0x0018


// Sort orders
#define ORDER_CONTACT_FILEAS           PROPID_CONTACT_FILEAS

///<topic name="datacatappointment" displayname="appointment">
///<summary>
///  <para>
///    CATEGORYNAME_APPOINTMENT
///  </para>
///  <para>
///    Represents a calendar entry/appointment
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_APPOINTMENT TEXT("appointment")

// Property has VT_LPWSTR type
#define PROPID_CALENDAR_SUBJECT         0x0001
// Property has VT_FILETIME type
#define PROPID_CALENDAR_BEGIN           0x0002
// Property has VT_FILETIME type
#define PROPID_CALENDAR_END             0x0003
// Property has VT_LPWSTR type
#define PROPID_CALENDAR_LOCATION        0x0004
// Property has VT_LPWSTR type
#define PROPID_CALENDAR_ORGANIZER       0x0005
// Property has (VT_VECTOR|VT_LPWSTR) type
#define PROPID_CALENDAR_ATTENDEES       0x0006
// Property has VT_BOOL type
#define PROPID_CALENDAR_ALLDAY          0x0007
// Property has VT_LPWSTR type
#define PROPID_CALENDAR_FRIENDLYDATE    0x0008
// Property has VT_UI4 type
#define PROPID_CALENDAR_VLVSTATE        0x0009
// Property has VT_LPWSTR type
#define PROPID_CALENDAR_DATETIME        0x000A
// Property has VT_UI4 type
#define PROPID_CALENDAR_BUSYSTATUS      0x000B


// Sort orders
#define ORDER_CALENDAR_SUBJECT      PROPID_CALENDAR_SUBJECT
#define ORDER_CALENDAR_BEGIN        PROPID_CALENDAR_BEGIN
#define ORDER_CALENDAR_BEGIN_END    DATAMODEL_SCHEMA_SPECIALSORT(0x01)


///<topic name="datacattask" displayname="task">
///<summary>
///  <para>
///    CATEGORYNAME_TASK
///  </para>
///  <para>
///    Represents a task in a TODO list
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_TASK TEXT("task")


// Property has VT_LPWSTR type
#define PROPID_TASK_SUBJECT         0x0001
// Property has VT_FILETIME type
#define PROPID_TASK_DUE             0x0002
// Property has VT_UI4 type
#define PROPID_TASK_PRIORITY        0x0003
// Property has VT_BOOL type
#define PROPID_TASK_COMPLETE        0x0004
// Property has VT_LPWSTR type
#define PROPID_TASK_CATEGORIES      0x0005

// Sort orders
#define ORDER_TASK_SUBJECT          PROPID_TASK_SUBJECT
#define ORDER_TASK_DUE              PROPID_TASK_DUE
#define ORDER_TASK_PRIORITY         PROPID_TASK_PRIORITY
#define ORDER_TASK_COMPLETE         PROPID_TASK_COMPLETE
#define ORDER_TASK_COMPLETE_SUBJECT DATAMODEL_SCHEMA_SPECIALSORT(0x01)



///<topic name="datacatmedia" displayname="media">
///<summary>
///  <para>
///    CATEGORYNAME_MEDIA
///  </para>
///  <para>
///    Represents a item that pertains to media (e.g.: songs, pictures, videos,
///    artists, genres, etc.)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_MEDIA TEXT("media")

#define PROPID_MEDIA_LASTID         0x0200

///<topic name="datacatmusic" displayname="music">
///<summary>
///  <para>
///    CATEGORYNAME_MUSIC
///  </para>
///  <para>
///    Represents a music item (i.e., a song)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_MUSIC TEXT("music")

// Property has VT_LPWSTR type
#define PROPID_MUSIC_NAME       (PROPID_MEDIA_LASTID + 0x0001)
// Property has VT_LPWSTR type
#define PROPID_MUSIC_ARTIST     (PROPID_MEDIA_LASTID + 0x0002)
// Property has VT_LPWSTR type
#define PROPID_MUSIC_ALBUM      (PROPID_MEDIA_LASTID + 0x0003)
// Property has VT_LPWSTR type
#define PROPID_MUSIC_GENRE      (PROPID_MEDIA_LASTID + 0x0004)
// Property has VT_UI4 type. Amount represents time, in seconds.
#define PROPID_MUSIC_LENGTH     (PROPID_MEDIA_LASTID + 0x0005)

// Sort orders
#define ORDER_MUSIC_NAME        PROPID_MUSIC_NAME
#define ORDER_MUSIC_ARTIST      PROPID_MUSIC_ARTIST
#define ORDER_MUSIC_ALBUM       PROPID_MUSIC_ALBUM
#define ORDER_MUSIC_GENRE       PROPID_MUSIC_GENRE


///<topic name="datacatphoto" displayname="photo">
///<summary>
///  <para>
///    CATEGORYNAME_PHOTO
///  </para>
///  <para>
///    Represents a photograph
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_PHOTO TEXT("photo")

// Property has VT_LPWSTR type
#define PROPID_PHOTO_NAME       (PROPID_MEDIA_LASTID + 0x0001)
// Property has VT_FILETIME type
#define PROPID_PHOTO_DATETAKEN  (PROPID_MEDIA_LASTID + 0x0002)

// Sort orders
#define ORDER_PHOTO_NAME        PROPID_PHOTO_NAME
#define ORDER_PHOTO_DATETAKEN   PROPID_PHOTO_DATETAKEN


///<topic name="datacatvideo" displayname="video">
///<summary>
///  <para>
///    CATEGORYNAME_VIDEO
///  </para>
///  <para>
///    Represents a video
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_VIDEO TEXT("video")

// Property has VT_LPWSTR type
#define PROPID_VIDEO_NAME       (PROPID_MEDIA_LASTID + 0x0001)
// Property has VT_FILETIME type
#define PROPID_VIDEO_DATETAKEN  (PROPID_MEDIA_LASTID + 0x0002)
// Property has VT_LPWSTR type
#define PROPID_VIDEO_SERIES     (PROPID_MEDIA_LASTID + 0x0002)

// Sort orders
#define ORDER_VIDEO_NAME        PROPID_VIDEO_NAME
#define ORDER_VIDEO_DATETAKEN   PROPID_VIDEO_DATETAKEN


///<topic name="datacatlocation" displayname="location">
///<summary>
///  <para>
///    CATEGORYNAME_LOCATION
///  </para>
///  <para>
///    Represents a location (coordinates and/or address)
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_LOCATION TEXT("location")

// Property has VT_R8 type
#define PROPID_LOCATION_LAT     0x0001
// Property has VT_R8 type
#define PROPID_LOCATION_LON     0x0002
// Property has VT_LPWSTR type
#define PROPID_LOCATION_ADDRESS 0x0003

///<topic name="datacathelp" displayname="help">
///<summary>
///  <para>
///    CATEGORYNAME_HELP
///  </para>
///  <para>
///    Represents a help document
///  </para>
///</summary>
///</topic>
#define CATEGORYNAME_HELP TEXT("help")

// Property has VT_LPWSTR type
#define PROPID_HELP_TITLE       0x0001
// Property has VT_LPWSTR type
#define PROPID_HELP_CATEGORY    0x0002
// Property has VT_LPWSTR type
#define PROPID_HELP_TEXT        0x0003

#define ORDER_HELP_TITLE        PROPID_HELP_TITLE
#define ORDER_HELP_CATEGORY     PROPID_HELP_CATEGORY



///</topic_scope> datacatpredefined

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dbgprop.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:51 2007
 */
/* Compiler settings for ..\dbgprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dbgprop_0000 */
/* [local] */ 






typedef 
enum tagOBJECT_ATTRIB_FLAG
    {	OBJECT_ATTRIB_NO_ATTRIB	= 0,
	OBJECT_ATTRIB_NO_NAME	= 0x1,
	OBJECT_ATTRIB_NO_TYPE	= 0x2,
	OBJECT_ATTRIB_NO_VALUE	= 0x4,
	OBJECT_ATTRIB_VALUE_IS_INVALID	= 0x8,
	OBJECT_ATTRIB_VALUE_IS_OBJECT	= 0x10,
	OBJECT_ATTRIB_VALUE_IS_ENUM	= 0x20,
	OBJECT_ATTRIB_VALUE_IS_CUSTOM	= 0x40,
	OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE	= 0x70,
	OBJECT_ATTRIB_VALUE_HAS_CODE	= 0x80,
	OBJECT_ATTRIB_TYPE_IS_OBJECT	= 0x100,
	OBJECT_ATTRIB_TYPE_HAS_CODE	= 0x200,
	OBJECT_ATTRIB_TYPE_IS_EXPANDABLE	= 0x100,
	OBJECT_ATTRIB_SLOT_IS_CATEGORY	= 0x400,
	OBJECT_ATTRIB_VALUE_READONLY	= 0x800,
	OBJECT_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	OBJECT_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	OBJECT_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	OBJECT_ATTRIB_ACCESS_FINAL	= 0x8000,
	OBJECT_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	OBJECT_ATTRIB_STORAGE_STATIC	= 0x20000,
	OBJECT_ATTRIB_STORAGE_FIELD	= 0x40000,
	OBJECT_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	OBJECT_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	OBJECT_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000,
	OBJECT_ATTRIB_IS_CLASS	= 0x1000000,
	OBJECT_ATTRIB_IS_FUNCTION	= 0x2000000,
	OBJECT_ATTRIB_IS_VARIABLE	= 0x4000000,
	OBJECT_ATTRIB_IS_PROPERTY	= 0x8000000,
	OBJECT_ATTRIB_IS_MACRO	= 0x10000000,
	OBJECT_ATTRIB_IS_TYPE	= 0x20000000,
	OBJECT_ATTRIB_IS_INHERITED	= 0x40000000,
	OBJECT_ATTRIB_IS_INTERFACE	= 0x80000000
    }	OBJECT_ATTRIB_FLAGS;

typedef 
enum tagPROP_INFO_FLAGS
    {	PROP_INFO_NAME	= 0x1,
	PROP_INFO_TYPE	= 0x2,
	PROP_INFO_VALUE	= 0x4,
	PROP_INFO_FULLNAME	= 0x20,
	PROP_INFO_ATTRIBUTES	= 0x8,
	PROP_INFO_DEBUGPROP	= 0x10,
	PROP_INFO_AUTOEXPAND	= 0x8000000
    }	PROP_INFO_FLAGS;

#define	PROP_INFO_STANDARD	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_ATTRIBUTES )

#define	PROP_INFO_ALL	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_FULLNAME | PROP_INFO_ATTRIBUTES | PROP_INFO_DEBUGPROP )

typedef struct tagDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    }	DebugPropertyInfo;

typedef 
enum tagEX_PROP_INFO_FLAGS
    {	EX_PROP_INFO_ID	= 0x100,
	EX_PROP_INFO_NTYPE	= 0x200,
	EX_PROP_INFO_NVALUE	= 0x400,
	EX_PROP_INFO_LOCKBYTES	= 0x800,
	EX_PROP_INFO_DEBUGEXTPROP	= 0x1000
    }	EX_PROP_INFO_FLAGS;

typedef struct tagExtendedDebugPropertyInfo
    {
    DWORD dwValidFields;
    LPOLESTR pszName;
    LPOLESTR pszType;
    LPOLESTR pszValue;
    LPOLESTR pszFullName;
    DWORD dwAttrib;
    IDebugProperty __RPC_FAR *pDebugProp;
    DWORD nDISPID;
    DWORD nType;
    VARIANT varValue;
    ILockBytes __RPC_FAR *plbValue;
    IDebugExtendedProperty __RPC_FAR *pDebugExtProp;
    }	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/* interface IDebugProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_RemoteGetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IDebugProperty_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetExtendedInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ ULONG cInfos,
    /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
    /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);


void __RPC_STUB IDebugProperty_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_SetValueAsString_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ UINT nRadix);


void __RPC_STUB IDebugProperty_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_EnumMembers_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [in] */ REFIID refiid,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IDebugProperty_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetParent_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugProperty_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/* interface IEnumDebugPropertyInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched)

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    (This)->lpVtbl -> Clone(This,ppepi)

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][unique][out][in] */ DebugPropertyInfo __RPC_FAR *pinfo,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Skip_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Reset_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Clone_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IEnumDebugPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_GetCount_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/* interface IDebugExtendedProperty */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtendedMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExtendedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExtendedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_GetExtendedPropertyInfo_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);


void __RPC_STUB IDebugExtendedProperty_GetExtendedPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_EnumExtendedMembers_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);


void __RPC_STUB IDebugExtendedProperty_EnumExtendedMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/* interface IEnumDebugExtendedPropertyInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched)

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    (This)->lpVtbl -> Clone(This,pedpe)

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Next_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Skip_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Reset_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Clone_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_GetCount_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/* interface IPerPropertyBrowsing2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayString )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPropertyToPage )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPredefinedValue )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerPropertyBrowsing2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerPropertyBrowsing2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr)

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage)

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetDisplayString_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pBstr);


void __RPC_STUB IPerPropertyBrowsing2_GetDisplayString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_MapPropertyToPage_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CLSID __RPC_FAR *pClsidPropPage);


void __RPC_STUB IPerPropertyBrowsing2_MapPropertyToPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetPredefinedStrings_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
    /* [out] */ CADWORD __RPC_FAR *pCaCookies);


void __RPC_STUB IPerPropertyBrowsing2_GetPredefinedStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_SetPredefinedValue_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IPerPropertyBrowsing2_SetPredefinedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_All */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_All_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_All_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_All_GetName(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0015)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyEnumType_All_GetName_Proxy( 
    IDebugPropertyEnumType_All __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *__MIDL_0015);


void __RPC_STUB IDebugPropertyEnumType_All_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Locals */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Locals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0015)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Arguments */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0015)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_LocalsPlusArgs */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0015)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/* interface IDebugPropertyEnumType_Registers */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0015);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Registers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL_0015)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0015)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Stub( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


/* [call_as] */ HRESULT __stdcall IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][unique][out][in] */ DebugPropertyInfo __RPC_FAR *pinfo,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dbt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
*                                                                           *
****************************************************************************/

/*****************************************************************************
 *
 *  Title:      DBT.H - Equates for WM_DEVICECHANGE and BroadcastSystemMessage
 *
 *  Version:    4.00
 *
 *****************************************************************************/

#ifndef _DBT_H
#define _DBT_H

/*
 * BroadcastSpecialMessage constants.
 */
#define WM_DEVICECHANGE         0x0219

/* XLATOFF */
#ifdef  IS_32
#define DBTFAR
#else
#define DBTFAR  far
#endif
/* XLATON */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef GUID_DEFINED
    #define GUID_DEFINED
    typedef struct _GUID {
        ULONG   Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];
    } GUID;
#endif // !defined(GUID_DEFINED)

/*
 * Broadcast message and receipient flags.
 *
 * Note that there is a third "flag". If the wParam has:
 *
 * bit 15 on:   lparam is a pointer and bit 14 is meaningfull.
 * bit 15 off:  lparam is just a UNLONG data type.
 *
 * bit 14 on:   lparam is a pointer to an ASCIIZ string.
 * bit 14 off:  lparam is a pointer to a binary struture starting with
 *              a dword describing the length of the structure.
 */
#define BSF_QUERY               0x00000001
#define BSF_IGNORECURRENTTASK   0x00000002      /* Meaningless for VxDs */
#define BSF_FLUSHDISK           0x00000004      /* Shouldn't be used by VxDs */
#define BSF_NOHANG              0x00000008
#define BSF_POSTMESSAGE         0x00000010
#define BSF_FORCEIFHUNG         0x00000020
#define BSF_NOTIMEOUTIFNOTHUNG  0x00000040
#define BSF_MSGSRV32ISOK        0x80000000      /* Called synchronously from PM API */
#define BSF_MSGSRV32ISOK_BIT    31              /* Called synchronously from PM API */

#define BSM_ALLCOMPONENTS       0x00000000
#define BSM_VXDS                0x00000001
#define BSM_NETDRIVER           0x00000002
#define BSM_INSTALLABLEDRIVERS  0x00000004
#define BSM_APPLICATIONS        0x00000008

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYBEGIN
 * lParam  = (not used)
 *
 *      'Appy-time is now available.  This message is itself sent
 *      at 'Appy-time.
 *
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_APPYEND
 * lParam  = (not used)
 *
 *      'Appy-time is no longer available.  This message is *NOT* sent
 *      at 'Appy-time.  (It cannot be, because 'Appy-time is gone.)
 *
 * NOTE!  It is possible for DBT_APPYBEGIN and DBT_APPYEND to be sent
 * multiple times during a single Windows session.  Each appearance of
 * 'Appy-time is bracketed by these two messages, but 'Appy-time may
 * momentarily become unavailable during otherwise normal Windows
 * processing.  The current status of 'Appy-time availability can always
 * be obtained from a call to _SHELL_QueryAppyTimeAvailable.
 */
#define DBT_APPYBEGIN                   0x0000
#define DBT_APPYEND                     0x0001

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_DEVNODES_CHANGED
 * lParam  = 0
 *
 *      send when configmg finished a process tree batch. Some devnodes
 *      may have been added or removed. This is used by ring3 people which
 *      need to be refreshed whenever any devnode changed occur (like
 *      device manager). People specific to certain devices should use
 *      DBT_DEVICE* instead.
 */

#define DBT_DEVNODES_CHANGED            0x0007

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_QUERYCHANGECONFIG
 * lParam  = 0
 *
 *      sent to ask if a config change is allowed
 */

#define DBT_QUERYCHANGECONFIG           0x0017

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGED
 * lParam  = 0
 *
 *      sent when a config has changed
 */

#define DBT_CONFIGCHANGED               0x0018

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGCHANGECANCELED
 * lParam  = 0
 *
 *      someone cancelled the config change
 */

#define DBT_CONFIGCHANGECANCELED        0x0019

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_MONITORCHANGE
 * lParam  = new resolution to use (LOWORD=x, HIWORD=y)
 *           if 0, use the default res for current config
 *
 *      this message is sent when the display monitor has changed
 *      and the system should change the display mode to match it.
 */

#define DBT_MONITORCHANGE               0x001B

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_SHELLLOGGEDON
 * lParam  = 0
 *
 *      The shell has finished login on: VxD can now do Shell_EXEC.
 */

#define DBT_SHELLLOGGEDON               0x0020

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_CONFIGMGAPI
 * lParam  = CONFIGMG API Packet
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_CONFIGMGAPI32               0x0022

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VXDINITCOMPLETE
 * lParam  = 0
 *
 *      CONFIGMG ring 3 call.
 */
#define DBT_VXDINITCOMPLETE             0x0023

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_VOLLOCK*
 * lParam  = pointer to VolLockBroadcast structure described below
 *
 *      Messages issued by IFSMGR for volume locking purposes on WM_DEVICECHANGE.
 *      All these messages pass a pointer to a struct which has no pointers.
 */

#define DBT_VOLLOCKQUERYLOCK    0x8041
#define DBT_VOLLOCKLOCKTAKEN    0x8042
#define DBT_VOLLOCKLOCKFAILED   0x8043
#define DBT_VOLLOCKQUERYUNLOCK  0x8044
#define DBT_VOLLOCKLOCKRELEASED 0x8045
#define DBT_VOLLOCKUNLOCKFAILED 0x8046

/*
 * Device broadcast header
 */

struct _DEV_BROADCAST_HDR {     /* */
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
};

typedef struct  _DEV_BROADCAST_HDR      DEV_BROADCAST_HDR;
typedef         DEV_BROADCAST_HDR       DBTFAR *PDEV_BROADCAST_HDR;

/*
 * Structure for volume lock broadcast
 */

typedef struct VolLockBroadcast VolLockBroadcast;
typedef VolLockBroadcast *pVolLockBroadcast;
struct VolLockBroadcast {
        struct  _DEV_BROADCAST_HDR vlb_dbh;
        DWORD   vlb_owner;              // thread on which lock request is being issued
        BYTE    vlb_perms;              // lock permission flags defined below
        BYTE    vlb_lockType;           // type of lock
        BYTE    vlb_drive;              // drive on which lock is issued
        BYTE    vlb_flags;              // miscellaneous flags
};

/*
 * Values for vlb_perms
 */
#define LOCKP_ALLOW_WRITES              0x01    // Bit 0 set - allow writes
#define LOCKP_FAIL_WRITES               0x00    // Bit 0 clear - fail writes
#define LOCKP_FAIL_MEM_MAPPING          0x02    // Bit 1 set - fail memory mappings
#define LOCKP_ALLOW_MEM_MAPPING         0x00    // Bit 1 clear - allow memory mappings
#define LOCKP_USER_MASK                 0x03    // Mask for user lock flags
#define LOCKP_LOCK_FOR_FORMAT           0x04    // Level 0 lock for format

/*
 * Values for vlb_flags
 */
#define LOCKF_LOGICAL_LOCK              0x00    // Bit 0 clear - logical lock
#define LOCKF_PHYSICAL_LOCK             0x01    // Bit 0 set - physical lock

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_NODISKSPACE
 * lParam  = drive number of drive that is out of disk space (1-based)
 *
 * Message issued by IFS manager when it detects that a drive is run out of
 * free space.
 */

#define DBT_NO_DISK_SPACE               0x0047

/*
 * Message = WM_DEVICECHANGE
 * wParam  = DBT_LOW_DISK_SPACE
 * lParam  = drive number of drive that is low on disk space (1-based)
 *
 * Message issued by VFAT when it detects that a drive it has mounted
 * has the remaning free space below a threshold specified by the
 * registry or by a disk space management application.
 * The broadcast is issued by VFAT ONLY when space is either allocated
 * or freed by VFAT.
 */

#define DBT_LOW_DISK_SPACE      0x0048

#define DBT_CONFIGMGPRIVATE             0x7FFF

/*
 * The following messages are for WM_DEVICECHANGE. The immediate list
 * is for the wParam. ALL THESE MESSAGES PASS A POINTER TO A STRUCT
 * STARTING WITH A DWORD SIZE AND HAVING NO POINTER IN THE STRUCT.
 *
 */
#define DBT_DEVICEARRIVAL               0x8000  // system detected a new device
#define DBT_DEVICEQUERYREMOVE           0x8001  // wants to remove, may fail
#define DBT_DEVICEQUERYREMOVEFAILED     0x8002  // removal aborted
#define DBT_DEVICEREMOVEPENDING         0x8003  // about to remove, still avail.
#define DBT_DEVICEREMOVECOMPLETE        0x8004  // device is gone
#define DBT_DEVICETYPESPECIFIC          0x8005  // type specific event
#if(WINVER >= 0x040A)
#define DBT_CUSTOMEVENT                 0x8006  // user-defined event
#endif /* WINVER >= 0x040A */

#define DBT_DEVTYP_OEM                  0x00000000  // oem-defined device type
#define DBT_DEVTYP_DEVNODE              0x00000001  // devnode number
#define DBT_DEVTYP_VOLUME               0x00000002  // logical volume
#define DBT_DEVTYP_PORT                 0x00000003  // serial, parallel
#define DBT_DEVTYP_NET                  0x00000004  // network resource

#if(WINVER >= 0x040A)
#define DBT_DEVTYP_DEVICEINTERFACE      0x00000005  // device interface class
#define DBT_DEVTYP_HANDLE               0x00000006  // file system handle
#endif /* WINVER >= 0x040A */

struct _DEV_BROADCAST_HEADER { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
};

struct _DEV_BROADCAST_OEM {     /* */
    DWORD       dbco_size;
    DWORD       dbco_devicetype;
    DWORD       dbco_reserved;
    DWORD       dbco_identifier;
    DWORD       dbco_suppfunc;
};

typedef struct  _DEV_BROADCAST_OEM      DEV_BROADCAST_OEM;
typedef         DEV_BROADCAST_OEM       DBTFAR *PDEV_BROADCAST_OEM;

struct _DEV_BROADCAST_DEVNODE { /* */
    DWORD       dbcd_size;
    DWORD       dbcd_devicetype;
    DWORD       dbcd_reserved;
    DWORD       dbcd_devnode;
};

typedef struct  _DEV_BROADCAST_DEVNODE  DEV_BROADCAST_DEVNODE;
typedef         DEV_BROADCAST_DEVNODE   DBTFAR *PDEV_BROADCAST_DEVNODE;

typedef struct _DEV_BROADCAST_VOLUME_A { /* */
    DWORD       dbcv_size;
    DWORD       dbcv_devicetype;
    DWORD       dbcv_reserved;
    DWORD       dbcv_unitmask;
    WORD        dbcv_flags;
    char        dbcv_name[1];
} DEV_BROADCAST_VOLUME_A, *PDEV_BROADCAST_VOLUME_A;

typedef struct _DEV_BROADCAST_VOLUME_W { /* */
    DWORD       dbcv_size;
    DWORD       dbcv_devicetype;
    DWORD       dbcv_reserved;
    DWORD       dbcv_unitmask;
    WORD        dbcv_flags;
    wchar_t     dbcv_name[1];
} DEV_BROADCAST_VOLUME_W, *PDEV_BROADCAST_VOLUME_W;

#ifdef UNICODE
typedef DEV_BROADCAST_VOLUME_W   DEV_BROADCAST_VOLUME;
typedef PDEV_BROADCAST_VOLUME_W  PDEV_BROADCAST_VOLUME;
#else
typedef DEV_BROADCAST_VOLUME_A   DEV_BROADCAST_VOLUME;
typedef PDEV_BROADCAST_VOLUME_A  PDEV_BROADCAST_VOLUME;
#endif

#define DBTF_MEDIA      0x0001          // media comings and goings
#define DBTF_NET        0x0002          // network volume

typedef struct _DEV_BROADCAST_PORT_A {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    char        dbcp_name[1];
} DEV_BROADCAST_PORT_A, *PDEV_BROADCAST_PORT_A;

typedef struct _DEV_BROADCAST_PORT_W {
    DWORD       dbcp_size;
    DWORD       dbcp_devicetype;
    DWORD       dbcp_reserved;
    wchar_t     dbcp_name[1];
} DEV_BROADCAST_PORT_W, DBTFAR *PDEV_BROADCAST_PORT_W;

#ifdef UNICODE
typedef DEV_BROADCAST_PORT_W     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_W    PDEV_BROADCAST_PORT;
#else
typedef DEV_BROADCAST_PORT_A     DEV_BROADCAST_PORT;
typedef PDEV_BROADCAST_PORT_A    PDEV_BROADCAST_PORT;
#endif

struct _DEV_BROADCAST_NET { /* */
    DWORD       dbcn_size;
    DWORD       dbcn_devicetype;
    DWORD       dbcn_reserved;
    DWORD       dbcn_resource;
    DWORD       dbcn_flags;
};

typedef struct  _DEV_BROADCAST_NET      DEV_BROADCAST_NET;
typedef         DEV_BROADCAST_NET       DBTFAR *PDEV_BROADCAST_NET;

#if(WINVER >= 0x040A)

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_A {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    char        dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_A, *PDEV_BROADCAST_DEVICEINTERFACE_A;

typedef struct _DEV_BROADCAST_DEVICEINTERFACE_W {
    DWORD       dbcc_size;
    DWORD       dbcc_devicetype;
    DWORD       dbcc_reserved;
    GUID        dbcc_classguid;
    wchar_t     dbcc_name[1];
} DEV_BROADCAST_DEVICEINTERFACE_W, *PDEV_BROADCAST_DEVICEINTERFACE_W;

#ifdef UNICODE
typedef DEV_BROADCAST_DEVICEINTERFACE_W   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_W  PDEV_BROADCAST_DEVICEINTERFACE;
#else
typedef DEV_BROADCAST_DEVICEINTERFACE_A   DEV_BROADCAST_DEVICEINTERFACE;
typedef PDEV_BROADCAST_DEVICEINTERFACE_A  PDEV_BROADCAST_DEVICEINTERFACE;
#endif

typedef struct _DEV_BROADCAST_HANDLE {
    DWORD       dbch_size;
    DWORD       dbch_devicetype;
    DWORD       dbch_reserved;
    DWORD       dbch_handle;     // file handle used in call to RegisterDeviceNotification
    DWORD       dbch_hdevnotify; // HDEVNOTIFY returned from RegisterDeviceNotification
    //
    // The following 3 fields are only valid if wParam is DBT_CUSTOMEVENT.
    //
    GUID        dbch_eventguid;
    LONG        dbch_nameoffset; // offset (bytes) of variable-length string buffer (-1 if none)
    BYTE        dbch_data[1];    // variable-sized buffer, potentially containing binary and/or text data
} DEV_BROADCAST_HANDLE, *PDEV_BROADCAST_HANDLE;

#endif /* WINVER >= 0x040A */

#define DBTF_RESOURCE   0x00000001      // network resource
#define DBTF_XPORT      0x00000002      // new transport coming or going
#define DBTF_SLOWNET    0x00000004      // new incoming transport is slow
                                        // (dbcn_resource undefined for now)

#define DBT_VPOWERDAPI  0x8100          // VPOWERD API for Win95

/*
 *  User-defined message types all use wParam = 0xFFFF with the
 *  lParam a pointer to the structure below.
 *
 *  dbud_dbh - DEV_BROADCAST_HEADER must be filled in as usual.
 *
 *  dbud_szName contains a case-sensitive ASCIIZ name which names the
 *  message.  The message name consists of the vendor name, a backslash,
 *  then arbitrary user-defined ASCIIZ text.  For example:
 *
 *      "WidgetWare\QueryScannerShutdown"
 *      "WidgetWare\Video Q39S\AdapterReady"
 *
 *  After the ASCIIZ name, arbitrary information may be provided.
 *  Make sure that dbud_dbh.dbch_size is big enough to encompass
 *  all the data.  And remember that nothing in the structure may
 *  contain pointers.
 */

#define DBT_USERDEFINED 0xFFFF

struct _DEV_BROADCAST_USERDEFINED { /* */
    struct _DEV_BROADCAST_HDR dbud_dbh;
    char        dbud_szName[1];     /* ASCIIZ name */
/*  BYTE        dbud_rgbUserDefined[];*/ /* User-defined contents */
};

/*
 *  Obsolete definitions--do not use.
 */
#if(WINVER >= 0x040A)

#define DBT_DEVTYP_INTERFACEDEVICE  DBT_DEVTYP_DEVICEINTERFACE

typedef DEV_BROADCAST_DEVICEINTERFACE_W   DEV_BROADCAST_INTERFACEDEVICE_W;
typedef PDEV_BROADCAST_DEVICEINTERFACE_W  PDEV_BROADCAST_INTERFACEDEVICE_W;
typedef DEV_BROADCAST_DEVICEINTERFACE_A   DEV_BROADCAST_INTERFACEDEVICE_A;
typedef PDEV_BROADCAST_DEVICEINTERFACE_A  PDEV_BROADCAST_INTERFACEDEVICE_A;
#ifdef UNICODE
typedef DEV_BROADCAST_INTERFACEDEVICE_W   DEV_BROADCAST_INTERFACEDEVICE;
typedef PDEV_BROADCAST_INTERFACEDEVICE_W  PDEV_BROADCAST_INTERFACEDEVICE;
#else
typedef DEV_BROADCAST_INTERFACEDEVICE_A   DEV_BROADCAST_INTERFACEDEVICE;
typedef PDEV_BROADCAST_INTERFACEDEVICE_A  PDEV_BROADCAST_INTERFACEDEVICE;
#endif

#endif /* WINVER >= 0x040A */

#endif  // _DBT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddkmacro.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

//
// This file contains inline definitions of ceddk APIs.  The inline versions
// of these APIs should only be used when (a) performance is critical and
// (b) the platform's bus architecture supports them.
//

#pragma once

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#if x86

int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);

int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);

ULONG __inline READ_PORT_ULONG(volatile const ULONG * const port)
{
    return _inpd((USHORT)port);
}

VOID __inline WRITE_PORT_ULONG(volatile ULONG * const port, const ULONG value)
{
    _outpd((USHORT)port, (value));
}

USHORT __inline READ_PORT_USHORT(volatile const USHORT * const port)
{
    return _inpw((USHORT)port);
}

VOID __inline WRITE_PORT_USHORT(volatile USHORT * const port, USHORT const value)
{
    _outpw((USHORT)port, (value));
}

UCHAR __inline READ_PORT_UCHAR(volatile const UCHAR * const port)
{
    return _inp((USHORT)port);
}

VOID __inline WRITE_PORT_UCHAR(volatile UCHAR * const port, UCHAR const value)
{
    _outp((USHORT)port, (value));
}

#define READ_REGISTER_ULONG(reg) \
    (*(volatile unsigned long * const)(reg))

#define WRITE_REGISTER_ULONG(reg, val) \
    (*(volatile unsigned long * const)(reg)) = (val)

#define READ_REGISTER_USHORT(reg) \
    (*(volatile unsigned short * const)(reg))

#define WRITE_REGISTER_USHORT(reg, val) \
    (*(volatile unsigned short * const)(reg)) = (val)

#define READ_REGISTER_UCHAR(reg) \
    (*(volatile unsigned char * const)(reg))

#define WRITE_REGISTER_UCHAR(reg, val) \
    (*(volatile unsigned char * const)(reg)) = (val)

VOID _inline
READ_PORT_BUFFER_UCHAR(
    volatile const UCHAR * const  Port,
    UCHAR *  Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         edi, Buffer
    cld
    rep insb
  }
}


VOID _inline
READ_PORT_BUFFER_USHORT(
    volatile const USHORT * const Port,
    USHORT * Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         edi, Buffer
    cld
    rep insw
  }
}


VOID _inline
READ_PORT_BUFFER_ULONG(
    volatile const ULONG * const  Port,
    ULONG *  Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         edi, Buffer
    cld
    rep insd
  }
}

VOID _inline
WRITE_PORT_BUFFER_UCHAR(
    volatile UCHAR * const  Port,
    const UCHAR *  Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         esi, Buffer
    cld
    rep outsb
  }
}


VOID _inline
WRITE_PORT_BUFFER_USHORT(
    volatile USHORT * const Port,
    const USHORT * Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         esi, Buffer
    cld
    rep outsw
  }
}


VOID _inline
WRITE_PORT_BUFFER_ULONG(
    volatile ULONG * const  Port,
    const ULONG *  Buffer,
    ULONG   Count
    )
{
  __asm {
    mov         dx, word ptr Port
    mov         ecx, Count
    mov         esi, Buffer
    cld
    rep outsd
  }
}

// end of x86

#elif defined(MIPS) || defined(ARM)

#define READ_PORT_ULONG(reg) \
    (*(volatile unsigned long * const)(reg))

#define WRITE_PORT_ULONG(reg, val) \
    (*(volatile unsigned long * const)(reg)) = (val)

#define READ_PORT_USHORT(reg) \
    (*(volatile unsigned short * const)(reg))

#define WRITE_PORT_USHORT(reg, val) \
    (*(volatile unsigned short * const)(reg)) = (val)

#define READ_PORT_UCHAR(reg) \
    (*(volatile unsigned char * const)(reg))

#define WRITE_PORT_UCHAR(reg, val) \
    (*(volatile unsigned char * const)(reg)) = (val)

#define READ_REGISTER_ULONG(reg) \
    (*(volatile unsigned long * const)(reg))

#define WRITE_REGISTER_ULONG(reg, val) \
    (*(volatile unsigned long * const)(reg)) = (val)

#define READ_REGISTER_USHORT(reg) \
    (*(volatile unsigned short * const)(reg))

#define WRITE_REGISTER_USHORT(reg, val) \
    (*(volatile unsigned short * const)(reg)) = (val)

#define READ_REGISTER_UCHAR(reg) \
    (*(volatile unsigned char * const)(reg))

#define WRITE_REGISTER_UCHAR(reg, val) \
    (*(volatile unsigned char * const)(reg)) = (val)

VOID _inline
READ_PORT_BUFFER_UCHAR(
    volatile const UCHAR * const  Port,
    UCHAR *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *Buffer++ = *(volatile UCHAR * const)Port;
}


VOID _inline
READ_PORT_BUFFER_USHORT(
    volatile const USHORT * const Port,
    USHORT * Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *Buffer++ = *(volatile USHORT * const)Port;
}


VOID _inline
READ_PORT_BUFFER_ULONG(
    volatile const ULONG * const  Port,
    ULONG *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *Buffer++ = *(volatile ULONG * const)Port;
}


VOID _inline
WRITE_PORT_BUFFER_UCHAR(
    volatile UCHAR * const  Port,
    const UCHAR *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile UCHAR * const)Port = *Buffer++;
}


VOID _inline
WRITE_PORT_BUFFER_USHORT(
    volatile USHORT * const Port,
    const USHORT * Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile USHORT * const)Port = *Buffer++;
}


VOID _inline
WRITE_PORT_BUFFER_ULONG(
    volatile ULONG * const  Port,
    const ULONG *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile ULONG * const)Port = *Buffer++;
}


#elif SHx

ULONG READ_PORT_ULONG(volatile const ULONG * const port);

VOID WRITE_PORT_ULONG(volatile ULONG * const port, const ULONG value);

USHORT READ_PORT_USHORT(volatile const USHORT * const port);

VOID WRITE_PORT_USHORT(volatile USHORT * const port, const USHORT value);

UCHAR READ_PORT_UCHAR(volatile const UCHAR * const port);

VOID WRITE_PORT_UCHAR(volatile UCHAR * const port, const UCHAR value);

#define READ_REGISTER_ULONG(reg) \
    (*(volatile unsigned long * const)(reg))

#define WRITE_REGISTER_ULONG(reg, val) \
    (*(volatile unsigned long * const)(reg)) = (val)

#define READ_REGISTER_USHORT(reg) \
    (*(volatile unsigned short * const)(reg))

#define WRITE_REGISTER_USHORT(reg, val) \
    (*(volatile unsigned short * const)(reg)) = (val)

#define READ_REGISTER_UCHAR(reg) \
    (*(volatile unsigned char * const)(reg))

#define WRITE_REGISTER_UCHAR(reg, val) \
    (*(volatile unsigned char * const)(reg)) = (val)

VOID
READ_PORT_BUFFER_UCHAR(
    volatile const UCHAR * const  Port,
    UCHAR *  Buffer,
    ULONG   Count
    );

VOID
READ_PORT_BUFFER_USHORT(
    volatile const USHORT * const Port,
    USHORT * Buffer,
    ULONG   Count
    );

VOID
READ_PORT_BUFFER_ULONG(
    volatile const ULONG * const  Port,
    ULONG *  Buffer,
    ULONG   Count
    );

VOID
WRITE_PORT_BUFFER_UCHAR(
    volatile UCHAR * const  Port,
    const UCHAR *  Buffer,
    ULONG   Count
    );

VOID
WRITE_PORT_BUFFER_USHORT(
    volatile USHORT * const Port,
    const USHORT * Buffer,
    ULONG   Count
    );

VOID
WRITE_PORT_BUFFER_ULONG(
    volatile ULONG * const  Port,
    const ULONG *  Buffer,
    ULONG   Count
    );

#endif // MIPS

VOID _inline
READ_REGISTER_BUFFER_UCHAR(
    volatile const UCHAR * const  Register,
    UCHAR *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
         *Buffer++ = *(volatile UCHAR * const)Register;
}


VOID _inline
READ_REGISTER_BUFFER_USHORT(
    volatile const USHORT * const Register,
    USHORT * Buffer,
    ULONG   Count
    )
{
    while( Count-- )
         *Buffer++ = *(volatile USHORT * const)Register;
}


VOID _inline
READ_REGISTER_BUFFER_ULONG(
    volatile const ULONG * const  Register,
    ULONG *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
         *Buffer++ = *(volatile ULONG * const)Register;
}


VOID _inline
WRITE_REGISTER_BUFFER_UCHAR(
    volatile UCHAR * const  Register,
    const UCHAR *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile UCHAR * const)Register = *Buffer++;        
}


VOID _inline
WRITE_REGISTER_BUFFER_USHORT(
    volatile USHORT * const Register,
    const USHORT * Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile USHORT * const)Register = *Buffer++;
}


VOID _inline
WRITE_REGISTER_BUFFER_ULONG(
    volatile ULONG * const  Register,
    const ULONG *  Buffer,
    ULONG   Count
    )
{
    while( Count-- )
        *(volatile ULONG * const)Register = *Buffer++;
}


#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddkreg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

//
// This file contains prototypes for PCI helper functions.
//

#pragma once

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#include <devload.h>

#define MAX_DEVICE_WINDOWS              6

    // this structure describes a base/length pair
typedef struct _DEVICEWINDOW_tag {
    DWORD dwBase;                   // window base address
    DWORD dwLen;                    // window
} DEVICEWINDOW, *PDEVICEWINDOW;

// this structure contains address window information
typedef struct _DDKWINDOWINFO_tag {
    DWORD   cbSize;                 // size of this structure
    DWORD   dwBusNumber;            // PCI bus number
    DWORD   dwInterfaceType;        // INTERFACE_TYPE value (probably PCI == 5)
    DWORD   dwNumIoWindows;         // number of I/O windows
    DEVICEWINDOW ioWindows[MAX_DEVICE_WINDOWS];
    DWORD   dwNumMemWindows;        // number of memory windows
    DEVICEWINDOW memWindows[MAX_DEVICE_WINDOWS];
} DDKWINDOWINFO, *PDDKWINDOWINFO;

// This value indicates no IRQ was specified
#define IRQ_UNSPECIFIED                     0xFFFFFFFF

// this structure contains ISR information
typedef struct _DDKISRINFO_tag {
    DWORD   cbSize;                 // size of this structure
    DWORD   dwIrq;                  // interrupt number
    DWORD   dwSysintr;              // windows CE interrupt ID
    WCHAR   szIsrDll[DEVDLL_LEN];   // installable ISR dll
    WCHAR   szIsrHandler[DEVENTRY_LEN]; // installable ISR dll entry point
} DDKISRINFO, *PDDKISRINFO;

// ID word indices
#define PCIID_CLASS                         0
#define PCIID_SUBCLASS                      1
#define PCIID_PROGIF                        2
#define PCIID_VENDORID                      3
#define PCIID_DEVICEID                      4
#define PCIID_REVISIONID                    5
#define PCIID_SUBSYSTEMVENDORID             6
#define PCIID_SUBSYSTEMID                   7
#define PCIID_MAXNUMIDS                     (PCIID_SUBSYSTEMID + 1)

// ID word masks
#define PCIIDM_CLASS                        (1 << PCIID_CLASS)
#define PCIIDM_SUBCLASS                     (1 << PCIID_SUBCLASS)
#define PCIIDM_PROGIF                       (1 << PCIID_PROGIF)
#define PCIIDM_VENDORID                     (1 << PCIID_VENDORID)
#define PCIIDM_DEVICEID                     (1 << PCIID_DEVICEID)
#define PCIIDM_REVISIONID                   (1 << PCIID_REVISIONID)
#define PCIIDM_SUBSYSTEMVENDORID            (1 << PCIID_SUBSYSTEMVENDORID)
#define PCIIDM_SUBSYSTEMID                  (1 << PCIID_SUBSYSTEMID)

// this structure keeps track of standard PCI device instance information
typedef struct _DDKPCIINFO_tag {
    DWORD   cbSize;                 // size of this structure

    // instancing information
    DWORD   dwDeviceNumber;
    DWORD   dwFunctionNumber;
    DWORD   dwInstanceIndex;

    // device ID information
    DWORD   dwWhichIds;             // idVals[PCIID_XXX] present if (dwWhichIds & (1 << PCIID_XXX)) != 0
    DWORD   idVals[PCIID_MAXNUMIDS]; // class, subclass, etc, populated as described in dwWhichIds
} DDKPCIINFO, *PDDKPCIINFO;

// function prototypes
DWORD WINAPI DDKReg_GetWindowInfo(HKEY hk, PDDKWINDOWINFO pwi);
DWORD WINAPI DDKReg_GetIsrInfo(HKEY hk, PDDKISRINFO pii);
DWORD WINAPI DDKReg_GetPciInfo(HKEY hk, PDDKPCIINFO ppi);

#ifdef __cplusplus
};
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddraw.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*==========================================================================;
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *
 ***************************************************************************/
#pragma once

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif


// Other components use this define to tell if they have the DirectDraw
// defintitions presents or if they have to re-define stuff.
#define __DDRAW_INCLUDED__

/*
 * GUIDS used by DirectDraw objects
 */
#include <ddrawguids.h>
/*
 * Forward interface declerations
 */

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;
struct IDirectDrawColorControl;
struct IDirectDrawGammaControl;

typedef struct IDirectDraw              *LPDIRECTDRAW;
typedef struct IDirectDrawSurface       *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawPalette       *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper       *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl  *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl  *LPDIRECTDRAWGAMMACONTROL;

/*
 * DirectDraw Structures
 */

/*
 * DDCOLORKEY
 */

typedef struct _DDCOLORKEY
{
    DWORD   dwColorSpaceLowValue;   // low boundary of color space that is to
                                    // be treated as Color Key, inclusive
    DWORD   dwColorSpaceHighValue;  // high boundary of color space that is
                                    // to be treated as Color Key, inclusive
} DDCOLORKEY, * LPDDCOLORKEY;

/*
 * DDARGB
 * Generic pixel format with 8-bit RGB and alpha components
 */

typedef struct _DDARGB
{
    BYTE    blue;
    BYTE    green;
    BYTE    red;
    BYTE    alpha;

} DDARGB, *LPDDARGB;

/*
 * DDBLTFX
 */

typedef struct _DDBLTFX
{
    DWORD      dwSize;              // size of structure
    DWORD      dwROP;               // Win32 raster operations
    DWORD      dwFillColor;         // color in RGB or Palettized (Brush value for Win32 ROPs)
    DDCOLORKEY ddckDestColorkey;    // DestColorkey override
    DDCOLORKEY ddckSrcColorkey;     // SrcColorkey override
    DWORD      dwDDFX;              // Flags
} DDBLTFX, * LPDDBLTFX;

/*
 * DDALPHABLTFX
 */

typedef struct _DDALPHABLTFX
{
    DWORD   dwSize;                 // size of structure
    DDARGB  ddargbScaleFactors;     // Constant scaling factors
    DWORD   dwFillColor;            // color in ARGB or Palettized
    DWORD   dwDDFX;                 // BLTFX Flags

} DDALPHABLTFX, * LPDDALPHABLTFX;

/*
 * DDSCAPS
 * Caps bits defined below.
 */

typedef struct _DDSCAPS
{
    DWORD   dwCaps;

} DDSCAPS, * LPDDSCAPS;

/*
 * DDCAPS
 */

#define DD_ROP_SPACE (256/32)       // space required to store ROP array

typedef struct _DDCAPS
{
    DWORD   dwSize;                 // size of the DDCAPS structure

    // Surface capabilities

    DWORD   dwVidMemTotal;          // total amount of video memory
    DWORD   dwVidMemFree;           // amount of free video memory
    DWORD   dwVidMemStride;         // video memory stride (0 if linear)

    DDSCAPS ddsCaps;                // surface caps

    DWORD   dwNumFourCCCodes;       // number of four cc codes

    // Palette capabilities

    DWORD   dwPalCaps;              // palette capabilities

    // Hardware blitting capabilities

    DWORD   dwBltCaps;              // driver specific capabilities
    DWORD   dwCKeyCaps;             // color key blitting capabilities
    DWORD   dwAlphaCaps;            // alpha blitting capabilities
    DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported

    // Overlay capabilities

    DWORD   dwOverlayCaps;          // general overlay capabilities.

    DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD   dwCurrVisibleOverlays;  // current number of visible overlays

    DWORD   dwAlignBoundarySrc;     // source rectangle alignment
    DWORD   dwAlignSizeSrc;         // source rectangle byte size
    DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD   dwAlignSizeDest;        // dest rectangle byte size

    DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3

    // Miscallenous capabilities

    DWORD   dwMiscCaps;

    // Video port capabilities.
    
    DWORD   dwMinVideoStretch;      // minimum video port stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD   dwMaxVideoStretch;      // maximum video port stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
        
    DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
    DWORD   dwCurrVideoPorts;       // current number of video ports used

} DDCAPS, * LPDDCAPS;

/*
 * DDPIXELFORMAT
 */

typedef struct _DDPIXELFORMAT
{
    DWORD   dwSize;                 // size of structure
    DWORD   dwFlags;                // pixel format flags
    DWORD   dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel
    DWORD   dwYUVBitCount;          // how many bits per pixel
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    };

} DDPIXELFORMAT, * LPDDPIXELFORMAT;

/*
 * DDPIXELFORMAT dwFlags values.
 */

#define DDPF_ALPHAPIXELS        0x00000001
#define DDPF_ALPHA              0x00000002
#define DDPF_FOURCC             0x00000004
#define DDPF_PALETTEINDEXED     0x00000020
#define DDPF_RGB                0x00000040
#define DDPF_ALPHAPREMULT       0x00008000

#define DDPF_VALID              (DDPF_ALPHAPIXELS    | \
                                 DDPF_ALPHA          | \
                                 DDPF_FOURCC         | \
                                 DDPF_PALETTEINDEXED | \
                                 DDPF_RGB            | \
                                 DDPF_ALPHAPREMULT)

/*
 * DDSURFACEDESC
 */

typedef struct _DDSURFACEDESC
{
    DWORD         dwSize;               // size of the DDSURFACEDESC structure
    DWORD         dwFlags;              // determines what fields are valid
    DWORD         dwHeight;             // height of surface to be created
    DWORD         dwWidth;              // width of input surface
    LONG          lPitch;               // bytes to next line down (return value only)
    LONG          lXPitch;              // bytes to next pixel right (return value only)
    DWORD         dwBackBufferCount;    // number of back buffers requested
    DWORD         dwRefreshRate;        // refresh rate (used when display mode is described)
    LPVOID        lpSurface;            // pointer to the associated surface memory
    DDCOLORKEY    ddckCKDestOverlay;    // color key for destination overlay use
    DDCOLORKEY    ddckCKDestBlt;        // color key for destination blt use
    DDCOLORKEY    ddckCKSrcOverlay;     // color key for source overlay use
    DDCOLORKEY    ddckCKSrcBlt;         // color key for source blt use
    DDPIXELFORMAT ddpfPixelFormat;      // pixel format description of the surface
    DDSCAPS       ddsCaps;              // direct draw surface capabilities
    DWORD         dwSurfaceSize;        // Surface size, in bytes

} DDSURFACEDESC, * LPDDSURFACEDESC;

/*
 * DDSURFACEDESC dwFlags values.
 */

#define DDSD_CAPS               0x00000001
#define DDSD_HEIGHT             0x00000002
#define DDSD_WIDTH              0x00000004
#define DDSD_PITCH              0x00000008
#define DDSD_XPITCH             0x00000010
#define DDSD_BACKBUFFERCOUNT    0x00000020
#define DDSD_LPSURFACE          0x00000800
#define DDSD_PIXELFORMAT        0x00001000
#define DDSD_CKDESTOVERLAY      0x00002000
#define DDSD_CKDESTBLT          0x00004000
#define DDSD_CKSRCOVERLAY       0x00008000
#define DDSD_CKSRCBLT           0x00010000
#define DDSD_REFRESHRATE        0x00040000
#define DDSD_SURFACESIZE        0x00080000

#define DDSD_VALID              (DDSD_CAPS              | \
                                 DDSD_HEIGHT            | \
                                 DDSD_WIDTH             | \
                                 DDSD_PITCH             | \
                                 DDSD_XPITCH            | \
                                 DDSD_BACKBUFFERCOUNT   | \
                                 DDSD_LPSURFACE         | \
                                 DDSD_PIXELFORMAT       | \
                                 DDSD_CKDESTOVERLAY     | \
                                 DDSD_CKDESTBLT         | \
                                 DDSD_CKSRCOVERLAY      | \
                                 DDSD_CKSRCBLT          | \
                                 DDSD_REFRESHRATE       | \
                                 DDSD_SURFACESIZE)

#define DDSD_ENUM_VALID         (DDSD_CAPS              | \
                                 DDSD_HEIGHT            | \
                                 DDSD_WIDTH             | \
                                 DDSD_PIXELFORMAT)

/*
 * DDOVERLAYFX
 */

typedef struct _DDOVERLAYFX
{
    DWORD      dwSize;                  // size of structure

    DWORD      dwAlphaConstBitDepth;    // Bit depth used to specify alpha constant.
    DWORD      dwAlphaConst;            // Constant to use as alpha channel.

    DDCOLORKEY dckDestColorkey;         // DestColorkey override
    DDCOLORKEY dckSrcColorkey;          // DestColorkey override

} DDOVERLAYFX, * LPDDOVERLAYFX;

/*
 * DDGAMMARAMP
 */

typedef struct _DDGAMMARAMP
{
    WORD    red[256];
    WORD    green[256];
    WORD    blue[256];

} DDGAMMARAMP, * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

#define MAX_DDDEVICEID_STRING 512

typedef struct _DDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */

    wchar_t szDriver[MAX_DDDEVICEID_STRING];
    wchar_t szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */

    LARGE_INTEGER liDriverVersion;


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution. 
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */

    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */

    GUID    guidDeviceIdentifier;

} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

/*
 * DDCOLORCONTROL
 */

typedef struct _DDCOLORCONTROL
{
    DWORD   dwSize;
    DWORD   dwFlags;
    LONG    lBrightness;
    LONG    lContrast;
    LONG    lHue;
    LONG    lSaturation;
    LONG    lSharpness;
    LONG    lGamma;
    LONG    lColorEnable;

} DDCOLORCONTROL, * LPDDCOLORCONTROL;

/*
 * DDCOLORCONTROL dwFlags values.
 */

#define DDCOLOR_BRIGHTNESS      0x00000001
#define DDCOLOR_CONTRAST        0x00000002
#define DDCOLOR_HUE             0x00000004
#define DDCOLOR_SATURATION      0x00000008
#define DDCOLOR_SHARPNESS       0x00000010
#define DDCOLOR_GAMMA           0x00000020
#define DDCOLOR_COLORENABLE     0x00000040

#define DDCOLOR_VALID           (DDCOLOR_BRIGHTNESS     | \
                                 DDCOLOR_CONTRAST       | \
                                 DDCOLOR_HUE            | \
                                 DDCOLOR_SATURATION     | \
                                 DDCOLOR_SHARPNESS      | \
                                 DDCOLOR_GAMMA          | \
                                 DDCOLOR_COLORENABLE)

/*
 * API's
 */

typedef BOOL (PASCAL * LPDDENUMCALLBACKEX)(LPGUID, LPWSTR, LPWSTR, LPVOID, HMONITOR);
extern HRESULT WINAPI DirectDrawEnumerateEx(LPDDENUMCALLBACKEX lpCallback, LPVOID lpContext, DWORD dwFlags);

extern HRESULT WINAPI DirectDrawCreate(LPGUID lpGUID, LPDIRECTDRAW *lplpDD, IUnknown *pUnkOuter);
extern HRESULT WINAPI DirectDrawCreateClipper(DWORD dwFlags, LPDIRECTDRAWCLIPPER *lplpDDClipper, IUnknown *pUnkOuter);

/*
 * DirectDrawEnumerateEx Flags
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002

#define DDENUM_VALID                        (DDENUM_ATTACHEDSECONDARYDEVICES | \
                                             DDENUM_DETACHEDSECONDARYDEVICES)

/*
 * Enumeration function pointer types
 */

typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);

/*
 * IDirectDraw
 */

#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_(IDirectDraw, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDraw methods ***/
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER *, IUnknown *) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE *, IUnknown *) PURE;
    STDMETHOD(CreateSurface)(THIS_ LPDDSURFACEDESC, LPDIRECTDRAWSURFACE *, IUnknown *) PURE;
    STDMETHOD(EnumDisplayModes)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE) PURE;
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetSurfaceFromDC)(THIS_ HDC, LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
};

/*
 * IDirectDrawPalette
 */

#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_(IDirectDrawPalette, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD, DWORD, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD, DWORD, DWORD, LPPALETTEENTRY) PURE;
};

/*
 * IDirectDrawClipper
 */

#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_(IDirectDrawClipper, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND *) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ LPBOOL) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA, DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND) PURE;
};

/*
 * IDirectDrawSurface
 */

#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_(IDirectDrawSurface, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDBLTFX) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID, LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD, LPVOID, LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER *) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE *) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT, LPDDSURFACEDESC, DWORD, HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(GetDDInterface)(THIS_ LPDIRECTDRAW *) PURE;
    STDMETHOD(AlphaBlt)(THIS_ LPRECT, LPDIRECTDRAWSURFACE, LPRECT, DWORD, LPDDALPHABLTFX) PURE;
};

/*
 * IDirectDrawColorControl
 */

#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_(IDirectDrawColorControl, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

/*
 * IDirectDrawGammaControl
 */

#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_(IDirectDrawGammaControl, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

/*
 * DirectDraw Macros
 */

#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                                \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |         \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

/*
 * Direct Draw Capability Flags
 */

/*
 * Surface Capability Flags
 */

#define DDSCAPS_ALPHA                   0x00000001
#define DDSCAPS_BACKBUFFER              0x00000002
#define DDSCAPS_FLIP                    0x00000004
#define DDSCAPS_FRONTBUFFER             0x00000008
#define DDSCAPS_OVERLAY                 0x00000010
#define DDSCAPS_PALETTE                 0x00000020
#define DDSCAPS_PRIMARYSURFACE          0x00000040
#define DDSCAPS_SYSTEMMEMORY            0x00000080
#define DDSCAPS_VIDEOMEMORY             0x00000100
#define DDSCAPS_WRITEONLY               0x00000200
#define DDSCAPS_VIDEOPORT               0x00000400
#define DDSCAPS_READONLY                0x00000800       
#define DDSCAPS_HARDWAREDEINTERLACE     0x00001000
#define DDSCAPS_NOTUSERLOCKABLE         0x00002000
#define DDSCAPS_DYNAMIC                 0x00004000
#define DDSCAPS_OWNDC                   0x00008000

#define DDSCAPS_VALID                   (DDSCAPS_ALPHA               | \
                                         DDSCAPS_BACKBUFFER          | \
                                         DDSCAPS_FLIP                | \
                                         DDSCAPS_FRONTBUFFER         | \
                                         DDSCAPS_OVERLAY             | \
                                         DDSCAPS_PALETTE             | \
                                         DDSCAPS_PRIMARYSURFACE      | \
                                         DDSCAPS_SYSTEMMEMORY        | \
                                         DDSCAPS_VIDEOMEMORY         | \
                                         DDSCAPS_WRITEONLY           | \
                                         DDSCAPS_VIDEOPORT           | \
                                         DDSCAPS_READONLY            | \
                                         DDSCAPS_HARDWAREDEINTERLACE | \
                                         DDSCAPS_NOTUSERLOCKABLE     | \
                                         DDSCAPS_DYNAMIC             | \
                                         DDSCAPS_OWNDC)

/*
 * Palette Capability Flags
 */

#define DDPCAPS_PRIMARYSURFACE          0x00000010
#define DDPCAPS_ALPHA                   0x00000400

#define DDPCAPS_VALID                   (DDPCAPS_PRIMARYSURFACE | \
                                         DDPCAPS_ALPHA)

/*
 * DirectDraw Capability Flags
 */

/*
 * General hardware blitting capabilities (For DDCAPS dwBltCaps field)
 */

#define DDBLTCAPS_READSYSMEM            0x00000001
#define DDBLTCAPS_WRITESYSMEM           0x00000002
#define DDBLTCAPS_FOURCCTORGB           0x00000004
#define DDBLTCAPS_COPYFOURCC            0x00000008
#define DDBLTCAPS_FILLFOURCC            0x00000010
#define DDBLTCAPS_ROTATION90            0x00000020
#define DDBLTCAPS_RGBTOFOURCC           0x00000040

#define DDBLTCAPS_VALID                 (DDBLTCAPS_READSYSMEM  | \
                                         DDBLTCAPS_WRITESYSMEM | \
                                         DDBLTCAPS_FOURCCTORGB | \
                                         DDBLTCAPS_COPYFOURCC  | \
                                         DDBLTCAPS_FILLFOURCC  | \
                                         DDBLTCAPS_ROTATION90  | \
                                         DDBLTCAPS_RGBTOFOURCC)

/*
 * Hardware color key blitting capabilities (For DDCAPS dwCKeyCaps field)
 */

#define DDCKEYCAPS_DESTBLT              0x00000001
#define DDCKEYCAPS_DESTBLTCLRSPACE      0x00000002
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV   0x00000004
#define DDCKEYCAPS_SRCBLT               0x00000200
#define DDCKEYCAPS_SRCBLTCLRSPACE       0x00000400
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV    0x00000800
#define DDCKEYCAPS_BOTHBLT              0x00001000

#define DDCKEYCAPS_VALID                (DDCKEYCAPS_DESTBLT            | \
                                         DDCKEYCAPS_DESTBLTCLRSPACE    | \
                                         DDCKEYCAPS_DESTBLTCLRSPACEYUV | \
                                         DDCKEYCAPS_SRCBLT             | \
                                         DDCKEYCAPS_SRCBLTCLRSPACE     | \
                                         DDCKEYCAPS_SRCBLTCLRSPACEYUV  | \
                                         DDCKEYCAPS_BOTHBLT)

/*
 * Hardware alpha blitting capabilities (For DDCAPS dwAlphaCaps field)
 */

#define DDALPHACAPS_ALPHAPIXELS         0x00000001
#define DDALPHACAPS_ALPHASURFACE        0x00000002
#define DDALPHACAPS_ALPHAPALETTE        0x00000004
#define DDALPHACAPS_ALPHACONSTANT       0x00000008
#define DDALPHACAPS_ARGBSCALE           0x00000010
#define DDALPHACAPS_SATURATE            0x00000020
#define DDALPHACAPS_PREMULT             0x00000040
#define DDALPHACAPS_NONPREMULT          0x00000080
#define DDALPHACAPS_ALPHAFILL           0x00000800
#define DDALPHACAPS_ALPHANEG            0x00000100

#define DDALPHACAPS_VALID               (DDALPHACAPS_ALPHAPIXELS   | \
                                         DDALPHACAPS_ALPHASURFACE  | \
                                         DDALPHACAPS_ALPHAPALETTE  | \
                                         DDALPHACAPS_ALPHACONSTANT | \
                                         DDALPHACAPS_ARGBSCALE     | \
                                         DDALPHACAPS_SATURATE      | \
                                         DDALPHACAPS_PREMULT       | \
                                         DDALPHACAPS_NONPREMULT    | \
                                         DDALPHACAPS_ALPHAFILL     | \
                                         DDALPHACAPS_ALPHANEG)

/*
 * Overlay capabilities ( For DDCAPS dwOverlayCaps field)
 */

#define DDOVERLAYCAPS_FLIP                  0x00000001
#define DDOVERLAYCAPS_AUTOFLIP              0x00000002
#define DDOVERLAYCAPS_FOURCC                0x00000004
#define DDOVERLAYCAPS_ZORDER                0x00000008
#define DDOVERLAYCAPS_MIRRORLEFTRIGHT       0x00000010
#define DDOVERLAYCAPS_MIRRORUPDOWN          0x00000020
#define DDOVERLAYCAPS_CKEYSRC               0x00000040
#define DDOVERLAYCAPS_CKEYSRCCLRSPACE       0x00000080
#define DDOVERLAYCAPS_CKEYSRCCLRSPACEYUV    0x00000100
#define DDOVERLAYCAPS_CKEYDEST              0x00000200
#define DDOVERLAYCAPS_CKEYDESTCLRSPACE      0x00000400
#define DDOVERLAYCAPS_CKEYDESTCLRSPACEYUV   0x00000800
#define DDOVERLAYCAPS_CKEYBOTH              0x00001000
#define DDOVERLAYCAPS_ALPHADEST             0x00002000
#define DDOVERLAYCAPS_ALPHASRC              0x00008000
#define DDOVERLAYCAPS_ALPHADESTNEG          0x00002000
#define DDOVERLAYCAPS_ALPHASRCNEG           0x00008000
#define DDOVERLAYCAPS_ALPHACONSTANT         0x00010000
#define DDOVERLAYCAPS_ALPHAPREMULT          0x00040000
#define DDOVERLAYCAPS_ALPHANONPREMULT       0x00080000
#define DDOVERLAYCAPS_ALPHAANDKEYDEST       0x00100000
#define DDOVERLAYCAPS_OVERLAYSUPPORT        0x80000000

#define DDOVERLAYCAPS_VALID                 (DDOVERLAYCAPS_FLIP                | \
                                             DDOVERLAYCAPS_AUTOFLIP            | \
                                             DDOVERLAYCAPS_FOURCC              | \
                                             DDOVERLAYCAPS_ZORDER              | \
                                             DDOVERLAYCAPS_MIRRORLEFTRIGHT     | \
                                             DDOVERLAYCAPS_MIRRORUPDOWN        | \
                                             DDOVERLAYCAPS_CKEYSRC             | \
                                             DDOVERLAYCAPS_CKEYSRCCLRSPACE     | \
                                             DDOVERLAYCAPS_CKEYSRCCLRSPACEYUV  | \
                                             DDOVERLAYCAPS_CKEYDEST            | \
                                             DDOVERLAYCAPS_CKEYDESTCLRSPACE    | \
                                             DDOVERLAYCAPS_CKEYDESTCLRSPACEYUV | \
                                             DDOVERLAYCAPS_CKEYBOTH            | \
                                             DDOVERLAYCAPS_ALPHADEST           | \
                                             DDOVERLAYCAPS_ALPHASRC            | \
                                             DDOVERLAYCAPS_ALPHADESTNEG        | \
                                             DDOVERLAYCAPS_ALPHASRCNEG         | \
                                             DDOVERLAYCAPS_ALPHACONSTANT       | \
                                             DDOVERLAYCAPS_ALPHAPREMULT        | \
                                             DDOVERLAYCAPS_ALPHANONPREMULT     | \
                                             DDOVERLAYCAPS_ALPHAANDKEYDEST     | \
                                             DDOVERLAYCAPS_OVERLAYSUPPORT)

/*
 * Miscellaneous Capability Flags (For DDCAPS dwMiscCaps member)
 */

#define DDMISCCAPS_READSCANLINE         0x00000001
#define DDMISCCAPS_READMONITORFREQ      0x00000002
#define DDMISCCAPS_READVBLANKSTATUS     0x00000004
#define DDMISCCAPS_FLIPINTERVAL         0x00000008
#define DDMISCCAPS_FLIPODDEVEN          0x00000010
#define DDMISCCAPS_FLIPVSYNCWITHVBI     0x00000020
#define DDMISCCAPS_COLORCONTROLOVERLAY  0x00000040
#define DDMISCCAPS_COLORCONTROLPRIMARY  0x00000080
#define DDMISCCAPS_GAMMACONTROLOVERLAY  0x00000100
#define DDMISCCAPS_GAMMACONTROLPRIMARY  0x00000200
#define DDMISCCAPS_AUTOFLIPOVERLAY      0x00000400
#define DDMISCCAPS_VIDEOPORT            0x00000800
#define DDMISCCAPS_BOBINTERLEAVED       0x00001000
#define DDMISCCAPS_BOBNONINTERLEAVED    0x00002000
#define DDMISCCAPS_BOBHARDWARE          0x00004000

#define DDMISCCAPS_VALID                (DDMISCCAPS_READSCANLINE        | \
                                         DDMISCCAPS_READMONITORFREQ     | \
                                         DDMISCCAPS_READVBLANKSTATUS    | \
                                         DDMISCCAPS_FLIPINTERVAL        | \
                                         DDMISCCAPS_FLIPODDEVEN         | \
                                         DDMISCCAPS_FLIPVSYNCWITHVBI    | \
                                         DDMISCCAPS_COLORCONTROLOVERLAY | \
                                         DDMISCCAPS_COLORCONTROLPRIMARY | \
                                         DDMISCCAPS_GAMMACONTROLOVERLAY | \
                                         DDMISCCAPS_GAMMACONTROLPRIMARY | \
                                         DDMISCCAPS_AUTOFLIPOVERLAY     | \
                                         DDMISCCAPS_VIDEOPORT           | \
                                         DDMISCCAPS_BOBINTERLEAVED      | \
                                         DDMISCCAPS_BOBNONINTERLEAVED   | \
                                         DDMISCCAPS_BOBHARDWARE)

/*
 * DirectDraw method flags
 */

/*
 * Flags for IDirectDraw::EnumSurfaces
 */

#define DDENUMSURFACES_ALL              0x00000001
#define DDENUMSURFACES_MATCH            0x00000002
#define DDENUMSURFACES_NOMATCH          0x00000004
#define DDENUMSURFACES_CANBECREATED     0x00000008
#define DDENUMSURFACES_DOESEXIST        0x00000010

#define DDENUMSURFACES_VALID            (DDENUMSURFACES_ALL          | \
                                         DDENUMSURFACES_MATCH        | \
                                         DDENUMSURFACES_NOMATCH      | \
                                         DDENUMSURFACES_CANBECREATED | \
                                         DDENUMSURFACES_DOESEXIST)

/*
 * Flags for IDirectDraw::SetCooperativeLevel
 */

#define DDSCL_NORMAL                0x00000000
#define DDSCL_FULLSCREEN            0x00000001

#define DDSCL_VALID                 (DDSCL_FULLSCREEN | \
                                     DDSCL_NORMAL)

/*
 * Flags for IDirectDraw::WaitForVerticalBlank
 */

#define DDWAITVB_BLOCKBEGIN         0x00000001
#define DDWAITVB_BLOCKEND           0x00000004

#define DDWAITVB_VALID              (DDWAITVB_BLOCKBEGIN | \
                                     DDWAITVB_BLOCKEND)

/*
 * Flags for IDirectDrawSurface::GetColorKey and IDirectDrawSurface::SetColorKey
 */

#define DDCKEY_COLORSPACE           0x00000001
#define DDCKEY_DESTBLT              0x00000002
#define DDCKEY_DESTOVERLAY          0x00000004
#define DDCKEY_SRCBLT               0x00000008
#define DDCKEY_SRCOVERLAY           0x00000010

#define DDCKEY_VALID                (DDCKEY_DESTBLT     | \
                                     DDCKEY_DESTOVERLAY | \
                                     DDCKEY_SRCBLT      | \
                                     DDCKEY_SRCOVERLAY)

/*
 * Flags for IDirectDrawSurface::Blt
 */

#define DDBLT_COLORFILL             0x00000400
#define DDBLT_DDFX                  0x00000800
#define DDBLT_KEYDEST               0x00002000
#define DDBLT_KEYDESTOVERRIDE       0x00004000
#define DDBLT_KEYSRC                0x00008000
#define DDBLT_KEYSRCOVERRIDE        0x00010000
#define DDBLT_ROP                   0x00020000
#define DDBLT_WAITNOTBUSY           0x01000000
#define DDBLT_WAITVSYNC             0x00000001


#define DDBLT_VALID                 (DDBLT_COLORFILL       | \
                                     DDBLT_DDFX            | \
                                     DDBLT_KEYDEST         | \
                                     DDBLT_KEYDESTOVERRIDE | \
                                     DDBLT_KEYSRC          | \
                                     DDBLT_KEYSRCOVERRIDE  | \
                                     DDBLT_ROP             | \
                                     DDBLT_WAITNOTBUSY     | \
                                     DDBLT_WAITVSYNC)


#define DDBLTFX_ROTATE90            0x00000001
#define DDBLTFX_ROTATE180           0x00000002
#define DDBLTFX_ROTATE270           0x00000004

#define DDBLTFX_VALID               (DDBLTFX_ROTATE90 | \
                                     DDBLTFX_ROTATE180 | \
                                     DDBLTFX_ROTATE270)

/*
 * Flags for IDirectDrawSurface::AlphaBlt
 */

#define DDABLT_NOBLEND              0x02000000
#define DDABLT_COLORFILL            0x00100000
#define DDABLT_DDFX                 0x00000800
#define DDABLT_ALPHADESTNEG         0x00000004
#define DDABLT_ALPHASRCNEG          0x00000080
#define DDABLT_WAITNOTBUSY          0x01000000
#define DDABLT_WAITVSYNC            0x00000001

#define DDABLT_VALID                (DDABLT_NOBLEND      | \
                                     DDABLT_COLORFILL    | \
                                     DDABLT_DDFX         | \
                                     DDABLT_ALPHADESTNEG | \
                                     DDABLT_ALPHASRCNEG  | \
                                     DDABLT_WAITNOTBUSY  | \
                                     DDABLT_WAITVSYNC)

#define DDABLTFX_ROTATE90           DDBLTFX_ROTATE90
#define DDABLTFX_ROTATE180          DDBLTFX_ROTATE180
#define DDABLTFX_ROTATE270          DDBLTFX_ROTATE270

#define DDABLTFX_VALID              (DDABLTFX_ROTATE90 | \
                                     DDABLTFX_ROTATE180 | \
                                     DDABLTFX_ROTATE270)

/*
 * Flags for IDirectDrawSurface::Flip
 */

#define DDFLIP_EVEN                 0x00000002
#define DDFLIP_ODD                  0x00000004
#define DDFLIP_INTERVAL1            0x01000000
#define DDFLIP_INTERVAL2            0x02000000
#define DDFLIP_INTERVAL4            0x04000000
#define DDFLIP_WAITNOTBUSY          0x00000008
#define DDFLIP_WAITVSYNC                     0x00000001

#define DDFLIP_VALID                (DDFLIP_EVEN         | \
                                     DDFLIP_ODD          | \
                                     DDFLIP_INTERVAL1    | \
                                     DDFLIP_INTERVAL2    | \
                                     DDFLIP_INTERVAL4    | \
                                     DDFLIP_WAITNOTBUSY  | \
                                     DDFLIP_WAITVSYNC)

#define DDFLIP_INTERVAL3            (DDFLIP_INTERVAL1 | \
                                     DDFLIP_INTERVAL2)

#define DDFLIP_INTERVALMASK         (DDFLIP_INTERVAL1 | \
                                     DDFLIP_INTERVAL2 | \
                                     DDFLIP_INTERVAL4)

/*
 * Flag values for IDirectDrawSurface::UpdateOverlay
 */

#define DDOVER_ALPHADEST            0x00000001
#define DDOVER_ALPHADESTNEG         0x00000002
#define DDOVER_ALPHASRC             0x00000004
#define DDOVER_ALPHASRCNEG          0x00000008
#define DDOVER_ALPHACONSTOVERRIDE   0x00000010
#define DDOVER_HIDE                 0x00000020
#define DDOVER_KEYDEST              0x00000040
#define DDOVER_KEYDESTOVERRIDE      0x00000080
#define DDOVER_KEYSRC               0x00000100
#define DDOVER_KEYSRCOVERRIDE       0x00000200
#define DDOVER_SHOW                 0x00000400
#define DDOVER_MIRRORLEFTRIGHT      0x00001000
#define DDOVER_MIRRORUPDOWN         0x00002000
#define DDOVER_WAITNOTBUSY          0x00004000
#define DDOVER_WAITVSYNC            0x00008000
#define DDOVER_AUTOFLIP             0x00100000
#define DDOVER_BOB                  0x00200000
#define DDOVER_OVERRIDEBOBWEAVE     0x00400000
#define DDOVER_INTERLEAVED          0x00800000
#define DDOVER_BOBHARDWARE          0x01000000

#define DDOVER_VALID                (DDOVER_ALPHADEST          | \
                                     DDOVER_ALPHADESTNEG       | \
                                     DDOVER_ALPHASRC           | \
                                     DDOVER_ALPHASRCNEG        | \
                                     DDOVER_ALPHACONSTOVERRIDE | \
                                     DDOVER_HIDE               | \
                                     DDOVER_KEYDEST            | \
                                     DDOVER_KEYDESTOVERRIDE    | \
                                     DDOVER_KEYSRC             | \
                                     DDOVER_KEYSRCOVERRIDE     | \
                                     DDOVER_SHOW               | \
                                     DDOVER_MIRRORLEFTRIGHT    | \
                                     DDOVER_MIRRORUPDOWN       | \
                                     DDOVER_WAITNOTBUSY        | \
                                     DDOVER_WAITVSYNC          | \
                                     DDOVER_AUTOFLIP           | \
                                     DDOVER_BOB                | \
                                     DDOVER_OVERRIDEBOBWEAVE   | \
                                     DDOVER_INTERLEAVED        | \
                                     DDOVER_BOBHARDWARE)

/*
 * Flags for IDirectDrawSurface::Lock
 */

#define DDLOCK_READONLY             0x00000001
#define DDLOCK_WRITEONLY            0x00000002
#define DDLOCK_DISCARD              0x00000004
#define DDLOCK_WAITNOTBUSY          0x00000008
#define DDLOCK_UNLOCKSUBRECT        0x10000000

#define DDLOCK_VALID                (DDLOCK_READONLY    | \
                                     DDLOCK_WRITEONLY   | \
                                     DDLOCK_DISCARD     | \
                                     DDLOCK_WAITNOTBUSY | \
                                     DDLOCK_UNLOCKSUBRECT)

/*
 * Flags for IDirectDrawSurface::GetFlipStatus
 */

#define DDGFS_CANFLIP               0x00000001
#define DDGFS_ISFLIPDONE            0x00000002

#define DDGFS_VALID                 (DDGFS_CANFLIP | \
                                     DDGFS_ISFLIPDONE)


/*
 * Flags for IDirectDrawSurface::GetBltStatus
 */

#define DDGBS_CANBLT                0x00000001
#define DDGBS_ISBLTDONE             0x00000002

#define DDGBS_VALID                 (DDGBS_CANBLT | \
                                     DDGBS_ISBLTDONE)

/*
 * Flags for IDirectDrawSurface::EnumOverlayZOrders
 */

#define DDENUMOVERLAYZ_FRONTTOBACK  0x00000001

#define DDENUMOVERLAYZ_VALID        DDENUMOVERLAYZ_FRONTTOBACK

/*
 * Flags for IDirectDrawSurface::UpdateOverlayZOrder
 */

#define DDOVERZ_SENDTOFRONT         0x00000000
#define DDOVERZ_SENDTOBACK          0x00000001
#define DDOVERZ_MOVEFORWARD         0x00000002
#define DDOVERZ_MOVEBACKWARD        0x00000003
#define DDOVERZ_INSERTINFRONTOF     0x00000004
#define DDOVERZ_INSERTINBACKOF      0x00000005

/*
 * DirectDraw Return Codes
 */

/*
 * Enumeration function return values.
 */

#define DDENUMRET_CANCEL            ((HRESULT)(0))
#define DDENUMRET_OK                ((HRESULT)(1))

/*
 * DirectDraw error codes.
 */

#define _FACDD    0x876
#define MAKE_DDHRESULT( code )              MAKE_HRESULT( 1, _FACDD, code )

#define DD_OK                               NOERROR

#define DDERR_CURRENTLYNOTAVAIL             MAKE_DDHRESULT( 40 )
#define DDERR_GENERIC                       E_FAIL
#define DDERR_HEIGHTALIGN                   MAKE_DDHRESULT( 90 )
#define DDERR_INCOMPATIBLEPRIMARY           MAKE_DDHRESULT( 95 )
#define DDERR_INVALIDCAPS                   MAKE_DDHRESULT( 100 )
#define DDERR_INVALIDCLIPLIST               MAKE_DDHRESULT( 110 )
#define DDERR_INVALIDMODE                   MAKE_DDHRESULT( 120 )
#define DDERR_INVALIDOBJECT                 MAKE_DDHRESULT( 130 )
#define DDERR_INVALIDPARAMS                 E_INVALIDARG
#define DDERR_INVALIDPIXELFORMAT            MAKE_DDHRESULT( 145 )
#define DDERR_INVALIDRECT                   MAKE_DDHRESULT( 150 )
#define DDERR_LOCKEDSURFACES                MAKE_DDHRESULT( 160 )
#define DDERR_NOCLIPLIST                    MAKE_DDHRESULT( 205 )
#define DDERR_NOALPHAHW                     MAKE_DDHRESULT( 180 )
#define DDERR_NOCOLORCONVHW                 MAKE_DDHRESULT( 210 )
#define DDERR_NOCOOPERATIVELEVELSET         MAKE_DDHRESULT( 212 )
#define DDERR_NOCOLORKEYHW                  MAKE_DDHRESULT( 215 )
#define DDERR_NOFLIPHW                      MAKE_DDHRESULT( 230 )
#define DDERR_NOTFOUND                      MAKE_DDHRESULT( 255 )
#define DDERR_NOOVERLAYHW                   MAKE_DDHRESULT( 260 )
#define DDERR_OVERLAPPINGRECTS              MAKE_DDHRESULT( 270 )
#define DDERR_NORASTEROPHW                  MAKE_DDHRESULT( 280 )
#define DDERR_NOSTRETCHHW                   MAKE_DDHRESULT( 310 )
#define DDERR_NOVSYNCHW                     MAKE_DDHRESULT( 335 )
#define DDERR_NOZOVERLAYHW                  MAKE_DDHRESULT( 350 )
#define DDERR_OUTOFCAPS                     MAKE_DDHRESULT( 360 )
#define DDERR_OUTOFMEMORY                   E_OUTOFMEMORY
#define DDERR_OUTOFVIDEOMEMORY              MAKE_DDHRESULT( 380 )
#define DDERR_PALETTEBUSY                   MAKE_DDHRESULT( 387 )
#define DDERR_COLORKEYNOTSET                MAKE_DDHRESULT( 400 )
#define DDERR_SURFACEBUSY                   MAKE_DDHRESULT( 430 )
#define DDERR_CANTLOCKSURFACE               MAKE_DDHRESULT( 435 )
#define DDERR_SURFACELOST                   MAKE_DDHRESULT( 450 )
#define DDERR_SURFACENOTATTACHED            MAKE_DDHRESULT( 460 )
#define DDERR_TOOBIGHEIGHT                  MAKE_DDHRESULT( 470 )
#define DDERR_TOOBIGSIZE                    MAKE_DDHRESULT( 480 )
#define DDERR_TOOBIGWIDTH                   MAKE_DDHRESULT( 490 )
#define DDERR_UNSUPPORTED                   E_NOTIMPL
#define DDERR_UNSUPPORTEDFORMAT             MAKE_DDHRESULT( 536 )
#define DDERR_VERTICALBLANKINPROGRESS       MAKE_DDHRESULT( 537 )
#define DDERR_WASSTILLDRAWING               MAKE_DDHRESULT( 540 )
#define DDERR_INVALIDDIRECTDRAWGUID         MAKE_DDHRESULT( 561 )
#define DDERR_DIRECTDRAWALREADYCREATED      MAKE_DDHRESULT( 562 )
#define DDERR_PRIMARYSURFACEALREADYEXISTS   MAKE_DDHRESULT( 564 )
#define DDERR_REGIONTOOSMALL                MAKE_DDHRESULT( 566 )
#define DDERR_CLIPPERISUSINGHWND            MAKE_DDHRESULT( 567 )
#define DDERR_NOCLIPPERATTACHED             MAKE_DDHRESULT( 568 )
#define DDERR_NOPALETTEATTACHED             MAKE_DDHRESULT( 572 )
#define DDERR_NOPALETTEHW                   MAKE_DDHRESULT( 573 )
#define DDERR_NOBLTHW                       MAKE_DDHRESULT( 575 )
#define DDERR_OVERLAYNOTVISIBLE             MAKE_DDHRESULT( 577 )
#define DDERR_NOOVERLAYDEST                 MAKE_DDHRESULT( 578 )
#define DDERR_INVALIDPOSITION               MAKE_DDHRESULT( 579 )
#define DDERR_NOTAOVERLAYSURFACE            MAKE_DDHRESULT( 580 )
#define DDERR_EXCLUSIVEMODEALREADYSET       MAKE_DDHRESULT( 581 )
#define DDERR_NOTFLIPPABLE                  MAKE_DDHRESULT( 582 )
#define DDERR_NOTLOCKED                     MAKE_DDHRESULT( 584 )
#define DDERR_CANTCREATEDC                  MAKE_DDHRESULT( 585 )
#define DDERR_NODC                          MAKE_DDHRESULT( 586 )
#define DDERR_WRONGMODE                     MAKE_DDHRESULT( 587 )
#define DDERR_IMPLICITLYCREATED             MAKE_DDHRESULT( 588 )
#define DDERR_NOTPALETTIZED                 MAKE_DDHRESULT( 589 )
#define DDERR_DCALREADYCREATED              MAKE_DDHRESULT( 620 )
#define DDERR_MOREDATA                      MAKE_DDHRESULT( 690 )
#define DDERR_VIDEONOTACTIVE                MAKE_DDHRESULT( 695 )
#define DDERR_DEVICEDOESNTOWNSURFACE        MAKE_DDHRESULT( 699 )


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddrawguids.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __DDRAW_GUIDS__
#define __DDRAW_GUIDS__

#ifndef OUR_GUID_ENTRY
    #define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif


OUR_GUID_ENTRY(CLSID_DirectDraw,            0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35)
OUR_GUID_ENTRY(CLSID_DirectDrawClipper,     0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDraw,             0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDraw2,            0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56)
OUR_GUID_ENTRY(IID_IDirectDrawSurface,      0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawSurface2,     0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27)
OUR_GUID_ENTRY(IID_IDirectDrawSurface3,     0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB)
OUR_GUID_ENTRY(IID_IDirectDrawSurface4,     0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B)
OUR_GUID_ENTRY(IID_IDirectDrawSurface7,     0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b)
OUR_GUID_ENTRY(IID_IDirectDrawPalette,      0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawClipper,      0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60)
OUR_GUID_ENTRY(IID_IDirectDrawColorControl, 0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8)
OUR_GUID_ENTRY(IID_IDirectDrawGammaControl,    0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddmm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//  File:       ddmm.h
//  Content:    Routines for using DirectDraw on a multimonitor system
//--------------------------------------------------------------------------;

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEX)(LPDDENUMCALLBACKEX lpCallback, LPVOID lpContext, DWORD dwFlags);
typedef HRESULT (*PDRAWCREATE)(IID *,LPDIRECTDRAW *,LPUNKNOWN);
typedef HRESULT (*PDRAWENUM)(LPDDENUMCALLBACKEX, LPVOID);

IDirectDraw * DirectDrawCreateFromDevice(LPSTR, PDRAWCREATE, PDRAWENUM);
IDirectDraw * DirectDrawCreateFromDeviceEx(LPSTR, PDRAWCREATE, LPDIRECTDRAWENUMERATEEX);
INT_PTR DeviceFromWindow(HWND hwnd, LPSTR szDevice, RECT*prc);
HMONITOR OneMonitorFromWindow(HWND hwnd);

#ifdef __cplusplus
}
#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ddstream.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for ddstream.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ddstream_h__
#define __ddstream_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirectDrawMediaStream_FWD_DEFINED__
#define __IDirectDrawMediaStream_FWD_DEFINED__
typedef interface IDirectDrawMediaStream IDirectDrawMediaStream;
#endif 	/* __IDirectDrawMediaStream_FWD_DEFINED__ */


#ifndef __IDirectDrawStreamSample_FWD_DEFINED__
#define __IDirectDrawStreamSample_FWD_DEFINED__
typedef interface IDirectDrawStreamSample IDirectDrawStreamSample;
#endif 	/* __IDirectDrawStreamSample_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "mmstream.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ddstream_0000_0000 */
/* [local] */ 

//
//	The following declarations within the 'if 0' block are dummy typedefs used to make
//	the ddstream.idl file build.  The actual definitions are contained in DDRAW.H
//
#if 0
typedef void *LPDDSURFACEDESC;

typedef struct tDDSURFACEDESC DDSURFACEDESC;

#endif
#include <ddraw.h>

enum __MIDL___MIDL_itf_ddstream_0000_0000_0001
    {	DDSFF_PROGRESSIVERENDER	= 0x1
    } ;







extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ddstream_0000_0000_v0_0_s_ifspec;

#ifndef __IDirectDrawMediaStream_INTERFACE_DEFINED__
#define __IDirectDrawMediaStream_INTERFACE_DEFINED__

/* interface IDirectDrawMediaStream */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCE-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawMediaStream : public IMediaStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFormat( 
            /* [optional][out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [optional][out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [optional][out] */ DDSURFACEDESC *pDDSDDesired,
            /* [optional][out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFormat( 
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [optional][in] */ IDirectDrawPalette *pDirectDrawPalette) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out] */ IDirectDraw **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDirectDraw( 
            /* [in] */ IDirectDraw *pDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSample( 
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimePerFrame( 
            /* [out] */ STREAM_TIME *pFrameTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawMediaStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiMediaStream )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetInformation )( 
            IDirectDrawMediaStream * This,
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);
        
        HRESULT ( STDMETHODCALLTYPE *SetSameFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IMediaStream *pStreamThatHasDesiredFormat,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSharedSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);
        
        HRESULT ( STDMETHODCALLTYPE *SendEndOfStream )( 
            IDirectDrawMediaStream * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormat )( 
            IDirectDrawMediaStream * This,
            /* [optional][out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [optional][out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [optional][out] */ DDSURFACEDESC *pDDSDDesired,
            /* [optional][out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetFormat )( 
            IDirectDrawMediaStream * This,
            /* [in] */ const DDSURFACEDESC *pDDSurfaceDesc,
            /* [optional][in] */ IDirectDrawPalette *pDirectDrawPalette);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [out] */ IDirectDraw **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *SetDirectDraw )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDraw *pDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSample )( 
            IDirectDrawMediaStream * This,
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimePerFrame )( 
            IDirectDrawMediaStream * This,
            /* [out] */ STREAM_TIME *pFrameTime);
        
        END_INTERFACE
    } IDirectDrawMediaStreamVtbl;

    interface IDirectDrawMediaStream
    {
        CONST_VTBL struct IDirectDrawMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawMediaStream_GetMultiMediaStream(This,ppMultiMediaStream)	\
    ( (This)->lpVtbl -> GetMultiMediaStream(This,ppMultiMediaStream) ) 

#define IDirectDrawMediaStream_GetInformation(This,pPurposeId,pType)	\
    ( (This)->lpVtbl -> GetInformation(This,pPurposeId,pType) ) 

#define IDirectDrawMediaStream_SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags)	\
    ( (This)->lpVtbl -> SetSameFormat(This,pStreamThatHasDesiredFormat,dwFlags) ) 

#define IDirectDrawMediaStream_AllocateSample(This,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> AllocateSample(This,dwFlags,ppSample) ) 

#define IDirectDrawMediaStream_CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample)	\
    ( (This)->lpVtbl -> CreateSharedSample(This,pExistingSample,dwFlags,ppNewSample) ) 

#define IDirectDrawMediaStream_SendEndOfStream(This,dwFlags)	\
    ( (This)->lpVtbl -> SendEndOfStream(This,dwFlags) ) 


#define IDirectDrawMediaStream_GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags)	\
    ( (This)->lpVtbl -> GetFormat(This,pDDSDCurrent,ppDirectDrawPalette,pDDSDDesired,pdwFlags) ) 

#define IDirectDrawMediaStream_SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette)	\
    ( (This)->lpVtbl -> SetFormat(This,pDDSurfaceDesc,pDirectDrawPalette) ) 

#define IDirectDrawMediaStream_GetDirectDraw(This,ppDirectDraw)	\
    ( (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw) ) 

#define IDirectDrawMediaStream_SetDirectDraw(This,pDirectDraw)	\
    ( (This)->lpVtbl -> SetDirectDraw(This,pDirectDraw) ) 

#define IDirectDrawMediaStream_CreateSample(This,pSurface,pRect,dwFlags,ppSample)	\
    ( (This)->lpVtbl -> CreateSample(This,pSurface,pRect,dwFlags,ppSample) ) 

#define IDirectDrawMediaStream_GetTimePerFrame(This,pFrameTime)	\
    ( (This)->lpVtbl -> GetTimePerFrame(This,pFrameTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawMediaStream_INTERFACE_DEFINED__ */


#ifndef __IDirectDrawStreamSample_INTERFACE_DEFINED__
#define __IDirectDrawStreamSample_INTERFACE_DEFINED__

/* interface IDirectDrawStreamSample */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDirectDrawStreamSample;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4104FCF-9A70-11d0-8FDE-00C04FD9189D")
    IDirectDrawStreamSample : public IStreamSample
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [optional][out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [optional][out] */ RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ const RECT *pRect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirectDrawStreamSampleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirectDrawStreamSample * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirectDrawStreamSample * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirectDrawStreamSample * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaStream )( 
            IDirectDrawStreamSample * This,
            /* [in] */ IMediaStream **ppMediaStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);
        
        HRESULT ( STDMETHODCALLTYPE *SetSampleTimes )( 
            IDirectDrawStreamSample * This,
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);
        
        HRESULT ( STDMETHODCALLTYPE *Update )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD dwAPCData);
        
        HRESULT ( STDMETHODCALLTYPE *CompletionStatus )( 
            IDirectDrawStreamSample * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDirectDrawStreamSample * This,
            /* [optional][out] */ IDirectDrawSurface **ppDirectDrawSurface,
            /* [optional][out] */ RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetRect )( 
            IDirectDrawStreamSample * This,
            /* [in] */ const RECT *pRect);
        
        END_INTERFACE
    } IDirectDrawStreamSampleVtbl;

    interface IDirectDrawStreamSample
    {
        CONST_VTBL struct IDirectDrawStreamSampleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirectDrawStreamSample_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDirectDrawStreamSample_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDirectDrawStreamSample_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDirectDrawStreamSample_GetMediaStream(This,ppMediaStream)	\
    ( (This)->lpVtbl -> GetMediaStream(This,ppMediaStream) ) 

#define IDirectDrawStreamSample_GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime)	\
    ( (This)->lpVtbl -> GetSampleTimes(This,pStartTime,pEndTime,pCurrentTime) ) 

#define IDirectDrawStreamSample_SetSampleTimes(This,pStartTime,pEndTime)	\
    ( (This)->lpVtbl -> SetSampleTimes(This,pStartTime,pEndTime) ) 

#define IDirectDrawStreamSample_Update(This,dwFlags,hEvent,pfnAPC,dwAPCData)	\
    ( (This)->lpVtbl -> Update(This,dwFlags,hEvent,pfnAPC,dwAPCData) ) 

#define IDirectDrawStreamSample_CompletionStatus(This,dwFlags,dwMilliseconds)	\
    ( (This)->lpVtbl -> CompletionStatus(This,dwFlags,dwMilliseconds) ) 


#define IDirectDrawStreamSample_GetSurface(This,ppDirectDrawSurface,pRect)	\
    ( (This)->lpVtbl -> GetSurface(This,ppDirectDrawSurface,pRect) ) 

#define IDirectDrawStreamSample_SetRect(This,pRect)	\
    ( (This)->lpVtbl -> SetRect(This,pRect) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDirectDrawStreamSample_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\devpkey.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devpkey.h

Abstract:

    Defines property keys for the Plug and Play Device Property API.

Environment:

    User and Kernel modes.


--*/

#pragma once

#include <devpropdef.h>

//
// DEVPKEY_NAME
// Common DEVPKEY used to retrieve the display name for an object.
//
DEFINE_DEVPROPKEY(DEVPKEY_NAME,                          0xb725f130, 0x47ef, 0x101a, 0xa5, 0xf1, 0x02, 0x60, 0x8c, 0x9e, 0xeb, 0xac, 10);    // DEVPROP_TYPE_STRING


//
// Device properties
// These DEVPKEYs correspond to the SetupAPI SPDRP_XXX device properties.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DeviceDesc,             0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_HardwareIds,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 3);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_CompatibleIds,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 4);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Service,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 6);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Class,                  0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 9);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ClassGuid,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 10);    // DEVPROP_TYPE_GUID
DEFINE_DEVPROPKEY(DEVPKEY_Device_Driver,                 0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 11);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ConfigFlags,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 12);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Manufacturer,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 13);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_FriendlyName,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 14);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_LocationInfo,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 15);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_PDOName,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 16);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Capabilities,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 17);    // DEVPROP_TYPE_UNINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_UINumber,               0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 18);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_UpperFilters,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 19);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_LowerFilters,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 20);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusTypeGuid,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 21);    // DEVPROP_TYPE_GUID
DEFINE_DEVPROPKEY(DEVPKEY_Device_LegacyBusType,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 22);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusNumber,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 23);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_EnumeratorName,         0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 24);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Security,               0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 25);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR
DEFINE_DEVPROPKEY(DEVPKEY_Device_SecuritySDS,            0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 26);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DevType,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 27);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Exclusive,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 28);    // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_Characteristics,        0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 29);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_Address,                0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 30);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_UINumberDescFormat,     0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 31);    // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_PowerData,              0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 32);    // DEVPROP_TYPE_BINARY
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicy,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 33);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicyDefault,   0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 34);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalPolicyOverride,  0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 35);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_InstallState,           0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 36);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_LocationPaths,          0xa45c254e, 0xdf1c, 0x4efd, 0x80, 0x20, 0x67, 0xd1, 0x46, 0xa8, 0x50, 0xe0, 37);    // DEVPROP_TYPE_STRING_LIST

//
// Device properties
// These DEVPKEYs correspond to a device's status and problem code.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DevNodeStatus,          0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 2);     // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_ProblemCode,            0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 3);     // DEVPROP_TYPE_UINT32

//
// Device properties
// These DEVPKEYs correspond to a device's relations.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_EjectionRelations,      0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 4);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_RemovalRelations,       0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 5);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_PowerRelations,         0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 6);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_BusRelations,           0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 7);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Parent,                 0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 8);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_Children,               0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 9);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_Siblings,               0x4340a6c5, 0x93fa, 0x4706, 0x97, 0x2c, 0x7b, 0x64, 0x80, 0x08, 0xa5, 0xa7, 10);    // DEVPROP_TYPE_STRING_LIST

//
// Other Device properties
// These DEVPKEYs are set for the corresponding types of root-enumerated devices.     ;comment
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_Reported,               0x80497100, 0x8c73, 0x48b9, 0xaa, 0xd9, 0xce, 0x38, 0x7e, 0x19, 0xc5, 0x6e, 2);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_Legacy,                 0x80497100, 0x8c73, 0x48b9, 0xaa, 0xd9, 0xce, 0x38, 0x7e, 0x19, 0xc5, 0x6e, 3);     // DEVPROP_TYPE_BOOLEAN

//
// Device Instance Id
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_InstanceId,             0x78c34fc8, 0x104a, 0x4aca, 0x9e, 0xa4, 0x52, 0x4d, 0x52, 0x99, 0x6e, 0x57, 256);   // DEVPROP_TYPE_STRING

//
// Other Device properties
//
DEFINE_DEVPROPKEY(DEVPKEY_Numa_Proximity_Domain,         0x540b947e, 0x8b40, 0x45bc, 0xa8, 0xa2, 0x6a, 0x0b, 0x89, 0x4c, 0xbd, 0xa2, 1);     // DEVPROP_TYPE_UINT32

//
// Device Session Id
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_SessionId,              0x83da6326, 0x97a6, 0x4088, 0x94, 0x53, 0xa1, 0x92, 0x3f, 0x57, 0x3b, 0x29, 6);     // DEVPROP_TYPE_UINT32

//
// Device driver properties
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverDate,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 2);      // DEVPROP_TYPE_FILETIME
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverVersion,          0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 3);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverDesc,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 4);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfPath,          0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 5);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfSection,       0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 6);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverInfSectionExt,    0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 7);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_MatchingDeviceId,       0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 8);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverProvider,         0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 9);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverPropPageProvider, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 10);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverCoInstallers,     0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 11);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_Device_ResourcePickerTags,     0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 12);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_ResourcePickerExceptions, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 13);   // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverRank,             0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 14);     // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_Device_DriverLogoLevel,        0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 15);     // DEVPROP_TYPE_UINT32

//
// Device properties
// These DEVPKEYs may be set by the driver package installed for a device.
//
DEFINE_DEVPROPKEY(DEVPKEY_Device_NoConnectSound,         0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 17);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_Device_GenericDriverInstalled, 0xa8b865dd, 0x2e3d, 0x4094, 0xad, 0x97, 0xe5, 0x93, 0xa7, 0xc, 0x75, 0xd6, 18);     // DEVPROP_TYPE_BOOLEAN

//
// Device properties
// These DEVPKEYs may be set by the driver package installed for a device.
//
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_Model,                  0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_VendorWebSite,          0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 3);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_DetailedDescription,    0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 4);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_DocumentationLink,      0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 5);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_Icon,                   0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 6);     // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DrvPkg_BrandingIcon,           0xcf73bb51, 0x3abf, 0x44a2, 0x85, 0xe0, 0x9a, 0x3d, 0xc7, 0xa1, 0x21, 0x32, 7);     // DEVPROP_TYPE_STRING_LIST


//
// Device setup class properties
// These DEVPKEYs correspond to the SetupAPI SPCRP_XXX setup class properties.
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_UpperFilters,      0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 19);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_LowerFilters,      0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 20);    // DEVPROP_TYPE_STRING_LIST
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Security,          0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 25);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_SecuritySDS,       0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 26);    // DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_DevType,           0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 27);    // DEVPROP_TYPE_UINT32
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Exclusive,         0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 28);    // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Characteristics,   0x4321918b, 0xf69e, 0x470d, 0xa5, 0xde, 0x4d, 0x88, 0xc7, 0x5a, 0xd2, 0x4b, 29);    // DEVPROP_TYPE_UINT32

//
// Device setup class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Name,              0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 2);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassName,         0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 3);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_Icon,              0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 4);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassInstaller,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 5);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_PropPageProvider,  0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 6);      // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoInstallClass,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 7);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoDisplayClass,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 8);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_SilentInstall,     0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 9);      // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_NoUseClass,        0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 10);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_DefaultService,    0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 11);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_IconPath,          0x259abffc, 0x50a7, 0x47ce, 0xaf, 0x8, 0x68, 0xc9, 0xa7, 0xd7, 0x33, 0x66, 12);     // DEVPROP_TYPE_STRING_LIST

//
// Other Device setup class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceClass_ClassCoInstallers, 0x713d1703, 0xa2e2, 0x49f5, 0x92, 0x14, 0x56, 0x47, 0x2e, 0xf3, 0xda, 0x5c, 2);     // DEVPROP_TYPE_STRING_LIST


//
// Device interface properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_FriendlyName,  0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 2);     // DEVPROP_TYPE_STRING
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_Enabled,       0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 3);     // DEVPROP_TYPE_BOOLEAN
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterface_ClassGuid,     0x026e516e, 0xb814, 0x414b, 0x83, 0xcd, 0x85, 0x6d, 0x6f, 0xef, 0x48, 0x22, 4);     // DEVPROP_TYPE_GUID


//
// Device interface class properties
//
DEFINE_DEVPROPKEY(DEVPKEY_DeviceInterfaceClass_DefaultInterface,  0x14c83a99, 0x0b3f, 0x44b7, 0xbe, 0x4c, 0xa1, 0x78, 0xd3, 0x99, 0x05, 0x64, 2); // DEVPROP_TYPE_STRING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\devpropdef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devpropdef.h

Abstract:

    Defines property types and keys for the Plug and Play Device Property API.

Environment:

    User and Kernel modes.

--*/

#pragma once

#ifndef _DEVPROPDEF_H_
#define _DEVPROPDEF_H_

#ifdef UNDER_CE
#include <guiddef.h> // For DECLSPEC_SELECTANY
#endif

//
// Type definition for property data types.  Valid DEVPROPTYPE values are
// constructed from base DEVPROP_TYPE_ values, which may be modified by a
// logical OR with DEVPROP_TYPEMOD_ values, as appropriate.
//
typedef ULONG DEVPROPTYPE, *PDEVPROPTYPE;

//
// Property type modifiers.  Used to modify base DEVPROP_TYPE_ values, as
// appropriate.  Not valid as standalone DEVPROPTYPE values.
//
#define DEVPROP_TYPEMOD_ARRAY                   0x00001000  // array of fixed-sized data elements
#define DEVPROP_TYPEMOD_LIST                    0x00002000  // list of variable-sized data elements

//
// Property data types.
//
#define DEVPROP_TYPE_EMPTY                      0x00000000  // nothing, no property data
#define DEVPROP_TYPE_NULL                       0x00000001  // null property data
#define DEVPROP_TYPE_SBYTE                      0x00000002  // 8-bit signed int (SBYTE)
#define DEVPROP_TYPE_BYTE                       0x00000003  // 8-bit unsigned int (BYTE)
#define DEVPROP_TYPE_INT16                      0x00000004  // 16-bit signed int (SHORT)
#define DEVPROP_TYPE_UINT16                     0x00000005  // 16-bit unsigned int (USHORT)
#define DEVPROP_TYPE_INT32                      0x00000006  // 32-bit signed int (LONG)
#define DEVPROP_TYPE_UINT32                     0x00000007  // 32-bit unsigned int (ULONG)
#define DEVPROP_TYPE_INT64                      0x00000008  // 64-bit signed int (LONG64)
#define DEVPROP_TYPE_UINT64                     0x00000009  // 64-bit unsigned int (ULONG64)
#define DEVPROP_TYPE_FLOAT                      0x0000000A  // 32-bit floating-point (FLOAT)
#define DEVPROP_TYPE_DOUBLE                     0x0000000B  // 64-bit floating-point (DOUBLE)
#define DEVPROP_TYPE_DECIMAL                    0x0000000C  // 128-bit data (DECIMAL)
#define DEVPROP_TYPE_GUID                       0x0000000D  // 128-bit unique identifier (GUID)
#define DEVPROP_TYPE_CURRENCY                   0x0000000E  // 64 bit signed int currency value (CURRENCY)
#define DEVPROP_TYPE_DATE                       0x0000000F  // date (DATE)
#define DEVPROP_TYPE_FILETIME                   0x00000010  // file time (FILETIME)
#define DEVPROP_TYPE_BOOLEAN                    0x00000011  // 8-bit boolean (DEVPROP_BOOLEAN)
#define DEVPROP_TYPE_STRING                     0x00000012  // null-terminated string
#define DEVPROP_TYPE_STRING_LIST (DEVPROP_TYPE_STRING|DEVPROP_TYPEMOD_LIST) // multi-sz string list
#define DEVPROP_TYPE_SECURITY_DESCRIPTOR        0x00000013  // self-relative binary SECURITY_DESCRIPTOR
#define DEVPROP_TYPE_SECURITY_DESCRIPTOR_STRING 0x00000014  // security descriptor string (SDDL format)
#define DEVPROP_TYPE_DEVPROPKEY                 0x00000015  // device property key (DEVPROPKEY)
#define DEVPROP_TYPE_DEVPROPTYPE                0x00000016  // device property type (DEVPROPTYPE)
#define DEVPROP_TYPE_BINARY      (DEVPROP_TYPE_BYTE|DEVPROP_TYPEMOD_ARRAY)  // custom binary data
#define DEVPROP_TYPE_ERROR                      0x00000017  // 32-bit Win32 system error code
#define DEVPROP_TYPE_NTSTATUS                   0x00000018  // 32-bit NTSTATUS code
#define DEVPROP_TYPE_STRING_INDIRECT            0x00000019  // string resource (@[path\]<dllname>,-<strId>)

//
// Max base DEVPROP_TYPE_ and DEVPROP_TYPEMOD_ values.
//
#define MAX_DEVPROP_TYPE                        0x00000019  // max valid DEVPROP_TYPE_ value
#define MAX_DEVPROP_TYPEMOD                     0x00002000  // max valid DEVPROP_TYPEMOD_ value

//
// Bitmasks for extracting DEVPROP_TYPE_ and DEVPROP_TYPEMOD_ values.
//
#define DEVPROP_MASK_TYPE                       0x00000FFF  // range for base DEVPROP_TYPE_ values
#define DEVPROP_MASK_TYPEMOD                    0x0000F000  // mask for DEVPROP_TYPEMOD_ type modifiers


//
// Property type specific data types.
//

// 8-bit boolean type definition for DEVPROP_TYPE_BOOLEAN (True=-1, False=0)
typedef CHAR DEVPROP_BOOLEAN, *PDEVPROP_BOOLEAN;
#define DEVPROP_TRUE  ((DEVPROP_BOOLEAN)-1)
#define DEVPROP_FALSE ((DEVPROP_BOOLEAN) 0)


//
// DEVPROPKEY structure
//

#ifndef DEVPROPKEY_DEFINED
#define DEVPROPKEY_DEFINED

typedef GUID  DEVPROPGUID, *PDEVPROPGUID;
typedef ULONG DEVPROPID,   *PDEVPROPID;

typedef struct _DEVPROPKEY {
    DEVPROPGUID fmtid;
    DEVPROPID   pid;
} DEVPROPKEY, *PDEVPROPKEY;

#endif // DEVPROPKEY_DEFINED

//
// All valid DEVPROPKEY definitions must use a PROPID that is equal to or greater
// than DEVPROPID_FIRST_USABLE.
//
#define DEVPROPID_FIRST_USABLE 2

#endif // _DEVPROPDEF_H_


#ifdef DEFINE_DEVPROPKEY
#undef DEFINE_DEVPROPKEY
#endif
#ifdef INITGUID
#define DEFINE_DEVPROPKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const DEVPROPKEY DECLSPEC_SELECTANY name = { { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }, pid }
#else
#define DEFINE_DEVPROPKEY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8, pid) EXTERN_C const DEVPROPKEY name
#endif // INITGUID


#ifndef IsEqualDevPropKey
#ifdef __cplusplus
#define IsEqualDevPropKey(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid) )
#else // !__cplusplus
#define IsEqualDevPropKey(a, b)   (((a).pid == (b).pid) && IsEqualIID(&(a).fmtid, &(b).fmtid) )
#endif // __cplusplus
#endif // !IsEqualDevPropKey
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\devload.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  

devload.h

Abstract:

Device loader structures and defines

Notes: 


--*/

#ifndef __DEVLOAD_H_
#define __DEVLOAD_H_

#ifdef __cplusplus
extern "C" {
#endif

// @doc DRIVERS

//
// These keys are under HKEY_LOCAL_MACHINE
//
#define DEVLOAD_DRIVERS_KEY  TEXT("Drivers")
#define DEVLOAD_BUILT_IN_KEY TEXT("Drivers\\BuiltIn")
#define DEVLOAD_PCMCIA_KEY   TEXT("Drivers\\PCMCIA")
#define DEVLOAD_ACTIVE_KEY   TEXT("Drivers\\Active")
#define DEVLOAD_ICLASS_KEY   TEXT("Drivers\\IClass")
#define DEVLOAD_DISABLED_ICLASS_KEY TEXT("Drivers\\DisabledIClass")
#define DEVLOAD_OLDACCESS_EXCEPTION_KEY TEXT("Drivers\\OldAccessException")
#define DEVLOAD_DETECT_KEY   DEVLOAD_PCMCIA_KEY TEXT("\\Detect")

//
// These are the required and optional values under a device key.
//
#define DEVLOAD_DLLNAME_VALNAME     TEXT("Dll")     // DLL name (required)
#define DEVLOAD_DLLNAME_VALTYPE     REG_SZ
#define DEVLOAD_ICLASS_VALNAME      TEXT("IClass")  // Class(es) of device interface (semi-required)
#define DEVLOAD_ICLASS_VALTYPE      REG_MULTI_SZ
#define DEVLOAD_LOADORDER_VALNAME   TEXT("Order")   // LoadOrder (optional)
#define DEVLOAD_LOADORDER_VALTYPE   REG_DWORD
#define DEVLOAD_ENTRYPOINT_VALNAME  TEXT("Entry")   // Entrypoint name (deprecated)
#define DEVLOAD_ENTRYPOINT_VALTYPE  REG_SZ
#define DEVLOAD_PREFIX_VALNAME      TEXT("Prefix")  // Device prefix (optional)
#define DEVLOAD_PREFIX_VALTYPE      REG_SZ
#define DEVLOAD_INDEX_VALNAME       TEXT("Index")   // Device index (optional)
#define DEVLOAD_INDEX_VALTYPE       REG_DWORD
#define DEVLOAD_CONTEXT_VALNAME     TEXT("Context") // Device context (optional)
#define DEVLOAD_CONTEXT_VALTYPE     REG_DWORD
#define DEVLOAD_INITCODE_VALNAME    TEXT("Ioctl")   // Device IO control code to indicate context (deprecated)
#define DEVLOAD_INITCODE_VALTYPE    REG_DWORD
#define DEVLOAD_BUSINITCODE_VALNAME TEXT("BusIoctl")   // Bus IO control code to indicate context
#define DEVLOAD_BUSINITCODE_VALTYPE REG_DWORD
#define DEVLOAD_FLAGS_VALNAME       TEXT("Flags")   // Flag to control loading/unloading (optional)
#define DEVLOAD_FLAGS_VALTYPE       REG_DWORD
#define DEVLOAD_INTRPEND_VALNAME    TEXT("NoIntrPend") // Is the interrupt pending flag invalid (optional)
#define DEVLOAD_INTRPEND_VALTYPE    REG_DWORD
#define DEVLOAD_REPARMS_VALNAME     TEXT("RegenumParms") // Regenum parms passed into Active\xx
#define DEVLOAD_REPARMS_VALTYPE     REG_MULTI_SZ
#define DEVLOAD_FILTER_VALNAME      TEXT("Filter")
#define DEVLOAD_FILTER_VALTYPE      REG_MULTI_SZ

#define DEVLOAD_MEMBASE_VALNAME     TEXT("MemBase") // Memory base (optional)
#define DEVLOAD_MEMLEN_VALNAME      TEXT("MemLen")  // Memory length (optional)
#define DEVLOAD_IOBASE_VALNAME      TEXT("IoBase")  // IO base (optional)
#define DEVLOAD_IOLEN_VALNAME       TEXT("IoLen")   // IO length (optional)
#define DEVLOAD_SYSINTR_VALNAME     TEXT("SysIntr") // System interrupt number (optional)
#define DEVLOAD_IRQ_VALNAME         TEXT("Irq")     // Irq number (optional)
#define DEVLOAD_IFCTYPE_VALNAME     TEXT("InterfaceType")   // Bus interface type (i.e. PCIbus, ISA, etc) (optional)
#define DEVLOAD_BUSNUMBER_VALNAME   TEXT("BusNumber")       // Bus number (relevant for PCIbus) (optional)
#define DEVLOAD_ISRDLL_VALNAME      TEXT("IsrDll")  // DLL name of ISR (optional)
#define DEVLOAD_ISRHANDLER_VALNAME  TEXT("IsrHandler")      // ISR handler function name (optional)
// User Mode Driver Registry
#define DEVLOAD_USERPROCGROUP_VALNAME   TEXT("UserProcGroup")
#define DEVLOAD_USERPROCGROUP_VALTYPE   REG_DWORD
#define DEVLOAD_USERACCOUNTSID_VALNAME  TEXT("AccountSid")
#define DEVLOAD_USERACCOUNTSID_VALTYPE  REG_SZ

//
// The presence of the value "Keep" will cause device.exe to skip the call to
// FreeLibrary after calling the specified entrypoint.  This only affects
// builtin drivers that specify an entrypoint. (This usage is deprecated -
// make appropriate use of the UNLOAD flag instead).
//
#define DEVLOAD_KEEPLIB_VALNAME      TEXT("Keep")   // (deprecated - see above)
#define DEVLOAD_KEEPLIB_VALTYPE      REG_DWORD

//
// Flag values.
//
#define DEVFLAGS_NONE           0x00000000      // No flags defined
#define DEVFLAGS_UNLOAD         0x00000001      // Unload driver after call to entry point returns
#define DEVFLAGS_LOADLIBRARY    0x00000002      // Use LoadLibrary instead of LoadDriver
#define DEVFLAGS_NOLOAD         0x00000004      // Don't load Dll
#define DEVFLAGS_NAKEDENTRIES   0x00000008      // Entry points don't have Prefix prepended
#define DEVFLAGS_LOAD_AS_USERPROC 0x00000010    // Driver loaded to user mode processor
#define DEVFLAGS_NOUNLOAD       0x00000020      // Do not unload this driver in DeativateDevice
#define DEVFLAGS_SAME_AS_CALLER 0x00000040      // Driver loaded to same proc as caller.(only used by bus driver).
#define DEVFLAGS_BOOTPHASE_1    0x00001000      // This driver only load at system phase 1 
#define DEVFLAGS_IRQ_EXCLUSIVE  0x00000100      // This driver only can be load when it has exclusive access for IRQ.
#define DEVFLAGS_TRUSTEDCALLERONLY  0x00010000  // This driver only can be opened by trusted application.
#define DEVFLAGS_LOADDISABLED   0x00020000      // this driver no enable during the load
#define DEVFLAGS_LOADINOWNGROUP 0x00040000      // Load this into a new/seperate ProcGroup

//
// Structure passed in the input buffer of DeviceIoControl() for the 
// post initialization ioctl
//
typedef struct _POST_INIT_BUF {
    HANDLE p_hDevice;        // device handle from RegisterDevice
    HKEY   p_hDeviceKey;     // open registry handle to the driver's device key
} POST_INIT_BUF, *PPOST_INIT_BUF;


// 
// For passing additional registry settings to ActivateDeviceEx()
//
typedef struct _REGINI {
    LPCWSTR lpszVal;
    LPBYTE pData;
    DWORD dwLen;
    DWORD dwType;
} REGINI;
typedef struct _REGINI const *LPCREGINI;

//
// These values reside under a device's active key
//
#define DEVLOAD_CLIENTINFO_VALNAME  TEXT("ClientInfo") // ClientInfo DWORD from ActivateDriver
#define DEVLOAD_CLIENTINFO_VALTYPE  REG_DWORD
#define DEVLOAD_HANDLE_VALNAME      TEXT("Hnd")     // Device handle (from RegisterDevice)
#define DEVLOAD_HANDLE_VALTYPE      REG_DWORD
#define DEVLOAD_DEVNAME_VALNAME     TEXT("Name")    // Device name (i.e "COM1:")
#define DEVLOAD_DEVNAME_VALTYPE     REG_SZ
#define DEVLOAD_DEVKEY_VALNAME      TEXT("Key")     // Device key in \Drivers\(Built-In or PCMCIA)
#define DEVLOAD_DEVKEY_VALTYPE      REG_SZ
#define DEVLOAD_PNPID_VALNAME       TEXT("PnpId")   // Plug and Play Id (PCMCIA, optional)
#define DEVLOAD_PNPID_VALTYPE       REG_SZ
#define DEVLOAD_SOCKET_VALNAME      TEXT("Sckt")    // PCMCIA socket (optional)
#define DEVLOAD_SOCKET_VALTYPE      REG_DWORD       // Actually a CARD_SOCKET_HANDLE   
#define DEVLOAD_INTERFACETYPE_VALNAME TEXT("InterfaceType")  // Bus Type
#define DEVLOAD_INTERFACETYPE_VALTYPE  REG_DWORD 
#define DEVLOAD_UDRIVER_REF_HANDLE_VALNAME   TEXT("ReflectorHandle") // User Mode Driver kernel Access Key. It is optional
#define DEVLOAD_UDRIVER_REF_HANDLE_VALTYPE   REG_DWORD
//
// These values reside under a device's active key.  They are provided by the device's bus
// driver.  All values are optional.  The BusParent tells the Device Manager which device
// driver loaded the new driver.  The BusPrefix is used to specify DLL entry point decoration
// for devices that do not expose a stream interface to applications (via the legacy or $device
// namespaces).  If a Prefix value is specified in the device's device key and a BusPrefix value
// is specified, they must match.  The BusName provides the Device Manager with the name that the
// device driver will expose in the $bus namespace.  This name must be unique and is completely
// specified by the bus driver; it is not decorated with an instance index; if a duplicate name 
// is found, the driver will not load.
//
#define DEVLOAD_BUSPARENT_VALNAME   TEXT("BusParent")   // parent bus driver handle
#define DEVLOAD_BUSPARENT_VALTYPE   REG_DWORD
#define DEVLOAD_BUSPREFIX_VALNAME   TEXT("BusPrefix")   // DLL entry point decoration -- must match "Prefix" if present in device key
#define DEVLOAD_BUSPREFIX_VALTYPE   REG_SZ
#define DEVLOAD_BUSNAME_VALNAME     TEXT("BusName")     // device's name on the parent bus
#define DEVLOAD_BUSNAME_VALTYPE     REG_SZ

//
// TAPI Pnp support
//
#define DEVLOAD_TSPDLL_VALNAME      TEXT("Tsp")     // TAPI Service Provider DLL
#define DEVLOAD_TSPDLL_VALTYPE      REG_SZ
#define DEVLOAD_TSPDEV_VALNAME      TEXT("THnd")    // TAPI device index
#define DEVLOAD_TSPDEV_VALTYPE      REG_DWORD

//
// Prototype for the optional device driver entrypoint
//
typedef DWORD (*PFN_DEV_ENTRY)(LPTSTR);     // Parameter is registry path of device's key

#define DEVKEY_LEN      256  // Max length of registry key path name
#define DEVNAME_LEN     16  // Max length of device name
#define DEVDLL_LEN      64  // Max length of device driver DLL name
#define DEVENTRY_LEN    64  // Max length of device driver entrypoint name
#define DEVPREFIX_LEN    8  // Max length of device prefix

//
// Device APIs: EnumPnpIds, EnumDevices, GetDeviceKeys and OpenDeviceKey
// (in coredll.dll)
//
DWORD EnumPnpIds(LPTSTR PnpList, LPDWORD lpBuflen);
DWORD EnumDevices(LPTSTR DevList, LPDWORD lpBuflen);
DWORD GetDeviceKeys(LPCTSTR DevName, LPTSTR ActiveKey, LPDWORD lpActiveLen,
                                     LPTSTR DriverKey, LPDWORD lpDriverLen);
HKEY OpenDeviceKey(LPCTSTR ActiveKey);
HANDLE GetDeviceHandleFromContext(LPCTSTR pContext);

//
// Device Manager APIs located in devmgr.dll.  These APIs are only available to drivers
// loaded in the Device Manager's process context.
//
DWORD WINAPI DmAdvertiseInterface(HANDLE hDevice, const GUID *devclass, LPCWSTR name, BOOL fAdd);

//
// This interface GUID indicates that the device supports differentiating the $bus and $device
// (and legacy) namespaces.  Devices must advertise this GUID via IClass or calls to 
// DmAdvertiseInterface() before CreateFile() requests on their $bus names will succeed.  The GUID
// must be associated with their bus name, not their $device or legacy name.
//
#define DMCLASS_PROTECTEDBUSNAMESPACE   TEXT("{6F40791D-300E-44E4-BC38-E0E63CA8375C}")

//
// Drivers that advertise DMCLASS_PROTECTEDBUSNAMESPACE will have this bit set in the dwAccess
// parameter to their XXX_Open() entry point when a handle is opened using the $bus namespace.
// This allows them to know which handles are allowed to carry out privileged operations.  If they
// advertise DMCLASS_PROTECTEDBUSNAMESPACE, they are required to block privileged operations on
// handles opened in the $device or legacy namespaces.
//
#define DEVACCESS_BUSNAMESPACE          FILE_WRITE_ATTRIBUTES

// Value under DEVLOAD_OLDACCESS_EXCEPTION_KEY 
#define DEVLOAD_EXCEPTION_FLAGS_VALNAME       TEXT("ExceptionFlags")   // missing access code in old app.(optional)
#define DEVLOAD_EXCEPTION_FLAGS_VALTYPE       REG_DWORD

typedef enum _NameSpaceType_tag {
    NtLegacy, 
    NtDevice, 
    NtBus,
    NtIClass
} NameSpaceType;

#define DeviceManagerPrefixString TEXT("/DEVICEMANAGER")
#define NtDeviceString TEXT("DEVICE")
#define NtBusString TEXT("BUS")
#define NtIClassString TEXT("ICLASS")

#define SID_UDEVICE_STANDARD_STR      (L"SID_UDEVICE_STANDARD")
#define SID_UDEVICE_ELEVATED_STR      (L"SID_UDEVICE_ELEVATED")
#define SID_UDEVICE_TCB_STR           (L"SID_UDEVICE_TCB")

#define DEVLOAD_ICLASS_IOCTL     TEXT("IoCtl")
#define DEVLOAD_ICLASS_IOCTLMASK TEXT("IoCtlMask")

// by default launch udevice.exe in elevated chamber
#define UD_DEFAULT_ACCOUNTSID SID_UDEVICE_ELEVATED

//
// GUID to the device driver filter servicesFilter.dll, which implements servicesd.exe specific networking logic
//
#define SERVICES_DRIVER_FILTER_GUID         TEXT("{299A39FC-4CF2-4c18-9A17-2F097601DF33}")


#ifdef __cplusplus
}
#endif

#endif //__DEVLOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\devmgmt.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:devmgmt.h

Purpose:Public Header for Device Management API

--*/

#ifndef _DEVMGMT_H_
#define _DEVMGMT_H_

// task type bits
//---------------------------------------------------------------------------
// four task types
#define DMSTASK_POLL             0x00000001
#define DMSTASK_DOWNLOAD         0x00000002
#define DMSTASK_REPORT           0x00000004
#define DMSTASK_TYPE_MASK        (DMSTASK_POLL | DMSTASK_DOWNLOAD | DMSTASK_REPORT)                              

// source of the data
#define DMSTASK_SRC_FILE         0x00010000
#define DMSTASK_SRC_BUFFER       0x00020000 // point a null terminated LPTSTR
#define DMSTASK_SRC_MASK         (DMSTASK_SRC_FILE | DMSTASK_SRC_BUFFER)         

// the task is scheduled to launch immediately
#define DMSTASK_IMMEDIATE        0x10000000
//---------------------------------------------------------------------------

// task flag bits
//---------------------------------------------------------------------------
// For the nonce, a "fast network" runs at >= 1Mb/sec
#define ADL_FAST_NETWORK_SPEED 1000000

// This operation can be performed over a slow connection
#define ADL_SLOW_NETWORK 0x0001

// This operation can be performed over a fast network
#define ADL_FAST_NETWORK 0x0002

// There's some means other than desktop passthrough through
// which this operation could be performed
#define ADL_NONPASSTHROUGH_ALLOWED (ADL_FAST_NETWORK | ADL_SLOW_NETWORK)

// This operation can be performed over desktop passthrough
#define ADL_PASSTHROUGH 0x0004

// This operation can ONLY be performed over desktop passthrough
#define ADL_PASSTHROUGH_ONLY 0x0008

// This operation is performed repeatedly
#define ADL_RECURRENT           0x80000000

// This bit set means the package is downloaded once, but executed recurrently
#define ADL_RECUR_EXEC_ONLY     0x20000000

// Inventory Report task type
#define ADL_REPORT_SOFTWARE     0x00010000
#define ADL_REPORT_FILECOLLECT  0x00020000
#define ADL_REPORT_HARDWARE     0x00040000
#define ADL_REPORT_INVENTORY    0x00070000  // any of the above three

// This bit set means no source files at this package, so execute the post command line only
#define ADL_NOSOURCEFILES       0x00100000
//---------------------------------------------------------------------------


// package record state
//---------------------------------------------------------------------------
// < package type >
#define PACKAGE_OPTIONAL        0x00010000
#define PACKAGE_MANDATORY       0x00020000

// < download state >
// download task launched
#define PACKAGE_DL_PENDING      0x00000010

// download failed
#define PACKAGE_DL_FAIL         0x00000020 

// after a package is stored
#define PACKAGE_DL_SUCCESS      0x00000040 

#define PACKAGE_DL_STATES       (PACKAGE_DL_PENDING | PACKAGE_DL_FAIL | PACKAGE_DL_SUCCESS)


#define PACKAGE_ALL             0x00030070 // bit or of all the above

// the entry is empty
#define PACKAGE_NULL            0x00000000 // must be zero


// used in Poll response processing (internal, not be used in db)
#define PACKAGE_TO_REQUEST      0x10000000



// CeGetDevMgmtPackageList filter flags
// --------------------------------------------------------------------------
// Have CeGetDevMgmtPackageList retrieve a record with a package id
#define PACKAGE_SRCH_BY_ID       0x10000000

// Get package id and state only
#define PACKAGE_GET_ID_ONLY      0x20000000



//---------------------------------------------------------------------------


// flags value used by CeSetDevMgmtPackageList
//---------------------------------------------------------------------------
#define PACKAGE_WRITE		    0x01	// overwrite or append a record (default)
#define	PACKAGE_DELETE		    0x02	// delete the record found

//---------------------------------------------------------------------------

// if a caller wants to overwrite the text field it must specify explicitly
#define PACKAGE_WRITE_STORTEXT  0x1000
#define PACKAGE_WRITE_LONGTEXT  0x2000
#define PACKAGE_WRITE_APPNAME   0x4000
#define PACKAGE_WRITE_SIZE      0x8000
#define PACKAGE_WRITE_DLINFO    0x0100
#define PACKAGE_WR_STATE_OVR    0x0200
#define PACKAGE_WR_STATE_ADD    0x0400    // set a state bit 
#define PACKAGE_WR_STATE_DEL    0x0800    // clear a state big

#define PACKAGE_WRITE_ALL   (PACKAGE_WRITE | PACKAGE_WRITE_DLINFO | \
                             PACKAGE_WRITE_STORTEXT | PACKAGE_WRITE_LONGTEXT | \
                             PACKAGE_WRITE_APPNAME | PACKAGE_WRITE_SIZE | PACKAGE_WR_STATE_OVR)

// Action types of CeStartDevMgmtService
#define DEVMGMT_SVC_STOP        0
#define DEVMGMT_SVC_START       1
#define DEVMGMT_SVC_GETSTATUS   2       // detect whether the service is running
#define DEVMGMT_SVC_REGWND      3
#define DEVMGMT_SVC_UNREGWND    4

#define PACKAGE_APPNAME_TEXT_LEN    128
#define PACKAGE_SHORT_TEXT_LEN      140
#define PACKAGE_LONG_TEXT_LEN       512

#define DEVICE_ID_LEN               300

#define DMSINVHEADER_MAGIC          0xA54088CE

#define DMS_CTL_SETTASK    CTL_CODE(FILE_DEVICE_NULL, 1000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define DMS_CTL_REGWND     CTL_CODE(FILE_DEVICE_NULL, 1001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define DMS_CTL_UNREGWND   CTL_CODE(FILE_DEVICE_NULL, 1002, METHOD_NEITHER, FILE_ANY_ACCESS)

#ifdef __cplusplus
extern "C" {
#endif

// task information, passed from application to dmsdklib
typedef struct {
    // task info
    DWORD      dwSize;
    SYSTEMTIME stStartTime;
    SYSTEMTIME stDeltaTime;
    SYSTEMTIME stRetryTime;
    DWORD      dwType;
    DWORD      dwMaxRetryTime;
    DWORD      dwFlags;
    LPTSTR     pwzRDN;          // reserved
    LPTSTR     pwzURL;
    LPTSTR     pwzURLSig;       // reserved
    LPTSTR     pwzMisc;         // mostly used for Action name (Report task may use "Status" or "Report")
    LPTSTR     pwzData;         // either a file name or a blob (contains data in TCHAR)
    LPTSTR     pwzXml;          // reserved
} DMTASKINFO, *PDMTASKINFO;


// db header
typedef struct {
    DWORD   dwMagic;
    DWORD   dwRecSize;  
    DWORD   dwRecNumber;
    DWORD   dwReserved;
} DMSINVHEADER, *PDMSINVHEADER;


typedef struct {
    SYSTEMTIME stStartTime;
    SYSTEMTIME stDeltaTime;
    DWORD    dwFlags;
    TCHAR    wzDest[MAX_PATH];
    TCHAR    wzCmdLine[MAX_PATH];    
} DMSDLINFO, *PDMSDLINFO;

// Package db record
typedef struct {
    TCHAR    wzPackageID[DEVICE_ID_LEN];
    TCHAR    wzShortText[PACKAGE_SHORT_TEXT_LEN];
    TCHAR    wzLongText [PACKAGE_LONG_TEXT_LEN];
    TCHAR    wzAppName  [PACKAGE_APPNAME_TEXT_LEN];
    DWORD    dwPackageSize;         // in bytes
    DWORD    dwState;
    DMSDLINFO dlInfo;
    DWORD    dwAux;                 // reserved
} DMSINVRECORD, *PDMSINVRECORD;


// Package db record -- id and state only
typedef struct {
    TCHAR wzPackageID[DEVICE_ID_LEN];
    DWORD dwState;
} DMSINVPKGID, *PDMSINVPKGID;


// Communication between engine and apps
#define WM_REFRESH_DMSDATA          0xA001

// wParam (magic number)
#define DMS_CALLBACK_MAGIC          0x22480EE4

// lParam (update info)

// task list changed
#define DMS_REFRESH_TASKS           0x00000001

// database changed
#define DMS_REFRESH_DB              0x00000002
#define DMS_REFRESH_DB_ADD          0x00000012
#define DMS_REFRESH_DB_REMOVE       0x00000022
#define DMS_REFRESH_DB_DL_FAIL      0x00000042

//
// API prototypes
//
//---------------------------------------------------------------------------
HRESULT WINAPI CeSetDevMgmtTask
(
    PDMTASKINFO pdi
); 


//---------------------------------------------------------------------------
HRESULT WINAPI CeGetDevMgmtPackageList    
(
    PDMSINVRECORD   pRecord,
    LPDWORD         pdwEntryNumber,
    DWORD           dwFilter
);

//---------------------------------------------------------------------------
HRESULT WINAPI CeSetDevMgmtPackageList    
(
    PDMSINVRECORD   pRecord,
    DWORD           dwFlags
);

//---------------------------------------------------------------------------
HANDLE WINAPI CeStartDevMgmtService
(
    int     nAction,
#ifdef __cplusplus
    HWND    hCallbackWnd = NULL
#else
    HWND    hCallbackWnd
#endif
);

typedef HANDLE  (*PFNCESTARTDEVMGMTSERVICE) (int nAction, HWND hWnd);
typedef HRESULT (*PFNCESETDEVMGMTTASK) (PDMTASKINFO pti);
typedef HRESULT (*PFNCEGETDEVMGMTPACKAGELIST) (PDMSINVRECORD, LPDWORD, DWORD);
typedef HRESULT (*PFNCESETDEVMGMTPACKAGELIST) (PDMSINVRECORD, DWORD);


//
// Prototypes for functions supported by Bin handler DLL
//
//---------------------------------------------------------------------------
typedef BOOL (*PFNPROCESSDOWNLOADBEGIN)(void);
typedef BOOL (*PFNPROCESSDOWNLOADEND)(void);

#ifdef __cplusplus
}
#endif

#endif // _DEVMGMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dispex.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:56 2007
 */
/* Compiler settings for ..\dispex.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dispex_h__
#define __dispex_h__

/* Forward Declarations */ 

#ifndef __IDispatchEx_FWD_DEFINED__
#define __IDispatchEx_FWD_DEFINED__
typedef interface IDispatchEx IDispatchEx;
#endif 	/* __IDispatchEx_FWD_DEFINED__ */


#ifndef __IDispError_FWD_DEFINED__
#define __IDispError_FWD_DEFINED__
typedef interface IDispError IDispError;
#endif 	/* __IDispError_FWD_DEFINED__ */


#ifndef __IVariantChangeType_FWD_DEFINED__
#define __IVariantChangeType_FWD_DEFINED__
typedef interface IVariantChangeType IVariantChangeType;
#endif 	/* __IVariantChangeType_FWD_DEFINED__ */


#ifndef __IObjectIdentity_FWD_DEFINED__
#define __IObjectIdentity_FWD_DEFINED__
typedef interface IObjectIdentity IObjectIdentity;
#endif 	/* __IObjectIdentity_FWD_DEFINED__ */


#ifndef __IProvideRuntimeContext_FWD_DEFINED__
#define __IProvideRuntimeContext_FWD_DEFINED__
typedef interface IProvideRuntimeContext IProvideRuntimeContext;
#endif 	/* __IProvideRuntimeContext_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "servprov.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dispex_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DispEx.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IDispatchEx Interfaces.
//

#ifndef DISPEX_H_
#define DISPEX_H_





#include "servprov.h"

#ifndef _NO_DISPATCHEX_GUIDS

// {A6EF9860-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispatchEx, 0xa6ef9860, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9861-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IDispError, 0xa6ef9861, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {A6EF9862-C720-11d0-9337-00A0C90DCAA9}
DEFINE_GUID(IID_IVariantChangeType, 0xa6ef9862, 0xc720, 0x11d0, 0x93, 0x37, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {1F101481-BCCD-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_VariantConversion, 0x1f101481, 0xbccd, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {4717CC40-BCB9-11d0-9336-00A0C90DCAA9}
DEFINE_GUID(SID_GetCaller, 0x4717cc40, 0xbcb9, 0x11d0, 0x93, 0x36, 0x0, 0xa0, 0xc9, 0xd, 0xca, 0xa9);

// {74A5040C-DD0C-48f0-AC85-194C3259180A}
DEFINE_GUID(SID_ProvideRuntimeContext, 0x74a5040c, 0xdd0c, 0x48f0, 0xac, 0x85, 0x19, 0x4c, 0x32, 0x59, 0x18, 0xa);

// {10E2414A-EC59-49d2-BC51-5ADD2C36FEBC}
DEFINE_GUID(IID_IProvideRuntimeContext, 0x10e2414a, 0xec59, 0x49d2, 0xbc, 0x51, 0x5a, 0xdd, 0x2c, 0x36, 0xfe, 0xbc);

// {CA04B7E6-0D21-11d1-8CC5-00C04FC2B085}
DEFINE_GUID(IID_IObjectIdentity, 0xca04b7e6, 0xd21, 0x11d1, 0x8c, 0xc5, 0x0, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);

#define SID_GetScriptSite IID_IActiveScriptSite

#endif // _NO_DISPATCHEX_GUIDS


#ifndef _NO_DISPATCHEX_CONSTS

// Input flags for GetDispID
#define fdexNameCaseSensitive       0x00000001L
#define fdexNameEnsure              0x00000002L
#define fdexNameImplicit            0x00000004L
#define fdexNameCaseInsensitive     0x00000008L
#define fdexNameInternal            0x00000010L
#define fdexNameNoDynamicProperties 0x00000020L

// Output flags for GetMemberProperties
#define fdexPropCanGet              0x00000001L
#define fdexPropCannotGet           0x00000002L
#define fdexPropCanPut              0x00000004L
#define fdexPropCannotPut           0x00000008L
#define fdexPropCanPutRef           0x00000010L
#define fdexPropCannotPutRef        0x00000020L
#define fdexPropNoSideEffects       0x00000040L
#define fdexPropDynamicType         0x00000080L
#define fdexPropCanCall             0x00000100L
#define fdexPropCannotCall          0x00000200L
#define fdexPropCanConstruct        0x00000400L
#define fdexPropCannotConstruct     0x00000800L
#define fdexPropCanSourceEvents     0x00001000L
#define fdexPropCannotSourceEvents  0x00002000L

#define grfdexPropCanAll \
       (fdexPropCanGet | fdexPropCanPut | fdexPropCanPutRef | \
        fdexPropCanCall | fdexPropCanConstruct | fdexPropCanSourceEvents)
#define grfdexPropCannotAll \
       (fdexPropCannotGet | fdexPropCannotPut | fdexPropCannotPutRef | \
        fdexPropCannotCall | fdexPropCannotConstruct | fdexPropCannotSourceEvents)
#define grfdexPropExtraAll \
       (fdexPropNoSideEffects | fdexPropDynamicType)
#define grfdexPropAll \
       (grfdexPropCanAll | grfdexPropCannotAll | grfdexPropExtraAll)

// Input flags for GetNextDispID
#define fdexEnumDefault             0x00000001L
#define fdexEnumAll                 0x00000002L

// Additional flags for Invoke - when object member is
// used as a constructor.
#define DISPATCH_CONSTRUCT 0x4000

// Standard DISPIDs
#define DISPID_THIS (-613)
#define DISPID_STARTENUM DISPID_UNKNOWN

#endif //_NO_DISPATCHEX_CONSTS



extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0000_v0_0_s_ifspec;

#ifndef __IDispatchEx_INTERFACE_DEFINED__
#define __IDispatchEx_INTERFACE_DEFINED__

/* interface IDispatchEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispatchEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9860-C720-11d0-9337-00A0C90DCAA9")
    IDispatchEx : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDispID( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE InvokeEx( 
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByName( 
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMemberByDispID( 
            /* [in] */ DISPID id) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberProperties( 
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemberName( 
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextDispID( 
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNameSpaceParent( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispatchEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispatchEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDispatchEx __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvokeEx )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [in] */ DISPPARAMS __RPC_FAR *pdp,
            /* [out] */ VARIANT __RPC_FAR *pvarRes,
            /* [out] */ EXCEPINFO __RPC_FAR *pei,
            /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMemberByName )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ DWORD grfdex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMemberByDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberProperties )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [in] */ DWORD grfdexFetch,
            /* [out] */ DWORD __RPC_FAR *pgrfdex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMemberName )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DISPID id,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextDispID )( 
            IDispatchEx __RPC_FAR * This,
            /* [in] */ DWORD grfdex,
            /* [in] */ DISPID id,
            /* [out] */ DISPID __RPC_FAR *pid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNameSpaceParent )( 
            IDispatchEx __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        END_INTERFACE
    } IDispatchExVtbl;

    interface IDispatchEx
    {
        CONST_VTBL struct IDispatchExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatchEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispatchEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispatchEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispatchEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispatchEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDispatchEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDispatchEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDispatchEx_GetDispID(This,bstrName,grfdex,pid)	\
    (This)->lpVtbl -> GetDispID(This,bstrName,grfdex,pid)

#define IDispatchEx_InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)	\
    (This)->lpVtbl -> InvokeEx(This,id,lcid,wFlags,pdp,pvarRes,pei,pspCaller)

#define IDispatchEx_DeleteMemberByName(This,bstrName,grfdex)	\
    (This)->lpVtbl -> DeleteMemberByName(This,bstrName,grfdex)

#define IDispatchEx_DeleteMemberByDispID(This,id)	\
    (This)->lpVtbl -> DeleteMemberByDispID(This,id)

#define IDispatchEx_GetMemberProperties(This,id,grfdexFetch,pgrfdex)	\
    (This)->lpVtbl -> GetMemberProperties(This,id,grfdexFetch,pgrfdex)

#define IDispatchEx_GetMemberName(This,id,pbstrName)	\
    (This)->lpVtbl -> GetMemberName(This,id,pbstrName)

#define IDispatchEx_GetNextDispID(This,grfdex,id,pid)	\
    (This)->lpVtbl -> GetNextDispID(This,grfdex,id,pid)

#define IDispatchEx_GetNameSpaceParent(This,ppunk)	\
    (This)->lpVtbl -> GetNameSpaceParent(This,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispatchEx_GetDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ DWORD grfdex,
    /* [out] */ DISPID __RPC_FAR *pid);


void __RPC_STUB IDispatchEx_GetDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_RemoteInvokeEx_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ UINT __RPC_FAR *rgiRefArg,
    /* [size_is][out][in] */ VARIANT __RPC_FAR *rgvarRefArg);


void __RPC_STUB IDispatchEx_RemoteInvokeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_DeleteMemberByName_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ DWORD grfdex);


void __RPC_STUB IDispatchEx_DeleteMemberByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_DeleteMemberByDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id);


void __RPC_STUB IDispatchEx_DeleteMemberByDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetMemberProperties_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ DWORD grfdexFetch,
    /* [out] */ DWORD __RPC_FAR *pgrfdex);


void __RPC_STUB IDispatchEx_GetMemberProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetMemberName_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IDispatchEx_GetMemberName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetNextDispID_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DWORD grfdex,
    /* [in] */ DISPID id,
    /* [out] */ DISPID __RPC_FAR *pid);


void __RPC_STUB IDispatchEx_GetNextDispID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatchEx_GetNameSpaceParent_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IDispatchEx_GetNameSpaceParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatchEx_INTERFACE_DEFINED__ */


#ifndef __IDispError_INTERFACE_DEFINED__
#define __IDispError_INTERFACE_DEFINED__

/* interface IDispError */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDispError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9861-C720-11d0-9337-00A0C90DCAA9")
    IDispError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryErrorInfo( 
            /* [in] */ GUID guidErrorType,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHresult( 
            /* [out] */ HRESULT __RPC_FAR *phr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ BSTR __RPC_FAR *pbstrSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrFileName,
            /* [out] */ DWORD __RPC_FAR *pdwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pbstrDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryErrorInfo )( 
            IDispError __RPC_FAR * This,
            /* [in] */ GUID guidErrorType,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IDispError __RPC_FAR * This,
            /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHresult )( 
            IDispError __RPC_FAR * This,
            /* [out] */ HRESULT __RPC_FAR *phr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSource )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpInfo )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrFileName,
            /* [out] */ DWORD __RPC_FAR *pdwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IDispError __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrDescription);
        
        END_INTERFACE
    } IDispErrorVtbl;

    interface IDispError
    {
        CONST_VTBL struct IDispErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispError_QueryErrorInfo(This,guidErrorType,ppde)	\
    (This)->lpVtbl -> QueryErrorInfo(This,guidErrorType,ppde)

#define IDispError_GetNext(This,ppde)	\
    (This)->lpVtbl -> GetNext(This,ppde)

#define IDispError_GetHresult(This,phr)	\
    (This)->lpVtbl -> GetHresult(This,phr)

#define IDispError_GetSource(This,pbstrSource)	\
    (This)->lpVtbl -> GetSource(This,pbstrSource)

#define IDispError_GetHelpInfo(This,pbstrFileName,pdwContext)	\
    (This)->lpVtbl -> GetHelpInfo(This,pbstrFileName,pdwContext)

#define IDispError_GetDescription(This,pbstrDescription)	\
    (This)->lpVtbl -> GetDescription(This,pbstrDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispError_QueryErrorInfo_Proxy( 
    IDispError __RPC_FAR * This,
    /* [in] */ GUID guidErrorType,
    /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);


void __RPC_STUB IDispError_QueryErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetNext_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ IDispError __RPC_FAR *__RPC_FAR *ppde);


void __RPC_STUB IDispError_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetHresult_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ HRESULT __RPC_FAR *phr);


void __RPC_STUB IDispError_GetHresult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetSource_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrSource);


void __RPC_STUB IDispError_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetHelpInfo_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrFileName,
    /* [out] */ DWORD __RPC_FAR *pdwContext);


void __RPC_STUB IDispError_GetHelpInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispError_GetDescription_Proxy( 
    IDispError __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrDescription);


void __RPC_STUB IDispError_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispError_INTERFACE_DEFINED__ */


#ifndef __IVariantChangeType_INTERFACE_DEFINED__
#define __IVariantChangeType_INTERFACE_DEFINED__

/* interface IVariantChangeType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVariantChangeType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6EF9862-C720-11d0-9337-00A0C90DCAA9")
    IVariantChangeType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
            /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantChangeTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantChangeType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantChangeType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantChangeType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeType )( 
            IVariantChangeType __RPC_FAR * This,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
            /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
            /* [in] */ LCID lcid,
            /* [in] */ VARTYPE vtNew);
        
        END_INTERFACE
    } IVariantChangeTypeVtbl;

    interface IVariantChangeType
    {
        CONST_VTBL struct IVariantChangeTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantChangeType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantChangeType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantChangeType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantChangeType_ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)	\
    (This)->lpVtbl -> ChangeType(This,pvarDst,pvarSrc,lcid,vtNew)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVariantChangeType_ChangeType_Proxy( 
    IVariantChangeType __RPC_FAR * This,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarDst,
    /* [unique][in] */ VARIANT __RPC_FAR *pvarSrc,
    /* [in] */ LCID lcid,
    /* [in] */ VARTYPE vtNew);


void __RPC_STUB IVariantChangeType_ChangeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantChangeType_INTERFACE_DEFINED__ */


#ifndef __IObjectIdentity_INTERFACE_DEFINED__
#define __IObjectIdentity_INTERFACE_DEFINED__

/* interface IObjectIdentity */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA04B7E6-0D21-11d1-8CC5-00C04FC2B085")
    IObjectIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsEqualObject( 
            /* [in] */ IUnknown __RPC_FAR *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectIdentity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectIdentity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectIdentity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqualObject )( 
            IObjectIdentity __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *punk);
        
        END_INTERFACE
    } IObjectIdentityVtbl;

    interface IObjectIdentity
    {
        CONST_VTBL struct IObjectIdentityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectIdentity_IsEqualObject(This,punk)	\
    (This)->lpVtbl -> IsEqualObject(This,punk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectIdentity_IsEqualObject_Proxy( 
    IObjectIdentity __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IObjectIdentity_IsEqualObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectIdentity_INTERFACE_DEFINED__ */


#ifndef __IProvideRuntimeContext_INTERFACE_DEFINED__
#define __IProvideRuntimeContext_INTERFACE_DEFINED__

/* interface IProvideRuntimeContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvideRuntimeContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10E2414A-EC59-49d2-BC51-5ADD2C36FEBC")
    IProvideRuntimeContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSourceContext( 
            /* [out] */ DWORD_PTR __RPC_FAR *pdwContext,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfExecutingGlobalCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideRuntimeContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProvideRuntimeContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProvideRuntimeContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProvideRuntimeContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentSourceContext )( 
            IProvideRuntimeContext __RPC_FAR * This,
            /* [out] */ DWORD_PTR __RPC_FAR *pdwContext,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pfExecutingGlobalCode);
        
        END_INTERFACE
    } IProvideRuntimeContextVtbl;

    interface IProvideRuntimeContext
    {
        CONST_VTBL struct IProvideRuntimeContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideRuntimeContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideRuntimeContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideRuntimeContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideRuntimeContext_GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode)	\
    (This)->lpVtbl -> GetCurrentSourceContext(This,pdwContext,pfExecutingGlobalCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IProvideRuntimeContext_GetCurrentSourceContext_Proxy( 
    IProvideRuntimeContext __RPC_FAR * This,
    /* [out] */ DWORD_PTR __RPC_FAR *pdwContext,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pfExecutingGlobalCode);


void __RPC_STUB IProvideRuntimeContext_GetCurrentSourceContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideRuntimeContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dispex_0155 */
/* [local] */ 

#endif //DISPEX_H_


extern RPC_IF_HANDLE __MIDL_itf_dispex_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dispex_0155_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub( 
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [out] */ VARIANT __RPC_FAR *pvarRes,
    /* [out] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller,
    /* [in] */ UINT cvarRefArg,
    /* [size_is][in] */ UINT __RPC_FAR *rgiRefArg,
    /* [size_is][out][in] */ VARIANT __RPC_FAR *rgvarRefArg);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dimm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 29 11:25:14 2007
 */
/* Compiler settings for ..\dimm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __dimm_h__
#define __dimm_h__

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dimm_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#include <imm.h>
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    }	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    }	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    }	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    }	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    }	STYLEBUFW;

typedef WORD ATOM;

#if (WINVER < 0x040A)
typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    }	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    }	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        }	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    }	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dimm_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    }	IMEINFO;

#endif
#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC __RPC_FAR *rgInputContext,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumInputContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumInputContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumInputContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumInputContext __RPC_FAR * This,
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumInputContext __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC __RPC_FAR *rgInputContext,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumInputContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumInputContext __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext __RPC_FAR * This,
    /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC __RPC_FAR *rgInputContext,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext __RPC_FAR * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMRegistrar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterIME )( 
            IActiveIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterIME )( 
            IActiveIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_RegisterIME_Proxy( 
    IActiveIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID lgid,
    /* [in] */ LPCWSTR pszIconFile,
    /* [in] */ LPCWSTR pszDesc);


void __RPC_STUB IActiveIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_UnregisterIME_Proxy( 
    IActiveIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IActiveIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG __RPC_FAR *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ const MSG __RPC_FAR *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This,
    /* [in] */ const MSG __RPC_FAR *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDefWindowProc )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterClientWindows )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContextEx )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImeMenuItemsA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImeMenuItemsW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumInputContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp __RPC_FAR * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ ATOM __RPC_FAR *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateMessage )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReSizeIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCSize )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroySoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeybdEvent )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContextEx )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImeMenuItemsA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImeMenuItemsW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumInputContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestMessageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestMessageW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendIMCA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendIMCW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSleeping )( 
            IActiveIMMIME __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMIME_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_IsSleeping(This)	\
    (This)->lpVtbl -> IsSleeping(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT __RPC_FAR *puModifiers,
    /* [out] */ UINT __RPC_FAR *puVKey,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContextEx_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMIME_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DisableIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMIME_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA __RPC_FAR *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA __RPC_FAR *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW __RPC_FAR *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW __RPC_FAR *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumInputContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IActiveIMMIME_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsSleeping_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_IsSleeping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Inquire )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConversionList )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Escape )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveContext )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessKey )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionString )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToAsciiEx )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyle )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD __RPC_FAR *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDest,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void __RPC_FAR *pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE __RPC_FAR *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void __RPC_FAR *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void __RPC_FAR *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE __RPC_FAR *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
    /* [out] */ UINT __RPC_FAR *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIME2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIME2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Inquire )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConversionList )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Escape )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveContext )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessKey )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionString )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToAsciiEx )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWord )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWord )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyle )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWord )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIME2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIME2 __RPC_FAR * This,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Sleep )( 
            IActiveIME2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unsleep )( 
            IActiveIME2 __RPC_FAR * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME2_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME2_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)


#define IActiveIME2_Sleep(This)	\
    (This)->lpVtbl -> Sleep(This)

#define IActiveIME2_Unsleep(This,fDead)	\
    (This)->lpVtbl -> Unsleep(This,fDead)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME2_Sleep_Proxy( 
    IActiveIME2 __RPC_FAR * This);


void __RPC_STUB IActiveIME2_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME2_Unsleep_Proxy( 
    IActiveIME2 __RPC_FAR * This,
    /* [in] */ BOOL fDead);


void __RPC_STUB IActiveIME2_Unsleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dialbroker.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//


#ifndef _DIALBROKER_H_
#define _DIALBROKER_H_

#if (_MSC_VER >= 1000)
#pragma once
#endif

#include <objbase.h>
#include "phone.h"  // PH_DIAL_PARAMETERS

#ifdef __cplusplus
extern "C" {
#endif

/// <file_topic_scope tref="DialBroker" />
/// <topic name="DialBroker" displayname="Dial Broker">
///   <topic_scope tref="Phone" />
///   <summary>
///     These are a set of APIs that allow interested parties to control which
///     provider and line is used to make outgoing calls on.
///   </summary>
/// </topic>
/// 

/// <summary>
///   This agent has no referral for this pending dial attempt.
/// </summary>
#define E_NOREFERRAL HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)

/// <summary>
///   Line data for a particular provider.
/// </summary>
/// <param_skipvalidate name="guidProvider">
///   GUID of provider for this line data.
/// </param_skipvalidate>
/// <param_skipvalidate name="cLines">
///   Count of possible lines for this provider.
/// </param_skipvalidate>
/// <param_skipvalidate name="grfHidden">
///   Bitmask indicating which lines numbers (1-based indexes) have been hidden,
///   e.g. 0x3 would mean that lines 1 and 2 are hidden lines.
///   Hidden lines cannot be selected through the UI though they can be
///   selected by dial agents.
/// </param_skipvalidate>
typedef struct PROVIDER_LINEDATA
{
    GUID guidProvider;
    UINT cLines;
    DWORD grfHidden;
} PROVIDER_LINEDATA;

/// <summary>
///   Dial Agent Flags to help communicate referral status to subsequent agents.
/// </summary>
typedef enum DIALAGENT_FLAG
{
    /// <summary>
    ///   This agent is allowed to make a referral for this call attempt.
    /// </summary>
    DIALAGENT_FLAG_REFERRALALLOWED = 0x1,

    /// <summary>
    ///   At least one agent has made a referral.
    /// </summary>
    DIALAGENT_FLAG_REFERRALMADE = 0x2,

    /// <summary>
    ///   The call request has been finalized using pdialparams and hCallNew.
    /// </summary>
    DIALAGENT_FLAG_REFERRALFINALIZED = 0x4,

    /// <summary>
    ///   At least one agent detects that this is an emergency number dial request.
    /// </summary>
    DIALAGENT_FLAG_EMERGENCY = 0x8,

    /// <summary>
    ///   At least one agent detects that this is a provider specific dial request.
    /// </summary>
    DIALAGENT_FLAG_PROVIDERSPECIFIC = 0x10
} DIALAGENT_FLAG;

/// <summary>
///   Composite agent for the phone application that aggregates the referrals
///   from each DialBroker agent to determine which CSP (Call Service Provider)
///   should be used to handle each dial attempt.
/// </summary>
/// <remarks>
///   Note that the dial broker host is also a IDialAgent
///   that merges the responses from all of the other IDialAgents. <para />
///   IDialBroker also implements additional APIs for clients to use
///   to query available providers and lines and/or set the default outgoing line. <para />
/// </remarks>
class IDialBroker
{
public:

    virtual ~IDialBroker() {};
    
    /// <summary>
    ///   This method is called to get the currently available lines for making calls.
    /// </summary>
    /// <param name="pprgLineData">
    ///   Pointer to receive array of <see cref="PROVIDER_LINEDATA" /> of available lines.
    /// </param>
    /// <param name="pcLineData">
    ///   Pointer to receive count of <see cref="PROVIDER_LINEDATA" /> items stored in prgLineData.
    /// </param>
    /// <returns>
    ///   Standard HRESULT
    /// </returns>
    /// <remarks>
    ///   Caller is responsible for calling LocalFree on prgLineData when no longer needed
    /// </remarks>
    STDMETHOD(GetAvailableLineData)(THIS_
                                    __deref_out_ecount(*pcLineData) PROVIDER_LINEDATA **pprgLineData,
                                    __out UINT *pcLineData) PURE;

    /// <summary>
    ///   This method is called to get the original <see cref="PH_DIAL_PARAMETERS" />
    ///   that the DialBroker received for this call attempt.
    /// </summary>
    /// <param name="ppdialparams">
    ///   Original <see cref="PH_DIAL_PARAMETERS" /> used to make this dial request.
    /// </param>
    /// <returns>
    ///   Standard HRESULT
    /// </returns>
    /// <remarks>
    ///   Each dial agent receives a possibly modified version of the
    ///   original <see cref="PH_DIAL_PARAMETERS" /> used to make a call. <para />
    ///   Use this function to get the original unmodified dial parameters. <para />
    ///   The caller is responsible for calling FreeDialParams on pdial
    /// </remarks>
    STDMETHOD(GetOriginalDialParams)(THIS_
                                     __deref_out PH_DIAL_PARAMETERS **ppdialparams) PURE;

    /// <summary>
    ///   This method is called to free the memory allocated by GetOriginalDialParams.
    /// </summary>
    /// <param name="pdialparams">
    ///   <see cref="PH_DIAL_PARAMETERS" /> result output by GetOriginalDialParams.
    /// </param>
    /// <returns>
    ///   Standard HRESULT
    /// </returns>
    STDMETHOD(FreeDialParams)(THIS_
                              __inout_opt PH_DIAL_PARAMETERS *pdialparams) PURE;

    /// <summary>
    ///   This method is called to get the default outgoing line.
    /// </summary>
    /// <param name="pguidProvider">
    ///   GUID of provider of the default outgoing line.
    /// </param>
    /// <param name="piLineNum">
    ///   Pointer to receive the line number from the provider.
    /// </param>
    /// <returns>
    ///   Standard HRESULT
    /// </returns>
    /// <remarks>
    ///   The default outgoing line is the line that will be used for dial
    ///   attempts if no agent makes a referral.
    /// </remarks>
    STDMETHOD(GetDefaultOutgoingLine)(THIS_
                                      __out GUID* pguidProvider,
                                      __out UINT *piLineNum) PURE;
};

// {F2688CF8-7D1F-4f72-95F5-AB338877CF7E}
DEFINE_GUID(CLSID_DialAgent, 
0xF2688CF8, 0x7D1F, 0x4f72, 0x95, 0xF5, 0xAB, 0x33, 0x88, 0x77, 0xCF, 0x7E);

// {72360FF9-6A2B-40c1-8234-97B9E0731B21}
DEFINE_GUID(IID_IDialAgent, 
0x72360FF9, 0x6A2B, 0x40c1, 0x82, 0x34, 0x97, 0xB9, 0xE0, 0x73, 0x1B, 0x21);

/// <topic name="DialAgentRegistration" displayname="Dial Agent Registration">
/// <topic_scope tref="DialBroker" />
///   <summary> 
///     Each dial agent is identified by a GUID and is registered in the device
///     registry using that guid. <para />
///     Dial agents should register themselves under the following registry keys:     
///     [HKEY_LOCAL_MACHINE\System\Phone\DialAgents] <para />
///       "VALUENAME"="{DIALAGENT-GUID}" <para />
///     [HKEY_CLASSES_ROOT\CLSID\{DIALAGENT-GUID}\InprocServer32] <para />
///       @="DIALAGENT-DLL" <para />
///   </summary>
///   <remarks>
///     VALUENAME can be any unique value
///   </remarks>
/// </topic>

#undef INTERFACE
#define INTERFACE IDialAgent
/// <summary>
///   An agent for IDialBroker that helps manage lines available to the user
///   and helps choose an appropriate line to dial calls on.
/// </summary>
/// <remarks>
///   A default set of agents is implemented by Microsoft that appropriately routes
///   standard, emergency, and voicemail calls. <para />
///   Providers only need to implement dial agent(s) to enable custom handling
///   such as VoIP calls only during business hours. <para />
/// </remarks>
DECLARE_INTERFACE_IID(IDialAgent, "72360FF9-6A2B-40c1-8234-97B9E0731B21")
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, __deref_out LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    /// <summary>
    ///   This method is called to initialize the dial agent.
    /// </summary>
    /// <param name="pDialBroker">
    ///   Pointer to <see cref="IDialBroker" /> that is hosting this agent.
    /// </param>
    /// <returns>
    ///   Standard HRESULT
    /// </returns>
    STDMETHOD(Initialize)(THIS_
                          __in IDialBroker *pDialBroker) PURE;    

    /// <summary>
    ///   This method is called to receive this agent's referral on what
    ///   provider and line should be used to make the pending dial attempt.
    /// </summary>
    /// <param name="hCallNew">
    ///   HPHONECALL value that will be used to make this dial request.
    /// </param>
    /// <param name="pdialparams">
    ///   Coming in: <see cref="PH_DIAL_PARAMETERS" /> used to make this dial request.
    ///   Going out: Updated value.  See remarks.
    /// </param>
    /// <param name="pdwDialAgentFlags">
    ///   Coming in: Pointer to set of <see cref="DIALAGENT_FLAG" />s containing
    ///     data about previous dial agent referrals. <para />
    ///   Going out: Updated value.
    /// </param>
    /// <returns>
    ///   S_OK if a referral has been made. <para />
    ///   E_NOREFERRAL if this agent has no referral. <para />
    ///   E_ABORT if this agent would like the call aborted. <para />
    ///   <para>Standard HRESULT otherwise</para>
    /// </returns>
    /// <remarks>
    ///   Agents should only change the values of out parameters if they
    ///   have a referral and return S_OK.
    ///   pdialparams contains the composite <see cref="PH_DIAL_PARAMETERS" />
    ///   result from previous dial agents.  For example, agents can change
    ///   the pguidProvider and iLineNum fields in order to refer a different
    ///   provider and line number to use to handle the pending dial attempt. <para />
    ///   Use <see cref="IDialBroker.GetOriginalDialParams" /> to get the
    ///   original unmodified dial parameters. <para />
    ///   E_ABORT will end the call attempt with no error message if this agent's referral is used.
    ///   It is intended for use by applications that detect that the dial attempt
    ///   is really intended for them and want to handle it independently of the
    ///   phone application. <para />
    ///   Note that the DialBroker may ignore some or all changes made by particular
    ///   agents depending on the scenario.  For example, pszDialNumber changes
    ///   from one agent may be ignored if the actual provider and line number
    ///   chosen by the DialBroker corresponds to another agent's referral.
    /// </remarks>
    STDMETHOD(Refer)(THIS_
                     HPHONECALL hCallNew,
                     __inout PH_DIAL_PARAMETERS * pdialparams, 
                     __inout DWORD * pdwDialAgentFlags) PURE;
};

#ifdef __cplusplus
}
#endif

#endif // _DIALBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dllsetup.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// To be self registering, OLE servers must
// export functions named DllRegisterServer
// and DllUnregisterServer.  To allow use of
// custom and default implementations the
// defaults are named AMovieDllRegisterServer
// and AMovieDllUnregisterServer.
//
// To the use the default implementation you
// must provide stub functions.
//
// i.e. STDAPI DllRegisterServer()
//      {
//        return AMovieDllRegisterServer();
//      }
//
//      STDAPI DllUnregisterServer()
//      {
//        return AMovieDllUnregisterServer();
//      }
//
//
// AMovieDllRegisterServer   calls IAMovieSetup.Register(), and
// AMovieDllUnregisterServer calls IAMovieSetup.Unregister().

STDAPI AMovieDllRegisterServer2( BOOL );
STDAPI AMovieDllRegisterServer();
STDAPI AMovieDllUnregisterServer();

// helper functions
STDAPI EliminateSubKey( HKEY, LPTSTR );


#ifndef NO_FILTERMAPPER2
STDAPI
AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
                          , IFilterMapper2 *                 pIFM2
                          , BOOL                             bRegister  );
#endif //!NO_FILTERMAPPER2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dlgs.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//


/*++

Module Name:

    dlgs.h

Abstract:

    This module contains the UI dialog header information.

--*/


#ifndef _DLGSH_INCLUDED_
#define _DLGSH_INCLUDED_


//
//  Constant Declarations.
//

#define ctlFirst    0x0400
#define ctlLast     0x04ff

//
//  Push buttons.
//
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f

//
//  Checkboxes.
//
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f

//
//  Radio buttons.
//
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f

//
//  Groups, frames, rectangles, and icons.
//
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f

//
//  Static text.
//
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f

//
//  Listboxes.
//
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f

//
//  Combo boxes.
//
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f

//
//  Edit controls.
//
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f

//
//  Scroll bars.
//
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

//
//  Controls
//
#define ctl1        0x04A0

//
//  These dialog resource ordinals really start at 0x0600, but the
//  RC Compiler can't handle hex for resource IDs, hence the decimal.
//
#ifdef UNIX

#define MW_BIG_FILEOPENORD      10000
#define MW_BIG_MULTIFILEOPENORD 10001

#define FILEOPENORDMOTIF        10003
#define PRINTDLGORDMOTIF        10004
#define FINDDLGORDMOTIF         10005
#endif

#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544
#define RUNDLGORD        1545

#if (WINVER >= 0x400)
#define PAGESETUPDLGORD         1546
#define NEWFILEOPENORD          1547
#define PRINTDLGEXORD           1549
#define PAGESETUPDLGORDMOTIF    1550
#define COLORMGMTDLGORD         1551
#define NEWFILEOPENV2ORD        1552
#endif /* WINVER >= 0x400) */






//
//  Typedef Declarations.
//
typedef struct tagCRGB
{
    BYTE    bRed;
    BYTE    bGreen;
    BYTE    bBlue;
    BYTE    bExtra;
} CRGB;           /* RGB Color */


#endif // _DLGSH_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmo.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __DMO_H__
#define __DMO_H__

//
// Headers that almost every DMO will need
//
#include "mediaerr.h"

// When using ATL we get collisions on Lock so in this case rename
// IMediaObject::Lock to IMediaObject::DMOLock

#ifdef FIX_LOCK_NAME
#define Lock DMOLock
#endif
#include "mediaobj.h"
#ifdef FIX_LOCK_NAME
#undef Lock
#endif
#include "dmoreg.h"
#include "dmort.h"

#endif //__DMO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dlmgridl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:12:59 2007
 */
/* Compiler settings for ..\dlmgridl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dlmgridl_h__
#define __dlmgridl_h__

/* Forward Declarations */ 

#ifndef __IDownloadManager_FWD_DEFINED__
#define __IDownloadManager_FWD_DEFINED__
typedef interface IDownloadManager IDownloadManager;
#endif 	/* __IDownloadManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dlmgridl_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dlmgridl.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Lightweight User Profile Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {988934A4-064B-11D3-BB80-00104B35E7F9}
DEFINE_GUID(IID_IDownloadManager, 0x988934a4, 0x064b, 0x11d3, 0xbb, 0x80, 0x0, 0x10, 0x4b, 0x35, 0xe7, 0xf9);



extern RPC_IF_HANDLE __MIDL_itf_dlmgridl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dlmgridl_0000_v0_0_s_ifspec;

#ifndef __IDownloadManager_INTERFACE_DEFINED__
#define __IDownloadManager_INTERFACE_DEFINED__

/* interface IDownloadManager */
/* [unique][dual][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("988934A4-064B-11D3-BB80-00104B35E7F9")
    IDownloadManager : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ BSTR bstrSaveTo,
            /* [in] */ VARIANT_BOOL fSaveAs,
            /* [in] */ VARIANT_BOOL fSafe,
            /* [in] */ BSTR bstrHeaders,
            /* [in] */ LONG dwVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ VARIANT __RPC_FAR *pbinfo,
            /* [in] */ BSTR bstrRedir,
            /* [in] */ LONG uiCP,
            /* [in] */ LONG dwAttempt) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartURL( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ VARIANT_BOOL fSaveAs,
            /* [in] */ BSTR bstrSaveTo,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ VARIANT_BOOL fSafe,
            /* [in] */ BSTR bstrHeaders,
            /* [in] */ LONG dwVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ VARIANT __RPC_FAR *pbinfo,
            /* [in] */ BSTR bstrRedir,
            /* [in] */ LONG uiCP,
            /* [in] */ LONG dwAttempt) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DownloadURL( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ VARIANT_BOOL fSaveAs) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_eventlock( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEventLock) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_eventlock( 
            /* [in] */ VARIANT_BOOL fEventLock) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelDownload( 
            /* [in] */ LONG lID) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ LONG lID,
            /* [in] */ LONG lState) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartPendingLaterDownloads( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDownloadManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDownloadManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDownloadManager __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ BSTR bstrSaveTo,
            /* [in] */ VARIANT_BOOL fSaveAs,
            /* [in] */ VARIANT_BOOL fSafe,
            /* [in] */ BSTR bstrHeaders,
            /* [in] */ LONG dwVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ VARIANT __RPC_FAR *pbinfo,
            /* [in] */ BSTR bstrRedir,
            /* [in] */ LONG uiCP,
            /* [in] */ LONG dwAttempt);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartURL )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ VARIANT_BOOL fSaveAs,
            /* [in] */ BSTR bstrSaveTo,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ VARIANT_BOOL fSafe,
            /* [in] */ BSTR bstrHeaders,
            /* [in] */ LONG dwVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ VARIANT __RPC_FAR *pbinfo,
            /* [in] */ BSTR bstrRedir,
            /* [in] */ LONG uiCP,
            /* [in] */ LONG dwAttempt);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DownloadURL )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ VARIANT_BOOL fSaveAs);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_eventlock )( 
            IDownloadManager __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEventLock);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_eventlock )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fEventLock);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelDownload )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ LONG lID);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ LONG lID,
            /* [in] */ LONG lState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartPendingLaterDownloads )( 
            IDownloadManager __RPC_FAR * This);
        
        END_INTERFACE
    } IDownloadManagerVtbl;

    interface IDownloadManager
    {
        CONST_VTBL struct IDownloadManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDownloadManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDownloadManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDownloadManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDownloadManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDownloadManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDownloadManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDownloadManager_Start(This,pmk,pbc,bstrSaveTo,fSaveAs,fSafe,bstrHeaders,dwVerb,grfBINDF,pbinfo,bstrRedir,uiCP,dwAttempt)	\
    (This)->lpVtbl -> Start(This,pmk,pbc,bstrSaveTo,fSaveAs,fSafe,bstrHeaders,dwVerb,grfBINDF,pbinfo,bstrRedir,uiCP,dwAttempt)

#define IDownloadManager_StartURL(This,bstrURL,fSaveAs,bstrSaveTo,pbc,fSafe,bstrHeaders,dwVerb,grfBINDF,pbinfo,bstrRedir,uiCP,dwAttempt)	\
    (This)->lpVtbl -> StartURL(This,bstrURL,fSaveAs,bstrSaveTo,pbc,fSafe,bstrHeaders,dwVerb,grfBINDF,pbinfo,bstrRedir,uiCP,dwAttempt)

#define IDownloadManager_DownloadURL(This,bstrURL,fSaveAs)	\
    (This)->lpVtbl -> DownloadURL(This,bstrURL,fSaveAs)

#define IDownloadManager_get_eventlock(This,pfEventLock)	\
    (This)->lpVtbl -> get_eventlock(This,pfEventLock)

#define IDownloadManager_put_eventlock(This,fEventLock)	\
    (This)->lpVtbl -> put_eventlock(This,fEventLock)

#define IDownloadManager_CancelDownload(This,lID)	\
    (This)->lpVtbl -> CancelDownload(This,lID)

#define IDownloadManager_SetState(This,lID,lState)	\
    (This)->lpVtbl -> SetState(This,lID,lState)

#define IDownloadManager_StartPendingLaterDownloads(This)	\
    (This)->lpVtbl -> StartPendingLaterDownloads(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_Start_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pmk,
    /* [in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ BSTR bstrSaveTo,
    /* [in] */ VARIANT_BOOL fSaveAs,
    /* [in] */ VARIANT_BOOL fSafe,
    /* [in] */ BSTR bstrHeaders,
    /* [in] */ LONG dwVerb,
    /* [in] */ LONG grfBINDF,
    /* [in] */ VARIANT __RPC_FAR *pbinfo,
    /* [in] */ BSTR bstrRedir,
    /* [in] */ LONG uiCP,
    /* [in] */ LONG dwAttempt);


void __RPC_STUB IDownloadManager_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_StartURL_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ VARIANT_BOOL fSaveAs,
    /* [in] */ BSTR bstrSaveTo,
    /* [in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ VARIANT_BOOL fSafe,
    /* [in] */ BSTR bstrHeaders,
    /* [in] */ LONG dwVerb,
    /* [in] */ LONG grfBINDF,
    /* [in] */ VARIANT __RPC_FAR *pbinfo,
    /* [in] */ BSTR bstrRedir,
    /* [in] */ LONG uiCP,
    /* [in] */ LONG dwAttempt);


void __RPC_STUB IDownloadManager_StartURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_DownloadURL_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ VARIANT_BOOL fSaveAs);


void __RPC_STUB IDownloadManager_DownloadURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDownloadManager_get_eventlock_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfEventLock);


void __RPC_STUB IDownloadManager_get_eventlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDownloadManager_put_eventlock_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fEventLock);


void __RPC_STUB IDownloadManager_put_eventlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_CancelDownload_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ LONG lID);


void __RPC_STUB IDownloadManager_CancelDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_SetState_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ LONG lID,
    /* [in] */ LONG lState);


void __RPC_STUB IDownloadManager_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IDownloadManager_StartPendingLaterDownloads_Proxy( 
    IDownloadManager __RPC_FAR * This);


void __RPC_STUB IDownloadManager_StartPendingLaterDownloads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDownloadManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmobase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//------------------------------------------------------------------------------
// File: DMOBase.h
//
// Desc: A collection of DMO base classes.
//
//------------------------------------------------------------------------------

// Current hierarchy:
//
//   IMediaObject
//   |
//   +-- C1in1outDMO - generic base class for DMOs with 1 in and 1 out
//   |   |
//   |   +-- FBRDMO - base class for fixed sample size, fixed bitrate DMOs
//   |   |   |
//   |   |   +-- CPCMDMO - base class for PCM audio DMOs
//   |   |
//   |   +-- C1for1DMO - base class for single sample per buffer 1-in/1-out DMOs
//   |       |
//   |       +-- C1for1QCDMO - adds IDMOQualityControl to C1for1DMO
//   |
//   +-- CGenericDMO - resonably generic base class for multi-input/output DMOs
//

#ifndef __DMOBASE_H_
#define __DMOBASE_H_

#include "dmo.h"
#ifdef UNDER_CE
#ifdef DEBUG
#define assert(x)   {if(!(x)) DebugBreak();}
#else
#define assert(x)
#endif
#else
#include "assert.h"
#endif
#include "math.h"

//
// locking helper class
//
#ifdef DMO_NOATL
class CDMOAutoLock {
public:
   CDMOAutoLock(CRITICAL_SECTION* pcs)
      : m_pcs(pcs)
   {
      EnterCriticalSection(m_pcs);
   }
   ~CDMOAutoLock() {
      LeaveCriticalSection(m_pcs);
   }
private:
   CRITICAL_SECTION* m_pcs;
};
#else
class CDMOAutoLock {
public:
   CDMOAutoLock(CComAutoCriticalSection* pcs)
      : m_pcs(pcs)
   {
      m_pcs->Lock();
   }
   ~CDMOAutoLock() {
      m_pcs->Unlock();
   }
private:
   CComAutoCriticalSection* m_pcs;
};
#endif


//
// C1in1outDMO - generic base class for 1-input/1-output DMOs.
//
//
//
// C1in1outDMO implements all IMediaObject methods.  The derived class
// customizes the DMO's behavior by overriding some or all of the following
// virtual functions:
//
// Main Streaming:
//    AcceptInput          // accept one new input buffer
//    ProduceOutput        // fill up one output buffer with new data
//    AcceptingInput       // check if DMO is ready for new input
// Other streaming:
//    PrepareForStreaming  // hook called after both types have been set
//    Discontinuity        // notify DMO of a discontinuity
//    DoFlush              // discard all data and start anew
// Mediatype negotiation:
//    GetInputType         // input type enumerator
//    GetOutputType        // output type enumerator
//    CheckInputType       // verifies proposed input type is acceptable
//    CheckOutputType      // verifies proposed output type is acceptable
// Buffer size negotiation:
//    GetInputFlags        // input data flow flags
//    GetOutputFlags       // output fata flow flags
//    GetInputSizeInfo     // input buffer size requirements
//    GetOutputSizeInfo    // output buffer size requirements
//
// This base class assumes that the derived class will not override any
// IMediaObject methods directly - the derived class should override the
// methods listed above instead.
//
//
//
// The base class provides a default implementation for each of the
// overridables listed above.  However, to make a useful DMO the derived class
// probably needs to override at least the following two methods:
//
//    HRESULT AcceptingInput();
//    HRESULT AcceptInput(BYTE* pData,
//                        ULONG ulSize,
//                        DWORD dwFlags,
//                        REFERENCE_TIME rtTimestamp,
//                        REFERENCE_TIME rtTimelength,
//                        IMediaBuffer* pMediaBuffer);
//    HRESULT ProduceOutput(BYTE *pData,
//                        ULONG ulAvail,
//                        ULONG* pulUsed,
//                        DWORD* pdwStatus,
//                        REFERENCE_TIME *prtTimestamp,
//                        REFERENCE_TIME *prtTimelength);
//
// All good DMOs should also override these (the default implementation
// simply accepts any mediatype, which in general is not good DMO behavior):
//
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// DMOs that store data and/or state information may need to implement
//
//    HRESULT PrepareForStreaming();
//    HRESULT Discontinuity();
//    HRESULT Flush();
//
// Finally, DMOs that make any buffer size assumptions will need to override
// these:
//
//    HRESULT GetInputFlags(DWORD* pdwFlags);
//    HRESULT GetOutputFlags(DWORD* pdwFlags);
//    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment);
//    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment);
//
//
//
// The following functions are provided by this base class exclusively for use
// by the derived class.  The derived class should call these to find out the
// currently set mediatype(s) whenever it needs to make a decision that
// depends on the mediatype used.  Each of these returns NULL if the mediatype
// has not been set yet.
//
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

#define PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulStreamIndex >= 1) \
       return DMO_E_INVALIDSTREAMINDEX

class C1in1outDMO : public IMediaObject
{
public:
    C1in1outDMO() :
       m_bInputTypeSet(FALSE),
       m_bOutputTypeSet(FALSE),
       m_bIncomplete(FALSE)
    {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
    }
    ~C1in1outDMO() {

       FreeInputType();
       FreeOutputType();

#ifdef DMO_NOATL
       DeleteCriticalSection(&m_cs);
#endif
    }

public:
    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = 1;
        *pulNumberOfOutputStreams = 1;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetInputFlags(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
       if( NULL == pdwFlags ) {
          return E_POINTER;
       }

       PROLOGUE;
       return GetOutputFlags(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetInputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;
       return GetOutputType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bInputTypeSet)
           return MoCopyMediaType(pmt, &m_InputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
       PROLOGUE;

       if (m_bOutputTypeSet)
           return MoCopyMediaType(pmt, &m_OutputType);
       else
          return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        
       if( (NULL == pulSize) || (NULL == pcbMaxLookahead) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bInputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetInputSizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {

       if( (NULL == pulSize) || (NULL == pulAlignment) ) {
          return E_POINTER;
       }

       PROLOGUE;

       if (!m_bOutputTypeSet)
          return DMO_E_TYPE_NOT_SET;
       return GetOutputSizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {

       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeInputType();
          return NOERROR;
       } else {
          hr = CheckInputType(pmt);
          if (FAILED(hr))
             return hr;

          if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
             return NOERROR;

          hr = AtomicCopyMediaType(pmt, &m_InputType, m_bInputTypeSet);
          if (FAILED(hr)) {
             return hr;
          }

          m_bInputTypeSet = TRUE;

          if (m_bOutputTypeSet) {
             hr = PrepareForStreaming();
             if (FAILED(hr)) {
                FreeInputType();
                return hr;
             }
          }

          return NOERROR;
       }
    }
    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        
       PROLOGUE;

       HRESULT hr = ValidateSetTypeParameters(pmt, dwFlags);
       if (FAILED(hr)) {
          return hr;
       }

       if (DMO_SET_TYPEF_CLEAR & dwFlags) {
          FreeOutputType();
          return NOERROR;
       } else {
           hr = CheckOutputType(pmt);
           if (FAILED(hr))
              return hr;

           if (dwFlags & DMO_SET_TYPEF_TEST_ONLY)
              return NOERROR;

           hr = AtomicCopyMediaType(pmt, &m_OutputType, m_bOutputTypeSet);
           if (FAILED(hr)) {
              return hr;
           }

           m_bOutputTypeSet = TRUE;

           if (m_bInputTypeSet) {
              hr = PrepareForStreaming();
              if (FAILED(hr)) {
                 FreeOutputType();
                 return hr;
              }
           }

           return NOERROR;
       }
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {

       if( NULL == pdwStatus ) {
          return E_POINTER;
       }

       PROLOGUE;

       *pdwStatus = 0;
       if (AcceptingInput() == S_OK)
          *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
       return NOERROR;

    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
       PROLOGUE;
       return Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);
       DoFlush();
       return NOERROR;
    }
    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       PROLOGUE;
       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }
       if (AcceptingInput() != S_OK)
          return DMO_E_NOTACCEPTING;
       if (!pBuffer)
          return E_POINTER;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pData;
       ULONG ulSize;
       HRESULT hr = pBuffer->GetBufferAndLength(&pData, &ulSize);
       if (FAILED(hr))
          return hr;
       if (pData == NULL)
          ulSize = 0;

       m_bIncomplete = TRUE; // new input means we may be able to produce output

       return AcceptInput(pData, ulSize, dwFlags, rtTimestamp, rtTimelength, pBuffer);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       HRESULT hr;
       CDMOAutoLock l(&m_cs);

       if (pdwStatus == NULL) {
           return E_POINTER;
       }

       *pdwStatus = 0;

       if (ulOutputBufferCount != 1)
          return E_INVALIDARG;

       if (!TypesSet()) {
          return DMO_E_TYPE_NOT_SET;
       }

       pOutputBuffers[0].dwStatus = 0;

       // deal with the IMediaBuffer so the derived class doesn't have to
       BYTE *pOut = NULL;
       ULONG ulSize = 0;
       ULONG ulAvail = 0;

       if (pOutputBuffers[0].pBuffer) {
           hr = pOutputBuffers[0].pBuffer->GetBufferAndLength(&pOut, &ulSize);
           if (FAILED(hr)) return hr;
           hr = pOutputBuffers[0].pBuffer->GetMaxLength(&ulAvail);
           if (FAILED(hr)) return hr;

           if (ulSize) { // skip any already used portion of the buffer
              if (ulSize > ulAvail)
                 return E_INVALIDARG;
              ulAvail -= ulSize;
              pOut += ulSize;
           }
       }
       else { // no IMediaBuffer
           //
           // If (a) the output stream says it can operate without buffers, AND
           //    (b) the DISCARD flag was set in dwReserved,
           // then call ProduceOutput with a NULL output buffer pointer.
           //
           // Otherwise just return the INCOMPLETE flag without any processing.
           //
           DWORD dwFlags;
           if (SUCCEEDED(GetOutputFlags(&dwFlags)) &&
               ((dwFlags & DMO_OUTPUT_STREAMF_DISCARDABLE) ||
                (dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)
               ) &&
               (dwReserved & DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER))
           { // process, but discard the output
               pOut = NULL;
               ulAvail = 0;
           }
           else { // just report the incomplete status without altering our state
              if (m_bIncomplete)
                 pOutputBuffers[0].dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
              return NOERROR;
           }
       }

       ULONG ulProduced = 0;

       if (0 == (dwReserved & DMO_PROCESS_OUTPUT_FLUSH_SAMPLES))
       {
           hr = ProduceOutput(pOut,
                              ulAvail,
                              &ulProduced,
                              &(pOutputBuffers[0].dwStatus),
                              &(pOutputBuffers[0].rtTimestamp),
                              &(pOutputBuffers[0].rtTimelength));
       }
       else
       {
           hr = FlushOutput(pOut,
                            ulAvail,
                            &ulProduced,
                            &(pOutputBuffers[0].dwStatus),
                            &(pOutputBuffers[0].rtTimestamp),
                            &(pOutputBuffers[0].rtTimelength));
       }

       if (FAILED(hr))
          return hr;

       HRESULT hrProcess = hr; // remember this in case it's S_FALSE

       // remember the DMO's incomplete status
       if (pOutputBuffers[0].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
          m_bIncomplete = TRUE;
       else
          m_bIncomplete = FALSE;

       if (pOut) { // if using an output buffer, set the amount we used
           if (ulProduced > ulAvail)
              return E_FAIL;

           hr = pOutputBuffers[0].pBuffer->SetLength(ulSize + ulProduced);
           if (FAILED(hr))
              return hr;
       }

       return hrProcess;
    }

#ifdef FIX_LOCK_NAME
    STDMETHODIMP DMOLock(LONG lLock)
#else
    STDMETHODIMP Lock(LONG lLock)
#endif
    {
        if (lLock) {
#ifdef DMO_NOATL
            EnterCriticalSection(&m_cs);
#else
            m_cs.Lock();
#endif
        } 
        else 
        {
#ifdef DMO_NOATL
            LeaveCriticalSection(&m_cs);
#else
            m_cs.Unlock();
#endif
        }
        return S_OK;
    }

protected:
    HRESULT AtomicCopyMediaType(const DMO_MEDIA_TYPE *pmtSource, DMO_MEDIA_TYPE *pmtDestination, BOOL bDestinationInitialized) {

       // pmtDestination should always point to a valid DMO_MEDIA_TYPE structure.
       assert(NULL != pmtDestination);

       DMO_MEDIA_TYPE mtTempDestination;

       // actually set the type
       HRESULT hr = MoCopyMediaType(&mtTempDestination, pmtSource);
       if (FAILED(hr)) {
          return hr;
       }

       // Free any previous mediatype
       if (bDestinationInitialized) {
          MoFreeMediaType(pmtDestination);
       }

       *pmtDestination = mtTempDestination;

        return S_OK;
    }

    //
    // private methods for use by derived class
    //
    DMO_MEDIA_TYPE *InputType() {
       if (m_bInputTypeSet)
          return &m_InputType;
       else
          return NULL;
    }
    DMO_MEDIA_TYPE *OutputType() {
       if (m_bOutputTypeSet)
          return &m_OutputType;
       else
          return NULL;
    }

protected:
    //
    // To be overriden by the derived class
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0; // default implementation assumes no lookahead
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = 0;
       return NOERROR;
    }

    virtual HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       return DMO_E_NO_MORE_ITEMS; // default implementation exposes no types
    }
    virtual HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }
    virtual HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
       if ((pmt == NULL) || ((pmt->cbFormat > 0) && (pmt->pbFormat == NULL)))
          return E_POINTER;
       return S_OK; // default implementation accepts anything
    }

    virtual HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pcbMaxLookahead = 0; // default implementation assumes no lookahead
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }
    virtual HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       *pulSize = 1; // default implementation imposes no size requirements
       *pulAlignment = 1; // default implementation assumes no alignment
       return NOERROR;
    }

    virtual HRESULT PrepareForStreaming() {
       return NOERROR;
    }
    virtual HRESULT AcceptingInput() {
       return S_FALSE;
    }
    virtual HRESULT Discontinuity() {
       return NOERROR;
    }
    virtual HRESULT DoFlush() {
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pMediaBuffer
    ) {
       m_bIncomplete = FALSE;
       return S_FALSE;
    }
    virtual HRESULT ProduceOutput(BYTE *pData,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       return S_FALSE;
    }

    //
    // May be overriden by the derived class
    //
    virtual HRESULT FlushOutput(BYTE *pData,
                                ULONG ulAvail,
                                ULONG* pulUsed,
                                DWORD* pdwStatus,
                                REFERENCE_TIME *prtTimestamp,
                                REFERENCE_TIME *prtTimelength)
    {
        return NOERROR;
    }

    HRESULT ValidateSetTypeParameters(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
       // Validate parameters.
       if (!(DMO_SET_TYPEF_CLEAR & dwFlags)) {
          // The DMO specification states that pmt CANNOT be NULL if
          // the DMO_SET_TYPEF_CLEAR flag is NOT set.
          if (NULL == pmt) {
             return E_POINTER;
          }
       }

       // The caller cannot set the DMO_SET_TYPEF_CLEAR flag and the 
       // DMO_SET_TYPEF_TEST_ONLY flag.  The DMO specification prohibits 
       // this combination because the two flags are mutually exclusive.
       if ((DMO_SET_TYPEF_CLEAR & dwFlags) && (DMO_SET_TYPEF_TEST_ONLY & dwFlags)) {
          return E_INVALIDARG;
       }

       // Check for illegal flags.
       if (~(DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY) & dwFlags) {
            return E_INVALIDARG;
       }

       return S_OK;
    }

    bool TypesSet() {
        return m_bInputTypeSet && m_bOutputTypeSet;
    }

    void FreeInputType() {
       if (m_bInputTypeSet) {
          MoFreeMediaType( &m_InputType );
          m_bInputTypeSet = FALSE;
       }
    }

    void FreeOutputType() {
       if (m_bOutputTypeSet) {
          MoFreeMediaType( &m_OutputType );
          m_bOutputTypeSet = FALSE;
       }
    }

protected:
    // mediatype stuff
    BOOL m_bInputTypeSet;
    BOOL m_bOutputTypeSet;
    DMO_MEDIA_TYPE m_InputType;
    DMO_MEDIA_TYPE m_OutputType;

    BOOL m_bIncomplete;
protected:
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};



//
// C1for1DMO - base class for 1-input/1-output DMOs which
//  - work on whole samples at a time, one sample per buffer
//  - produce exactly one output sample for every input sample
//  - don't need to accumulate more than 1 input sample before producing
//  - don't produce any additional stuff at the end
//  - the output sample corresponds in time to the input sample
//
// The derived class must implement:
//    HRESULT Process(BYTE* pIn,
//                    ULONG ulBytesIn,
//                    BYTE* pOut,
//                    ULONG* pulProduced);
//    HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
//                           ULONG* pulMaxOutputSampleSize);
//
//
// The derived class should implement:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
//
// The derived class may implement if it needs to:
//    HRESULT Init();
//
// The following methods are implemented by the base class.  The derived class
// should call these to find out if the input/output type has been set and if
// so what it was set to.
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//

class C1for1DMO : public C1in1outDMO
{
public:
    C1for1DMO() :
       m_pBuffer(NULL)
    {
    }
    ~C1for1DMO() {
       if (m_pBuffer)
          m_pBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    virtual HRESULT GetInputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }
    virtual HRESULT GetOutputFlags(DWORD* pdwFlags) {
       *pdwFlags = DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
       return NOERROR;
    }

    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxInputSize;
       *pcbMaxLookahead = 0;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       *pulSize = m_ulMaxOutputSize;
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT PrepareForStreaming() {
       HRESULT hr = GetSampleSizes(&m_ulMaxInputSize, &m_ulMaxOutputSize);
       if (FAILED(hr))
          return hr;

       return Init();
    }
    HRESULT AcceptingInput() {
       return m_pBuffer ? S_FALSE : S_OK; // accept unless holding one already
    }
    HRESULT AcceptInput(BYTE* pData,
                        ULONG ulSize,
                        DWORD dwFlags,
                        REFERENCE_TIME rtTimestamp,
                        REFERENCE_TIME rtTimelength,
                        IMediaBuffer* pMediaBuffer
    ) {
       if (AcceptingInput() != S_OK)
          return E_FAIL;
       m_pData        = pData;
       m_ulSize       = ulSize;
       m_dwFlags      = dwFlags;
       m_rtTimestamp  = rtTimestamp;
       m_rtTimelength = rtTimelength;
       m_pBuffer      = pMediaBuffer;
       pMediaBuffer->AddRef();
       return NOERROR;
    }
    HRESULT DoFlush() {
       Discontinuity();
       if (m_pBuffer) {
          m_pBuffer->Release();
          m_pBuffer = NULL;
       }
       return NOERROR;
    }
    HRESULT ProduceOutput(BYTE *pOut,
                          ULONG ulAvail,
                          ULONG* pulUsed,
                          DWORD* pdwStatus,
                          REFERENCE_TIME *prtTimestamp,
                          REFERENCE_TIME *prtTimelength
    ) {
       *pulUsed = 0;
       *pdwStatus = 0;

       if (!m_pBuffer)
          return S_FALSE;

       if (pOut) {
          if (ulAvail < m_ulMaxOutputSize)
             return E_INVALIDARG;
       }

       HRESULT hr = Process(m_pData, m_ulSize, pOut, pulUsed);

       m_pBuffer->Release();
       m_pBuffer = NULL;

       if (FAILED(hr))
          return hr;

       if (*pulUsed == 0)
          return S_FALSE;

       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_SYNCPOINT)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;
       if (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIMELENGTH)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
       *prtTimestamp = m_rtTimestamp;
       *prtTimelength = m_rtTimelength;

       return hr;
    }
protected:
    //
    // To be implemented by derived class
    //
    virtual HRESULT Process(BYTE* pIn,
                            ULONG ulBytesIn,
                            BYTE* pOut,
                            ULONG* pulProduced) = 0;
    virtual HRESULT GetSampleSizes(ULONG* pulMaxInputSampleSize,
                                   ULONG* pulMaxOutputSampleSize) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

   IMediaBuffer* m_pBuffer;
   BYTE* m_pData;
   ULONG m_ulSize;
   DWORD m_dwFlags;
   REFERENCE_TIME m_rtTimestamp;
   REFERENCE_TIME m_rtTimelength;

   ULONG m_ulMaxOutputSize;
   ULONG m_ulMaxInputSize;
};

//
// C1for1QCDMO - adds an IDMOQualityControl implementation to C1for1DMO. Just like
// C1for1DMO, this base class assumes that the DMO produces exactly one output sample
// for each input sample, etc. etc.
//
// A class that derives from C1for1QCDMO has access to / ability to override all
// the same methods as with C1for1DMO, except
//   (1) A class derived from C1for1QCDMO should override QCProcess instead of
//       Process because C1for1QCDMO::Process implements some code required for
//       quality control.  QCProcess has the same prototype as C1for1DMO::Process.
//   (2) If a class derived from C1for1QCDMO overrides Init(), it should at some
//       point call C1for1QCDMO::Init() to make sure C1for1QCDMO's quality control
//       data members are properly initialized.
//
class C1for1QCDMO : public C1for1DMO, public IDMOQualityControl {
public:
   //
   // IDMOQualityControl
   //
   STDMETHODIMP SetNow(REFERENCE_TIME rtNow) {
      // Remember SetNow values even if quality control is not currently enabled
      DWORD dwTicks = GetTickCount();
      CDMOAutoLock l(&m_cs);
      m_rtNow = rtNow;
      m_dwNow = dwTicks;
      return NOERROR;
   }
   STDMETHODIMP SetStatus(DWORD dwFlags) {
      // Any point in grabbing the object lock here ?
      if (dwFlags & DMO_QUALITY_STATUS_ENABLED)
         m_bQualityControlEnabled = TRUE;
      else
         m_bQualityControlEnabled = FALSE;
      return NOERROR;
   }
   STDMETHODIMP GetStatus(DWORD *pdwFlags) {
      // Any point in grabbing the object lock here ?
      if (m_bQualityControlEnabled)
         *pdwFlags = DMO_QUALITY_STATUS_ENABLED;
      else
         *pdwFlags = 0;
      return NOERROR;
   }

protected:
   HRESULT Init() {
      m_bQualityControlEnabled = FALSE;
      m_rtProcess = 100000; // 10 ms - initial guess at processing time
      return NOERROR;
   }

   // Override Process to add quality control
   HRESULT Process(BYTE* pIn,ULONG ulBytesIn,BYTE* pOut,ULONG* pulProduced) {
      // Skip the sample if it is likely to be late.
      if (m_bQualityControlEnabled &&
          (m_dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) &&   // timestamp present
          (m_rtNow + (GetTickCount() - m_dwNow) * 10000 + m_rtProcess > m_rtTimestamp + 0000000)) {
         *pulProduced = 0;
         return S_FALSE;
      }

      DWORD dwBefore = GetTickCount();
      HRESULT hr = QCProcess(m_pData, m_ulSize, pOut, pulProduced);
      DWORD dwAfter = GetTickCount();

      // Make the new m_rtProcess a weighted average of the old m_rtProcess
      // and the value we just got.  0.8 and 0.2 give a time constant of about 4,
      // and it takes about 10 iterations to reach 90% - seems reasonable, but
      // I don't know what the optimal value is.
      m_rtProcess = (REFERENCE_TIME)(0.8 * m_rtProcess + 0.2 * (((REFERENCE_TIME)(dwAfter - dwBefore)) * 10000));
      return hr;
   }

   // To be implemented by derived class
   virtual HRESULT QCProcess(BYTE* pIn,
                             ULONG ulBytesIn,
                             BYTE* pOut,
                             ULONG* pulProduced) = 0;

private:
   // variables used by quality control code
   BOOL m_bQualityControlEnabled;
   REFERENCE_TIME m_rtNow;
   DWORD m_dwNow;
   REFERENCE_TIME m_rtProcess; // average processing delay
};

//
// CFBRDMO - DMO base class for 'fixed bitrate' DMOs.  More specifically,
// this base class assumes the following:
//  - 1 input, 1 output;
//  - both input and output consist of equally sized 'quanta';
//  - input/output quantum sizes can be determined from mediatypes;
//  - each output quantum can be generated independently (without looking at
//     previous output quanta);
//  - if multiple input quanta are needed to generate a particular output
//     quantum ('window overhead'), then the range of input required has an upper
//     bound derived from mediatypes on both sides (i.e., both 'lookahead'
//     and 'input memory' are bounded).
//
// The derived class must implement the following virtual functions:
//    HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut);
//    HRESULT GetStreamingParams(
//       DWORD *pdwInputQuantumSize, // in bytes
//       DWORD *pdwOutputQuantumSize, // in bytes
//       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
//       DWORD *pdwLookBehind,
//       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
//       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
//    );
// The derived class should also implement the following:
//    HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt);
//    HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt);
// The derived class may need to implement the followng:
//    HRESULT Init();
//    HRESULT Discontinuity();
//
// The derived class may use these entry points into the base class to get
// the currently set mediatypes:
//    DMO_MEDIA_TYPE *InputType();
//    DMO_MEDIA_TYPE *OutputType().
//
// The sum of *pdwMaxLookahead and *pdwLoookbehind is the 'window overhead' of
// the algorithm (the window overhead is 0 if the algorithm only needs the
// current input sample).
//
// Because the non-zero window overhead case is more complicated, it is handled by a
// separate set of functions in this base class.  The names of all non-zero
// window overhead functions have the 'NZWO' prefix.  The names of the
// zero window overhead functions begin with 'ZWO'.
//
// A data copy on the input side is necessary in the non-zero window overhead case.
//

class CFBRDMO : public C1in1outDMO
{
public:
    CFBRDMO() :
       m_bParametersSet(FALSE),
       m_pMediaBuffer(NULL),
       m_pAllocAddr(NULL),
       m_bStreaming(FALSE)
    {
    }
    ~CFBRDMO() {
       /*
       if (m_bStreaming)
          StopStreaming();
       */
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;
       if (m_pMediaBuffer)
          m_pMediaBuffer->Release();
    }

protected:
    //
    // Implement C1in1outDMO overridables
    //
    HRESULT GetInputSizeInfo(ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       //
       // For efficiency reasons we might like to be fed fairly large amounts
       // of data at a time, but technically all we need is one quantum.
       //
       *pulSize = m_ulInputQuantumSize;
       *pcbMaxLookahead = 0; // this base class does not rely on HOLDS_BUFFERS
       *pulAlignment = 1;
       return NOERROR;
    }
    HRESULT GetOutputSizeInfo(ULONG *pulSize, ULONG *pulAlignment) {
       if (!(InputType() && OutputType()))
          return DMO_E_TYPE_NOT_SET;
       *pulSize = m_ulOutputQuantumSize;
       *pulAlignment = 1;
       return NOERROR;
    }

    virtual HRESULT Discontinuity() {
       m_bDiscontinuity = TRUE;
       return NOERROR;
    }

    virtual HRESULT AcceptInput(BYTE* pData,
                                ULONG ulSize,
                                DWORD dwFlags,
                                REFERENCE_TIME rtTimestamp,
                                REFERENCE_TIME rtTimelength,
                                IMediaBuffer* pBuffer
    ) {
       BOOL bTimestamp = (dwFlags & DMO_INPUT_DATA_BUFFERF_TIME) ? TRUE : FALSE;

       if (m_ulWindowOverhead)
          return NZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
       else
          return ZWOProcessInput(pBuffer, pData, ulSize, bTimestamp, rtTimestamp);
    }
    virtual HRESULT ProduceOutput(BYTE *pOut,
                                  ULONG ulAvail,
                                  ULONG* pulUsed,
                                  DWORD* pdwStatus,
                                  REFERENCE_TIME *prtTimestamp,
                                  REFERENCE_TIME *prtTimelength
    ) {
       HRESULT hr;
       if (!m_bParametersSet)
          return DMO_E_TYPE_NOT_SET;

       // call Discontinuity() if this is the first ProcessOutput() call
       if (!m_bStreaming) {
          HRESULT hr = Discontinuity();
          if (FAILED(hr))
             return hr;
          m_bStreaming = TRUE;
       }

       *pdwStatus = 0;

       ULONG ulInputQuantaAvailable = InputQuantaAvailable();
       if (!ulInputQuantaAvailable)
          return S_FALSE; // did not produce anything

       ULONG ulOutputQuantaPossible = ulAvail / m_ulOutputQuantumSize;
       if (!ulOutputQuantaPossible)
          return E_INVALIDARG;

       ULONG ulQuantaToProcess = min(ulOutputQuantaPossible, ulInputQuantaAvailable);
       assert(ulQuantaToProcess > 0);

       BOOL bTimestamp = 0;
       if (m_ulWindowOverhead)
          hr = NZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       else
          hr = ZWOProcessOutput(pOut, ulQuantaToProcess, &bTimestamp, prtTimestamp);
       if (FAILED(hr))
          return hr;

       *pulUsed = ulQuantaToProcess * m_ulOutputQuantumSize;

       *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
       if (bTimestamp)
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_TIME;

       // any data left ?
       if (InputQuantaAvailable()) // yes - set incomplete
          *pdwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;
       else if (m_bDiscontinuity) // no - process any discontinuity
          DoFlush();

       return NOERROR;
    }
    HRESULT DoFlush()
    {
       Discontinuity();
       // reset flags
       m_bDiscontinuity = FALSE;
       m_bTimestamps = FALSE;

       if (m_ulWindowOverhead)
          NZWODiscardData();
       else
          ZWODiscardData();

       return NOERROR;
    }
    HRESULT AcceptingInput() {
       if (!m_bParametersSet) // uninitialized
          return S_FALSE;

       BOOL bResult;
       if (m_ulWindowOverhead)
          bResult = NZWOQueryAccept();
       else
          bResult = ZWOQueryAccept();

       return bResult ? S_OK : S_FALSE;
    }
    // End C1in1out overridables implementation

private:
    //
    // Common private code (window overhead or no window overhead)
    //
    // returns the number of input quanta available minus any window overhead
    ULONG InputQuantaAvailable() {
       if (m_ulWindowOverhead)
          return NZWOAvail();
       else
          return ZWOAvail();
    }

    // Private method to compute/allocate stuff once all types have been set.
    HRESULT PrepareForStreaming () {
       m_bParametersSet = FALSE;
       // Now that both types are set, query the derived class for params
       HRESULT hr;
       if (FAILED(hr = GetStreamingParams(&m_ulInputQuantumSize,
                               &m_ulOutputQuantumSize,
                               &m_ulLookahead,
                               &m_ulLookbehind,
                               &m_rtDurationNumerator,
                               &m_rtDenominator)))
          return hr;

       // m_ulOutputQuantumSize and m_ulInputQuantumSize should never be 0.
       assert( (0 != m_ulInputQuantumSize) && (0 != m_ulOutputQuantumSize) );

       if (!m_rtDenominator) {
          assert(!"bad object - duration denominator should not be 0 !");
          return E_FAIL;
       }
       // Attempt to reduce the fraction.  Probably the most complicated number
       // we will ever see is 44100 = (3 * 7 * 2 * 5) ^ 2, so trying the first
       // few numbers should suffice in most cases.
       DWORD dwP[] = {2,3,5,7,11,13,17,19,23,29,31};
       for (DWORD c = 0; c < sizeof(dwP) / sizeof(DWORD); c++) {
          while ((m_rtDurationNumerator % dwP[c] == 0) &&
                 (m_rtDenominator % dwP[c] == 0)) {
             m_rtDurationNumerator /= dwP[c];
             m_rtDenominator /= dwP[c];
          }
       }

       // We cannot afford to have huge denominators, unfortunately, because
       // we store timestamp numerators using 64 bits, so a large denominator
       // could result in timestamp overflows.  So if the denominator is still
       // too large, reduce it anyway with loss of precision.
       ULONG ulMax = 0x10000; // largest acceptable denominator value
       if (m_rtDenominator >= ulMax) {
          double actual_ratio = (double)m_rtDurationNumerator * (double)m_rtDenominator;
          ULONG ulDenominator = 1;
          // Repeatedly increase the denominator until either the actual ratio
          // can be represented precisely using the denominator, or the
          // denominator gets too large.
          do {
             double fractional_part = actual_ratio * (double)ulDenominator
                                    - floor(actual_ratio * (double)ulDenominator);
             if (fractional_part == 0)
                break;
             ULONG ulNewDenominator = (ULONG)floor(ulDenominator / fractional_part);
             if (ulNewDenominator >= ulMax)
                break;
             ulDenominator = ulNewDenominator;
          } while(1);
          m_rtDurationNumerator = (ULONG)floor(actual_ratio * ulDenominator);
          m_rtDenominator = ulDenominator;
       }

       m_ulWindowOverhead = m_ulLookahead + m_ulLookbehind;
       if (!m_ulWindowOverhead) // No window overhead - the simple case
          m_bParametersSet = TRUE;
       else // The complicated case with window overhead
          AllocateCircularBuffer();

       m_bTimestamps = FALSE;
       m_bDiscontinuity = FALSE;

       if (m_bStreaming) {
          //StopStreaming();
          m_bStreaming = FALSE;
       }
       
       hr = Init();
       if( FAILED( hr ) ) {
          m_bParametersSet = FALSE;
          return hr;
       }

       return m_bParametersSet ? NOERROR : E_FAIL;
    }
    // end common code

    //
    // zero window overhead case code
    //
    HRESULT ZWOProcessInput(IMediaBuffer* pBuffer,
                                     BYTE* pData,
                                     ULONG ulSize,
                                     BOOL bTimestamp,
                                     REFERENCE_TIME rtTimestamp) {
       assert(!m_pMediaBuffer);

       m_bTimestamp = bTimestamp;
       m_rtTimestamp = rtTimestamp;
       m_pData = pData;
       m_ulData = ulSize;
       m_ulUsed = 0;

       // make sure they gave us a meaningful amount of data
       if (m_ulData < m_ulInputQuantumSize)
          return S_FALSE;

       // save the buffer we were given
       m_pMediaBuffer = pBuffer;
       pBuffer->AddRef();
       return NOERROR;
    }
    HRESULT ZWOProcessOutput(BYTE* pOut,
                                      ULONG ulQuantaToProcess,
                                      BOOL* pbTimestamp,
                                      REFERENCE_TIME* prtTimestamp) {
       assert(m_ulUsed % m_ulInputQuantumSize == 0);
       HRESULT hr = FBRProcess(ulQuantaToProcess, m_pData + m_ulUsed, pOut);
       if (FAILED(hr)) return hr;
       ZWOConsume(ulQuantaToProcess);

       if (m_bTimestamp) { // there was a timestamp on this input buffer
          // m_rtTimestamp refers to the beginning of the input buffer.
          // Extrapolate to the beginning of the area we just processed.
          *prtTimestamp = m_rtTimestamp +
               (m_ulUsed % m_ulInputQuantumSize) * m_rtDurationNumerator /
                                                   m_rtDenominator;
          *pbTimestamp = TRUE;
       }
       else if (m_bTimestamps) { // there was a timestamp earlier
          // bugbug: should we extrapolate from a previous timestamp ?
          *pbTimestamp = FALSE;
       }
       else // no timestamps at all
          *pbTimestamp = FALSE;

       return NOERROR;
    }
    ULONG ZWOAvail() {
       if (m_pMediaBuffer) {
          assert(m_ulData - m_ulUsed >= m_ulInputQuantumSize);
          return (m_ulData - m_ulUsed) / m_ulInputQuantumSize;
       }
       else
          return 0;
    }
    void ZWOConsume(ULONG ulN) { // the zero window overhead version
       assert(m_pMediaBuffer);
       m_ulUsed += ulN * m_ulInputQuantumSize;
       assert(m_ulData >= m_ulUsed);
       if (m_ulData - m_ulUsed < m_ulInputQuantumSize) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    BOOL ZWOQueryAccept() {
        // Accept if and only if (IFF) the DMO is not already holding a buffer.
       if (!m_pMediaBuffer)
          return TRUE;
       else
          return FALSE;
    }
    void ZWODiscardData() {
       if (m_pMediaBuffer) {
          m_pMediaBuffer->Release();
          m_pMediaBuffer = NULL;
       }
    }
    // End zero window overhead case code

    //
    // Non zero window overhead case code.
    //
    HRESULT NZWOProcessInput(IMediaBuffer* pBuffer,
                                  BYTE* pData,
                                  ULONG ulSize,
                                  BOOL bTimestamp,
                                  REFERENCE_TIME rtTimestamp) {
       if (bTimestamp) { // process the timestamp
          if (!m_bTimestamps) { // this is the first timestamp we've seen
             // Just getting started - initialize the timestamp to refer to
             // the first input quantum for which we will actually generate
             // output (the first m_ulLookbehind quanta are pure lookbehind and
             // generate no output).
             m_rtTimestampNumerator = rtTimestamp * m_rtDenominator
                                    + m_ulLookbehind * m_rtDurationNumerator;

          }
          else {
             // We are already streaming and just got a new timestamp.  Use it
             // to check if our stored timestamp has somehow drifted away from
             // where it should be and adjust if it is far enough off.

             ULONG ulInputQuantaAvailable = InputQuantaAvailable();
             if (ulInputQuantaAvailable) {
                // ulInputQuantaAvailable is how far back in time the next
                // quantum we would process is located relative the beginning
                // of the new buffer we just received.

                // Compute what the timestamp back there ought to be now.
                REFERENCE_TIME rtTimestampNumerator;
                rtTimestampNumerator = m_rtDenominator * rtTimestamp
                                     - ulInputQuantaAvailable * m_rtDurationNumerator;

                // Adjust the stored timestamp if it is off by more than half
                // the duration of a quantum.  Should also have a DbgLog here.
                if ((m_rtTimestampNumerator >= rtTimestampNumerator + m_rtDurationNumerator / 2) ||
                    (m_rtTimestampNumerator <= rtTimestampNumerator - m_rtDurationNumerator / 2)) {
                   m_rtTimestampNumerator = rtTimestampNumerator;
                }
             }
             else {
                // We must still be accumulating the initial window overhead.
                // Too early to need an adjustment, one would hope.
             }
          }
          m_bTimestamps = TRUE;
       }

       if (BufferUsed() + ulSize > m_ulBufferAllocated)
          return E_FAIL; // need a max input size to prevent this

       // append to our buffer
       AppendData(pData, ulSize);

       // are we ready to produce now ?
       if (NZWOAvail())
          return NOERROR;
       else
          return S_FALSE; // no output can be produced yet
    }
    HRESULT NZWOProcessOutput(BYTE* pOut,
                                   ULONG ulQuantaToProcess,
                                   BOOL* pbTimestamp,
                                   REFERENCE_TIME* prtTimestamp) {
       //
       // Handle any timestamps
       //
       if (m_bTimestamps) {
          // In window overhead mode the stored timestamp refers to the input
          // data immediately after lookbehind, which corresponds to the
          // begining of the output buffer by definition of FDRProcess.
          *prtTimestamp = m_rtTimestampNumerator / m_rtDenominator;
          *pbTimestamp = TRUE;

       }
       else
          *pbTimestamp = FALSE;

       //
       // Handle the data
       //
       HRESULT hr;
       ULONG ulInputNeeded = m_ulInputQuantumSize * (ulQuantaToProcess + m_ulWindowOverhead);
       assert(ulInputNeeded < BufferUsed());
       if (m_ulDataHead + ulInputNeeded <= m_ulBufferAllocated) {
          // No wraparound, everything is easy
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       }
       else { // The data we want to send wraps around the end
          // Q.: does it wrap around inside the window overhead area
          // or inside the main data area ?
          if (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize < m_ulBufferAllocated) {
             // The wraparound occurs inside the main data area.  Advance the
             // window overhead up to the wraparound point by processing some data.
             ULONG ulAdvance = m_ulBufferAllocated - (m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize);
             assert(ulAdvance % m_ulInputQuantumSize == 0);
             ulAdvance /= m_ulInputQuantumSize; // convert to quanta
             assert(ulAdvance > 0);
             assert(ulAdvance < ulQuantaToProcess);
             hr = FBRProcess(ulAdvance,
                             m_pCircularBuffer + m_ulDataHead + m_ulLookbehind * m_ulInputQuantumSize,
                             pOut);
             if (FAILED(hr))
                return hr;
             NZWOConsume(ulAdvance);

             // Adjust stuff so that the code below can act
             // as if this extra process call never happened.
             pOut += m_ulOutputQuantumSize * ulAdvance;
             ulQuantaToProcess -= ulAdvance;
             assert(ulQuantaToProcess > 0);

             // Now the wraparound point should be exactly on the boundary
             // between window overhead and main data.
             assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize == m_ulBufferAllocated);
          } // wraparound in main data

          // When we get here, the wraparound point occurs somewhere inside
          // the window overhead area or right on the border between window overhead and
          // main data.
          assert(m_ulDataHead + m_ulWindowOverhead * m_ulInputQuantumSize >= m_ulBufferAllocated);
          ULONG ulLookaheadToCopy = m_ulBufferAllocated - m_ulDataHead;

          // copy to the special area we reserved at the front
          memcpy(m_pCircularBuffer - ulLookaheadToCopy,
                 m_pCircularBuffer + m_ulDataHead,
                 ulLookaheadToCopy);

          // Now the block we are interested in is all in one piece
          hr = FBRProcess(ulQuantaToProcess,
                          m_pCircularBuffer - ulLookaheadToCopy  + m_ulLookbehind * m_ulInputQuantumSize,
                          pOut);
          if (FAILED(hr))
             return hr;
          NZWOConsume(ulQuantaToProcess);
       } // data handling - wraparound case
       return NOERROR;
    }
    void AllocateCircularBuffer() {
       // free any previously allocated input buffer
       if (m_pAllocAddr)
          delete[] m_pAllocAddr;

       // bugbug: need a better way to decide this number
       m_ulBufferAllocated = max(m_ulInputQuantumSize * 16, 65536L);
       m_ulDataHead = m_ulDataTail = 0;

       // reserve room at the front for copying window overhead
       ULONG ulPrefix = m_ulWindowOverhead * m_ulInputQuantumSize;
       m_pAllocAddr = new BYTE[m_ulBufferAllocated + ulPrefix];
       if (!m_pAllocAddr)
          return;
       m_pCircularBuffer = m_pAllocAddr + ulPrefix;

       m_bParametersSet = TRUE;
    }
    BOOL NZWOQueryAccept() {
       // We are using a temp input buffer.  Is there room to append more ?
       // The answer really depends on how much data they will try to feed
       // us.  Without knowing the maximum input buffer size, we will accept
       // more if the input buffer is less than half full.
       if (2 * BufferUsed() < m_ulBufferAllocated)
          return TRUE;
       else
          return FALSE;
    }
    ULONG NZWOAvail() {
       ULONG ulInputQuantaAvailable = BufferUsed() / m_ulInputQuantumSize;
       if (ulInputQuantaAvailable > m_ulWindowOverhead)
          return ulInputQuantaAvailable - m_ulWindowOverhead;
       else
          return 0;
    }
    void NZWOConsume(ULONG ulN) { // the window overhead version
       assert(ulN * m_ulInputQuantumSize <= BufferUsed());
       m_ulDataHead += ulN * m_ulInputQuantumSize;
       if (m_ulDataHead > m_ulBufferAllocated) //wraparound
          m_ulDataHead -= m_ulBufferAllocated;

       // Advance the timestamp.
       // The same denominator is used for both timestamp and duration.
       m_rtTimestampNumerator += ulN * m_rtDurationNumerator;
    }
    ULONG BufferUsed() {
       if (m_ulDataTail >= m_ulDataHead)
          return m_ulDataTail - m_ulDataHead;
       else
          return m_ulBufferAllocated - (m_ulDataHead - m_ulDataTail);
    }
    void AppendData(BYTE *pData, ULONG ulSize) {
       if (m_ulDataTail + ulSize <= m_ulBufferAllocated) { // no wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, ulSize);
		  m_ulDataTail += ulSize;
       }
       else { // wraparound
          memcpy(m_pCircularBuffer + m_ulDataTail, pData, m_ulBufferAllocated - m_ulDataTail);
          memcpy(m_pCircularBuffer, pData + m_ulBufferAllocated - m_ulDataTail, ulSize - (m_ulBufferAllocated - m_ulDataTail));
		  m_ulDataTail += ulSize;
		  m_ulDataTail -= m_ulBufferAllocated;
       }
    }
    void NZWODiscardData() {
       m_ulDataHead = m_ulDataTail = 0;
    }
    // End window overhead case code


protected:
    //
    // To be implemebted by the derived class
    //
    virtual HRESULT FBRProcess(DWORD cQuanta, BYTE *pIn, BYTE *pOut) = 0;
    virtual HRESULT GetStreamingParams(
                       DWORD *pdwInputQuantumSize, // in bytes
                       DWORD *pdwOutputQuantumSize, // in bytes
                       DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
                       DWORD *pdwLookbehind,
                       REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
                       REFERENCE_TIME *prtDurationDenominator // optional, normally 1
                    ) = 0;
    virtual HRESULT Init() {
       return NOERROR;
    }

private:

    BOOL m_bNewInput;

    // streaming parameters
    BOOL m_bParametersSet;
    ULONG m_ulInputQuantumSize;
    ULONG m_ulOutputQuantumSize;
    ULONG m_ulLookahead;
    ULONG m_ulLookbehind;
    ULONG m_ulWindowOverhead;
    REFERENCE_TIME m_rtDurationNumerator;
    REFERENCE_TIME m_rtDenominator;

    // streaming state
    BOOL m_bTimestamps; // we have seen at least one timestamp
    BOOL m_bDiscontinuity;
    BOOL m_bStreaming;

    // zero window overhead case input data
    IMediaBuffer *m_pMediaBuffer;
    BYTE *m_pData;
    ULONG m_ulData;
    ULONG m_ulUsed;
    BOOL m_bTimestamp; // timestamp on current buffer
    REFERENCE_TIME m_rtTimestamp;

    // window overhead case input data
    BYTE *m_pCircularBuffer;
    BYTE *m_pAllocAddr;
    ULONG m_ulBufferAllocated;
    ULONG m_ulDataHead;
    ULONG m_ulDataTail;
    REFERENCE_TIME m_rtTimestampNumerator; // uses the same denominator as duration

};


// CPCMDMO - base class for PCM audio transform filters.
// Helps non-converting PCM audio transforms with mediatype negotiation.
// Based on CFBRDMO - study that first.
//
// Derived class must implement:
//     FBRProcess()
// Deriver class may implement:
//   Discontinuity() // default implementaion does nothing
//   Init()          // default implementaion does nothing
//   GetPCMParams()    // default implementation proposes 44100/2/16
//   CheckPCMParams()  // default implementation accepts any 8/16 bit format
//   GetWindowParams()   // default implementation assumes no lookahead/lookbehind
//
// This class conveniently provides the following data members accessible
// by the derived class:
//   ULONG m_ulSamplingRate
//   ULONG m_cChannels
//   BOOL m_b8bit
//
#include <mmreg.h>
#include <uuids.h>

class CPCMDMO : public CFBRDMO
{
protected:
   //
   // implement pure virtual CFBRDMO methods
   //
   HRESULT GetInputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, OutputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT GetOutputType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
      if (ulTypeIndex > 0)
         return DMO_E_NO_MORE_ITEMS;
      if (pmt != NULL) {
         HRESULT hr = GetType(pmt, InputType());
         if (FAILED(hr)) {
            return hr;
         }
      }

      return S_OK;
   }
   HRESULT CheckInputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, OutputType());
   }
   HRESULT CheckOutputType(const DMO_MEDIA_TYPE *pmt) {
      return CheckType(pmt, InputType());
   }
   HRESULT Init() {
      return NOERROR;
   }
   HRESULT Discontinuity() {
      return NOERROR;
   }
   HRESULT GetStreamingParams(
              DWORD *pdwInputQuantumSize, // in bytes
              DWORD *pdwOutputQuantumSize, // in bytes
              DWORD *pdwMaxLookahead, // in input quanta, 0 means no lookahead
              DWORD *pdwMaxLookbehind,
              REFERENCE_TIME *prtQuantumDuration, // same for input and output quanta
              REFERENCE_TIME *prtDurationDenominator // optional, normally 1
           ) {
      // Sanity check: all of this should have been taken care of by base class
      DMO_MEDIA_TYPE* pmtIn =  InputType();
      DMO_MEDIA_TYPE* pmtOut = OutputType();
      if (!pmtIn || !pmtOut)
         return DMO_E_TYPE_NOT_SET;
      if (CheckType(pmtIn, NULL) || CheckType(pmtOut, pmtIn))
         return DMO_E_TYPE_NOT_ACCEPTED;

      WAVEFORMATEX *pWave = (WAVEFORMATEX*)pmtIn->pbFormat;

      m_b8bit          = (pWave->wBitsPerSample == 8);
      m_cChannels      = pWave->nChannels;
      m_ulSamplingRate = pWave->nSamplesPerSec;

      *pdwInputQuantumSize    = pWave->nBlockAlign;
      *pdwOutputQuantumSize   = pWave->nBlockAlign;
      *prtQuantumDuration     = 10000000; // rt units per sec
      *prtDurationDenominator = pWave->nSamplesPerSec;

      GetWindowParams(pdwMaxLookahead, pdwMaxLookbehind);
      return NOERROR;
   }

protected:
   //
   // Methods to be overridden by derived class
   //
   // We use this to get lookahead/lookbehind from the derived class
   virtual void GetWindowParams(DWORD *pdwMaxLookahead,
                                DWORD *pdwMaxLookbehind) {
      *pdwMaxLookahead = 0;
      *pdwMaxLookbehind = 0;
   }
   // derived class can override these if it has specific requirements
   virtual void GetPCMParams(BOOL* pb8bit, DWORD* pcChannels, DWORD* pdwSamplesPerSec) {
      // These values are what the DMO will advertise in its media type.
      // Specifying them here does not mean that this is the only acceptable
      // combination - CheckPCMParams() is the ultimate authority on what we will
      // accept.
      *pb8bit = FALSE;
      *pcChannels = 2;
      *pdwSamplesPerSec = 44100;
   }
   virtual BOOL CheckPCMParams(BOOL b8bit, DWORD cChannels, DWORD dwSamplesPerSec) {
      // Default implementation accepts anything.  Override if you have specific
      // requirements WRT sampling rate, number of channels, or bit depth.
      return TRUE;
   }

private:
   //
   // private helpers
   //
   HRESULT GetType(DMO_MEDIA_TYPE* pmt, const DMO_MEDIA_TYPE *pmtOther) {

      HRESULT hr;

      // If the other type is set, enumerate that.  Otherwise propose 44100/2/16.
      if (pmtOther) {
         hr = MoCopyMediaType(pmt, pmtOther);
         if (FAILED(hr)) {
            return hr;
         }
         return NOERROR;
      }

      hr = MoInitMediaType(pmt, sizeof(WAVEFORMATEX));
      if (FAILED(hr))
         return hr;

      pmt->majortype  = MEDIATYPE_Audio;
      pmt->subtype    = MEDIASUBTYPE_PCM;
      pmt->formattype = FORMAT_WaveFormatEx;

      WAVEFORMATEX* pWave = (WAVEFORMATEX*) pmt->pbFormat;
      pWave->wFormatTag = WAVE_FORMAT_PCM;

      BOOL b8bit;
      DWORD cChannels;
      GetPCMParams(&b8bit, &cChannels, &(pWave->nSamplesPerSec));
      pWave->nChannels = (unsigned short)cChannels;
      pWave->wBitsPerSample = (WORD)(b8bit ? 8 : 16);
      pWave->nBlockAlign = (WORD)(pWave->nChannels * pWave->wBitsPerSample / 8);
      pWave->nAvgBytesPerSec = pWave->nSamplesPerSec * pWave->nBlockAlign;
      pWave->cbSize = 0;

      return NOERROR;
   }
   HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DMO_MEDIA_TYPE *pmtOther) {

      if (NULL == pmt) {
         return E_POINTER;
      }

      // verify that this is PCM with a WAVEFORMATEX format specifier
      if ((pmt->majortype  != MEDIATYPE_Audio) ||
          (pmt->subtype    != MEDIASUBTYPE_PCM) ||
          (pmt->formattype != FORMAT_WaveFormatEx) ||
          (pmt->cbFormat < sizeof(WAVEFORMATEX)) ||
          (pmt->pbFormat == NULL))
         return DMO_E_TYPE_NOT_ACCEPTED;

      // If other type set, accept only if identical to that.  Otherwise accept
      // any standard PCM audio.
      if (pmtOther) {
         if (memcmp(pmt->pbFormat, pmtOther->pbFormat, sizeof(WAVEFORMATEX)))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      else {
         WAVEFORMATEX* pWave = (WAVEFORMATEX*)pmt->pbFormat;
         if ((pWave->wFormatTag != WAVE_FORMAT_PCM) ||
             ((pWave->wBitsPerSample != 8) && (pWave->wBitsPerSample != 16)) ||
             (pWave->nBlockAlign != pWave->nChannels * pWave->wBitsPerSample / 8) ||
             (pWave->nAvgBytesPerSec != pWave->nSamplesPerSec * pWave->nBlockAlign) ||
             !CheckPCMParams((pWave->wBitsPerSample == 8), pWave->nChannels, pWave->nSamplesPerSec))
            return DMO_E_TYPE_NOT_ACCEPTED;
      }
      return NOERROR;
   }

protected:
   // format info - the derived class may look at these (but no modify)
   ULONG m_ulSamplingRate;
   ULONG m_cChannels;
   BOOL m_b8bit;
};

//
// CGenericDMO - generic DMO base class.  This is currently the only base
// class for DMOs that have multiple inputs or multiple outputs.
//
// This base class tries to be reasonably generic.  The derived class reports
// how many streams it supports and describes each stream by calling
// CreateInputStreams() and CreateOutputStreams().  Each of these functions
// takes an array of STREAMDESCRIPTOR structures, each of which poits to an
// array of FORMATENTRY structures.
//
// This base class uses CInputStream and COutputStream classes (both derived
// from CStream) to keep track of input and output stream.  However, these
// objects are not visible to the derived class - the derived class only sees
// stream IDs.
//
// One limitation of the scheme use here is that the derived class cannot
// override the GetType/SetType methods individually for each stream.  It must
// either (a) live with a static, finite set of types communicated via the
// STREAMDESCRIPTOR structure, or (b) override all IMediaObject type methods
// and handle type negotiation for all streams itself.
//
// Processing occurs when the base class calles DoProcess (overridden by the
// derived class).  DoProcess receives an array of input buffer structs and
// an array of output buffer structs.  The base class takes care of talking
// to IMediaBuffers, so the derived class only sees actual data pointers.
//

// flags used to communicate with the derived class
enum _INPUT_STATUS_FLAGS {
   INPUT_STATUSF_RESIDUAL // cannot be further processed w/o additional input
};

// These are used to pass buffers between this class and the derived class.
typedef struct _INPUTBUFFER {
   BYTE *pData;                 // [in] - if NULL, the rest are garbage
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [in] - DMO_INPUT_DATA_BUFFERF_XXX
   DWORD dwStatus;              // [out] - INPUT_STATUSF_XXX from above
   REFERENCE_TIME rtTimestamp;  // [in]
   REFERENCE_TIME rtTimelength; // [in]
} INPUTBUFFER, *PINPUTBUFFER;
typedef struct _OUTPUTBUFFER {
   BYTE *pData;                 // [in]
   DWORD cbSize;                // [in]
   DWORD cbUsed;                // [out]
   DWORD dwFlags;               // [out] - DMO_OUTPUT_DATA_BUFFERF_XXX
   REFERENCE_TIME rtTimestamp;  // [out]
   REFERENCE_TIME rtTimelength; // [out]
} OUTPUTBUFFER, *POUTPUTBUFFER;

// Used by derived class to describe the format supported by each stream
typedef struct _FORMATENTRY
{
    const GUID *majortype;
    const GUID *subtype;
    const GUID *formattype;
    DWORD cbFormat;
    BYTE* pbFormat;
} FORMATENTRY;

// These are used by the derived class to described its streams
typedef struct _INPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
   BOOL         bHoldsBuffers;
   DWORD        dwMaxLookahead; // used if HOLDS_BUFFERS set
} INPUTSTREAMDESCRIPTOR;
typedef struct _OUTPUTSTREAMDESCRIPTOR {
   DWORD        cFormats;
   FORMATENTRY *pFormats;
   DWORD        dwMinBufferSize;
} OUTPUTSTREAMDESCRIPTOR;

// Common input/output stream stuff
class CStream {
public:
    DMO_MEDIA_TYPE       m_MediaType;
    BOOL                m_bEOS;
    BOOL                m_bTypeSet;

    DWORD        m_cFormats;
    FORMATENTRY *m_pFormats;
    DWORD        m_dwMinBufferSize;

    //  Should really pass in a format type list
    CStream()
    {
        MoInitMediaType(&m_MediaType, 0);
        m_bTypeSet = FALSE;
        Flush();
    }
    ~CStream()
    {
        MoFreeMediaType(&m_MediaType);
    }
    HRESULT Flush() {
       m_bEOS = FALSE;
       return NOERROR;
    }
    HRESULT StreamInfo(unsigned long *pdwFlags)
    {
       if (pdwFlags == NULL) {
           return E_POINTER;
       }
       *pdwFlags = 0;
       return S_OK;
    }
    HRESULT GetType(ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt)
    {
        if (ulTypeIndex >= m_cFormats) {
            return E_INVALIDARG;
        }
        //  Just return our types
        MoInitMediaType(pmt, m_pFormats[ulTypeIndex].cbFormat);
        pmt->majortype  = *m_pFormats[ulTypeIndex].majortype;
        pmt->subtype    = *m_pFormats[ulTypeIndex].subtype;
        pmt->formattype = *m_pFormats[ulTypeIndex].formattype;
        memcpy(pmt->pbFormat, m_pFormats[ulTypeIndex].pbFormat, m_pFormats[ulTypeIndex].cbFormat);
        return S_OK;
    }
    HRESULT GetCurrentType(DMO_MEDIA_TYPE *pmt)
    {
        if (NULL == pmt) {
            return E_POINTER;
        }

        if (m_bTypeSet) {
           //  BUGBUG check success
           MoCopyMediaType(pmt, &(m_MediaType));
           return S_OK;
        }
        else
           return DMO_E_TYPE_NOT_SET;
    }
    HRESULT SetType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        //  Need to check this
        HRESULT hr = CheckType(pmt, 0);
        if (FAILED(hr)) {
            return hr;
        }
        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR; // check konly
        }
        //  BUGBUG - check success
        MoCopyMediaType(&m_MediaType, pmt);

        m_bTypeSet = TRUE;;
        return S_OK;
    }
    HRESULT CheckType(const DMO_MEDIA_TYPE *pmt, DWORD dwFlags)
    {
        if (pmt == NULL) {
            return E_POINTER;
        }
        //if (dwFlags & ~DMO_SET_TYPEF_NOT_PARTIAL)
        //    return E_INVALIDARG;

        //  Default - check GUIDs

        bool bMatched = false;
        for (DWORD i = 0; i < m_cFormats; i++) {
            const FORMATENTRY *pFormat = &(m_pFormats[i]);
            if (pmt->majortype  == *(pFormat->majortype) &&
                pmt->subtype    == *(pFormat->subtype) &&
                pmt->formattype == *(pFormat->formattype)) {
                bMatched = true;
                break;
            }
        }

        if (bMatched) {
            return S_OK;
        } else {
            return DMO_E_INVALIDTYPE;
        }
    }
    HRESULT SizeInfo(ULONG *plSize, ULONG *plAlignment)
    {
        if (plSize == NULL || plAlignment == NULL) {
            return E_POINTER;
        }

        *plAlignment = 1;
        *plSize      = m_dwMinBufferSize;
        return S_OK;
    }
};

// Input stream specific stuff
class CInputStream : public CStream {
public:
    BOOL         m_bHoldsBuffers;
    DWORD        m_dwMaxLookahead; // used if HOLDS_BUFFERS set

    // Current input sample
    IMediaBuffer *m_pMediaBuffer;
    DWORD m_dwFlags; // discontinuity, etc.
    REFERENCE_TIME m_rtTimestamp;
    REFERENCE_TIME m_rtTimelength;
    BYTE *m_pData;
    DWORD m_cbSize;
    DWORD m_cbUsed;

    // residual
    BYTE *m_pbResidual;
    DWORD m_cbResidual;
    DWORD m_cbResidualBuffer;

    // temporary buffer for handling the residual
    BYTE *m_pbTemp;

   HRESULT Flush() {
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      return CStream::Flush();
   }
   CInputStream() {
      m_pMediaBuffer = NULL;
      m_pbResidual = NULL;
      m_pbTemp = NULL;
   }
   ~CInputStream() {
      if (m_pMediaBuffer)
         m_pMediaBuffer->Release();
      if (m_pbResidual)
         delete[] m_pbResidual;
   }
   HRESULT StreamInfo(DWORD *pdwFlags) {
      HRESULT hr = CStream::StreamInfo(pdwFlags);
      if (FAILED(hr))
         return hr;
      if (m_bHoldsBuffers)
         *pdwFlags |= DMO_INPUT_STREAMF_HOLDS_BUFFERS;
      return NOERROR;
   }
   HRESULT Init(INPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      m_bHoldsBuffers = pDescriptor->bHoldsBuffers;
      m_dwMaxLookahead = pDescriptor->dwMaxLookahead;

      // Just in case Init is called multiple times:
      // delete any preexisting stuff.
      if (m_pMediaBuffer) {
         m_pMediaBuffer->Release();
         m_pMediaBuffer = NULL;
      }
      if (m_pbResidual) {
         delete[] m_pbResidual;
         m_pbResidual = NULL;
      }

      m_cbResidual = 0;
      m_cbResidualBuffer = m_dwMinBufferSize * 2; // enough ?
      m_pbResidual = new BYTE[m_cbResidualBuffer];

      return NOERROR;
   }
   HRESULT InputStatus(DWORD *pdwStatus) {
       // objects that hold buffers must implement InputStatus themselves
      assert(!m_bHoldsBuffers);
      *pdwStatus = 0;
      if (!m_pMediaBuffer)
         *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
      return NOERROR;
   }
   HRESULT Deliver(
      IMediaBuffer *pBuffer, // [in], must not be NULL
      DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
      REFERENCE_TIME rtTimestamp, // [in], valid if flag set
      REFERENCE_TIME rtTimelength // [in], valid if flag set
   ) {
      if (!pBuffer)
         return E_POINTER;
       // objects that hold buffers must implement Deliver themselves
      assert(!m_bHoldsBuffers);
      DWORD dwStatus = 0;
      InputStatus(&dwStatus);
      if (!(dwStatus & DMO_INPUT_STATUSF_ACCEPT_DATA))
         return DMO_E_NOTACCEPTING;
      assert(!m_pMediaBuffer); // can't hold multiple buffers

      //Deal with the IMediaBuffer
      HRESULT hr;
      hr = pBuffer->GetBufferAndLength(&m_pData, &m_cbSize);
      if (FAILED(hr))
         return hr;

      if (!m_cbSize) // empty buffer
         return S_FALSE; // no data

      pBuffer->AddRef();
      m_pMediaBuffer = pBuffer;
      m_dwFlags = dwFlags;
      m_rtTimestamp = rtTimestamp;
      m_rtTimelength = rtTimelength;
      m_cbUsed = 0;
      return NOERROR;
   }

   //
   // Fetch data from the currently held IMediaBuffer plus any residual
   //
   HRESULT PrepareInputBuffer(INPUTBUFFER *pBuffer)
   {
      // Q.: do we even have any data to give it ?
      if (m_pMediaBuffer) {
         // Is there a residual we need to feed first ?
         if (m_cbResidual) {
            // Yes, prepend the residual to the new input

            // If we have used some of the input buffer by now, we
            // should have also used up any residual with that.
            assert(m_cbUsed == 0);

            // compute how many bytes total we are going to send
            pBuffer->cbSize = m_cbResidual
                                      + m_cbSize;

            // Make sure we have at least dwMinBufferSize bytes of data.
            // We really should - the input buffer alone ought to be at
            // least that big.
            assert(pBuffer->cbSize > m_dwMinBufferSize);

            // Is the residual buffer big enough to hold the residual plus
            // all of the new buffer ?
            if (pBuffer->cbSize <= m_cbResidualBuffer) {
               // Yes - wonderful, we can use the residual buffer
               memcpy(m_pbResidual + m_cbResidual,
                      m_pData,
                      m_cbSize);
               pBuffer->pData = m_pbResidual;
            }
            else {
               // No - allocate a sufficiently large temporary buffer.
               // This is supposed to be a rare case.
               m_pbTemp = new BYTE[pBuffer->cbSize];
               if (m_pbTemp == NULL)
                  return E_OUTOFMEMORY;
               // copy the residual
               memcpy(m_pbTemp,
                      m_pbResidual,
                      m_cbResidual);
               // append the new buffer
               memcpy(m_pbTemp + m_cbResidual,
                      m_pData,
                      m_cbSize);

               // set the buffer pointer to our temp buffer
               pBuffer->pData = m_pbTemp;
            }

            // BUGBUG - is this the correct way to handle timestamps &
            // discontinuities when handling a residual ?
            pBuffer->dwFlags = 0;
         }
         else { // no residual
            pBuffer->pData = m_pData + m_cbUsed;
            pBuffer->cbSize = m_cbSize - m_cbUsed;
            pBuffer->dwFlags = m_dwFlags;
            pBuffer->rtTimestamp = m_rtTimestamp;
            pBuffer->rtTimelength= m_rtTimelength;
         }
         pBuffer->cbUsed = 0; // derived class should set this
         pBuffer->dwStatus = 0; // derived class should set this
      }
      else {
         pBuffer->pData = NULL;
         pBuffer->cbSize = 0;
      }
      return NOERROR;
   }

   //
   // Save any residual and release the IMediaBuffer as appropriate.
   // Returns TRUE if there is enough data left to call ProcesInput again.
   //
   BOOL PostProcessInputBuffer(INPUTBUFFER *pBuffer)
   {
      BOOL bRet = FALSE;
      // did we even give this stream anything ?
      if (m_pMediaBuffer) {
         // Yes, but did it eat any of it ?
         if (pBuffer->cbUsed) {
            // Did we even get past the residual
            if (pBuffer->cbUsed > m_cbResidual) {
               // Yes - reflect this in the current buffer's cbUsed.
               m_cbUsed += (pBuffer->cbUsed - m_cbResidual);
               m_cbResidual = 0;
            }
            else {
               // No - just subtract from the residual.
               // This is a rather odd case.
               m_cbResidual -= pBuffer->cbUsed;
               memmove(m_pbResidual,
                       m_pbResidual + pBuffer->cbUsed,
                       m_cbResidual);
            }
         }

         // Is there enough left to feed again the next time ?
         if ((m_cbSize - m_cbUsed <
              m_dwMinBufferSize)
              || (pBuffer->dwStatus & INPUT_STATUSF_RESIDUAL)) {
            // No - copy the residual and release the buffer
            memcpy(m_pbResidual,
                   m_pData + m_cbUsed,
                   m_cbSize - m_cbUsed);
            m_cbResidual
              = pBuffer->cbSize - pBuffer->cbUsed;
            m_pMediaBuffer->Release();
            m_pMediaBuffer = NULL;
         }
         else { // Yes - need another Process call to eat remaining input
            bRet = TRUE;
         }

         // Free any temporary buffer we may have used - rare case
         if (m_pbTemp) {
            delete[] m_pbTemp;
            m_pbTemp = NULL;
         }
      }
      return bRet;
   }
   HRESULT Discontinuity() {
      // BUGBUG - implement
      // m_bDiscontinuity = TRUE;
      return NOERROR;
   }
   HRESULT SizeInfo(ULONG *pulSize,
                    ULONG *pulMaxLookahead,
                    ULONG *pulAlignment) {
      HRESULT hr = CStream::SizeInfo(pulSize, pulAlignment);
      if (FAILED(hr))
         return hr;

      if (m_bHoldsBuffers)
         *pulMaxLookahead = m_dwMaxLookahead;
      else
         *pulMaxLookahead = *pulSize;
      return NOERROR;
   }
};

// Output stream specific stuff
class COutputStream : public CStream {
public:
   BOOL m_bIncomplete;
   DWORD m_cbAlreadyUsed; // temp per-stream variable used during Process

   HRESULT Init(OUTPUTSTREAMDESCRIPTOR *pDescriptor) {
      m_cFormats = pDescriptor->cFormats;
      m_pFormats = pDescriptor->pFormats;
      m_dwMinBufferSize = pDescriptor->dwMinBufferSize;
      return NOERROR;
   }

   //
   // Initialize the OUTPUTBUFFER struct with info from the IMediaBuffer
   //
   HRESULT PrepareOutputBuffer(OUTPUTBUFFER *pBuffer, IMediaBuffer *pMediaBuffer, BOOL bNewInput)
   {
      //
      // See if the caller supplied an output buffer
      //
      if (pMediaBuffer == NULL) {
         // This is allowed to be NULL only if (1) the object did not set
         // the INCOMPLETE flag for this stream during the last Process
         // call, and (2) no new input data has been supplied to the object
         // since the last Process call.
         if (bNewInput)
            return E_POINTER;
         if (m_bIncomplete)
            return E_POINTER;

         // ok - initialize assuming no buffer
         pBuffer->cbSize = 0;
         pBuffer->pData = NULL;
      }
      else { // the IMediaBuffer is not NULL - deal with it
         HRESULT hr;
         hr = pMediaBuffer->GetMaxLength(&pBuffer->cbSize);
         if (FAILED(hr))
            return hr;

         hr = pMediaBuffer->GetBufferAndLength(
                 &(pBuffer->pData),
                 &(m_cbAlreadyUsed));
         if (FAILED(hr))
            return hr;

         // Check current size - should we even bother with this ?
         if (m_cbAlreadyUsed) {
            if (m_cbAlreadyUsed >= pBuffer->cbSize)
               return E_INVALIDARG; // buffer already full ?!?
            pBuffer->cbSize -= m_cbAlreadyUsed;
            pBuffer->pData += m_cbAlreadyUsed;
         }
      }

      // It is really the derived class's job to set these, but we
      // will be nice to it and initialize them anyway just in case.
      pBuffer->cbUsed = 0;
      pBuffer->dwFlags = 0;

      return NOERROR;
   }

   //
   // Copy the OUTPUTBUFFER back into the DMO_OUTPUT_DATA_BUFFER (yawn)
   //
   void PostProcessOutputBuffer(OUTPUTBUFFER *pBuffer, DMO_OUTPUT_DATA_BUFFER *pDMOBuffer, BOOL bForceIncomplete) {
      assert(pBuffer->cbUsed <= pBuffer->cbSize);
      if (pDMOBuffer->pBuffer)
         pDMOBuffer->pBuffer->SetLength(pBuffer->cbUsed + m_cbAlreadyUsed);
      pDMOBuffer->dwStatus = pBuffer->dwFlags;
      pDMOBuffer->rtTimestamp = pBuffer->rtTimestamp;
      pDMOBuffer->rtTimelength = pBuffer->rtTimelength;

      // Even if the derived class did not set INCOMPLETE, we may need to
      // set it anyway if some input buffer we are holding still has
      // enough data to call Process() again.
      if (bForceIncomplete)
         pDMOBuffer->dwStatus |= DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

      // remember this output stream's INCOMPLETE state
      if (pDMOBuffer->dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE)
         m_bIncomplete = TRUE;
      else
         m_bIncomplete = FALSE;
   }
};

// Code that goes at the beginning of every IMediaObject method
#define INPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulInputStreamIndex >= m_nInputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    CInputStream *pStream = &m_pInputStreams[ulInputStreamIndex]

#define OUTPUT_STREAM_PROLOGUE \
    CDMOAutoLock l(&m_cs); \
    if (ulOutputStreamIndex >= m_nOutputStreams) \
       return DMO_E_INVALIDSTREAMINDEX; \
    COutputStream *pStream = &m_pOutputStreams[ulOutputStreamIndex]


class CGenericDMO : public IMediaObject
{
public:
    CGenericDMO() {
#ifdef DMO_NOATL
       InitializeCriticalSection(&m_cs);
#endif
       m_nInputStreams = 0;
       m_nOutputStreams = 0;
    }
#ifdef DMO_NOATL
    ~CGenericDMO() {
       DeleteCriticalSection(&m_cs);
    }
#endif

public:
    //
    // Implement IMediaObject methods
    //
    STDMETHODIMP GetInputStreamInfo(ULONG ulInputStreamIndex, DWORD *pdwFlags)
    {
       INPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulOutputStreamIndex, DWORD *pdwFlags)
    {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->StreamInfo(pdwFlags);
    }
    STDMETHODIMP GetInputType(ULONG ulInputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulOutputStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetType(ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulInputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       INPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulOutputStreamIndex, DMO_MEDIA_TYPE *pmt) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->GetCurrentType(pmt);
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulInputStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulOutputStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SizeInfo(pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulInputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       INPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP SetOutputType(ULONG ulOutputStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
       OUTPUT_STREAM_PROLOGUE;
       return pStream->SetType(pmt, dwFlags);
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulInputStreamIndex,
        DWORD *pdwStatus
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->InputStatus(pdwStatus);
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME *prtLatency) {
       // BUGBUG - I don't know what to do with this right now.
       // Punt to the derived class ?
       return E_NOTIMPL;
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulInputStreamIndex, REFERENCE_TIME rtLatency) {
       return E_NOTIMPL;
    }
    STDMETHODIMP ProcessInput(
        DWORD ulInputStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Deliver(pBuffer, dwFlags, rtTimestamp, rtTimelength);
    }
    STDMETHODIMP Discontinuity(ULONG ulInputStreamIndex) {
       INPUT_STREAM_PROLOGUE;
       return pStream->Discontinuity();
    }

    STDMETHODIMP Flush()
    {
       CDMOAutoLock l(&m_cs);

       //  Flush all the streams
       ULONG i;
       for (i = 0; i < m_nInputStreams; i++) {
          m_pInputStreams[i].Flush();
       }
       for (i = 0; i < m_nOutputStreams; i++) {
          m_pOutputStreams[i].Flush();
       }
       return S_OK;
    }

    STDMETHODIMP AllocateStreamingResources() {return S_OK;}
    STDMETHODIMP FreeStreamingResources() {return S_OK;}

    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        CDMOAutoLock l(&m_cs);
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams = m_nInputStreams;
        *pulNumberOfOutputStreams = m_nOutputStreams;
        return S_OK;
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwReserved,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
       CDMOAutoLock l(&m_cs);
       if (ulOutputBufferCount != m_nOutputStreams)
          return E_INVALIDARG;

       HRESULT hr;
       DWORD c;

       // Prepare the input buffers
       for (c = 0; c < m_nInputStreams; c++) {
          // objects that hold buffers must implement Process themselves
          assert(!m_pInputStreams[c].m_bHoldsBuffers);
          hr = m_pInputStreams[c].PrepareInputBuffer(&m_pInputBuffers[c]);
          if (FAILED(hr))
             return hr;
       }

       //
       // Prepare the output buffers
       //
       for (c = 0; c < m_nOutputStreams; c++) {
          hr = m_pOutputStreams[c].PrepareOutputBuffer(&m_pOutputBuffers[c], pOutputBuffers[c].pBuffer, m_bNewInput);
          if (FAILED(hr))
             return hr;
       }

       hr = DoProcess(m_pInputBuffers,m_pOutputBuffers);
       if (FAILED(hr))
          return hr; // BUGBUG - don't just "return hr", do something !

       // post-process input buffers
       BOOL bSomeInputStillHasData = FALSE;
       for (c = 0; c < m_nInputStreams; c++) {
          if (m_pInputStreams[c].PostProcessInputBuffer(&m_pInputBuffers[c]))
             bSomeInputStillHasData = TRUE;
       }

       // post-process output buffers
       for (c = 0; c < m_nOutputStreams; c++) {
          m_pOutputStreams[c].PostProcessOutputBuffer(&m_pOutputBuffers[c],
                                                      &pOutputBuffers[c],
                                                      bSomeInputStillHasData);
       }

       m_bNewInput = FALSE;
       return NOERROR;
    }

protected:
    //
    // These are called by the derived class at initialization time
    //
    HRESULT CreateInputStreams(INPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pInputStreams = new CInputStream[cStreams];

       if (m_pInputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pInputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pInputStreams;
             return hr;
          }
       }

       m_pInputBuffers = new INPUTBUFFER[cStreams];
       if (!m_pInputBuffers) {
          delete[] m_pInputStreams;
          return E_OUTOFMEMORY;
       }

       m_nInputStreams = cStreams;
       return NOERROR;
    }
    HRESULT CreateOutputStreams(OUTPUTSTREAMDESCRIPTOR *pStreams, DWORD cStreams) {
       CDMOAutoLock l(&m_cs);
       if (pStreams == NULL) {
          return E_POINTER;
       }

       m_pOutputStreams = new COutputStream[cStreams];

       if (m_pOutputStreams == NULL) {
          return E_OUTOFMEMORY;
       }

       DWORD c;
       for (c = 0; c < cStreams; c++) {
          HRESULT hr = m_pOutputStreams[c].Init(&(pStreams[c]));
          if (FAILED(hr)) {
             delete[] m_pOutputStreams;
             return hr;
          }
       }
	
       m_pOutputBuffers = new OUTPUTBUFFER[cStreams];
       if (!m_pOutputBuffers) {
          delete[] m_pOutputStreams;
          return E_OUTOFMEMORY;
       }

       m_nOutputStreams = cStreams;
       return NOERROR;
    }

    virtual HRESULT DoProcess(INPUTBUFFER*, OUTPUTBUFFER *) = 0;

private:

    ULONG           m_nInputStreams;
    CInputStream*   m_pInputStreams;
    ULONG           m_nOutputStreams;
    COutputStream*  m_pOutputStreams;

    INPUTBUFFER*    m_pInputBuffers;
    OUTPUTBUFFER*   m_pOutputBuffers;

    BOOL m_bNewInput;
#ifdef DMO_NOATL
    CRITICAL_SECTION m_cs;
#else
    CComAutoCriticalSection m_cs;
#endif
};

#endif // __DMOBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmoreg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __DMOREG_H__
#define __DMOREG_H__

#include "mediaobj.h"


// 57f2db8b-e6bb-4513-9d43-dcd2a6593125
DEFINE_GUID(DMOCATEGORY_AUDIO_DECODER, 0x57f2db8b,0xe6bb,0x4513,0x9d,0x43,0xdc,0xd2,0xa6,0x59,0x31,0x25);
// 33D9A761-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_AUDIO_ENCODER, 0x33D9A761,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// 4a69b442-28be-4991-969c-b500adf5d8a8
DEFINE_GUID(DMOCATEGORY_VIDEO_DECODER, 0x4a69b442,0x28be,0x4991,0x96,0x9c,0xb5,0x00,0xad,0xf5,0xd8,0xa8);
// 33D9A760-90C8-11d0-BD43-00A0C911CE86
DEFINE_GUID(DMOCATEGORY_VIDEO_ENCODER, 0x33D9A760,0x90C8,0x11d0,0xBD,0x43,0x00,0xA0,0xC9,0x11,0xCE,0x86);
// f3602b3f-0592-48df-a4cd-674721e7ebeb
DEFINE_GUID(DMOCATEGORY_AUDIO_EFFECT, 0xf3602b3f,0x0592,0x48df,0xa4,0xcd,0x67,0x47,0x21,0xe7,0xeb,0xeb);
// d990ee14-776c-4723-be46-3da2f56f10b9
DEFINE_GUID(DMOCATEGORY_VIDEO_EFFECT, 0xd990ee14,0x776c,0x4723,0xbe,0x46,0x3d,0xa2,0xf5,0x6f,0x10,0xb9);
// f665aaba-3e09-4920-aa5f-219811148f09
DEFINE_GUID(DMOCATEGORY_AUDIO_CAPTURE_EFFECT, 0xf665aaba,0x3e09,0x4920,0xaa,0x5f,0x21,0x98,0x11,0x14,0x8f,0x09);

// Acoustic Echo Canceller {BF963D80-C559-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_ACOUSTIC_ECHO_CANCEL in ksmedia.h
DEFINE_GUID(DMOCATEGORY_ACOUSTIC_ECHO_CANCEL, 0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

// Noise Supression {E07F903F-62FD-4e60-8CDD-DEA7236665B5}
// Matches KSNODETYPE_AUDIO_NOISE_SUPPRESS in post Windows ME DDK's ksmedia.h
DEFINE_GUID(DMOCATEGORY_AUDIO_NOISE_SUPPRESS, 0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5);

// Automatic Gain Control {E88C9BA0-C557-11D0-8A2B-00A0C9255AC1}
// Matches KSNODETYPE_AGC in ksmedia.h
DEFINE_GUID(DMOCATEGORY_AGC, 0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1);

typedef struct _DMO_PARTIAL_MEDIATYPE {
   GUID type;
   GUID subtype;
} DMO_PARTIAL_MEDIATYPE, *PDMO_PARTIAL_MEDIATYPE;

enum DMO_REGISTER_FLAGS {
   DMO_REGISTERF_IS_KEYED = 0x00000001
};

enum DMO_ENUM_FLAGS {
   DMO_ENUMF_INCLUDE_KEYED = 0x00000001
};

STDAPI DMORegister(
   LPCWSTR szName,
   REFCLSID clsidDMO,
   REFGUID guidCategory,
   DWORD dwFlags, // DMO_REGISTERF_XXX
   //
   // Register all mediatypes supported by the object.  This carries no
   // information about which combinations of input/output types would
   // actually work.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes,
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes
);

STDAPI DMORegisterFilter(
    LPCWSTR szName,
    REFCLSID clsidDMO,
    REFGUID guidCategory,
    REFCLSID clsidAutoWrap,
    DWORD dwFlags, // DMO_REGISTERF_XXX
    unsigned long ulInTypes,
    const DMO_PARTIAL_MEDIATYPE *pInTypes,
    unsigned long ulOutTypes,
    const DMO_PARTIAL_MEDIATYPE *pOutTypes);

STDAPI DMOUnregister(
   REFCLSID clsidDMO,
   REFGUID guidCategory // optional - GUID_NULL means unregister from all
);

STDAPI DMOUnregisterFilter(REFCLSID clsidAutoWrap);

STDAPI DMOEnum(
   REFGUID guidCategory, // GUID_NULL for "all"
   DWORD dwFlags, // DMO_ENUMF_XXX
   //
	// Enumerate only objects that support at least one of the specified input types
	// and at least one of the specified output types.  If no input types are specified,
	// enumerate objects regardless of what input types they support.  Same for
	// output types.
   //
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, // can be NULL only of ulInTypes = 0
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes, // can be NULL only of ulOutTypes = 0
   //
   // Output parameter - this receives a pointer to the DMO CLSID enumerator
   //
   IEnumDMO **ppEnum
);

STDAPI DMOGetTypes(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

STDAPI DMOGetName(
   REFCLSID clsidDMO,
   WCHAR szName[80]
);
#endif //__DMOREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmoimpl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef _dmoimpl_h_
#define _dmoimpl_h_

#include <crtdbg.h>

//  Class to implement a DMO
//
//
//       Assumes the number of input and output streams is fixed
//       (these are template parameters)
//
//       Provides following services:
//
//          Basic parameter checking and locking
//          Fully implements :
//                 GetStreamCount
//                 SetInputType
//                 SetOutputType
//                 GetCurrentInputType
//                 GetCurrentOutputType
//
//          Checks if all types are set before streaming
//          Automatically calls AllocateStreamingResources before streaming
//              if it's not been called already
//          Prevents streaming until the types on all non-optional streams
//              have been set
//
//
//  Derived class implements the following methods :
//
/*
   HRESULT InternalGetInputStreamInfo(DWORD dwInputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalGetOutputStreamInfo(DWORD dwOutputStreamIndex, DWORD *pdwFlags);
   HRESULT InternalCheckInputType(DWORD dwInputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalCheckOutputType(DWORD dwOutputStreamIndex, const DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputType(DWORD dwInputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetOutputType(DWORD dwOutputStreamIndex, DWORD dwTypeIndex,
                            DMO_MEDIA_TYPE *pmt);
   HRESULT InternalGetInputSizeInfo(DWORD dwInputStreamIndex, DWORD *pcbSize,
                            DWORD *pcbMaxLookahead, DWORD *pcbAlignment);
   HRESULT InternalGetOutputSizeInfo(DWORD dwOutputStreamIndex, DWORD *pcbSize,
                             DWORD *pcbAlignment);
   HRESULT InternalGetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME *prtMaxLatency);
   HRESULT InternalSetInputMaxLatency(DWORD dwInputStreamIndex, REFERENCE_TIME rtMaxLatency);
   HRESULT InternalFlush();
   HRESULT InternalDiscontinuity(DWORD dwInputStreamIndex);
   HRESULT InternalAllocateStreamingResources();
   HRESULT InternalFreeStreamingResources();
   HRESULT InternalProcessInput(DWORD dwInputStreamIndex, IMediaBuffer *pBuffer,
                               DWORD dwFlags, REFERENCE_TIME rtTimestamp,
                               REFERENCE_TIME rtTimelength);
   HRESULT InternalProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                               DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                           DWORD *pdwStatus);
   HRESULT InternalAcceptingInput(DWORD dwInputStreamIndex);
   void Lock();
   void Unlock();

   Notes:
       The derived class is meant to do most work to initialize streaming
       in AllocateStreamingResources rather than when types are set.

       This centralizes the work to one
       clear place based on the types set for all streams.

       The derived class implements locking.

       The derived class implements the IUnknown methods

   Usage example (1 input and 1 output) :
   class CMyDMO : public IMediaObjectImpl<CMyDmo, 1, 1>,
                  ...
*/


#define INTERNAL_CALL(_T_, _X_) \
    static_cast<_T_ *>(this)->Internal##_X_

template <class _DERIVED_, int NUMBEROFINPUTS, int NUMBEROFOUTPUTS>
class IMediaObjectImpl : public IMediaObject
{
private:
    // Member variables
    struct {
        DWORD   fTypeSet:1;
        DWORD   fIncomplete:1;
        DMO_MEDIA_TYPE CurrentMediaType;
    } m_InputInfo[NUMBEROFINPUTS], m_OutputInfo[NUMBEROFOUTPUTS];

    bool m_fTypesSet;
    bool m_fFlushed;
    bool m_fResourcesAllocated;

protected:

    //  Helpers
    bool InputTypeSet(DWORD ulInputStreamIndex) const
    {
        _ASSERTE(ulInputStreamIndex < NUMBEROFINPUTS);
        return 0 != m_InputInfo[ulInputStreamIndex].fTypeSet;
    }

    bool OutputTypeSet(DWORD ulOutputStreamIndex) const
    {
        _ASSERTE(ulOutputStreamIndex < NUMBEROFOUTPUTS);
        return 0 != m_OutputInfo[ulOutputStreamIndex].fTypeSet;
    }
    const DMO_MEDIA_TYPE *InputType(DWORD ulInputStreamIndex)
    {
        if (!InputTypeSet(ulInputStreamIndex)) {
            return NULL;
        }
        return &m_InputInfo[ulInputStreamIndex].CurrentMediaType;
    }
    const DMO_MEDIA_TYPE *OutputType(DWORD ulOutputStreamIndex)
    {
        if (!OutputTypeSet(ulOutputStreamIndex)) {
            return NULL;
        }
        return &m_OutputInfo[ulOutputStreamIndex].CurrentMediaType;
    }


    class LockIt
    {
    public:
        LockIt(_DERIVED_ *p) : m_p(p)
        {
            static_cast<_DERIVED_ *>(m_p)->Lock();
        }
        ~LockIt()
        {
            static_cast<_DERIVED_ *>(m_p)->Unlock();
        }
        _DERIVED_ *const m_p;
    };

    bool CheckTypesSet()
    {
        m_fTypesSet = false;
        DWORD dw;
        for (dw = 0; dw < NUMBEROFINPUTS; dw++) {
            if (!InputTypeSet(dw)) {
                return false;
            }
        }
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (!OutputTypeSet(dw)) {
                //  Check if it's optional
                DWORD dwFlags;
#ifdef _DEBUG
                dwFlags = 0xFFFFFFFF;
#endif
                INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(dw, &dwFlags);
                _ASSERTE(0 == (dwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                         DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                         DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                         DMO_OUTPUT_STREAMF_DISCARDABLE |
                                         DMO_OUTPUT_STREAMF_OPTIONAL)));
                if (!(dwFlags & DMO_OUTPUT_STREAMF_OPTIONAL)) {
                    return false;
                }
            }
        }
        m_fTypesSet = true;
        return true;
    }


    IMediaObjectImpl() :
        m_fTypesSet(false),
        m_fFlushed(true),
        m_fResourcesAllocated(false)
    {
        ZeroMemory(&m_InputInfo, sizeof(m_InputInfo));
        ZeroMemory(&m_OutputInfo, sizeof(m_OutputInfo));
    }

    virtual ~IMediaObjectImpl() {
        DWORD dwCurrentType;

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFINPUTS; dwCurrentType++) {
            if(InputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_InputInfo[dwCurrentType].CurrentMediaType);
            }
        }

        for (dwCurrentType = 0; dwCurrentType < NUMBEROFOUTPUTS; dwCurrentType++) {
            if(OutputTypeSet(dwCurrentType)) {
                MoFreeMediaType(&m_OutputInfo[dwCurrentType].CurrentMediaType);
            }
        }
    }


    // IMediaObject methods


    //
    // IMediaObject methods
    //
    STDMETHODIMP GetStreamCount(unsigned long *pulNumberOfInputStreams, unsigned long *pulNumberOfOutputStreams)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (pulNumberOfInputStreams == NULL ||
            pulNumberOfOutputStreams == NULL) {
            return E_POINTER;
        }
        *pulNumberOfInputStreams  = NUMBEROFINPUTS;
        *pulNumberOfOutputStreams = NUMBEROFOUTPUTS;
        return S_OK;
    }
    STDMETHODIMP GetInputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetInputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_INPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_INPUT_STREAMF_HOLDS_BUFFERS)));
        return hr;
    }
    STDMETHODIMP GetOutputStreamInfo(ULONG ulStreamIndex, DWORD *pdwFlags)
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (pdwFlags == NULL) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, GetOutputStreamInfo)(ulStreamIndex, pdwFlags);
        _ASSERTE(0 == (*pdwFlags & ~(DMO_OUTPUT_STREAMF_WHOLE_SAMPLES |
                                   DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER |
                                   DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE |
                                   DMO_OUTPUT_STREAMF_DISCARDABLE |
                                   DMO_OUTPUT_STREAMF_OPTIONAL)));
        return hr;
    }
    STDMETHODIMP GetInputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetInputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetOutputType(ULONG ulStreamIndex, ULONG ulTypeIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        return INTERNAL_CALL(_DERIVED_, GetOutputType)(ulStreamIndex, ulTypeIndex, pmt);
    }
    STDMETHODIMP GetInputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (InputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_InputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetOutputCurrentType(ULONG ulStreamIndex, DMO_MEDIA_TYPE *pmt) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (OutputTypeSet(ulStreamIndex))
            return MoCopyMediaType(pmt,
                                   &m_OutputInfo[ulStreamIndex].CurrentMediaType);
        else
           return DMO_E_TYPE_NOT_SET;
    }
    STDMETHODIMP GetInputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pcbMaxLookahead, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment ||
            NULL == pcbMaxLookahead) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!InputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetInputSizeInfo)(ulStreamIndex, pulSize, pcbMaxLookahead, pulAlignment);
    }
    STDMETHODIMP GetOutputSizeInfo(ULONG ulStreamIndex, ULONG *pulSize, ULONG *pulAlignment) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pulSize || NULL == pulAlignment) {
            return E_POINTER;
        }
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet || !OutputTypeSet(ulStreamIndex)) {
           return DMO_E_TYPE_NOT_SET;
        }
        return INTERNAL_CALL(_DERIVED_, GetOutputSizeInfo)(ulStreamIndex, pulSize, pulAlignment);
    }
    STDMETHODIMP SetInputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            m_InputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckInputType)(ulStreamIndex, pmt);
        if (FAILED(hr))
           return hr;

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (InputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_InputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_InputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_InputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }

    STDMETHODIMP SetOutputType(ULONG ulStreamIndex, const DMO_MEDIA_TYPE *pmt, DWORD dwFlags) {
        if (ulStreamIndex >= NUMBEROFOUTPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~ (DMO_SET_TYPEF_CLEAR | DMO_SET_TYPEF_TEST_ONLY)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (dwFlags & DMO_SET_TYPEF_CLEAR) {
            MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            m_OutputInfo[ulStreamIndex].fTypeSet = FALSE;
            if (!CheckTypesSet()) {
                Flush();
                FreeStreamingResources();
            }
            return NOERROR;
        }
        if (NULL == pmt) {
            return E_POINTER;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, CheckOutputType)(ulStreamIndex, pmt);
        if (FAILED(hr)) {
           return hr;
        }

        if (dwFlags & DMO_SET_TYPEF_TEST_ONLY) {
           return NOERROR;
        }


        // actually set the type
        DMO_MEDIA_TYPE mtTemp;
        if (S_OK == MoCopyMediaType(&mtTemp, pmt)) {
            // Free any previous mediatype
            if (OutputTypeSet(ulStreamIndex)) {
                MoFreeMediaType(&m_OutputInfo[ulStreamIndex].CurrentMediaType);
            }
            m_OutputInfo[ulStreamIndex].CurrentMediaType = mtTemp;
            m_OutputInfo[ulStreamIndex].fTypeSet = TRUE;
            CheckTypesSet();
        } else {
            return E_OUTOFMEMORY;
        }

        return NOERROR;
    }
    STDMETHODIMP GetInputStatus(
        ULONG ulStreamIndex,
        DWORD *pdwStatus
    ) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (NULL == pdwStatus) {
            return E_POINTER;
        }
        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) == S_OK) {
           *pdwStatus |= DMO_INPUT_STATUSF_ACCEPT_DATA;
        }
        return NOERROR;
    }
    STDMETHODIMP GetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME *prtLatency) {

        if (prtLatency == NULL) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, GetInputMaxLatency)(ulStreamIndex, prtLatency);
    }
    STDMETHODIMP SetInputMaxLatency(unsigned long ulStreamIndex, REFERENCE_TIME rtLatency) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        return INTERNAL_CALL(_DERIVED_, SetInputMaxLatency)(ulStreamIndex, rtLatency);
    }
    STDMETHODIMP Discontinuity(ULONG ulStreamIndex) {
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }

        if (S_OK != INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex)) {
            return DMO_E_NOTACCEPTING;
        }

        return INTERNAL_CALL(_DERIVED_, Discontinuity)(ulStreamIndex);
    }

    STDMETHODIMP Flush()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));

        if (!m_fTypesSet) {
            return S_OK;
        }
        if (m_fFlushed) {
            return S_OK;
        }
        HRESULT hr =  INTERNAL_CALL(_DERIVED_, Flush)();
        m_fFlushed = true;
        return hr;
    }

    STDMETHODIMP AllocateStreamingResources() {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (!m_fTypesSet) {
            return DMO_E_TYPE_NOT_SET;
        }
        if (m_fResourcesAllocated) {
            return S_OK;
        }
        HRESULT hr = INTERNAL_CALL(_DERIVED_, AllocateStreamingResources)();
        if (SUCCEEDED(hr)) {
            m_fResourcesAllocated = true;
        }
        return hr;
    }
    STDMETHODIMP FreeStreamingResources()
    {
        LockIt lck(static_cast<_DERIVED_ *>(this));
        if (m_fResourcesAllocated) {
            m_fResourcesAllocated = false;
            INTERNAL_CALL(_DERIVED_, Flush)();
            return INTERNAL_CALL(_DERIVED_, FreeStreamingResources)();
        }
        return S_OK;
    }

    //
    // Processing methods - public entry points
    //
    STDMETHODIMP ProcessInput(
        DWORD ulStreamIndex,
        IMediaBuffer *pBuffer, // [in], must not be NULL
        DWORD dwFlags, // [in] - discontinuity, timestamp, etc.
        REFERENCE_TIME rtTimestamp, // [in], valid if flag set
        REFERENCE_TIME rtTimelength // [in], valid if flag set
    ) {
        if (!pBuffer) {
            return E_POINTER;
        }
        if (ulStreamIndex >= NUMBEROFINPUTS) {
            return DMO_E_INVALIDSTREAMINDEX;
        }
        if (dwFlags & ~(DMO_INPUT_DATA_BUFFERF_SYNCPOINT |
                        DMO_INPUT_DATA_BUFFERF_TIME |
                        DMO_INPUT_DATA_BUFFERF_TIMELENGTH)) {
            return E_INVALIDARG;
        }

        LockIt lck(static_cast<_DERIVED_ *>(this));

        //  Make sure all streams have media types set and resources are allocated
        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }
        if (INTERNAL_CALL(_DERIVED_, AcceptingInput)(ulStreamIndex) != S_OK) {
            return DMO_E_NOTACCEPTING;
        }

        m_fFlushed = false;

        return INTERNAL_CALL(_DERIVED_, ProcessInput)(
                                    ulStreamIndex,
                                    pBuffer,
                                    dwFlags,
                                    rtTimestamp,
                                    rtTimelength);
    }

    STDMETHODIMP ProcessOutput(
                    DWORD dwFlags,
                    DWORD ulOutputBufferCount,
                    DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
                    DWORD *pdwStatus)
    {
        if (pdwStatus == NULL) {
            return E_POINTER;
        }


        if (ulOutputBufferCount != NUMBEROFOUTPUTS || 
            (dwFlags & ~(DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER |
                         DMO_PROCESS_OUTPUT_HIDDEN_VIDEOWINDOW))) {
           return E_INVALIDARG;
        }

        if (NUMBEROFOUTPUTS != 0 && pOutputBuffers == NULL) {
            return E_POINTER;
        }

        *pdwStatus = 0;

        LockIt lck(static_cast<_DERIVED_ *>(this));

        HRESULT hr = AllocateStreamingResources();
        if (FAILED(hr)) {
            return hr;
        }

        for (DWORD dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            pOutputBuffers[dw].dwStatus = 0;
        }

        hr = INTERNAL_CALL(_DERIVED_, ProcessOutput)(
                           dwFlags,
                           ulOutputBufferCount,
                           pOutputBuffers,
                           pdwStatus);

        // remember the DMO's incomplete status
        for (dw = 0; dw < NUMBEROFOUTPUTS; dw++) {
            if (pOutputBuffers[dw].dwStatus & DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE) {
                m_OutputInfo[dw].fIncomplete = TRUE;
            } else {
                m_OutputInfo[dw].fIncomplete = FALSE;
            }
        }

        return hr;
    }

    STDMETHODIMP DMOLock(LONG lLock)
    {
        if (lLock) {
            static_cast<_DERIVED_ *>(this)->Lock();
        } else {
            static_cast<_DERIVED_ *>(this)->Unlock();
        }
        return S_OK;
    }
};

#endif // _dmoimpl_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmodshow.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for dmodshow.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dmodshow_h__
#define __dmodshow_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDMOWrapperFilter_FWD_DEFINED__
#define __IDMOWrapperFilter_FWD_DEFINED__
typedef interface IDMOWrapperFilter IDMOWrapperFilter;
#endif 	/* __IDMOWrapperFilter_FWD_DEFINED__ */


#ifndef __IDMOWrapperFilter2_FWD_DEFINED__
#define __IDMOWrapperFilter2_FWD_DEFINED__
typedef interface IDMOWrapperFilter2 IDMOWrapperFilter2;
#endif 	/* __IDMOWrapperFilter2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "mediaobj.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dmodshow_0000_0000 */
/* [local] */ 

DEFINE_GUID(CLSID_DMOFilterCategory,0xbcd5796c,0xbd52,0x4d30,0xab,0x76,0x70,0xf9,0x75,0xb8,0x91,0x99);


extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dmodshow_0000_0000_v0_0_s_ifspec;

#ifndef __IDMOWrapperFilter_INTERFACE_DEFINED__
#define __IDMOWrapperFilter_INTERFACE_DEFINED__

/* interface IDMOWrapperFilter */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOWrapperFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("52d6f586-9f0f-4824-8fc8-e32ca04930c2")
    IDMOWrapperFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            REFCLSID clsidDMO,
            REFCLSID catDMO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOWrapperFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOWrapperFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOWrapperFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOWrapperFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDMOWrapperFilter * This,
            REFCLSID clsidDMO,
            REFCLSID catDMO);
        
        END_INTERFACE
    } IDMOWrapperFilterVtbl;

    interface IDMOWrapperFilter
    {
        CONST_VTBL struct IDMOWrapperFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOWrapperFilter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOWrapperFilter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOWrapperFilter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOWrapperFilter_Init(This,clsidDMO,catDMO)	\
    ( (This)->lpVtbl -> Init(This,clsidDMO,catDMO) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOWrapperFilter_INTERFACE_DEFINED__ */


#ifndef __IDMOWrapperFilter2_INTERFACE_DEFINED__
#define __IDMOWrapperFilter2_INTERFACE_DEFINED__

/* interface IDMOWrapperFilter2 */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDMOWrapperFilter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82B70892-5E96-4b88-8695-7D500B26812E")
    IDMOWrapperFilter2 : public IDMOWrapperFilter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            CLSID *pclsidDMO,
            CLSID *pcatDMO) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOWrapperFilter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOWrapperFilter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOWrapperFilter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOWrapperFilter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDMOWrapperFilter2 * This,
            REFCLSID clsidDMO,
            REFCLSID catDMO);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IDMOWrapperFilter2 * This,
            CLSID *pclsidDMO,
            CLSID *pcatDMO);
        
        END_INTERFACE
    } IDMOWrapperFilter2Vtbl;

    interface IDMOWrapperFilter2
    {
        CONST_VTBL struct IDMOWrapperFilter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOWrapperFilter2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOWrapperFilter2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOWrapperFilter2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOWrapperFilter2_Init(This,clsidDMO,catDMO)	\
    ( (This)->lpVtbl -> Init(This,clsidDMO,catDMO) ) 


#define IDMOWrapperFilter2_GetInfo(This,pclsidDMO,pcatDMO)	\
    ( (This)->lpVtbl -> GetInfo(This,pclsidDMO,pcatDMO) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOWrapperFilter2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dot1x.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft shared
// source or premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license agreement,
// you are not authorized to use this source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the SOURCE.RTF on your install media or the root of your tools installation.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef __DOT1X_H_
#define __DOT1X_H_

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <l2cmn.h>

#if __midl
#define V1_ENUM [v1_enum]
#else
#define V1_ENUM
#endif

/*
    The identity that is being used by the 1X module. This is a function of the
    onex auth mode and system triggers (e.g. user logon/logoff)
    */  
typedef V1_ENUM enum _ONEX_AUTH_IDENTITY 
{
    OneXAuthIdentityNone,
    OneXAuthIdentityMachine,
    OneXAuthIdentityUser,
    OneXAuthIdentityExplicitUser,
    OneXAuthIdentityGuest,
    OneXAuthIdentityInvalid
} ONEX_AUTH_IDENTITY, *PONEX_AUTH_IDENTITY;

/*
    The 1X authentication status. Each of the auth status corresponds to one or
    more of the internal 1X states. 
    */
typedef V1_ENUM enum _ONEX_AUTH_STATUS
{
    OneXAuthNotStarted,
    OneXAuthInProgress,
    OneXAuthNoAuthenticatorFound,
    OneXAuthSuccess,
    OneXAuthFailure,
    OneXAuthInvalid
} ONEX_AUTH_STATUS, *PONEX_AUTH_STATUS;

/*
    1X specific reason codes
    */
typedef V1_ENUM enum _ONEX_REASON_CODE
{
    ONEX_REASON_CODE_SUCCESS = 0,
    ONEX_REASON_START = L2_REASON_CODE_ONEX_BASE,
    ONEX_UNABLE_TO_IDENTIFY_USER,
    ONEX_IDENTITY_NOT_FOUND,
    ONEX_UI_DISABLED,
    ONEX_UI_FAILURE,
    ONEX_EAP_FAILURE_RECEIVED,
    ONEX_AUTHENTICATOR_NO_LONGER_PRESENT,
    ONEX_NO_RESPONSE_TO_IDENTITY,
    ONEX_PROFILE_VERSION_NOT_SUPPORTED,
    ONEX_PROFILE_INVALID_LENGTH,
    ONEX_PROFILE_DISALLOWED_EAP_TYPE,
    ONEX_PROFILE_INVALID_EAP_TYPE_OR_FLAG,
    ONEX_PROFILE_INVALID_ONEX_FLAGS,
    ONEX_PROFILE_INVALID_TIMER_VALUE,
    ONEX_PROFILE_INVALID_SUPPLICANT_MODE,
    ONEX_PROFILE_INVALID_AUTH_MODE,
    ONEX_PROFILE_INVALID_EAP_CONNECTION_PROPERTIES,
} ONEX_REASON_CODE, *PONEX_REASON_CODE;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\downloadmgr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:06 2007
 */
/* Compiler settings for ..\downloadmgr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __downloadmgr_h__
#define __downloadmgr_h__

/* Forward Declarations */ 

#ifndef __IDownloadManager_FWD_DEFINED__
#define __IDownloadManager_FWD_DEFINED__
typedef interface IDownloadManager IDownloadManager;
#endif 	/* __IDownloadManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"
#include "urlmon.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_downloadmgr_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// downloadmgr.h
//=--------------------------------------------------------------------------=
// (C) Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Explorer Download Manager Interfaces

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {988934A4-064B-11D3-BB80-00104B35E7F9}
DEFINE_GUID(IID_IDownloadManager, 0x988934a4, 0x064b, 0x11d3, 0xbb, 0x80, 0x0, 0x10, 0x4b, 0x35, 0xe7, 0xf9);
#define SID_SDownloadManager IID_IDownloadManager



extern RPC_IF_HANDLE __MIDL_itf_downloadmgr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_downloadmgr_0000_v0_0_s_ifspec;

#ifndef __IDownloadManager_INTERFACE_DEFINED__
#define __IDownloadManager_INTERFACE_DEFINED__

/* interface IDownloadManager */
/* [local][unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IDownloadManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("988934A4-064B-11D3-BB80-00104B35E7F9")
    IDownloadManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ DWORD dwBindVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ BINDINFO __RPC_FAR *pBindInfo,
            /* [in] */ LPCOLESTR pszHeaders,
            /* [in] */ LPCOLESTR pszRedir,
            /* [in] */ UINT uiCP) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDownloadManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDownloadManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Download )( 
            IDownloadManager __RPC_FAR * This,
            /* [in] */ IMoniker __RPC_FAR *pmk,
            /* [in] */ IBindCtx __RPC_FAR *pbc,
            /* [in] */ DWORD dwBindVerb,
            /* [in] */ LONG grfBINDF,
            /* [in] */ BINDINFO __RPC_FAR *pBindInfo,
            /* [in] */ LPCOLESTR pszHeaders,
            /* [in] */ LPCOLESTR pszRedir,
            /* [in] */ UINT uiCP);
        
        END_INTERFACE
    } IDownloadManagerVtbl;

    interface IDownloadManager
    {
        CONST_VTBL struct IDownloadManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDownloadManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDownloadManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDownloadManager_Download(This,pmk,pbc,dwBindVerb,grfBINDF,pBindInfo,pszHeaders,pszRedir,uiCP)	\
    (This)->lpVtbl -> Download(This,pmk,pbc,dwBindVerb,grfBINDF,pBindInfo,pszHeaders,pszRedir,uiCP)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDownloadManager_Download_Proxy( 
    IDownloadManager __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pmk,
    /* [in] */ IBindCtx __RPC_FAR *pbc,
    /* [in] */ DWORD dwBindVerb,
    /* [in] */ LONG grfBINDF,
    /* [in] */ BINDINFO __RPC_FAR *pBindInfo,
    /* [in] */ LPCOLESTR pszHeaders,
    /* [in] */ LPCOLESTR pszRedir,
    /* [in] */ UINT uiCP);


void __RPC_STUB IDownloadManager_Download_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDownloadManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dmort.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//
// dmort.h - misc. runtime support for DirectShow Media Objects
//
#ifndef __DMORT_H__
#define __DMORT_H__

//
// Mediatype helpers.  MoInitMediaType() goes with MoFreeMediaType(),
// MoCreateMediaType() goes with MoDeleteMediaType() - don't mix !
//



//
// Takes a pointer to an already allocated DMO_MEDIA_TYPE structure, allocates
// a format block of cbFormat bytes, and sets appropriate members of
// DMO_MEDIA_TYPE to point to the newly allocated format block.  Also
// initializes the IUnknown pointer inside DMO_MEDIA_TYPE to NULL.
//
// The format block allocated by MoInitMediaType must be freed by calling
// MoFreeMediaType().
//
STDAPI MoInitMediaType(DMO_MEDIA_TYPE *pmt, DWORD cbFormat);

//
// Frees the format block and releases any IUnknown, but does not free the
// DMO_MEDIA_TYPE structure itself.  Input parameter must point to an
// DMO_MEDIA_TYPE structure previously initialized by MoInitMediaType().
//
STDAPI MoFreeMediaType(DMO_MEDIA_TYPE *pmt);

//
// Copies the DMO_MEDIA_TYPE members.  Also duplicates the format block and
// the IUnknown pointer.  Both parameters must point to valid DMO_MEDIA_TYPE
// structures.  Target structure must be later freed using MoFreeMediaType().
//
STDAPI MoCopyMediaType(DMO_MEDIA_TYPE *pmtDest, const DMO_MEDIA_TYPE *pmtSrc);



//
// Allocates a new DMO_MEDIA_TYPE structure and initializes it just like
// MoInitMediaType.  I.e., this function allocates both the format block
// and the DMO_MEDIA_TYPE structure itself.  Pointer to DMO_MEDIA_TYPE is
// returned as *ppmt.
//
// DMO_MEDIA_TYPE structures allocated by MoCreateMediaType() must be freed
// by calling MoDeleteMediaType().
//
STDAPI MoCreateMediaType(DMO_MEDIA_TYPE **ppmt, DWORD cbFormat);

//
// Frees any format block, releases any IUnknown, and deletes the
// DMO_MEDIA_TYPE structure itself.  The input parameter must point to an
// DMO_MEDIA_TYPE structure previously allocated by MoCreateMediaType().
//
STDAPI MoDeleteMediaType(DMO_MEDIA_TYPE *pmt);

//
// Allocates a new DMO_MEDIA_TYPE structure and copies pmtSrc into it like
// MoCopyMediaType.  I.e., this function allocates a new DMO_MEDIA_TYPE struct
// as well as a new format block for the target mediatype.  Trager mediatype
// must later be freed using MoDeleteMediaType().
//
STDAPI MoDuplicateMediaType(DMO_MEDIA_TYPE **ppmtDest, const DMO_MEDIA_TYPE *pmtSrc);



#endif //__DMORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\docobj.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:02 2007
 */
/* Compiler settings for ..\docobj.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __docobj_h__
#define __docobj_h__

/* Forward Declarations */ 

#ifndef __IOleDocument_FWD_DEFINED__
#define __IOleDocument_FWD_DEFINED__
typedef interface IOleDocument IOleDocument;
#endif  /* __IOleDocument_FWD_DEFINED__ */


#ifndef __IOleDocumentSite_FWD_DEFINED__
#define __IOleDocumentSite_FWD_DEFINED__
typedef interface IOleDocumentSite IOleDocumentSite;
#endif  /* __IOleDocumentSite_FWD_DEFINED__ */


#ifndef __IOleDocumentView_FWD_DEFINED__
#define __IOleDocumentView_FWD_DEFINED__
typedef interface IOleDocumentView IOleDocumentView;
#endif  /* __IOleDocumentView_FWD_DEFINED__ */


#ifndef __IEnumOleDocumentViews_FWD_DEFINED__
#define __IEnumOleDocumentViews_FWD_DEFINED__
typedef interface IEnumOleDocumentViews IEnumOleDocumentViews;
#endif  /* __IEnumOleDocumentViews_FWD_DEFINED__ */


#ifndef __IContinueCallback_FWD_DEFINED__
#define __IContinueCallback_FWD_DEFINED__
typedef interface IContinueCallback IContinueCallback;
#endif  /* __IContinueCallback_FWD_DEFINED__ */


#ifndef __IPrint_FWD_DEFINED__
#define __IPrint_FWD_DEFINED__
typedef interface IPrint IPrint;
#endif  /* __IPrint_FWD_DEFINED__ */


#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef interface IOleCommandTarget IOleCommandTarget;
#endif  /* __IOleCommandTarget_FWD_DEFINED__ */


#ifndef __IZoomEvents_FWD_DEFINED__
#define __IZoomEvents_FWD_DEFINED__
typedef interface IZoomEvents IZoomEvents;
#endif  /* __IZoomEvents_FWD_DEFINED__ */


#ifndef __IProtectFocus_FWD_DEFINED__
#define __IProtectFocus_FWD_DEFINED__
typedef interface IProtectFocus IProtectFocus;
#endif  /* __IProtectFocus_FWD_DEFINED__ */


#ifndef __IProtectedModeMenuServices_FWD_DEFINED__
#define __IProtectedModeMenuServices_FWD_DEFINED__
typedef interface IProtectedModeMenuServices IProtectedModeMenuServices;
#endif  /* __IProtectedModeMenuServices_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "servprov.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_docobj_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// DocObj.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// OLE Document Object Interfaces.









////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPOLEDOCUMENT_DEFINED
#define _LPOLEDOCUMENT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0000_v0_0_s_ifspec;

#ifndef __IOleDocument_INTERFACE_DEFINED__
#define __IOleDocument_INTERFACE_DEFINED__

/* interface IOleDocument */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocument __RPC_FAR *LPOLEDOCUMENT;

typedef /* [public] */ 
enum __MIDL_IOleDocument_0001
    {   DOCMISC_CANCREATEMULTIPLEVIEWS  = 1,
    DOCMISC_SUPPORTCOMPLEXRECTANGLES    = 2,
    DOCMISC_CANTOPENEDIT    = 4,
    DOCMISC_NOFILESUPPORT   = 8
    }   DOCMISC;


EXTERN_C const IID IID_IOleDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc5-4e68-101b-a2bc-00aa00404770")
    IOleDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateView( 
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus( 
            /* [out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumViews( 
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IOleDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateView )( 
            IOleDocument __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ DWORD dwReserved,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocMiscStatus )( 
            IOleDocument __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumViews )( 
            IOleDocument __RPC_FAR * This,
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);
        
        END_INTERFACE
    } IOleDocumentVtbl;

    interface IOleDocument
    {
        CONST_VTBL struct IOleDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocument_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocument_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IOleDocument_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IOleDocument_CreateView(This,pIPSite,pstm,dwReserved,ppView)    \
    (This)->lpVtbl -> CreateView(This,pIPSite,pstm,dwReserved,ppView)

#define IOleDocument_GetDocMiscStatus(This,pdwStatus)   \
    (This)->lpVtbl -> GetDocMiscStatus(This,pdwStatus)

#define IOleDocument_EnumViews(This,ppEnum,ppView)  \
    (This)->lpVtbl -> EnumViews(This,ppEnum,ppView)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocument_CreateView_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite,
    /* [unique][in] */ IStream __RPC_FAR *pstm,
    /* [in] */ DWORD dwReserved,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);


void __RPC_STUB IOleDocument_CreateView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocument_GetDocMiscStatus_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB IOleDocument_GetDocMiscStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocument_EnumViews_Proxy( 
    IOleDocument __RPC_FAR * This,
    /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppView);


void __RPC_STUB IOleDocument_EnumViews_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOleDocument_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0152 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTSITE_DEFINED
#define _LPOLEDOCUMENTSITE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0152_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0152_v0_0_s_ifspec;

#ifndef __IOleDocumentSite_INTERFACE_DEFINED__
#define __IOleDocumentSite_INTERFACE_DEFINED__

/* interface IOleDocumentSite */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocumentSite __RPC_FAR *LPOLEDOCUMENTSITE;


EXTERN_C const IID IID_IOleDocumentSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc7-4e68-101b-a2bc-00aa00404770")
    IOleDocumentSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ActivateMe( 
            /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IOleDocumentSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocumentSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocumentSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocumentSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ActivateMe )( 
            IOleDocumentSite __RPC_FAR * This,
            /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate);
        
        END_INTERFACE
    } IOleDocumentSiteVtbl;

    interface IOleDocumentSite
    {
        CONST_VTBL struct IOleDocumentSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentSite_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocumentSite_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IOleDocumentSite_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IOleDocumentSite_ActivateMe(This,pViewToActivate)   \
    (This)->lpVtbl -> ActivateMe(This,pViewToActivate)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocumentSite_ActivateMe_Proxy( 
    IOleDocumentSite __RPC_FAR * This,
    /* [in] */ IOleDocumentView __RPC_FAR *pViewToActivate);


void __RPC_STUB IOleDocumentSite_ActivateMe_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOleDocumentSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0153 */
/* [local] */ 

#endif
#ifndef _LPOLEDOCUMENTVIEW_DEFINED
#define _LPOLEDOCUMENTVIEW_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0153_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0153_v0_0_s_ifspec;

#ifndef __IOleDocumentView_INTERFACE_DEFINED__
#define __IOleDocumentView_INTERFACE_DEFINED__

/* interface IOleDocumentView */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleDocumentView __RPC_FAR *LPOLEDOCUMENTVIEW;


EXTERN_C const IID IID_IOleDocumentView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc6-4e68-101b-a2bc-00aa00404770")
    IOleDocumentView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite( 
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite( 
            /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRect( 
            /* [in] */ LPRECT prcView) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRect( 
            /* [out] */ LPRECT prcView) = 0;
        
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE SetRectComplex( 
            /* [unique][in] */ LPRECT prcView,
            /* [unique][in] */ LPRECT prcHScroll,
            /* [unique][in] */ LPRECT prcVScroll,
            /* [unique][in] */ LPRECT prcSizeBox) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UIActivate( 
            /* [in] */ BOOL fUIActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseView( 
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveViewState( 
            /* [in] */ LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyViewState( 
            /* [in] */ LPSTREAM pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IOleDocumentViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleDocumentView __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleDocumentView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInPlaceSite )( 
            IOleDocumentView __RPC_FAR * This,
            /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInPlaceSite )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocument )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRect )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPRECT prcView);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRect )( 
            IOleDocumentView __RPC_FAR * This,
            /* [out] */ LPRECT prcView);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRectComplex )( 
            IOleDocumentView __RPC_FAR * This,
            /* [unique][in] */ LPRECT prcView,
            /* [unique][in] */ LPRECT prcHScroll,
            /* [unique][in] */ LPRECT prcVScroll,
            /* [unique][in] */ LPRECT prcSizeBox);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Show )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UIActivate )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ BOOL fUIActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IOleDocumentView __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseView )( 
            IOleDocumentView __RPC_FAR * This,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveViewState )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyViewState )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ LPSTREAM pstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IOleDocumentView __RPC_FAR * This,
            /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew);
        
        END_INTERFACE
    } IOleDocumentViewVtbl;

    interface IOleDocumentView
    {
        CONST_VTBL struct IOleDocumentViewVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleDocumentView_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleDocumentView_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IOleDocumentView_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IOleDocumentView_SetInPlaceSite(This,pIPSite)   \
    (This)->lpVtbl -> SetInPlaceSite(This,pIPSite)

#define IOleDocumentView_GetInPlaceSite(This,ppIPSite)  \
    (This)->lpVtbl -> GetInPlaceSite(This,ppIPSite)

#define IOleDocumentView_GetDocument(This,ppunk)    \
    (This)->lpVtbl -> GetDocument(This,ppunk)

#define IOleDocumentView_SetRect(This,prcView)  \
    (This)->lpVtbl -> SetRect(This,prcView)

#define IOleDocumentView_GetRect(This,prcView)  \
    (This)->lpVtbl -> GetRect(This,prcView)

#define IOleDocumentView_SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)  \
    (This)->lpVtbl -> SetRectComplex(This,prcView,prcHScroll,prcVScroll,prcSizeBox)

#define IOleDocumentView_Show(This,fShow)   \
    (This)->lpVtbl -> Show(This,fShow)

#define IOleDocumentView_UIActivate(This,fUIActivate)   \
    (This)->lpVtbl -> UIActivate(This,fUIActivate)

#define IOleDocumentView_Open(This) \
    (This)->lpVtbl -> Open(This)

#define IOleDocumentView_CloseView(This,dwReserved) \
    (This)->lpVtbl -> CloseView(This,dwReserved)

#define IOleDocumentView_SaveViewState(This,pstm)   \
    (This)->lpVtbl -> SaveViewState(This,pstm)

#define IOleDocumentView_ApplyViewState(This,pstm)  \
    (This)->lpVtbl -> ApplyViewState(This,pstm)

#define IOleDocumentView_Clone(This,pIPSiteNew,ppViewNew)   \
    (This)->lpVtbl -> Clone(This,pIPSiteNew,ppViewNew)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IOleDocumentView_SetInPlaceSite_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [unique][in] */ IOleInPlaceSite __RPC_FAR *pIPSite);


void __RPC_STUB IOleDocumentView_SetInPlaceSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetInPlaceSite_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ IOleInPlaceSite __RPC_FAR *__RPC_FAR *ppIPSite);


void __RPC_STUB IOleDocumentView_GetInPlaceSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetDocument_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IOleDocumentView_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleDocumentView_SetRect_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPRECT prcView);


void __RPC_STUB IOleDocumentView_SetRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_GetRect_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [out] */ LPRECT prcView);


void __RPC_STUB IOleDocumentView_GetRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleDocumentView_SetRectComplex_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [unique][in] */ LPRECT prcView,
    /* [unique][in] */ LPRECT prcHScroll,
    /* [unique][in] */ LPRECT prcVScroll,
    /* [unique][in] */ LPRECT prcSizeBox);


void __RPC_STUB IOleDocumentView_SetRectComplex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Show_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB IOleDocumentView_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_UIActivate_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ BOOL fUIActivate);


void __RPC_STUB IOleDocumentView_UIActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Open_Proxy( 
    IOleDocumentView __RPC_FAR * This);


void __RPC_STUB IOleDocumentView_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_CloseView_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    DWORD dwReserved);


void __RPC_STUB IOleDocumentView_CloseView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_SaveViewState_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPSTREAM pstm);


void __RPC_STUB IOleDocumentView_SaveViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_ApplyViewState_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ LPSTREAM pstm);


void __RPC_STUB IOleDocumentView_ApplyViewState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleDocumentView_Clone_Proxy( 
    IOleDocumentView __RPC_FAR * This,
    /* [in] */ IOleInPlaceSite __RPC_FAR *pIPSiteNew,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *ppViewNew);


void __RPC_STUB IOleDocumentView_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOleDocumentView_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0154 */
/* [local] */ 

#endif
#ifndef _LPENUMOLEDOCUMENTVIEWS_DEFINED
#define _LPENUMOLEDOCUMENTVIEWS_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0154_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0154_v0_0_s_ifspec;

#ifndef __IEnumOleDocumentViews_INTERFACE_DEFINED__
#define __IEnumOleDocumentViews_INTERFACE_DEFINED__

/* interface IEnumOleDocumentViews */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumOleDocumentViews __RPC_FAR *LPENUMOLEDOCUMENTVIEWS;


EXTERN_C const IID IID_IEnumOleDocumentViews;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc8-4e68-101b-a2bc-00aa00404770")
    IEnumOleDocumentViews : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT __stdcall Next( 
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cViews) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IEnumOleDocumentViewsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Next )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ ULONG cViews,
            /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [in] */ ULONG cViews);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumOleDocumentViews __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumOleDocumentViews __RPC_FAR * This,
            /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumOleDocumentViewsVtbl;

    interface IEnumOleDocumentViews
    {
        CONST_VTBL struct IEnumOleDocumentViewsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumOleDocumentViews_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumOleDocumentViews_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IEnumOleDocumentViews_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IEnumOleDocumentViews_Next(This,cViews,rgpView,pcFetched)   \
    (This)->lpVtbl -> Next(This,cViews,rgpView,pcFetched)

#define IEnumOleDocumentViews_Skip(This,cViews) \
    (This)->lpVtbl -> Skip(This,cViews)

#define IEnumOleDocumentViews_Reset(This)   \
    (This)->lpVtbl -> Reset(This)

#define IEnumOleDocumentViews_Clone(This,ppEnum)    \
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_RemoteNext_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumOleDocumentViews_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Skip_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews);


void __RPC_STUB IEnumOleDocumentViews_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Reset_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This);


void __RPC_STUB IEnumOleDocumentViews_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumOleDocumentViews_Clone_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [out] */ IEnumOleDocumentViews __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumOleDocumentViews_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IEnumOleDocumentViews_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0155 */
/* [local] */ 

#endif
#ifndef _LPCONTINUECALLBACK_DEFINED
#define _LPCONTINUECALLBACK_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0155_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0155_v0_0_s_ifspec;

#ifndef __IContinueCallback_INTERFACE_DEFINED__
#define __IContinueCallback_INTERFACE_DEFINED__

/* interface IContinueCallback */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IContinueCallback __RPC_FAR *LPCONTINUECALLBACK;


EXTERN_C const IID IID_IContinueCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcca-4e68-101b-a2bc-00aa00404770")
    IContinueCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FContinue( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FContinuePrinting( 
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IContinueCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IContinueCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IContinueCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IContinueCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FContinue )( 
            IContinueCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FContinuePrinting )( 
            IContinueCallback __RPC_FAR * This,
            /* [in] */ LONG nCntPrinted,
            /* [in] */ LONG nCurPage,
            /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus);
        
        END_INTERFACE
    } IContinueCallbackVtbl;

    interface IContinueCallback
    {
        CONST_VTBL struct IContinueCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IContinueCallback_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IContinueCallback_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IContinueCallback_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IContinueCallback_FContinue(This)   \
    (This)->lpVtbl -> FContinue(This)

#define IContinueCallback_FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)  \
    (This)->lpVtbl -> FContinuePrinting(This,nCntPrinted,nCurPage,pwszPrintStatus)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IContinueCallback_FContinue_Proxy( 
    IContinueCallback __RPC_FAR * This);


void __RPC_STUB IContinueCallback_FContinue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IContinueCallback_FContinuePrinting_Proxy( 
    IContinueCallback __RPC_FAR * This,
    /* [in] */ LONG nCntPrinted,
    /* [in] */ LONG nCurPage,
    /* [unique][in] */ wchar_t __RPC_FAR *pwszPrintStatus);


void __RPC_STUB IContinueCallback_FContinuePrinting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IContinueCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0156 */
/* [local] */ 

#endif
#ifndef _LPPRINT_DEFINED
#define _LPPRINT_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0156_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0156_v0_0_s_ifspec;

#ifndef __IPrint_INTERFACE_DEFINED__
#define __IPrint_INTERFACE_DEFINED__

/* interface IPrint */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPrint __RPC_FAR *LPPRINT;

typedef /* [public] */ 
enum __MIDL_IPrint_0001
    {   PRINTFLAG_MAYBOTHERUSER = 1,
    PRINTFLAG_PROMPTUSER    = 2,
    PRINTFLAG_USERMAYCHANGEPRINTER  = 4,
    PRINTFLAG_RECOMPOSETODEVICE = 8,
    PRINTFLAG_DONTACTUALLYPRINT = 16,
    PRINTFLAG_FORCEPROPERTIES   = 32,
    PRINTFLAG_PRINTTOFILE   = 64
    }   PRINTFLAG;

typedef struct tagPAGERANGE
    {
    LONG nFromPage;
    LONG nToPage;
    }   PAGERANGE;

typedef struct tagPAGESET
    {
    ULONG cbStruct;
    BOOL fOddPages;
    BOOL fEvenPages;
    ULONG cPageRange;
    /* [size_is] */ PAGERANGE rgPages[ 1 ];
    }   PAGESET;

#define PAGESET_TOLASTPAGE   ((WORD)(-1L))

EXTERN_C const IID IID_IPrint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bcc9-4e68-101b-a2bc-00aa00404770")
    IPrint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetInitialPageNum( 
            /* [in] */ LONG nFirstPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageInfo( 
            /* [out] */ LONG __RPC_FAR *pnFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPages) = 0;
        
        virtual /* [local] */ HRESULT __stdcall Print( 
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
            /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
            /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
            /* [in] */ IContinueCallback __RPC_FAR *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
            /* [out] */ LONG __RPC_FAR *pnLastPage) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IPrintVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPrint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPrint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPrint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInitialPageNum )( 
            IPrint __RPC_FAR * This,
            /* [in] */ LONG nFirstPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageInfo )( 
            IPrint __RPC_FAR * This,
            /* [out] */ LONG __RPC_FAR *pnFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPages);
        
        /* [local] */ HRESULT ( __stdcall __RPC_FAR *Print )( 
            IPrint __RPC_FAR * This,
            /* [in] */ DWORD grfFlags,
            /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
            /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
            /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
            /* [in] */ IContinueCallback __RPC_FAR *pcallback,
            /* [in] */ LONG nFirstPage,
            /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
            /* [out] */ LONG __RPC_FAR *pnLastPage);
        
        END_INTERFACE
    } IPrintVtbl;

    interface IPrint
    {
        CONST_VTBL struct IPrintVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrint_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrint_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IPrint_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IPrint_SetInitialPageNum(This,nFirstPage)   \
    (This)->lpVtbl -> SetInitialPageNum(This,nFirstPage)

#define IPrint_GetPageInfo(This,pnFirstPage,pcPages)    \
    (This)->lpVtbl -> GetPageInfo(This,pnFirstPage,pcPages)

#define IPrint_Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)  \
    (This)->lpVtbl -> Print(This,grfFlags,pptd,ppPageSet,pstgmOptions,pcallback,nFirstPage,pcPagesPrinted,pnLastPage)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IPrint_SetInitialPageNum_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ LONG nFirstPage);


void __RPC_STUB IPrint_SetInitialPageNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrint_GetPageInfo_Proxy( 
    IPrint __RPC_FAR * This,
    /* [out] */ LONG __RPC_FAR *pnFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPages);


void __RPC_STUB IPrint_GetPageInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT __stdcall IPrint_RemotePrint_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *pppageset,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);


void __RPC_STUB IPrint_RemotePrint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IPrint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0157 */
/* [local] */ 

#endif
#ifndef _LPOLECOMMANDTARGET_DEFINED
#define _LPOLECOMMANDTARGET_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0157_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0157_v0_0_s_ifspec;

#ifndef __IOleCommandTarget_INTERFACE_DEFINED__
#define __IOleCommandTarget_INTERFACE_DEFINED__

/* interface IOleCommandTarget */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IOleCommandTarget __RPC_FAR *LPOLECOMMANDTARGET;

typedef 
enum OLECMDF
    {   OLECMDF_SUPPORTED   = 0x1,
    OLECMDF_ENABLED = 0x2,
    OLECMDF_LATCHED = 0x4,
    OLECMDF_NINCHED = 0x8,
    OLECMDF_INVISIBLE   = 0x10,
    OLECMDF_DEFHIDEONCTXTMENU   = 0x20
    }   OLECMDF;

typedef struct _tagOLECMD
    {
    ULONG cmdID;
    DWORD cmdf;
    }   OLECMD;

typedef struct _tagOLECMDTEXT
    {
    DWORD cmdtextf;
    ULONG cwActual;
    ULONG cwBuf;
    /* [size_is] */ wchar_t rgwz[ 1 ];
    }   OLECMDTEXT;

typedef 
enum OLECMDTEXTF
    {   OLECMDTEXTF_NONE    = 0,
    OLECMDTEXTF_NAME    = 1,
    OLECMDTEXTF_STATUS  = 2
    }   OLECMDTEXTF;

typedef 
enum OLECMDEXECOPT
    {   OLECMDEXECOPT_DODEFAULT = 0,
    OLECMDEXECOPT_PROMPTUSER    = 1,
    OLECMDEXECOPT_DONTPROMPTUSER    = 2,
    OLECMDEXECOPT_SHOWHELP  = 3
    }   OLECMDEXECOPT;

/* OLECMDID_STOPDOWNLOAD and OLECMDID_ALLOWUILESSSAVEAS are supported for QueryStatus Only */
typedef 
enum OLECMDID
    {   OLECMDID_OPEN   = 1,
    OLECMDID_NEW    = 2,
    OLECMDID_SAVE   = 3,
    OLECMDID_SAVEAS = 4,
    OLECMDID_SAVECOPYAS = 5,
    OLECMDID_PRINT  = 6,
    OLECMDID_PRINTPREVIEW   = 7,
    OLECMDID_PAGESETUP  = 8,
    OLECMDID_SPELL  = 9,
    OLECMDID_PROPERTIES = 10,
    OLECMDID_CUT    = 11,
    OLECMDID_COPY   = 12,
    OLECMDID_PASTE  = 13,
    OLECMDID_PASTESPECIAL   = 14,
    OLECMDID_UNDO   = 15,
    OLECMDID_REDO   = 16,
    OLECMDID_SELECTALL  = 17,
    OLECMDID_CLEARSELECTION = 18,
    OLECMDID_ZOOM   = 19,
    OLECMDID_GETZOOMRANGE   = 20,
    OLECMDID_UPDATECOMMANDS = 21,
    OLECMDID_REFRESH    = 22,
    OLECMDID_STOP   = 23,
    OLECMDID_HIDETOOLBARS   = 24,
    OLECMDID_SETPROGRESSMAX = 25,
    OLECMDID_SETPROGRESSPOS = 26,
    OLECMDID_SETPROGRESSTEXT    = 27,
    OLECMDID_SETTITLE   = 28,
    OLECMDID_SETDOWNLOADSTATE   = 29,
    OLECMDID_STOPDOWNLOAD   = 30,
    OLECMDID_ONTOOLBARACTIVATED = 31,
    OLECMDID_FIND   = 32,
    OLECMDID_DELETE = 33,
    OLECMDID_HTTPEQUIV  = 34,
    OLECMDID_HTTPEQUIV_DONE = 35,
    OLECMDID_ENABLE_INTERACTION = 36,
    OLECMDID_ONUNLOAD   = 37,
    OLECMDID_PROPERTYBAG2   = 38,
    OLECMDID_PREREFRESH = 39,
    OLECMDID_SHOWSCRIPTERROR    = 40,
    OLECMDID_SHOWMESSAGE    = 41,
    OLECMDID_SHOWFIND   = 42,
    OLECMDID_SHOWPAGESETUP  = 43,
    OLECMDID_SHOWPRINT  = 44,
    OLECMDID_CLOSE  = 45,
    OLECMDID_ALLOWUILESSSAVEAS  = 46,
    OLECMDID_DONTDOWNLOADCSS    = 47,
    OLECMDID_UPDATEPAGESTATUS   = 48,
    OLECMDID_PRINT2 = 49,
    OLECMDID_PRINTPREVIEW2  = 50,
    OLECMDID_SETPRINTTEMPLATE   = 51,
    OLECMDID_GETPRINTTEMPLATE   = 52,
    OLECMDID_PAGEACTIONBLOCKED  = 55,
    OLECMDID_PAGEACTIONUIQUERY  = 56,
    OLECMDID_FOCUSVIEWCONTROLS  = 57,
    OLECMDID_FOCUSVIEWCONTROLSQUERY = 58,
    OLECMDID_SHOWPAGEACTIONMENU = 59,
    OLECMDID_ADDTRAVELENTRY = 60,
    OLECMDID_UPDATETRAVELENTRY  = 61,
    OLECMDID_UPDATEBACKFORWARDSTATE = 62,
    OLECMDID_OPTICAL_ZOOM   = 63,
    OLECMDID_OPTICAL_GETZOOMRANGE   = 64,
    OLECMDID_WINDOWSTATECHANGED = 65,
    OLECMDID_WORKINGMODE = 66
    }   OLECMDID;

#define OLECMDERR_E_FIRST            (OLE_E_LAST+1)
#define OLECMDERR_E_NOTSUPPORTED     (OLECMDERR_E_FIRST)
#define OLECMDERR_E_DISABLED         (OLECMDERR_E_FIRST+1)
#define OLECMDERR_E_NOHELP           (OLECMDERR_E_FIRST+2)
#define OLECMDERR_E_CANCELED         (OLECMDERR_E_FIRST+3)
#define OLECMDERR_E_UNKNOWNGROUP     (OLECMDERR_E_FIRST+4)
#define MSOCMDERR_E_FIRST            OLECMDERR_E_FIRST
#define MSOCMDERR_E_NOTSUPPORTED     OLECMDERR_E_NOTSUPPORTED
#define MSOCMDERR_E_DISABLED         OLECMDERR_E_DISABLED
#define MSOCMDERR_E_NOHELP           OLECMDERR_E_NOHELP
#define MSOCMDERR_E_CANCELED         OLECMDERR_E_CANCELED
#define MSOCMDERR_E_UNKNOWNGROUP     OLECMDERR_E_UNKNOWNGROUP
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_HWND     0
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_X        1
#define OLECMDARGINDEX_SHOWPAGEACTIONMENU_Y        2
#define OLECMDARGINDEX_ACTIVEXINSTALL_PUBLISHER    0
#define OLECMDARGINDEX_ACTIVEXINSTALL_DISPLAYNAME  1
typedef 
enum IGNOREMIME
    {   IGNOREMIME_PROMPT   = 0x1,
    IGNOREMIME_TEXT = 0x2
    }   IGNOREMIME;

typedef 
enum WPCSETTING
    {   WPCSETTING_LOGGING_ENABLED  = 0x1,
    WPCSETTING_FILEDOWNLOAD_BLOCKED = 0x2
    }   WPCSETTING;

#endif

EXTERN_C const IID IID_IOleCommandTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b722bccb-4e68-101b-a2bc-00aa00404770")
    IOleCommandTarget : public IUnknown
    {
    public:
        virtual /* [input_sync] */ HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
            /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IOleCommandTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IOleCommandTarget __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IOleCommandTarget __RPC_FAR * This);
        
        /* [input_sync] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryStatus )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ ULONG cCmds,
            /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
            /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exec )( 
            IOleCommandTarget __RPC_FAR * This,
            /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID,
            /* [in] */ DWORD nCmdexecopt,
            /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
            /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut);
        
        END_INTERFACE
    } IOleCommandTargetVtbl;

    interface IOleCommandTarget
    {
        CONST_VTBL struct IOleCommandTargetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IOleCommandTarget_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IOleCommandTarget_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IOleCommandTarget_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IOleCommandTarget_QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)    \
    (This)->lpVtbl -> QueryStatus(This,pguidCmdGroup,cCmds,prgCmds,pCmdText)

#define IOleCommandTarget_Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)  \
    (This)->lpVtbl -> Exec(This,pguidCmdGroup,nCmdID,nCmdexecopt,pvaIn,pvaOut)

#endif /* COBJMACROS */


#endif  /* C style interface */



/* [input_sync] */ HRESULT STDMETHODCALLTYPE IOleCommandTarget_QueryStatus_Proxy( 
    IOleCommandTarget __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
    /* [in] */ ULONG cCmds,
    /* [out][in][size_is] */ OLECMD __RPC_FAR prgCmds[  ],
    /* [unique][out][in] */ OLECMDTEXT __RPC_FAR *pCmdText);


void __RPC_STUB IOleCommandTarget_QueryStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IOleCommandTarget_Exec_Proxy( 
    IOleCommandTarget __RPC_FAR * This,
    /* [unique][in] */ const GUID __RPC_FAR *pguidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [in] */ DWORD nCmdexecopt,
    /* [unique][in] */ VARIANT __RPC_FAR *pvaIn,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvaOut);


void __RPC_STUB IOleCommandTarget_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IOleCommandTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0158 */
/* [local] */ 

#endif
typedef enum
{
      OLECMDIDF_REFRESH_NORMAL          = 0,
      OLECMDIDF_REFRESH_IFEXPIRED       = 1,
      OLECMDIDF_REFRESH_CONTINUE        = 2,
      OLECMDIDF_REFRESH_COMPLETELY      = 3,
      OLECMDIDF_REFRESH_NO_CACHE        = 4,
      OLECMDIDF_REFRESH_RELOAD          = 5,
      OLECMDIDF_REFRESH_LEVELMASK       = 0x00FF,
      OLECMDIDF_REFRESH_CLEARUSERINPUT  = 0x1000,
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000,
      OLECMDIDF_REFRESH_PAGEACTION_ACTIVEXINSTALL = 0x00010000,
      OLECMDIDF_REFRESH_PAGEACTION_FILEDOWNLOAD   = 0x00020000,
      OLECMDIDF_REFRESH_PAGEACTION_LOCALMACHINE   = 0x00040000,
      OLECMDIDF_REFRESH_PAGEACTION_POPUPWINDOW    = 0x00080000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNLOCALMACHINE  = 0x00100000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNTRUSTED       = 0x00200000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTRANET      = 0x00400000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNINTERNET      = 0x00800000,
      OLECMDIDF_REFRESH_PAGEACTION_PROTLOCKDOWNRESTRICTED    = 0x01000000,
#elif(NTDDI_VERSION >= NTDDI_WINXP)
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000,
      OLECMDIDF_REFRESH_THROUGHSCRIPT   = 0x4000
#else
      OLECMDIDF_REFRESH_PROMPTIFOFFLINE = 0x2000
#endif
      OLECMDIDF_REFRESH_PAGEACTION_MIXEDCONTENT              = 0x02000000,
      OLECMDIDF_REFRESH_PAGEACTION_INVALID_CERT              = 0x04000000,
} OLECMDID_REFRESHFLAG;
#if(NTDDI_VERSION >= NTDDI_WIN2K3)
typedef enum
{
      OLECMDIDF_PAGEACTION_FILEDOWNLOAD                       = 0x00000001,
      OLECMDIDF_PAGEACTION_ACTIVEXINSTALL                     = 0x00000002,
      OLECMDIDF_PAGEACTION_ACTIVEXTRUSTFAIL                   = 0x00000004,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERDISABLE                 = 0x00000008,
      OLECMDIDF_PAGEACTION_ACTIVEXDISALLOW                    = 0x00000010,
      OLECMDIDF_PAGEACTION_ACTIVEXUNSAFE                      = 0x00000020,
      OLECMDIDF_PAGEACTION_POPUPWINDOW                        = 0x00000040,
      OLECMDIDF_PAGEACTION_LOCALMACHINE                       = 0x00000080,
      OLECMDIDF_PAGEACTION_MIMETEXTPLAIN                      = 0x00000100,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE                     = 0x00000200,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXINSTALL      = 0x00000200,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNLOCALMACHINE           = 0x00000400,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNTRUSTED                = 0x00000800,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTRANET               = 0x00001000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNINTERNET               = 0x00002000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNRESTRICTED             = 0x00004000,
      OLECMDIDF_PAGEACTION_PROTLOCKDOWNDENY                   = 0x00008000,
      OLECMDIDF_PAGEACTION_POPUPALLOWED                       = 0x00010000,
      OLECMDIDF_PAGEACTION_SCRIPTPROMPT                       = 0x00020000,
      OLECMDIDF_PAGEACTION_ACTIVEXUSERAPPROVAL                = 0x00040000,
      OLECMDIDF_PAGEACTION_MIXEDCONTENT                       = 0x00080000,
      OLECMDIDF_PAGEACTION_INVALID_CERT                       = 0x00100000,
      OLECMDIDF_PAGEACTION_INTRANETZONEREQUEST                = 0x00200000,
      OLECMDIDF_PAGEACTION_SPOOFABLEIDNHOST                   = 0x00800000,
      OLECMDIDF_PAGEACTION_LOWRIGHTSIE                        = 0x01000000,
      OLECMDIDF_PAGEACTION_SCRIPTNAVIGATE_ACTIVEXUSERAPPROVAL = 0x02000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED                         = 0x04000000,
      OLECMDIDF_PAGEACTION_WPCBLOCKED_ACTIVEX                 = 0x08000000,
      OLECMDIDF_PAGEACTION_EXTENSION_COMPAT_BLOCKED           = 0x10000000,
      OLECMDIDF_PAGEACTION_NORESETACTIVEX                     = 0x20000000,
      OLECMDIDF_PAGEACTION_GENERIC_STATE                      = 0x40000000,
      OLECMDIDF_PAGEACTION_RESET                              = 0x80000000,
} OLECMDID_PAGEACTIONFLAG;
typedef enum
{
      OLECMDIDF_BROWSERSTATE_EXTENSIONSOFF                      = 0x00000001,
      OLECMDIDF_BROWSERSTATE_IESECURITY                         = 0x00000002,
      OLECMDIDF_BROWSERSTATE_PROTECTEDMODE_OFF                  = 0x00000004,
      OLECMDIDF_BROWSERSTATE_RESET                              = 0x00000008,
} OLECMDID_BROWSERSTATEFLAG;
typedef enum
{
    PAGEACTION_UI_DEFAULT     = 0,
    PAGEACTION_UI_MODAL       = 1,
    PAGEACTION_UI_MODELESS    = 2,
    PAGEACTION_UI_SILENT      = 3,
} PAGEACTION_UI;
#endif
typedef enum
{
    OLECMDIDF_WINDOWSTATE_USERVISIBLE        = 0x00000001,
    OLECMDIDF_WINDOWSTATE_ENABLED            = 0x00000002,
    OLECMDIDF_WINDOWSTATE_USERVISIBLE_VALID  = 0x00010000,
    OLECMDIDF_WINDOWSTATE_ENABLED_VALID      = 0x00020000,
} OLECMDID_WINDOWSTATE_FLAG;
typedef enum
{
    OLECMDIDF_MOBILEOPTVIEW_OPTION_ENABLEMOV            = 0x0000,
    OLECMDIDF_MOBILEOPTVIEW_OPTION_OPTWIDTHZOOMPCT      = 0x0001,
    OLECMDIDF_MOBILEOPTVIEW_OPTION_CONTENTEXTENDHEIGHT  = 0x0002,
} OLECMDID_MOBILEOPTVIEW_OPTION;
typedef enum
{
    OLECMDIDF_MOBILEOPTVIEW_VALUE_DISABLE               = 0x0000,
    OLECMDIDF_MOBILEOPTVIEW_VALUE_ENABLE                = 0x0001,
    OLECMDIDF_MOBILEOPTVIEW_VALUE_QUERY                 = 0xFFFF,
} OLECMDID_MOBILEOPTVIEW_VALUE;

typedef enum
{
    OLECMDIDF_WORKINGMODE_NORMAL               = 0x00000001,
    OLECMDIDF_WORKINGMODE_SUSPEND              = 0x00000002,
} OLECMDID_WORKINGMODE_FLAG;


////////////////////////////////////////////////////////////////////////////
//  Aliases to original office-compatible names
#define IMsoDocument             IOleDocument
#define IMsoDocumentSite         IOleDocumentSite
#define IMsoView                 IOleDocumentView
#define IEnumMsoView             IEnumOleDocumentViews
#define IMsoCommandTarget        IOleCommandTarget
#define LPMSODOCUMENT            LPOLEDOCUMENT
#define LPMSODOCUMENTSITE        LPOLEDOCUMENTSITE
#define LPMSOVIEW                LPOLEDOCUMENTVIEW
#define LPENUMMSOVIEW            LPENUMOLEDOCUMENTVIEWS
#define LPMSOCOMMANDTARGET       LPOLECOMMANDTARGET
#define MSOCMD                   OLECMD
#define MSOCMDTEXT               OLECMDTEXT
#define IID_IMsoDocument         IID_IOleDocument
#define IID_IMsoDocumentSite     IID_IOleDocumentSite
#define IID_IMsoView             IID_IOleDocumentView
#define IID_IEnumMsoView         IID_IEnumOleDocumentViews
#define IID_IMsoCommandTarget    IID_IOleCommandTarget
#define MSOCMDF_SUPPORTED OLECMDF_SUPPORTED
#define MSOCMDF_ENABLED OLECMDF_ENABLED
#define MSOCMDF_LATCHED OLECMDF_LATCHED
#define MSOCMDF_NINCHED OLECMDF_NINCHED
#define MSOCMDTEXTF_NONE OLECMDTEXTF_NONE
#define MSOCMDTEXTF_NAME OLECMDTEXTF_NAME
#define MSOCMDTEXTF_STATUS OLECMDTEXTF_STATUS
#define MSOCMDEXECOPT_DODEFAULT OLECMDEXECOPT_DODEFAULT
#define MSOCMDEXECOPT_PROMPTUSER OLECMDEXECOPT_PROMPTUSER
#define MSOCMDEXECOPT_DONTPROMPTUSER OLECMDEXECOPT_DONTPROMPTUSER
#define MSOCMDEXECOPT_SHOWHELP OLECMDEXECOPT_SHOWHELP
#define MSOCMDID_OPEN OLECMDID_OPEN
#define MSOCMDID_NEW OLECMDID_NEW
#define MSOCMDID_SAVE OLECMDID_SAVE
#define MSOCMDID_SAVEAS OLECMDID_SAVEAS
#define MSOCMDID_SAVECOPYAS OLECMDID_SAVECOPYAS
#define MSOCMDID_PRINT OLECMDID_PRINT
#define MSOCMDID_PRINTPREVIEW OLECMDID_PRINTPREVIEW
#define MSOCMDID_PAGESETUP OLECMDID_PAGESETUP
#define MSOCMDID_SPELL OLECMDID_SPELL
#define MSOCMDID_PROPERTIES OLECMDID_PROPERTIES
#define MSOCMDID_CUT OLECMDID_CUT
#define MSOCMDID_COPY OLECMDID_COPY
#define MSOCMDID_PASTE OLECMDID_PASTE
#define MSOCMDID_PASTESPECIAL OLECMDID_PASTESPECIAL
#define MSOCMDID_UNDO OLECMDID_UNDO
#define MSOCMDID_REDO OLECMDID_REDO
#define MSOCMDID_SELECTALL OLECMDID_SELECTALL
#define MSOCMDID_CLEARSELECTION OLECMDID_CLEARSELECTION
#define MSOCMDID_ZOOM OLECMDID_ZOOM
#define MSOCMDID_GETZOOMRANGE OLECMDID_GETZOOMRANGE
EXTERN_C const GUID SID_SContainerDispatch;


extern RPC_IF_HANDLE __MIDL_itf_docobj_0158_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0158_v0_0_s_ifspec;

#ifndef __IZoomEvents_INTERFACE_DEFINED__
#define __IZoomEvents_INTERFACE_DEFINED__

/* interface IZoomEvents */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IZoomEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41B68150-904C-4e17-A0BA-A438182E359D")
    IZoomEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnZoomPercentChanged( 
            /* [in] */ ULONG ulZoomPercent) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IZoomEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IZoomEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IZoomEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IZoomEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnZoomPercentChanged )( 
            IZoomEvents __RPC_FAR * This,
            /* [in] */ ULONG ulZoomPercent);
        
        END_INTERFACE
    } IZoomEventsVtbl;

    interface IZoomEvents
    {
        CONST_VTBL struct IZoomEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoomEvents_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IZoomEvents_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IZoomEvents_Release(This)   \
    (This)->lpVtbl -> Release(This)


#define IZoomEvents_OnZoomPercentChanged(This,ulZoomPercent)    \
    (This)->lpVtbl -> OnZoomPercentChanged(This,ulZoomPercent)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IZoomEvents_OnZoomPercentChanged_Proxy( 
    IZoomEvents __RPC_FAR * This,
    /* [in] */ ULONG ulZoomPercent);


void __RPC_STUB IZoomEvents_OnZoomPercentChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IZoomEvents_INTERFACE_DEFINED__ */


#ifndef __IProtectFocus_INTERFACE_DEFINED__
#define __IProtectFocus_INTERFACE_DEFINED__

/* interface IProtectFocus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectFocus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d81f90a3-8156-44f7-ad28-5abb87003274")
    IProtectFocus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllowFocusChange( 
            /* [out] */ BOOL __RPC_FAR *pfAllow) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IProtectFocusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProtectFocus __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProtectFocus __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProtectFocus __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AllowFocusChange )( 
            IProtectFocus __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pfAllow);
        
        END_INTERFACE
    } IProtectFocusVtbl;

    interface IProtectFocus
    {
        CONST_VTBL struct IProtectFocusVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectFocus_QueryInterface(This,riid,ppvObject)   \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProtectFocus_AddRef(This)  \
    (This)->lpVtbl -> AddRef(This)

#define IProtectFocus_Release(This) \
    (This)->lpVtbl -> Release(This)


#define IProtectFocus_AllowFocusChange(This,pfAllow)    \
    (This)->lpVtbl -> AllowFocusChange(This,pfAllow)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IProtectFocus_AllowFocusChange_Proxy( 
    IProtectFocus __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pfAllow);


void __RPC_STUB IProtectFocus_AllowFocusChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IProtectFocus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0160 */
/* [local] */ 

#define SID_SProtectFocus  IID_IProtectFocus
#ifndef _LPPROTECTEDMODEMENUSERVICES_DEFINED
#define _LPPROTECTEDMODEMENUSERVICES_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_docobj_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0160_v0_0_s_ifspec;

#ifndef __IProtectedModeMenuServices_INTERFACE_DEFINED__
#define __IProtectedModeMenuServices_INTERFACE_DEFINED__

/* interface IProtectedModeMenuServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProtectedModeMenuServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73c105ee-9dff-4a07-b83c-7eff290c266e")
    IProtectedModeMenuServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMenu( 
            /* [out] */ HMENU __RPC_FAR *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenu( 
            /* [string][in] */ LPCWSTR pszModuleName,
            /* [string][in] */ LPCWSTR pszMenuName,
            /* [out] */ HMENU __RPC_FAR *phMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMenuID( 
            /* [string][in] */ LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ HMENU __RPC_FAR *phMenu) = 0;
        
    };
    
#else   /* C style interface */

    typedef struct IProtectedModeMenuServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IProtectedModeMenuServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IProtectedModeMenuServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IProtectedModeMenuServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateMenu )( 
            IProtectedModeMenuServices __RPC_FAR * This,
            /* [out] */ HMENU __RPC_FAR *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadMenu )( 
            IProtectedModeMenuServices __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszModuleName,
            /* [string][in] */ LPCWSTR pszMenuName,
            /* [out] */ HMENU __RPC_FAR *phMenu);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadMenuID )( 
            IProtectedModeMenuServices __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszModuleName,
            /* [in] */ WORD wResourceID,
            /* [out] */ HMENU __RPC_FAR *phMenu);
        
        END_INTERFACE
    } IProtectedModeMenuServicesVtbl;

    interface IProtectedModeMenuServices
    {
        CONST_VTBL struct IProtectedModeMenuServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProtectedModeMenuServices_QueryInterface(This,riid,ppvObject)  \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProtectedModeMenuServices_AddRef(This) \
    (This)->lpVtbl -> AddRef(This)

#define IProtectedModeMenuServices_Release(This)    \
    (This)->lpVtbl -> Release(This)


#define IProtectedModeMenuServices_CreateMenu(This,phMenu)  \
    (This)->lpVtbl -> CreateMenu(This,phMenu)

#define IProtectedModeMenuServices_LoadMenu(This,pszModuleName,pszMenuName,phMenu)  \
    (This)->lpVtbl -> LoadMenu(This,pszModuleName,pszMenuName,phMenu)

#define IProtectedModeMenuServices_LoadMenuID(This,pszModuleName,wResourceID,phMenu)    \
    (This)->lpVtbl -> LoadMenuID(This,pszModuleName,wResourceID,phMenu)

#endif /* COBJMACROS */


#endif  /* C style interface */



HRESULT STDMETHODCALLTYPE IProtectedModeMenuServices_CreateMenu_Proxy( 
    IProtectedModeMenuServices __RPC_FAR * This,
    /* [out] */ HMENU __RPC_FAR *phMenu);


void __RPC_STUB IProtectedModeMenuServices_CreateMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProtectedModeMenuServices_LoadMenu_Proxy( 
    IProtectedModeMenuServices __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszModuleName,
    /* [string][in] */ LPCWSTR pszMenuName,
    /* [out] */ HMENU __RPC_FAR *phMenu);


void __RPC_STUB IProtectedModeMenuServices_LoadMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IProtectedModeMenuServices_LoadMenuID_Proxy( 
    IProtectedModeMenuServices __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszModuleName,
    /* [in] */ WORD wResourceID,
    /* [out] */ HMENU __RPC_FAR *phMenu);


void __RPC_STUB IProtectedModeMenuServices_LoadMenuID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif  /* __IProtectedModeMenuServices_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_docobj_0161 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_docobj_0161_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_docobj_0161_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HMENU_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HMENU __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HMENU_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HMENU __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HMENU_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HMENU __RPC_FAR * ); 
void                      __RPC_USER  HMENU_UserFree(     unsigned long __RPC_FAR *, HMENU __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub( 
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched);

/* [local] */ HRESULT __stdcall IPrint_Print_Proxy( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub( 
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *pppageset,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\drfilter.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
Module Name:
    DrFilter.h

Abstract:
    Driver's Filter interface defintion.


*/
#pragma once
// Filter De-activation Entry.

typedef struct __DRIVER_FILTER *PDRIVER_FILTER;
typedef VOID  (*pFDriverDeinitFn) (PDRIVER_FILTER pCurrentFilter);

// prototypes for device driver entry points
typedef DWORD (* pFilterInitFn)(DWORD,LPVOID,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterPreDeinitFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterDeinitFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef DWORD (* pFilterOpenFn)(DWORD,DWORD,DWORD,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterPreCloseFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterCloseFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef DWORD (* pFilterReadFn)(DWORD,LPVOID,DWORD,HANDLE,PDRIVER_FILTER pCurrentFilter);
typedef DWORD (* pFilterWriteFn)(DWORD,LPCVOID,DWORD,HANDLE,PDRIVER_FILTER pCurrentFilter);
typedef DWORD (* pFilterSeekFn)(DWORD,long,DWORD,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterControlFn)(DWORD,DWORD,PBYTE,DWORD,PBYTE,DWORD,PDWORD,HANDLE,PDRIVER_FILTER pCurrentFilter);
typedef void (* pFilterPowerupFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef void (* pFilterPowerdnFn)(DWORD,PDRIVER_FILTER pCurrentFilter);
typedef BOOL (* pFilterCancelIoFn)(DWORD, HANDLE,PDRIVER_FILTER pCurrentFilter);

#define DRIVER_FILTER_INTERFACE_VERSION_MAJOR  0
#define DRIVER_FILTER_INTERFACE_VERSION_MINOR  0

#define DRIVER_FILTER_INTERFACE_VERSION MAKELONG(DRIVER_FILTER_INTERFACE_VERSION_MINOR,DRIVER_FILTER_INTERFACE_VERSION_MAJOR)
#define GET_DRIVER_FILTER_INTERFACE_MAJOR(x) (WORD)(x>>16)
#define GET_DRIVER_FILTER_INTERFACE_MINOR(x) (WORD)(x)

typedef struct __DRIVER_FILTER {
    DWORD               dwFilterInterfaceVersion;
    pFDriverDeinitFn    fnFilterDeinit;
    PDRIVER_FILTER      pNextFilter; // Setup by DM after FilterInit called.
    
    // Driver's Entry
    pFilterInitFn         fnInit;             
    pFilterPreDeinitFn    fnPreDeinit;   
    pFilterDeinitFn       fnDeinit;         
    pFilterOpenFn         fnOpen;             
    pFilterPreCloseFn     fnPreClose;     
    pFilterCloseFn        fnClose;           
    pFilterReadFn         fnRead;
    pFilterWriteFn        fnWrite;
    pFilterSeekFn         fnSeek;
    pFilterControlFn      fnControl;
    pFilterPowerupFn      fnPowerup;       
    pFilterPowerdnFn      fnPowerdn;       
    pFilterCancelIoFn     fnCancelIo;     
    
} DRIVER_FILTER, *PDRIVER_FILTER;


typedef PDRIVER_FILTER  (*pInitEntry) ( LPCTSTR lpcFilterRegistryPath, LPCTSTR lpDeviceRegistryPath, PDRIVER_FILTER pNextFilter ) ;
    


#define DEFAULT_FILTER_REGISTRY_PATH TEXT("Drivers\\Filters\\")

#define DRIVER_FILTER_INIT_ENTRY TEXT("InitEntry")

#ifdef __cplusplus

class DriverFilterBase : public __DRIVER_FILTER {
private:
public:
    DriverFilterBase( LPCTSTR lpcRegistryPath,PDRIVER_FILTER pNextFilterParam) 
    {
        dwFilterInterfaceVersion = DRIVER_FILTER_INTERFACE_VERSION;
        fnFilterDeinit = FDriverDeinitStatic;
        pNextFilter = pNextFilterParam;
    
    // Driver's Entry
        fnInit = (pNextFilterParam!=NULL && pNextFilterParam->fnInit!=NULL)? FilterInitStatic: NULL;
        fnPreDeinit = (pNextFilterParam!=NULL && pNextFilterParam->fnPreDeinit!=NULL)? FilterPreDeinitStatic: NULL;
        fnDeinit = (pNextFilterParam!=NULL && pNextFilterParam->fnDeinit!=NULL)? FilterDeinitStatic: NULL;
        fnOpen = (pNextFilterParam!=NULL && pNextFilterParam->fnOpen!=NULL)? FilterOpenStatic: NULL;
        fnPreClose = (pNextFilterParam!=NULL && pNextFilterParam->fnPreClose!=NULL)? FilterPreCloseStatic: NULL;
        fnClose = (pNextFilterParam!=NULL && pNextFilterParam->fnClose!=NULL)? FilterCloseStatic: NULL;
        fnRead = (pNextFilterParam!=NULL && pNextFilterParam->fnRead!=NULL)? FilterReadStatic: NULL;
        fnWrite =(pNextFilterParam!=NULL && pNextFilterParam->fnWrite!=NULL)? FilterWriteStatic: NULL; 
        fnSeek = (pNextFilterParam!=NULL && pNextFilterParam->fnSeek!=NULL)? FilterSeekStatic: NULL; 
        fnControl = (pNextFilterParam!=NULL && pNextFilterParam->fnControl!=NULL)? FilterControlStatic: NULL; 
        fnPowerup = (pNextFilterParam!=NULL && pNextFilterParam->fnPowerup!=NULL)? FilterPowerupStatic: NULL; 
        fnPowerdn = (pNextFilterParam!=NULL && pNextFilterParam->fnPowerdn!=NULL)? FilterPowerdnStatic: NULL; 
        fnCancelIo = (pNextFilterParam!=NULL && pNextFilterParam->fnCancelIo!=NULL)? FilterCancelIoStatic: NULL; 
    };
    virtual Init() { return TRUE; };
    virtual ~DriverFilterBase() {};
    static VOID  FDriverDeinitStatic (PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            delete (DriverFilterBase *)pCurrentFilter;
        else {
            ASSERT(FALSE);
        }
    }
    static DWORD FilterInitStatic(DWORD dwContext,LPVOID lpParam,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterInit(dwContext, lpParam);
        else {
            ASSERT(FALSE);
            return 0;
        }
    }
    static BOOL FilterPreDeinitStatic(DWORD dwContext,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterPreDeinit(dwContext);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static BOOL FilterDeinitStatic(DWORD dwContext,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterDeinit(dwContext);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static DWORD FilterOpenStatic(DWORD dwConext,DWORD dwAccessCode,DWORD SharedMode,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterOpen(dwConext,dwAccessCode,SharedMode);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static BOOL FilterPreCloseStatic(DWORD dwOpenCont,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterPreClose(dwOpenCont);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static BOOL FilterCloseStatic(DWORD dwOpenCont,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterClose(dwOpenCont);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static DWORD FilterReadStatic(DWORD dwOpenCont,LPVOID pInBuf,DWORD cbSize,HANDLE hAsyncRef,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterRead(dwOpenCont,pInBuf,cbSize,hAsyncRef);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static DWORD FilterWriteStatic(DWORD dwOpenCont,LPCVOID pOutBuf,DWORD cbSize,HANDLE hAsyncRef,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterWrite(dwOpenCont,pOutBuf,cbSize,hAsyncRef);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static DWORD FilterSeekStatic(DWORD dwOpenCont,long lDistanceToMove,DWORD dwMoveMethod,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterSeek(dwOpenCont,lDistanceToMove,dwMoveMethod);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    static BOOL FilterControlStatic(DWORD dwOpenCont,DWORD dwCode, PBYTE pBufIn, DWORD dwLenIn, PBYTE pBufOut, DWORD dwLenOut,
              PDWORD pdwActualOut,HANDLE hAsyncRef,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterControl(dwOpenCont,dwCode,pBufIn,dwLenIn,pBufOut,dwLenOut,pdwActualOut,hAsyncRef);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
        
    }

    static void FilterPowerupStatic(DWORD dwConext,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter){
            ((DriverFilterBase *)pCurrentFilter)->FilterPowerup(dwConext);
        }
        else {
            ASSERT(FALSE);
        }
    }
    static void FilterPowerdnStatic(DWORD dwConext,PDRIVER_FILTER pCurrentFilter) {
        if (pCurrentFilter){
            return ((DriverFilterBase *)pCurrentFilter)->FilterPowerup(dwConext);
        }
        else {
            ASSERT(FALSE);
        }
    }
    static BOOL FilterCancelIoStatic(DWORD dwOpenCont, HANDLE hAsyncHandle,PDRIVER_FILTER pCurrentFilter){
        if (pCurrentFilter)
            return ((DriverFilterBase *)pCurrentFilter)->FilterCancelIo(dwOpenCont, hAsyncHandle);
        else {
            ASSERT(FALSE);
            return FALSE;
        }
    }
protected:
    virtual DWORD   FilterInit(DWORD dwContext,LPVOID lpParam) {
        return pNextFilter->fnInit(dwContext,lpParam,pNextFilter);
    }
    virtual BOOL    FilterPreDeinit(DWORD dwContext) {
        return pNextFilter->fnPreDeinit(dwContext,pNextFilter);
    }
    virtual BOOL    FilterDeinit(DWORD dwContext) {
        return pNextFilter->fnDeinit(dwContext,pNextFilter);
    }
    virtual DWORD   FilterOpen(DWORD dwConext,DWORD dwAccessCode,DWORD SharedMode) {
        return pNextFilter->fnOpen(dwConext,dwAccessCode,SharedMode,pNextFilter);
    }
    virtual BOOL    FilterPreClose(DWORD dwOpenCont) {
        return pNextFilter->fnPreClose(dwOpenCont, pNextFilter);
    }
    virtual BOOL    FilterClose(DWORD dwOpenCont) {
        return pNextFilter->fnClose(dwOpenCont,pNextFilter);
    }
    virtual DWORD   FilterRead(DWORD dwOpenCont,LPVOID pInBuf,DWORD cbSize,HANDLE hAsyncRef) {
        return pNextFilter->fnRead(dwOpenCont,pInBuf,cbSize,hAsyncRef,pNextFilter);
    }
    virtual DWORD   FilterWrite(DWORD dwOpenCont,LPCVOID pOutBuf,DWORD cbSize,HANDLE hAsyncRef) {
        return pNextFilter->fnWrite(dwOpenCont, pOutBuf, cbSize, hAsyncRef,pNextFilter);
    }
    virtual DWORD   FilterSeek(DWORD dwOpenCont,long lDistanceToMove,DWORD dwMoveMethod) {
        return pNextFilter->fnSeek(dwOpenCont,lDistanceToMove,dwMoveMethod,pNextFilter);
    }
    virtual BOOL    FilterControl(DWORD dwOpenCont,DWORD dwCode, PBYTE pBufIn, DWORD dwLenIn, PBYTE pBufOut, DWORD dwLenOut,
              PDWORD pdwActualOut,HANDLE hAsyncRef)
        {
        return pNextFilter->fnControl(dwOpenCont, dwCode, pBufIn, dwLenIn, pBufOut, dwLenOut, pdwActualOut, hAsyncRef,pNextFilter);
    }
    virtual void    FilterPowerup(DWORD dwConext) {
        return pNextFilter->fnPowerup(dwConext,pNextFilter) ;
    }
    virtual void    FilterPowerdn(DWORD dwConext ) {
        return pNextFilter->fnPowerdn(dwConext,pNextFilter);
    }
    virtual BOOL    FilterCancelIo(DWORD dwOpenCont, HANDLE hAsyncHandle) {
        return pNextFilter->fnCancelIo(dwOpenCont, hAsyncHandle, pNextFilter);
    }
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dsdispid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _DS_DISPIDS_H
#define _DS_DISPIDS_H

// Passing flags to MIDL on CE doesn't seem to work...
#if defined(WMPCE) || !defined(WMPCE)
#define helpstring(s) 
#endif

#include <idispids.h>

///////////////////////////////////////////////////////////////////////////////
//                              PROPERTIES
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ActiveMovie poperties
///////////////////////////////////////////////////////////////////////////////
#define DISPID_AM_IMAGESOURCEWIDTH              4       // Duplicate prop
#define DISPID_AM_IMAGESOURCEHEIGHT             5       // Duplicate prop
#define DISPID_AM_AUTHOR                        6       // Duplicate prop
#define DISPID_AM_TITLE                         7       // Duplicate prop
#define DISPID_AM_COPYRIGHT                     8       // Duplicate prop
#define DISPID_AM_DESCRIPTION                   9       // Duplicate prop
#define DISPID_AM_RATING                       10       // Duplicate prop
#define DISPID_AM_FILENAME                     11       // Duplicate prop
#define DISPID_AM_DURATION                     12       // Duplicate prop
#define DISPID_AM_CURRENTPOSITION              13       // Duplicate prop
#define DISPID_AM_PLAYCOUNT                    14       // Duplicate prop
#define DISPID_SELECTION_START                 15
#define DISPID_SELECTION_END                   16
#define DISPID_AM_CURRENTSTATE                 17       // Duplicate prop
#define DISPID_AM_RATE                         18       // Duplicate prop
#define DISPID_VOLUME                          19
#define DISPID_BALANCE                         20
#define DISPID_AM_ENABLECONTEXTMENU            21       // Duplicate prop
#define DISPID_SHOW_DISPLAY                    22
#define DISPID_SHOW_CONTROLS                   23
#define DISPID_SHOW_POSITION_CONTROLS          24
#define DISPID_SHOW_SELECTION_CONTROLS         25
#define DISPID_SHOW_TRACKER                    26
#define DISPID_ENABLE_POSITION_CONTROLS        27
#define DISPID_ENABLE_SELECTION_CONTROLS       28
#define DISPID_ENABLE_TRACKER                  29
#define DISPID_ALLOW_HIDE_DISPLAY              30
#define DISPID_ALLOW_HIDE_CONTROLS             31
#define DISPID_DISPLAY_MODE                    32
#define DISPID_ALLOW_CHANGE_DISPLAY_MODE       33
#define DISPID_FILTERGRAPH                     34
#define DISPID_FILTER_GRAPH_DISPATCH           35
#define DISPID_DISPLAY_FORE_COLOR              36
#define DISPID_DISPLAY_BACK_COLOR              37
#define DISPID_MOVIE_WINDOW_SIZE               38
#define DISPID_FULL_SCREEN_MODE                39
#define DISPID_AM_AUTOSTART                    40        // Duplicate prop
#define DISPID_AM_AUTOREWIND                   41        // Duplicate prop
#define DISPID_BORDER_STYLE                    42
#define DISPID_ISSOUNDCARDENABLED              53
#define DISPID_INFO                            0x6002004d   // hidden

///////////////////////////////////////////////////////////////////////////////
// NSPlay control properties
///////////////////////////////////////////////////////////////////////////////
#define DISPID_IMAGESOURCEWIDTH                 1001
#define DISPID_IMAGESOURCEHEIGHT                1002
#define DISPID_DURATION                         1003
#define DISPID_AUTHOR                           1004
#define DISPID_COPYRIGHT                        1005
#define DISPID_DESCRIPTION                      1006
#define DISPID_RATING                           1007
#define DISPID_TITLE                            1008
#define DISPID_SOURCELINK                       1009
#define DISPID_MARKERCOUNT                      1010
#define DISPID_CANSCAN                          1011
#define DISPID_CANSEEK                          1012
#define DISPID_SENDKEYBOARDEVENTS               1013
#define DISPID_SENDMOUSECLICKEVENTS             1014
#define DISPID_SENDMOUSEMOVEEVENTS              1015
#define DISPID_SENDSTATECHANGEEVENTS            1016
#define DISPID_AUTOSTART                        1017
#define DISPID_AUTOREWIND                       1018
#define DISPID_ALLOWCHANGECONTROLTYPE           1019
#define DISPID_INVOKEURLS                       1020
#define DISPID_ENABLECONTEXTMENU                1021
#define DISPID_TRANSPARENTATSTART               1022
#define DISPID_TRANSPARENTONSTOP                1023
#define DISPID_CLICKTOPLAY                      1025
#define DISPID_FILENAME                         1026
#define DISPID_CURRENTPOSITION                  1027
#define DISPID_RATE                             1028
#define DISPID_CURRENTMARKER                    1029
#define DISPID_PLAYCOUNT                        1030
#define DISPID_CURRENTSTATE                     1031
#define DISPID_DISPLAYSIZE                      1032
#define DISPID_MAINWINDOW                       1033
#define DISPID_CONTROLTYPE                      1034
#define DISPID_ALLOWSCAN                        1035
#define DISPID_CREATIONDATE                     1036
#define DISPID_BANDWIDTH                        1037
#define DISPID_ERRORCORRECTION                  1038
#define DISPID_RECEIVEDPACKETS                  1039
#define DISPID_RECOVEREDPACKETS                 1040
#define DISPID_LOSTPACKETS                      1041
#define DISPID_RECEPTIONQUALITY                 1042
#define DISPID_BUFFERINGCOUNT                   1043
#define DISPID_CURSORTYPE                       1044
#define DISPID_ANIMATIONATSTART                 1045
#define DISPID_ANIMATIONONSTOP                  1046
#define DISPID_CANSEEKTOMARKERS                 1047
#define DISPID_SESSIONSTART                     1048
#define DISPID_SESSIONEND                       1049
#define DISPID_CHANNELNAME                      1050
#define DISPID_CHANNELDESCRIPTION               1051
#define DISPID_CHANNELURL                       1052
#define DISPID_CONTACTADDRESS                   1053
#define DISPID_CONTACTPHONE                     1054
#define DISPID_CONTACTEMAIL                     1055
#define DISPID_ALLOWCHANGEDISPLAYSIZE           1056
#define DISPID_CODECCOUNT                       1057
#define DISPID_ISBROADCAST                      1058
#define DISPID_ISDURATIONVALID                  1059
#define DISPID_SOURCEPROTOCOL                   1060
#define DISPID_OPENSTATE                        1061
#define DISPID_SENDOPENSTATECHANGEEVENTS        1062
#define DISPID_SENDWARNINGEVENTS                1063
#define DISPID_SENDERROREVENTS                  1064
#define DISPID_HASERROR                         1065
#define DISPID_ERRORDESCRIPTION                 1066
#define DISPID_ERRORCODE                        1067 
#define DISPID_PLAYSTATE                        1068
#define DISPID_SENDPLAYSTATECHANGEEVENTS        1069
#define DISPID_BUFFERINGTIME                    1070
#define DISPID_USEFIXEDUDPPORT                  1071
#define DISPID_FIXEDUDPPORT                     1072
#define DISPID_USEHTTPPROXY                     1073
#define DISPID_HTTPPROXYHOST                    1074
#define DISPID_HTTPPROXYPORT                    1075
#define DISPID_ENABLEMULTICAST                  1076
#define DISPID_ENABLEUDP                        1077
#define DISPID_ENABLETCP                        1078
#define DISPID_ENABLEHTTP                       1079
#define DISPID_BUFFERINGPROGRESS                1080
#define DISPID_ENABLEAUTOPROXY                  1081
#define DISPID_BASEURL                          1082
#define DISPID_DEFAULTFRAME                     1083

///////////////////////////////////////////////////////////////////////////////
// DirectShow properties
///////////////////////////////////////////////////////////////////////////////
#define DISPID_SHOWCAPTIONING	                1084
#define DISPID_CAPTIONING_ID	                1085
#define DISPID_SHOWSTATUSBAR                    1086
#define DISPID_SHOWTOOLBAR                      1087
#define DISPID_SHOWGOTOBAR                      1088
#define DISPID_MUTE                             1089
#define DISPID_FULLSCREENCONTROLS               1090
#define DISPID_PREVIEWMODE			1091
#define DISPID_DIALOGAVAILABILITY               1092
#define DISPID_CANPREVIEW                       1093
#define DISPID_HASMULTIPLEITEMS                 1094
#define DISPID_LANGUAGE				1095
#define DISPID_AUDIOSTREAM			1096
#define DISPID_SAMISTYLE			1097
#define DISPID_SAMILANG				1098
#define DISPID_SAMIFILENAME			1099
#define DISPID_STREAMCOUNT                      1100
#define DISPID_VIDEOBORDER_WIDTH                1101
#define DISPID_VIDEOBORDER_COLOR                1102
#define DISPID_VIDEOBORDER_3D                   1103

#define DISPID_CLIENTID                         1106
#define DISPID_SHOWAUDIOCONTROLS                1107
#define DISPID_ENABLEFULLSCREENCONTROLS         1108
#define DISPID_ACTIVEMOVIE                      1109
#define DISPID_NSPLAY                           1110
#define DISPID_MEDIAPLAYER                      1111
#define DISPID_WINDOWLESSVIDEO                  1112
#define DISPID_CONNECTIONSPEED                  1113


#define DISPID_MPDVD                            1500
#define DISPID_MPDVDCONTROL                     1501
#define DISPID_MPDVDINFO                        1502
#define DISPID_MPDVDCONFIG                      1503
#define DISPID_DVDNOTIFY                        1505

#define DISPID_DOEVENT                          1506

#define DISPID_DVD_TITLEPLAY                    1507
#define DISPID_DVD_CHAPTERPLAY                  1508
#define DISPID_DVD_TIMEPLAY                     1509
#define DISPID_DVD_STOPRESUME                   1510
#define DISPID_DVD_GOUP                         1511
#define DISPID_DVD_TIMESEARCH                   1512
#define DISPID_DVD_CHAPTERSEARCH                1513
#define DISPID_DVD_PREVPGSEARCH                 1514
#define DISPID_DVD_TOPPGSEARCH                  1515    
#define DISPID_DVD_NEXTPGSEARCH                 1516
#define DISPID_DVD_FORWARDSCAN                  1517
#define DISPID_DVD_BACKWARDSCAN                 1518
#define DISPID_DVD_MENUCALL                     1519    
#define DISPID_DVD_RESUME                       1520
#define DISPID_DVD_UPPERBUTTONSELECT            1521
#define DISPID_DVD_LOWERBUTTONSELECT            1522
#define DISPID_DVD_LEFTBUTTONSELECT             1523
#define DISPID_DVD_RIGHTBUTTONSELECT            1524
#define DISPID_DVD_BUTTONACTIVATE               1525
#define DISPID_DVD_BUTTONSELECTANDACTIVATE      1526
#define DISPID_DVD_STILLOFF                     1527
#define DISPID_DVD_PAUSEON                      1528
#define DISPID_DVD_PAUSEOFF                     1529
#define DISPID_DVD_MENULANGSEL                  1530
#define DISPID_DVD_AUDIOSTREAMCHANGE            1531
#define DISPID_DVD_SUBPICTURESTREAMCHANGE       1532    
#define DISPID_DVD_ANGLECHANGE                  1533
#define DISPID_DVD_PARENTALLEVELSELECT          1534
#define DISPID_DVD_PARENTALCONTRYSELECT         1535
#define DISPID_DVD_KARAOKEMODE                  1536
#define DISPID_DVD_VIDEOMODEPREF                1537
#define DISPID_DVD_ROOT                         1538
#define DISPID_DVD_MOUSEACTIVATE                1539
#define DISPID_DVD_MOUSESELECT                  1540
#define DISPID_DVD_CHAPTERPLAYAUTOSTOP          1541
#define DISPID_DVD_DOMAIN                       1542
#define DISPID_DVD_AUDIOSTREAMSAVAIL            1543
#define DISPID_DVD_CURRENTAUDIOSTREAM           1544
#define DISPID_DVD_CURRENTSUBPICTURESTREAM      1545
#define DISPID_DVD_SUBPICTURESTREAMSAVAIL       1546
#define DISPID_DVD_SUBPICTUREON                 1547
#define DISPID_DVD_CURRENTANGLE                 1548
#define DISPID_DVD_ANGLESAVAILABLE              1549

#define DISPID_DVD_NUMBEROFCHAPTERS             1550
#define DISPID_DVD_GETAUDIOLANGUAGE             1551
#define DISPID_DVD_GETBUTTON                    1552
#define DISPID_DVD_GETDOMAIN                    1553
#define DISPID_DVD_GETLOCATION                  1554
#define DISPID_DVD_GETSUBPICTURELANG            1555
#define DISPID_DVD_PARENTALLEVEL                1556

#define DISPID_DVD_GETUOPS                      1558
#define DISPID_DVD_GETALLSPRMS                  1559
#define DISPID_DVD_GETALLGPRMS                  1560
#define DISPID_DVD_GETVIDEOATTRIBUTES           1561
#define DISPID_DVD_GETAUDIOATTRIBUTES           1562
#define DISPID_DVD_GETSUBPICTUREATTRIBUTES      1563
#define DISPID_DVD_GETTITLEATTRIBUTES           1564
#define DISPID_DVD_GETVMGATTRIBUTES             1565
#define DISPID_DVD_GETDVDTEXTINFO               1566
#define DISPID_DVD_GETTITLENUM                  1567
#define DISPID_DVD_GETCHAPTERNUM                1568
#define DISPID_DVD_CURRENTTIME                  1569

#define DISPID_DVD_CURRENTBUTTON                1570
#define DISPID_DVD_BUTTONSAVAIL                 1571

#define DISPID_DVD_PARENTALCOUNTRY              1572
#define DISPID_DVD_FRAMESPERSECOND              1573
#define DISPID_DVD_CURRENTDOMAIN                1574
#define DISPID_DVD_TITLESAVAILABLE              1575
#define DISPID_DVD_VOLUMESAVAILABLE             1576
#define DISPID_DVD_CURRENTVOLUME                1577
#define DISPID_DVD_CURRENTDISCSIDE              1578
#define DISPID_DVD_CURRENTUOPS                  1579
#define DISPID_DVD_CURRENTCCSERVICE             1580
#define DISPID_DVD_CCACTIVE                     1581
#define DISPID_DVD_GETTOTALTITLETIME            1582
#define DISPID_DVD_GETTITLEPARENTALLEVEL        1583
#define DISPID_DVD_UNIQUEID                     1584
#define DISPID_DVD_COLORKEY                     1585


///////////////////////////////////////////////////////////////////////////////
//                          METHODS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ActiveMovie methods 
///////////////////////////////////////////////////////////////////////////////
#define DISPID_RUN                     0x60020001
#define DISPID_AM_PAUSE                0x60020002    // duplicate method
#define DISPID_AM_STOP                 0x60020003    // duplicate method

///////////////////////////////////////////////////////////////////////////////
// NSPlay control methods - 10 of our own currently + 1 "stock" AboutBox property
///////////////////////////////////////////////////////////////////////////////
#define DISPID_PLAY                     2001
#define DISPID_PAUSE                    2002    
#define DISPID_STOP                     2003    
#define DISPID_GETMARKERTIME            2004
#define DISPID_GETMARKERNAME            2005
#define DISPID_CANCEL                   2006
#define DISPID_GETCODECINSTALLED        2007
#define DISPID_GETCODECDESCRIPTION      2008
#define DISPID_GETCODECURL              2009
#define DISPID_OPEN                     2010                                

///////////////////////////////////////////////////////////////////////////////
// DirectShow methods
///////////////////////////////////////////////////////////////////////////////
#define DISPID_GETMOREINFOURL           2011
#define DISPID_FILEPROPERTIESDIALOG	    2012
#define DISPID_STATISTICSDIALOG	        2013
#define DISPID_GOTODIALOG	            2014
#define DISPID_STREAMSELECT             2015
#define DISPID_GETMEDIAINFOSTRING       2016
#define DISPID_DOWNLOADIMAGE            2017
#define DISPID_NAVIGATEBROWSERTOURL     2018
#define DISPID_GETSTREAMNAME            2019
#define DISPID_GETSTREAMGROUP           2020
#define DISPID_GETSTREAMSELECTED        2021
#define DISPID_PREVIOUS                 2022
#define DISPID_NEXT                     2023
#define DISPID_FASTFORWARD              2024
#define DISPID_FASTREVERSE              2025
#define DISPID_PREVIEW                  2026
#define DISPID_WAIT                     2027
#define DISPID_GETMEDIAPARAMETER        2028
#define DISPID_GETMEDIAPARAMETERNAME    2029
#define DISPID_ENTRYCOUNT               2030
#define DISPID_GETCURRENTENTRY          2031
#define DISPID_SETCURRENTENTRY          2032
#define DISPID_SHOWDIALOG               2033

///////////////////////////////////////////////////////////////////////////////
//                                  EVENTS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//                  ActiveMovie events
///////////////////////////////////////////////////////////////////////////////
#define DISPID_AM_STATECHANGE                   1   // duplicate event
#define DISPID_POSITIONCHANGE                   2
#define DISPID_TIMER                            3
#define DISPID_OPENCOMPLETE                    50
#define DISPID_DISPLAYMODECHANGE               51
#define DISPID_AM_SCRIPTCOMMAND	               52   // duplicate event
#define DISPID_AM_ERROR                        999  // duplicate event

///////////////////////////////////////////////////////////////////////////////
// NSPlay control events - 12 of our own currently + 8 "stock" keyboard + mouse events
///////////////////////////////////////////////////////////////////////////////
#define DISPID_SCRIPTCOMMAND            3001
#define DISPID_ENDOFSTREAM              3002
#define DISPID_BUFFERING                3003
#define DISPID_DISCONNECT               3004
#define DISPID_STATECHANGE              3005
#define DISPID_MARKERHIT                3006
#define DISPID_AUTOSTARTFAILURE         3007
#define DISPID_NEWSTREAM                3008
#define DISPID_WARNING                  3009
#define DISPID_ERROR                    3010
#define DISPID_OPENSTATECHANGE          3011
#define DISPID_PLAYSTATECHANGE          3012

///////////////////////////////////////////////////////////////////////////////
// DirectShow events 
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//                          INTERNAL PROPERTIES
///////////////////////////////////////////////////////////////////////////////

// Toolbar properties
#define DISPID_AMTFLAT			6000
#define DISPID_AMTDOWNLOADED		6001
#define DISPID_AMTRESET			6002
#define DISPID_AMTHIGHLIGHTCOLOR	6003
#define DISPID_AMTSHADOWCOLOR		6004
#define DISPID_AMTSHOWBORDER		6005
#define DISPID_AMTSTATICCOLOR		6006
#define DISPID_AMTDOWNLOADCOLOR		6007
#define DISPID_AMTVIEWEDCOLOR		6008
#define DISPID_AMTVIEWED		6009
#define DISPID_AMTSTATUSTEXT            6010
#define DISPID_AMTSHOWAUDIOCONTROLS     6011
#define DISPID_AMTFULLSCREEN            6012
#define DISPID_SHOWCANCEL               6013
#define DISPID_AMTMINWIDTH              6014
#define DISPID_AMTRESTARTPLAYLIST       6015
#define DISPID_REOPENURL                6016
#define DISPID_AMTALLOWPAUSE            6017

// Ad Banner control properties
#define DISPID_IMAGEURL                 6100
#define DISPID_IMAGEJUSTIFYWIDTH        6101
#define DISPID_DESTINATIONURL           6102
#define DISPID_LAUNCHBROWSER            6103
#ifndef DISPID_CLEAR
#define DISPID_CLEAR 			6104
#endif

// More toolbar id's

// common control properties
#define DISPID_CONTAINERTIMER           6200
#define DISPID_VISIBLE                  6201
// common control methods

// More toolbar id's
#define DISPID_SKIPFORWARD              6301
#define DISPID_SKIPREVERSE              6302

///////////////////////////////////////////////////////////////////////////////
//                             INTERNAL EVENTS
///////////////////////////////////////////////////////////////////////////////

// Toolbar events	
#define DISPID_AMTSTATECHANGE           8001
#define DISPID_AMTCANCEL                8002
#define DISPID_AMTDOWNLOADCOMPLETE      8003

// Player launch methods
#define DISPID_LOADMONIKER              8004
#define DISPID_LOADMONIKER2             8005
#endif // _DS_DISPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dsgetdc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: DsGetDc.h

Purpose: Declares structures and routines related to DsGetDcNameW.
--*/


#ifndef _DSGETDC_
#define _DSGETDC_

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

// WinCE does not support any DsGetDcName() flags for input.
// It always contacts an LDAP server to perform its query.

//
// Structure returned from DsGetDcName
//

typedef struct _DOMAIN_CONTROLLER_INFOW {
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerName;
#else // MIDL_PASS
    LPWSTR DomainControllerName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainControllerAddress;
#else // MIDL_PASS
    LPWSTR DomainControllerAddress;
#endif // MIDL_PASS
    ULONG DomainControllerAddressType;
    GUID DomainGuid;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DomainName;
#else // MIDL_PASS
    LPWSTR DomainName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *DnsForestName;
#else // MIDL_PASS
    LPWSTR DnsForestName;
#endif // MIDL_PASS
    ULONG Flags;
#ifdef MIDL_PASS
    [string,unique] wchar_t *DcSiteName;
#else // MIDL_PASS
    LPWSTR DcSiteName;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [string,unique] wchar_t *ClientSiteName;
#else // MIDL_PASS
    LPWSTR ClientSiteName;
#endif // MIDL_PASS
} DOMAIN_CONTROLLER_INFOW, *PDOMAIN_CONTROLLER_INFOW;

#define DOMAIN_CONTROLLER_INFO DOMAIN_CONTROLLER_INFOW
#define PDOMAIN_CONTROLLER_INFO PDOMAIN_CONTROLLER_INFOW


//
// Values for returned Flags
//

#define DS_PDC_FLAG            0x00000001    // DC is PDC of Domain
#define DS_GC_FLAG             0x00000004    // DC is a GC of forest
#define DS_LDAP_FLAG           0x00000008    // Server supports an LDAP server
#define DS_DS_FLAG             0x00000010    // DC supports a DS and is a Domain Controller
#define DS_KDC_FLAG            0x00000020    // DC is running KDC service
#define DS_TIMESERV_FLAG       0x00000040    // DC is running time service
#define DS_CLOSEST_FLAG        0x00000080    // DC is in closest site to client
#define DS_WRITABLE_FLAG       0x00000100    // DC has a writable DS
#define DS_GOOD_TIMESERV_FLAG  0x00000200    // DC is running time service (and has clock hardware)
#define DS_NDNC_FLAG           0x00000400    // DomainName is non-domain NC serviced by the LDAP server
#define DS_PING_FLAGS          0x0000FFFF    // Flags returned on ping

#define DS_DNS_CONTROLLER_FLAG 0x20000000    // DomainControllerName is a DNS name
#define DS_DNS_DOMAIN_FLAG     0x40000000    // DomainName is a DNS name
#define DS_DNS_FOREST_FLAG     0x80000000    // DnsForestName is a DNS name

//
// Function Prototypes
//

DWORD
WINAPI
DsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

#define DsGetDcName DsGetDcNameW

// Free buffers allocated with DsGetDcNameW()
NET_API_STATUS NetApiBufferFree(LPVOID Buffer);


#ifdef __cplusplus
}
#endif


#endif // _DSGETDC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dshow.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

#ifndef __DSHOW_INCLUDED__
#define __DSHOW_INCLUDED__

// for DX8 streams.h has been renamed to dshow.h so for compatibility
// we can use either streams.h or dshow.h on Windows CE
#include <streams.h>

#endif // __DSHOW_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dshowwmibase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media Foundation
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************

// Windows XP version of WMI instrumentation headers.

#if !defined(__MFWMIBASE_H__)
#define __MFWMIBASE_H__

#include <wmistr.h>
#include <evntrace.h>

// specify calling convention? !!!
typedef void (*PfnOnStateChanged)(void);

struct WmiInfo
{
    WmiInfo():
        fEventTracingAvailable(FALSE),
        hWmiTrace(NULL)
    {}
        
    BOOL fEventTracingAvailable;
    ULONG ulWmiEnableFlags;
    UCHAR ucWmiEnableLevel;
    TRACEHANDLE hWmiTrace;
    TRACEHANDLE hWmiReg;
    PfnOnStateChanged pfnOnStateChanged;   
};
                                              
BOOL WmiInit(WmiInfo* pWmiInfo, const GUID *pControlGuid, LPCWSTR wzKeyName, PfnOnStateChanged pfnOnStateChanged);
void WmiShutdown(WmiInfo* pWmiInfo);

#endif // __MFWMIBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dshowwmiguid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//  DShow WMI Instrumentation Structures and GUIDs

#if !defined(__MFWMIGUID_H__)
#define __MFWMIGUID_H__
#ifdef __cplusplus
extern "C" {
#endif

//
// {8959E8FC-BAE3-44f4-9A62-C50284504A03}
DEFINE_GUID(DSHOWWMIGUID, 
0x8959e8fc, 0xbae3, 0x44f4, 0x9a, 0x62, 0xc5, 0x2, 0x84, 0x50, 0x4a, 0x3);

//==============================
// Event GUIDs are defined here.
//==============================

//------------------------
// Object event
//  This event is reported when an object is created or deleted.
//
// {54A408BF-345E-4307-8B52-1AD937531913}
DEFINE_GUID(DSHOWWMIGUID_OBJECT_EVENT, 
0x54a408bf, 0x345e, 0x4307, 0x8b, 0x52, 0x1a, 0xd9, 0x37, 0x53, 0x19, 0x13);

//------------------------
// Dropping/glitching/starvation events
//
// {D42659AC-94F7-4a72-BBED-8D1E53A5C94A}
DEFINE_GUID(DSHOWWMIGUID_VIDEO_FRAME_GLITCH_EVENT, 
0xd42659ac, 0x94f7, 0x4a72, 0xbb, 0xed, 0x8d, 0x1e, 0x53, 0xa5, 0xc9, 0x4a);

// {BDE2A764-BED5-4632-A108-F0B02D90A073}
DEFINE_GUID(DSHOWWMIGUID_DATA_DROP_EVENT, 
0xbde2a764, 0xbed5, 0x4632, 0xa1, 0x8, 0xf0, 0xb0, 0x2d, 0x90, 0xa0, 0x73);

// {A8894BCF-E056-425a-964C-16770E181756}
DEFINE_GUID(DSHOWWMIGUID_AUDIORENDERER_STARVATION_EVENT, 
0xa8894bcf, 0xe056, 0x425a, 0x96, 0x4c, 0x16, 0x77, 0xe, 0x18, 0x17, 0x56);

//------------------------
// ClockGetTime Event
// {85C88917-519D-456b-9FA8-B6899BBFABF1}
DEFINE_GUID(DSHOWWMIGUID_CLOCK_GETTIME_EVENT, 
0x85c88917, 0x519d, 0x456b, 0x9f, 0xa8, 0xb6, 0x89, 0x9b, 0xbf, 0xab, 0xf1);

//------------------------
// ClockSetTime Event
// {918787B6-2046-4eac-A77D-DC36ABA7EDE1}
DEFINE_GUID(DSHOWWMIGUID_CLOCK_SETTIME_EVENT, 
0x918787b6, 0x2046, 0x4eac, 0xa7, 0x7d, 0xdc, 0x36, 0xab, 0xa7, 0xed, 0xe1);

//------------------------
// Stream event
// {43EB4C9E-A770-45a1-91D8-144657B3EBD2}
DEFINE_GUID(DSHOWWMIGUID_STREAM_EVENT, 
0x43eb4c9e, 0xa770, 0x45a1, 0x91, 0xd8, 0x14, 0x46, 0x57, 0xb3, 0xeb, 0xd2);

//------------------------
// MEDIATYPE change event
// {574FDB59-AB53-4e60-98EB-C735A757159F}
DEFINE_GUID(DSHOWWMIGUID_MEDIATYPE_CHANGE_EVENT, 
0x574fdb59, 0xab53, 0x4e60, 0x98, 0xeb, 0xc7, 0x35, 0xa7, 0x57, 0x15, 0x9f);

//------------------------
// Buffer event
// {12F1BA5C-368B-4491-ADFD-72C0558ADF9C}
DEFINE_GUID(DSHOWWMIGUID_BUFFER_EVENT, 
0x12f1ba5c, 0x368b, 0x4491, 0xad, 0xfd, 0x72, 0xc0, 0x55, 0x8a, 0xdf, 0x9c);

//-------------------------
// Unusual streaming event
// {191E80E7-58E5-4b55-B569-B879ACF9872A}
DEFINE_GUID(DSHOWWMIGUID_UNUSUAL_STREAMING_EVENT, 
0x191e80e7, 0x58e5, 0x4b55, 0xb5, 0x69, 0xb8, 0x79, 0xac, 0xf9, 0x87, 0x2a);

//-------------------------
// Disk events
// {0636675E-F10B-4127-9FB7-FD6DD137CF36}
DEFINE_GUID(DSHOWWMIGUID_DISKIO_REQUEST_EVENT, 
0x636675e, 0xf10b, 0x4127, 0x9f, 0xb7, 0xfd, 0x6d, 0xd1, 0x37, 0xcf, 0x36);

// {71F1BE77-9369-4be1-BA3C-087E0AA0A105}
DEFINE_GUID(DSHOWWMIGUID_DISKIO_COMPLETE_EVENT, 
0x71f1be77, 0x9369, 0x4be1, 0xba, 0x3c, 0x8, 0x7e, 0xa, 0xa0, 0xa1, 0x5);

// {75C0B368-BFFA-4b3e-8004-34627B947070}
DEFINE_GUID(DSHOWWMIGUID_FILE_OPEN_EVENT, 
0x75c0b368, 0xbffa, 0x4b3e, 0x80, 0x4, 0x34, 0x62, 0x7b, 0x94, 0x70, 0x70);

//-------------------------
// Renderer events
// {A71FD694-523D-46b7-86C7-5C6AD041B828}
DEFINE_GUID(DSHOWWMIGUID_RENDER_REND_EVENT, 
0xa71fd694, 0x523d, 0x46b7, 0x86, 0xc7, 0x5c, 0x6a, 0xd0, 0x41, 0xb8, 0x28);

//-------------------------
// Buffer fullness events
// {D5319DB6-91D7-4136-969F-232CA341BEA2}
DEFINE_GUID(DSHOWWMIGUID_AUDIORENDERER_BUFFERFULLNESS_EVENT, 
0xd5319db6, 0x91d7, 0x4136, 0x96, 0x9f, 0x23, 0x2c, 0xa3, 0x41, 0xbe, 0xa2);

//-------------------------
// State change events
// {217A0449-FF1F-4e50-AE79-E20F3C0199BE}
DEFINE_GUID(DSHOWWMIGUID_STATE_CHANGE_EVENT, 
0x217a0449, 0xff1f, 0x4e50, 0xae, 0x79, 0xe2, 0xf, 0x3c, 0x1, 0x99, 0xbe);

//-------------------------
// Netsource events
// {E35D5AB8-84C1-4c8a-BCC7-3CBFDD087176}
DEFINE_GUID(DSHOWWMIGUID_NETSOURCE_EVENT, 
0xe35d5ab8, 0x84c1, 0x4c8a, 0xbc, 0xc7, 0x3c, 0xbf, 0xdd, 0x8, 0x71, 0x76);

//-------------------------
// HTTP Bytestream events
// {1F89DEEF-93DD-4143-9624-6398775CC6BE}
DEFINE_GUID(DSHOWWMIGUID_HTTP_BYTESTREAM_EVENT, 
0x1f89deef, 0x93dd, 0x4143, 0x96, 0x24, 0x63, 0x98, 0x77, 0x5c, 0xc6, 0xbe);

//-------------------------
// SourceResolver events
// {803D39AE-1752-4f20-A4E3-F00AFC856FFD}
DEFINE_GUID(DSHOWWMIGUID_SOURCERESOLUTION_EVENT, 
0x803d39ae, 0x1752, 0x4f20, 0xa4, 0xe3, 0xf0, 0xa, 0xfc, 0x85, 0x6f, 0xfd);

//-------------------------
// Quality Manager events
// {726E9FAD-B975-4d40-A2B6-EE9508BC453D}
DEFINE_GUID(DSHOWWMIGUID_QM_EVENT, 
0x726e9fad, 0xb975, 0x4d40, 0xa2, 0xb6, 0xee, 0x95, 0x8, 0xbc, 0x45, 0x3d);

//-------------------------
// Adjust sample time events
// {873A2476-7943-409c-AA20-18D0037E23F8}
DEFINE_GUID(DSHOWWMIGUID_ADJUST_SAMPLE_TIME_EVENT, 
0x873a2476, 0x7943, 0x409c, 0xaa, 0x20, 0x18, 0xd0, 0x3, 0x7e, 0x23, 0xf8);

//------------------------
// Renderer Events
// {A01E93E9-9082-48f6-A660-A49E60A2073E}
DEFINE_GUID(DSHOWWMIGUID_VIDEO_RENDER_EVENT, 
0xa01e93e9, 0x9082, 0x48f6, 0xa6, 0x60, 0xa4, 0x9e, 0x60, 0xa2, 0x7, 0x3e);

// {5062CCCB-D77F-4de8-B58F-E750CD8D1E2B}
DEFINE_GUID(DSHOWWMI_GUID_AUDIO_RENDER_EVENT, 
0x5062cccb, 0xd77f, 0x4de8, 0xb5, 0x8f, 0xe7, 0x50, 0xcd, 0x8d, 0x1e, 0x2b);

//-------------------------
// Muxer Events
// {F002E858-D408-4eea-8DB9-DC02C1494C80}
DEFINE_GUID(DSHOWWMIGUID_MUXER_EVENT, 
0xf002e858, 0xd408, 0x4eea, 0x8d, 0xb9, 0xdc, 0x2, 0xc1, 0x49, 0x4c, 0x80);

//------------------------
// Timer Late event
// {213E13E2-724B-4a6e-B949-1C04426A1527}
DEFINE_GUID(DSHOWWMIGUID_TIMER_LATE_EVENT, 
0x213e13e2, 0x724b, 0x4a6e, 0xb9, 0x49, 0x1c, 0x4, 0x42, 0x6a, 0x15, 0x27);

//-------------------------
// Lock event
// {8BA1189D-AE62-40b1-B2B6-4944989B1BDA}
DEFINE_GUID(DSHOWWMIGUID_LOCK_EVENT, 
0x8ba1189d, 0xae62, 0x40b1, 0xb2, 0xb6, 0x49, 0x44, 0x98, 0x9b, 0x1b, 0xda);

//-------------------------
// Graph events
// {6FE6BC72-BA71-46a8-8A77-0DD13102B9AF}
DEFINE_GUID(DSHOWWMIGUID_GRAPH_EVENT, 
0x6fe6bc72, 0xba71, 0x46a8, 0x8a, 0x77, 0xd, 0xd1, 0x31, 0x2, 0xb9, 0xaf);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dshowwmi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma once

#include <dshowWmiBase.h>
extern WmiInfo g_WmiInfo;

#include <dshowwmistr.h>

typedef unsigned __int64 QWORD;

extern DBGPARAM dpCurSettings;

#define CELID_DSHOW_BASE        (CELID_USER + 0x300)
#define CELID_DSHOW_PACKET      (CELID_DSHOW_BASE)              // deprecated, old perf logging style
#define CELID_DSHOW_OBJECT      (CELID_DSHOW_BASE + 1)          // deprecated, old perf logging style
#define CELID_DSHOW_EVENT_TRACE (CELID_DSHOW_BASE + 2)
#define CELID_DSHOW_MAX         (CELID_DSHOW_BASE + 3)

__inline void TraceEvent (TRACEHANDLE TraceHandle, EVENT_TRACE_HEADER *pEventHeader)
{
    LARGE_INTEGER liCounter;
    liCounter.QuadPart = 0;
    QueryPerformanceCounter(&liCounter);

    pEventHeader->ThreadId = GetCurrentThreadId();
    pEventHeader->ProcessId = GetCurrentProcessId();
    pEventHeader->TimeStamp = liCounter;
    CeLogData (TRUE, CELID_DSHOW_EVENT_TRACE, pEventHeader, pEventHeader->Size, 1, CELZONE_MISC, 0, FALSE);
}


#define INVALID_SAMPLE_TIME _I64_MAX
#define INVALID_SAMPLE_DURATION _I64_MAX
#define INVALID_COUNT_BYTE  _I32_MIN
#define DONT_CARE_TIME      _I64_MIN // when time does not matter

#define NULL_SCENARIO_IID  {0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0} }
#define SCENARIOIID_IS_NULL(id) ((id.Data1==0)&&(id.Data2==0)&&(id.Data3==0)&&\
                                (id.Data4[0]==0)&&(id.Data4[1]==0)&&(id.Data4[2]==0)&&\
                                (id.Data4[3]==0)&&(id.Data4[4]==0)&&(id.Data4[5]==0)&&\
                                (id.Data4[6]==0)&&(id.Data4[7]==0))

typedef GUID    SCENARIOIID ;
typedef GUID *  PSCENARIOIID ;

inline ULONGLONG WMI_COUNTER( void ) {
    LARGE_INTEGER liCounter;
    liCounter.QuadPart = 0;
    if (g_WmiInfo.ucWmiEnableLevel > 0) {
        QueryPerformanceCounter(&liCounter);
    }
    return (ULONGLONG)liCounter.QuadPart;
}

#define WMI_MEASURE_START ULONGLONG ullStart = WMI_COUNTER()
#define WMI_MEASURE_END (WMI_COUNTER() - ullStart)
#define WMI_IS_LOGGING (g_WmiInfo.ulWmiEnableLevel > 0)

#define FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, eventGuid, eventType, pObject ) \
        FILL_DSHOWPERFINFO_COMMON_PTR( &perfData, sizeof(perfData), dwReporterTag, eventGuid, eventType, pObject)

#define FILL_DSHOWPERFINFO_COMMON_PTR( pperfData, dwSize, dwTag, eventGuid, eventType, pObj ){\
        ZeroMemory(pperfData, dwSize);                                        \
        (pperfData)->hdr.wmiHeader.Size         = (USHORT)(dwSize);           \
        (pperfData)->hdr.wmiHeader.Flags        = WNODE_FLAG_TRACED_GUID;     \
        (pperfData)->hdr.wmiHeader.Guid         = (eventGuid);                \
        (pperfData)->hdr.wmiHeader.Class.Type   = (eventType);                \
        (pperfData)->hdr.pObject                = (DSHOWWMI_PTR)(pObj);          \
        (pperfData)->hdr.dwReporterTag          = (dwTag);                    \
    }


//
// These boolean macros are defined so that expensive events can be by-passed by provider
// modules quickly when logging is not enabled.
// WMILOG_* in-line functions use thes too so we can adjust the control easily at this place.
// The convention is b##WMILOG_* to signify a boolean. As more events are added, at some
// point we might add conditions to the expressions to finer control what get logged. Finer
// controls may use masks and more levels.
//

#ifdef SHIP_BUILD

// Critical events
#define bWMILOG_AUDIORENDER_STARVATION  (0)
#define bWMILOG_VIDEO_FRAME_GLITCH      (0)
#define bWMILOG_DATA_DROP               (0)
#define bWMILOG_STATE_CHANGE            (0)
#define bWMILOG_CLOCK_SETTIME           (0)

// Warning events
#define bWMILOG_MEDIATYPE_CHANGE        (0)
#define bWMILOG_UNUSUAL_STREAMING_EVENT (0)
#define bWMILOG_FILE_OPEN               (0)
#define bWMILOG_NETSOURCE               (0)
#define bWMILOG_ADJUST_SAMPLE_TIME      (0)
#define bWMILOG_TIMER_LATE              (0)

// Trace events
#define bWMILOG_BUFFER                  (0)
#define bWMILOG_OBJECT                  (0)
#define bWMILOG_DISKIO_REQUEST          (0)
#define bWMILOG_DISKIO_COMPLETE         (0)
#define bWMILOG_RENDERER_REND           (0)
#define bWMILOG_MUXER                   (0)

// Need to use events (warning level)
#define bWMILOG_AUDIORENDERER_BUFFERFULLNESS (0)
#define bWMILOG_SOURCERESOLUTION             (0)
#define bWMILOG_QM                           (0)
#define bWMILOG_VIDEO_RENDER                 (0)
#define bWMILOG_AUDIO_RENDER                 (0)

// Need to use events (verbose level)
#define bWMILOG_CLOCK_GETTIME           (0)
#define bWMILOG_LOCK                    (0)
#define bWMILOG_STREAM                  (0)
#define bWMILOG_HTTP_BYTESTREAM         (0)


#define WMILOG_OBJECT(dwReporterTag,lActionType,pObject,lObjectType) (void(0))
#define WMILOG_AUDIORENDER_STARVATION(dwReporterTag,pObject,ullCount) (void(0))
#define WMILOG_VIDEO_FRAME_GLITCH(dwReporterTag,pObject,dwObjectID,pSample,llSampleTime,llTargetSystemTime,llOffset) (void(0))
#define WMILOG_DATA_DROP(dwReporterTag,dwDataType,pObject,dwObjectID,llSampleTime,cbDropped,dwReasons) (void(0))
#define WMILOG_CLOCK_GETTIME(dwReporterTag,pObject,llTime) (void(0))
#define WMILOG_CLOCK_SETTIME(dwReporterTag,pObject,llTime,llDelta) (void(0))
#define WMILOG_STREAM(dwReporterTag,lStreamType,pObject) (void(0))
#define WMILOG_MEDIATYPE_CHANGE(dwReporterTag,pObject,pStream,cbNewType,pbNewType) (void(0))
#define WMILOG_BUFFER(dwReporterTag,pObject,Type,dwObjectCategory,pStream,llTimestamp,pClock,pSample,cbBuffer,cbSample,llDuration) (void(0))
#define WMILOG_UNUSUAL_STREAMING_EVENT(dwReporterTag,Type,pObject,dwEvent) (void(0))
#define WMILOG_FILE_OPEN(dwReporterTag,pObject,h,pwszName) (void(0))
#define WMILOG_FILE_CLOSE(dwReporterTag,pObject,h,pwszName) (void(0))
#define WMILOG_DISKIO_REQUEST(dwReporterTag,Type,pObject,h,qwOffset,bCount) (void(0))
#define WMILOG_DISKIO_COMPLETE(dwReporterTag,Type,pObject,h) (void(0))
#define WMILOG_RENDERER_REND(dwReporterTag,Type,pObject,pSample,llTime,llDuration,llClock) (void(0))
#define WMILOG_RENDERER_MIX(dwReporterTag,Type,pObject,pSample,llTime,llDuration,llClock) \
    WMILOG_RENDERER_REND(dwReporterTag,Type,pObject,pSample,llTime,llDuration,llClock)

#define WMILOG_AUDIORENDERER_BUFFERFULLNESS(dwReporterTag,pObject,dwFullness) (void(0))
#define WMILOG_STATE_CHANGE(dwReporterTag,pObject,dwStateChange) (void(0))
#define WMILOG_NETSOURCE(dwReporterTag,pObject,Type,Arg1,Arg2) (void(0))
#define WMILOG_HTTP_BYTESTREAM(dwReporterTag,pObject,Type) (void(0))
#define WMILOG_SOURCERESOLUTION(dwReporterTag,pObject,Type,pwszURL,pObjectCreated,hr) (void(0))
#define WMILOG_QM(dwReporterTag,pObject,Type,dwKnobId,dwPrevLevel,dwNewLevel,llDropTime) (void(0))
#define WMILOG_ADJUST_SAMPLE_TIME(dwReporterTag,pObject,ucType,llOriginalSampleTime,llAdjustment) (void(0))
#define WMILOG_VIDEO_RENDER(dwReporterTag,pObject,pSample,llSampleTime,llSampleDuration,llClockTime,hwndVideo,dwRefreshRate,dwWidth,dwHeight,dwLeft,dwTop,dwRight,dwBottom,dwLeft1,dwTop1,dwRight1,dwBottom1) (void(0))
#define WMILOG_AUDIO_RENDER(dwReporterTag,pObject,pSample,llTime,llDuration,llMasterTime,llDeviceTime) (void(0))
#define WMILOG_MUXER(dwReportTag,pObject,Type,wStreamNumber,llSampleTime,cbSample,llPacketNumber,llPacketSendTime,cbPacket) (void(0))
#define WMILOG_TIMER_LATE(dwReporterTag,pObject,llEventTime,llLateBy,pCallback) (void(0))
#define WMILOG_LOCK(dwReporterTag,pObject,Type,pLockObject) (void(0))
#define WMILOG_GRAPH(dwReporterTag,pObject,Type,hr) (void(0))

DWORD inline SetFilePointerLogged(
    HANDLE hFile, 
    LONG lDistanceToMove, 
    PLONG lpDistanceToMoveHigh, 
    DWORD dwMoveMethod, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    return SetFilePointer (hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
}


BOOL inline WriteFileLogged (
    HANDLE hFile, 
    LPCVOID lpBuffer, 
    DWORD nNumberOfBytesToWrite, 
    LPDWORD lpNumberOfBytesWritten, 
    LPOVERLAPPED lpOverlapped, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    return WriteFile (hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}


BOOL inline ReadFileLogged(
    HANDLE hFile, 
    LPVOID lpBuffer, 
    DWORD nNumberOfBytesToRead, 
    LPDWORD lpNumberOfBytesRead, 
    LPOVERLAPPED lpOverlapped, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    return ReadFile (hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
}

#else   // !SHIP_BUILD

#define WMILOG_LEVEL_DISABLED 0
#define WMILOG_LEVEL_CRITICAL 1
#define WMILOG_LEVEL_WARNING  2
#define WMILOG_LEVEL_TRACE    3
#define WMILOG_LEVEL_VERBOSE  4

// Critical events
#define bWMILOG_AUDIORENDER_STARVATION  (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_CRITICAL)
#define bWMILOG_VIDEO_FRAME_GLITCH      (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_CRITICAL)
#define bWMILOG_DATA_DROP               (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_CRITICAL)
#define bWMILOG_STATE_CHANGE            (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_CRITICAL)
#define bWMILOG_CLOCK_SETTIME           (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_CRITICAL)

// Warning events
#define bWMILOG_MEDIATYPE_CHANGE        (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_UNUSUAL_STREAMING_EVENT (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_FILE_OPEN               (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_NETSOURCE               (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_ADJUST_SAMPLE_TIME      (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_TIMER_LATE              (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)

// Trace events
#define bWMILOG_BUFFER                  (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)
#define bWMILOG_OBJECT                  (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)
#define bWMILOG_DISKIO_REQUEST          (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)
#define bWMILOG_DISKIO_COMPLETE         (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)
#define bWMILOG_RENDERER_REND           (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)
#define bWMILOG_MUXER                   (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_TRACE)

// Need to use events (warning level)
#define bWMILOG_AUDIORENDERER_BUFFERFULLNESS (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_SOURCERESOLUTION             (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_QM                           (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_VIDEO_RENDER                 (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_AUDIO_RENDER                 (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)
#define bWMILOG_GRAPH                        (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_WARNING)

// Need to use events (verbose level)
#define bWMILOG_CLOCK_GETTIME           (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_VERBOSE)
#define bWMILOG_LOCK                    (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_VERBOSE)
#define bWMILOG_STREAM                  (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_VERBOSE)
#define bWMILOG_HTTP_BYTESTREAM         (g_WmiInfo.ucWmiEnableLevel >= WMILOG_LEVEL_VERBOSE)


void inline WMILOG_OBJECT( 
    DWORD dwReporterTag, 
    UCHAR lActionType, 
    PVOID pObject, 
    DSHOWWMI_OBJECT_TYPE lObjectType )
{
    if ( bWMILOG_OBJECT )
    {
        DSHOWPERFINFO_OBJECT    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_OBJECT_EVENT, lActionType, pObject);
        perfData.eObjectType = lObjectType;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_AUDIORENDER_STARVATION(
    DWORD dwReporterTag, 
    PVOID pObject, 
    DWORDLONG ullCount )
{
    if ( bWMILOG_AUDIORENDER_STARVATION )
    {
        DSHOWPERFINFO_AUDIORENDERER_STARVATION    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_AUDIORENDERER_STARVATION_EVENT, 0, pObject);
        perfData.ullByteCount               = (ullCount);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
   }
}

void inline WMILOG_VIDEO_FRAME_GLITCH(
      DWORD dwReporterTag, 
      PVOID pObject, 
      DWORD dwObjectID,
      PVOID pSample, 
      LONGLONG llSampleTime, 
      LONGLONG llTargetSystemTime, 
      LONGLONG llOffset)
{
    if ( bWMILOG_VIDEO_FRAME_GLITCH )
    {
        DSHOWPERFINFO_VIDEO_FRAME_GLITCH    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_VIDEO_FRAME_GLITCH_EVENT, 0, pObject);
        perfData.pSample                    = (DSHOWWMI_PTR)pSample;
        perfData.dwObjectID                 = dwObjectID;
        perfData.llSampleTime               = llSampleTime;
        perfData.llTargetSystemTime         = llTargetSystemTime;
        perfData.llOffset                   = llOffset;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
   }
}

void inline WMILOG_DATA_DROP(
    DWORD dwReporterTag,
    DWORD dwDataType,
    PVOID pObject,
    DWORD dwObjectID,
    LONGLONG llSampleTime,
    DWORD cbDropped,
    DWORD dwReasons)
{
    if ( bWMILOG_DATA_DROP )
    {
        DSHOWPERFINFO_DATA_DROP    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_DATA_DROP_EVENT, 0, pObject);
        perfData.dwDataType                 = dwDataType;
        perfData.llSampleTime               = llSampleTime;
        perfData.cbDropped                  = cbDropped;
        perfData.dwReasons                  = dwReasons;
        perfData.dwObjectID                 = dwObjectID;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_CLOCK_GETTIME( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    LONGLONG llTime )
{
    if ( bWMILOG_CLOCK_GETTIME )
    {
        DSHOWPERFINFO_CLOCK_GETTIME perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_CLOCK_GETTIME_EVENT, 0, pObject);
        perfData.llClockTime                = llTime;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_CLOCK_SETTIME( 
     DWORD dwReporterTag, 
     PVOID pObject, 
     LONGLONG llTime, 
     LONGLONG llDelta )
{
    if ( bWMILOG_CLOCK_SETTIME )
    {
        DSHOWPERFINFO_CLOCK_SETTIME perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_CLOCK_SETTIME_EVENT, 0, pObject);
        perfData.llDelta                    = llDelta;
        perfData.llClockTime                = llTime;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_STREAM( 
    DWORD dwReporterTag, 
    DWORD lStreamType, 
    PVOID pObject )
{
    if ( bWMILOG_STREAM )
    {
        DSHOWPERFINFO_STREAM    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_STREAM_EVENT, (UCHAR)lStreamType, pObject);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_MEDIATYPE_CHANGE( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    PVOID pStream, 
    DWORD cbNewType, 
    __in_bcount(cbNewType) const BYTE *pbNewType )
{
    if ( bWMILOG_MEDIATYPE_CHANGE )
    {
        DSHOWPERFINFO_MEDIATYPE_CHANGE    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_MEDIATYPE_CHANGE_EVENT, 0, pObject);
        perfData.pStream        = (DSHOWWMI_PTR) pStream;
        perfData.cbNewType      = cbNewType;
        memcpy(perfData.pbNewType, pbNewType, cbNewType > MAXMEDIATYPE ? MAXMEDIATYPE : cbNewType);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_BUFFER(
    DWORD       dwReporterTag,
    PVOID       pObject,
    UCHAR       Type,
    DWORD       dwObjectCategory,
    PVOID       pStream,
    LONGLONG    llTimestamp,
    PVOID       pClock,
    PVOID       pSample,
    DWORD       cbTotalBuffer,
    DWORD       cbUsedBuffer,
    LONGLONG    llDuration )
{
    //
    // If we were using flags, the condition (g_ulWmiEnableFlags &  DSHOW_WMI_FLAG_SAMPLES)
    // could be checked in addition to the level condition being checked here.
    //
    if ( bWMILOG_BUFFER )
    {
        DSHOWPERFINFO_BUFFER    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_BUFFER_EVENT, Type, pObject);
        perfData.dwObjectCategory           = dwObjectCategory;
        perfData.pStream                    = (DSHOWWMI_PTR) pStream;
        perfData.llTimestamp                = llTimestamp;
        perfData.pBuffer                    = (DSHOWWMI_PTR) pSample;
        perfData.cbUsedBuffer               = cbUsedBuffer;
        perfData.llDuration                 = llDuration;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_UNUSUAL_STREAMING_EVENT(
    DWORD dwReporterTag,
    UCHAR Type,
    PVOID pObject,
    DWORD dwEvent)
{
    if ( bWMILOG_UNUSUAL_STREAMING_EVENT )
    {
        DSHOWPERFINFO_UNUSUAL_STREAMING_EVENT perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_UNUSUAL_STREAMING_EVENT, Type, pObject);
        perfData.dwEvent      = (dwEvent);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_FILE_OPEN( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    HANDLE h, 
    LPCWSTR pwszName )
{
    if ( bWMILOG_FILE_OPEN )
    {
        DWORD dwLen = min(lstrlenW(pwszName), MAX_PATH);
        DWORD dwSize = sizeof(DSHOWPERFINFO_FILE_OPEN) + dwLen * sizeof(WCHAR);
        BYTE *pb = new BYTE[dwSize];
        if (pb)
        {
            DSHOWPERFINFO_FILE_OPEN *pperfData = (DSHOWPERFINFO_FILE_OPEN *)pb;
            FILL_DSHOWPERFINFO_COMMON_PTR(pperfData, dwSize, dwReporterTag, DSHOWWMIGUID_FILE_OPEN_EVENT, 0, pObject);
            pperfData->hFile = (DSHOWWMI_HANDLE) (h);
            CopyMemory(pperfData->szName, (pwszName), dwLen * sizeof(WCHAR));
            pperfData->szName[dwLen] = 0;
            TraceEvent(g_WmiInfo.hWmiTrace, &pperfData->hdr.wmiHeader);
            delete [] pb;
        }
    }
}

void inline WMILOG_FILE_CLOSE( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    HANDLE h, 
    LPCWSTR pwszName )
{
    if ( bWMILOG_FILE_OPEN )
    {
        DWORD dwLen = pwszName ? min(lstrlenW(pwszName), MAX_PATH) : 0;
        DWORD dwSize = sizeof(DSHOWPERFINFO_FILE_CLOSE) + dwLen * sizeof(WCHAR);
        BYTE *pb = new BYTE[dwSize];
        if (pb)
        {
            DSHOWPERFINFO_FILE_OPEN *pperfData = (DSHOWPERFINFO_FILE_OPEN *)pb;
            FILL_DSHOWPERFINFO_COMMON_PTR(pperfData, dwSize, dwReporterTag, DSHOWWMIGUID_FILE_OPEN_EVENT, 0, pObject);
            pperfData->hFile = (DSHOWWMI_HANDLE) (h);
            if (dwLen)
            {
                CopyMemory(pperfData->szName, (pwszName), dwLen * sizeof(WCHAR));
            }
            pperfData->szName[dwLen] = 0;
            TraceEvent(g_WmiInfo.hWmiTrace, &pperfData->hdr.wmiHeader);
            delete [] pb;
        }
    }
}

void inline WMILOG_DISKIO_REQUEST( 
    DWORD dwReporterTag, 
    UCHAR Type, 
    PVOID pObject, 
    HANDLE h, 
    QWORD qwOffset, 
    DWORD bCount )
{
    if ( bWMILOG_DISKIO_REQUEST )
    {
        DSHOWPERFINFO_DISKIO_REQUEST    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_DISKIO_REQUEST_EVENT, Type, pObject);
        perfData.hFile                      = (DSHOWWMI_HANDLE) (h);
        perfData.llOffset                   = qwOffset;
        perfData.byteCount                  = (bCount);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_DISKIO_COMPLETE( 
    DWORD dwReporterTag, 
    UCHAR Type, 
    PVOID pObject, 
    HANDLE h )
{
    if ( bWMILOG_DISKIO_COMPLETE )
    {
        DSHOWPERFINFO_DISKIO_COMPLETE    perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_DISKIO_COMPLETE_EVENT, Type, pObject);
        perfData.hFile                      = (DSHOWWMI_HANDLE) (h);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_RENDERER_REND( 
    DWORD dwReporterTag, 
    UCHAR Type, 
    PVOID pObject, 
    PVOID pSample, 
    LONGLONG llTime, 
    LONGLONG llDuration, 
    LONGLONG llClock )
{
    if ( bWMILOG_RENDERER_REND )
    {
        DSHOWPERFINFO_RENDERER_REND perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_RENDER_REND_EVENT, Type, pObject);
        perfData.pSample            = (DSHOWWMI_PTR)(pSample);
        perfData.llSampleTime       = (llTime);
        perfData.llSampleDuration   = (llDuration);
        perfData.llClockTime        = (llClock);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

#define WMILOG_RENDERER_MIX( dwReporterTag, Type, pObject, pSample, llTime, llDuration, llClock ) \
    WMILOG_RENDERER_REND( dwReporterTag, Type, pObject, pSample, llTime, llDuration, llClock )

void inline WMILOG_AUDIORENDERER_BUFFERFULLNESS( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    DWORD dwFullness)
{
    if (bWMILOG_AUDIORENDERER_BUFFERFULLNESS)
    {
        DSHOWPERFINFO_AUDIORENDERER_BUFFERFULLNESS perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_AUDIORENDERER_BUFFERFULLNESS_EVENT, 0, pObject);
        perfData.msBuffer = dwFullness;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_STATE_CHANGE( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    DWORD dwStateChange)
{
    if ( bWMILOG_STATE_CHANGE )
    {
        DSHOWPERFINFO_STATE_CHANGE perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_STATE_CHANGE_EVENT, (UCHAR)dwStateChange, pObject);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_NETSOURCE( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    UCHAR Type, 
    DWORD Arg1, 
    DWORD Arg2 )
{
    if ( bWMILOG_NETSOURCE)
    {
        DSHOWPERFINFO_NETSOURCE  perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_NETSOURCE_EVENT, Type, pObject);
        perfData.Arg1 = Arg1;
        perfData.Arg2 = Arg2;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_HTTP_BYTESTREAM( 
    DWORD dwReporterTag, 
    PVOID pObject, 
    UCHAR Type )
{
    if ( bWMILOG_HTTP_BYTESTREAM)
    {
        DSHOWPERFINFO_HTTP_BYTESTREAM perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_HTTP_BYTESTREAM_EVENT, Type, pObject );
        TraceEvent( g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader );
    }
}

void inline WMILOG_SOURCERESOLUTION(
    DWORD dwReporterTag, 
    PVOID pObject, 
    UCHAR Type, 
    LPCWSTR pwszURL, 
    PVOID pObjectCreated, 
    HRESULT hr )
{
    if ( bWMILOG_SOURCERESOLUTION )
    {
        DSHOWPERFINFO_SOURCERESOLUTION perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_SOURCERESOLUTION_EVENT, Type, pObject );
        perfData.pwszURL = pwszURL;
        perfData.pObjectCreated = pObjectCreated;
        perfData.hr = hr;
        TraceEvent( g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader );
    }
}

void inline WMILOG_QM(
    DWORD dwReporterTag, 
    PVOID pObject, 
    UCHAR Type, 
    DWORD dwKnobId, 
    DWORD dwPrevLevel, 
    DWORD dwNewLevel, 
    LONGLONG llDropTime )
{
    if ( bWMILOG_QM )
    {
        DSHOWPERFINFO_QM perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_QM_EVENT, Type, pObject );
        perfData.dwKnobId = dwKnobId;
        perfData.dwPrevLevel = dwPrevLevel;
        perfData.dwNewLevel = dwNewLevel;
        perfData.llDropTime = llDropTime;
        TraceEvent( g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader );
    }
}

void inline WMILOG_ADJUST_SAMPLE_TIME(
    DWORD       dwReporterTag,
    PVOID       pObject,
    UCHAR       ucType,
    LONGLONG    llOriginalSampleTime,
    LONGLONG    llAdjustment )
{
    if ( bWMILOG_ADJUST_SAMPLE_TIME )
    {
        DSHOWPERFINFO_ADJUST_SAMPLE_TIME    perfData;

        FILL_DSHOWPERFINFO_COMMON(
                perfData,
                dwReporterTag,
                DSHOWWMIGUID_ADJUST_SAMPLE_TIME_EVENT,
                ucType,
                pObject);

        perfData.llOriginalSampleTime = llOriginalSampleTime;
        perfData.llAdjustment = llAdjustment;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline WMILOG_VIDEO_RENDER(
    DWORD       dwReporterTag,
    PVOID       pObject,
    PVOID       pSample,
    LONGLONG    llSampleTime,
    LONGLONG    llSampleDuration,
    LONGLONG    llClockTime,
    HANDLE      hwndVideo,
    DWORD       dwRefreshRate,
    DWORD       dwWidth,
    DWORD       dwHeight,
    DWORD       dwLeft,
    DWORD       dwTop,
    DWORD       dwRight,
    DWORD       dwBottom,
    DWORD       dwLeft1,
    DWORD       dwTop1,
    DWORD       dwRight1,
    DWORD       dwBottom1
    )
{
    if ( bWMILOG_VIDEO_RENDER )
    {
        DSHOWPERFINFO_VIDEO_RENDER    perfData;

        FILL_DSHOWPERFINFO_COMMON(
                perfData,
                dwReporterTag,
                DSHOWWMIGUID_VIDEO_RENDER_EVENT,
                0,
                pObject);

        perfData.hwndVideo = (DSHOWWMI_HANDLE)hwndVideo;
        perfData.llSampleTime = llSampleTime;
        perfData.llSampleDuration = llSampleDuration;
        perfData.llClockTime = llClockTime;
        perfData.pSample = (DSHOWWMI_PTR)pSample;
        perfData.dwRefreshRate = dwRefreshRate;
        perfData.dwWidth = dwWidth;
        perfData.dwHeight = dwHeight;
        perfData.dwLeft = dwLeft;
        perfData.dwTop = dwTop;
        perfData.dwRight = dwRight;
        perfData.dwBottom = dwBottom;
        perfData.dwLeft1 = dwLeft1;
        perfData.dwTop1 = dwTop1;
        perfData.dwRight1 = dwRight1;
        perfData.dwBottom1 = dwBottom1;

        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}

void inline
WMILOG_AUDIO_RENDER(
    DWORD dwReporterTag,
    PVOID pObject,
    PVOID pSample,
    LONGLONG llTime,
    LONGLONG llDuration,
    LONGLONG llMasterTime,
    LONGLONG llDeviceTime)
{
    if ( bWMILOG_AUDIO_RENDER )
    {
        DSHOWPERFINFO_AUDIO_RENDER perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMI_GUID_AUDIO_RENDER_EVENT, 0, pObject);
        perfData.pSample            = (DSHOWWMI_PTR)(pSample);
        perfData.llSampleTime       = (llTime);
        perfData.llSampleDuration   = (llDuration);
        perfData.llMasterTime       = (llMasterTime);
        perfData.llDeviceTime       = (llDeviceTime);
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_MUXER(   DWORD dwReportTag,
                            PVOID pObject,
                            UCHAR Type,
                            DWORD wStreamNumber,
                            LONGLONG llSampleTime,
                            DWORD cbSample,
                            LONGLONG llPacketNumber,
                            LONGLONG llPacketSendTime,
                            DWORD cbPacket )
{
    if( bWMILOG_MUXER )
    {
        DSHOWPERFINFO_MUXER perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReportTag, DSHOWWMIGUID_MUXER_EVENT, Type, pObject );
        perfData.wStreamNumber = wStreamNumber;
        perfData.llSampleTime = llSampleTime;
        perfData.cbSample = cbSample;
        perfData.llPacketNumber = llPacketNumber;
        perfData.llPacketSendTime = llPacketSendTime;
        perfData.cbPacket = cbPacket;
        TraceEvent( g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader );
    }
}


void inline WMILOG_TIMER_LATE(
    DWORD       dwReporterTag,
    PVOID       pObject,
    DWORD       dwObjectID,
    LONGLONG    llEventTime,
    LONGLONG    llLateBy)
{
    if( bWMILOG_TIMER_LATE )
    {
        DSHOWPERFINFO_TIMER_LATE perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_TIMER_LATE_EVENT, 0, pObject );
        perfData.llEventTime = llEventTime;
        perfData.llLateBy = llLateBy;
        perfData.dwObjectID = dwObjectID;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_LOCK(
    DWORD      dwReporterTag,
    PVOID      pObject,
    UCHAR      Type,     // Acquire, Acquired, Released
    PVOID      pLockObject)
{
    if( bWMILOG_LOCK )
    {
        DSHOWPERFINFO_LOCK perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_LOCK_EVENT, Type, pObject );
        perfData.pLockObject = pLockObject;
        TraceEvent(g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader);
    }
}


void inline WMILOG_GRAPH(
    DWORD dwReporterTag, 
    PVOID pObject, 
    UCHAR Type, 
    HRESULT hr )
{
    if ( bWMILOG_GRAPH ) {
        DSHOWPERFINFO_GRAPH perfData;
        FILL_DSHOWPERFINFO_COMMON( perfData, dwReporterTag, DSHOWWMIGUID_GRAPH_EVENT, Type, pObject );
        perfData.hr = hr;
        TraceEvent( g_WmiInfo.hWmiTrace, &perfData.hdr.wmiHeader );
    }
}

DWORD inline SetFilePointerLogged(
    HANDLE hFile, 
    LONG lDistanceToMove, 
    PLONG lpDistanceToMoveHigh, 
    DWORD dwMoveMethod, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    DWORD dwRet;

    if (bWMILOG_DISKIO_REQUEST)
    {
        QWORD qwPosition;

        qwPosition = lpDistanceToMoveHigh ? ((QWORD)*lpDistanceToMoveHigh) << 32: 0;
        qwPosition|= lDistanceToMove;

        WMILOG_DISKIO_REQUEST(dwReporterTag,
                                 DSHOWWMI_DISKIO_SEEK,
                                 NULL,
                                 hFile,
                                 qwPosition,
                                 (DWORD)-1);
    }

    dwRet = SetFilePointer (hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);

    // WMILOG: log how long as well
    WMILOG_DISKIO_COMPLETE(dwReporterTag,
                           DSHOWWMI_DISKIO_SEEK,
                           NULL,
                           hFile);
    return dwRet;
}


BOOL inline WriteFileLogged (
    HANDLE hFile, 
    LPCVOID lpBuffer, 
    DWORD nNumberOfBytesToWrite, 
    LPDWORD lpNumberOfBytesWritten, 
    LPOVERLAPPED lpOverlapped, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    BOOL bRet;

    WMILOG_DISKIO_REQUEST(dwReporterTag,
                          DSHOWWMI_DISKIO_WRITE,
                          NULL,
                          hFile,
                          (QWORD)-1,
                          nNumberOfBytesToWrite);

    bRet = WriteFile (hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);

    // WMILOG: log how long as well
    WMILOG_DISKIO_COMPLETE(dwReporterTag,
                           DSHOWWMI_DISKIO_WRITE,
                           NULL,
                           hFile);
    return bRet;
}


BOOL inline ReadFileLogged(
    HANDLE hFile, 
    LPVOID lpBuffer, 
    DWORD nNumberOfBytesToRead, 
    LPDWORD lpNumberOfBytesRead, 
    LPOVERLAPPED lpOverlapped, 
    DWORD dwReporterTag = DSHOWWMITAG_WIN32FILE)
{
    BOOL bRet;

    WMILOG_DISKIO_REQUEST(dwReporterTag,
                             DSHOWWMI_DISKIO_READ,
                             NULL,
                             hFile,
                             (QWORD)-1,
                             nNumberOfBytesToRead);

    bRet = ReadFile (hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);

    // WMILOG: log how long as well
    WMILOG_DISKIO_COMPLETE(dwReporterTag,
                           DSHOWWMI_DISKIO_READ,
                           NULL,
                           hFile);
    return bRet;
}

#endif // !SHIP_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dshowwmistr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//  DShow WMI Instrumentation Structures and GUIDs

#pragma once

#include <dshowwmiguid.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// Define all event provider DSHOWWMITAG's here
//
// This tag allows us to identify the reporter of an event easily
// and human friendly. It could also be used to selective enable or
// disable logging of a particular events from WMILOG_*, should this
// be necessary.
//
#define DSHOWWMITAG_AUDIO_RENDERER             'ARen'  // Audio renderer
#define DSHOWWMITAG_AUDIO_CAPTURER             'ACap'  // Audio capturer
#define DSHOWWMITAG_CORE_BASE                  'CorB'  // Core_Base
#define DSHOWWMITAG_MUXER                      'Muxr'  // muxer
#define DSHOWWMITAG_SPLITTER                   'Splt'  // Splitter
#define DSHOWWMITAG_ASF_MEDIA_SINK             'AfMk'  // asf media sink
#define DSHOWWMITAG_ASF_STREAM_SINK            'AfSk'  // asf stream sink
#define DSHOWWMITAG_ASF_MEDIA_STREAM           'AfMm'  // asf media stream
#define DSHOWWMITAG_CD_MEDIA_STREAM            'CDMm'  // CD media stream
#define DSHOWWMITAG_PCMAUDIO_MEDIA_SINK        'CDSK'  // PCM audio media sink
#define DSHOWWMITAG_PCMAUDIO_STREAM_SINK       'CDSk'  // PCM audio stream sink
#define DSHOWWMITAG_M3U_MEDIA_STREAM           'M3uS'  // M3u media stream
#define DSHOWWMITAG_MP3_MEDIA_STREAM           'MP3M'  // M3u media stream
#define DSHOWMWITAG_MP3_MEDIA_SOURCE_BASE      'MP3B'  // MP3 media source base
#define DSHOWWMITAG_MP3_MEDIA_SINK             'MP3K'  // MP3 media sink
#define DSHOWWMITAG_MP3_STREAM_SINK            'MP3k'  // MP3 stream sink
#define DSHOWWMITAG_NET_SOURCE                 'NetS'  // NetSOurce output
#define DSHOWWMITAG_NET_SINK                   'Nsnk'  // Network sink
#define DSHOWWMITAG_HTTP_BYTESTREAM            'HTTP'  // HTTP Bytestream
#define DSHOWWMITAG_MEDIACACHE                 'MCch'  // MediaCache
#define DSHOWWMITAG_WIN32FILE                  'W32F'  // Win32File
#define DSHOWWMITAG_CACHEREADER                'ChRd'  // ASF/MP3 Source CacheReader
#define DSHOWWMITAG_MEDIA_PROCESSOR            'MpCr'  // MediaProcess Core
#define DSHOWWMITAG_MEDIA_PROCESSOR_TOPOLOGY   'MpTp'  // MediaProcess Topology
#define DSHOWWMITAG_MEDIA_SESSION_BITPUMP      'MsBp'  // Media Session and Bitpump
#define DSHOWWMITAG_ASF_MEDIA_SOURCE           'AfMs'  // Asf media source
#define DSHOWWMITAG_VIDEO_MEDIA_SINK           'VSnk'  // Video Renderer
#define DSHOWWMITAG_VIDEO_STREAM_SINK          'VStr'  // Video Stream
#define DSHOWWMITAG_VIDEO_PRESENTER            'VPrs'  // Video Presenter
#define DSHOWWMITAG_VIDEO_MIXER                'VMix'  // Video Mixer
#define DSHOWWMITAG_VIDEO_CAPTURER             'VCap'  // Video Capturer    
#define DSHOWWMITAG_WMAD                       'WMAD'  // WMA decoder
#define DSHOWWMITAG_WMAE                       'WMAE'  // WMA encoder
#define DSHOWWMITAG_WMSP_ENCODER               'WSPE'  // WM Speech Encoder
#define DSHOWWMITAG_WMSP_DECODER               'WSPD'  // WM Speech Decoder
#define DSHOWWMITAG_WMVD                       'WMVD'  // WMV decoder
#define DSHOWWMITAG_WMVE                       'WMVE'  // WMV encoder
#define DSHOWWMITAG_WMVSD                      'WMSD'  // WMV screen decoder
#define DSHOWWMITAG_WMVSE                      'WMSE'  // WMV screen encoder
#define DSHOWWMITAG_WMAGEQ                     'AGEQ'  // WM audio graphic equalizer
#define DSHOWWMITAG_WMASPKRCORR                'SPKR'  // WM audio speaker/room correction
#define DSHOWWMITAG_WMABASSMGMT                'BASS'  // WM audio bass management
#define DSHOWWMITAG_WMASA                      'WMSA'  // WM audio spetrum analyzer
#define DSHOWWMITAG_WMNORM                     'NORM'  // WM audio normalization
#define DSHOWWMITAG_WMHDCDDEC                  'HDCD'  // WM HDCD decoder
#define DSHOWWMITAG_WMTIMECMP                  'TCMP'  // WM time compression
#define DSHOWWMITAG_WMAUDMORPHING              'AMOR'  // WM audio morpher
#define DSHOWWMITAG_WMAMIX                     'AMIX'  // WM audio mixer
#define DSHOWWMITAG_WMAVRHPHONE                'AVRH'  // WM virtualization headphone
#define DSHOWWMITAG_WMASPKRFILL                'ESPF'  // WM audio Enhanced Speaker Filling
#define DSHOWWMITAG_WMASPDTX                   'SpdT'  // WM audio WMA-Pro S/PDIF transmitter
#define DSHOWWMITAG_AECMA                      'AECM'  // AEC and Micarray
#define DSHOWWMITAG_DVDECODER                  'DVde'  // DV Decoder
#define DSHOWWMITAG_DVENCODER                  'DVen'  // DV Encoder
#define DSHOWWMITAG_MPEG2DEC                   'MPGD'  // MPEG2 Decoder 
#define DSHOWWMITAG_AC3DEC                     'AC3D'  // AC3 Decoder 
#define DSHOWWMITAG_MEDIA_ENGINE               'MEng'  // Media Engine
#define DSHOWWMITAG_TOPOLOADER                 'TpLd'  // Topology loader
#define DSHOWWMITAG_LATENCY                    'Late'  // Component Latency
#define DSHOWWMITAG_SOURCERESOLVER             'SoRe'  // Source Resolver
#define DSHOWWMITAG_VIDEO_RECORDER             'VRec'  // Video Recorder
#define DSHOWWMITAG_TRANSFORM                  'Tran'  // Transform
#define DSHOWWMITAG_COLOR_CONTROL              'CCtr'  // Color Control
#define DSHOWWMITAG_FRAMERATE_CONVERTER        'FrCv'  // Frame Rate Converter
#define DSHOWWMITAG_SMPTE_TRANSFORMS           'Smpt'  // SMPTE Transforms
#define DSHOWWMITAG_COLOR_LEGALIZER            'CLgl'  // Color Legalizer
#define DSHOWWMITAG_VIDEO_DENOISER             'VDns'  // Video Denoiser
#define DSHOWWMITAG_COLORCONV                  'CCon'  // WM Color Conversion
#define DSHOWWMITAG_RESIZE                     'Resz'  // WM Resizer
#define DSHOWWMITAG_FRAME_INTERPOLATION        'FInp'  // WM Frame Interpolation
#define DSHOWWMITAG_INTERLACE_TELECINE         'Telc'  // WM DeInterlace and Telecine
#define DSHOWWMITAG_WMRESAMP                   'ARes'  // Audio Resampler
#define DSHOWWMITAG_SEQUENCER_SOURCE           'TSrc'  // WM Timeline Source
#define DSHOWWMITAG_QM                         'QMan'  // Quality Manager
#define DSHOWWMITAG_MEIDA_PROC_SOURCE          'MPSc'  // WM Media Proc Source
#define DSHOWWMITAG_FRAME_GRABBER              'FRGB'  // WM Frame Grabber Source
#define DSHOWWMITAG_WAV_MEDIA_SINK             'WAVK'  // WAV media sink
#define DSHOWWMITAG_WAV_STREAM_SINK            'WAVk'  // WAV stream sink
#define DSHOWWMITAG_AVI_MEDIA_SINK             'AVIK'  // AVI media sink
#define DSHOWWMITAG_AVI_STREAM_SINK            'AVIk'  // AVI stream sink
#define DSHOWWMITAG_MEDIACLIP                  'MClp'  // Media Clip
#define DSHOWWMITAG_SCRIPT_SINK                'SCRK'  // Script sink
#define DSHOWWMITAG_FIRSTPASS_SINK             '1PAK'  // FirstPass sink
#define DSHOWWMITAG_RATELESSNULL_SINK          'RLNK'  // Rateless Null sink
#define DSHOWWMITAG_FILETRANSFER_SINK          'FTRK'  // File Transfer sink
#define DSHOWWMITAG_MPG_SOURCE                 'MPGS'  // MPEG Source
#define DSHOWWMITAG_AUDIOFILE_SOURCE           'AUFS'  // Audio File Source
#define DSHOWWMITAG_SCREENCAP_SOURCE           'SCPS'  // Screen Capture Source
#define DSHOWWMITAG_IMAGE_SOURCE               'IMGS'  // Image Source
#define DSHOWWMITAG_SCRIPT_SOURCE              'SCRS'  // Script Source
#define DSHOWWMITAG_SILENCE_SOURCE             'SILS'  // Silence Source
#define DSHOWWMITAG_SOLIDCOLOR_SOURCE          'SLCS'  // WM Solid Color Source
#define DSHOWWMITAG_FILETRANSFER_SOURCE        'FTRS'  // File Transfer Source
#define DSHOWWMITAG_UNMANAGED_SINK             'UNMK'  // Unmanaged wrapper sink
#define DSHOWWMITAG_EVER_SOURCE                'EVRS'  // EVeR Source
#define DSHOWWMITAG_SBE_SOURCE                 'SBES'  // SBE Media Source
#define DSHOWWMITAG_METADATA                   'Meta'  // Metadata
#define DSHOWWMITAG_METADATA_TRANSFORM         'MXFM'  // Metadata Transform
#define DSHOWWMITAG_METADATA_RULES             'MXFR'  // Metadata Rules
#define DSHOWWMITAG_SAMI_SOURCE                'SAMI'  // SAMI Media Source
#define DSHOWWMITAG_SAMPLEGRABBER_SINK         'SGSK'  // Sample Grabber Sink
#define DSHOWWMITAG_GEN_FILE_MEDIA_SINK        'GENK'  // Generic File media sink
#define DSHOWWMITAG_GEN_FILE_STREAM_SINK       'GENk'  // Generic File stream sink
#define DSHOWWMITAG_PRESENTATION_CLOCK         'PClk'  // Presentation Clock
#define DSHOWWMITAG_DEV_PLATFORM               'Pltf'  // Development Platform
#define DSHOWWMITAG_SMX_SOURCE                 'SMXS'  // SMX Media Source
#define DSHOWWMITAG_SMX_TRANSFORM              'SMXT'  // SMX Transform
#define DSHOWWMITAG_GRAPH                      'FGRP'  // Graph
#define DSHOWWMITAG_FILTER_GRAPH_CACHE         'FGCH'  // Filter graph cache
#define DSHOWWMITAG_FILTER_GRAPH_MAPPER        'FGMP'  // Filter graph mapper
#define DSHOWWMITAG_WMP_PLAYBACK               'WMPP'  // WMP Playback
#define DSHOWWMITAG_SOURCE_PROXY               'SrPx'  // Source Proxy
#define DSHOWWMITAG_DMO_WRAPPER                'DMOW'  // DMO wrapper filter
#define DSHOWWMITAG_BUFFERING                  'BUFF'  // Buffering filter
#define DSHOWWMITAG_SMARTTEE                   'STEE'  // Smart tee
#define DSHOWWMITAG_GENERIC                    'GENF'  // Generic filter/DMO

typedef ULONGLONG DSHOWWMI_PTR;

typedef ULONGLONG DSHOWWMI_HANDLE;

// Commenting these out for now: We're not differentiating which events to
// trace on the basis of what flags (yet)
/*
#define DSHOW_WMI_FLAG_AUDIO   0x01    // audio-specific processing
#define DSHOW_WMI_FLAG_VIDEO   0x02    // video-specific processing
#define DSHOW_WMI_FLAG_DATA    0x04    // non-AV specific processing
#define DSHOW_WMI_FLAG_NETWORK 0x08    // network activity
#define DSHOW_WMI_FLAG_DISKIO  0x10    // disk activity
#define DSHOW_WMI_FLAG_SOURCE_SINK 0x20    // source and sink activity (ie endpoints)
#define DSHOW_WMI_FLAG_TRANSFORM   0x40    // transform activity
#define DSHOW_WMI_FLAG_REALTIME    0x80    // real-time related events
#define DSHOW_WMI_FLAG_CLOCK   0x100   // clock data
#define DSHOW_WMI_FLAG_SAMPLES 0x200   // all samples
#define DSHOW_WMI_FLAG_OBJECTS 0x400   // all object create/delete
#define DSHOW_WMI_FLAG_STREAMINFO  0x800   // all stream and format events
*/

#pragma pack(push, 4)

typedef struct DSHOWPERFINFO_COMMON {
    EVENT_TRACE_HEADER wmiHeader;
    DSHOWWMI_PTR       pObject;
    DWORD              dwReporterTag;
} DSHOWPERFINFO_COMMON;

//
// this is the control guid for all events
//

//==============================
// Event GUIDs are defined here.
//==============================

//------------------------
// Object event
//  This event is reported when an object is created or deleted.
//

#define OBJECT_ACTIONTYPE_CREATE 1
#define OBJECT_ACTIONTYPE_DELETE 2


typedef enum _DSHOWWMI_OBJECT_TYPE
{
     DSHOWWMI_OBJECT_TYPE_UNKNOWN                 = -1,
     DSHOWWMI_OBJECT_TYPE_LOCAL_AUDIO_RENDERER    = 1,
     DSHOWWMI_OBJECT_TYPE_LOCAL_VIDEO_RENDERER    = 2,
     DSHOWWMI_OBJECT_TYPE_BYTESTREAM_SOURCE       = 3,
     DSHOWWMI_OBJECT_TYPE_VIDEO_CAPTURE_SOURCE    = 4,
     DSHOWWMI_OBJECT_TYPE_AUDIO_CAPTURE_SOURCE    = 5,
     DSHOWWMI_OBJECT_TYPE_TV_CAPTURE              = 6,
     DSHOWWMI_OBJECT_TYPE_AUDIO_DMO               = 7,
     DSHOWWMI_OBJECT_TYPE_VIDEO_DMO               = 8,
     DSHOWWMI_OBJECT_TYPE_DEMUX                   = 9,
     DSHOWWMI_OBJECT_TYPE_MUX                     = 10,
     DSHOWWMI_OBJECT_TYPE_FILE_SINK               = 11,
     DSHOWWMI_OBJECT_TYPE_NETWORK_SINK            = 12,
     DSHOWWMI_OBJECT_TYPE_COLOR_SPACE_CONVERTOR   = 13,
     DSHOWWMI_OBJECT_TYPE_NETCLIENT               = 14,
     DSHOWWMI_OBJECT_TYPE_NETQUEUE                = 15,
     DSHOWWMI_OBJECT_TYPE_FILE_SOURCE             = 16,
     DSHOWWMI_OBJECT_TYPE_GENERIC_SOURCE          = 17,
     DSHOWWMI_OBJECT_TYPE_GENERIC_SINK            = 18,
     DSHOWWMI_OBJECT_TYPE_BYTE_SINK               = 19,
     DSHOWWMI_OBJECT_TYPE_VIDEO_RECORDER          = 20,
     DSHOWWMI_OBJECT_TYPE_NETSINK                 = 21,
     DSHOWWMI_OBJECT_TYPE_DVD_SOURCE              = 22,
     DSHOWWMI_OBJECT_TYPE_NETSINK_PACKET_QUEUE    = 23,
     DSHOWWMI_OBJECT_TYPE_CONTROL_LAYER           = 24,
     DSHOWWMI_OBJECT_TYPE_APO                     = 25,
     DSHOWWMI_OBJECT_TYPE_GENERIC_TRANSFORM       = 26,
} DSHOWWMI_OBJECT_TYPE;

typedef struct _DSHOWPERFINFO_OBJECT {
    DSHOWPERFINFO_COMMON   hdr;
    DSHOWWMI_OBJECT_TYPE   eObjectType;
} DSHOWPERFINFO_OBJECT;

//------------------------
// AudioRenderer Starvation event
//

//
// Or the flag AUDIO_GLITCH_PREVIOUS_DISCONTINUITY in the type if the starvation
// follows a discontinuity or  when a stream is just started. So we can easily
// distinguish gaps from this type of starvations which is usually in-audible, i.e.
// no perceptible glitches.
// All audio components would need be updated to report the equivalent information
// so every audio glitch events are consistent.
//
#define AUDIO_GLITCH_TYPE_START (0x01)
#define AUDIO_GLITCH_TYPE_STOP  (0x02)

#define AUDIO_GLITCH_PREVIOUS_DISCONTINUITY (0x80)

typedef struct _DSHOWPERFINFO_AUDIORENDERER_STARVATION {
    DSHOWPERFINFO_COMMON   hdr;
    ULONGLONG              ullByteCount;
} DSHOWPERFINFO_AUDIORENDERER_STARVATION;

//------------------------
// Video Frame glitch event
//

typedef struct _DSHOWPERFINFO_VIDEO_FRAME_GLITCH {
    DSHOWPERFINFO_COMMON   hdr;
    DSHOWWMI_PTR           pSample;
    DWORD                  dwObjectID;
    LONGLONG               llSampleTime;
    LONGLONG               llTargetSystemTime;
    LONGLONG               llOffset; // positive = late
} DSHOWPERFINFO_VIDEO_FRAME_GLITCH;

//------------------------
// Data Drop
//
// A module that drops samples should log this event unless it is absolutely sure
// the drop is intentional and will not cause glitches. E.g
// a video capture source dropping samples during Pause is by design. There is little
// value to log the drops but filling up the log buffer.
//
// When unsure of the glitch implication of dropping data, a module should log the drop.
// A realtime monitor or postprosessing tools can be educated to tell if the drop is
// benign or not. If the drop were not logged, we'd miss the information or a problem.
//

//
// define data types, so we know what type of data is being dropped
//
enum DSHOWWMI_DATA_TYPE {
    DSHOWWMI_DATA_TYPE_AUDIO = 1,
    DSHOWWMI_DATA_TYPE_VIDEO = 2,
    DSHOWWMI_DATA_TYPE_OTHER = 3,
    DSHOWWMI_DATA_TYPE_UNKNOWN = 4,
};

//
// define reasons for data drops, append necessay new reasons without altering existing ones.
// a module should know why it drops data.
//
#define DSHOWWMI_DATA_DROP_REASON_LATE_ARRIVAL     (0x01) // sample pastdue at receive
#define DSHOWWMI_DATA_DROP_REASON_LATE_FINISH      (0x02) // process takes too long or lacks of cpu cycles
#define DSHOWWMI_DATA_DROP_REASON_BAD_DATA         (0x04) // samples are corrupted
#define DSHOWWMI_DATA_DROP_REASON_INSUFFICIENT_BIT (0x08) // allocated bits not enough
#define DSHOWWMI_DATA_DROP_REASON_NET_DATA_LOSS    (0x10) // apply to connectionless comm
#define DSHOWWMI_DATA_DROP_REASON_OVERRUN          (0x20) // samples are not taking off capture buffer timely, or mux has had an overrun
#define DSHOWWMI_DATA_DROP_REASON_STALE            (0x40) // stale data was trimmed from the ASF sink holding queue. Received during a bad state, or received too late.
#define DSHOWWMI_DATA_DROP_REASON_MUX_FAILED       (0x80) // mux failed to consume the data
#define DSHOWWMI_DATA_DROP_REASON_NOT_FLOWING     (0x100) // data not flowing
#define DSHOWWMI_DATA_DROP_REASON_NOT_KEYFRAME    (0x200) // object is not a keyframe

typedef struct _DSHOWPERFINFO_DATA_DROP {
    DSHOWPERFINFO_COMMON   hdr;
    DWORD                  dwDataType;         // Use DSHOWWMI_DATA_TYPE values
    DWORD                  dwObjectID;
    LONG                   cbDropped;
    LONGLONG               llSampleTime;
    DWORD                  dwReasons;
} DSHOWPERFINFO_DATA_DROP;

//------------------------
// ClockGetTime Event
// Report this event when the clock is queried.


typedef struct _DSHOWPERFINFO_CLOCK_GETTIME {
    DSHOWPERFINFO_COMMON   hdr;
    LONGLONG               llClockTime;
} DSHOWPERFINFO_CLOCK_GETTIME;


//------------------------
// ClockSetTime Event
// Report this event when the clock is modified by one of the filters.

typedef struct _DSHOWPERFINFO_CLOCK_SETTIME {
    DSHOWPERFINFO_COMMON   hdr;
    LONGLONG               llClockTime;
    LONGLONG               llDelta;
} DSHOWPERFINFO_CLOCK_SETTIME;


//------------------------
// Predicted video sample event
// Report this event when sample is being delivered to the stream sink

//------------------------
// Stream event
//  This event is reported when a stream is created or deleted.
//

#define STREAM_CREATE 1
#define STREAM_DELETE 2

typedef struct _DSHOWPERFINFO_STREAM {
    DSHOWPERFINFO_COMMON   hdr;
} DSHOWPERFINFO_STREAM;

//------------------------
// MEDIATYPE change event
//

#define MAXMEDIATYPE 128

typedef struct _DSHOWPERFINFO_MEDIATYPE_CHANGE {
    DSHOWPERFINFO_COMMON   hdr;
    DSHOWWMI_PTR           pStream;
    LONG                   cbNewType;
    DWORD                  dwPadding;
    BYTE                   pbNewType[MAXMEDIATYPE];
} DSHOWPERFINFO_MEDIATYPE_CHANGE;

//------------------------
// Buffer event definition:
//  This event is reported when a component receives or sends a sample buffer.
//  These events are essential to track buffer latency which will also assist
//  in glitch analysis.
//

#define DSHOWPERFINFO_BUFFER_INPUT     1
#define DSHOWPERFINFO_BUFFER_OUTPUT    2
#define DSHOWPERFINFO_BUFFER_QUEUED    3
#define DSHOWPERFINFO_BUFFER_DROPPED   4

typedef struct _DSHOWPERFINFO_BUFFER {
    DSHOWPERFINFO_COMMON hdr;
    DWORD                dwObjectCategory;
    DWORD                cbUsedBuffer;     // used buffer space
    DSHOWWMI_PTR         pStream;
    LONGLONG             llTimestamp;
    DSHOWWMI_PTR         pBuffer;
    LONGLONG             llDuration;        // for DSHOWPERFINFO_BUFFER_OUTPUT, llDuration contains the processing time for the sample
} DSHOWPERFINFO_BUFFER;


typedef struct _DSHOWPERFINFO_UNUSUAL_STREAMING_EVENT {
    DSHOWPERFINFO_COMMON hdr;
    DWORD              dwEvent;
} DSHOWPERFINFO_UNUSUAL_STREAMING_EVENT;

#define DSHOWWMI_UNUSUAL_STREAMING_TYPE_START    1
#define DSHOWWMI_UNUSUAL_STREAMING_TYPE_END      2
#define DSHOWWMI_UNUSUAL_STREAMING_TYPE_ONESHOT  3

#define DSHOWWMI_UNUSUAL_STREAMING_EVENT_DMO_FLUSH          1
#define DSHOWWMI_UNUSUAL_STREAMING_EVENT_DMO_DISCONTINUITY  2
#define DSHOWWMI_UNUSUAL_STREAMING_EVENT_WAVEOUT_START      3
#define DSHOWWMI_UNUSUAL_STREAMING_EVENT_WAVEOUT_DELAYSTART 4

#define DSHOWWMI_DISKIO_READ  1
#define DSHOWWMI_DISKIO_WRITE 2
#define DSHOWWMI_DISKIO_SEEK  3
typedef struct DSHOWPERFINFO_DISKIO_REQUEST {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_HANDLE      hFile;
    ULONGLONG            llOffset;
    ULONG                byteCount;
} DSHOWPERFINFO_DISKIO_REQUEST;


typedef struct _DSHOWPERFINFO_DISKIO_COMPLETE {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_HANDLE      hFile;
} DSHOWPERFINFO_DISKIO_COMPLETE;


typedef struct _DSHOWPERFINFO_FILE_OPEN {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_HANDLE      hFile;
    WCHAR                szName[1];
} DSHOWPERFINFO_FILE_OPEN;


typedef struct _DSHOWPERFINFO_FILE_CLOSE {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_HANDLE      hFile;
    WCHAR                szName[1];
} DSHOWPERFINFO_FILE_CLOSE;


#define DSHOW_REND_TYPE_ALLOC_SAMPLE       0x4
#define DSHOW_REND_TYPE_RECV_SAMPLE        0x1
#define DSHOW_REND_TYPE_START_REND         0x2
#define DSHOW_REND_TYPE_END_REND           0x3
#define DSHOW_REND_TYPE_START_MIX          0x6
#define DSHOW_REND_TYPE_END_MIX            0x7
#define DSHOW_REND_TYPE_START_DECODE       0x8
#define DSHOW_REND_TYPE_END_DECODE         0x9
#define DSHOW_REND_TYPE_START_DEINTERLACE  0xA
#define DSHOW_REND_TYPE_END_DEINTERLACE    0xB
#define DSHOW_REND_TYPE_START_PROCAMP      0xC
#define DSHOW_REND_TYPE_END_PROCAMP        0xD
#define DSHOW_REND_TYPE_START_FRC          0xE
#define DSHOW_REND_TYPE_END_FRC            0xF
#define DSHOW_REND_TYPE_MID_REND          0x10 // half point between START_REND and END_REND (used by windowed mode slicer)
#define DSHOW_REND_TYPE_MAP_REND          0x11 // Mapping of presentation time to system time when a sample is received

// distinguish audio, video via dwDataType
typedef struct _DSHOWPERFINFO_RENDERER_REND {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_PTR         pSample;
    LONGLONG             llSampleTime;
    LONGLONG             llSampleDuration;
    LONGLONG             llClockTime;
} DSHOWPERFINFO_RENDERER_REND, DSHOWPERFINFO_RENDERER_MIX;


typedef struct _DSHOWPERFINFO_AUDIORENDERER_BUFFERFULLNESS {
    DSHOWPERFINFO_COMMON hdr;
    DWORD                msBuffer;
} DSHOWPERFINFO_AUDIORENDERER_BUFFERFULLNESS;

#define DSHOWWMI_STATECHANGE_STOP  1
#define DSHOWWMI_STATECHANGE_PAUSE 2
#define DSHOWWMI_STATECHANGE_START 3
typedef struct _DSHOWPERFINFO_STATE_CHANGE{
    DSHOWPERFINFO_COMMON hdr;
} DSHOWPERFINFO_STATE_CHANGE;


//-------------------------
// Netsource events

#define DSHOWWMI_NETSOURCE_DISCONNECT         1
#define DSHOWWMI_NETSOURCE_RECONNECT_START    2
#define DSHOWWMI_NETSOURCE_RECONNECT_STOP     3
#define DSHOWWMI_NETSOURCE_ANNOUNCE           4
#define DSHOWWMI_NETSOURCE_EOS                5
#define DSHOWWMI_NETSOURCE_STREAMSWITCH       6
#define DSHOWWMI_NETSOURCE_STREAMSWITCH_DONE  7
#define DSHOWWMI_NETSOURCE_BUFFERING_START    8
#define DSHOWWMI_NETSOURCE_BUFFERING_STOP     9
#define DSHOWWMI_NETSOURCE_CONNECT_START      10
#define DSHOWWMI_NETSOURCE_CONNECT_STOP       11
#define DSHOWWMI_NETSOURCE_OPEN_START         12
#define DSHOWWMI_NETSOURCE_OPEN_STOP          13
#define DSHOWWMI_NETSOURCE_MCAST_JOIN_DONE    14

typedef struct DSHOWPERFINFO_NETSOURCE {
        DSHOWPERFINFO_COMMON   hdr;
        DWORD Arg1;
        DWORD Arg2;
} DSHOWPERFINFO_NETSOURCE;

//-------------------------
// HTTP Bytestream events

#define DSHOWWMI_HTTP_BYTESTREAM_OPEN_START        1
#define DSHOWWMI_HTTP_BYTESTREAM_OPEN_STOP         2

typedef struct DSHOWPERFINFO_HTTP_BYTESTREAM {
        DSHOWPERFINFO_COMMON   hdr;
} DSHOWPERFINFO_HTTP_BYTESTREAM;

//-------------------------
// SourceResolver events
// To measure how long the Source Resolver takes in its various steps

#define DSHOWWMI_SOURCERESOLUTION_START_CREATION                               1
#define DSHOWWMI_SOURCERESOLUTION_END_CREATION                                 2

#define DSHOWWMI_SOURCERESOLUTION_START_BEGINCREATEOBJECTFROMURL               3
#define DSHOWWMI_SOURCERESOLUTION_END_BEGINCREATEOBJECTFROMURL                 4

#define DSHOWWMI_SOURCERESOLUTION_START_ENDCREATEOBJECTFROMURL                 5
#define DSHOWWMI_SOURCERESOLUTION_END_ENDCREATEOBJECTFROMURL                   6

#define DSHOWWMI_SOURCERESOLUTION_START_BEGINCREATEOBJECTFROMBYTESTREAM        7
#define DSHOWWMI_SOURCERESOLUTION_END_BEGINCREATEOBJECTFROMBYTESTREAM          8

#define DSHOWWMI_SOURCERESOLUTION_START_ENDCREATEOBJECTFROMBYTESTREAM          9
#define DSHOWWMI_SOURCERESOLUTION_END_ENDCREATEOBJECTFROMBYTESTREAM            10

#define DSHOWWMI_SOURCERESOLUTION_START_LOOKUPSCHEMEHANDLER                    11
#define DSHOWWMI_SOURCERESOLUTION_END_LOOKUPSCHEMEHANDLER                      12

#define DSHOWWMI_SOURCERESOLUTION_START_LOOKUPBYTESTREAMHANDLER                13
#define DSHOWWMI_SOURCERESOLUTION_END_LOOKUPBYTESTREAMHANDLER                  14

#define DSHOWWMI_SOURCERESOLUTION_START_SCHEMEHANDLER_BEGINCREATEOBJECT        15
#define DSHOWWMI_SOURCERESOLUTION_END_SCHEMEHANDLER_BEGINCREATEOBJECT          16

#define DSHOWWMI_SOURCERESOLUTION_START_SCHEMEHANDLER_ENDCREATEOBJECT          17
#define DSHOWWMI_SOURCERESOLUTION_END_SCHEMEHANDLER_ENDCREATEOBJECT            18

#define DSHOWWMI_SOURCERESOLUTION_BYTESTREAMCREATED                            19

#define DSHOWWMI_SOURCERESOLUTION_START_BYTESTREAMHANDLER_BEGINCREATEOBJECT    20
#define DSHOWWMI_SOURCERESOLUTION_END_BYTESTREAMHANDLER_BEGINCREATEOBJECT      21

#define DSHOWWMI_SOURCERESOLUTION_START_BYTESTREAMHANDLER_ENDCREATEOBJECT      22
#define DSHOWWMI_SOURCERESOLUTION_END_BYTESTREAMHANDLER_ENDCREATEOBJECT        23

#define DSHOWWMI_SOURCERESOLUTION_MEDIASOURCECREATED                           24


typedef struct DSHOWPERFINFO_SOURCERESOLUTION {
    DSHOWPERFINFO_COMMON   hdr;
    LPCWSTR             pwszURL;
    PVOID               pObjectCreated;
    HRESULT             hr;
}   DSHOWPERFINFO_SOURCERESOLUTION;

//-------------------------
// Quality Manager events
// To indicate when quality goes up and down


#define DSHOWWMI_QM_SetQualityLevel                      1
#define DSHOWWMI_QM_SetDropMode                       2
#define DSHOWWMI_QM_SetDropTime             3

#define DSHOWWMI_QM_DECODER_KNOB   1
#define DSHOWWMI_QM_VIDEOSINK_KNOB 2
#define DSHOWWMI_QM_SOURCE_KNOB 3

typedef struct DSHOWPERFINFO_QM {
    DSHOWPERFINFO_COMMON   hdr;
    DWORD               dwKnobId;
    DWORD               dwPrevLevel;
    DWORD               dwNewLevel;    
    LONGLONG           llDropTime;
} DSHOWPERFINFO_QM;


//-------------------------
// WMILOG_ADJUST_SAMPLE_TIME
//
// If a module adjusts sample presentation times, it must log the adjustment to the samples.
// We rely heavily on sample times to detect glitches and to measure latency.
// Therefore, this event is crucial. However, rebuffering that requres new time satmps
// but involves no adjustments needs not log this event.
// E.g. a module receives a buffer of samples with timestamp s that is worth time t, i.e.
// (timestamp, duration) = (s, t). If it outputs the samples in two halves, 1st with
// (s, t/2) and 2nd with (s+t/2, t/2), there is no adjustment but new labelings, it needs
// not log this event.
// If a module applys a constant delta to sample times, it reports this event once with the starting
// sample time and type DSHOWWMI_ADJUST_SAMPLE_TIME_REPEAT until it uses a different adjustment.
// Oneshot adjustment applies to the timestamp in the event only.
//

#define DSHOWWMI_ADJUST_SAMPLE_TIME_ONESHOT (1)
#define DSHOWWMI_ADJUST_SAMPLE_TIME_REPEAT  (2)

typedef struct DSHOWPERFINFO_ADJUST_SAMPLE_TIME {
    DSHOWPERFINFO_COMMON   hdr;
    LONGLONG        llOriginalSampleTime;
    LONGLONG        llAdjustment;
}   DSHOWPERFINFO_ADJUST_SAMPLE_TIME;

//------------------------
// WMILOG_VIDEO_RENDER
//
// The renderer event for both audio and video are diverging
// in the data required. We are using a separate video render
// event here to avoid extraneous fileds for audio render.
// We need vren event to have window coordinates and Video window handle
// so we can match the bitblt events reported dxg.
// We need dxg events so we can more acuratly track actual presentation
// time of video frames. Dxg scanline events also provide us a mean to
// calculate Video clock.
//

typedef struct DSHOWPERFINFO_VIDEO_RENDER {
    DSHOWPERFINFO_COMMON   hdr;
    DSHOWWMI_PTR           pSample;
    LONGLONG            llSampleTime;
    LONGLONG            llSampleDuration;
    LONGLONG            llClockTime;
    DSHOWWMI_HANDLE        hwndVideo;
    DWORD               dwRefreshRate;
    DWORD               dwWidth;
    DWORD               dwHeight;
    DWORD               dwLeft;
    DWORD               dwTop;
    DWORD               dwRight;
    DWORD               dwBottom;
    DWORD               dwLeft1;
    DWORD               dwTop1;
    DWORD               dwRight1;
    DWORD               dwBottom1;
} DSHOWPERFINFO_VIDEO_RENDER;

//
// This event contains a superset of fileds for Renderer_Rend event. We need this
// audio specific event to have master clock and time of the sample being rendered
// so we can compute audio jitters which are needed to computer AVSync. If the audio
// renderer is chosen as the master clock, the pair of times are DONT_CARE_TIME since
// we don't need them for the AVSync calculation.
//
typedef struct _DSHOWPERFINFO_AUDIO_RENDER {
    DSHOWPERFINFO_COMMON hdr;
    DSHOWWMI_PTR         pSample;
    LONGLONG          llSampleTime;
    LONGLONG          llSampleDuration;
    LONGLONG          llMasterTime;
    LONGLONG          llDeviceTime;
} DSHOWPERFINFO_AUDIO_RENDER;


//-------------------------
// Muxer Events

#define DSHOWWMI_Muxer_ProcessSample        (1)
#define DSHOWWMI_Muxer_AddPayload           (2)
#define DSHOWWMI_Muxer_OnCompletedPacket    (3)

typedef struct DSHOWPERFINFO_MUXER
{
    DSHOWPERFINFO_COMMON   hdr;
    DWORD wStreamNumber;
    LONGLONG llSampleTime;
    DWORD cbSample;
    LONGLONG llPacketNumber;
    LONGLONG llPacketSendTime;
    DWORD cbPacket;
} DSHOWPERFINFO_MUXER;


//------------------------
// Timer Late event

typedef struct _DSHOWPERFINFO_TIMER_LATE {
    DSHOWPERFINFO_COMMON   hdr;
    LONGLONG            llEventTime;
    LONGLONG            llLateBy;
    DWORD               dwObjectID;
} DSHOWPERFINFO_TIMER_LATE;


//-------------------------
// Lock event

#define DSHOWWMI_Lock_TryAcquire   (1)
#define DSHOWWMI_Lock_Acquired     (2)
#define DSHOWWMI_Lock_Released     (3)

typedef struct DSHOWPERFINFO_LOCK
{
    DSHOWPERFINFO_COMMON   hdr;
    PVOID pLockObject;
} DSHOWPERFINFO_LOCK;


//-------------------------
// Graph events

#define DSHOWWMI_GRAPH_START_RUN                                             1
#define DSHOWWMI_GRAPH_END_RUN                                               2
#define DSHOWWMI_GRAPH_START_STOP                                            3
#define DSHOWWMI_GRAPH_END_STOP                                              4
#define DSHOWWMI_GRAPH_START_PAUSE                                           5
#define DSHOWWMI_GRAPH_END_PAUSE                                             6
#define DSHOWWMI_GRAPH_START_CACHE_LOAD                                      7
#define DSHOWWMI_GRAPH_END_CACHE_LOAD                                        8
#define DSHOWWMI_GRAPH_START_CACHE_UPDATE                                    9
#define DSHOWWMI_GRAPH_END_CACHE_UPDATE                                     10
#define DSHOWWMI_GRAPH_START_RENDERFILE                                     11
#define DSHOWWMI_GRAPH_END_RENDERFILE                                       12
#define DSHOWWMI_GRAPH_START_ADD_SOURCE_FILTER                              13
#define DSHOWWMI_GRAPH_END_ADD_SOURCE_FILTER                                14
#define DSHOWWMI_GRAPH_START_ADD_FILTER                                     15
#define DSHOWWMI_GRAPH_END_ADD_FILTER                                       16
#define DSHOWWMI_GRAPH_START_COCREATE_FILTER                                17
#define DSHOWWMI_GRAPH_END_COCREATE_FILTER                                  18
#define DSHOWWMI_GRAPH_START_GET_URL                                        19
#define DSHOWWMI_GRAPH_END_GET_URL                                          20

typedef struct DSHOWPERFINFO_GRAPH {
    DSHOWPERFINFO_COMMON   hdr;
    HRESULT             hr;
}   DSHOWPERFINFO_GRAPH;


#pragma pack(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dslisten.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:10 2007
 */
/* Compiler settings for ..\dslisten.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dslisten_h__
#define __dslisten_h__

/* Forward Declarations */ 

#ifndef __IDATASRCListener_FWD_DEFINED__
#define __IDATASRCListener_FWD_DEFINED__
typedef interface IDATASRCListener IDATASRCListener;
#endif 	/* __IDATASRCListener_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IDATASRCListener_INTERFACE_DEFINED__
#define __IDATASRCListener_INTERFACE_DEFINED__

/* interface IDATASRCListener */
/* [uuid][version][object][local] */ 


EXTERN_C const IID IID_IDATASRCListener;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050F380-98B5-11CF-BB82-00AA00BDCE0B")
    IDATASRCListener : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE datasrcChanged( 
            /* [in] */ BSTR bstrQualifier,
            /* [in] */ BOOL fDataAvail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDATASRCListenerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDATASRCListener __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDATASRCListener __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDATASRCListener __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *datasrcChanged )( 
            IDATASRCListener __RPC_FAR * This,
            /* [in] */ BSTR bstrQualifier,
            /* [in] */ BOOL fDataAvail);
        
        END_INTERFACE
    } IDATASRCListenerVtbl;

    interface IDATASRCListener
    {
        CONST_VTBL struct IDATASRCListenerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDATASRCListener_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDATASRCListener_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDATASRCListener_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDATASRCListener_datasrcChanged(This,bstrQualifier,fDataAvail)	\
    (This)->lpVtbl -> datasrcChanged(This,bstrQualifier,fDataAvail)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDATASRCListener_datasrcChanged_Proxy( 
    IDATASRCListener __RPC_FAR * This,
    /* [in] */ BSTR bstrQualifier,
    /* [in] */ BOOL fDataAvail);


void __RPC_STUB IDATASRCListener_datasrcChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDATASRCListener_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dstruct.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#ifndef _DSTRUCT_H
#define _DSTRUCT_H

#ifndef dim
// Prefer to use _countof() directly, replacing dim()
#pragma deprecated("dim")
#define dim(x) _countof(x)
#endif

#define SAFEDELETE( pointer ) \
    if ( NULL != pointer )    \
    {                         \
        delete pointer;       \
        pointer = NULL;       \
    }


typedef struct _Supported_Video_Formats
{
    GUID                categoryGUID;
    ULONG               ulAvailFormats;
    PCS_DATARANGE_VIDEO *pCsDataRangeVideo;
} PINVIDEOFORMAT, * PPINVIDEOFORMAT;

typedef struct _Sensor_Property 
{
    ULONG                     ulDefaultValue;
    ULONG                     ulCurrentValue;
    ULONG                     ulFlags;
    ULONG                     ulCapabilities;
    PCSPROPERTY_VALUES        pCsPropValues;
    PCSPROPERTY_STEPPING_LONG pRangeNStep;
    BOOL                      fGetSupported;
    BOOL                      fSetSupported;
} SENSOR_PROPERTY, * PSENSOR_PROPERTY;

typedef struct _Video_Control_Caps
{
    ULONG DefaultVideoControlCaps;
    ULONG CurrentVideoControlCaps;
} VIDCONTROLCAPS, *PVIDCONTROLCAPS;

class CPinDevice;

typedef struct _StreamInstances
{
    DWORD        dwSize;
    ULONG        ulCInstances;
    ULONG        ulPossibleCount;
    CSSTATE      CsPrevState;
    VIDCONTROLCAPS   VideoCaps;
    PPINVIDEOFORMAT   pVideoFormat;
    CPinDevice * pPinDev;
} STREAM_INSTANCES, * PSTREAM_INSTANCES;


typedef struct _SensorModeInfo
{
    DWORD dwSize;
    ULONG MemoryModel;          // Memory model to be used for this sensor mode. Allowed values are 
                                // CSPROPERTY_BUFFER_CLIENT_LIMITED, CSPROPERTY_BUFFER_CLIENT_UNLIMITED
                                // and CSPROPERTY_BUFFER_DRIVER.
    ULONG MaxNumOfBuffers;      // Max Number of buffers of buffers for this sensor mode.
    ULONG PossibleCount;        // Max Number of Instances of this sensor Mode that this PDD/MDD support
                                // Usually set to 1;
    VIDCONTROLCAPS   VideoCaps; // VideoControl Caps corresponding to the sensor mode    
    PPINVIDEOFORMAT   pVideoFormat;// All the Video Formats supported by the sensor mode

} SENSORMODEINFO, *PSENSORMODEINFO;

typedef struct _AdapterInfo
{
    DWORD dwSize;
    ULONG ulCTypes;     // Total number of senosr modes implemented by this camera
    ULONG ulVersionID;  // The version number of MDD/PDD interface that the PDD implements    
    POWER_CAPABILITIES PowerCaps; // Power Capabilities   
    SENSOR_PROPERTY     SensorProps[NUM_PROPERTY_ITEMS]; // All ProcAmp and CameraControl props
} ADAPTERINFO, *PADAPTERINFO;


typedef struct __PDD_FuncTbl {
    DWORD dwSize;
    PVOID (*PDD_Init)( PVOID MDDContext, __PDD_FuncTbl * pPDDFuncTbl );
    DWORD (*PDD_DeInit)( LPVOID PDDContext );
    DWORD (*PDD_GetAdapterInfo)( LPVOID PDDContext, PADAPTERINFO pAdapterInfo );
    DWORD (*PDD_HandleVidProcAmpChanges)( LPVOID PDDContext, DWORD dwPropId, LONG lFlags, LONG lValue);
    DWORD (*PDD_HandleCamControlChanges)( LPVOID PDDContext, DWORD dwPropId, LONG lFlags, LONG lValue );
    DWORD (*PDD_HandleVideoControlCapsChanges)( LPVOID PDDContext, LONG lModeType ,ULONG ulCaps );
    DWORD (*PDD_SetPowerState)( LPVOID PDDContext, CEDEVICE_POWER_STATE PowerState );
    DWORD (*PDD_HandleAdapterCustomProperties)( LPVOID PDDContext, PUCHAR pInBuf, DWORD  InBufLen, PUCHAR pOutBuf, DWORD  OutBufLen, PDWORD pdwBytesTransferred );
    DWORD (*PDD_InitSensorMode)( LPVOID PDDContext, ULONG ulModeType, LPVOID ModeContext );
    DWORD (*PDD_DeInitSensorMode)( LPVOID PDDContext, ULONG ulModeType );
    DWORD (*PDD_SetSensorState)( LPVOID PDDContext, ULONG ulModeType, CSSTATE CsState );
    DWORD (*PDD_TakeStillPicture)( LPVOID PDDContext, LPVOID pBurstModeInfo );
    DWORD (*PDD_GetSensorModeInfo)( LPVOID PDDContext, ULONG ulModeType, PSENSORMODEINFO pSensorModeInfo );
    DWORD (*PDD_SetSensorModeFormat)( LPVOID PDDContext, ULONG ulModeType, PCS_DATARANGE_VIDEO pCsDataRangeVideo );
    PVOID (*PDD_AllocateBuffer)( LPVOID PDDContext, ULONG ulModeType );
    DWORD (*PDD_DeAllocateBuffer)( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );
    DWORD (*PDD_RegisterClientBuffer)( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );
    DWORD (*PDD_UnRegisterClientBuffer)( LPVOID PDDContext, ULONG ulModeType, PVOID pBuffer );
    DWORD (*PDD_FillBuffer)( LPVOID PDDContext, ULONG ulModeType, PUCHAR pImage );
    DWORD (*PDD_HandleModeCustomProperties)( LPVOID PDDContext, ULONG ulModeType, PUCHAR pInBuf, DWORD  InBufLen, PUCHAR pOutBuf, DWORD  OutBufLen, PDWORD pdwBytesTransferred );
} PDDFUNCTBL, *PPDDFUNCTBL;

typedef struct __PDD_FuncTbl2 {
    PDDFUNCTBL PDDfuncTble1;
    DWORD (*PDD_Open)( LPVOID PDDContext, LPVOID MDDOpenContext );
    DWORD (*PDD_Close)( LPVOID PDDContext, LPVOID MDDOpenContext );
    DWORD (*PDD_GetMetadata)( LPVOID PDDContext, DWORD dwPropId, PUCHAR pOutBuf, DWORD OutBufLen, PDWORD pdwBytesTransferred );
} PDDFUNCTBL2, *PPDDFUNCTBL2;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dsthread.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#ifndef _DEF_DSTHREAD_H
#define _DEF_DSTHREAD_H

// The module is for changing thread priority from registry
// daihu - Jan 7 2001

#define CUSTOM_THREADPRIORITY

HANDLE _internal_CreateThread (
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD   cbStack,
    LPTHREAD_START_ROUTINE lpStartAddr,
    LPVOID lpvThreadParam,
    DWORD fdwCreate,
    LPDWORD lpIDThread
    );

int _internal_GetThreadPriority(HANDLE hThread);

BOOL _internal_SetThreadPriority(HANDLE hThread, int nPriority);

#ifndef CUSTOM_THREADPRIORITY

inline HANDLE _internal_CreateThread (
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD   cbStack,
    LPTHREAD_START_ROUTINE lpStartAddr,
    LPVOID lpvThreadParam,
    DWORD fdwCreate,
    LPDWORD lpIDThread
    )
{
	return CreateThread (lpsa, cbStack, lpStartAddr, lpvThreadParam, fdwCreate, lpIDThread);
}

inline int _internal_GetThreadPriority(HANDLE hThread)
{
	return CeGetThreadPriority (hThread);
}

inline BOOL _internal_SetThreadPriority(HANDLE hThread, int nPriority)
{
	return SetThreadPriority (hThread, nPriority);
}

#endif // CUSTOM_THREADPRIORITY

#endif // _DEF_DSTHREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dtbase.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DTBase.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseNTo1 transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DTBase.h"
#include "new.h"

//--- Initialize static member of debug scope class
#ifdef _DEBUG
CDXTDbgFlags CDXTDbgScope::m_DebugFlags;
#endif

//--- This should only be used locally in this file. We duplicated this GUID
//    value to avoid having to include DDraw.
static const IID IID_IDXDupDirectDraw =
    { 0x6C14DB80,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDDrawSurface =
    { 0x6C14DB81,0xA733,0x11CE, { 0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 } };

static const IID IID_IDXDupDirect3DRM =
    {0x2bc49361, 0x8327, 0x11cf, {0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1 } };

static const IID IID_IDXDupDirect3DRM3 =
    {0x4516ec83, 0x8f20, 0x11d0, {0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3 } };

static const IID IID_IDXDupDirect3DRMMeshBuilder3 =
    { 0x4516ec82, 0x8f20, 0x11d0, { 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3} };

HRESULT CDXDataPtr::Assign(BOOL bMesh, IUnknown * pObject, IDXSurfaceFactory *pSurfaceFactory)
{
    HRESULT hr = S_OK;
    if (pObject)
    {
        IUnknown *pNative = NULL;
        if (!bMesh)
        {
            //--- Try to get a DX surface
            hr = pObject->QueryInterface( IID_IDXSurface, (void **)&pNative );
            if( FAILED( hr ) )
            {
                IDirectDrawSurface *pSurf;
                //--- Try to get a DDraw surface
                hr = pObject->QueryInterface( IID_IDXDupDDrawSurface, (void **)&pSurf );
                if( SUCCEEDED( hr ) )
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = pSurfaceFactory->CreateFromDDSurface(
                                pSurf, NULL, 0, NULL, IID_IDXSurface,
                                (void **)&pNative );
                    pSurf->Release();
                }
            }
        }
        else // Must be a mesh builder
        {
            hr = pObject->QueryInterface(IID_IDXDupDirect3DRMMeshBuilder3, (void **)&pNative);
        }
        if (SUCCEEDED(hr))
        {
            Release();
            m_pNativeInterface = pNative;
            pObject->AddRef();
            m_pUnkOriginalObject = pObject;
            if (SUCCEEDED(pNative->QueryInterface(IID_IDXBaseObject, (void **)&m_pBaseObj)))
            {
                m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
                m_dwLastDirtyGenId--;
            }
            if (!bMesh)
            {   
                ((IDXSurface *)pNative)->GetPixelFormat(NULL, &m_SampleFormat);
            }
        }
        else
        {
            if (hr == E_NOINTERFACE)
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else 
    {
        Release();
    }
    return hr;
} /* CDXDataPtr::Assign */

bool CDXDataPtr::IsDirty(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastDirtyGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastDirtyGenId);
        return dwOldId != m_dwLastDirtyGenId;
    }
    else
    {
        return false;
    }

}

DWORD CDXDataPtr::GenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwGenId;
        m_pBaseObj->GetGenerationId(&dwGenId);
        return dwGenId;
    }
    else
    {
        return 0;
    }
}


bool CDXDataPtr::UpdateGenerationId(void)
{
    if (m_pBaseObj)
    {
        DWORD dwOldId = m_dwLastUpdGenId;
        m_pBaseObj->GetGenerationId(&m_dwLastUpdGenId);
        return dwOldId != m_dwLastUpdGenId;
    }
    else
    {
        return false;
    }
} /* CDXDataPtr::UpdateGenerationId */

ULONG CDXDataPtr::ObjectSize(void)
{
    ULONG ulSize = 0;
    if (m_pBaseObj)
    {
        m_pBaseObj->GetObjectSize(&ulSize);
    }
    return ulSize;    
}

/*****************************************************************************
* CDXBaseNTo1::CDXBaseNTo1 *
*--------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::CDXBaseNTo1() :
    m_aInputs(NULL),
    m_ulNumInputs(0),
    m_ulNumProcessors(1),   // Default to one until task manager is set
    m_dwGenerationId(1),
    m_dwCleanGenId(0),
    m_Duration(1.0f),
    m_StepResolution(0.0f),
    m_Progress(0.0f),
    m_dwBltFlags(0),
    m_bPickDoneByBase(false),
    m_bInMultiThreadWorkProc(FALSE),
    m_fQuality(0.5f),   // Default to normal quality.
    //  Wait forever before timing out on a lock by default
    m_ulLockTimeOut(INFINITE),
    //
    //  Override these flags if your object does not support one or more of these options.
    //  Typically, 3-D effects should set this member to 0.
    //
    m_dwMiscFlags(DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT |
                  DXTMF_BLEND_SUPPORTED | DXTMF_DITHER_SUPPORTED | DXTMF_BOUNDS_SUPPORTED | DXTMF_PLACEMENT_SUPPORTED),
    //
    //  If your object has a different number of objects or a different number of
    //  required objects than 1, simply set these members in the body of your
    //  constructor or in FinalConstruct().  For every input that is > the number
    //  required, that input will be reported as optional.
    //
    //  If your transform takes 2 required inputs, set both to 2.
    //  If your transform takes 2 optional inputs, set MaxInputs = 2, NumInRequired = 0
    //  If your transform takes 1 required and 2 optional inputs,
    //      set MaxInputs = 2, NumInRequired = 1
    //
    //  For more complex combinations of optinal/required, you will need to override
    //  the OnSetup method of this base class, and override the methods
    //      GetInOutInfo
    //
    m_ulMaxInputs(1),
    m_ulNumInRequired(1),
    //
    //  If the intputs or output types are not surfaces then set appropriate object type
    //
    m_dwOptionFlags(0),     // Inputs and output are surfaces, don't have to be the same size
    m_ulMaxImageBands(DXB_MAX_IMAGE_BANDS),
    m_fIsSetup(false)
{
    DXTDBG_FUNC( "CDXBaseNTo1::CDXBaseNTo1" );
    //
    //  Set event handles to NULL.
    //
    memset(m_aEvent, 0, sizeof(m_aEvent));
} /* CDXBaseNTo1::CDXBaseNTo1 */

/*****************************************************************************
* CDXBaseNTo1::~CDXBaseNTo1 *
*---------------------------*
*   Description:
*       Constructor
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
CDXBaseNTo1::~CDXBaseNTo1()
{
    DXTDBG_FUNC( "CDXBaseNTo1::~CDXBaseNTo1" );
    _ReleaseReferences();
    delete[] m_aInputs;

    //--- Release event objects
    for(ULONG i = 0; i < DXB_MAX_IMAGE_BANDS; ++i )
    {
        if( m_aEvent[i] ) ::CloseHandle( m_aEvent[i] );
    }
} /* CDXBaseNTo1::~CDXBaseNTo1 */


/*****************************************************************************
* CDXBaseNTo1::_ReleaseRefernces *
*--------------------------------*
*   Description:
*       Releases all references to input and output objects
*-----------------------------------------------------------------------------
*   Created By: RAL
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::_ReleaseReferences()
{
    //--- Release data objects
    if( m_aInputs )
    {
        for( ULONG i = 0; i < m_ulNumInputs; ++i )
        {
            m_aInputs[i].Release();
        }
    }

    m_Output.Release();

    m_fIsSetup = false;
} /* CDXBaseNTo1::_ReleaseRefernces */



STDMETHODIMP CDXBaseNTo1::GetGenerationId(ULONG *pGenerationId)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetGenerationId" );
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseNTo1::IncrementGenerationId(BOOL bRefresh)
{
    DXTDBG_FUNC( "CDXBaseNTo1::IncrementGenerationId" );
    HRESULT hr = S_OK;
    Lock();
    m_dwGenerationId++;
    if (bRefresh)
    {
        //
        //  If we have any inputs or outputs, call Setup again to refresh all internal
        //  knowledge about the surfaces (formats, height or width could change, etc.)
        //
        //  Note that we need to AddRef the objects prior to calling Setup becuase the
        //  DXTransform may be the only object holding a referec
        //
        ULONG cInputs = m_ulNumInputs;
        ULONG cOutputs = 0;
        IUnknown *pOutput = m_Output.m_pUnkOriginalObject;
        if (pOutput)
        {
            cOutputs = 1;
            pOutput->AddRef();
        }
        IUnknown ** ppInputs = NULL;
        if (cInputs)
        {
            ppInputs = (IUnknown **)_alloca(m_ulNumInputs * sizeof(IUnknown *));
            for (ULONG i = 0; i < cInputs; i++)
            {
                ppInputs[i] = m_aInputs[i].m_pUnkOriginalObject;
                if (ppInputs[i]) ppInputs[i]->AddRef();
            }
        }
        if (cInputs || cOutputs)    // If we're not setup, skip this step.
        {
            hr = Setup(ppInputs, cInputs, &pOutput, cOutputs, 0);
            if (pOutput) pOutput->Release();
            for (ULONG i = 0; i < cInputs; i++)
            {
                if (ppInputs[i]) ppInputs[i]->Release();
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetObjectSize(ULONG *pcbSize)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetObjectSize" );
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}


void CDXBaseNTo1::_ReleaseServices(void)
{
    m_cpTransFact.Release();
    m_cpSurfFact.Release();
    m_cpTaskMgr.Release();
    m_cpDirectDraw.Release();
#ifndef IEMOBILE    
    m_cpDirect3DRM.Release();
#endif // #ifndef IEMOBILE  
}

//
//  The documentation for SetSite indicates that it is invaid to return
//  an error from this function, even if the site does not support the
//  functionality we want.  So, even if there is no service provider, or
//  the required services are not available, we will return S_OK.
//
STDMETHODIMP CDXBaseNTo1::SetSite(IUnknown * pUnkSite)
{
    DXTDBG_FUNC( "CDXBaseNTo1::SetSite" );
    HRESULT hr = S_OK;
    Lock();
    m_cpUnkSite = pUnkSite;
    _ReleaseServices();
    if (pUnkSite)
    {
        if (DXIsBadInterfacePtr(pUnkSite))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            HRESULT hr2;
            hr2 = pUnkSite->QueryInterface(IID_IDXTransformFactory, (void **)&m_cpTransFact);
	    if (SUCCEEDED(hr2))
	    {
                //
                //  Allocate memory for inputs if necessary
                //
                if (m_aInputs == NULL && m_ulMaxInputs)
                {
                    m_aInputs  = new CDXDataPtr[m_ulMaxInputs];
                    if (!m_aInputs)
                    {
                        _ASSERT(TRUE);
                        hr2 = E_OUTOFMEMORY;
                    }
                }
                hr2 = m_cpTransFact->QueryService( SID_SDXSurfaceFactory, IID_IDXSurfaceFactory, (void **)&m_cpSurfFact);
#ifndef IEMOBILE
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService( SID_SDXTaskManager, IID_IDXTaskManager, (void **)&m_cpTaskMgr);
                }
                if (SUCCEEDED(hr2))
                {
                    m_cpTaskMgr->QueryNumProcessors(&m_ulNumProcessors);
                    if (m_ulMaxImageBands && (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)) == 0)
                    {
                        for (ULONG i = 0; SUCCEEDED(hr2) && i < m_ulMaxImageBands; i++)
                        {
                            //
                            // In theory we could get back here after failing to create an event, or
                            // by getting a new site, so make sure it's non-null before creating one.
                            //
                            if (m_aEvent[i] == NULL)
                            {
                                m_aEvent[i] = ::CreateEvent(NULL, true, false, NULL);
                                if (m_aEvent[i] == NULL)
                                {
                                    hr2 = E_OUTOFMEMORY;
                                }
                            }

                        }
                    }
                }
#endif // #ifndef IEMOBILE
                if (SUCCEEDED(hr2))
                {
                    hr2 = m_cpTransFact->QueryService(SID_SDirectDraw, IID_IDXDupDirectDraw, (void**)&m_cpDirectDraw);
                }
                if (SUCCEEDED(hr2) && 
                    (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
                {
#ifndef IEMOBILE                
                    hr2 = m_cpTransFact->QueryService(SID_SDirect3DRM, IID_IDXDupDirect3DRM3, (void **)&m_cpDirect3DRM);
#else
                    hr2 = E_NOINTERFACE;
#endif
                }
                if (FAILED(hr2))
                {
                    _ASSERT(TRUE);
                    _ReleaseServices();
                }
            }
        }
    }
    Unlock();
    return hr;
}


STDMETHODIMP CDXBaseNTo1::GetSite(REFIID riid, void **ppv)
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetSite" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(ppv, sizeof(*ppv)) )
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        if (m_cpUnkSite)
        {
            hr = m_cpUnkSite->QueryInterface(riid, ppv);
        }
        else
        {
            *ppv = NULL;
            hr = E_FAIL;    // This is the proper documented return code
                            // for this interface if no service provider.
        }
        Unlock();
    }
    return hr;
} 


void CDXBaseNTo1::_UpdateBltFlags(void)
{
    m_dwBltFlags = 0;
    if ((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0)
    {
        if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) 
        {
            if ((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) || m_ulNumInputs == 0)
            {
                m_dwBltFlags |= DXBOF_DO_OVER;
            }
            else
            {
                for(ULONG i = 0; i < m_ulNumInputs; ++i )
                {
                    if (InputSampleFormat(i) & DXPF_TRANSPARENCY)
                    {
                        m_dwBltFlags |= DXBOF_DO_OVER;
                        break;
                    }
                }
            }
        }
        //
        //  Set the dither flag to true only if output error is > at least one input
        //
        if (m_dwMiscFlags & DXTMF_DITHER_OUTPUT)
        {
            ULONG OutputErr = (OutputSampleFormat() & DXPF_ERRORMASK);
            if (OutputErr)
            {
                if (m_ulNumInputs)
                {
                    for(ULONG i = 0; i < m_ulNumInputs; ++i )
                    {
                        if (InputSurface(i) && (ULONG)(InputSampleFormat(i) & DXPF_ERRORMASK) < OutputErr)
                        {
                            m_dwBltFlags |= DXBOF_DITHER;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // If output has no error then don't set dither in blt flags
                    //  
                    if (OutputErr)
                    {
                        m_dwBltFlags |= DXBOF_DITHER; 
                    }
                }
            }
        }
    }
}



/*****************************************************************************
* CDXBaseNTo1::Setup *
*--------------------*
*   Description:
*       The Setup method is used to perform any required one-time setup
*   before the Execute method is called. Single surfaces or SurfaceSets may
*   be used as arguments in any combination. 
*   If punkOutputs is NULL, Execute will allocate an output result of the
*   appropriate size and return it.
*   if punkInputs and punkOutputs are NULL and it is a quick setup, the current
*   input and output objects are released.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::Setup( IUnknown * const * punkInputs, ULONG ulNumInputs,
                                 IUnknown * const * punkOutputs, ULONG ulNumOutputs, DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Setup" );
    //--- Lock object so state cannot change during setup
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    ULONG i;

    //
    //  Early out for null setup.  Forget about all other param validation, just do it.
    //  
    if (ulNumInputs == 0 && ulNumOutputs == 0)
    {
        _ReleaseReferences();
        OnReleaseObjects();
        return hr;
    }

    //--- Validate Params
    //--- Make sure we have a reference to the transform factory
    if( !m_cpTransFact )
    {
        hr = DXTERR_UNINITIALIZED;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
    }
    else
    {
        //
        //  We know that if we have a transform factory that we must also have
        //  allocated m_aInputs since this is done on SetSite to avoid work during
        //  each setup.
        //
        _ASSERT(m_aInputs || m_ulMaxInputs == 0);
        if( dwFlags ||              // No flags are valid
            ulNumOutputs != 1 ||
            ulNumInputs < m_ulNumInRequired ||
            ulNumInputs > m_ulMaxInputs ||
            (ulNumInputs && DXIsBadReadPtr( punkInputs , sizeof( *punkInputs ) * ulNumInputs )) ||
            DXIsBadReadPtr(punkOutputs, sizeof(*punkOutputs)) ||
            DXIsBadInterfacePtr(punkOutputs[0]))
        {
            hr = E_INVALIDARG;
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
        }
        else
        {
            for( i = 0; i < ulNumInputs; ++i )
            {
                if((punkInputs[i] && DXIsBadInterfacePtr(punkInputs[i])) ||
                    (punkInputs[i] == NULL && i < m_ulNumInRequired))
                {
                    hr = E_INVALIDARG;
                    DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
                    break;
                }
            }        
        }
    }

    //--- Allocate slots for input data object pointers
    if( SUCCEEDED( hr ) )
    {
        //--- Release data objects
        _ReleaseReferences();
        m_ulNumInputs = ulNumInputs;
    }

    //
    //  Assign 
    //
    for( i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
    {
        hr = m_aInputs[i].Assign((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER), punkInputs[i], m_cpSurfFact);
    }

    if( SUCCEEDED(hr) )
    {
        hr = m_Output.Assign((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER), punkOutputs[0], m_cpSurfFact);
    }   

    if (SUCCEEDED(hr) && (m_dwOptionFlags & DXBOF_SAME_SIZE_INPUTS))
    {
        hr = _MakeInputsSameSize();
    }

    if (SUCCEEDED(hr))
    {
        _UpdateBltFlags();      // Do this before calling OnSetup...
        hr = OnSetup(dwFlags);
    }
    
    if (FAILED(hr))
    {
        _ReleaseReferences();
        OnReleaseObjects();
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup failed" );
    }
    else
    {
        m_fIsSetup = true;
    }

    return hr;
} /* CDXBaseNTo1::Setup */


/*****************************************************************************
* CDXBaseNTo1::_MakeInputsSameSize *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 03/31/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

HRESULT CDXBaseNTo1::_MakeInputsSameSize(void)
{
    _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);

    HRESULT hr = S_OK;
    if (m_ulNumInputs > 1)      // No need to do this for just one input!
    {
        CDXDBnds SurfBnds(false);
        CDXDBnds Union(true);
        ULONG i;
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                Union |= SurfBnds;
            }
        }
        for (i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; i++)
        {
            if (InputSurface(i))
            {
                hr = SurfBnds.SetToSurfaceBounds(InputSurface(i));
                if (SUCCEEDED(hr) && SurfBnds != Union)
                {
                    IDXSurfaceModifier *pSurfMod;
                    hr = ::CoCreateInstance(CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                            IID_IDXSurfaceModifier, (void **)&pSurfMod);
                    if (SUCCEEDED(hr))
                    {
                        POINT p;
                        p.x = p.y = 0;
                        if (m_dwOptionFlags & DXBOF_CENTER_INPUTS)
                        {
                            p.x = (Union.Width() - SurfBnds.Width()) / 2;
                            p.y = (Union.Height() - SurfBnds.Height()) / 2;
                        }
                        pSurfMod->SetForeground(InputSurface(i), FALSE, &p);
                        pSurfMod->SetBounds(&Union);
                        InputSurface(i)->Release();
                        pSurfMod->QueryInterface(IID_IDXSurface, (void **)&(m_aInputs[i].m_pNativeInterface));
                        ((IDXSurface *)m_aInputs[i].m_pNativeInterface)->GetPixelFormat(NULL, &m_aInputs[i].m_SampleFormat);
                        pSurfMod->Release();
                    }
                }
            }
        }
    }
    return hr;
}


/*****************************************************************************
* CDXBaseNTo1::Execute *
*----------------------*
*   Description:
*       The Execute method is used to walk the inputs/outputs and break up the
*   work into suitably sized pieces to spread symetrically accross the available
*   processors in the system.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    Execute( const GUID* pRequestID, const DXBNDS *pClipBnds, const DXVEC *pPlacement )
{
    DXTDBG_FUNC( "CDXBaseNTo1::Execute" );
    //--- Lock object so state cannot change during execution
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;

    //--- Check args
    if( !HaveOutput() )
    {
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform has not been initialized" );
        return DXTERR_UNINITIALIZED;
    }

    if (m_ulMaxImageBands == 0 ||
        (m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER)))
    {
        if ((pClipBnds && (m_dwMiscFlags & DXTMF_BOUNDS_SUPPORTED) == 0) ||
            (pPlacement && (m_dwMiscFlags & DXTMF_PLACEMENT_SUPPORTED) == 0) )
        {
            DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
            return E_INVALIDARG;
        }
        return OnExecute( pRequestID, pClipBnds, pPlacement );
    }

    //--- Banded image working variables
    CDXTWorkInfoNTo1 WI;

    if ((pClipBnds && pClipBnds->eType != DXBT_DISCRETE) ||
        (pPlacement && pPlacement->eType != DXBT_DISCRETE))
    {
        hr = E_INVALIDARG;
        DXTDBG_MSG0( _CRT_ERROR, "\nTransform setup with invalid args" );
    }
    else
    {
        hr = MapBoundsIn2Out( NULL, 0, 0, &WI.DoBnds );
        if( hr == S_OK )
        {
            hr = WI.OutputBnds.SetToSurfaceBounds(OutputSurface());
            if (hr == S_OK)
            {
                hr = DXClipToOutputWithPlacement(WI.DoBnds, (CDXDBnds *)pClipBnds, WI.OutputBnds, (CDXDVec *)pPlacement);
            }
        }
    }

    //--- Check for clipping early exit
    if( hr != S_OK )
    {
        return hr;
    }

    //=== Process ====================================================
    _ASSERT(m_ulMaxImageBands <= DXB_MAX_IMAGE_BANDS);
    ULONG ulNumBandsToDo = m_ulNumProcessors;
    if( ulNumBandsToDo > 1 )
    {
        ulNumBandsToDo = 1 + ((WI.OutputBnds.Width() * WI.OutputBnds.Height()) / 0x1000);
        if (ulNumBandsToDo > m_ulMaxImageBands)
        {
            ulNumBandsToDo = m_ulMaxImageBands;
        }
        if (ulNumBandsToDo > m_ulNumProcessors)
        {
            ulNumBandsToDo = m_ulNumProcessors;
        }
    }
    hr = OnInitInstData(WI, ulNumBandsToDo);
    if( SUCCEEDED( hr ) )
    {
        if (ulNumBandsToDo == 1 && pRequestID == NULL)
        {
            static BOOL bContinue = TRUE;
            hr = WorkProc(WI, &bContinue);
        }
        else
        {
            _ASSERT( ulNumBandsToDo <= DXB_MAX_IMAGE_BANDS );
            _ASSERT( m_aEvent[ulNumBandsToDo-1] );

            long lStartAtRow = WI.DoBnds[DXB_Y].Min;
            ULONG ulRowCount = WI.DoBnds[DXB_Y].Max - lStartAtRow;
            _ASSERT( ( ulRowCount / ulNumBandsToDo ) != 0 );

            //--- Init the work info structures
            ULONG ulBand, RowsPerBand = ulRowCount / ulNumBandsToDo;
            CDXTWorkInfoNTo1 *WIArray = (CDXTWorkInfoNTo1*)alloca( sizeof(CDXTWorkInfoNTo1) *
                                                         ulNumBandsToDo );
            DWORD *TaskIDs = (DWORD*)alloca( sizeof(DWORD) * ulNumBandsToDo );
            DXTMTASKINFO* TaskInfo = (DXTMTASKINFO*)alloca( sizeof( DXTMTASKINFO ) *
                                                            ulNumBandsToDo );

            //--- Build task info list
            WI.hr       = S_OK;
            WI.pvThis   =  this;
            long Start  = lStartAtRow;
            ULONG Count = RowsPerBand;
            long OutputYDelta = WI.OutputBnds[DXB_Y].Min - WI.DoBnds[DXB_Y].Min;

            for (ulBand = 0; ulBand < ulNumBandsToDo; ++ulBand)
            {
                memcpy(&WIArray[ulBand], &WI, sizeof(WI));

                WIArray[ulBand].DoBnds[DXB_Y].Min       = Start;
                WIArray[ulBand].OutputBnds[DXB_Y].Min   = Start + OutputYDelta;

                // If this is the last band, make sure it includes the last row.

                if (ulBand == ulNumBandsToDo - 1)
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = WI.DoBnds[DXB_Y].Max;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = WI.OutputBnds[DXB_Y].Max;
                }
                else // Not the last band.
                {
                    WIArray[ulBand].DoBnds[DXB_Y].Max       = Start + Count;
                    WIArray[ulBand].OutputBnds[DXB_Y].Max   = Start + Count 
                                                              + OutputYDelta;
                }

                TaskInfo[ulBand].pfnTaskProc      = _TaskProc;
                TaskInfo[ulBand].pTaskData        = &WIArray[ulBand];
                TaskInfo[ulBand].pfnCompletionAPC = NULL;
                TaskInfo[ulBand].dwCompletionData = 0;
                TaskInfo[ulBand].pRequestID       = pRequestID;

                // Advance.

                Start += Count;
            }

            //
            //  Procedural surfaces (and perhaps some transforms) need to "know" that
            //  they are in a multi-threaded work procedure to avoid deadlocks.  Procedural
            //  surfaces need to allow LockSurface to work WITHOUT taking the object
            //  critical section.  Other transforms may also want to know this information
            //  to avoid deadlocks.
            //
            m_bInMultiThreadWorkProc = TRUE;

            //--- Schedule the work and wait for it to complete
            hr = m_cpTaskMgr->ScheduleTasks( TaskInfo, m_aEvent,
                                             TaskIDs, ulNumBandsToDo, m_ulLockTimeOut );

            m_bInMultiThreadWorkProc = FALSE;

            //--- Check return codes from work info structures
            //    return the first bad hr if any
            for( ulBand = 0; SUCCEEDED( hr ) && ( ulBand < ulNumBandsToDo ); ++ulBand )
            {
                hr = WIArray[ulBand].hr;
                if( hr != S_OK ) break;
            }
        }
        OnFreeInstData( WI );
    }

#ifdef _DEBUG
    if( FAILED( hr ) ) DXTDBG_MSG1( _CRT_ERROR, "\nExecute failed. HR = %X", hr );
#endif

    return hr;
} /* CDXBaseNTo1::Execute */

/*****************************************************************************
* CDXBaseNTo1::_ImageMapIn2Out *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_ImageMapIn2Out( CDXDBnds & bnds, ULONG ulNumInBnds,
                                      const CDXDBnds * pInBounds )
{
    HRESULT hr = S_OK;
    if(ulNumInBnds)
    {
        for(ULONG i = 0; i < ulNumInBnds; ++i )
        {
            bnds |= pInBounds[i];
        }
    }
    else
    {
        for( ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
        {
            if (InputSurface(i))
            {
                CDXDBnds SurfBnds(InputSurface(i), hr);
                bnds |= SurfBnds;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = DetermineBnds(bnds);
    }
    return hr;
} /* CDXBaseNTo1::_ImageMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::_MeshMapIn2Out *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 07/28/97
*****************************************************************************/
HRESULT CDXBaseNTo1::_MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds)
{
#ifndef IEMOBILE
    HRESULT hr = S_OK;
    if (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER)
    {
        if(ulNumInBnds)
        {
            for(ULONG i = 0; i < ulNumInBnds; ++i )
            {
                bnds |= pInBounds[i];
            }
        }
        else
        {
            for(ULONG i = 0; SUCCEEDED(hr) && i < m_ulNumInputs; ++i )
            {
                if (InputMeshBuilder(i))
                {
                    CDXCBnds MeshBnds(InputMeshBuilder(i), hr);
                    bnds |= MeshBnds;
                }
            }

        }
    }
    else
    {
        //  Already done -> bnds[DXB_T].Min = 0.0f;
        bnds[DXB_X].Min = bnds[DXB_Y].Min = bnds[DXB_Z].Min = -1.0f;
        bnds[DXB_X].Max = bnds[DXB_Y].Max = bnds[DXB_Z].Max = bnds[DXB_T].Max = 1.0f;
    }

    //
    //  Call the derived class to get the scale values.
    //
    if (SUCCEEDED(hr))
    {
	// Increase the size just a bit so we won't have rounding errors
	// result in bounds that don't actually contain the result.
	const float fBndsIncrease = 0.0001F;
	float fTemp = bnds.Width() * fBndsIncrease;

	bnds[DXB_X].Min -= fTemp;
	bnds[DXB_X].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Height();
	bnds[DXB_Y].Min -= fTemp;
	bnds[DXB_Y].Max += fTemp;

	fTemp = fBndsIncrease * bnds.Depth();
	bnds[DXB_Z].Min -= fTemp;
	bnds[DXB_Z].Max += fTemp;

        hr = DetermineBnds(bnds);
    }
    return hr;
#else
    return E_FAIL;
#endif
} /* CDXBaseNTo1::_MeshMapIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsIn2Out *
*------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                           ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsIn2Out" );
    if((ulNumInBnds && DXIsBadReadPtr( pInBounds, ulNumInBnds * sizeof( *pInBounds ) )) ||
        ulOutIndex)
    {
        return E_INVALIDARG;
    }

    if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        return E_POINTER;
    }
    //
    //  Set the bounds to empty and the appropriate type.
    //
    memset(pOutBounds, 0, sizeof(*pOutBounds));
    _ASSERT(DXBT_DISCRETE == 0);
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        pOutBounds->eType = DXBT_CONTINUOUS;
    }

    //
    //  Make sure all input bounds are of the correct type.
    //
    if( ulNumInBnds )
    {
        DXBNDTYPE eType = (m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) ? DXBT_CONTINUOUS : DXBT_DISCRETE;
        for (ULONG i = 0; i < ulNumInBnds; i++)
        {
            if (pInBounds[i].eType != eType)
            {
                return E_INVALIDARG;
            }
        }
    }

    //
    //  Now do the appropriate mapping
    //
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        //
        //  NOTE:  In the case of non-mesh inputs, the inputs are discrete, but they will
        //         be completely ignored by the function so it's OK to cast them to CDXCBnds
        //
        return _MeshMapIn2Out(*((CDXCBnds *)pOutBounds), ulNumInBnds, (CDXCBnds *)pInBounds);
    }
    else 
    {
        return _ImageMapIn2Out(*(CDXDBnds *)pOutBounds, ulNumInBnds, (CDXDBnds *)pInBounds);
    }
} /* CDXBaseNTo1::MapBoundsIn2Out */

/*****************************************************************************
* CDXBaseNTo1::MapBoundsOut2In *
*------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::
    MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXBaseNTo1::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if (m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER)
    {
        hr = E_NOTIMPL;     // This is pointless for meshes.
    }
    else if(ulInIndex >= m_ulMaxInputs || ulOutIndex || DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;
    }
    return hr;
} /* CDXBaseNTo1::MapBoundsOut2In */

/*****************************************************************************
* CDXBaseNTo1::SetMiscFlags *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30.97
*-----------------------------------------------------------------------------
*   Parameters:
*       bMiscFlags - New value to set 
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetMiscFlags( DWORD dwMiscFlags )
{ 
    DXTDBG_FUNC( "CDXBaseNTo1::SetMiscFlags" );
    HRESULT hr = S_OK;
    Lock();
    WORD wOpts = (WORD)dwMiscFlags;     // Ignore high word.  Only set low word.
    if (((WORD)m_dwMiscFlags) != wOpts)
    {
        if ((wOpts & (~DXTMF_VALID_OPTIONS)) ||
            ((wOpts & DXTMF_BLEND_WITH_OUTPUT) && (m_dwMiscFlags & DXTMF_BLEND_SUPPORTED) == 0) ||
            ((wOpts & DXTMF_DITHER_OUTPUT) && (m_dwMiscFlags & DXTMF_DITHER_SUPPORTED) == 0))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_dwMiscFlags &= 0xFFFF0000;
            m_dwMiscFlags |= wOpts;
            _UpdateBltFlags();
            m_dwGenerationId++;
        }
    }
    Unlock();  
    return hr;
} /* CDXBaseNTo1::SetMiscFlags */

/*****************************************************************************
* CDXBaseNTo1::GetMiscFlags *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetMiscFlags( DWORD* pdwMiscFlags )
{
    if( DXIsBadWritePtr( pdwMiscFlags, sizeof( *pdwMiscFlags ) ) )
    {
        return E_POINTER;
    }
    *pdwMiscFlags = m_dwMiscFlags;
    return S_OK;
} /* CDXBaseNTo1::GetMiscFlags */


/*****************************************************************************
* CDXBaseNTo1::SetQuality *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::SetQuality(float fQuality)
{
    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        return E_NOTIMPL;
    }

    if (fQuality < 0.0f || fQuality > 1.0f)
    {
        return E_INVALIDARG;
    }

    Lock();
    if (m_fQuality != fQuality)
    {
        m_fQuality = fQuality;
        m_dwGenerationId++;
    }
    Unlock();

    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::GetQuality *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                            Date: 10/30/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/

STDMETHODIMP CDXBaseNTo1::GetQuality(float *pfQuality)
{
    HRESULT hr = S_OK;

    if ((m_dwMiscFlags & DXTMF_QUALITY_SUPPORTED) == 0)
    {
        hr = E_NOTIMPL;
    }
    else 
    {
        if( DXIsBadWritePtr( pfQuality, sizeof( *pfQuality ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            *pfQuality = m_fQuality;
        }
    }
    return hr;
}



/*****************************************************************************
* GetInOutInfo
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags,
                                        GUID * pIDs, ULONG *pcIDs, IUnknown **ppUnkCurObj )
{
    DXTDBG_FUNC( "CDXBaseNTo1::GetInOutInfo" );
    HRESULT hr = S_FALSE;
    DWORD dwFlags = 0;
    BOOL bImage;
    if( bOutput )
    {
        bImage = !(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        if (ulIndex == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        bImage = !(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        if (ulIndex < m_ulMaxInputs)
        {
            hr = S_OK;
            if (ulIndex >= m_ulNumInRequired)
            {
                dwFlags = DXINOUTF_OPTIONAL;
            }
        }
    }
    if( hr == S_OK )
    {
        if( pdwFlags && !DXIsBadWritePtr( pdwFlags, sizeof( *pdwFlags ) ) )
        {
            *pdwFlags = dwFlags;
        }

        if( pIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) ||
                DXIsBadWritePtr( pIDs, *pcIDs * sizeof( *pIDs ) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if (bImage)
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXSurface;
                    }
                    if (*pcIDs > 1)
                    {
                        pIDs[1] = IID_IDXDupDDrawSurface;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 2;
                }
                else
                {
                    if (*pcIDs > 0)
                    {
                        pIDs[0] = IID_IDXDupDirect3DRMMeshBuilder3;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
                    }
                    *pcIDs = 1;
                }
            }
        }
        else if( pcIDs )
        {
            if( DXIsBadWritePtr( pcIDs, sizeof( *pcIDs ) ) )
            {
                hr = E_POINTER;
            }
            else
            {
                *pcIDs = bImage ? 2 : 1;
            }
        }
        if (hr == S_OK && ppUnkCurObj)
        {
            if (DXIsBadWritePtr(ppUnkCurObj, sizeof(*ppUnkCurObj)))
            {
                hr = E_POINTER;
            }
            else
            {
                if (bOutput)
                {
                    *ppUnkCurObj = m_Output.m_pNativeInterface;
                }
                else
                {
                    *ppUnkCurObj = NULL;
                    if (ulIndex < GetNumInputs())
                    {
                        *ppUnkCurObj = m_aInputs[ulIndex].m_pUnkOriginalObject;
                    }
                }
                if (*ppUnkCurObj)
                {
                    (*ppUnkCurObj)->AddRef();
                }
            }
        }
    }
    return hr;
} /* CDXBaseNTo1::GetInOutInfo */

/*****************************************************************************
* CDXBaseNTo1::OnUpdateGenerationId *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
void CDXBaseNTo1::OnUpdateGenerationId(void)
{
    DXTDBG_FUNC( "CDXBaseNTo1::OnUpdateGenerationId" );
    if( (m_dwMiscFlags & DXTMF_INPLACE_OPERATION) &&
        m_Output.UpdateGenerationId())
    {
        m_dwGenerationId++;
    }
    for (ULONG i = 0; i < m_ulNumInputs; i++)
    {
        if (m_aInputs[i].UpdateGenerationId())
        {
            m_dwGenerationId++;
        }
    }
} /* CDXBaseNTo1::OnUpdateGenerationId */

/*****************************************************************************
* CDXBaseNTo1::OnGetObjectSize *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
ULONG CDXBaseNTo1::OnGetObjectSize(void)
{
    return sizeof(*this);
}

//
//  Effect interface
//

/*****************************************************************************
* CDXBaseNTo1::get_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Progress(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Progress" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Progress;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::put_Progress *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Progress(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Progress" );
    HRESULT hr = S_OK;
    if (newVal < 0.0 || newVal > 1.0f)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        Lock();
        m_Progress = newVal;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_dwGenerationId++;     
        Unlock();
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_StepResolution *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_StepResolution(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_StepResolution" );
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_StepResolution;
    }
    return hr;
}

/*****************************************************************************
* CDXBaseNTo1::get_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::get_Duration(float *pVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::get_Duration" );
    if( DXIsBadWritePtr(pVal, sizeof(*pVal)) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_Duration;
    }
    return S_OK;
}

/*****************************************************************************
* CDXBaseNTo1::put_Duration *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::put_Duration(float newVal)
{
    DXTDBG_FUNC( "CDXBaseNTo1::put_Duration" );
    if (newVal <= 0.)
    {
        return E_INVALIDARG;
    }
    if(newVal != m_Duration)
    {
	Lock();
	m_dwGenerationId++;
        m_dwCleanGenId++;       // This should not make the transform "dirty" internally
        m_Duration = newVal;
    	Unlock();
    }
    return S_OK;
}


/*****************************************************************************
* CDXBaseNTo1::PointPick *
*------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 5/5/98
*****************************************************************************/
STDMETHODIMP CDXBaseNTo1::PointPick(const DXVEC *pPoint,
                                    ULONG * pulInputSurfaceIndex,
                                    DXVEC *pInputPoint)
{
    HRESULT hr          = S_OK;
    BOOL    bFoundIt    = FALSE;

    // If we haven't been set up yet, we will just act as if we're transparent.

    if (!m_fIsSetup)
    {
        hr = S_FALSE;

        goto done;
    }

    if (DXIsBadReadPtr(pPoint, sizeof(*pPoint)) || pPoint->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        if (DXIsBadWritePtr(pulInputSurfaceIndex, sizeof(*pulInputSurfaceIndex)) ||
            DXIsBadWritePtr(pInputPoint, sizeof(*pInputPoint)))
        {
            hr = E_POINTER;
        }
        else 
        {
            HRESULT     hr2         = S_OK;
            CDXDBnds    bndsOutput;
            CDXDBnds    OutBndsPoint(*((CDXDVec *)pPoint));
            CDXDVec &   InVec       = *(new(pInputPoint) CDXDVec(*((CDXDVec *)pPoint)));

            // Get the output size of the DXTransform.  If this point is not on
            // the output at all, we can return S_FALSE right now.

            hr = MapBoundsIn2Out(NULL, 0, 0, &bndsOutput);

            if (FAILED(hr))
            {
                goto done;
            }

            if (!bndsOutput.TestIntersect(OutBndsPoint))
            {
                hr = S_FALSE;

                goto done;
            }

            hr2 = OnSurfacePick(OutBndsPoint, *pulInputSurfaceIndex, InVec);

            if (hr2 != E_NOTIMPL)
            {
                hr = hr2;
            }
            else
            {
                //--- The derived class does not implement so we will do
                //    the hit test against the input for them.
                ULONG * aulInIndex = (ULONG *)_alloca(sizeof(ULONG) * m_ulMaxInputs);
                BYTE * aWeights = (BYTE *)_alloca(sizeof(BYTE) * m_ulMaxInputs);
                ULONG ulNumToTest;
                OnGetSurfacePickOrder(OutBndsPoint, ulNumToTest, aulInIndex, aWeights);

                if( m_bPickDoneByBase && ( m_ulNumInputs > 1 ) )
                {
                    //--- We don't know how to do multi-input picking from the base.
                    hr = E_NOTIMPL;
                }

                for (ULONG i = 0; SUCCEEDED(hr) && i < ulNumToTest; i++)
                {
                    ULONG ulInput = aulInIndex[i];
                    if (HaveInput(ulInput) && aWeights[i])
                    {
                        CDXDBnds Out2InBnds(false);
                        hr = MapBoundsOut2In(0, &OutBndsPoint, ulInput, &Out2InBnds);
                        if (SUCCEEDED(hr))
                        {
                            CDXDBnds InSurfBnds(InputSurface(ulInput), hr);
                            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
                            {
                                IDXARGBReadPtr * pPtr;
                                hr = InputSurface(ulInput)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                                if( SUCCEEDED(hr) )
                                {
                                    DXPMSAMPLE val;
                                    pPtr->UnpackPremult(&val, 1, FALSE);
                                    pPtr->Release();
                                    if (val.Alpha * aWeights[i] / 255)
                                    {
                                        InSurfBnds.GetMinVector(InVec);
                                        bFoundIt = TRUE;
                                        *pulInputSurfaceIndex = ulInput;
                                        break;
                                    }
                                }
                            }   
                        }
                    }
                }
                if (SUCCEEDED(hr) & (!bFoundIt))
                {
                    hr = S_FALSE;
                }
            }
        }
    }

done:

    return hr;
} /* CDXBaseNTo1::PointPick */

/*****************************************************************************
* RegisterTansform (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseNTo1::
RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                  ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    DXTDBG_FUNC( "CDXBaseNTo1::RegisterTransform" );
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = ::CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}


void CDXBaseNTo1::_TaskProc(void* pTaskInfo, BOOL* pbContinue )
{ 
    _ASSERT( pTaskInfo );
    CDXTWorkInfoNTo1& WI = *((CDXTWorkInfoNTo1 *)pTaskInfo);
    CDXBaseNTo1& This = *((CDXBaseNTo1 *)WI.pvThis);
    WI.hr = This.WorkProc(WI, pbContinue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dtbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DTBase.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseNTo1 implementation. It is
*   used as a base class to implement discrete transform objects that support
*   DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DTBase_h
#define DTBase_h

//--- Additional includes
#ifndef DXHelper_h
#include <DXHelper.h>
#endif

#ifndef DXTmpl_h
#include <DXTmpl.h>
#endif

#ifndef dxatlpb_h
#include <dxatlpb.h>
#endif

#ifndef _ASSERT
#include <crtdbg.h>
#endif

#ifndef DXTDbg_h
#include <DXTDbg.h>
#endif

//=== Constants ====================================================
#define DXBOF_INPUTS_MESHBUILDER    0x00000001
#define DXBOF_OUTPUT_MESHBUILDER    0x00000002
#define DXBOF_SAME_SIZE_INPUTS      0x00000004
#define DXBOF_CENTER_INPUTS         0x00000008

#define DXB_MAX_IMAGE_BANDS         4           // Maximum of 4 image bands

//=== Class, Enum, Struct and Union Declarations ===================
class CDXBaseNTo1;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXDataPtr
*
*/
class CDXDataPtr
{
    friend CDXBaseNTo1;
public:
    IUnknown           *m_pUnkOriginalObject;
    IUnknown           *m_pNativeInterface;
    IDXBaseObject      *m_pBaseObj;
    DWORD               m_dwLastDirtyGenId;
    DXSAMPLEFORMATENUM  m_SampleFormat;

    CDXDataPtr() : 
        m_pUnkOriginalObject(NULL),
        m_pNativeInterface(NULL), 
        m_pBaseObj(NULL),
        m_dwLastUpdGenId(0),
        m_dwLastDirtyGenId(0),
        m_SampleFormat(DXPF_NONSTANDARD)
        {};
    ~CDXDataPtr() { Release(); }
    void Release()
    {
        if (m_pNativeInterface)
        {
            m_pNativeInterface->Release();
            m_pNativeInterface = NULL;
        }
        if (m_pBaseObj)
        {
            m_pBaseObj->Release();
            m_pBaseObj = NULL;
        }
        if (m_pUnkOriginalObject)
        {
            m_pUnkOriginalObject->Release();
            m_pUnkOriginalObject = NULL;
        }
    }
    HRESULT Assign(BOOL bMeshBuilder, IUnknown * pObject, IDXSurfaceFactory *pSurfFact);
    bool IsDirty(void);
    DWORD GenerationId(void);
    ULONG ObjectSize(void);
private:    // This should only be called by base class
    DWORD           m_dwLastUpdGenId;
    bool UpdateGenerationId(void);
};

/*--- CDXTWorkInfoNTo1
*   This structure is used to hold the arguments needed by the
*   image processing function defined by the derived class
*/
class CDXTWorkInfoNTo1
{
public:
    CDXTWorkInfoNTo1()
    { pvThis = NULL; pUserInstData = NULL; hr = S_OK; }
    void *   pvThis;          // The owning class object (must be cast to the right type)
    CDXDBnds DoBnds;          // The portion of the output space to render
    CDXDBnds OutputBnds;      // The portion of the output SURFACE to render
    void*    pUserInstData;   // User field for instance data
    HRESULT  hr;              // Error return code from work procedure
};

/*** CDXBaseNTo1
*   This is a base class used for implementing 1 in 1 out discrete transforms.
*/
class ATL_NO_VTABLE CDXBaseNTo1 : 
    public CComObjectRootEx<CComMultiThreadModel>,
#if(_ATL_VER < 0x0300)
    public IObjectSafetyImpl<CDXBaseNTo1>,
#else
    public IObjectSafetyImpl<CDXBaseNTo1,INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
#endif
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CDXBaseNTo1)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IObjectWithSite)
#if(_ATL_VER < 0x0300)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
#else
        COM_INTERFACE_ENTRY(IObjectSafety)
#endif
        COM_INTERFACE_ENTRY_FUNC(IID_IDXSurfacePick, 0, QI2DPick)
    END_COM_MAP()

    //
    //  Only return the 2D pick inteface for surface to surface transforms
    //
    static HRESULT WINAPI QI2DPick(void* pv, REFIID riid, LPVOID* ppv, ULONG_PTR dw)
    {
        CDXBaseNTo1 * pThis = (CDXBaseNTo1 *)pv;
        if (pThis->m_dwOptionFlags & (DXBOF_INPUTS_MESHBUILDER | DXBOF_OUTPUT_MESHBUILDER))
        {
            return S_FALSE; // Continue processing COM map
        }
        *ppv = (IDXSurfacePick *)pThis;
        ((IDXSurfacePick *)pThis)->AddRef();
        return S_OK;
    }

    CComPtr<IOleClientSite> m_cpOleClientSite;

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>            m_cpUnkSite;
    CComPtr<IDXTransformFactory> m_cpTransFact;   
    CComPtr<IDXSurfaceFactory>   m_cpSurfFact;
    CComPtr<IDXTaskManager>      m_cpTaskMgr;
    CComPtr<IDirectDraw>         m_cpDirectDraw;
#ifndef IEMOBILE    
    CComPtr<IDirect3DRM3>        m_cpDirect3DRM;
#endif
    DWORD        m_dwMiscFlags;
    HANDLE       m_aEvent[DXB_MAX_IMAGE_BANDS];
    ULONG        m_ulNumProcessors;
    DWORD        m_dwGenerationId;
    DWORD        m_dwCleanGenId;
    BOOL         m_bPickDoneByBase;
    float        m_Duration;
    float        m_StepResolution;
    float        m_fQuality;        // Set DXTMF_QUALITY_SUPPORTED in m_dwMiscFlags if you use this property.    
    ULONG        m_ulNumInputs;
    DWORD        m_dwBltFlags;      // Ser prior to OnSetup and any Execute for classes with surface outputs
    BOOL         m_bInMultiThreadWorkProc;  // Base class sets to TRUE when scheduling tasks on multiple threads

    //
    //  Derived classes should set these values in their constructor or in FinalConstruct()
    //
    DWORD        m_dwOptionFlags;
    ULONG        m_ulLockTimeOut;     // The amount of time used for blocking
    ULONG        m_ulMaxInputs;
    ULONG        m_ulNumInRequired;
    ULONG        m_ulMaxImageBands;   // Only used for surface->Surface transforms
    float        m_Progress;

private:
    CDXDataPtr* m_aInputs;
    CDXDataPtr  m_Output;

    // m_fIsSetup   This is true when the DXTransform has been properly set up.

    unsigned    m_fIsSetup : 1;

  /*=== Methods =======*/
  public:
    //--- Constructors
    CDXBaseNTo1();
    ~CDXBaseNTo1();

    //--- Support virtuals for derived classes
    virtual HRESULT OnInitInstData( CDXTWorkInfoNTo1& /*WorkInfo*/, ULONG& /*ulNumBandsToDo*/) { return S_OK; }
    virtual HRESULT OnFreeInstData( CDXTWorkInfoNTo1& /*WorkInfo*/ ) { return S_OK; }
    virtual HRESULT OnSetup( DWORD /* dwFlags */) { return S_OK; }    // Override to be notified of a new non-null setup
    virtual void OnReleaseObjects() {}  // Override to be notified of NULL setup
    virtual HRESULT OnExecute(const GUID* /* pRequestID */, const DXBNDS * /*pClipBnds */,
                              const DXVEC * /*pPlacement */ ) { return E_FAIL; }
    virtual void OnUpdateGenerationId(void);
    virtual ULONG OnGetObjectSize(void);
    virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, BOOL* pbContinueProcessing) { return E_FAIL; }   // Override to do work
    virtual HRESULT DetermineBnds(CDXCBnds & Bnds) { return S_OK; } // Override for mesh output transforms
    virtual HRESULT DetermineBnds(CDXDBnds & Bnds) { return S_OK; } // Override for surface output transforms
    //
    //  Only override this function if you need to do a customized point pick implementation.  Otherwise simply
    //  override GetPointPickOrder() and return appropriate information.
    //
    virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec) { return E_NOTIMPL; }
    virtual void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, ULONG aInIndex[], BYTE aWeight[])
    {
        m_bPickDoneByBase = true;
        ulInToTest  = 1;
        aInIndex[0] = 0;
        aWeight[0]  = 255;
    }

    //--- Private helpers
 private:
    static DXTASKPROC _TaskProc;
    void _ReleaseReferences();
    void _ReleaseServices();
    void _UpdateBltFlags(void);
    HRESULT _MakeInputsSameSize(void);
    HRESULT _ImageMapIn2Out(CDXDBnds & bnds, ULONG ulNumBnds, const CDXDBnds * pInBounds);
    HRESULT _MeshMapIn2Out(CDXCBnds & bnds, ULONG ulNumInBnds, CDXCBnds * pInBounds);


    //
    //--- Public helpers
    //
 public:
    float GetEffectProgress(void) { return m_Progress; }
    ULONG GetNumInputs(void) { return m_ulNumInputs; }

    //
    //  Use these inline functions to access input and output objects
    //
    BOOL HaveInput(ULONG i = 0) { return (m_ulNumInputs > i && m_aInputs[i].m_pNativeInterface); }

#ifndef IEMOBILE
    IDirect3DRMMeshBuilder3 * OutputMeshBuilder()
    {
        _ASSERT(m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_Output.m_pNativeInterface;
    }
#endif // #ifndef IEMOBILE

    IDXSurface * OutputSurface()
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return (IDXSurface *)m_Output.m_pNativeInterface;
    }

#ifndef IEMOBILE
    IDirect3DRMMeshBuilder3 * InputMeshBuilder(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT(m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER);
        return (IDirect3DRMMeshBuilder3 *)m_aInputs[i].m_pNativeInterface;
    }
#endif // #ifndef IEMOBILE


    IDXSurface * InputSurface(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return (IDXSurface *)m_aInputs[i].m_pNativeInterface;
    }

    DXSAMPLEFORMATENUM OutputSampleFormat(void)
    {
        _ASSERT((m_dwOptionFlags & DXBOF_OUTPUT_MESHBUILDER) == 0);
        return m_Output.m_SampleFormat;
    }

    DXSAMPLEFORMATENUM InputSampleFormat(ULONG i = 0)
    {
        _ASSERT(i < m_ulNumInputs);
        _ASSERT((m_dwOptionFlags & DXBOF_INPUTS_MESHBUILDER) == 0);
        return m_aInputs[i].m_SampleFormat;
    }

    BOOL HaveOutput(void) { return m_Output.m_pNativeInterface != NULL; }

    bool IsInputDirty(ULONG i = 0)
    {   
        _ASSERT(i < m_ulNumInputs);
        return m_aInputs[i].IsDirty();
    }

    bool IsOutputDirty()
    {   
        _ASSERT(HaveOutput());
        return m_Output.IsDirty();
    }

    //--- Public helpers.  Should be called with critical seciton claimed.
    inline BOOL DoOver(void) const
    { 
        return m_dwBltFlags & DXBOF_DO_OVER;
    }

    inline BOOL DoDither(void) const
    {
        return m_dwBltFlags & DXBOF_DITHER;
    }

    BOOL NeedSrcPMBuff(ULONG i = 0)
    {
        return ((m_dwBltFlags & DXBOF_DITHER) || InputSampleFormat(i) != DXPF_PMARGB32);
    }

    BOOL NeedDestPMBuff(void)
    {
        return OutputSampleFormat() != DXPF_PMARGB32;
    }

    void SetDirty() { m_dwGenerationId++; }
    void ClearDirty() { OnUpdateGenerationId(); m_dwCleanGenId = m_dwGenerationId; }
    BOOL IsTransformDirty() { OnUpdateGenerationId(); return m_dwCleanGenId != m_dwGenerationId; }

    
  public:
    //=== IObjectWithSite =======================================
    STDMETHOD( SetSite )( IUnknown *pUnkSite );
    STDMETHOD( GetSite )( REFIID riid, void ** ppvSite );

    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

  
      //=== IDXTransform ===============================================
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn,
                        IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID,
                          const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                  ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    STDMETHOD (PointPick) (const DXVEC *pPoint,
                           ULONG * pulInputSurfaceIndex,
                           DXVEC *pInputPoint);

    //
    //  Effect interface
    //
    //  NOTE:  Derived classes MUST implement get_Capabilities.  Use macros below.
    //
    STDMETHODIMP get_Capabilities(long *pVal) { _ASSERT(true); return E_NOTIMPL; }
    //
    //  All other methods are implemented in the base.
    //
    STDMETHODIMP get_Progress(float *pVal);
    STDMETHODIMP put_Progress(float newVal);
    STDMETHODIMP get_StepResolution(float *pVal);
    STDMETHODIMP get_Duration(float *pVal);
    STDMETHODIMP put_Duration(float newVal);

    //
    //  Helper functions derived classes can use
    //

    //
    //  Static function for registering in one or more component categories
    //
    static HRESULT RegisterTransform(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                     ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);

};

//=== Inline Function Definitions ==================================

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_TRANSFORM(id, catid)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 1, &(catid), 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_TRANS_CATS(id, countimpl, pcatidsimpl, countreq, pcatidsreq)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), (count), (pcatids), (countreq), (pcatidsreq), bRegister); \
        } 

#define DECLARE_REGISTER_DX_IMAGE_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DXImageTransform)

#define DECLARE_REGISTER_DX_3D_TRANS(id) \
    DECLARE_REGISTER_DX_TRANSFORM(id, CATID_DX3DTransform)

#define DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DXImageTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_3D_AUTHOR_TRANS(id) \
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            GUID a_Cats[2]; \
            a_Cats[0] = CATID_DX3DTransform; \
            a_Cats[1] = CATID_DXAuthoringTransform; \
            return CDXBaseNTo1::RegisterTransform(GetObjectCLSID(), (id), 2, a_Cats, 0, NULL, bRegister); \
        } 

//
//  Effect interface
//
#define DECLARE_GET_CAPABILITIES(Caps)\
STDMETHODIMP get_Capabilities(long *pVal) { if (DXIsBadWritePtr(pVal, sizeof(*pVal))) return E_POINTER; *pVal = Caps; return S_OK; }

#define DECLARE_GET_PROGRESS()\
        STDMETHODIMP get_Progress(float *pVal) { return CDXBaseNTo1::get_Progress(pVal); }

#define DECLARE_PUT_PROGRESS()\
        STDMETHODIMP put_Progress(float newVal) { return CDXBaseNTo1::put_Progress(newVal); }

#define DECLARE_GET_STEPRESOLUTION()\
        STDMETHODIMP get_StepResolution(float *pVal) { return CDXBaseNTo1::get_StepResolution(pVal); }
        
#define DECLARE_GET_DURATION()\
        STDMETHODIMP get_Duration(float *pVal) { return CDXBaseNTo1::get_Duration(pVal); }

#define DECLARE_PUT_DURATION()\
        STDMETHODIMP put_Duration(float newVal) { return CDXBaseNTo1::put_Duration(newVal); }
        
#define DECLARE_IDXEFFECT_METHODS(Caps)\
        DECLARE_GET_CAPABILITIES(Caps)\
        DECLARE_GET_PROGRESS()\
        DECLARE_PUT_PROGRESS()\
        DECLARE_GET_STEPRESOLUTION()\
        DECLARE_GET_DURATION()\
        DECLARE_PUT_DURATION()

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvdata.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for dvdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dvdata_h__
#define __dvdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDVDROM_FWD_DEFINED__
#define __IDVDROM_FWD_DEFINED__
typedef interface IDVDROM IDVDROM;
#endif 	/* __IDVDROM_FWD_DEFINED__ */


#ifndef __IDVDParentalManagementTable_FWD_DEFINED__
#define __IDVDParentalManagementTable_FWD_DEFINED__
typedef interface IDVDParentalManagementTable IDVDParentalManagementTable;
#endif 	/* __IDVDParentalManagementTable_FWD_DEFINED__ */


#ifndef __IDVDTextManager_FWD_DEFINED__
#define __IDVDTextManager_FWD_DEFINED__
typedef interface IDVDTextManager IDVDTextManager;
#endif 	/* __IDVDTextManager_FWD_DEFINED__ */


#ifndef __IDVDStreamAttributes_FWD_DEFINED__
#define __IDVDStreamAttributes_FWD_DEFINED__
typedef interface IDVDStreamAttributes IDVDStreamAttributes;
#endif 	/* __IDVDStreamAttributes_FWD_DEFINED__ */


#ifndef __IDVDDomain_FWD_DEFINED__
#define __IDVDDomain_FWD_DEFINED__
typedef interface IDVDDomain IDVDDomain;
#endif 	/* __IDVDDomain_FWD_DEFINED__ */


#ifndef __IDVDMenu_FWD_DEFINED__
#define __IDVDMenu_FWD_DEFINED__
typedef interface IDVDMenu IDVDMenu;
#endif 	/* __IDVDMenu_FWD_DEFINED__ */


#ifndef __IEnumDVD_CELL_PIECE_FWD_DEFINED__
#define __IEnumDVD_CELL_PIECE_FWD_DEFINED__
typedef interface IEnumDVD_CELL_PIECE IEnumDVD_CELL_PIECE;
#endif 	/* __IEnumDVD_CELL_PIECE_FWD_DEFINED__ */


#ifndef __IEnumDVD_TEXT_LANGUAGE_UNIT_FWD_DEFINED__
#define __IEnumDVD_TEXT_LANGUAGE_UNIT_FWD_DEFINED__
typedef interface IEnumDVD_TEXT_LANGUAGE_UNIT IEnumDVD_TEXT_LANGUAGE_UNIT;
#endif 	/* __IEnumDVD_TEXT_LANGUAGE_UNIT_FWD_DEFINED__ */


#ifndef __IEnumDVD_TEXT_ITEM_FWD_DEFINED__
#define __IEnumDVD_TEXT_ITEM_FWD_DEFINED__
typedef interface IEnumDVD_TEXT_ITEM IEnumDVD_TEXT_ITEM;
#endif 	/* __IEnumDVD_TEXT_ITEM_FWD_DEFINED__ */


#ifndef __IDVDTitleSet_FWD_DEFINED__
#define __IDVDTitleSet_FWD_DEFINED__
typedef interface IDVDTitleSet IDVDTitleSet;
#endif 	/* __IDVDTitleSet_FWD_DEFINED__ */


#ifndef __IDVDProgramChain_FWD_DEFINED__
#define __IDVDProgramChain_FWD_DEFINED__
typedef interface IDVDProgramChain IDVDProgramChain;
#endif 	/* __IDVDProgramChain_FWD_DEFINED__ */


#ifndef __IDVDTimeMap_FWD_DEFINED__
#define __IDVDTimeMap_FWD_DEFINED__
typedef interface IDVDTimeMap IDVDTimeMap;
#endif 	/* __IDVDTimeMap_FWD_DEFINED__ */


#ifndef __IDVDVideoVolume_FWD_DEFINED__
#define __IDVDVideoVolume_FWD_DEFINED__
typedef interface IDVDVideoVolume IDVDVideoVolume;
#endif 	/* __IDVDVideoVolume_FWD_DEFINED__ */


#ifndef __IDVDDataSearchInfo_FWD_DEFINED__
#define __IDVDDataSearchInfo_FWD_DEFINED__
typedef interface IDVDDataSearchInfo IDVDDataSearchInfo;
#endif 	/* __IDVDDataSearchInfo_FWD_DEFINED__ */


#ifndef __IDVDHighlightInfo_FWD_DEFINED__
#define __IDVDHighlightInfo_FWD_DEFINED__
typedef interface IDVDHighlightInfo IDVDHighlightInfo;
#endif 	/* __IDVDHighlightInfo_FWD_DEFINED__ */


#ifndef __IDVDStreamControlInfo_FWD_DEFINED__
#define __IDVDStreamControlInfo_FWD_DEFINED__
typedef interface IDVDStreamControlInfo IDVDStreamControlInfo;
#endif 	/* __IDVDStreamControlInfo_FWD_DEFINED__ */


#ifndef __IDVDNavDataStatusSink_FWD_DEFINED__
#define __IDVDNavDataStatusSink_FWD_DEFINED__
typedef interface IDVDNavDataStatusSink IDVDNavDataStatusSink;
#endif 	/* __IDVDNavDataStatusSink_FWD_DEFINED__ */


#ifndef __DVDData_FWD_DEFINED__
#define __DVDData_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVDData DVDData;
#else
typedef struct DVDData DVDData;
#endif /* __cplusplus */

#endif 	/* __DVDData_FWD_DEFINED__ */


#ifndef __DVDStreamControlInfo_FWD_DEFINED__
#define __DVDStreamControlInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVDStreamControlInfo DVDStreamControlInfo;
#else
typedef struct DVDStreamControlInfo DVDStreamControlInfo;
#endif /* __cplusplus */

#endif 	/* __DVDStreamControlInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "dvdcom.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dvdata_0000_0000 */
/* [local] */ 

typedef /* [string] */ WCHAR UNICODE_PATH[ 128 ];



extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0000_v0_0_s_ifspec;

#ifndef __IDVDROM_INTERFACE_DEFINED__
#define __IDVDROM_INTERFACE_DEFINED__

/* interface IDVDROM */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDROM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5072-9F3D-11D0-A979-00A0C9050598")
    IDVDROM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Bind( 
            UNICODE_PATH path) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unbind( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVMGI( 
            /* [out][ref] */ UINT32 *length,
            /* [out][ref][full] */ UINT8 **bufPtr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVTSI( 
            UINT16 zbVTSN,
            UINT32 *length,
            UINT8 **bufPtr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseMem( 
            /* [full][in][ref] */ UINT8 *bufPtr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenVOB( 
            UINT16 *hVOB,
            INT16 obVTSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVOB( 
            UINT16 hVOB,
            UINT8 *buf,
            UINT32 startBlock,
            UINT32 endBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseVOB( 
            UINT16 hVOB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDROMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDROM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDROM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDROM * This);
        
        HRESULT ( STDMETHODCALLTYPE *Bind )( 
            IDVDROM * This,
            UNICODE_PATH path);
        
        HRESULT ( STDMETHODCALLTYPE *Unbind )( 
            IDVDROM * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVMGI )( 
            IDVDROM * This,
            /* [out][ref] */ UINT32 *length,
            /* [out][ref][full] */ UINT8 **bufPtr);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVTSI )( 
            IDVDROM * This,
            UINT16 zbVTSN,
            UINT32 *length,
            UINT8 **bufPtr);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseMem )( 
            IDVDROM * This,
            /* [full][in][ref] */ UINT8 *bufPtr);
        
        HRESULT ( STDMETHODCALLTYPE *OpenVOB )( 
            IDVDROM * This,
            UINT16 *hVOB,
            INT16 obVTSN);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVOB )( 
            IDVDROM * This,
            UINT16 hVOB,
            UINT8 *buf,
            UINT32 startBlock,
            UINT32 endBlock);
        
        HRESULT ( STDMETHODCALLTYPE *CloseVOB )( 
            IDVDROM * This,
            UINT16 hVOB);
        
        END_INTERFACE
    } IDVDROMVtbl;

    interface IDVDROM
    {
        CONST_VTBL struct IDVDROMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDROM_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDROM_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDROM_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDROM_Bind(This,path)	\
    ( (This)->lpVtbl -> Bind(This,path) ) 

#define IDVDROM_Unbind(This)	\
    ( (This)->lpVtbl -> Unbind(This) ) 

#define IDVDROM_ReadVMGI(This,length,bufPtr)	\
    ( (This)->lpVtbl -> ReadVMGI(This,length,bufPtr) ) 

#define IDVDROM_ReadVTSI(This,zbVTSN,length,bufPtr)	\
    ( (This)->lpVtbl -> ReadVTSI(This,zbVTSN,length,bufPtr) ) 

#define IDVDROM_ReleaseMem(This,bufPtr)	\
    ( (This)->lpVtbl -> ReleaseMem(This,bufPtr) ) 

#define IDVDROM_OpenVOB(This,hVOB,obVTSN)	\
    ( (This)->lpVtbl -> OpenVOB(This,hVOB,obVTSN) ) 

#define IDVDROM_ReadVOB(This,hVOB,buf,startBlock,endBlock)	\
    ( (This)->lpVtbl -> ReadVOB(This,hVOB,buf,startBlock,endBlock) ) 

#define IDVDROM_CloseVOB(This,hVOB)	\
    ( (This)->lpVtbl -> CloseVOB(This,hVOB) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDROM_INTERFACE_DEFINED__ */


#ifndef __IDVDParentalManagementTable_INTERFACE_DEFINED__
#define __IDVDParentalManagementTable_INTERFACE_DEFINED__

/* interface IDVDParentalManagementTable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDParentalManagementTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5074-9F3D-11D0-A979-00A0C9050598")
    IDVDParentalManagementTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConvertParentalLevelToID( 
            /* [in] */ UINT8 level,
            /* [in] */ UINT16 countryCode,
            /* [in] */ UINT16 vtsn,
            /* [ref][out] */ UINT16 *parentalID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDParentalManagementTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDParentalManagementTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDParentalManagementTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDParentalManagementTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertParentalLevelToID )( 
            IDVDParentalManagementTable * This,
            /* [in] */ UINT8 level,
            /* [in] */ UINT16 countryCode,
            /* [in] */ UINT16 vtsn,
            /* [ref][out] */ UINT16 *parentalID);
        
        END_INTERFACE
    } IDVDParentalManagementTableVtbl;

    interface IDVDParentalManagementTable
    {
        CONST_VTBL struct IDVDParentalManagementTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDParentalManagementTable_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDParentalManagementTable_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDParentalManagementTable_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDParentalManagementTable_ConvertParentalLevelToID(This,level,countryCode,vtsn,parentalID)	\
    ( (This)->lpVtbl -> ConvertParentalLevelToID(This,level,countryCode,vtsn,parentalID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDParentalManagementTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvdata_0000_0002 */
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0002_v0_0_s_ifspec;

#ifndef __IDVDTextManager_INTERFACE_DEFINED__
#define __IDVDTextManager_INTERFACE_DEFINED__

/* interface IDVDTextManager */
/* [unique][helpstring][uuid][object] */ 

typedef struct _structDVD_TEXT_LANGUAGE_UNIT
    {
    UINT16 tdlc;
    UINT8 charset;
    } 	DVD_TEXT_LANGUAGE_UNIT;

typedef struct _structDVD_TEXT_LANGUAGE_UNIT *PDVD_TEXT_LANGUAGE_UNIT;

typedef struct _structDVD_TEXT_ITEM
    {
    UINT8 *pTextData;
    UINT8 itemCode;
    } 	DVD_TEXT_ITEM;

typedef struct _structDVD_TEXT_ITEM *PDVD_TEXT_ITEM;


EXTERN_C const IID IID_IDVDTextManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5077-9F3D-11D0-A979-00A0C9050598")
    IDVDTextManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumerateTextLanguageUnits( 
            /* [ref][out] */ IEnumDVD_TEXT_LANGUAGE_UNIT **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextItemsCount( 
            /* [ref][in] */ DVD_TEXT_LANGUAGE_UNIT *pTLU,
            /* [in] */ UINT8 title,
            /* [ref][out] */ UINT16 *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateTitleTextItems( 
            /* [ref][in] */ DVD_TEXT_LANGUAGE_UNIT *pTLU,
            /* [in] */ UINT8 title,
            /* [ref][out] */ IEnumDVD_TEXT_ITEM **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDTextManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDTextManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDTextManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDTextManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTextLanguageUnits )( 
            IDVDTextManager * This,
            /* [ref][out] */ IEnumDVD_TEXT_LANGUAGE_UNIT **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextItemsCount )( 
            IDVDTextManager * This,
            /* [ref][in] */ DVD_TEXT_LANGUAGE_UNIT *pTLU,
            /* [in] */ UINT8 title,
            /* [ref][out] */ UINT16 *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTitleTextItems )( 
            IDVDTextManager * This,
            /* [ref][in] */ DVD_TEXT_LANGUAGE_UNIT *pTLU,
            /* [in] */ UINT8 title,
            /* [ref][out] */ IEnumDVD_TEXT_ITEM **ppEnum);
        
        END_INTERFACE
    } IDVDTextManagerVtbl;

    interface IDVDTextManager
    {
        CONST_VTBL struct IDVDTextManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDTextManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDTextManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDTextManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDTextManager_EnumerateTextLanguageUnits(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateTextLanguageUnits(This,ppEnum) ) 

#define IDVDTextManager_GetTextItemsCount(This,pTLU,title,pCount)	\
    ( (This)->lpVtbl -> GetTextItemsCount(This,pTLU,title,pCount) ) 

#define IDVDTextManager_EnumerateTitleTextItems(This,pTLU,title,ppEnum)	\
    ( (This)->lpVtbl -> EnumerateTitleTextItems(This,pTLU,title,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDTextManager_INTERFACE_DEFINED__ */


#ifndef __IDVDStreamAttributes_INTERFACE_DEFINED__
#define __IDVDStreamAttributes_INTERFACE_DEFINED__

/* interface IDVDStreamAttributes */
/* [unique][helpstring][uuid][object] */ 

typedef struct _structDVD_AUDIO_STREAM_ATTR
    {
    UINT16 attr;
    UINT16 reserved[ 3 ];
    } 	DVD_AUDIO_STREAM_ATTR;

typedef struct _structDVD_AUDIO_STREAM_ATTR *PDVD_AUDIO_STREAM_ATTR;

typedef struct _structDVD_AUDIO_MU_ATTR
    {
    UINT8 atr1[ 8 ];
    struct 
        {
        UINT8 alpha;
        UINT8 beta;
        } 	atr2[ 8 ];
    } 	DVD_AUDIO_MU_ATTR;

typedef struct _structDVD_AUDIO_MU_ATTR *PDVD_AUDIO_MU_ATTR;

typedef struct _structDVD_SUBPICTURE_STREAM_ATTR
    {
    UINT16 modetype;
    UINT16 specificCode;
    UINT16 extension;
    } 	DVD_SUBPICTURE_STREAM_ATTR;

typedef struct _structDVD_SUBPICTURE_STREAM_ATTR *PDVD_SUBPICTURE_STREAM_ATTR;


EXTERN_C const IID IID_IDVDStreamAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5078-9F3D-11D0-A979-00A0C9050598")
    IDVDStreamAttributes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVideoAttr( 
            /* [ref][out] */ UINT16 *pVideoAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioCount( 
            /* [ref][out] */ UINT8 *pStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioAttr( 
            /* [in] */ UINT nStreamNo,
            /* [ref][out] */ DVD_AUDIO_STREAM_ATTR *pAudioAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioMultichannelUseAttr( 
            /* [in] */ UINT8 nStreamNo,
            /* [ref][out] */ DVD_AUDIO_MU_ATTR *pMuse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureCount( 
            /* [ref][out] */ UINT8 *pStreamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureAttr( 
            /* [in] */ UINT8 nStreamNo,
            /* [ref][out] */ DVD_SUBPICTURE_STREAM_ATTR *pSPAttr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDStreamAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDStreamAttributes * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDStreamAttributes * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDStreamAttributes * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoAttr )( 
            IDVDStreamAttributes * This,
            /* [ref][out] */ UINT16 *pVideoAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioCount )( 
            IDVDStreamAttributes * This,
            /* [ref][out] */ UINT8 *pStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioAttr )( 
            IDVDStreamAttributes * This,
            /* [in] */ UINT nStreamNo,
            /* [ref][out] */ DVD_AUDIO_STREAM_ATTR *pAudioAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioMultichannelUseAttr )( 
            IDVDStreamAttributes * This,
            /* [in] */ UINT8 nStreamNo,
            /* [ref][out] */ DVD_AUDIO_MU_ATTR *pMuse);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureCount )( 
            IDVDStreamAttributes * This,
            /* [ref][out] */ UINT8 *pStreamCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureAttr )( 
            IDVDStreamAttributes * This,
            /* [in] */ UINT8 nStreamNo,
            /* [ref][out] */ DVD_SUBPICTURE_STREAM_ATTR *pSPAttr);
        
        END_INTERFACE
    } IDVDStreamAttributesVtbl;

    interface IDVDStreamAttributes
    {
        CONST_VTBL struct IDVDStreamAttributesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDStreamAttributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDStreamAttributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDStreamAttributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDStreamAttributes_GetVideoAttr(This,pVideoAttr)	\
    ( (This)->lpVtbl -> GetVideoAttr(This,pVideoAttr) ) 

#define IDVDStreamAttributes_GetAudioCount(This,pStreamCount)	\
    ( (This)->lpVtbl -> GetAudioCount(This,pStreamCount) ) 

#define IDVDStreamAttributes_GetAudioAttr(This,nStreamNo,pAudioAttr)	\
    ( (This)->lpVtbl -> GetAudioAttr(This,nStreamNo,pAudioAttr) ) 

#define IDVDStreamAttributes_GetAudioMultichannelUseAttr(This,nStreamNo,pMuse)	\
    ( (This)->lpVtbl -> GetAudioMultichannelUseAttr(This,nStreamNo,pMuse) ) 

#define IDVDStreamAttributes_GetSubpictureCount(This,pStreamCount)	\
    ( (This)->lpVtbl -> GetSubpictureCount(This,pStreamCount) ) 

#define IDVDStreamAttributes_GetSubpictureAttr(This,nStreamNo,pSPAttr)	\
    ( (This)->lpVtbl -> GetSubpictureAttr(This,nStreamNo,pSPAttr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDStreamAttributes_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvdata_0000_0004 */
/* [local] */ 

#define	DVD_SYSTEM_SPACE_BIT	1
#define	DVD_MENU_SPACE_BIT		(DVD_SYSTEM_SPACE_BIT << 1)
#define	DVD_VMG_SPACE_BIT		(DVD_MENU_SPACE_BIT << 1)
#define	DVD_VTS_SPACE_BIT		(DVD_VMG_SPACE_BIT << 1)







extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0004_v0_0_s_ifspec;

#ifndef __IDVDDomain_INTERFACE_DEFINED__
#define __IDVDDomain_INTERFACE_DEFINED__

/* interface IDVDDomain */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][public] */ 
enum __MIDL_IDVDDomain_0001
    {	DVD_FP_DOM	= 0,
	DVD_VMGM_DOM	= ( DVD_FP_DOM + 1 ) ,
	DVD_VTSM_DOM	= ( DVD_VMGM_DOM + 1 ) ,
	DVD_TT_DOM	= ( DVD_VTSM_DOM + 1 ) 
    } 	EDVDDomainType;


EXTERN_C const IID IID_IDVDDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5079-9F3D-11D0-A979-00A0C9050598")
    IDVDDomain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [ref][out] */ EDVDDomainType *pDType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpace( 
            /* [ref][out] */ UINT8 *pSpaceSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamAttributes( 
            /* [ref][out] */ IDVDStreamAttributes **ppAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPGCCount( 
            /* [ref][out] */ UINT16 *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPGC( 
            /* [in] */ UINT16 pgcn,
            /* [ref][out] */ IDVDProgramChain **ppPGC,
            /* [ref][out] */ UINT32 *pPGCCat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalVideoObjects( 
            /* [ref][out] */ UINT16 *pTotalVobs,
            /* [ref][out] */ UINT32 *pCellPieceCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellPieceEnumerator( 
            /* [ref][out] */ IEnumDVD_CELL_PIECE **ppEnumPieces,
            /* [ref][out] */ UINT32 *pPieceCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalVOBUnits( 
            /* [ref][out] */ UINT32 *pVobus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVOBUTablePtr( 
            /* [ref][out] */ UINT32 **ppVOBUAddressArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimeMap( 
            /* [in] */ UINT16 pgcn,
            /* [ref][out] */ IDVDTimeMap **ppTimeMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVOBFileId( 
            INT16 *pFileId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolume( 
            IDVDVideoVolume **ppVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleSet( 
            IDVDTitleSet **ppTitleSet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IDVDDomain * This,
            /* [ref][out] */ EDVDDomainType *pDType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpace )( 
            IDVDDomain * This,
            /* [ref][out] */ UINT8 *pSpaceSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamAttributes )( 
            IDVDDomain * This,
            /* [ref][out] */ IDVDStreamAttributes **ppAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetPGCCount )( 
            IDVDDomain * This,
            /* [ref][out] */ UINT16 *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetPGC )( 
            IDVDDomain * This,
            /* [in] */ UINT16 pgcn,
            /* [ref][out] */ IDVDProgramChain **ppPGC,
            /* [ref][out] */ UINT32 *pPGCCat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalVideoObjects )( 
            IDVDDomain * This,
            /* [ref][out] */ UINT16 *pTotalVobs,
            /* [ref][out] */ UINT32 *pCellPieceCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCellPieceEnumerator )( 
            IDVDDomain * This,
            /* [ref][out] */ IEnumDVD_CELL_PIECE **ppEnumPieces,
            /* [ref][out] */ UINT32 *pPieceCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalVOBUnits )( 
            IDVDDomain * This,
            /* [ref][out] */ UINT32 *pVobus);
        
        HRESULT ( STDMETHODCALLTYPE *GetVOBUTablePtr )( 
            IDVDDomain * This,
            /* [ref][out] */ UINT32 **ppVOBUAddressArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeMap )( 
            IDVDDomain * This,
            /* [in] */ UINT16 pgcn,
            /* [ref][out] */ IDVDTimeMap **ppTimeMap);
        
        HRESULT ( STDMETHODCALLTYPE *GetVOBFileId )( 
            IDVDDomain * This,
            INT16 *pFileId);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            IDVDDomain * This,
            IDVDVideoVolume **ppVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleSet )( 
            IDVDDomain * This,
            IDVDTitleSet **ppTitleSet);
        
        END_INTERFACE
    } IDVDDomainVtbl;

    interface IDVDDomain
    {
        CONST_VTBL struct IDVDDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDDomain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDDomain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDDomain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDDomain_GetType(This,pDType)	\
    ( (This)->lpVtbl -> GetType(This,pDType) ) 

#define IDVDDomain_GetSpace(This,pSpaceSet)	\
    ( (This)->lpVtbl -> GetSpace(This,pSpaceSet) ) 

#define IDVDDomain_GetStreamAttributes(This,ppAttr)	\
    ( (This)->lpVtbl -> GetStreamAttributes(This,ppAttr) ) 

#define IDVDDomain_GetPGCCount(This,pCount)	\
    ( (This)->lpVtbl -> GetPGCCount(This,pCount) ) 

#define IDVDDomain_GetPGC(This,pgcn,ppPGC,pPGCCat)	\
    ( (This)->lpVtbl -> GetPGC(This,pgcn,ppPGC,pPGCCat) ) 

#define IDVDDomain_GetTotalVideoObjects(This,pTotalVobs,pCellPieceCount)	\
    ( (This)->lpVtbl -> GetTotalVideoObjects(This,pTotalVobs,pCellPieceCount) ) 

#define IDVDDomain_GetCellPieceEnumerator(This,ppEnumPieces,pPieceCount)	\
    ( (This)->lpVtbl -> GetCellPieceEnumerator(This,ppEnumPieces,pPieceCount) ) 

#define IDVDDomain_GetTotalVOBUnits(This,pVobus)	\
    ( (This)->lpVtbl -> GetTotalVOBUnits(This,pVobus) ) 

#define IDVDDomain_GetVOBUTablePtr(This,ppVOBUAddressArray)	\
    ( (This)->lpVtbl -> GetVOBUTablePtr(This,ppVOBUAddressArray) ) 

#define IDVDDomain_GetTimeMap(This,pgcn,ppTimeMap)	\
    ( (This)->lpVtbl -> GetTimeMap(This,pgcn,ppTimeMap) ) 

#define IDVDDomain_GetVOBFileId(This,pFileId)	\
    ( (This)->lpVtbl -> GetVOBFileId(This,pFileId) ) 

#define IDVDDomain_GetVolume(This,ppVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,ppVolume) ) 

#define IDVDDomain_GetTitleSet(This,ppTitleSet)	\
    ( (This)->lpVtbl -> GetTitleSet(This,ppTitleSet) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDDomain_INTERFACE_DEFINED__ */


#ifndef __IDVDMenu_INTERFACE_DEFINED__
#define __IDVDMenu_INTERFACE_DEFINED__

/* interface IDVDMenu */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507A-9F3D-11D0-A979-00A0C9050598")
    IDVDMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [in] */ UINT16 languageCode,
            /* [ref][out] */ IDVDDomain **ppDomain,
            /* [ref][out] */ UINT8 *pExistFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuLanguageInfo( 
            /* [ref][out][in] */ UINT16 *pLangCount,
            /* [full] */ UINT16 *pLCBuffer,
            /* [full] */ UINT8 *pFlagsBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IDVDMenu * This,
            /* [in] */ UINT16 languageCode,
            /* [ref][out] */ IDVDDomain **ppDomain,
            /* [ref][out] */ UINT8 *pExistFlag);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuLanguageInfo )( 
            IDVDMenu * This,
            /* [ref][out][in] */ UINT16 *pLangCount,
            /* [full] */ UINT16 *pLCBuffer,
            /* [full] */ UINT8 *pFlagsBuffer);
        
        END_INTERFACE
    } IDVDMenuVtbl;

    interface IDVDMenu
    {
        CONST_VTBL struct IDVDMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDMenu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDMenu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDMenu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDMenu_GetDomain(This,languageCode,ppDomain,pExistFlag)	\
    ( (This)->lpVtbl -> GetDomain(This,languageCode,ppDomain,pExistFlag) ) 

#define IDVDMenu_GetMenuLanguageInfo(This,pLangCount,pLCBuffer,pFlagsBuffer)	\
    ( (This)->lpVtbl -> GetMenuLanguageInfo(This,pLangCount,pLCBuffer,pFlagsBuffer) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDMenu_INTERFACE_DEFINED__ */


#ifndef __IEnumDVD_CELL_PIECE_INTERFACE_DEFINED__
#define __IEnumDVD_CELL_PIECE_INTERFACE_DEFINED__

/* interface IEnumDVD_CELL_PIECE */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][public] */ struct __MIDL_IEnumDVD_CELL_PIECE_0001
    {
    UINT16 vob_id;
    UINT8 c_idn;
    UINT32 start;
    UINT32 end;
    } 	DVD_CELL_PIECE;

typedef struct __MIDL_IEnumDVD_CELL_PIECE_0001 *PDVD_CELL_PIECE;


EXTERN_C const IID IID_IEnumDVD_CELL_PIECE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507B-9F3D-11D0-A979-00A0C9050598")
    IEnumDVD_CELL_PIECE : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [full] */ DVD_CELL_PIECE *rgelt,
            /* [in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG eltCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [ref][out] */ IEnumDVD_CELL_PIECE **ppClone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDVD_CELL_PIECEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDVD_CELL_PIECE * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDVD_CELL_PIECE * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDVD_CELL_PIECE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDVD_CELL_PIECE * This,
            /* [in] */ ULONG celt,
            /* [full] */ DVD_CELL_PIECE *rgelt,
            /* [in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDVD_CELL_PIECE * This,
            /* [in] */ ULONG eltCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDVD_CELL_PIECE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDVD_CELL_PIECE * This,
            /* [ref][out] */ IEnumDVD_CELL_PIECE **ppClone);
        
        END_INTERFACE
    } IEnumDVD_CELL_PIECEVtbl;

    interface IEnumDVD_CELL_PIECE
    {
        CONST_VTBL struct IEnumDVD_CELL_PIECEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDVD_CELL_PIECE_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDVD_CELL_PIECE_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDVD_CELL_PIECE_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDVD_CELL_PIECE_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumDVD_CELL_PIECE_Skip(This,eltCount)	\
    ( (This)->lpVtbl -> Skip(This,eltCount) ) 

#define IEnumDVD_CELL_PIECE_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDVD_CELL_PIECE_Clone(This,ppClone)	\
    ( (This)->lpVtbl -> Clone(This,ppClone) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDVD_CELL_PIECE_INTERFACE_DEFINED__ */


#ifndef __IEnumDVD_TEXT_LANGUAGE_UNIT_INTERFACE_DEFINED__
#define __IEnumDVD_TEXT_LANGUAGE_UNIT_INTERFACE_DEFINED__

/* interface IEnumDVD_TEXT_LANGUAGE_UNIT */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDVD_TEXT_LANGUAGE_UNIT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507C-9F3D-11D0-A979-00A0C9050598")
    IEnumDVD_TEXT_LANGUAGE_UNIT : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [full] */ DVD_TEXT_LANGUAGE_UNIT *rgelt,
            /* [in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG eltCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [ref][out] */ IEnumDVD_TEXT_LANGUAGE_UNIT **ppClone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDVD_TEXT_LANGUAGE_UNITVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This,
            /* [in] */ ULONG celt,
            /* [full] */ DVD_TEXT_LANGUAGE_UNIT *rgelt,
            /* [in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This,
            /* [in] */ ULONG eltCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDVD_TEXT_LANGUAGE_UNIT * This,
            /* [ref][out] */ IEnumDVD_TEXT_LANGUAGE_UNIT **ppClone);
        
        END_INTERFACE
    } IEnumDVD_TEXT_LANGUAGE_UNITVtbl;

    interface IEnumDVD_TEXT_LANGUAGE_UNIT
    {
        CONST_VTBL struct IEnumDVD_TEXT_LANGUAGE_UNITVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDVD_TEXT_LANGUAGE_UNIT_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDVD_TEXT_LANGUAGE_UNIT_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDVD_TEXT_LANGUAGE_UNIT_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDVD_TEXT_LANGUAGE_UNIT_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumDVD_TEXT_LANGUAGE_UNIT_Skip(This,eltCount)	\
    ( (This)->lpVtbl -> Skip(This,eltCount) ) 

#define IEnumDVD_TEXT_LANGUAGE_UNIT_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDVD_TEXT_LANGUAGE_UNIT_Clone(This,ppClone)	\
    ( (This)->lpVtbl -> Clone(This,ppClone) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDVD_TEXT_LANGUAGE_UNIT_INTERFACE_DEFINED__ */


#ifndef __IEnumDVD_TEXT_ITEM_INTERFACE_DEFINED__
#define __IEnumDVD_TEXT_ITEM_INTERFACE_DEFINED__

/* interface IEnumDVD_TEXT_ITEM */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDVD_TEXT_ITEM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507D-9F3D-11D0-A979-00A0C9050598")
    IEnumDVD_TEXT_ITEM : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [full] */ DVD_TEXT_ITEM *rgelt,
            /* [in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG eltCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [ref][out] */ IEnumDVD_TEXT_ITEM **ppClone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDVD_TEXT_ITEMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDVD_TEXT_ITEM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDVD_TEXT_ITEM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDVD_TEXT_ITEM * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDVD_TEXT_ITEM * This,
            /* [in] */ ULONG celt,
            /* [full] */ DVD_TEXT_ITEM *rgelt,
            /* [in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDVD_TEXT_ITEM * This,
            /* [in] */ ULONG eltCount);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDVD_TEXT_ITEM * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDVD_TEXT_ITEM * This,
            /* [ref][out] */ IEnumDVD_TEXT_ITEM **ppClone);
        
        END_INTERFACE
    } IEnumDVD_TEXT_ITEMVtbl;

    interface IEnumDVD_TEXT_ITEM
    {
        CONST_VTBL struct IEnumDVD_TEXT_ITEMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDVD_TEXT_ITEM_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDVD_TEXT_ITEM_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDVD_TEXT_ITEM_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDVD_TEXT_ITEM_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumDVD_TEXT_ITEM_Skip(This,eltCount)	\
    ( (This)->lpVtbl -> Skip(This,eltCount) ) 

#define IEnumDVD_TEXT_ITEM_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDVD_TEXT_ITEM_Clone(This,ppClone)	\
    ( (This)->lpVtbl -> Clone(This,ppClone) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDVD_TEXT_ITEM_INTERFACE_DEFINED__ */


#ifndef __IDVDTitleSet_INTERFACE_DEFINED__
#define __IDVDTitleSet_INTERFACE_DEFINED__

/* interface IDVDTitleSet */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDTitleSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507E-9F3D-11D0-A979-00A0C9050598")
    IDVDTitleSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSpecVersion( 
            UINT16 *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            UINT32 *pCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenu( 
            IDVDMenu **ppMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDomain( 
            IDVDDomain **ppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleUnitCount( 
            UINT16 *pTtuCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitlePart( 
            UINT16 ttu,
            UINT16 ptt,
            UINT16 *pPgcn,
            UINT8 *pPgn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVTSN( 
            UINT16 *pVTSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolume( 
            IDVDVideoVolume **pVolume) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDTitleSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDTitleSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDTitleSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDTitleSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            IDVDTitleSet * This,
            UINT16 *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IDVDTitleSet * This,
            UINT32 *pCategory);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IDVDTitleSet * This,
            IDVDMenu **ppMenu);
        
        HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IDVDTitleSet * This,
            IDVDDomain **ppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleUnitCount )( 
            IDVDTitleSet * This,
            UINT16 *pTtuCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitlePart )( 
            IDVDTitleSet * This,
            UINT16 ttu,
            UINT16 ptt,
            UINT16 *pPgcn,
            UINT8 *pPgn);
        
        HRESULT ( STDMETHODCALLTYPE *GetVTSN )( 
            IDVDTitleSet * This,
            UINT16 *pVTSN);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolume )( 
            IDVDTitleSet * This,
            IDVDVideoVolume **pVolume);
        
        END_INTERFACE
    } IDVDTitleSetVtbl;

    interface IDVDTitleSet
    {
        CONST_VTBL struct IDVDTitleSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDTitleSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDTitleSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDTitleSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDTitleSet_GetSpecVersion(This,pVersion)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,pVersion) ) 

#define IDVDTitleSet_GetCategory(This,pCategory)	\
    ( (This)->lpVtbl -> GetCategory(This,pCategory) ) 

#define IDVDTitleSet_GetMenu(This,ppMenu)	\
    ( (This)->lpVtbl -> GetMenu(This,ppMenu) ) 

#define IDVDTitleSet_GetDomain(This,ppDomain)	\
    ( (This)->lpVtbl -> GetDomain(This,ppDomain) ) 

#define IDVDTitleSet_GetTotalTitleUnitCount(This,pTtuCount)	\
    ( (This)->lpVtbl -> GetTotalTitleUnitCount(This,pTtuCount) ) 

#define IDVDTitleSet_GetTitlePart(This,ttu,ptt,pPgcn,pPgn)	\
    ( (This)->lpVtbl -> GetTitlePart(This,ttu,ptt,pPgcn,pPgn) ) 

#define IDVDTitleSet_GetVTSN(This,pVTSN)	\
    ( (This)->lpVtbl -> GetVTSN(This,pVTSN) ) 

#define IDVDTitleSet_GetVolume(This,pVolume)	\
    ( (This)->lpVtbl -> GetVolume(This,pVolume) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDTitleSet_INTERFACE_DEFINED__ */


#ifndef __IDVDProgramChain_INTERFACE_DEFINED__
#define __IDVDProgramChain_INTERFACE_DEFINED__

/* interface IDVDProgramChain */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][public][public] */ struct __MIDL_IDVDProgramChain_0001
    {
    UINT8 cmd[ 8 ];
    } 	DVD_NAV_CMD;

typedef /* [public][public][public] */ 
enum __MIDL_IDVDProgramChain_0002
    {	DVD_PRE_CMD	= 0,
	DVD_POST_CMD	= 1,
	DVD_CELL_CMD	= 2
    } 	ENavCmdArea;

typedef /* [public][public] */ struct __MIDL_IDVDProgramChain_0003
    {
    UINT32 cellCategory;
    UINT32 cellPlaybackTime;
    UINT32 startFirstVobu;
    UINT32 endFirstIlvu;
    UINT32 startLastVobu;
    UINT32 endLastVobu;
    } 	DVD_CELL_PLAYBACK;

typedef /* [public][public] */ 
enum __MIDL_IDVDProgramChain_0004
    {	DVD_NEXT_PGC	= 0,
	DVD_PREVIOUS_PGC	= ( DVD_NEXT_PGC + 1 ) ,
	DVD_UP_PGC	= ( DVD_PREVIOUS_PGC + 1 ) 
    } 	EPGCLinkType;

typedef /* [public][public] */ 
enum __MIDL_IDVDProgramChain_0005
    {	DVD_PLAYMODE_SEQUENTIAL	= 0,
	DVD_PLAYMODE_RANDOM	= ( DVD_PLAYMODE_SEQUENTIAL + 1 ) ,
	DVD_PLAYMODE_SHUFFLE	= ( DVD_PLAYMODE_RANDOM + 1 ) 
    } 	EPGCPlaybackMode;


EXTERN_C const IID IID_IDVDProgramChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB507F-9F3D-11D0-A979-00A0C9050598")
    IDVDProgramChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDomain( 
            IDVDDomain **ppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContents( 
            UINT32 *pContents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlaybackTime( 
            UINT32 *pbcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserOperationControlMask( 
            UINT32 *pmask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioStreamSelector( 
            UINT8 streamN,
            UINT16 *pSelector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureStreamSelector( 
            UINT8 streamN,
            UINT32 *pSPSel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLink( 
            EPGCLinkType eType,
            UINT16 *pgcn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlaybackMode( 
            EPGCPlaybackMode *pMode,
            UINT8 *pRepeatCount,
            UINT8 *pStillTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpicturePalette( 
            UINT32 *pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNavCommandsCount( 
            ENavCmdArea eArea,
            UINT16 *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNavCommand( 
            ENavCmdArea area,
            UINT16 commandN,
            DVD_NAV_CMD *pCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProgramEntryCell( 
            UINT16 pgno,
            UINT8 *pEntryCN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellPlaybackInfo( 
            UINT8 cn,
            DVD_CELL_PLAYBACK *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellPosition( 
            UINT8 cn,
            UINT16 *pVOB_ID,
            UINT8 *pC_IDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPGCN( 
            UINT16 *pPGCN) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDProgramChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDProgramChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDProgramChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDProgramChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IDVDProgramChain * This,
            IDVDDomain **ppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetContents )( 
            IDVDProgramChain * This,
            UINT32 *pContents);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlaybackTime )( 
            IDVDProgramChain * This,
            UINT32 *pbcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserOperationControlMask )( 
            IDVDProgramChain * This,
            UINT32 *pmask);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioStreamSelector )( 
            IDVDProgramChain * This,
            UINT8 streamN,
            UINT16 *pSelector);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureStreamSelector )( 
            IDVDProgramChain * This,
            UINT8 streamN,
            UINT32 *pSPSel);
        
        HRESULT ( STDMETHODCALLTYPE *GetLink )( 
            IDVDProgramChain * This,
            EPGCLinkType eType,
            UINT16 *pgcn);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlaybackMode )( 
            IDVDProgramChain * This,
            EPGCPlaybackMode *pMode,
            UINT8 *pRepeatCount,
            UINT8 *pStillTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpicturePalette )( 
            IDVDProgramChain * This,
            UINT32 *pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetNavCommandsCount )( 
            IDVDProgramChain * This,
            ENavCmdArea eArea,
            UINT16 *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNavCommand )( 
            IDVDProgramChain * This,
            ENavCmdArea area,
            UINT16 commandN,
            DVD_NAV_CMD *pCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetProgramEntryCell )( 
            IDVDProgramChain * This,
            UINT16 pgno,
            UINT8 *pEntryCN);
        
        HRESULT ( STDMETHODCALLTYPE *GetCellPlaybackInfo )( 
            IDVDProgramChain * This,
            UINT8 cn,
            DVD_CELL_PLAYBACK *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetCellPosition )( 
            IDVDProgramChain * This,
            UINT8 cn,
            UINT16 *pVOB_ID,
            UINT8 *pC_IDN);
        
        HRESULT ( STDMETHODCALLTYPE *GetPGCN )( 
            IDVDProgramChain * This,
            UINT16 *pPGCN);
        
        END_INTERFACE
    } IDVDProgramChainVtbl;

    interface IDVDProgramChain
    {
        CONST_VTBL struct IDVDProgramChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDProgramChain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDProgramChain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDProgramChain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDProgramChain_GetDomain(This,ppDomain)	\
    ( (This)->lpVtbl -> GetDomain(This,ppDomain) ) 

#define IDVDProgramChain_GetContents(This,pContents)	\
    ( (This)->lpVtbl -> GetContents(This,pContents) ) 

#define IDVDProgramChain_GetPlaybackTime(This,pbcdTime)	\
    ( (This)->lpVtbl -> GetPlaybackTime(This,pbcdTime) ) 

#define IDVDProgramChain_GetUserOperationControlMask(This,pmask)	\
    ( (This)->lpVtbl -> GetUserOperationControlMask(This,pmask) ) 

#define IDVDProgramChain_GetAudioStreamSelector(This,streamN,pSelector)	\
    ( (This)->lpVtbl -> GetAudioStreamSelector(This,streamN,pSelector) ) 

#define IDVDProgramChain_GetSubpictureStreamSelector(This,streamN,pSPSel)	\
    ( (This)->lpVtbl -> GetSubpictureStreamSelector(This,streamN,pSPSel) ) 

#define IDVDProgramChain_GetLink(This,eType,pgcn)	\
    ( (This)->lpVtbl -> GetLink(This,eType,pgcn) ) 

#define IDVDProgramChain_GetPlaybackMode(This,pMode,pRepeatCount,pStillTime)	\
    ( (This)->lpVtbl -> GetPlaybackMode(This,pMode,pRepeatCount,pStillTime) ) 

#define IDVDProgramChain_GetSubpicturePalette(This,pBuf)	\
    ( (This)->lpVtbl -> GetSubpicturePalette(This,pBuf) ) 

#define IDVDProgramChain_GetNavCommandsCount(This,eArea,pCount)	\
    ( (This)->lpVtbl -> GetNavCommandsCount(This,eArea,pCount) ) 

#define IDVDProgramChain_GetNavCommand(This,area,commandN,pCmd)	\
    ( (This)->lpVtbl -> GetNavCommand(This,area,commandN,pCmd) ) 

#define IDVDProgramChain_GetProgramEntryCell(This,pgno,pEntryCN)	\
    ( (This)->lpVtbl -> GetProgramEntryCell(This,pgno,pEntryCN) ) 

#define IDVDProgramChain_GetCellPlaybackInfo(This,cn,pInfo)	\
    ( (This)->lpVtbl -> GetCellPlaybackInfo(This,cn,pInfo) ) 

#define IDVDProgramChain_GetCellPosition(This,cn,pVOB_ID,pC_IDN)	\
    ( (This)->lpVtbl -> GetCellPosition(This,cn,pVOB_ID,pC_IDN) ) 

#define IDVDProgramChain_GetPGCN(This,pPGCN)	\
    ( (This)->lpVtbl -> GetPGCN(This,pPGCN) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDProgramChain_INTERFACE_DEFINED__ */


#ifndef __IDVDTimeMap_INTERFACE_DEFINED__
#define __IDVDTimeMap_INTERFACE_DEFINED__

/* interface IDVDTimeMap */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDTimeMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5080-9F3D-11D0-A979-00A0C9050598")
    IDVDTimeMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTableHeader( 
            UINT8 *pTMU,
            UINT16 *pnEntries) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVOBUAddress( 
            UINT16 nEntryIndex,
            UINT32 *pVobuRlbn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDTimeMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDTimeMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDTimeMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDTimeMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTableHeader )( 
            IDVDTimeMap * This,
            UINT8 *pTMU,
            UINT16 *pnEntries);
        
        HRESULT ( STDMETHODCALLTYPE *GetVOBUAddress )( 
            IDVDTimeMap * This,
            UINT16 nEntryIndex,
            UINT32 *pVobuRlbn);
        
        END_INTERFACE
    } IDVDTimeMapVtbl;

    interface IDVDTimeMap
    {
        CONST_VTBL struct IDVDTimeMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDTimeMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDTimeMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDTimeMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDTimeMap_GetTableHeader(This,pTMU,pnEntries)	\
    ( (This)->lpVtbl -> GetTableHeader(This,pTMU,pnEntries) ) 

#define IDVDTimeMap_GetVOBUAddress(This,nEntryIndex,pVobuRlbn)	\
    ( (This)->lpVtbl -> GetVOBUAddress(This,nEntryIndex,pVobuRlbn) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDTimeMap_INTERFACE_DEFINED__ */


#ifndef __IDVDVideoVolume_INTERFACE_DEFINED__
#define __IDVDVideoVolume_INTERFACE_DEFINED__

/* interface IDVDVideoVolume */
/* [unique][helpstring][uuid][object] */ 

typedef struct _structDVD_PROVIDER_ID
    {
    UINT8 providerID[ 32 ];
    } 	DVD_PROVIDER_ID;

typedef struct _structDVD_POS_CODE
    {
    UINT8 posCode[ 8 ];
    } 	DVD_POS_CODE;

typedef struct _structDVD_TITLE_SET_INFO
    {
    UINT16 nParts;
    UINT16 parentalID;
    UINT8 titlePlaybackType;
    UINT8 nAngles;
    UINT8 vtsn;
    UINT8 vts_ttn;
    } 	DVD_TITLE_SET_INFO;


EXTERN_C const IID IID_IDVDVideoVolume;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5073-9F3D-11D0-A979-00A0C9050598")
    IDVDVideoVolume : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitData( 
            IDVDROM *pDisk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpecVersion( 
            /* [out][ref] */ UINT16 *pVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            /* [out][ref] */ UINT32 *pCat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolumeSetInfo( 
            /* [out][ref] */ UINT16 *pVolumeSetSize,
            /* [out][ref] */ UINT16 *pVolumeNo,
            /* [out][ref] */ UINT8 *pSide) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoTitleSetsCount( 
            /* [out][ref] */ UINT16 *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProviderID( 
            /* [ref][out] */ DVD_PROVIDER_ID *pProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPOSCode( 
            /* [ref][out] */ DVD_POS_CODE *pPOSCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstPlay( 
            /* [ref][out] */ IDVDDomain **ppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenu( 
            /* [ref][out] */ IDVDMenu **ppMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleUnitCount( 
            /* [ref][out] */ UINT16 *pTTUCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleUnitInfo( 
            /* [in] */ UINT16 ttu,
            /* [ref][out] */ DVD_TITLE_SET_INFO *pTUInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleSet( 
            UINT16 zbVtsn,
            IDVDTitleSet **ppTitleSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleSetAttributes( 
            /* [in] */ UINT16 vtsn,
            /* [ref][out] */ UINT32 *pVTSCategory,
            /* [ref][out] */ IDVDStreamAttributes **ppVideoAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentalManagementTable( 
            /* [ref][out] */ IDVDParentalManagementTable **ppTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextDataManager( 
            /* [ref][out] */ IDVDTextManager **ppTxtMgr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDVideoVolumeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDVideoVolume * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDVideoVolume * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDVideoVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitData )( 
            IDVDVideoVolume * This,
            IDVDROM *pDisk);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IDVDVideoVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unlock )( 
            IDVDVideoVolume * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpecVersion )( 
            IDVDVideoVolume * This,
            /* [out][ref] */ UINT16 *pVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IDVDVideoVolume * This,
            /* [out][ref] */ UINT32 *pCat);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolumeSetInfo )( 
            IDVDVideoVolume * This,
            /* [out][ref] */ UINT16 *pVolumeSetSize,
            /* [out][ref] */ UINT16 *pVolumeNo,
            /* [out][ref] */ UINT8 *pSide);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoTitleSetsCount )( 
            IDVDVideoVolume * This,
            /* [out][ref] */ UINT16 *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetProviderID )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ DVD_PROVIDER_ID *pProvider);
        
        HRESULT ( STDMETHODCALLTYPE *GetPOSCode )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ DVD_POS_CODE *pPOSCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstPlay )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ IDVDDomain **ppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ IDVDMenu **ppMenu);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleUnitCount )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ UINT16 *pTTUCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleUnitInfo )( 
            IDVDVideoVolume * This,
            /* [in] */ UINT16 ttu,
            /* [ref][out] */ DVD_TITLE_SET_INFO *pTUInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleSet )( 
            IDVDVideoVolume * This,
            UINT16 zbVtsn,
            IDVDTitleSet **ppTitleSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleSetAttributes )( 
            IDVDVideoVolume * This,
            /* [in] */ UINT16 vtsn,
            /* [ref][out] */ UINT32 *pVTSCategory,
            /* [ref][out] */ IDVDStreamAttributes **ppVideoAttr);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentalManagementTable )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ IDVDParentalManagementTable **ppTable);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextDataManager )( 
            IDVDVideoVolume * This,
            /* [ref][out] */ IDVDTextManager **ppTxtMgr);
        
        END_INTERFACE
    } IDVDVideoVolumeVtbl;

    interface IDVDVideoVolume
    {
        CONST_VTBL struct IDVDVideoVolumeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDVideoVolume_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDVideoVolume_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDVideoVolume_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDVideoVolume_InitData(This,pDisk)	\
    ( (This)->lpVtbl -> InitData(This,pDisk) ) 

#define IDVDVideoVolume_Lock(This)	\
    ( (This)->lpVtbl -> Lock(This) ) 

#define IDVDVideoVolume_Unlock(This)	\
    ( (This)->lpVtbl -> Unlock(This) ) 

#define IDVDVideoVolume_GetSpecVersion(This,pVersion)	\
    ( (This)->lpVtbl -> GetSpecVersion(This,pVersion) ) 

#define IDVDVideoVolume_GetCategory(This,pCat)	\
    ( (This)->lpVtbl -> GetCategory(This,pCat) ) 

#define IDVDVideoVolume_GetVolumeSetInfo(This,pVolumeSetSize,pVolumeNo,pSide)	\
    ( (This)->lpVtbl -> GetVolumeSetInfo(This,pVolumeSetSize,pVolumeNo,pSide) ) 

#define IDVDVideoVolume_GetVideoTitleSetsCount(This,pCount)	\
    ( (This)->lpVtbl -> GetVideoTitleSetsCount(This,pCount) ) 

#define IDVDVideoVolume_GetProviderID(This,pProvider)	\
    ( (This)->lpVtbl -> GetProviderID(This,pProvider) ) 

#define IDVDVideoVolume_GetPOSCode(This,pPOSCode)	\
    ( (This)->lpVtbl -> GetPOSCode(This,pPOSCode) ) 

#define IDVDVideoVolume_GetFirstPlay(This,ppDomain)	\
    ( (This)->lpVtbl -> GetFirstPlay(This,ppDomain) ) 

#define IDVDVideoVolume_GetMenu(This,ppMenu)	\
    ( (This)->lpVtbl -> GetMenu(This,ppMenu) ) 

#define IDVDVideoVolume_GetTotalTitleUnitCount(This,pTTUCount)	\
    ( (This)->lpVtbl -> GetTotalTitleUnitCount(This,pTTUCount) ) 

#define IDVDVideoVolume_GetTitleUnitInfo(This,ttu,pTUInfo)	\
    ( (This)->lpVtbl -> GetTitleUnitInfo(This,ttu,pTUInfo) ) 

#define IDVDVideoVolume_GetTitleSet(This,zbVtsn,ppTitleSet)	\
    ( (This)->lpVtbl -> GetTitleSet(This,zbVtsn,ppTitleSet) ) 

#define IDVDVideoVolume_GetTitleSetAttributes(This,vtsn,pVTSCategory,ppVideoAttr)	\
    ( (This)->lpVtbl -> GetTitleSetAttributes(This,vtsn,pVTSCategory,ppVideoAttr) ) 

#define IDVDVideoVolume_GetParentalManagementTable(This,ppTable)	\
    ( (This)->lpVtbl -> GetParentalManagementTable(This,ppTable) ) 

#define IDVDVideoVolume_GetTextDataManager(This,ppTxtMgr)	\
    ( (This)->lpVtbl -> GetTextDataManager(This,ppTxtMgr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDVideoVolume_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvdata_0000_0013 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0013_v0_0_s_ifspec;

#ifndef __IDVDDataSearchInfo_INTERFACE_DEFINED__
#define __IDVDDataSearchInfo_INTERFACE_DEFINED__

/* interface IDVDDataSearchInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDDataSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5081-9F3D-11D0-A979-00A0C9050598")
    IDVDDataSearchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetControlInfo( 
            IDVDStreamControlInfo **ppStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSCRBase( 
            UINT32 *pSCR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnitEndAddress( 
            UINT32 *pRLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRefPictureAddress( 
            UINT8 refNo,
            UINT32 *pRLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVOB_ID( 
            UINT16 *pVOB_ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetC_IDN( 
            UINT8 *pC_IDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSeamlessCategory( 
            UINT16 *pCat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterleavedUnitEndAddress( 
            UINT32 *pRLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextInterleavedUnit( 
            UINT32 *pRLBN,
            UINT16 *pLBSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioGapInfo( 
            UINT8 streamNo,
            UINT8 gapNo,
            UINT32 *pMpegStart,
            UINT32 *pMpegEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSeamlessAngleChangeAddress( 
            UINT8 angle,
            UINT32 *pRLBN,
            UINT32 *pLBSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnitStepAddress( 
            UINT8 dir,
            INT16 stepIndex,
            UINT32 *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncAudioAddress( 
            UINT8 streamN,
            UINT16 *pRLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncSPAddress( 
            UINT8 streamN,
            UINT32 *pRLBN) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDDataSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDDataSearchInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDDataSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDDataSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlInfo )( 
            IDVDDataSearchInfo * This,
            IDVDStreamControlInfo **ppStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSCRBase )( 
            IDVDDataSearchInfo * This,
            UINT32 *pSCR);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnitEndAddress )( 
            IDVDDataSearchInfo * This,
            UINT32 *pRLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetRefPictureAddress )( 
            IDVDDataSearchInfo * This,
            UINT8 refNo,
            UINT32 *pRLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetVOB_ID )( 
            IDVDDataSearchInfo * This,
            UINT16 *pVOB_ID);
        
        HRESULT ( STDMETHODCALLTYPE *GetC_IDN )( 
            IDVDDataSearchInfo * This,
            UINT8 *pC_IDN);
        
        HRESULT ( STDMETHODCALLTYPE *GetSeamlessCategory )( 
            IDVDDataSearchInfo * This,
            UINT16 *pCat);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterleavedUnitEndAddress )( 
            IDVDDataSearchInfo * This,
            UINT32 *pRLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInterleavedUnit )( 
            IDVDDataSearchInfo * This,
            UINT32 *pRLBN,
            UINT16 *pLBSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioGapInfo )( 
            IDVDDataSearchInfo * This,
            UINT8 streamNo,
            UINT8 gapNo,
            UINT32 *pMpegStart,
            UINT32 *pMpegEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetSeamlessAngleChangeAddress )( 
            IDVDDataSearchInfo * This,
            UINT8 angle,
            UINT32 *pRLBN,
            UINT32 *pLBSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnitStepAddress )( 
            IDVDDataSearchInfo * This,
            UINT8 dir,
            INT16 stepIndex,
            UINT32 *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncAudioAddress )( 
            IDVDDataSearchInfo * This,
            UINT8 streamN,
            UINT16 *pRLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncSPAddress )( 
            IDVDDataSearchInfo * This,
            UINT8 streamN,
            UINT32 *pRLBN);
        
        END_INTERFACE
    } IDVDDataSearchInfoVtbl;

    interface IDVDDataSearchInfo
    {
        CONST_VTBL struct IDVDDataSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDDataSearchInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDDataSearchInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDDataSearchInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDDataSearchInfo_GetControlInfo(This,ppStream)	\
    ( (This)->lpVtbl -> GetControlInfo(This,ppStream) ) 

#define IDVDDataSearchInfo_GetSCRBase(This,pSCR)	\
    ( (This)->lpVtbl -> GetSCRBase(This,pSCR) ) 

#define IDVDDataSearchInfo_GetUnitEndAddress(This,pRLBN)	\
    ( (This)->lpVtbl -> GetUnitEndAddress(This,pRLBN) ) 

#define IDVDDataSearchInfo_GetRefPictureAddress(This,refNo,pRLBN)	\
    ( (This)->lpVtbl -> GetRefPictureAddress(This,refNo,pRLBN) ) 

#define IDVDDataSearchInfo_GetVOB_ID(This,pVOB_ID)	\
    ( (This)->lpVtbl -> GetVOB_ID(This,pVOB_ID) ) 

#define IDVDDataSearchInfo_GetC_IDN(This,pC_IDN)	\
    ( (This)->lpVtbl -> GetC_IDN(This,pC_IDN) ) 

#define IDVDDataSearchInfo_GetSeamlessCategory(This,pCat)	\
    ( (This)->lpVtbl -> GetSeamlessCategory(This,pCat) ) 

#define IDVDDataSearchInfo_GetInterleavedUnitEndAddress(This,pRLBN)	\
    ( (This)->lpVtbl -> GetInterleavedUnitEndAddress(This,pRLBN) ) 

#define IDVDDataSearchInfo_GetNextInterleavedUnit(This,pRLBN,pLBSize)	\
    ( (This)->lpVtbl -> GetNextInterleavedUnit(This,pRLBN,pLBSize) ) 

#define IDVDDataSearchInfo_GetAudioGapInfo(This,streamNo,gapNo,pMpegStart,pMpegEnd)	\
    ( (This)->lpVtbl -> GetAudioGapInfo(This,streamNo,gapNo,pMpegStart,pMpegEnd) ) 

#define IDVDDataSearchInfo_GetSeamlessAngleChangeAddress(This,angle,pRLBN,pLBSize)	\
    ( (This)->lpVtbl -> GetSeamlessAngleChangeAddress(This,angle,pRLBN,pLBSize) ) 

#define IDVDDataSearchInfo_GetUnitStepAddress(This,dir,stepIndex,pAddress)	\
    ( (This)->lpVtbl -> GetUnitStepAddress(This,dir,stepIndex,pAddress) ) 

#define IDVDDataSearchInfo_GetSyncAudioAddress(This,streamN,pRLBN)	\
    ( (This)->lpVtbl -> GetSyncAudioAddress(This,streamN,pRLBN) ) 

#define IDVDDataSearchInfo_GetSyncSPAddress(This,streamN,pRLBN)	\
    ( (This)->lpVtbl -> GetSyncSPAddress(This,streamN,pRLBN) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDDataSearchInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvdata_0000_0014 */
/* [local] */ 

typedef /* [public][public] */ struct __MIDL___MIDL_itf_dvdata_0000_0014_0001
    {
    UINT16 xStart;
    UINT16 xEnd;
    UINT16 yStart;
    UINT16 yEnd;
    } 	DVD_RECT;



extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdata_0000_0014_v0_0_s_ifspec;

#ifndef __IDVDHighlightInfo_INTERFACE_DEFINED__
#define __IDVDHighlightInfo_INTERFACE_DEFINED__

/* interface IDVDHighlightInfo */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDHighlightInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5082-9F3D-11D0-A979-00A0C9050598")
    IDVDHighlightInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamingInfo( 
            IDVDStreamControlInfo **pControlInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPTMs( 
            UINT32 *puiStart,
            UINT32 *puiEnd,
            UINT32 *puiSelectionEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonMode( 
            UINT16 *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonOffset( 
            UINT8 *pbyteOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonCount( 
            UINT8 *pbyteCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberedButtonCount( 
            UINT8 *pbyteCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInitialSelectionButton( 
            UINT8 *pInitialSelection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultActionButton( 
            UINT8 *pActionButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonColorInfo( 
            UINT8 byteButtonColor,
            UINT32 *pSelectionColors,
            UINT32 *pActionColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonPositionInfo( 
            UINT8 byteButton,
            BYTE *pbyteButtonColor,
            UINT8 *pbyteActionMode,
            DVD_RECT *pArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdjacentButton( 
            UINT8 byteButton,
            UINT8 byteDir,
            UINT8 *pbyteButtonNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonCommand( 
            UINT8 byteButtonNumber,
            DVD_NAV_CMD *pCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHLIStatus( 
            UINT16 *pStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDHighlightInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDHighlightInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDHighlightInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDHighlightInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamingInfo )( 
            IDVDHighlightInfo * This,
            IDVDStreamControlInfo **pControlInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetPTMs )( 
            IDVDHighlightInfo * This,
            UINT32 *puiStart,
            UINT32 *puiEnd,
            UINT32 *puiSelectionEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonMode )( 
            IDVDHighlightInfo * This,
            UINT16 *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonOffset )( 
            IDVDHighlightInfo * This,
            UINT8 *pbyteOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonCount )( 
            IDVDHighlightInfo * This,
            UINT8 *pbyteCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberedButtonCount )( 
            IDVDHighlightInfo * This,
            UINT8 *pbyteCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetInitialSelectionButton )( 
            IDVDHighlightInfo * This,
            UINT8 *pInitialSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultActionButton )( 
            IDVDHighlightInfo * This,
            UINT8 *pActionButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonColorInfo )( 
            IDVDHighlightInfo * This,
            UINT8 byteButtonColor,
            UINT32 *pSelectionColors,
            UINT32 *pActionColors);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonPositionInfo )( 
            IDVDHighlightInfo * This,
            UINT8 byteButton,
            BYTE *pbyteButtonColor,
            UINT8 *pbyteActionMode,
            DVD_RECT *pArea);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdjacentButton )( 
            IDVDHighlightInfo * This,
            UINT8 byteButton,
            UINT8 byteDir,
            UINT8 *pbyteButtonNumber);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonCommand )( 
            IDVDHighlightInfo * This,
            UINT8 byteButtonNumber,
            DVD_NAV_CMD *pCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetHLIStatus )( 
            IDVDHighlightInfo * This,
            UINT16 *pStatus);
        
        END_INTERFACE
    } IDVDHighlightInfoVtbl;

    interface IDVDHighlightInfo
    {
        CONST_VTBL struct IDVDHighlightInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDHighlightInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDHighlightInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDHighlightInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDHighlightInfo_GetStreamingInfo(This,pControlInfo)	\
    ( (This)->lpVtbl -> GetStreamingInfo(This,pControlInfo) ) 

#define IDVDHighlightInfo_GetPTMs(This,puiStart,puiEnd,puiSelectionEnd)	\
    ( (This)->lpVtbl -> GetPTMs(This,puiStart,puiEnd,puiSelectionEnd) ) 

#define IDVDHighlightInfo_GetButtonMode(This,pMode)	\
    ( (This)->lpVtbl -> GetButtonMode(This,pMode) ) 

#define IDVDHighlightInfo_GetButtonOffset(This,pbyteOffset)	\
    ( (This)->lpVtbl -> GetButtonOffset(This,pbyteOffset) ) 

#define IDVDHighlightInfo_GetButtonCount(This,pbyteCount)	\
    ( (This)->lpVtbl -> GetButtonCount(This,pbyteCount) ) 

#define IDVDHighlightInfo_GetNumberedButtonCount(This,pbyteCount)	\
    ( (This)->lpVtbl -> GetNumberedButtonCount(This,pbyteCount) ) 

#define IDVDHighlightInfo_GetInitialSelectionButton(This,pInitialSelection)	\
    ( (This)->lpVtbl -> GetInitialSelectionButton(This,pInitialSelection) ) 

#define IDVDHighlightInfo_GetDefaultActionButton(This,pActionButton)	\
    ( (This)->lpVtbl -> GetDefaultActionButton(This,pActionButton) ) 

#define IDVDHighlightInfo_GetButtonColorInfo(This,byteButtonColor,pSelectionColors,pActionColors)	\
    ( (This)->lpVtbl -> GetButtonColorInfo(This,byteButtonColor,pSelectionColors,pActionColors) ) 

#define IDVDHighlightInfo_GetButtonPositionInfo(This,byteButton,pbyteButtonColor,pbyteActionMode,pArea)	\
    ( (This)->lpVtbl -> GetButtonPositionInfo(This,byteButton,pbyteButtonColor,pbyteActionMode,pArea) ) 

#define IDVDHighlightInfo_GetAdjacentButton(This,byteButton,byteDir,pbyteButtonNumber)	\
    ( (This)->lpVtbl -> GetAdjacentButton(This,byteButton,byteDir,pbyteButtonNumber) ) 

#define IDVDHighlightInfo_GetButtonCommand(This,byteButtonNumber,pCmd)	\
    ( (This)->lpVtbl -> GetButtonCommand(This,byteButtonNumber,pCmd) ) 

#define IDVDHighlightInfo_GetHLIStatus(This,pStatus)	\
    ( (This)->lpVtbl -> GetHLIStatus(This,pStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDHighlightInfo_INTERFACE_DEFINED__ */


#ifndef __IDVDStreamControlInfo_INTERFACE_DEFINED__
#define __IDVDStreamControlInfo_INTERFACE_DEFINED__

/* interface IDVDStreamControlInfo */
/* [unique][helpstring][uuid][object] */ 

typedef /* [public][public][public][public] */ struct __MIDL_IDVDStreamControlInfo_0001
    {
    UINT8 valid;
    UINT8 countryCode[ 2 ];
    UINT8 copyrightHolder[ 3 ];
    UINT8 bcdYear;
    UINT8 bcdNumber[ 3 ];
    } 	DVD_ISRC;


EXTERN_C const IID IID_IDVDStreamControlInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5083-9F3D-11D0-A979-00A0C9050598")
    IDVDStreamControlInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNavigationPack( 
            UINT8 *pPack) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBlockAddress( 
            UINT32 *pLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategory( 
            UINT16 *pCat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserOperationControlMask( 
            UINT32 *pMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPresentationTimes( 
            UINT32 *pMpegStart,
            UINT32 *pMpegEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndSequencePTM( 
            UINT32 *pMpegTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCellRelativeStartTime( 
            UINT32 *pBCDTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNonSeamlessAngleChangeAddress( 
            UINT8 angle,
            UINT32 *pRLBN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHighlightInfo( 
            IDVDHighlightInfo **ppHLI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataSearchInfo( 
            IDVDDataSearchInfo **ppDSI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingVideoInfo( 
            DVD_ISRC *pVideo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingAudioInfo( 
            UINT8 stream,
            DVD_ISRC *pAudio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingSubpictureGroup( 
            UINT8 *pSelector) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingSubpictureInfo( 
            UINT8 bin,
            DVD_ISRC *pSubInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReaderLock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReaderUnlock( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDStreamControlInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDStreamControlInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDStreamControlInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDStreamControlInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNavigationPack )( 
            IDVDStreamControlInfo * This,
            UINT8 *pPack);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlockAddress )( 
            IDVDStreamControlInfo * This,
            UINT32 *pLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetCategory )( 
            IDVDStreamControlInfo * This,
            UINT16 *pCat);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserOperationControlMask )( 
            IDVDStreamControlInfo * This,
            UINT32 *pMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresentationTimes )( 
            IDVDStreamControlInfo * This,
            UINT32 *pMpegStart,
            UINT32 *pMpegEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndSequencePTM )( 
            IDVDStreamControlInfo * This,
            UINT32 *pMpegTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCellRelativeStartTime )( 
            IDVDStreamControlInfo * This,
            UINT32 *pBCDTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetNonSeamlessAngleChangeAddress )( 
            IDVDStreamControlInfo * This,
            UINT8 angle,
            UINT32 *pRLBN);
        
        HRESULT ( STDMETHODCALLTYPE *GetHighlightInfo )( 
            IDVDStreamControlInfo * This,
            IDVDHighlightInfo **ppHLI);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataSearchInfo )( 
            IDVDStreamControlInfo * This,
            IDVDDataSearchInfo **ppDSI);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingVideoInfo )( 
            IDVDStreamControlInfo * This,
            DVD_ISRC *pVideo);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingAudioInfo )( 
            IDVDStreamControlInfo * This,
            UINT8 stream,
            DVD_ISRC *pAudio);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingSubpictureGroup )( 
            IDVDStreamControlInfo * This,
            UINT8 *pSelector);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingSubpictureInfo )( 
            IDVDStreamControlInfo * This,
            UINT8 bin,
            DVD_ISRC *pSubInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ReaderLock )( 
            IDVDStreamControlInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReaderUnlock )( 
            IDVDStreamControlInfo * This);
        
        END_INTERFACE
    } IDVDStreamControlInfoVtbl;

    interface IDVDStreamControlInfo
    {
        CONST_VTBL struct IDVDStreamControlInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDStreamControlInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDStreamControlInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDStreamControlInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDStreamControlInfo_SetNavigationPack(This,pPack)	\
    ( (This)->lpVtbl -> SetNavigationPack(This,pPack) ) 

#define IDVDStreamControlInfo_GetBlockAddress(This,pLBN)	\
    ( (This)->lpVtbl -> GetBlockAddress(This,pLBN) ) 

#define IDVDStreamControlInfo_GetCategory(This,pCat)	\
    ( (This)->lpVtbl -> GetCategory(This,pCat) ) 

#define IDVDStreamControlInfo_GetUserOperationControlMask(This,pMask)	\
    ( (This)->lpVtbl -> GetUserOperationControlMask(This,pMask) ) 

#define IDVDStreamControlInfo_GetPresentationTimes(This,pMpegStart,pMpegEnd)	\
    ( (This)->lpVtbl -> GetPresentationTimes(This,pMpegStart,pMpegEnd) ) 

#define IDVDStreamControlInfo_GetEndSequencePTM(This,pMpegTime)	\
    ( (This)->lpVtbl -> GetEndSequencePTM(This,pMpegTime) ) 

#define IDVDStreamControlInfo_GetCellRelativeStartTime(This,pBCDTime)	\
    ( (This)->lpVtbl -> GetCellRelativeStartTime(This,pBCDTime) ) 

#define IDVDStreamControlInfo_GetNonSeamlessAngleChangeAddress(This,angle,pRLBN)	\
    ( (This)->lpVtbl -> GetNonSeamlessAngleChangeAddress(This,angle,pRLBN) ) 

#define IDVDStreamControlInfo_GetHighlightInfo(This,ppHLI)	\
    ( (This)->lpVtbl -> GetHighlightInfo(This,ppHLI) ) 

#define IDVDStreamControlInfo_GetDataSearchInfo(This,ppDSI)	\
    ( (This)->lpVtbl -> GetDataSearchInfo(This,ppDSI) ) 

#define IDVDStreamControlInfo_GetRecordingVideoInfo(This,pVideo)	\
    ( (This)->lpVtbl -> GetRecordingVideoInfo(This,pVideo) ) 

#define IDVDStreamControlInfo_GetRecordingAudioInfo(This,stream,pAudio)	\
    ( (This)->lpVtbl -> GetRecordingAudioInfo(This,stream,pAudio) ) 

#define IDVDStreamControlInfo_GetRecordingSubpictureGroup(This,pSelector)	\
    ( (This)->lpVtbl -> GetRecordingSubpictureGroup(This,pSelector) ) 

#define IDVDStreamControlInfo_GetRecordingSubpictureInfo(This,bin,pSubInfo)	\
    ( (This)->lpVtbl -> GetRecordingSubpictureInfo(This,bin,pSubInfo) ) 

#define IDVDStreamControlInfo_ReaderLock(This)	\
    ( (This)->lpVtbl -> ReaderLock(This) ) 

#define IDVDStreamControlInfo_ReaderUnlock(This)	\
    ( (This)->lpVtbl -> ReaderUnlock(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDStreamControlInfo_INTERFACE_DEFINED__ */


#ifndef __IDVDNavDataStatusSink_INTERFACE_DEFINED__
#define __IDVDNavDataStatusSink_INTERFACE_DEFINED__

/* interface IDVDNavDataStatusSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDNavDataStatusSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77FB5085-9F3D-11D0-A979-00A0C9050598")
    IDVDNavDataStatusSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyNewPCI( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDNavDataStatusSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDNavDataStatusSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDNavDataStatusSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDNavDataStatusSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyNewPCI )( 
            IDVDNavDataStatusSink * This);
        
        END_INTERFACE
    } IDVDNavDataStatusSinkVtbl;

    interface IDVDNavDataStatusSink
    {
        CONST_VTBL struct IDVDNavDataStatusSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDNavDataStatusSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDNavDataStatusSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDNavDataStatusSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDNavDataStatusSink_NotifyNewPCI(This)	\
    ( (This)->lpVtbl -> NotifyNewPCI(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDNavDataStatusSink_INTERFACE_DEFINED__ */



#ifndef __DVDATALib_LIBRARY_DEFINED__
#define __DVDATALib_LIBRARY_DEFINED__

/* library DVDATALib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DVDATALib;

EXTERN_C const CLSID CLSID_DVDData;

#ifdef __cplusplus

class DECLSPEC_UUID("77FB5076-9F3D-11D0-A979-00A0C9050598")
DVDData;
#endif

EXTERN_C const CLSID CLSID_DVDStreamControlInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("77FB5084-9F3D-11D0-A979-00A0C9050598")
DVDStreamControlInfo;
#endif
#endif /* __DVDATALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dsound.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*==========================================================================;
 *
 *
 *  File:       dsound.h
 *  Content:    DirectSound include file
 *
 **************************************************************************/

#ifndef __DSOUND_INCLUDED__
#define __DSOUND_INCLUDED__

#undef CreatePalette
#undef GetDC
#undef ReleaseDC

#if defined(DIRECTSOUND3D_SUPPORT)

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Guard D3DVALUE and D3DVECTOR definition to make dsound.h
// independent of d3dtypes.h
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifndef DEFINED_D3DVALUE
#define DEFINED_D3DVALUE
#pragma pack(push,4)

/* D3DVALUE is the fundamental Direct3D fractional data type */

#define D3DVALP(val, prec) ((float)(val))
#define D3DVAL(val) ((float)(val))
typedef float D3DVALUE, *LPD3DVALUE;

#define D3DDivide(a, b)    (float)((double) (a) / (double) (b))
#define D3DMultiply(a, b)    ((a) * (b))

#pragma pack(pop)
#endif //!DEFINED_D3DVALUE

#ifndef DEFINED_D3DVECTOR
#define DEFINED_D3DVECTOR

#pragma pack(push,4)

typedef struct _D3DVECTOR {
    union {
	D3DVALUE x;
	D3DVALUE dvX;
    };
    union {
	D3DVALUE y;
	D3DVALUE dvY;
    };
    union {
	D3DVALUE z;
	D3DVALUE dvZ;
    };
#if (defined __cplusplus) && (defined D3D_OVERLOADS)

public:

    // =====================================
    // Constructors
    // =====================================

    _D3DVECTOR() { }
    _D3DVECTOR(D3DVALUE f);
    _D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z);
    _D3DVECTOR(const D3DVALUE f[3]);

    // =====================================
    // Access grants
    // =====================================

    const D3DVALUE&operator[](int i) const;
    D3DVALUE&operator[](int i);

    // =====================================
    // Assignment operators
    // =====================================

    _D3DVECTOR& operator += (const _D3DVECTOR& v);
    _D3DVECTOR& operator -= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (const _D3DVECTOR& v);
    _D3DVECTOR& operator /= (const _D3DVECTOR& v);
    _D3DVECTOR& operator *= (D3DVALUE s);
    _D3DVECTOR& operator /= (D3DVALUE s);

    // =====================================
    // Unary operators
    // =====================================

    friend _D3DVECTOR operator + (const _D3DVECTOR& v);
    friend _D3DVECTOR operator - (const _D3DVECTOR& v);


    // =====================================
    // Binary operators
    // =====================================

    // Addition and subtraction
        friend _D3DVECTOR operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
    // Scalar multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v, D3DVALUE s);
        friend _D3DVECTOR operator * (D3DVALUE s, const _D3DVECTOR& v);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v, D3DVALUE s);
    // Memberwise multiplication and division
        friend _D3DVECTOR operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Vector dominance
        friend int operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend int operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Bitwise equality
        friend int operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Length-related functions
        friend D3DVALUE SquareMagnitude (const _D3DVECTOR& v);
        friend D3DVALUE Magnitude (const _D3DVECTOR& v);

    // Returns vector with same direction and unit length
        friend _D3DVECTOR Normalize (const _D3DVECTOR& v);

    // Return min/max component of the input vector
        friend D3DVALUE Min (const _D3DVECTOR& v);
        friend D3DVALUE Max (const _D3DVECTOR& v);

    // Return memberwise min/max of input vectors
        friend _D3DVECTOR Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

    // Dot and cross product
        friend D3DVALUE DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);
        friend _D3DVECTOR CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2);

#endif

} D3DVECTOR, *LPD3DVECTOR;

#pragma pack(pop)
#endif // !DEFINED_D3DVECTOR

#endif // defined(DIRECTSOUND3D_SUPPORT)
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#endif

#define _FACDS  0x878
#define MAKE_DSHRESULT(code)  MAKE_HRESULT(1, _FACDS, code)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "pshpack1.h"   // Assume byte packing throughout

#ifndef _WAVEFORMATEX_				
#define _WAVEFORMATEX_
typedef struct
{
    WORD        wFormatTag;         // format type
    WORD        nChannels;          // number of channels (i.e. mono, stereo...)
    DWORD       nSamplesPerSec;     // sample rate
    DWORD       nAvgBytesPerSec;    // for buffer estimation
    WORD        nBlockAlign;        // block size of data
    WORD        wBitsPerSample;     // number of bits per sample of mono data
    WORD        cbSize;             // the count in bytes of the size of
                                    // extra information (after cbSize)
} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX;
#endif

// Direct Sound Component GUID {47D4D946-62E8-11cf-93BC-444553540000}
DEFINE_GUID(CLSID_DirectSound, 0x47d4d946, 0x62e8, 0x11cf, 0x93, 0xbc, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

// DirectSound Capture Component GUID {B0210780-89CD-11d0-AF08-00A0C925CD16}
DEFINE_GUID(CLSID_DirectSoundCapture, 0xb0210780, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#include "poppack.h"        /* Revert to default packing */

//
// Structures
// 

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IDirectSound;
struct IDirectSoundBuffer;
struct IDirectSound3DListener;
struct IDirectSound3DBuffer;
struct IDirectSoundCapture;
struct IDirectSoundCaptureBuffer;
struct IDirectSoundNotify;
#endif // __cplusplus

typedef struct IDirectSound *LPDIRECTSOUND;
typedef struct IDirectSoundBuffer *LPDIRECTSOUNDBUFFER;
typedef struct IDirectSound3DListener *LPDIRECTSOUND3DLISTENER;
typedef struct IDirectSound3DBuffer *LPDIRECTSOUND3DBUFFER;
typedef struct IDirectSoundCapture *LPDIRECTSOUNDCAPTURE;
typedef struct IDirectSoundCaptureBuffer *LPDIRECTSOUNDCAPTUREBUFFER;
typedef struct IDirectSoundNotify *LPDIRECTSOUNDNOTIFY;

typedef struct _DSCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwMinSecondarySampleRate;
    DWORD           dwMaxSecondarySampleRate;
    DWORD           dwPrimaryBuffers;
    DWORD           dwMaxHwMixingAllBuffers;
    DWORD           dwMaxHwMixingStaticBuffers;
    DWORD           dwMaxHwMixingStreamingBuffers;
    DWORD           dwFreeHwMixingAllBuffers;
    DWORD           dwFreeHwMixingStaticBuffers;
    DWORD           dwFreeHwMixingStreamingBuffers;
    DWORD           dwMaxHw3DAllBuffers;
    DWORD           dwMaxHw3DStaticBuffers;
    DWORD           dwMaxHw3DStreamingBuffers;
    DWORD           dwFreeHw3DAllBuffers;
    DWORD           dwFreeHw3DStaticBuffers;
    DWORD           dwFreeHw3DStreamingBuffers;
    DWORD           dwTotalHwMemBytes;
    DWORD           dwFreeHwMemBytes;
    DWORD           dwMaxContigFreeHwMemBytes;
    DWORD           dwUnlockTransferRateHwBuffers;
    DWORD           dwPlayCpuOverheadSwBuffers;
    DWORD           dwReserved1;
    DWORD           dwReserved2;
} DSCAPS, *LPDSCAPS;

typedef const DSCAPS *LPCDSCAPS;

typedef struct _DSBCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwUnlockTransferRate;
    DWORD           dwPlayCpuOverhead;
} DSBCAPS, *LPDSBCAPS;

typedef const DSBCAPS *LPCDSBCAPS;

typedef struct _DSBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSBUFFERDESC, *LPDSBUFFERDESC;

typedef const DSBUFFERDESC *LPCDSBUFFERDESC;

#if defined(DIRECTSOUND3D_SUPPORT)
typedef struct _DS3DBUFFER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    DWORD           dwInsideConeAngle;
    DWORD           dwOutsideConeAngle;
    D3DVECTOR       vConeOrientation;
    LONG            lConeOutsideVolume;
    D3DVALUE        flMinDistance;
    D3DVALUE        flMaxDistance;
    DWORD           dwMode;
} DS3DBUFFER, *LPDS3DBUFFER;

typedef const DS3DBUFFER *LPCDS3DBUFFER;

typedef struct _DS3DLISTENER
{
    DWORD           dwSize;
    D3DVECTOR       vPosition;
    D3DVECTOR       vVelocity;
    D3DVECTOR       vOrientFront;
    D3DVECTOR       vOrientTop;
    D3DVALUE        flDistanceFactor;
    D3DVALUE        flRolloffFactor;
    D3DVALUE        flDopplerFactor;
} DS3DLISTENER, *LPDS3DLISTENER;

typedef const DS3DLISTENER *LPCDS3DLISTENER;

#endif // defined(DIRECTSOUND3D_SUPPORT)

typedef struct _DSCCAPS
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwFormats;
    DWORD           dwChannels;
} DSCCAPS, *LPDSCCAPS;

typedef const DSCCAPS *LPCDSCCAPS;

typedef struct _DSCBUFFERDESC
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
    LPWAVEFORMATEX  lpwfxFormat;
} DSCBUFFERDESC, *LPDSCBUFFERDESC;

typedef const DSCBUFFERDESC *LPCDSCBUFFERDESC;

typedef struct _DSCBCAPS 
{
    DWORD           dwSize;
    DWORD           dwFlags;
    DWORD           dwBufferBytes;
    DWORD           dwReserved;
} DSCBCAPS, *LPDSCBCAPS;

typedef const DSCBCAPS *LPCDSCBCAPS;

typedef struct _DSBPOSITIONNOTIFY
{
    DWORD           dwOffset;
    HANDLE          hEventNotify;
} DSBPOSITIONNOTIFY, *LPDSBPOSITIONNOTIFY;

typedef const DSBPOSITIONNOTIFY *LPCDSBPOSITIONNOTIFY;

//
// Compatibility typedefs
//

typedef LPDIRECTSOUND *LPLPDIRECTSOUND;
typedef LPDIRECTSOUNDBUFFER *LPLPDIRECTSOUNDBUFFER;
typedef LPDIRECTSOUND3DLISTENER *LPLPDIRECTSOUND3DLISTENER;
typedef LPDIRECTSOUND3DBUFFER *LPLPDIRECTSOUND3DBUFFER;
typedef LPDIRECTSOUNDCAPTURE *LPLPDIRECTSOUNDCAPTURE;
typedef LPDIRECTSOUNDCAPTUREBUFFER *LPLPDIRECTSOUNDCAPTUREBUFFER;
typedef LPDIRECTSOUNDNOTIFY *LPLPDIRECTSOUNDNOTIFY;
typedef LPVOID *LPLPVOID;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

//
// DirectSound API
//

typedef BOOL (CALLBACK *LPDSENUMCALLBACKW)(LPGUID, LPCWSTR, LPCWSTR, LPVOID);
typedef BOOL (CALLBACK *LPDSENUMCALLBACKA)(LPGUID, LPCSTR, LPCSTR, LPVOID);

extern HRESULT WINAPI DirectSoundCreate(LPGUID, LPDIRECTSOUND *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW, LPVOID);
extern HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA, LPVOID);

extern HRESULT WINAPI DirectSoundCaptureCreate(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
extern HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW, LPVOID);
extern HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA, LPVOID);

#ifdef UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKW
#define DirectSoundEnumerate        DirectSoundEnumerateW
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateW
#else // UNICODE
#define LPDSENUMCALLBACK            LPDSENUMCALLBACKA
#define DirectSoundEnumerate        DirectSoundEnumerateA
#define DirectSoundCaptureEnumerate DirectSoundCaptureEnumerateA
#endif // UNICODE

//
// IDirectSound
//

DEFINE_GUID(IID_IDirectSound, 0x279AFA83, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound

DECLARE_INTERFACE_(IDirectSound, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectSound methods
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND, DWORD) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakerConfig)     (THIS_ LPDWORD) PURE;
    STDMETHOD(SetSpeakerConfig)     (THIS_ DWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IDirectSound_Release(p)                  (p)->lpVtbl->Release(p)
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->lpVtbl->CreateSoundBuffer(p,a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->lpVtbl->GetCaps(p,a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->lpVtbl->DuplicateSoundBuffer(p,a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->lpVtbl->SetCooperativeLevel(p,a,b)
#define IDirectSound_Compact(p)                  (p)->lpVtbl->Compact(p)
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->lpVtbl->GetSpeakerConfig(p,a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->lpVtbl->SetSpeakerConfig(p,b)
#define IDirectSound_Initialize(p,a)             (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
#define IDirectSound_AddRef(p)                   (p)->AddRef()
#define IDirectSound_Release(p)                  (p)->Release()
#define IDirectSound_CreateSoundBuffer(p,a,b,c)  (p)->CreateSoundBuffer(a,b,c)
#define IDirectSound_GetCaps(p,a)                (p)->GetCaps(a)
#define IDirectSound_DuplicateSoundBuffer(p,a,b) (p)->DuplicateSoundBuffer(a,b)
#define IDirectSound_SetCooperativeLevel(p,a,b)  (p)->SetCooperativeLevel(a,b)
#define IDirectSound_Compact(p)                  (p)->Compact()
#define IDirectSound_GetSpeakerConfig(p,a)       (p)->GetSpeakerConfig(a)
#define IDirectSound_SetSpeakerConfig(p,b)       (p)->SetSpeakerConfig(b)
#define IDirectSound_Initialize(p,a)             (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundBuffer
//

DEFINE_GUID(IID_IDirectSoundBuffer, 0x279AFA85, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSoundBuffer

DECLARE_INTERFACE_(IDirectSoundBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    
    // IDirectSoundBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND, LPCDSBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectSoundBuffer_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->lpVtbl->GetVolume(p,a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->lpVtbl->GetPan(p,a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->lpVtbl->GetFrequency(p,a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->lpVtbl->Play(p,a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->lpVtbl->SetCurrentPosition(p,a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->lpVtbl->SetFormat(p,a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->lpVtbl->SetVolume(p,a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->lpVtbl->SetPan(p,a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->lpVtbl->SetFrequency(p,a)
#define IDirectSoundBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->lpVtbl->Restore(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectSoundBuffer_AddRef(p)                    (p)->AddRef()
#define IDirectSoundBuffer_Release(p)                   (p)->Release()
#define IDirectSoundBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundBuffer_GetVolume(p,a)               (p)->GetVolume(a)
#define IDirectSoundBuffer_GetPan(p,a)                  (p)->GetPan(a)
#define IDirectSoundBuffer_GetFrequency(p,a)            (p)->GetFrequency(a)
#define IDirectSoundBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundBuffer_Play(p,a,b,c)                (p)->Play(a,b,c)
#define IDirectSoundBuffer_SetCurrentPosition(p,a)      (p)->SetCurrentPosition(a)
#define IDirectSoundBuffer_SetFormat(p,a)               (p)->SetFormat(a)
#define IDirectSoundBuffer_SetVolume(p,a)               (p)->SetVolume(a)
#define IDirectSoundBuffer_SetPan(p,a)                  (p)->SetPan(a)
#define IDirectSoundBuffer_SetFrequency(p,a)            (p)->SetFrequency(a)
#define IDirectSoundBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#define IDirectSoundBuffer_Restore(p)                   (p)->Restore()
#endif // !defined(__cplusplus) || defined(CINTERFACE)


#if defined(DIRECTSOUND3D_SUPPORT)

//
// IDirectSound3DListener
//

DEFINE_GUID(IID_IDirectSound3DListener, 0x279AFA84, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DListener

DECLARE_INTERFACE_(IDirectSound3DListener, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSound3D methods
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetOrientation)           (THIS_ LPD3DVECTOR, LPD3DVECTOR) PURE;
    STDMETHOD(GetPosition)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetVelocity)              (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER, DWORD) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound3DListener_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirectSound3DListener_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->lpVtbl->GetDistanceFactor(p,a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->lpVtbl->GetDopplerFactor(p,a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->lpVtbl->GetOrientation(p,a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->lpVtbl->GetRolloffFactor(p,a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->lpVtbl->SetDistanceFactor(p,a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->lpVtbl->SetDopplerFactor(p,a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->lpVtbl->SetOrientation(p,a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->lpVtbl->SetRolloffFactor(p,a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->lpVtbl->CommitDeferredSettings(p)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DListener_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
#define IDirectSound3DListener_AddRef(p)                        (p)->AddRef()
#define IDirectSound3DListener_Release(p)                       (p)->Release()
#define IDirectSound3DListener_GetAllParameters(p,a)            (p)->GetAllParameters(a)
#define IDirectSound3DListener_GetDistanceFactor(p,a)           (p)->GetDistanceFactor(a)
#define IDirectSound3DListener_GetDopplerFactor(p,a)            (p)->GetDopplerFactor(a)
#define IDirectSound3DListener_GetOrientation(p,a,b)            (p)->GetOrientation(a,b)
#define IDirectSound3DListener_GetPosition(p,a)                 (p)->GetPosition(a)
#define IDirectSound3DListener_GetRolloffFactor(p,a)            (p)->GetRolloffFactor(a)
#define IDirectSound3DListener_GetVelocity(p,a)                 (p)->GetVelocity(a)
#define IDirectSound3DListener_SetAllParameters(p,a,b)          (p)->SetAllParameters(a,b)
#define IDirectSound3DListener_SetDistanceFactor(p,a,b)         (p)->SetDistanceFactor(a,b)
#define IDirectSound3DListener_SetDopplerFactor(p,a,b)          (p)->SetDopplerFactor(a,b)
#define IDirectSound3DListener_SetOrientation(p,a,b,c,d,e,f,g)  (p)->SetOrientation(a,b,c,d,e,f,g)
#define IDirectSound3DListener_SetPosition(p,a,b,c,d)           (p)->SetPosition(a,b,c,d)
#define IDirectSound3DListener_SetRolloffFactor(p,a,b)          (p)->SetRolloffFactor(a,b)
#define IDirectSound3DListener_SetVelocity(p,a,b,c,d)           (p)->SetVelocity(a,b,c,d)
#define IDirectSound3DListener_CommitDeferredSettings(p)        (p)->CommitDeferredSettings()
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSound3DBuffer
//

DEFINE_GUID(IID_IDirectSound3DBuffer, 0x279AFA86, 0x4981, 0x11CE, 0xA5, 0x21, 0x00, 0x20, 0xAF, 0x0B, 0xE5, 0x60);

#undef INTERFACE
#define INTERFACE IDirectSound3DBuffer

DECLARE_INTERFACE_(IDirectSound3DBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundBuffer3D methods
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD, LPDWORD) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ LPD3DVALUE) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD) PURE;
    STDMETHOD(GetPosition)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(GetVelocity)          (THIS_ LPD3DVECTOR) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER, DWORD) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD, DWORD, DWORD) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG, DWORD) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE, DWORD) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE, D3DVALUE, D3DVALUE, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSound3DBuffer_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IDirectSound3DBuffer_Release(p)                 (p)->lpVtbl->Release(p)
#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->lpVtbl->GetAllParameters(p,a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->lpVtbl->GetConeAngles(p,a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->lpVtbl->GetConeOrientation(p,a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->lpVtbl->GetConeOutsideVolume(p,a)
#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->lpVtbl->GetPosition(p,a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->lpVtbl->GetMinDistance(p,a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->lpVtbl->GetMaxDistance(p,a)
#define IDirectSound3DBuffer_GetMode(p,a)               (p)->lpVtbl->GetMode(p,a)
#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->lpVtbl->GetVelocity(p,a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->lpVtbl->SetAllParameters(p,a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->lpVtbl->SetConeAngles(p,a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->lpVtbl->SetConeOrientation(p,a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->lpVtbl->SetConeOutsideVolume(p,a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->lpVtbl->SetPosition(p,a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->lpVtbl->SetMinDistance(p,a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->lpVtbl->SetMaxDistance(p,a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->lpVtbl->SetMode(p,a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->lpVtbl->SetVelocity(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSound3DBuffer_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IDirectSound3DBuffer_AddRef(p)                  (p)->AddRef()
#define IDirectSound3DBuffer_Release(p)                 (p)->Release()
#define IDirectSound3DBuffer_GetAllParameters(p,a)      (p)->GetAllParameters(a)
#define IDirectSound3DBuffer_GetConeAngles(p,a,b)       (p)->GetConeAngles(a,b)
#define IDirectSound3DBuffer_GetConeOrientation(p,a)    (p)->GetConeOrientation(a)
#define IDirectSound3DBuffer_GetConeOutsideVolume(p,a)  (p)->GetConeOutsideVolume(a)
#define IDirectSound3DBuffer_GetPosition(p,a)           (p)->GetPosition(a)
#define IDirectSound3DBuffer_GetMinDistance(p,a)        (p)->GetMinDistance(a)
#define IDirectSound3DBuffer_GetMaxDistance(p,a)        (p)->GetMaxDistance(a)
#define IDirectSound3DBuffer_GetMode(p,a)               (p)->GetMode(a)
#define IDirectSound3DBuffer_GetVelocity(p,a)           (p)->GetVelocity(a)
#define IDirectSound3DBuffer_SetAllParameters(p,a,b)    (p)->SetAllParameters(a,b)
#define IDirectSound3DBuffer_SetConeAngles(p,a,b,c)     (p)->SetConeAngles(a,b,c)
#define IDirectSound3DBuffer_SetConeOrientation(p,a,b,c,d) (p)->SetConeOrientation(a,b,c,d)
#define IDirectSound3DBuffer_SetConeOutsideVolume(p,a,b)(p)->SetConeOutsideVolume(a,b)
#define IDirectSound3DBuffer_SetPosition(p,a,b,c,d)     (p)->SetPosition(a,b,c,d)
#define IDirectSound3DBuffer_SetMinDistance(p,a,b)      (p)->SetMinDistance(a,b)
#define IDirectSound3DBuffer_SetMaxDistance(p,a,b)      (p)->SetMaxDistance(a,b)
#define IDirectSound3DBuffer_SetMode(p,a,b)             (p)->SetMode(a,b)
#define IDirectSound3DBuffer_SetVelocity(p,a,b,c,d)     (p)->SetVelocity(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // defined(DIRECTSOUND3D_SUPPORT)


//
// IDirectSoundCapture
//

DEFINE_GUID(IID_IDirectSoundCapture, 0xb0210781, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCapture

DECLARE_INTERFACE_(IDirectSoundCapture, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCapture methods
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundCapture_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectSoundCapture_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->lpVtbl->CreateCaptureBuffer(p,a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCapture_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectSoundCapture_AddRef(p)                       (p)->AddRef()
#define IDirectSoundCapture_Release(p)                      (p)->Release()
#define IDirectSoundCapture_CreateCaptureBuffer(p,a,b,c)    (p)->CreateCaptureBuffer(a,b,c)
#define IDirectSoundCapture_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectSoundCapture_Initialize(p,a)                 (p)->Initialize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundCaptureBuffer
//

DEFINE_GUID(IID_IDirectSoundCaptureBuffer, 0xb0210782, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundCaptureBuffer

DECLARE_INTERFACE_(IDirectSoundCaptureBuffer, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundCaptureBuffer methods
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS ) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX, DWORD, LPDWORD ) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD ) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) PURE;
    STDMETHOD(Start)                (THIS_ DWORD) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID, DWORD, LPVOID, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectSoundCaptureBuffer_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->lpVtbl->GetCaps(p,a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->lpVtbl->GetCurrentPosition(p,a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->lpVtbl->GetFormat(p,a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Lock(p,a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->lpVtbl->Start(p,a)
#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->lpVtbl->Stop(p)
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->lpVtbl->Unlock(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundCaptureBuffer_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectSoundCaptureBuffer_AddRef(p)                    (p)->AddRef()
#define IDirectSoundCaptureBuffer_Release(p)                   (p)->Release()
#define IDirectSoundCaptureBuffer_GetCaps(p,a)                 (p)->GetCaps(a)
#define IDirectSoundCaptureBuffer_GetCurrentPosition(p,a,b)    (p)->GetCurrentPosition(a,b)
#define IDirectSoundCaptureBuffer_GetFormat(p,a,b,c)           (p)->GetFormat(a,b,c)
#define IDirectSoundCaptureBuffer_GetStatus(p,a)               (p)->GetStatus(a)
#define IDirectSoundCaptureBuffer_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectSoundCaptureBuffer_Lock(p,a,b,c,d,e,f,g)        (p)->Lock(a,b,c,d,e,f,g)
#define IDirectSoundCaptureBuffer_Start(p,a)                   (p)->Start(a)
#define IDirectSoundCaptureBuffer_Stop(p)                      (p)->Stop()
#define IDirectSoundCaptureBuffer_Unlock(p,a,b,c,d)            (p)->Unlock(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundNotify
//

DEFINE_GUID(IID_IDirectSoundNotify, 0xb0210783, 0x89cd, 0x11d0, 0xaf, 0x8, 0x0, 0xa0, 0xc9, 0x25, 0xcd, 0x16);

#undef INTERFACE
#define INTERFACE IDirectSoundNotify

DECLARE_INTERFACE_(IDirectSoundNotify, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    // IDirectSoundNotify methods
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD, LPCDSBPOSITIONNOTIFY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectSoundNotify_AddRef(p)                        (p)->lpVtbl->AddRef(p)
#define IDirectSoundNotify_Release(p)                       (p)->lpVtbl->Release(p)
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->lpVtbl->SetNotificationPositions(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundNotify_QueryInterface(p,a,b)            (p)->QueryInterface(a,b)
#define IDirectSoundNotify_AddRef(p)                        (p)->AddRef()
#define IDirectSoundNotify_Release(p)                       (p)->Release()
#define IDirectSoundNotify_SetNotificationPositions(p,a,b)  (p)->SetNotificationPositions(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IKsPropertySet
//

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#ifdef __cplusplus
// 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined
struct IKsPropertySet;
#endif // __cplusplus

typedef struct IKsPropertySet *LPKSPROPERTYSET;

#define KSPROPERTY_SUPPORT_GET  0x00000001
#define KSPROPERTY_SUPPORT_SET  0x00000002

DEFINE_GUID(IID_IKsPropertySet, 0x31efac30, 0x515c, 0x11d0, 0xa9, 0xaa, 0x00, 0xaa, 0x00, 0x61, 0xbe, 0x93);

// {466F1D63-A006-492e-9B73-1014399FA370}
DEFINE_GUID(DSPROPSETID_CeMixerProp, 
0x466f1d63, 0xa006, 0x492e, 0x9b, 0x73, 0x10, 0x14, 0x39, 0x9f, 0xa3, 0x70);

// DSPROPSETID_CeMixerProp_Latency is a parameter-less read-only ULONG representing the mixer latency in milliseconds.
#define DSPROPSETID_CeMixerProp_Latency 0



#undef INTERFACE
#define INTERFACE IKsPropertySet

DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IKsPropertySet_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IKsPropertySet_Release(p)                  (p)->lpVtbl->Release(p)
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->lpVtbl->Get(p,a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->lpVtbl->Set(p,a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->lpVtbl->QuerySupport(p,a,b,c)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IKsPropertySet_QueryInterface(p,a,b)       (p)->QueryInterface(a,b)
#define IKsPropertySet_AddRef(p)                   (p)->AddRef()
#define IKsPropertySet_Release(p)                  (p)->Release()
#define IKsPropertySet_Get(p,a,b,c,d,e,f,g)        (p)->Get(a,b,c,d,e,f,g)
#define IKsPropertySet_Set(p,a,b,c,d,e,f)          (p)->Set(a,b,c,d,e,f)
#define IKsPropertySet_QuerySupport(p,a,b,c)       (p)->QuerySupport(a,b,c)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // _IKsPropertySet_

//
// Return Codes
//

#define DS_OK                           0

// The call failed because resources (such as a priority level)
// were already being used by another caller.
#define DSERR_ALLOCATED                 MAKE_DSHRESULT(10)

// The control (vol,pan,etc.) requested by the caller is not available.
#define DSERR_CONTROLUNAVAIL            MAKE_DSHRESULT(30)

// An invalid parameter was passed to the returning function
#define DSERR_INVALIDPARAM              E_INVALIDARG

// This call is not valid for the current state of this object
#define DSERR_INVALIDCALL               MAKE_DSHRESULT(50)

// An undetermined error occured inside the DirectSound subsystem
#define DSERR_GENERIC                   E_FAIL

// The caller does not have the priority level required for the function to
// succeed.
#define DSERR_PRIOLEVELNEEDED           MAKE_DSHRESULT(70)

// Not enough free memory is available to complete the operation
#define DSERR_OUTOFMEMORY               E_OUTOFMEMORY

// The specified WAVE format is not supported
#define DSERR_BADFORMAT                 MAKE_DSHRESULT(100)

// The function called is not supported at this time
#define DSERR_UNSUPPORTED               E_NOTIMPL

// No sound driver is available for use
#define DSERR_NODRIVER                  MAKE_DSHRESULT(120)

// This object is already initialized
#define DSERR_ALREADYINITIALIZED        MAKE_DSHRESULT(130)

// This object does not support aggregation
#define DSERR_NOAGGREGATION             CLASS_E_NOAGGREGATION

// The buffer memory has been lost, and must be restored.
#define DSERR_BUFFERLOST                MAKE_DSHRESULT(150)

// Another app has a higher priority level, preventing this call from
// succeeding.
#define DSERR_OTHERAPPHASPRIO           MAKE_DSHRESULT(160)

// This object has not been initialized
#define DSERR_UNINITIALIZED             MAKE_DSHRESULT(170)

// The requested COM interface is not available
#define DSERR_NOINTERFACE               E_NOINTERFACE

//
// Flags
//

#define DSCAPS_PRIMARYMONO          0x00000001
#define DSCAPS_PRIMARYSTEREO        0x00000002
#define DSCAPS_PRIMARY8BIT          0x00000004
#define DSCAPS_PRIMARY16BIT         0x00000008
#define DSCAPS_CONTINUOUSRATE       0x00000010
#define DSCAPS_EMULDRIVER           0x00000020
#define DSCAPS_CERTIFIED            0x00000040
#define DSCAPS_SECONDARYMONO        0x00000100
#define DSCAPS_SECONDARYSTEREO      0x00000200
#define DSCAPS_SECONDARY8BIT        0x00000400
#define DSCAPS_SECONDARY16BIT       0x00000800

#define DSBPLAY_LOOPING             0x00000001
      
#define DSBSTATUS_PLAYING           0x00000001
#define DSBSTATUS_BUFFERLOST        0x00000002
#define DSBSTATUS_LOOPING           0x00000004

#define DSBLOCK_FROMWRITECURSOR     0x00000001
#define DSBLOCK_ENTIREBUFFER        0x00000002

#define DSSCL_NORMAL                0x00000001
#define DSSCL_PRIORITY              0x00000002
#define DSSCL_EXCLUSIVE             0x00000003
#define DSSCL_WRITEPRIMARY          0x00000004

#define DS3DMODE_NORMAL             0x00000000
#define DS3DMODE_HEADRELATIVE       0x00000001
#define DS3DMODE_DISABLE            0x00000002

#define DS3D_IMMEDIATE              0x00000000
#define DS3D_DEFERRED               0x00000001

#define DS3D_MINDISTANCEFACTOR      0.0f
#define DS3D_MAXDISTANCEFACTOR      10.0f
#define DS3D_DEFAULTDISTANCEFACTOR  1.0f

#define DS3D_MINROLLOFFFACTOR       0.0f
#define DS3D_MAXROLLOFFFACTOR       10.0f
#define DS3D_DEFAULTROLLOFFFACTOR   1.0f

#define DS3D_MINDOPPLERFACTOR       0.0f
#define DS3D_MAXDOPPLERFACTOR       10.0f
#define DS3D_DEFAULTDOPPLERFACTOR   1.0f

#define DS3D_DEFAULTMINDISTANCE     1.0f
#define DS3D_DEFAULTMAXDISTANCE     1000000000.0f

#define DS3D_MINCONEANGLE           0
#define DS3D_MAXCONEANGLE           360
#define DS3D_DEFAULTCONEANGLE       360

#define DS3D_DEFAULTCONEOUTSIDEVOLUME   0

#define DSBCAPS_PRIMARYBUFFER       0x00000001
#define DSBCAPS_STATIC              0x00000002
#define DSBCAPS_LOCHARDWARE         0x00000004
#define DSBCAPS_LOCSOFTWARE         0x00000008
#define DSBCAPS_CTRL3D              0x00000010
#define DSBCAPS_CTRLFREQUENCY       0x00000020
#define DSBCAPS_CTRLPAN             0x00000040
#define DSBCAPS_CTRLVOLUME          0x00000080
#define DSBCAPS_CTRLPOSITIONNOTIFY  0x00000100
#define DSBCAPS_CTRLDEFAULT         0x000000E0
#define DSBCAPS_CTRLALL             0x000001F0
#define DSBCAPS_STICKYFOCUS         0x00004000
#define DSBCAPS_GLOBALFOCUS         0x00008000 
#define DSBCAPS_GETCURRENTPOSITION2 0x00010000
#define DSBCAPS_MUTE3DATMAXDISTANCE 0x00020000

#define DSCBCAPS_WAVEMAPPED         0x80000000

#define DSSPEAKER_HEADPHONE         0x00000001
#define DSSPEAKER_MONO              0x00000002
#define DSSPEAKER_QUAD              0x00000003
#define DSSPEAKER_STEREO            0x00000004
#define DSSPEAKER_SURROUND          0x00000005

#define DSSPEAKER_GEOMETRY_MIN      0x00000005  //   5 degrees
#define DSSPEAKER_GEOMETRY_NARROW   0x0000000A  //  10 degrees
#define DSSPEAKER_GEOMETRY_WIDE     0x00000014  //  20 degrees
#define DSSPEAKER_GEOMETRY_MAX      0x000000B4  // 180 degrees

#define DSSPEAKER_COMBINED(c, g)    ((DWORD)(((BYTE)(c)) | ((DWORD)((BYTE)(g))) << 16))
#define DSSPEAKER_CONFIG(a)         ((BYTE)(a))
#define DSSPEAKER_GEOMETRY(a)       ((BYTE)(((DWORD)(a) >> 16) & 0x00FF))

#define DSCCAPS_EMULDRIVER          0x00000020

#define DSCBLOCK_ENTIREBUFFER       0x00000001

#define DSCBSTATUS_CAPTURING        0x00000001
#define DSCBSTATUS_LOOPING          0x00000002

#define DSCBSTART_LOOPING           0x00000001

#define DSBFREQUENCY_MIN            100
#define DSBFREQUENCY_MAX            100000
#define DSBFREQUENCY_ORIGINAL       0

#define DSBPAN_LEFT                 -10000
#define DSBPAN_CENTER               0
#define DSBPAN_RIGHT                10000

#define DSBVOLUME_MIN               -10000
#define DSBVOLUME_MAX               0

#define DSBSIZE_MIN                 4
#define DSBSIZE_MAX                 0x0FFFFFFF

#define DSBPN_OFFSETSTOP            0xFFFFFFFF

#ifdef __cplusplus
};
#endif // __cplusplus

#endif  // __DSOUND_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvdevcod.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//------------------------------------------------------------------------------
// File: DVDevCod.h
//
// Desc: List of standard DVD-Video event codes and the expected params.
//
//------------------------------------------------------------------------------

#ifndef _INC_DVDEVCOD_H_
#define _INC_DVDEVCOD_H_

#define EC_DVDBASE                          0x0100

#ifndef EXCLUDE_DVDEVCODE_ENUMS

typedef enum _tagDVD_ERROR {
    DVD_ERROR_Unexpected=1,         // Something unexpected happened, perhaps content
                                    //   is incorrectly authored.  Playback is stopped.
    DVD_ERROR_CopyProtectFail=2,    // Key exchange for DVD copy protection failed. 
                                    //   Playback is stopped.
    DVD_ERROR_InvalidDVD1_0Disc=3,  // DVD-Video disc is incorrectly authored for v1.0 
                                    //   of spec. Playback is stopped.
    DVD_ERROR_InvalidDiscRegion=4,  // The Disc cannot be played because the disc is not
                                    // authored to play in system region.
                                    // The region mismatch may be fixable by 
                                    // changing the system region with dvdrgn.exe
    DVD_ERROR_LowParentalLevel=5,   // Player parental level is lower than the lowest parental
                                    //   level available in the DVD content. Playback is stopped.
    DVD_ERROR_MacrovisionFail=6,    // Macrovision Distribution Failed.
                                    // Playback is stopped.
    DVD_ERROR_IncompatibleSystemAndDecoderRegions=7,
                                    // No discs can be played because the system region
                                    // does not match the decoder region.
    DVD_ERROR_IncompatibleDiscAndDecoderRegions=8
                                    // The disc cannot be played because the disc is
                                    // not authored to be played in the decoder's region
} DVD_ERROR;

typedef enum _tagDVD_WARNING {
    DVD_WARNING_InvalidDVD1_0Disc=1,// DVD-Video disc is incorrectly authored. Playback
                                    //   can continue, but unexpected behavior may occur.
    DVD_WARNING_FormatNotSupported=2,// A decoder would not support the current format.  Playback
                                    //   of a stream (audio, video of SP) may not function.
    DVD_WARNING_IllegalNavCommand=3,// The internal DVD navigation command processor attempted to 
                                    //   process an illegal command.
    DVD_WARNING_Open = 4,           // File Open Failed
    DVD_WARNING_Seek = 5,           // File Seek Failed
    DVD_WARNING_Read = 6            // File Read Failed
} DVD_WARNING;

#endif

// DVD-Video event codes
// ======================
//
// All DVD-Video event are always passed on to the application, and are 
// never processed by the filter graph


#define EC_DVD_DOMAIN_CHANGE                    (EC_DVDBASE + 0x01)
// Parameters: ( DWORD, void ) 
// lParam1 is enum DVD_DOMAIN, and indicates the player's new domain
//
// Raised from following domains: all
//
// Signaled when ever the DVD player changes domains.


#define EC_DVD_TITLE_CHANGE                     (EC_DVDBASE + 0x02)
// Parameters: ( DWORD, void ) 
// lParam1 is the new title number.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Indicates when the current title number changes.  Title numbers
// range 1 to 99.  This indicates the TTN, which is the title number
// with respect to the whole disc, not the VTS_TTN which is the title
// number with respect to just a current VTS.


#define EC_DVD_CHAPTER_START                   (EC_DVDBASE + 0x03)
// Parameters: ( DWORD, void ) 
// lParam1 is the new chapter number (which is the program number for 
// One_Sequential_PGC_Titles).
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signales that DVD player started playback of a new program in the Title 
// domain.  This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_AUDIO_STREAM_CHANGE              (EC_DVDBASE + 0x04)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user audio stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user audio stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.
// Audio stream numbers range from 0 to 7.  Stream 0xffffffff
// indicates that no stream is selected.

#define EC_DVD_SUBPICTURE_STREAM_CHANGE         (EC_DVDBASE + 0x05)
// Parameters: ( DWORD, void ) 
// lParam1 is the new user subpicture stream number.
//
// Raised from following domains: all
//
// Signaled when ever the current user subpicture stream number changes for the main 
// title.  This can be changed automatically with a navigation command on disc
// as well as through IDVDAnnexJ.  
// Subpicture stream numbers range from 0 to 31.  Stream 0xffffffff
// indicates that no stream is selected.  

#define EC_DVD_ANGLE_CHANGE                     (EC_DVDBASE + 0x06)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available angles.
// lParam2 is the current user angle number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available angles changes, or  
//   b) the current user angle number changes.
// Current angle number can be changed automatically with navigation command 
// on disc as well as through IDVDAnnexJ.
// When the number of available angles is 1, the current video is not multiangle.
// Angle numbers range from 1 to 9.


#define EC_DVD_BUTTON_CHANGE                    (EC_DVDBASE + 0x07)
// Parameters: ( DWORD, DWORD ) 
// lParam1 is the number of available buttons.
// lParam2 is the current selected button number.
//
// Raised from following domains: all
//
// Signaled when ever either 
//   a) the number of available buttons changes, or  
//   b) the current selected button number changes.
// The current selected button can be changed automatically with navigation 
// commands on disc as well as through IDVDAnnexJ.  
// Button numbers range from 1 to 36.  Selected button number 0 implies that
// no button is selected.  Note that these button numbers enumerate all 
// available button numbers, and do not always correspond to button numbers
// used for IDVDAnnexJ::ButtonSelectAndActivate since only a subset of buttons
// may be activated with ButtonSelectAndActivate.


#define EC_DVD_VALID_UOPS_CHANGE                (EC_DVDBASE + 0x08)
// Parameters: ( DWORD, void ) 
// lParam1 is a VALID_UOP_SOMTHING_OR_OTHER bit-field stuct which indicates
//   which IDVDAnnexJ commands are explicitly disable by the DVD disc.
//
// Raised from following domains: all
//
// Signaled when ever the available set of IDVDAnnexJ methods changes.  This
// only indicates which operations are explicited disabled by the content on 
// the DVD disc, and does not guarentee that it is valid to call methods 
// which are not disabled.  For example, if no buttons are currently present,
// IDVDAnnexJ::ButtonActivate() won't work, even though the buttons are not
// explicitly disabled. 


#define EC_DVD_STILL_ON                         (EC_DVDBASE + 0x09)
// Parameters: ( BOOL, DWORD ) 
// lParam1 == 0  -->  buttons are available, so StillOff won't work
// lParam1 == 1  -->  no buttons available, so StillOff will work
// lParam2 indicates the number of seconds the still will last, with 0xffffffff 
//   indicating an infinite still (wait till button or StillOff selected).
//
// Raised from following domains: all
//
// Signaled at the beginning of any still: PGC still, Cell Still, or VOBU Still.
// Note that all combinations of buttons and still are possible (buttons on with
// still on, buttons on with still off, button off with still on, button off
// with still off).

#define EC_DVD_STILL_OFF                         (EC_DVDBASE + 0x0a)
// Parameters: ( void, void ) 
//
//   Indicating that any still that is currently active
//   has been released.
//
// Raised from following domains: all
//
// Signaled at the end of any still: PGC still, Cell Still, or VOBU Still.
//

#define EC_DVD_CURRENT_TIME                     (EC_DVDBASE + 0x0b)
// Parameters: ( DWORD, BOOL ) 
// lParam1 is a DVD_TIMECODE which indicates the current 
//   playback time code in a BCD HH:MM:SS:FF format.
// lParam2 == 0  -->  time code is 25 frames/sec
// lParam2 == 1  -->  time code is 30 frames/sec (non-drop).
// lParam2 == 2  -->  time code is invalid (current playback time 
//                    cannot be determined for current title)
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.
// This is only signaled for One_Sequential_PGC_Titles.


#define EC_DVD_ERROR                            (EC_DVDBASE + 0x0c)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_ERROR which notifies the app of some error condition.
//
// Raised from following domains: all
//

#define EC_DVD_WARNING                           (EC_DVDBASE + 0x0d)
// Parameters: ( DWORD, void) 
// lParam1 is an enum DVD_WARNING which notifies the app of some warning condition.
//
// Raised from following domains: all
//

#define EC_DVD_CHAPTER_AUTOSTOP                  (EC_DVDBASE + 0x0e)
// Parameters: (BOOL, void)
// lParam1 is a BOOL which indicates the reason for the cancellation of ChapterPlayAutoStop
// lParam1 == 0 indicates successful completion of ChapterPlayAutoStop
// lParam1 == 1 indicates that ChapterPlayAutoStop is being cancelled as a result of another
//            IDVDControl call or the end of content has been reached & no more chapters
//            can be played.
//  Indicating that playback is stopped as a result of a call
//  to IDVDControl::ChapterPlayAutoStop()
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_NO_FP_PGC                         (EC_DVDBASE + 0x0f)
//  Parameters : (void, void)
//
//  Raised from the following domains : FP_DOM
//
//  Indicates that the DVD disc does not have a FP_PGC (First Play Program Chain)
//  and the DVD Navigator will not automatically load any PGC and start playback.
//

#define EC_DVD_PLAYBACK_RATE_CHANGE              (EC_DVDBASE + 0x10)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new playback rate.
//  lParam1 < 0 indicates reverse playback mode.
//  lParam1 > 0 indicates forward playback mode
//  Value of lParam1 is the actual playback rate multiplied by 10000.
//  i.e. lParam1 = rate * 10000
//
//  Raised from the following domains : TT_DOM
//
//  Indicates that a rate change in playback has been initiated and the parameter
//  lParam1 indicates the new playback rate that is being used.
//

#define EC_DVD_PARENTAL_LEVEL_CHANGE            (EC_DVDBASE + 0x11)
//  Parameters : (LONG, void)
//  lParam1 is a LONG indicating the new parental level.
//
//  Raised from the following domains : VMGM_DOM
//
//  Indicates that an authored Nav command has changed the parental level
//  setting in the player.
//

#define EC_DVD_PLAYBACK_STOPPED                 (EC_DVDBASE + 0x12)
//  Parameters : (void, void)
//
//  Raised from the following domains : All Domains
//
// Indicates that playback has been stopped as the Navigator has completed
// playback of the pgc and did not find any other branching instruction for
// subsequent playback.
//

#define EC_DVD_ANGLES_AVAILABLE                 (EC_DVDBASE + 0x13)
//  Parameters : (BOOL, void)
//  lParam1 == 0 indicates that playback is not in an angle block and angles are
//             not available
//  lParam1 == 1 indicates that an angle block is being played back and angle changes
//             can be performed.
//
//  Indicates whether an angle block is being played and if angle changes can be 
//  performed. However, angle changes are not restricted to angle blocks and the
//  manifestation of the angle change can be seen only in an angle block.

#define EC_DVD_PLAYPERIOD_AUTOSTOP              (EC_DVDBASE + 0x14)
// Parameters: (void, void)
// Sent when the PlayPeriodInTitle completes or is cancelled
//
// Raised from following domains : DVD_DOMAIN_TITLE
//

#define EC_DVD_BUTTON_AUTO_ACTIVATED                 (EC_DVDBASE + 0x15)
// Parameters: (DWORD button, void)
// Sent when a button is automatically activated
//
// Raised from following domains : DVD_DOMAIN_MENU
//

#define EC_DVD_CMD_START                 (EC_DVDBASE + 0x16)
// Parameters: (CmdID, HRESULT)
// Sent when a command begins
//

#define EC_DVD_CMD_END                 (EC_DVDBASE + 0x17)
// Parameters: (CmdID, HRESULT)
// Sent when a command completes
//

#define EC_DVD_DISC_EJECTED                (EC_DVDBASE + 0x18)
// Parameters: none
// Sent when the nav detects that a disc was ejected and stops the playback
// The app does not need to take any action to stop the playback.
//

#define EC_DVD_DISC_INSERTED                (EC_DVDBASE + 0x19)
// Parameters: none
// Sent when the nav detects that a disc was inserted and the nav begins playback
// The app does not need to take any action to start the playback.
//

#define EC_DVD_CURRENT_HMSF_TIME                     (EC_DVDBASE + 0x1a)
// Parameters: ( ULONG, ULONG ) 
// lParam2 contains a union of the DVD_TIMECODE_FLAGS
// lParam1 contains a DVD_HMSF_TIMECODE.  Assign lParam1 to a ULONG then cast the
// ULONG as a DVD_HMSF_TIMECODE to use its values.
//
// Raised from following domains: DVD_DOMAIN_Title
//
// Signaled at the beginning of every VOBU, which occurs every .4 to 1.0 sec.

#define EC_DVD_KARAOKE_MODE                     (EC_DVDBASE + 0x1b)
// Parameters: ( BOOL, reserved ) 
// lParam1 is either TRUE (a karaoke track is being played) or FALSE (no karaoke data is being played).
//

#endif // _INC_DVDEVCOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvdmedia.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// dvdmedia.h
//
// Contains typedefs and #defines necessary for user mode (ring 3) DVD 
// filters and applications.
// This is should be included in the DirectShow SDK for user mode filters.
// The types defined here should be kept in synch with ksmedia.h WDM DDK for
// kernel mode filters.
//

#ifndef __DVDMEDIA_H__
#define __DVDMEDIA_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// -----------------------------------------------------------------------
// AC-3 definition for the AM_KSPROPSETID_AC3 property set
// -----------------------------------------------------------------------

typedef enum {
	AM_PROPERTY_AC3_ERROR_CONCEALMENT = 1,
	AM_PROPERTY_AC3_ALTERNATE_AUDIO,
	AM_PROPERTY_AC3_DOWNMIX,
	AM_PROPERTY_AC3_BIT_STREAM_MODE,
	AM_PROPERTY_AC3_DIALOGUE_LEVEL,
	AM_PROPERTY_AC3_LANGUAGE_CODE,
	AM_PROPERTY_AC3_ROOM_TYPE
} AM_PROPERTY_AC3;

typedef struct  {
	BOOL        fRepeatPreviousBlock;
	BOOL        fErrorInCurrentBlock;
} AM_AC3_ERROR_CONCEALMENT, *PAM_AC3_ERROR_CONCEALMENT;

typedef struct {
	BOOL    fStereo;
	ULONG   DualMode;
} AM_AC3_ALTERNATE_AUDIO, *PAM_AC3_ALTERNATE_AUDIO;

#define AM_AC3_ALTERNATE_AUDIO_1     1
#define AM_AC3_ALTERNATE_AUDIO_2     2
#define AM_AC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
	BOOL        fDownMix;
	BOOL        fDolbySurround;
} AM_AC3_DOWNMIX, *PAM_AC3_DOWNMIX;

typedef struct {
	LONG        BitStreamMode;
} AM_AC3_BIT_STREAM_MODE, *PAM_AC3_BIT_STREAM_MODE;

#define AM_AC3_SERVICE_MAIN_AUDIO            0
#define AM_AC3_SERVICE_NO_DIALOG             1
#define AM_AC3_SERVICE_VISUALLY_IMPAIRED     2
#define AM_AC3_SERVICE_HEARING_IMPAIRED      3
#define AM_AC3_SERVICE_DIALOG_ONLY           4
#define AM_AC3_SERVICE_COMMENTARY            5
#define AM_AC3_SERVICE_EMERGENCY_FLASH       6
#define AM_AC3_SERVICE_VOICE_OVER            7

typedef struct {
	ULONG   DialogueLevel;
} AM_AC3_DIALOGUE_LEVEL, *PAM_AC3_DIALOGUE_LEVEL;

typedef struct {
	BOOL    fLargeRoom;
} AM_AC3_ROOM_TYPE, *PAM_AC3_ROOM_TYPE;


// -----------------------------------------------------------------------
// subpicture definition for the AM_KSPROPSETID_DvdSubPic property set
// -----------------------------------------------------------------------

typedef enum {
	AM_PROPERTY_DVDSUBPIC_PALETTE,
	AM_PROPERTY_DVDSUBPIC_HLI,
	AM_PROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} AM_PROPERTY_DVDSUBPIC;

typedef struct _AM_DVD_YUV {
	UCHAR   Reserved;
	UCHAR   Y;
	UCHAR   U;
	UCHAR   V;
} AM_DVD_YUV, *PAM_DVD_YUV;

typedef struct _AM_PROPERTY_SPPAL {
	AM_DVD_YUV sppal[16];
} AM_PROPERTY_SPPAL, *PAM_PROPERTY_SPPAL;

typedef struct _AM_COLCON {
	UCHAR emph1col:4;
	UCHAR emph2col:4;
	UCHAR backcol:4;
	UCHAR patcol:4;
	UCHAR emph1con:4;
	UCHAR emph2con:4;
	UCHAR backcon:4;
	UCHAR patcon:4;

} AM_COLCON, *PAM_COLCON;

typedef struct _AM_PROPERTY_SPHLI {
	USHORT     HLISS;      //
	USHORT     Reserved;
	ULONG      StartPTM;   // start presentation time in x/90000
	ULONG      EndPTM;     // end PTM in x/90000
	USHORT     StartX;
	USHORT     StartY;
	USHORT     StopX;
	USHORT     StopY;
	AM_COLCON  ColCon;     // color contrast description (4 bytes as given in HLI)
} AM_PROPERTY_SPHLI, *PAM_PROPERTY_SPHLI;

typedef BOOL AM_PROPERTY_COMPOSIT_ON, *PAM_PROPERTY_COMPOSIT_ON;



// -----------------------------------------------------------------------
// copy protection definitions
// -----------------------------------------------------------------------

// AM_UseNewCSSKey for the dwTypeSpecificFlags in IMediaSample2 to indicate
// the exact point in a stream after which to start applying a new CSS key.
// This is typically sent on an empty media sample just before attempting 
// to renegotiate a CSS key.
#define AM_UseNewCSSKey    0x1

//
// AM_KSPROPSETID_CopyProt property set definitions
//
typedef enum {
	AM_PROPERTY_DVDCOPY_CHLG_KEY = 0x01,
	AM_PROPERTY_DVDCOPY_DVD_KEY1,
	AM_PROPERTY_DVDCOPY_DEC_KEY2,
	AM_PROPERTY_DVDCOPY_TITLE_KEY,
	AM_PROPERTY_COPY_MACROVISION,
	AM_PROPERTY_DVDCOPY_REGION,
	AM_PROPERTY_DVDCOPY_SET_COPY_STATE,
	AM_PROPERTY_DVDCOPY_DISC_KEY = 0x80
} AM_PROPERTY_DVDCOPYPROT;

typedef struct _AM_DVDCOPY_CHLGKEY {
	BYTE ChlgKey[10];
	BYTE Reserved[2];
} AM_DVDCOPY_CHLGKEY, *PAM_DVDCOPY_CHLGKEY;

typedef struct _AM_DVDCOPY_BUSKEY {
	BYTE BusKey[5];
	BYTE Reserved[1];
} AM_DVDCOPY_BUSKEY, *PAM_DVDCOPY_BUSKEY;

typedef struct _AM_DVDCOPY_DISCKEY {
	BYTE DiscKey[2048];
} AM_DVDCOPY_DISCKEY, *PAM_DVDCOPY_DISCKEY;

typedef struct AM_DVDCOPY_TITLEKEY {
	ULONG KeyFlags;
	ULONG Reserved1[2];
    UCHAR TitleKey[6];
	UCHAR Reserved2[2];
} AM_DVDCOPY_TITLEKEY, *PAM_DVDCOPY_TITLEKEY;

typedef struct _AM_COPY_MACROVISION {
	ULONG MACROVISIONLevel;
} AM_COPY_MACROVISION, *PAM_COPY_MACROVISION;

typedef struct AM_DVDCOPY_SET_COPY_STATE {
	ULONG DVDCopyState;
} AM_DVDCOPY_SET_COPY_STATE, *PAM_DVDCOPY_SET_COPY_STATE;

typedef enum {
	AM_DVDCOPYSTATE_INITIALIZE,
	AM_DVDCOPYSTATE_INITIALIZE_TITLE,	// indicates we are starting a title
										// key copy protection sequence
	AM_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
	AM_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
	AM_DVDCOPYSTATE_DONE
} AM_DVDCOPYSTATE;

typedef enum {
	AM_MACROVISION_DISABLED,
	AM_MACROVISION_LEVEL1,
	AM_MACROVISION_LEVEL2,
	AM_MACROVISION_LEVEL3
} AM_COPY_MACROVISION_LEVEL, *PAM_COPY_MACROVISION_LEVEL;


// CSS region stucture
typedef struct _DVD_REGION {
    UCHAR CopySystem;
    UCHAR RegionData;
	UCHAR SystemRegion;
    UCHAR Reserved;
} DVD_REGION, *PDVD_REGION;	

//
// CGMS Copy Protection Flags
//

#define AM_DVD_CGMS_RESERVED_MASK      0x00000078

#define AM_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define AM_DVD_CGMS_COPY_PERMITTED     0x00000000
#define AM_DVD_CGMS_COPY_ONCE          0x00000010
#define AM_DVD_CGMS_NO_COPY            0x00000018

#define AM_DVD_COPYRIGHT_MASK          0x00000040
#define AM_DVD_NOT_COPYRIGHTED         0x00000000
#define AM_DVD_COPYRIGHTED             0x00000040

#define AM_DVD_SECTOR_PROTECT_MASK     0x00000020
#define AM_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define AM_DVD_SECTOR_PROTECTED        0x00000020


//
// AM_KSPROPSETID_RendererPosition property set definitions
//
typedef enum {
	AM_PROPERTY_CurrentPosition = 0x01,
	AM_PROPERTY_DiscontinuityPosition,
	AM_PROPERTY_Delay,
} AM_PROPERTY_RENDERER_POSITION;



// -----------------------------------------------------------------------
// video format blocks
// -----------------------------------------------------------------------

enum AM_MPEG2Level {
	AM_MPEG2Level_Low = 1,
	AM_MPEG2Level_Main,
	AM_MPEG2Level_High1440,
	AM_MPEG2Level_High
};

enum AM_MPEG2Profile {
	AM_MPEG2Profile_Simple = 1,
	AM_MPEG2Profile_Main,
	AM_MPEG2Profile_SNRScalable,
	AM_MPEG2Profile_SpatiallyScalable,
	AM_MPEG2Profile_High
};


#define AMMPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image 
						//  based on pan-scan vectors in picture_display_extension 
						//  and change the picture aspect ratio accordingly.
#define AMMPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output 
						//  pin for DVD style closed caption data found in GOP layer of field 1
#define AMMPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output 
						//  pin for DVD style closed caption data found in GOP layer of field 2
#define AMMPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top 
						//  and bottom of the video.
#define AMMPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
						//  indicates that "camera mode" was used.
#define AMMPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should 
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.


typedef struct tagMPEG2VIDEOINFO {
	VIDEOINFOHEADER2    hdr;
	DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
	DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
	DWORD               dwProfile;              // use enum MPEG2Profile   
	DWORD               dwLevel;                // use enum MPEG2Level
	DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
	DWORD               dwSequenceHeader[1];    // DWORD instead of Byte for alignment purposes
												//   For MPEG-2, if a sequence_header is included, the sequence_extension 
												//   should also be included
} MPEG2VIDEOINFO;

#define SIZE_MPEG2VIDEOINFO(pv) (FIELD_OFFSET(MPEG2VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)


//===================================================================================
// flags for dwTypeSpecificFlags in AM_SAMPLE2_PROPERTIES which define type specific
// data in IMediaSample2
//===================================================================================

#define AM_VIDEO_FLAG_FIELD_MASK	    0x0003L	// use this mask to check whether the sample is field1 or field2 or frame
#define AM_VIDEO_FLAG_INTERLEAVED_FRAME	    0x0000L     // the sample is a frame (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1		    0x0001L	// the sample is field1 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD2		    0x0002L	// the sample is the field2 (remember to use AM_VIDEO_FLAG_FIELD_MASK when using this)
#define AM_VIDEO_FLAG_FIELD1FIRST	    0x0004L	// if set means display field1 first, else display field2 first.
							// this bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_WEAVE    		    0x0008L	// if set use bob display mode else weave
#define AM_VIDEO_FLAG_IPB_MASK		    0x0030L	// use this mask to check whether the sample is I, P or B
#define AM_VIDEO_FLAG_I_SAMPLE		    0x0000L     // I Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_P_SAMPLE		    0x0010L	// P Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_B_SAMPLE		    0x0020L	// B Sample (remember to use AM_VIDEO_FLAG_IPB_MASK when using this)
#define AM_VIDEO_FLAG_REPEAT_FIELD	    0x0040L	// if set means display the field which has been displayed first again after displaying 
							// both fields first. This bit is irrelavant for 1FieldPerSample mode
#define AM_VIDEO_FLAG_NO_OUTPUT         0x80000000 // Decode, but don't display, this frame - can't be used with codecs which require the previous frame's
                                                   // data.  Useful for WMV output from the DMO, when the video-renderer's video-window is hidden, but the
                                                   // DMO was given the primary surface (visible display-memory) to draw into.

// -----------------------------------------------------------------------
// AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------

typedef enum {
	AM_RATE_SimpleRateChange=1,   // rw, use AM_SimpleRateChange
	AM_RATE_ExactRateChange=2,	// rw, use AM_ExactRateChange
	AM_RATE_MaxFullDataRate=3,	// r, use AM_MaxFullDataRate
	AM_RATE_Step=4			// w, use AM_Step
} AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
	// this is the simplest mechinism to set a time stamp rate change on
	// a filter (simplest for the person setting the rate change, harder
	// for the filter doing the rate change).  
	REFERENCE_TIME	StartTime;  //stream time at which to start this rate
	LONG		Rate;       //new rate * 10000 (decimal)
} AM_SimpleRateChange;

typedef struct {
	REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
	LONG		Rate;       //new rate * 10000 (decimal)
} AM_ExactRateChange;

typedef LONG AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD AM_Step; // number of frame to step


#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __DVDMEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvdcom.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for dvdcom.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __dvdcom_h__
#define __dvdcom_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dvdcom_0000_0000 */
/* [local] */ 

typedef unsigned char UINT8;

typedef unsigned short UINT16;

typedef unsigned int UINT24;

typedef unsigned int UINT32;

typedef unsigned __int64 UINT64;

typedef signed char INT8;

typedef short INT16;

typedef int INT32;

typedef __int64 INT64;

typedef /* [public] */ struct __MIDL___MIDL_itf_dvdcom_0000_0000_0001
    {
    UINT8 key[ 5 ];
    } 	CSS_KEY;

typedef /* [public] */ struct __MIDL___MIDL_itf_dvdcom_0000_0000_0002
    {
    UINT8 challenge[ 10 ];
    } 	CSS_CHALLENGE;

typedef /* [public] */ struct __MIDL___MIDL_itf_dvdcom_0000_0000_0003
    {
    UINT32 sdks[ 512 ];
    } 	CSS_SDKS;

#define DVDLBSZ	2048
#define	DVD_SELECT_UPPER 0
#define	DVD_SELECT_LOWER 1
#define	DVD_SELECT_LEFT  2
#define	DVD_SELECT_RIGHT 3


extern RPC_IF_HANDLE __MIDL_itf_dvdcom_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdcom_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvdnav.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for dvdnav.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dvdnav_h__
#define __dvdnav_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDVDUserOperation_FWD_DEFINED__
#define __IDVDUserOperation_FWD_DEFINED__
typedef interface IDVDUserOperation IDVDUserOperation;
#endif 	/* __IDVDUserOperation_FWD_DEFINED__ */


#ifndef __IDVDNavigationManager_FWD_DEFINED__
#define __IDVDNavigationManager_FWD_DEFINED__
typedef interface IDVDNavigationManager IDVDNavigationManager;
#endif 	/* __IDVDNavigationManager_FWD_DEFINED__ */


#ifndef __IDVDNavigatorSink_FWD_DEFINED__
#define __IDVDNavigatorSink_FWD_DEFINED__
typedef interface IDVDNavigatorSink IDVDNavigatorSink;
#endif 	/* __IDVDNavigatorSink_FWD_DEFINED__ */


#ifndef __DVDNavigationManager_FWD_DEFINED__
#define __DVDNavigationManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DVDNavigationManager DVDNavigationManager;
#else
typedef struct DVDNavigationManager DVDNavigationManager;
#endif /* __cplusplus */

#endif 	/* __DVDNavigationManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "dvdcom.h"
#include "dvdata.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dvdnav_0000_0000 */
/* [local] */ 

#define	DVD_PROGRAM_PREVIOUS 0
#define	DVD_PROGRAM_NEXT 1
#define	DVD_PROGRAM_TOP 2
#define	DVD_MENU_TITLE 0
#define	DVD_MENU_ROOT 1
#define	DVD_MENU_SUBPICTURE 2
#define	DVD_MENU_AUDIO 3
#define	DVD_MENU_ANGLE 4
#define	DVD_MENU_PTT 5
#define	SPRM_M_LCD 0
#define	SPRM_ASTN 1
#define	SPRM_SPSTN 2
#define	SPRM_AGLN 3
#define	SPRM_TTN 4
#define	SPRM_VTS_TTN 5
#define	SPRM_TT_PGCN 6
#define	SPRM_PTTN 7
#define	SPRM_HL_BTNN 8
#define	SPRM_NV_TMR 9
#define	SPRM_NV_TMR_PGCN 10
#define	SPRM_P_AMXMD 11
#define	SPRM_CTY_CD 12
#define	SPRM_PTL_LVL 13
#define	SPRM_P_CFG_VIDEO 14
#define	SPRM_P_CFG_AUDIO 15
#define	SPRM_INI_LCD_AST 16
#define	SPRM_INI_LCD_EXT_AST 17
#define	SPRM_INI_LCD_SPST 18
#define	SPRM_INI_LCD_EXT_SPST 19
#define	SPRM_REGION 20
#ifndef _DVD_SCANCAPS_DEFINED_
#define _DVD_SCANCAPS_DEFINED_
#define DVD_SCANCAP_FORWARD_SCAN		0x1
#define DVD_SCANCAP_FORWARD_SLOW		0x2
#define DVD_SCANCAP_FORWARD_SINGLE	0x4
#define DVD_SCANCAP_BACKWARD_SCAN	0x8
#define DVD_SCANCAP_BACKWARD_SLOW	0x10
#define DVD_SCANCAP_BACKWARD_SINGLE	0x20
#endif
typedef /* [public][public] */ struct __MIDL___MIDL_itf_dvdnav_0000_0000_0001
    {
    UINT8 userData[ 201 ];
    } 	DVDUserGOPData;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_dvdnav_0000_0000_0002
    {	DVD_STOPPED	= 0,
	DVD_PAUSED	= ( DVD_STOPPED + 1 ) ,
	DVD_STILLED	= ( DVD_PAUSED + 1 ) ,
	DVD_NORMAL_PLAY	= ( DVD_STILLED + 1 ) ,
	DVD_FORWARD_SCAN	= ( DVD_NORMAL_PLAY + 1 ) ,
	DVD_FORWARD_SLOW	= ( DVD_FORWARD_SCAN + 1 ) ,
	DVD_FORWARD_SINGLE	= ( DVD_FORWARD_SLOW + 1 ) ,
	DVD_BACKWARD_SCAN	= ( DVD_FORWARD_SINGLE + 1 ) ,
	DVD_BACKWARD_SLOW	= ( DVD_BACKWARD_SCAN + 1 ) ,
	DVD_BACKWARD_SINGLE	= ( DVD_BACKWARD_SLOW + 1 ) 
    } 	EDDVDPlaybackState;




extern RPC_IF_HANDLE __MIDL_itf_dvdnav_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdnav_0000_0000_v0_0_s_ifspec;

#ifndef __IDVDUserOperation_INTERFACE_DEFINED__
#define __IDVDUserOperation_INTERFACE_DEFINED__

/* interface IDVDUserOperation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDUserOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07C89F52-C72E-11D0-A985-00A0C9050598")
    IDVDUserOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TitlePlay( 
            BYTE byteTitleNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PartPlay( 
            BYTE byteTitleNumber,
            USHORT uhPartOfTheTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimePlay( 
            BYTE byteTitleNumber,
            UINT uiBCDTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeSearch( 
            UINT uiBCDTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PTTSearch( 
            USHORT uhPartOfTheTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProgramSearch( 
            BYTE byteProgramType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForwardScan( 
            double dblSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackwardScan( 
            double dblSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuCall( 
            BYTE byteMenu_ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelect( 
            BYTE byteDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonActivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelectAndActivate( 
            BYTE byteButtonNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            BOOL bOnOff) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuLanguageSelect( 
            USHORT uhLanguageCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeAudioStream( 
            BYTE byteStreamNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeSubpictureStream( 
            BYTE streamNumber,
            BOOL bDisplayFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeAngle( 
            BYTE byteAngleNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalLevelSelect( 
            BYTE byteLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalCountrySelect( 
            USHORT uhCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KaraokeAudioModePresentationChange( 
            USHORT uhKaraokeMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoPresentationModeChange( 
            USHORT uhVideoMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDUserOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDUserOperation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDUserOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *TitlePlay )( 
            IDVDUserOperation * This,
            BYTE byteTitleNumber);
        
        HRESULT ( STDMETHODCALLTYPE *PartPlay )( 
            IDVDUserOperation * This,
            BYTE byteTitleNumber,
            USHORT uhPartOfTheTitle);
        
        HRESULT ( STDMETHODCALLTYPE *TimePlay )( 
            IDVDUserOperation * This,
            BYTE byteTitleNumber,
            UINT uiBCDTime);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GoUp )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *TimeSearch )( 
            IDVDUserOperation * This,
            UINT uiBCDTime);
        
        HRESULT ( STDMETHODCALLTYPE *PTTSearch )( 
            IDVDUserOperation * This,
            USHORT uhPartOfTheTitle);
        
        HRESULT ( STDMETHODCALLTYPE *ProgramSearch )( 
            IDVDUserOperation * This,
            BYTE byteProgramType);
        
        HRESULT ( STDMETHODCALLTYPE *ForwardScan )( 
            IDVDUserOperation * This,
            double dblSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *BackwardScan )( 
            IDVDUserOperation * This,
            double dblSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *MenuCall )( 
            IDVDUserOperation * This,
            BYTE byteMenu_ID);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelect )( 
            IDVDUserOperation * This,
            BYTE byteDirection);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonActivate )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelectAndActivate )( 
            IDVDUserOperation * This,
            BYTE byteButtonNumber);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDVDUserOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDVDUserOperation * This,
            BOOL bOnOff);
        
        HRESULT ( STDMETHODCALLTYPE *MenuLanguageSelect )( 
            IDVDUserOperation * This,
            USHORT uhLanguageCode);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeAudioStream )( 
            IDVDUserOperation * This,
            BYTE byteStreamNumber);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeSubpictureStream )( 
            IDVDUserOperation * This,
            BYTE streamNumber,
            BOOL bDisplayFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeAngle )( 
            IDVDUserOperation * This,
            BYTE byteAngleNumber);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalLevelSelect )( 
            IDVDUserOperation * This,
            BYTE byteLevel);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalCountrySelect )( 
            IDVDUserOperation * This,
            USHORT uhCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *KaraokeAudioModePresentationChange )( 
            IDVDUserOperation * This,
            USHORT uhKaraokeMode);
        
        HRESULT ( STDMETHODCALLTYPE *VideoPresentationModeChange )( 
            IDVDUserOperation * This,
            USHORT uhVideoMode);
        
        END_INTERFACE
    } IDVDUserOperationVtbl;

    interface IDVDUserOperation
    {
        CONST_VTBL struct IDVDUserOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDUserOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDUserOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDUserOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDUserOperation_TitlePlay(This,byteTitleNumber)	\
    ( (This)->lpVtbl -> TitlePlay(This,byteTitleNumber) ) 

#define IDVDUserOperation_PartPlay(This,byteTitleNumber,uhPartOfTheTitle)	\
    ( (This)->lpVtbl -> PartPlay(This,byteTitleNumber,uhPartOfTheTitle) ) 

#define IDVDUserOperation_TimePlay(This,byteTitleNumber,uiBCDTime)	\
    ( (This)->lpVtbl -> TimePlay(This,byteTitleNumber,uiBCDTime) ) 

#define IDVDUserOperation_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IDVDUserOperation_GoUp(This)	\
    ( (This)->lpVtbl -> GoUp(This) ) 

#define IDVDUserOperation_TimeSearch(This,uiBCDTime)	\
    ( (This)->lpVtbl -> TimeSearch(This,uiBCDTime) ) 

#define IDVDUserOperation_PTTSearch(This,uhPartOfTheTitle)	\
    ( (This)->lpVtbl -> PTTSearch(This,uhPartOfTheTitle) ) 

#define IDVDUserOperation_ProgramSearch(This,byteProgramType)	\
    ( (This)->lpVtbl -> ProgramSearch(This,byteProgramType) ) 

#define IDVDUserOperation_ForwardScan(This,dblSpeed)	\
    ( (This)->lpVtbl -> ForwardScan(This,dblSpeed) ) 

#define IDVDUserOperation_BackwardScan(This,dblSpeed)	\
    ( (This)->lpVtbl -> BackwardScan(This,dblSpeed) ) 

#define IDVDUserOperation_MenuCall(This,byteMenu_ID)	\
    ( (This)->lpVtbl -> MenuCall(This,byteMenu_ID) ) 

#define IDVDUserOperation_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDVDUserOperation_ButtonSelect(This,byteDirection)	\
    ( (This)->lpVtbl -> ButtonSelect(This,byteDirection) ) 

#define IDVDUserOperation_ButtonActivate(This)	\
    ( (This)->lpVtbl -> ButtonActivate(This) ) 

#define IDVDUserOperation_ButtonSelectAndActivate(This,byteButtonNumber)	\
    ( (This)->lpVtbl -> ButtonSelectAndActivate(This,byteButtonNumber) ) 

#define IDVDUserOperation_StillOff(This)	\
    ( (This)->lpVtbl -> StillOff(This) ) 

#define IDVDUserOperation_Pause(This,bOnOff)	\
    ( (This)->lpVtbl -> Pause(This,bOnOff) ) 

#define IDVDUserOperation_MenuLanguageSelect(This,uhLanguageCode)	\
    ( (This)->lpVtbl -> MenuLanguageSelect(This,uhLanguageCode) ) 

#define IDVDUserOperation_ChangeAudioStream(This,byteStreamNumber)	\
    ( (This)->lpVtbl -> ChangeAudioStream(This,byteStreamNumber) ) 

#define IDVDUserOperation_ChangeSubpictureStream(This,streamNumber,bDisplayFlag)	\
    ( (This)->lpVtbl -> ChangeSubpictureStream(This,streamNumber,bDisplayFlag) ) 

#define IDVDUserOperation_ChangeAngle(This,byteAngleNumber)	\
    ( (This)->lpVtbl -> ChangeAngle(This,byteAngleNumber) ) 

#define IDVDUserOperation_ParentalLevelSelect(This,byteLevel)	\
    ( (This)->lpVtbl -> ParentalLevelSelect(This,byteLevel) ) 

#define IDVDUserOperation_ParentalCountrySelect(This,uhCountryCode)	\
    ( (This)->lpVtbl -> ParentalCountrySelect(This,uhCountryCode) ) 

#define IDVDUserOperation_KaraokeAudioModePresentationChange(This,uhKaraokeMode)	\
    ( (This)->lpVtbl -> KaraokeAudioModePresentationChange(This,uhKaraokeMode) ) 

#define IDVDUserOperation_VideoPresentationModeChange(This,uhVideoMode)	\
    ( (This)->lpVtbl -> VideoPresentationModeChange(This,uhVideoMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDUserOperation_INTERFACE_DEFINED__ */


#ifndef __IDVDNavigationManager_INTERFACE_DEFINED__
#define __IDVDNavigationManager_INTERFACE_DEFINED__

/* interface IDVDNavigationManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDNavigationManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("07C89F53-C72E-11D0-A985-00A0C9050598")
    IDVDNavigationManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVolume( 
            IDVDVideoVolume *pVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSParameter( 
            UINT8 no,
            UINT16 *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGParameter( 
            UINT8 no,
            UINT16 *pValue,
            BOOL *pbCounterMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSParameter( 
            UINT8 no,
            UINT16 wValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScanCaps( 
            UINT16 *pMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlaybackState( 
            EDDVDPlaybackState *peState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UseRenderer( 
            WCHAR *pszRendererName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelectDirect( 
            BYTE byteButtonNumber) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDNavigationManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDNavigationManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDNavigationManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDNavigationManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVolume )( 
            IDVDNavigationManager * This,
            IDVDVideoVolume *pVolume);
        
        HRESULT ( STDMETHODCALLTYPE *GetSParameter )( 
            IDVDNavigationManager * This,
            UINT8 no,
            UINT16 *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetGParameter )( 
            IDVDNavigationManager * This,
            UINT8 no,
            UINT16 *pValue,
            BOOL *pbCounterMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetSParameter )( 
            IDVDNavigationManager * This,
            UINT8 no,
            UINT16 wValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetScanCaps )( 
            IDVDNavigationManager * This,
            UINT16 *pMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlaybackState )( 
            IDVDNavigationManager * This,
            EDDVDPlaybackState *peState);
        
        HRESULT ( STDMETHODCALLTYPE *UseRenderer )( 
            IDVDNavigationManager * This,
            WCHAR *pszRendererName);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelectDirect )( 
            IDVDNavigationManager * This,
            BYTE byteButtonNumber);
        
        END_INTERFACE
    } IDVDNavigationManagerVtbl;

    interface IDVDNavigationManager
    {
        CONST_VTBL struct IDVDNavigationManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDNavigationManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDNavigationManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDNavigationManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDNavigationManager_SetVolume(This,pVolume)	\
    ( (This)->lpVtbl -> SetVolume(This,pVolume) ) 

#define IDVDNavigationManager_GetSParameter(This,no,pValue)	\
    ( (This)->lpVtbl -> GetSParameter(This,no,pValue) ) 

#define IDVDNavigationManager_GetGParameter(This,no,pValue,pbCounterMode)	\
    ( (This)->lpVtbl -> GetGParameter(This,no,pValue,pbCounterMode) ) 

#define IDVDNavigationManager_SetSParameter(This,no,wValue)	\
    ( (This)->lpVtbl -> SetSParameter(This,no,wValue) ) 

#define IDVDNavigationManager_GetScanCaps(This,pMask)	\
    ( (This)->lpVtbl -> GetScanCaps(This,pMask) ) 

#define IDVDNavigationManager_GetPlaybackState(This,peState)	\
    ( (This)->lpVtbl -> GetPlaybackState(This,peState) ) 

#define IDVDNavigationManager_UseRenderer(This,pszRendererName)	\
    ( (This)->lpVtbl -> UseRenderer(This,pszRendererName) ) 

#define IDVDNavigationManager_ButtonSelectDirect(This,byteButtonNumber)	\
    ( (This)->lpVtbl -> ButtonSelectDirect(This,byteButtonNumber) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDNavigationManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dvdnav_0000_0002 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_dvdnav_0000_0002_0001
    {	InsufficientParentalLevel	= 0,
	FatalNavigationError	= ( InsufficientParentalLevel + 1 ) 
    } 	EDVDNavException;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_dvdnav_0000_0002_0002
    {	InitialAccess	= 0,
	TitlePartTimePlay	= ( InitialAccess + 1 ) ,
	MenuCallToVmgmDom	= ( TitlePartTimePlay + 1 ) ,
	MenuCallToVtsmDom	= ( MenuCallToVmgmDom + 1 ) 
    } 	EDVDSParamEvent;



extern RPC_IF_HANDLE __MIDL_itf_dvdnav_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dvdnav_0000_0002_v0_0_s_ifspec;

#ifndef __IDVDNavigatorSink_INTERFACE_DEFINED__
#define __IDVDNavigatorSink_INTERFACE_DEFINED__

/* interface IDVDNavigatorSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDVDNavigatorSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("212CD034-45B4-11d5-84F2-00C04F68EB0F")
    IDVDNavigatorSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSPRMChange( 
            UINT8 no,
            UINT16 wValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGPRMChange( 
            UINT8 no,
            UINT16 wValue,
            BOOL bCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNewProgramChain( 
            IDVDProgramChain *pChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNewProgram( 
            UINT8 progNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNewCell( 
            UINT8 cellNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnGOPUserData( 
            DVDUserGOPData *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUOPChange( 
            UINT32 newUOPMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPlaybackStateChange( 
            EDDVDPlaybackState eState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDiskReadError( 
            DWORD osCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmTemporaryParentalLevel( 
            UINT8 requestedLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnNavigationException( 
            EDVDNavException excCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeSystemParameters( 
            EDVDSParamEvent eventCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVDNavigatorSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVDNavigatorSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVDNavigatorSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVDNavigatorSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSPRMChange )( 
            IDVDNavigatorSink * This,
            UINT8 no,
            UINT16 wValue);
        
        HRESULT ( STDMETHODCALLTYPE *OnGPRMChange )( 
            IDVDNavigatorSink * This,
            UINT8 no,
            UINT16 wValue,
            BOOL bCounter);
        
        HRESULT ( STDMETHODCALLTYPE *OnNewProgramChain )( 
            IDVDNavigatorSink * This,
            IDVDProgramChain *pChain);
        
        HRESULT ( STDMETHODCALLTYPE *OnNewProgram )( 
            IDVDNavigatorSink * This,
            UINT8 progNo);
        
        HRESULT ( STDMETHODCALLTYPE *OnNewCell )( 
            IDVDNavigatorSink * This,
            UINT8 cellNo);
        
        HRESULT ( STDMETHODCALLTYPE *OnGOPUserData )( 
            IDVDNavigatorSink * This,
            DVDUserGOPData *pData);
        
        HRESULT ( STDMETHODCALLTYPE *OnUOPChange )( 
            IDVDNavigatorSink * This,
            UINT32 newUOPMask);
        
        HRESULT ( STDMETHODCALLTYPE *OnPlaybackStateChange )( 
            IDVDNavigatorSink * This,
            EDDVDPlaybackState eState);
        
        HRESULT ( STDMETHODCALLTYPE *OnDiskReadError )( 
            IDVDNavigatorSink * This,
            DWORD osCode);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmTemporaryParentalLevel )( 
            IDVDNavigatorSink * This,
            UINT8 requestedLevel);
        
        HRESULT ( STDMETHODCALLTYPE *OnNavigationException )( 
            IDVDNavigatorSink * This,
            EDVDNavException excCode);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeSystemParameters )( 
            IDVDNavigatorSink * This,
            EDVDSParamEvent eventCode);
        
        END_INTERFACE
    } IDVDNavigatorSinkVtbl;

    interface IDVDNavigatorSink
    {
        CONST_VTBL struct IDVDNavigatorSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVDNavigatorSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVDNavigatorSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVDNavigatorSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVDNavigatorSink_OnSPRMChange(This,no,wValue)	\
    ( (This)->lpVtbl -> OnSPRMChange(This,no,wValue) ) 

#define IDVDNavigatorSink_OnGPRMChange(This,no,wValue,bCounter)	\
    ( (This)->lpVtbl -> OnGPRMChange(This,no,wValue,bCounter) ) 

#define IDVDNavigatorSink_OnNewProgramChain(This,pChain)	\
    ( (This)->lpVtbl -> OnNewProgramChain(This,pChain) ) 

#define IDVDNavigatorSink_OnNewProgram(This,progNo)	\
    ( (This)->lpVtbl -> OnNewProgram(This,progNo) ) 

#define IDVDNavigatorSink_OnNewCell(This,cellNo)	\
    ( (This)->lpVtbl -> OnNewCell(This,cellNo) ) 

#define IDVDNavigatorSink_OnGOPUserData(This,pData)	\
    ( (This)->lpVtbl -> OnGOPUserData(This,pData) ) 

#define IDVDNavigatorSink_OnUOPChange(This,newUOPMask)	\
    ( (This)->lpVtbl -> OnUOPChange(This,newUOPMask) ) 

#define IDVDNavigatorSink_OnPlaybackStateChange(This,eState)	\
    ( (This)->lpVtbl -> OnPlaybackStateChange(This,eState) ) 

#define IDVDNavigatorSink_OnDiskReadError(This,osCode)	\
    ( (This)->lpVtbl -> OnDiskReadError(This,osCode) ) 

#define IDVDNavigatorSink_ConfirmTemporaryParentalLevel(This,requestedLevel)	\
    ( (This)->lpVtbl -> ConfirmTemporaryParentalLevel(This,requestedLevel) ) 

#define IDVDNavigatorSink_OnNavigationException(This,excCode)	\
    ( (This)->lpVtbl -> OnNavigationException(This,excCode) ) 

#define IDVDNavigatorSink_InitializeSystemParameters(This,eventCode)	\
    ( (This)->lpVtbl -> InitializeSystemParameters(This,eventCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVDNavigatorSink_INTERFACE_DEFINED__ */



#ifndef __DVDNAVLib_LIBRARY_DEFINED__
#define __DVDNAVLib_LIBRARY_DEFINED__

/* library DVDNAVLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DVDNAVLib;

EXTERN_C const CLSID CLSID_DVDNavigationManager;

#ifdef __cplusplus

class DECLSPEC_UUID("07C89F56-C72E-11D0-A985-00A0C9050598")
DVDNavigationManager;
#endif
#endif /* __DVDNAVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvec.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *	File name : dvec.h  class definitions
 *
 *	Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *	Facilitates an easy transition to compiler intrinsics
 *	or assembly language.
 *
 */

#ifndef _DVEC_H_INCLUDED
#define _DVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
	#error ERROR: This file is only supported in C++ compilations!
#endif /* !__cplusplus */

#if defined(_M_CEE_PURE)
	#error ERROR: This file is not supported in the pure mode!
#else

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <fvec.h>
#include <crtdefs.h>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined(_ENABLE_VEC_DEBUG)
	#include <iostream>
#endif

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

#define EXPLICIT explicit

/* EMM Functionality Intrinsics */

class I8vec16;			/* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;			/* 16 elements, each element a signed char data type */
class Iu8vec16;			/* 16 elements, each element an unsigned char data type */
class I16vec8;			/* 8 elements, each element a signed or unsigned short */
class Is16vec8;			/* 8 elements, each element a signed short */
class Iu16vec8;			/* 8 elements, each element an unsigned short */
class I32vec4;			/* 4 elements, each element a signed or unsigned long */
class Is32vec4;			/* 4 elements, each element a signed long */
class Iu32vec4;			/* 4 elements, each element a unsigned long */
class I64vec2;			/* 2 element, each a __m64 data type */
class I128vec1;			/* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

#pragma warning(push)
#pragma warning(disable : 4640)
inline const __m128i get_mask128()
{
	static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
	return mask128;
}
#pragma warning(pop)


/* M128 Class:
 * 1 element, a __m128i data type
 * Contructors & Logical Operations
 */

class M128
{
protected:
		__m128i vec;

public:
	M128()									{ }
	M128(__m128i mm)						{ vec = mm; }

	operator __m128i() const					{ return vec; }

	/* Logical Operations */
	M128& operator&=(const M128 &a)					{ return *this = (M128) _mm_and_si128(vec,a); }
	M128& operator|=(const M128 &a)					{ return *this = (M128) _mm_or_si128(vec,a); }
	M128& operator^=(const M128 &a)					{ return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)	{ return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)	{ return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)	{ return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)	{ return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128
{
public:
	I128vec1()								{ }
	I128vec1(__m128i mm) : M128(mm)				{ }

	I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
	I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
	I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
	I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class:
 * 2 elements, each element signed or unsigned 64-bit integer
 */
class I64vec2 : public M128
{
public:
	I64vec2() { }
	I64vec2(__m128i mm) : M128(mm) { }

	I64vec2(__m64 q1, __m64 q0)
	{
		_MM_2QW(0,vec) = *(__int64*)&q0;
		_MM_2QW(1,vec) = *(__int64*)&q1;
	}

	/* Assignment Operator */
	I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

	/* Logical Assignment Operators */
	I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
	I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
	I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I64vec2& operator +=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_add_epi64(vec,a); }
	I64vec2& operator -=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sub_epi64(vec,a); }

	/* Shift Logical Operators */
	I64vec2 operator<<(const I64vec2 &a) 			{ return _mm_sll_epi64(vec,a); }
	I64vec2 operator<<(int count) 					{ return _mm_slli_epi64(vec,count); }
	I64vec2& operator<<=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_sll_epi64(vec,a); }
	I64vec2& operator<<=(int count) 				{ return *this = (I64vec2) _mm_slli_epi64(vec,count); }
	I64vec2 operator>>(const I64vec2 &a) 			{ return _mm_srl_epi64(vec,a); }
	I64vec2 operator>>(int count) 					{ return _mm_srli_epi64(vec,count); }
	I64vec2& operator>>=(const I64vec2 &a)			{ return *this = (I64vec2) _mm_srl_epi64(vec,a); }
	I64vec2& operator>>=(int count) 				{ return *this = (I64vec2) _mm_srli_epi64(vec,count); }

	/* Element Access for Debug, No data modified */
	const __int64& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	__int64& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 2);	/* Only 2 elements to access */
		return _MM_2QW(i,vec);
	}


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b) 	{return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class:
 * 4 elements, each element either a signed or unsigned int
 */
class I32vec4 : public M128
{
public:
	I32vec4() { }
	I32vec4(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I32vec4& operator= (const M128 &a)				{ return *this = (I32vec4) a; }

	/* Logicals Operators */
	I32vec4& operator&=(const M128 &a)				{ return *this = (I32vec4) _mm_and_si128(vec,a); }
	I32vec4& operator|=(const M128 &a)				{ return *this = (I32vec4) _mm_or_si128(vec,a); }
	I32vec4& operator^=(const M128 &a)				{ return *this = (I32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I32vec4& operator +=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_add_epi32(vec,a); }
	I32vec4& operator -=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	I32vec4 operator<<(const I32vec4 &a) 			{ return _mm_sll_epi32(vec,a); }
	I32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	I32vec4& operator<<=(const I32vec4 &a)			{ return *this = (I32vec4)_mm_sll_epi32(vec,a); }
	I32vec4& operator<<=(int count) 				{ return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b) 	    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b) 	{ return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class:
 * 4 elements, each element signed integer
 */
class Is32vec4 : public I32vec4
{
public:
	Is32vec4() { }
	Is32vec4(__m128i mm) : I32vec4(mm) { }
	Is32vec4(int i3, int i2, int i1, int i0)
	{
		_MM_4DW(0,vec) = i0;
		_MM_4DW(1,vec) = i1;
		_MM_4DW(2,vec) = i2;
		_MM_4DW(3,vec) = i3;
	}

	/* Assignment Operator */
	Is32vec4& operator= (const M128 &a)		{ return *this = (Is32vec4) a; }

	/* Logical Operators */
	Is32vec4& operator&=(const M128 &a)		{ return *this = (Is32vec4) _mm_and_si128(vec,a); }
	Is32vec4& operator|=(const M128 &a)		{ return *this = (Is32vec4) _mm_or_si128(vec,a); }
	Is32vec4& operator^=(const M128 &a)		{ return *this = (Is32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is32vec4& operator +=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_add_epi32(vec,a); }
	Is32vec4& operator -=(const I32vec4 &a)	{ return *this = (Is32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Is32vec4 operator<<(const M128 &a) 		{ return _mm_sll_epi32(vec,a); }
	Is32vec4 operator<<(int count) 			{ return _mm_slli_epi32(vec,count); }
	Is32vec4& operator<<=(const M128 &a)	{ return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
	Is32vec4& operator<<=(int count) 		{ return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
	/* Shift Arithmetic Operations */
	Is32vec4 operator>>(const M128 &a) 		{ return _mm_sra_epi32(vec,a); }
	Is32vec4 operator>>(int count) 			{ return _mm_srai_epi32(vec,count); }
	Is32vec4& operator>>=(const M128 &a)	{ return *this = (Is32vec4) _mm_sra_epi32(vec,a); }
	Is32vec4& operator>>=(int count) 		{ return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is32vec4 &a)
	{
		os << "[3]:" << _MM_4DW(3,a)
			<< " [2]:" << _MM_4DW(2,a)
			<< " [1]:" << _MM_4DW(1,a)
			<< " [0]:" << _MM_4DW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}

	/* Element Access for Debug */
	int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4DW(i,vec);
	}
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b) 	    	{ return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)			{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)				{ return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b) 		{ return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)		{ return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class:
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4
{
public:
	Iu32vec4() { }
	Iu32vec4(__m128i mm) : I32vec4(mm) { }
	Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
	{
		_MM_4UDW(0,vec) = ui0;
		_MM_4UDW(1,vec) = ui1;
		_MM_4UDW(2,vec) = ui2;
		_MM_4UDW(3,vec) = ui3;
	}

	/* Assignment Operator */
	Iu32vec4& operator= (const M128 &a)		{ return *this = (Iu32vec4) a; }

	/* Logical Assignment Operators */
	Iu32vec4& operator&=(const M128 &a)		{ return *this = (Iu32vec4) _mm_and_si128(vec,a); }
	Iu32vec4& operator|=(const M128 &a)		{ return *this = (Iu32vec4) _mm_or_si128(vec,a); }
	Iu32vec4& operator^=(const M128 &a)		{ return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu32vec4& operator +=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
	Iu32vec4& operator -=(const I32vec4 &a)	{ return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }

	/* Shift Logical Operators */
	Iu32vec4 operator<<(const M128 &a) 				{ return _mm_sll_epi32(vec,a); }
	Iu32vec4 operator<<(int count) 					{ return _mm_slli_epi32(vec,count); }
	Iu32vec4& operator<<=(const M128 &a)			{ return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
	Iu32vec4& operator<<=(int count) 				{ return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
	Iu32vec4 operator>>(const M128 &a) 				{ return _mm_srl_epi32(vec,a); }
	Iu32vec4 operator>>(int count) 					{ return _mm_srli_epi32(vec,count); }
	Iu32vec4& operator>>=(const M128 &a)			{ return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
	Iu32vec4& operator>>=(int count) 				{ return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Iu32vec4 &a)
	{
		os << "[3]:" << _MM_4UDW(3,a)
			<< " [2]:" << _MM_4UDW(2,a)
			<< " [1]:" << _MM_4UDW(1,a)
			<< " [0]:" << _MM_4UDW(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned int& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}

	/* Element Access and Assignment for Debug */
	unsigned int& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 4);	/* Only 4 elements to access */
		return _MM_4UDW(i,vec);
	}
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b) 	{ return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)	{ return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class:
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128
{
public:
	I16vec8() { }
	I16vec8(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I16vec8& operator= (const M128 &a)		{ return *this = (I16vec8) a; }

	/* Logical Assignment Operators */
	I16vec8& operator&=(const M128 &a)		{ return *this = (I16vec8) _mm_and_si128(vec,a); }
	I16vec8& operator|=(const M128 &a)		{ return *this = (I16vec8) _mm_or_si128(vec,a); }
	I16vec8& operator^=(const M128 &a)		{ return *this = (I16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I16vec8& operator +=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_add_epi16(vec,a); }
	I16vec8& operator -=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_sub_epi16(vec,a); }
	I16vec8& operator *=(const I16vec8 &a)	{ return *this = (I16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	I16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	I16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	I16vec8& operator<<=(const M128 &a)				{ return *this = (I16vec8)_mm_sll_epi16(vec,a); }
	I16vec8& operator<<=(int count) 				{ return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b) 	{ return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class:
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8
{
public:
	Is16vec8() { }
	Is16vec8(__m128i mm) : I16vec8(mm) { }
	Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
	 {
		_MM_8W(0,vec) = s0;
		_MM_8W(1,vec) = s1;
		_MM_8W(2,vec) = s2;
		_MM_8W(3,vec) = s3;
		_MM_8W(4,vec) = s4;
		_MM_8W(5,vec) = s5;
		_MM_8W(6,vec) = s6;
		_MM_8W(7,vec) = s7;
	}

	/* Assignment Operator */
	Is16vec8& operator= (const M128 &a)		{ return *this = (Is16vec8) a; }

	/* Logical Assignment Operators */
	Is16vec8& operator&=(const M128 &a)		{ return *this = (Is16vec8) _mm_and_si128(vec,a); }
	Is16vec8& operator|=(const M128 &a)		{ return *this = (Is16vec8) _mm_or_si128(vec,a); }
	Is16vec8& operator^=(const M128 &a)		{ return *this = (Is16vec8) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is16vec8& operator +=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_add_epi16(vec,a); }
	Is16vec8& operator -=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_sub_epi16(vec,a); }
	Is16vec8& operator *=(const I16vec8 &a)	{ return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Is16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Is16vec8 operator<<(int count) 				{ return _mm_slli_epi16(vec,count); }
	Is16vec8& operator<<=(const M128 &a)			{ return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
	Is16vec8& operator<<=(int count) 				{ return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
	/* Shift Arithmetic Operators */
	Is16vec8 operator>>(const M128 &a) 				{ return _mm_sra_epi16(vec,a); }
	Is16vec8 operator>>(int count) 				{ return _mm_srai_epi16(vec,count); }
	Is16vec8& operator>>=(const M128 &a)			{ return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
	Is16vec8& operator>>=(int count) 				{ return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator<< (std::ostream &os, const Is16vec8 &a)
	{
		os << "[7]:" << _MM_8W(7,a)
			<< " [6]:" << _MM_8W(6,a)
			<< " [5]:" << _MM_8W(5,a)
			<< " [4]:" << _MM_8W(4,a)
			<< " [3]:" << _MM_8W(3,a)
			<< " [2]:" << _MM_8W(2,a)
			<< " [1]:" << _MM_8W(1,a)
			<< " [0]:" << _MM_8W(0,a);
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}

	/* Element Access and Assignment for Debug */
	signed short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8W(i,vec);
	}
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mullo_epi16(a,b); }


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)		{ return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)	{ return _mm_min_epi16(a,b); }


/* Iu16vec8 Class:
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8
{
public:
	Iu16vec8() { }
	Iu16vec8(__m128i mm) : I16vec8(mm) { }
	Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
	{
		_MM_8UW(0,vec) = s0;
		_MM_8UW(1,vec) = s1;
		_MM_8UW(2,vec) = s2;
		_MM_8UW(3,vec) = s3;
		_MM_8UW(4,vec) = s4;
		_MM_8UW(5,vec) = s5;
		_MM_8UW(6,vec) = s6;
		_MM_8UW(7,vec) = s7;
	}

	/* Assignment Operator */
	Iu16vec8& operator= (const M128 &a)		{ return *this = (Iu16vec8) a; }
	/* Logical Assignment Operators */
	Iu16vec8& operator&=(const M128 &a)		{ return *this = (Iu16vec8) _mm_and_si128(vec,a); }
	Iu16vec8& operator|=(const M128 &a)		{ return *this = (Iu16vec8) _mm_or_si128(vec,a); }
	Iu16vec8& operator^=(const M128 &a)		{ return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
	/* Addition & Subtraction Assignment Operators */
	Iu16vec8& operator +=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
	Iu16vec8& operator -=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }
	Iu16vec8& operator *=(const I16vec8 &a)	{ return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }

	/* Shift Logical Operators */
	Iu16vec8 operator<<(const M128 &a) 				{ return _mm_sll_epi16(vec,a); }
	Iu16vec8 operator<<(int count) 					{ return _mm_slli_epi16(vec,count); }
	Iu16vec8& operator<<=(const M128 &a)			{ return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
	Iu16vec8& operator<<=(int count) 				{ return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
	Iu16vec8 operator>>(const M128 &a) 				{ return _mm_srl_epi16(vec,a); }
	Iu16vec8 operator>>(int count) 					{ return _mm_srli_epi16(vec,count); }
	Iu16vec8& operator>>=(const M128 &a)			{ return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
	Iu16vec8& operator>>=(int count) 				{ return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu16vec8 &a)
	{
		 os << "[7]:"  << unsigned short(_MM_8UW(7,a))
			<< " [6]:" << unsigned short(_MM_8UW(6,a))
			<< " [5]:" << unsigned short(_MM_8UW(5,a))
			<< " [4]:" << unsigned short(_MM_8UW(4,a))
			<< " [3]:" << unsigned short(_MM_8UW(3,a))
			<< " [2]:" << unsigned short(_MM_8UW(2,a))
			<< " [1]:" << unsigned short(_MM_8UW(1,a))
			<< " [0]:" << unsigned short(_MM_8UW(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned short& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}

	/* Element Access for Debug */
	unsigned short& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 8);	/* Only 8 elements to access */
		return _MM_8UW(i,vec);
	}
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mullo_epi16(a,b); }

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b) 	{ return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)	{ return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class:
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128
{
public:
	I8vec16() { }
	I8vec16(__m128i mm) : M128(mm) { }

	/* Assignment Operator */
	I8vec16& operator= (const M128 &a)		{ return *this = (I8vec16) a; }

	/* Logical Assignment Operators */
	I8vec16& operator&=(const M128 &a)		{ return *this = (I8vec16) _mm_and_si128(vec,a); }
	I8vec16& operator|=(const M128 &a)		{ return *this = (I8vec16) _mm_or_si128(vec,a); }
	I8vec16& operator^=(const M128 &a)		{ return *this = (I8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	I8vec16& operator +=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_add_epi8(vec,a); }
	I8vec16& operator -=(const I8vec16 &a)	{ return *this = (I8vec16) _mm_sub_epi8(vec,a); }

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b) 		{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)	{ return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class:
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16
{
public:
	Is8vec16() { }
	Is8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Is8vec16& operator= (const M128 &a)		{ return *this = (Is8vec16) a; }

	/* Logical Assignment Operators */
	Is8vec16& operator&=(const M128 &a)		{ return *this = (Is8vec16) _mm_and_si128(vec,a); }
	Is8vec16& operator|=(const M128 &a)		{ return *this = (Is8vec16) _mm_or_si128(vec,a); }
	Is8vec16& operator^=(const M128 &a)		{ return *this = (Is8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Is8vec16& operator +=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_add_epi8(vec,a); }
	Is8vec16& operator -=(const I8vec16 &a)	{ return *this = (Is8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Is8vec16 &a)
	{
		 os << "[15]:"  << short(_MM_16B(15,a))
			<< " [14]:" << short(_MM_16B(14,a))
			<< " [13]:" << short(_MM_16B(13,a))
			<< " [12]:" << short(_MM_16B(12,a))
			<< " [11]:" << short(_MM_16B(11,a))
			<< " [10]:" << short(_MM_16B(10,a))
			<< " [9]:" << short(_MM_16B(9,a))
			<< " [8]:" << short(_MM_16B(8,a))
		      << " [7]:" << short(_MM_16B(7,a))
			<< " [6]:" << short(_MM_16B(6,a))
			<< " [5]:" << short(_MM_16B(5,a))
			<< " [4]:" << short(_MM_16B(4,a))
			<< " [3]:" << short(_MM_16B(3,a))
			<< " [2]:" << short(_MM_16B(2,a))
			<< " [1]:" << short(_MM_16B(1,a))
			<< " [0]:" << short(_MM_16B(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const signed char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

	/* Element Access for Debug */
	signed char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16B(i,vec);
	}

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)	{ return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class:
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16
{
public:
	Iu8vec16() { }
	Iu8vec16(__m128i mm) : I8vec16(mm) { }

	/* Assignment Operator */
	Iu8vec16& operator= (const M128 &a)		{ return *this = (Iu8vec16) a; }

	/* Logical Assignment Operators */
	Iu8vec16& operator&=(const M128 &a)		{ return *this = (Iu8vec16) _mm_and_si128(vec,a); }
	Iu8vec16& operator|=(const M128 &a)		{ return *this = (Iu8vec16) _mm_or_si128(vec,a); }
	Iu8vec16& operator^=(const M128 &a)		{ return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

	/* Addition & Subtraction Assignment Operators */
	Iu8vec16& operator +=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
	Iu8vec16& operator -=(const I8vec16 &a)	{ return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }

#if defined(_ENABLE_VEC_DEBUG)
	/* Output for Debug */
	friend std::ostream& operator << (std::ostream &os, const Iu8vec16 &a)
	{
		 os << "[15]:"  << unsigned short(_MM_16UB(15,a))
			<< " [14]:" << unsigned short(_MM_16UB(14,a))
			<< " [13]:" << unsigned short(_MM_16UB(13,a))
			<< " [12]:" << unsigned short(_MM_16UB(12,a))
			<< " [11]:" << unsigned short(_MM_16UB(11,a))
			<< " [10]:" << unsigned short(_MM_16UB(10,a))
			<< " [9]:" << unsigned short(_MM_16UB(9,a))
			<< " [8]:" << unsigned short(_MM_16UB(8,a))
		      << " [7]:" << unsigned short(_MM_16UB(7,a))
			<< " [6]:" << unsigned short(_MM_16UB(6,a))
			<< " [5]:" << unsigned short(_MM_16UB(5,a))
			<< " [4]:" << unsigned short(_MM_16UB(4,a))
			<< " [3]:" << unsigned short(_MM_16UB(3,a))
			<< " [2]:" << unsigned short(_MM_16UB(2,a))
			<< " [1]:" << unsigned short(_MM_16UB(1,a))
			<< " [0]:" << unsigned short(_MM_16UB(0,a));
		return os;
	}
#endif

	/* Element Access for Debug, No data modified */
	const unsigned char& operator[](int i)const
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

	/* Element Access for Debug */
	unsigned char& operator[](int i)
	{
		assert(static_cast<unsigned int>(i) < 16);	/* Only 16 elements to access */
		return _MM_16UB(i,vec);
	}

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b) 	{ return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)	{ return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b) 	{ return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b) 	{ return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); }

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*	version of: retval = (a OP b)? c : d;													 *
 *	Where OP is one of the possible comparision operators.									 *
 *	Example: r = select_eq(a,b,c,d);														 *
 *	if "member at position x of the vector a" == "member at position x of vector b" 		 *
 *	assign the corresponding member in r from c, else assign from d.							 *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
	inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d) 	   \
{																\
	I##vect12##vec##element mask = cmp##selop(a,b);						\
	return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 )))));	\
}
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)


#undef IVEC128_SELECT


class F64vec2
{
protected:
   	 __m128d vec;
public:

	/* Constructors: __m128d, 2 doubles */
	F64vec2() {}

	/* initialize 2 DP FP with __m128d data type */
	F64vec2(__m128d m)					{ vec = m;}

	/* initialize 2 DP FPs with 2 doubles */
	F64vec2(double d1, double d0)		                { vec= _mm_set_pd(d1,d0); }

	/* Explicitly initialize each of 2 DP FPs with same double */
	EXPLICIT F64vec2(double d)	{ vec = _mm_set1_pd(d); }

	/* Conversion functions */
	operator  __m128d() const	{ return vec; }		/* Convert to __m128d */

 	/* Logical Operators */
	friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
	friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
	friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

	/* Arithmetic Operators */
	friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
	friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); }
	friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); }
	friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

	F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
	F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }
	F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); }
	F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
	F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
	F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
	F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

	/* Horizontal Add */
	friend double add_horizontal(F64vec2 &a)
	{
		F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
		return ftemp[0];
	}

	/* And Not */
	friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

	/* Square Root */
	friend F64vec2 sqrt(const F64vec2 &a)		{ return _mm_sqrt_pd(a); }

	/* Compares: Mask is returned  */
	/* Macros expand to all compare intrinsics.  Example:
			friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b)
			{ return _mm_cmpeq_ps(a,b);} */
	#define F64vec2_COMP(op) \
	friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
		F64vec2_COMP(eq)					/* expanded to cmpeq(a,b) */
		F64vec2_COMP(lt)					/* expanded to cmplt(a,b) */
		F64vec2_COMP(le)					/* expanded to cmple(a,b) */
		F64vec2_COMP(gt)					/* expanded to cmpgt(a,b) */
		F64vec2_COMP(ge)					/* expanded to cmpge(a,b) */
		F64vec2_COMP(ngt)					/* expanded to cmpngt(a,b) */
		F64vec2_COMP(nge)					/* expanded to cmpnge(a,b) */
		F64vec2_COMP(neq)					/* expanded to cmpneq(a,b) */
		F64vec2_COMP(nlt)					/* expanded to cmpnlt(a,b) */
		F64vec2_COMP(nle)					/* expanded to cmpnle(a,b) */
	#undef F64vec2_COMP

	/* Min and Max */
	friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
	friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
	#define F64vec2_COMI(op) \
	friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
		F64vec2_COMI(eq)					/* expanded to comieq(a,b) */
		F64vec2_COMI(lt)					/* expanded to comilt(a,b) */
		F64vec2_COMI(le)					/* expanded to comile(a,b) */
		F64vec2_COMI(gt)					/* expanded to comigt(a,b) */
		F64vec2_COMI(ge)					/* expanded to comige(a,b) */
		F64vec2_COMI(neq)					/* expanded to comineq(a,b) */
	#undef F64vec2_COMI

        /* Compare lower DP FP values */
	#define F64vec2_UCOMI(op) \
	friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
		F64vec2_UCOMI(eq)					/* expanded to ucomieq(a,b) */
		F64vec2_UCOMI(lt)					/* expanded to ucomilt(a,b) */
		F64vec2_UCOMI(le)					/* expanded to ucomile(a,b) */
		F64vec2_UCOMI(gt)					/* expanded to ucomigt(a,b) */
		F64vec2_UCOMI(ge)					/* expanded to ucomige(a,b) */
		F64vec2_UCOMI(neq)					/* expanded to ucomineq(a,b) */
	#undef F64vec2_UCOMI

	/* Debug Features */
#if defined(_ENABLE_VEC_DEBUG)
	/* Output */
	friend std::ostream & operator<<(std::ostream & os, const F64vec2 &a)
	{
	/* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */
	  double *dp = (double*)&a;
		os <<	" [1]:" << *(dp+1)
			<< " [0]:" << *dp;
		return os;
	}
#endif
	/* Element Access Only, no modifications to elements*/
	const double& operator[](int i) const
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
	/* Element Access and Modification*/
	double& operator[](int i)
	{
		/* Assert enabled only during debug /DDEBUG */
		assert((0 <= i) && (i <= 1));			/* User should only access elements 0-1 */
		double *dp = (double*)&vec;
		return *(dp+i);
	}
};

						/* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)
{ return _mm_movemask_pd(a);}

						/* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)
{ a = _mm_loadu_pd(p); }

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)
{ _mm_storeu_pd(p, a); }

						/* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a)
{ _mm_stream_pd(p,a);}

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d) 	   \
{																\
	F64vec2 mask = _mm_cmp##op##_pd(a,b);						\
	return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d))));	\
}
F64vec2_SELECT(eq)		/* generates select_eq(a,b) */
F64vec2_SELECT(lt)		/* generates select_lt(a,b) */
F64vec2_SELECT(le)		/* generates select_le(a,b) */
F64vec2_SELECT(gt)		/* generates select_gt(a,b) */
F64vec2_SELECT(ge)		/* generates select_ge(a,b) */
F64vec2_SELECT(neq)		/* generates select_neq(a,b) */
F64vec2_SELECT(nlt)		/* generates select_nlt(a,b) */
F64vec2_SELECT(nle)		/* generates select_nle(a,b) */
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{

	return _mm_cvttsd_si32(a);

}

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{
	return _mm_cvtps_pd(a);
}

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{
	return _mm_cvtpd_ps(a);
}

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{
	return _mm_cvtsi32_sd(a,b);
}

#pragma pack(pop) /* 16-B aligned */

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* defined(_M_CEE_PURE) */

#endif /* RC_INVOKED */
#endif /* _DVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvrinterfaces.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for DvrInterfaces.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __DvrInterfaces_h__
#define __DvrInterfaces_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IStreamBufferCapture_FWD_DEFINED__
#define __IStreamBufferCapture_FWD_DEFINED__
typedef interface IStreamBufferCapture IStreamBufferCapture;
#endif 	/* __IStreamBufferCapture_FWD_DEFINED__ */


#ifndef __IStreamBufferPlayback_FWD_DEFINED__
#define __IStreamBufferPlayback_FWD_DEFINED__
typedef interface IStreamBufferPlayback IStreamBufferPlayback;
#endif 	/* __IStreamBufferPlayback_FWD_DEFINED__ */


#ifndef __IDVREngineHelpersDeleteMonitor_FWD_DEFINED__
#define __IDVREngineHelpersDeleteMonitor_FWD_DEFINED__
typedef interface IDVREngineHelpersDeleteMonitor IDVREngineHelpersDeleteMonitor;
#endif 	/* __IDVREngineHelpersDeleteMonitor_FWD_DEFINED__ */


#ifndef __IDVREngineHelpers_FWD_DEFINED__
#define __IDVREngineHelpers_FWD_DEFINED__
typedef interface IDVREngineHelpers IDVREngineHelpers;
#endif 	/* __IDVREngineHelpers_FWD_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_FWD_DEFINED__
#define __IStreamBufferMediaSeeking_FWD_DEFINED__
typedef interface IStreamBufferMediaSeeking IStreamBufferMediaSeeking;
#endif 	/* __IStreamBufferMediaSeeking_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __DVREngineLib_LIBRARY_DEFINED__
#define __DVREngineLib_LIBRARY_DEFINED__

/* library DVREngineLib */
/* [uuid] */ 

typedef 
enum DVREngineEvents
    {	DVR_SOURCE_EC_COMPLETE_PENDING	= ( 0x8000 | 819 ) ,
	DVR_SOURCE_EC_COMPLETE_DONE	= ( 0x8000 | 820 ) ,
	DVRENGINE_EVENT_BEGINNING_OF_PAUSE_BUFFER	= ( 0x8000 | 821 ) ,
	DVRENGINE_EVENT_END_OF_PAUSE_BUFFER	= ( 0x8000 | 822 ) ,
	DVRENGINE_EVENT_RECORDING_END_OF_STREAM	= ( 0x8000 | 823 ) ,
	DVRENGINE_EVENT_COPYPROTECTION_CHANGE_DETECTED	= ( 0x8000 | 824 ) ,
	DVRENGINE_XDSCODEC_NEWXDSPACKET	= ( 0x8000 | 825 ) ,
	DVRENGINE_XDSCODEC_NEWXDSRATING	= ( 0x8000 | 826 ) ,
	DVRENGINE_XDSCODEC_DUPLICATEXDSRATING	= ( 0x8000 | 827 ) ,
	DVRENGINE_EVENT_COPYPROTECTION_DUPLICATE_RECEIVED	= ( 0x8000 | 828 ) ,
	DVRENGINE_EVENT_CAPTURE_TUNE_DETECTED	= ( 0x8000 | 829 ) ,
	DVRENGINE_EVENT_PLAYBACK_TUNE_HANDLED	= ( 0x8000 | 830 ) 
    } 	DVR_ENGINE_EVENTS;

typedef 
enum DVRENGINE_RESUMPTION_REASON
    {	DVRENGINE_REWOUND_TO_BEGINNING	= 0,
	DVRENGINE_PAUSED_UNTIL_TRUNCATION	= ( DVRENGINE_REWOUND_TO_BEGINNING + 1 ) ,
	DVRENGINE_SLOW_PLAY_UNTIL_TRUNCATION	= ( DVRENGINE_PAUSED_UNTIL_TRUNCATION + 1 ) 
    } 	DVRENGINE_RESUMPTION_REASON;

typedef 
enum DVRENGINE_END_BUFFER_MODE
    {	DVRENGINE_LIVE_POSITION_IN_LIVE_TV	= 0,
	DVRENGINE_LIVE_POSITION_IN_BOUND_RECORDING	= ( DVRENGINE_LIVE_POSITION_IN_LIVE_TV + 1 ) 
    } 	DVRENGINE_END_BUFFER_MODE;

typedef 
enum DVRENGINE_END_RECORDING_MODE
    {	DVRENGINE_BEGINNING_OF_RECORDING	= 0,
	DVRENGINE_END_OF_RECORDING	= ( DVRENGINE_BEGINNING_OF_RECORDING + 1 ) 
    } 	DVRENGINE_END_RECORDING_MODE;

typedef 
enum CaptureMode
    {	STRMBUF_TEMPORARY_RECORDING	= 0,
	STRMBUF_PERMANENT_RECORDING	= ( STRMBUF_TEMPORARY_RECORDING + 1 ) 
    } 	STRMBUF_CAPTURE_MODE;

typedef 
enum PlaybackTransitionPolicy
    {	STRMBUF_STAY_WITH_RECORDING	= 0,
	STRMBUF_STAY_WITH_SINK	= ( STRMBUF_STAY_WITH_RECORDING + 1 ) 
    } 	STRMBUF_PLAYBACK_TRANSITION_POLICY;

typedef 
enum STRMBUF_PLAYBACK_TUNE_POLICY
    {	STRMBUF_PLAYBACK_TUNE_FLUSH_AND_GO_TO_LIVE	= 0,
	STRMBUF_PLAYBACK_TUNE_IGNORED	= ( STRMBUF_PLAYBACK_TUNE_FLUSH_AND_GO_TO_LIVE + 1 ) 
    } 	STRMBUF_PLAYBACK_TUNE_POLICY;


enum __MIDL___MIDL_itf_DvrInterfaces_0001_0187_0001
    {	STREAMBUFFER_EC_TIMEHOLE	= 0x326,
	STREAMBUFFER_EC_STALE_DATA_READ	= ( STREAMBUFFER_EC_TIMEHOLE + 1 ) ,
	STREAMBUFFER_EC_STALE_FILE_DELETED	= ( STREAMBUFFER_EC_STALE_DATA_READ + 1 ) ,
	STREAMBUFFER_EC_CONTENT_BECOMING_STALE	= ( STREAMBUFFER_EC_STALE_FILE_DELETED + 1 ) ,
	STREAMBUFFER_EC_WRITE_FAILURE	= ( STREAMBUFFER_EC_CONTENT_BECOMING_STALE + 1 ) ,
	STREAMBUFFER_EC_READ_FAILURE	= ( STREAMBUFFER_EC_WRITE_FAILURE + 1 ) ,
	STREAMBUFFER_EC_RATE_CHANGED	= ( STREAMBUFFER_EC_READ_FAILURE + 1 ) 
    } ;

EXTERN_C const IID LIBID_DVREngineLib;

#ifndef __IStreamBufferCapture_INTERFACE_DEFINED__
#define __IStreamBufferCapture_INTERFACE_DEFINED__

/* interface IStreamBufferCapture */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferCapture;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34DB9BD0-F185-4334-A2D7-CD460B950BDB")
    IStreamBufferCapture : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCaptureMode( 
            /* [out] */ STRMBUF_CAPTURE_MODE *peStrmbufCaptureMode,
            /* [out] */ LONGLONG *phyMaxBufferMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTemporaryRecording( 
            /* [in] */ LONGLONG hyBufferSizeInMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginPermanentRecording( 
            /* [in] */ LONGLONG hyRetainedSizeInMilliseconds,
            /* [out] */ LONGLONG *phyActualRetainedSizeInMillisecs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertToTemporaryRecording( 
            /* [in] */ LPCOLESTR pszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRecordingPath( 
            /* [in] */ LPCOLESTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingPath( 
            /* [out] */ LPOLESTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoundToLiveToken( 
            /* [out] */ LPOLESTR *ppszToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition( 
            /* [out] */ LONGLONG *phyCurrentPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferCaptureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferCapture * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferCapture * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferCapture * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaptureMode )( 
            IStreamBufferCapture * This,
            /* [out] */ STRMBUF_CAPTURE_MODE *peStrmbufCaptureMode,
            /* [out] */ LONGLONG *phyMaxBufferMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTemporaryRecording )( 
            IStreamBufferCapture * This,
            /* [in] */ LONGLONG hyBufferSizeInMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *BeginPermanentRecording )( 
            IStreamBufferCapture * This,
            /* [in] */ LONGLONG hyRetainedSizeInMilliseconds,
            /* [out] */ LONGLONG *phyActualRetainedSizeInMillisecs);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertToTemporaryRecording )( 
            IStreamBufferCapture * This,
            /* [in] */ LPCOLESTR pszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *SetRecordingPath )( 
            IStreamBufferCapture * This,
            /* [in] */ LPCOLESTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingPath )( 
            IStreamBufferCapture * This,
            /* [out] */ LPOLESTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoundToLiveToken )( 
            IStreamBufferCapture * This,
            /* [out] */ LPOLESTR *ppszToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IStreamBufferCapture * This,
            /* [out] */ LONGLONG *phyCurrentPosition);
        
        END_INTERFACE
    } IStreamBufferCaptureVtbl;

    interface IStreamBufferCapture
    {
        CONST_VTBL struct IStreamBufferCaptureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferCapture_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferCapture_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferCapture_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferCapture_GetCaptureMode(This,peStrmbufCaptureMode,phyMaxBufferMilliseconds)	\
    ( (This)->lpVtbl -> GetCaptureMode(This,peStrmbufCaptureMode,phyMaxBufferMilliseconds) ) 

#define IStreamBufferCapture_BeginTemporaryRecording(This,hyBufferSizeInMilliseconds)	\
    ( (This)->lpVtbl -> BeginTemporaryRecording(This,hyBufferSizeInMilliseconds) ) 

#define IStreamBufferCapture_BeginPermanentRecording(This,hyRetainedSizeInMilliseconds,phyActualRetainedSizeInMillisecs)	\
    ( (This)->lpVtbl -> BeginPermanentRecording(This,hyRetainedSizeInMilliseconds,phyActualRetainedSizeInMillisecs) ) 

#define IStreamBufferCapture_ConvertToTemporaryRecording(This,pszFileName)	\
    ( (This)->lpVtbl -> ConvertToTemporaryRecording(This,pszFileName) ) 

#define IStreamBufferCapture_SetRecordingPath(This,pszPath)	\
    ( (This)->lpVtbl -> SetRecordingPath(This,pszPath) ) 

#define IStreamBufferCapture_GetRecordingPath(This,ppszPath)	\
    ( (This)->lpVtbl -> GetRecordingPath(This,ppszPath) ) 

#define IStreamBufferCapture_GetBoundToLiveToken(This,ppszToken)	\
    ( (This)->lpVtbl -> GetBoundToLiveToken(This,ppszToken) ) 

#define IStreamBufferCapture_GetCurrentPosition(This,phyCurrentPosition)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,phyCurrentPosition) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferCapture_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferPlayback_INTERFACE_DEFINED__
#define __IStreamBufferPlayback_INTERFACE_DEFINED__

/* interface IStreamBufferPlayback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferPlayback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50845279-8C98-4e1f-A16A-8C48CE35EC12")
    IStreamBufferPlayback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTunePolicy( 
            /* [in] */ STRMBUF_PLAYBACK_TUNE_POLICY eStrmbufPlaybackTunePolicy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTunePolicy( 
            /* [out] */ STRMBUF_PLAYBACK_TUNE_POLICY *peStrmbufPlaybackTunePolicy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThrottlingEnabled( 
            /* [in] */ BOOL fThrottle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThrottlingEnabled( 
            /* [out] */ BOOL *pfThrottle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyGraphIsConnected( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAtLive( 
            /* [out] */ BOOL *pfAtLive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffsetFromLive( 
            /* [out] */ LONGLONG *pllOffsetFromLive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDesiredOffsetFromLive( 
            /* [in] */ LONGLONG llOffsetFromLive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLoadIncarnation( 
            /* [out] */ DWORD *pdwLoadIncarnation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableBackgroundPriority( 
            /* [in] */ BOOL fEnableBackgroundPriority) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferPlaybackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferPlayback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferPlayback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferPlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTunePolicy )( 
            IStreamBufferPlayback * This,
            /* [in] */ STRMBUF_PLAYBACK_TUNE_POLICY eStrmbufPlaybackTunePolicy);
        
        HRESULT ( STDMETHODCALLTYPE *GetTunePolicy )( 
            IStreamBufferPlayback * This,
            /* [out] */ STRMBUF_PLAYBACK_TUNE_POLICY *peStrmbufPlaybackTunePolicy);
        
        HRESULT ( STDMETHODCALLTYPE *SetThrottlingEnabled )( 
            IStreamBufferPlayback * This,
            /* [in] */ BOOL fThrottle);
        
        HRESULT ( STDMETHODCALLTYPE *GetThrottlingEnabled )( 
            IStreamBufferPlayback * This,
            /* [out] */ BOOL *pfThrottle);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyGraphIsConnected )( 
            IStreamBufferPlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsAtLive )( 
            IStreamBufferPlayback * This,
            /* [out] */ BOOL *pfAtLive);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffsetFromLive )( 
            IStreamBufferPlayback * This,
            /* [out] */ LONGLONG *pllOffsetFromLive);
        
        HRESULT ( STDMETHODCALLTYPE *SetDesiredOffsetFromLive )( 
            IStreamBufferPlayback * This,
            /* [in] */ LONGLONG llOffsetFromLive);
        
        HRESULT ( STDMETHODCALLTYPE *GetLoadIncarnation )( 
            IStreamBufferPlayback * This,
            /* [out] */ DWORD *pdwLoadIncarnation);
        
        HRESULT ( STDMETHODCALLTYPE *EnableBackgroundPriority )( 
            IStreamBufferPlayback * This,
            /* [in] */ BOOL fEnableBackgroundPriority);
        
        END_INTERFACE
    } IStreamBufferPlaybackVtbl;

    interface IStreamBufferPlayback
    {
        CONST_VTBL struct IStreamBufferPlaybackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferPlayback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferPlayback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferPlayback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferPlayback_SetTunePolicy(This,eStrmbufPlaybackTunePolicy)	\
    ( (This)->lpVtbl -> SetTunePolicy(This,eStrmbufPlaybackTunePolicy) ) 

#define IStreamBufferPlayback_GetTunePolicy(This,peStrmbufPlaybackTunePolicy)	\
    ( (This)->lpVtbl -> GetTunePolicy(This,peStrmbufPlaybackTunePolicy) ) 

#define IStreamBufferPlayback_SetThrottlingEnabled(This,fThrottle)	\
    ( (This)->lpVtbl -> SetThrottlingEnabled(This,fThrottle) ) 

#define IStreamBufferPlayback_GetThrottlingEnabled(This,pfThrottle)	\
    ( (This)->lpVtbl -> GetThrottlingEnabled(This,pfThrottle) ) 

#define IStreamBufferPlayback_NotifyGraphIsConnected(This)	\
    ( (This)->lpVtbl -> NotifyGraphIsConnected(This) ) 

#define IStreamBufferPlayback_IsAtLive(This,pfAtLive)	\
    ( (This)->lpVtbl -> IsAtLive(This,pfAtLive) ) 

#define IStreamBufferPlayback_GetOffsetFromLive(This,pllOffsetFromLive)	\
    ( (This)->lpVtbl -> GetOffsetFromLive(This,pllOffsetFromLive) ) 

#define IStreamBufferPlayback_SetDesiredOffsetFromLive(This,llOffsetFromLive)	\
    ( (This)->lpVtbl -> SetDesiredOffsetFromLive(This,llOffsetFromLive) ) 

#define IStreamBufferPlayback_GetLoadIncarnation(This,pdwLoadIncarnation)	\
    ( (This)->lpVtbl -> GetLoadIncarnation(This,pdwLoadIncarnation) ) 

#define IStreamBufferPlayback_EnableBackgroundPriority(This,fEnableBackgroundPriority)	\
    ( (This)->lpVtbl -> EnableBackgroundPriority(This,fEnableBackgroundPriority) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferPlayback_INTERFACE_DEFINED__ */


#ifndef __IDVREngineHelpersDeleteMonitor_INTERFACE_DEFINED__
#define __IDVREngineHelpersDeleteMonitor_INTERFACE_DEFINED__

/* interface IDVREngineHelpersDeleteMonitor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVREngineHelpersDeleteMonitor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49AB7D6F-05B4-4ae4-9DB3-2F4A667CE674")
    IDVREngineHelpersDeleteMonitor
    {
    public:
        BEGIN_INTERFACE
        virtual void STDMETHODCALLTYPE DeleteInProgress( void) = 0;
        
        END_INTERFACE
    };
    
#else 	/* C style interface */

    typedef struct IDVREngineHelpersDeleteMonitorVtbl
    {
        BEGIN_INTERFACE
        
        void ( STDMETHODCALLTYPE *DeleteInProgress )( 
            IDVREngineHelpersDeleteMonitor * This);
        
        END_INTERFACE
    } IDVREngineHelpersDeleteMonitorVtbl;

    interface IDVREngineHelpersDeleteMonitor
    {
        CONST_VTBL struct IDVREngineHelpersDeleteMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVREngineHelpersDeleteMonitor_DeleteInProgress(This)	\
    ( (This)->lpVtbl -> DeleteInProgress(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVREngineHelpersDeleteMonitor_INTERFACE_DEFINED__ */


#ifndef __IDVREngineHelpers_INTERFACE_DEFINED__
#define __IDVREngineHelpers_INTERFACE_DEFINED__

/* interface IDVREngineHelpers */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDVREngineHelpers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88F784A7-E9D0-4178-AB99-A6C0267D0D8F")
    IDVREngineHelpers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteRecording( 
            /* [in] */ LPCOLESTR pszFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CleanupOrphanedRecordings( 
            /* [in] */ LPCOLESTR pszDirName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRecordingSizeOnDisk( 
            LPCOLESTR pszRecordingName,
            LONGLONG *pllBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterActivityCallback( 
            /* [in] */ IDVREngineHelpersDeleteMonitor *piDVREngineHelpersDeleteMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterActivityCallback( 
            /* [in] */ IDVREngineHelpersDeleteMonitor *piDVREngineHelpersDeleteMonitor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVREngineHelpersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVREngineHelpers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVREngineHelpers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVREngineHelpers * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRecording )( 
            IDVREngineHelpers * This,
            /* [in] */ LPCOLESTR pszFileName);
        
        HRESULT ( STDMETHODCALLTYPE *CleanupOrphanedRecordings )( 
            IDVREngineHelpers * This,
            /* [in] */ LPCOLESTR pszDirName);
        
        HRESULT ( STDMETHODCALLTYPE *GetRecordingSizeOnDisk )( 
            IDVREngineHelpers * This,
            LPCOLESTR pszRecordingName,
            LONGLONG *pllBytes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterActivityCallback )( 
            IDVREngineHelpers * This,
            /* [in] */ IDVREngineHelpersDeleteMonitor *piDVREngineHelpersDeleteMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterActivityCallback )( 
            IDVREngineHelpers * This,
            /* [in] */ IDVREngineHelpersDeleteMonitor *piDVREngineHelpersDeleteMonitor);
        
        END_INTERFACE
    } IDVREngineHelpersVtbl;

    interface IDVREngineHelpers
    {
        CONST_VTBL struct IDVREngineHelpersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVREngineHelpers_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVREngineHelpers_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVREngineHelpers_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVREngineHelpers_DeleteRecording(This,pszFileName)	\
    ( (This)->lpVtbl -> DeleteRecording(This,pszFileName) ) 

#define IDVREngineHelpers_CleanupOrphanedRecordings(This,pszDirName)	\
    ( (This)->lpVtbl -> CleanupOrphanedRecordings(This,pszDirName) ) 

#define IDVREngineHelpers_GetRecordingSizeOnDisk(This,pszRecordingName,pllBytes)	\
    ( (This)->lpVtbl -> GetRecordingSizeOnDisk(This,pszRecordingName,pllBytes) ) 

#define IDVREngineHelpers_RegisterActivityCallback(This,piDVREngineHelpersDeleteMonitor)	\
    ( (This)->lpVtbl -> RegisterActivityCallback(This,piDVREngineHelpersDeleteMonitor) ) 

#define IDVREngineHelpers_UnregisterActivityCallback(This,piDVREngineHelpersDeleteMonitor)	\
    ( (This)->lpVtbl -> UnregisterActivityCallback(This,piDVREngineHelpersDeleteMonitor) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVREngineHelpers_INTERFACE_DEFINED__ */


#ifndef __IStreamBufferMediaSeeking_INTERFACE_DEFINED__
#define __IStreamBufferMediaSeeking_INTERFACE_DEFINED__

/* interface IStreamBufferMediaSeeking */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamBufferMediaSeeking;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f61f5c26-863d-4afa-b0ba-2f81dc978596")
    IStreamBufferMediaSeeking : public IMediaSeeking
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IStreamBufferMediaSeekingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStreamBufferMediaSeeking * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStreamBufferMediaSeeking * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *CheckCapabilities )( 
            IStreamBufferMediaSeeking * This,
            /* [out][in] */ DWORD *pCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *IsFormatSupported )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPreferredFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ const GUID *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDuration )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *GetStopPosition )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPosition )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertTimeFormat )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pTarget,
            /* [in] */ const GUID *pTargetFormat,
            /* [in] */ LONGLONG Source,
            /* [in] */ const GUID *pSourceFormat);
        
        HRESULT ( STDMETHODCALLTYPE *SetPositions )( 
            IStreamBufferMediaSeeking * This,
            /* [out][in] */ LONGLONG *pCurrent,
            /* [in] */ DWORD dwCurrentFlags,
            /* [out][in] */ LONGLONG *pStop,
            /* [in] */ DWORD dwStopFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPositions )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pCurrent,
            /* [out] */ LONGLONG *pStop);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailable )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pEarliest,
            /* [out] */ LONGLONG *pLatest);
        
        HRESULT ( STDMETHODCALLTYPE *SetRate )( 
            IStreamBufferMediaSeeking * This,
            /* [in] */ double dRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRate )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ double *pdRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreroll )( 
            IStreamBufferMediaSeeking * This,
            /* [out] */ LONGLONG *pllPreroll);
        
        END_INTERFACE
    } IStreamBufferMediaSeekingVtbl;

    interface IStreamBufferMediaSeeking
    {
        CONST_VTBL struct IStreamBufferMediaSeekingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamBufferMediaSeeking_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamBufferMediaSeeking_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamBufferMediaSeeking_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamBufferMediaSeeking_GetCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking_CheckCapabilities(This,pCapabilities)	\
    ( (This)->lpVtbl -> CheckCapabilities(This,pCapabilities) ) 

#define IStreamBufferMediaSeeking_IsFormatSupported(This,pFormat)	\
    ( (This)->lpVtbl -> IsFormatSupported(This,pFormat) ) 

#define IStreamBufferMediaSeeking_QueryPreferredFormat(This,pFormat)	\
    ( (This)->lpVtbl -> QueryPreferredFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_GetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> GetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_IsUsingTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> IsUsingTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_SetTimeFormat(This,pFormat)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,pFormat) ) 

#define IStreamBufferMediaSeeking_GetDuration(This,pDuration)	\
    ( (This)->lpVtbl -> GetDuration(This,pDuration) ) 

#define IStreamBufferMediaSeeking_GetStopPosition(This,pStop)	\
    ( (This)->lpVtbl -> GetStopPosition(This,pStop) ) 

#define IStreamBufferMediaSeeking_GetCurrentPosition(This,pCurrent)	\
    ( (This)->lpVtbl -> GetCurrentPosition(This,pCurrent) ) 

#define IStreamBufferMediaSeeking_ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat)	\
    ( (This)->lpVtbl -> ConvertTimeFormat(This,pTarget,pTargetFormat,Source,pSourceFormat) ) 

#define IStreamBufferMediaSeeking_SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags)	\
    ( (This)->lpVtbl -> SetPositions(This,pCurrent,dwCurrentFlags,pStop,dwStopFlags) ) 

#define IStreamBufferMediaSeeking_GetPositions(This,pCurrent,pStop)	\
    ( (This)->lpVtbl -> GetPositions(This,pCurrent,pStop) ) 

#define IStreamBufferMediaSeeking_GetAvailable(This,pEarliest,pLatest)	\
    ( (This)->lpVtbl -> GetAvailable(This,pEarliest,pLatest) ) 

#define IStreamBufferMediaSeeking_SetRate(This,dRate)	\
    ( (This)->lpVtbl -> SetRate(This,dRate) ) 

#define IStreamBufferMediaSeeking_GetRate(This,pdRate)	\
    ( (This)->lpVtbl -> GetRate(This,pdRate) ) 

#define IStreamBufferMediaSeeking_GetPreroll(This,pllPreroll)	\
    ( (This)->lpVtbl -> GetPreroll(This,pllPreroll) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamBufferMediaSeeking_INTERFACE_DEFINED__ */

#endif /* __DVREngineLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_DvrInterfaces_0001_0187 */
/* [local] */ 

DEFINE_GUID(CLSID_DVRSinkFilterMPEG,   0x07bd5a67, 0x25b8, 0x4738, 0x8c, 0xfc, 0x66, 0x31, 0x6c, 0xe6, 0x79, 0x9c);
DEFINE_GUID(CLSID_DVRSourceFilterMPEG, 0xa791e35d, 0xdcd7, 0x46cc, 0xa8, 0xf5, 0x99, 0xd3, 0x89, 0x9f, 0xf9, 0x21);
DEFINE_GUID(CLSID_DVDNav,              0x2e517ba9, 0x5f2c, 0x4e6e, 0x86, 0xe2, 0x53, 0x37, 0x63, 0x85, 0x8f, 0xec);
DEFINE_GUID(CLSID_AudioSync,           0x04aa8285, 0x3c64, 0x4cc8, 0x8c, 0x83, 0x32, 0x6d, 0xa7, 0x15, 0x76, 0xf0);
DEFINE_GUID(CLSID_DVRProgramStreamMux, 0xe9fa2a46, 0x8cd8, 0x4a5c, 0xae, 0x52, 0xb8, 0x23, 0x78, 0x70, 0x3a, 0x69);


extern RPC_IF_HANDLE __MIDL_itf_DvrInterfaces_0001_0187_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_DvrInterfaces_0001_0187_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dvp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*==========================================================================;
 *
 *  File:       dvp.h
 *  Content:    DirectDraw VideoPort include file
 *
 ***************************************************************************/

#pragma once

#include <windows.h>
#include <ddraw.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoPort objects
 */


DEFINE_GUID(IID_IDirectDrawVideoPort,   0xB36D93E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56);

DEFINE_GUID(DDVPTYPE_E_HREFH_VREFH,     0x54F39980,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_E_HREFH_VREFL,     0x92783220,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_E_HREFL_VREFH,     0xA07A02E0,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_E_HREFL_VREFL,     0xE09C77E0,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_CCIR656,           0xFCA326A0,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_BROOKTREE,         0x1352A560,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);
DEFINE_GUID(DDVPTYPE_PHILIPS,           0x332CF160,0xDA61,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8);

/*
 * Forward interface declerations
 */

struct IDDVideoPortContainer;
struct IDirectDrawVideoPort;

typedef struct IDDVideoPortContainer    *LPDDVIDEOPORTCONTAINER;
typedef struct IDirectDrawVideoPort     *LPDIRECTDRAWVIDEOPORT;

/*
 * DirectDraw Structures
 */

/*
 * DDVIDEOPORTCONNECT
 */

typedef struct _DDVIDEOPORTCONNECT
{
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags

} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

/*
 * DVIDEOPORTCONNECT dwFlags values.
 */

#define DDVPCONNECT_DOUBLECLOCK         0x00000001
#define DDVPCONNECT_VACT                0x00000002
#define DDVPCONNECT_INVERTPOLARITY      0x00000004
#define DDVPCONNECT_DISCARDSVREFDATA    0x00000008
#define DDVPCONNECT_HALFLINE            0x00000010
#define DDVPCONNECT_INTERLACED          0x00000020
#define DDVPCONNECT_SHAREEVEN           0x00000040
#define DDVPCONNECT_SHAREODD            0x00000080

#define DDVPCONNECT_VALID               (DDVPCONNECT_DOUBLECLOCK      | \
                                         DDVPCONNECT_VACT             | \
                                         DDVPCONNECT_INVERTPOLARITY   | \
                                         DDVPCONNECT_DISCARDSVREFDATA | \
                                         DDVPCONNECT_HALFLINE         | \
                                         DDVPCONNECT_INTERLACED       | \
                                         DDVPCONNECT_SHAREEVEN        | \
                                         DDVPCONNECT_SHAREODD)

/*
 * DDVIDEOPORTCAPS
 */

typedef struct _DDVIDEOPORTCAPS
{
    DWORD dwSize;                           // size of the DDVIDEOPORTCAPS structure
    DWORD dwFlags;                          // indicates which fields contain data
    DWORD dwMaxWidth;                       // max width of the video port field
    DWORD dwMaxVBIWidth;                    // max width of the VBI data
    DWORD dwMaxHeight;                      // max height of the video port field
    DWORD dwVideoPortID;                    // Video port ID (0 - (dwMaxVideoPorts -1))
    DWORD dwCaps;                           // Video port capabilities
    DWORD dwFX;                             // More video port capabilities
    DWORD dwNumAutoFlipSurfaces;            // Max number of autoflippable surfaces allowed
    DWORD dwAlignVideoPortBoundary;         // Byte restriction of placement within the surface
    DWORD dwAlignVideoPortPrescaleWidth;    // Byte restriction of width after prescaling
    DWORD dwAlignVideoPortCropBoundary;     // Byte restriction of left cropping
    DWORD dwAlignVideoPortCropWidth;        // Byte restriction of cropping width
    DWORD dwPreshrinkXStep;                 // Width can be shrunk in steps of 1/x
    DWORD dwPreshrinkYStep;                 // Height can be shrunk in steps of 1/x
    DWORD dwNumVBIAutoFlipSurfaces;         // Max number of VBI autoflippable surfaces allowed
    DWORD dwNumPreferredAutoflip;           // Optimal number of autoflippable surfaces for hardware
    WORD  wNumFilterTapsX;                  // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    WORD  wNumFilterTapsY;                  // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)

} DDVIDEOPORTCAPS, * LPDDVIDEOPORTCAPS;

/*
 * DDVIDEOPORTCAPS dwFlags values.
 */

#define DDVPD_WIDTH             0x00000001
#define DDVPD_HEIGHT            0x00000002
#define DDVPD_ID                0x00000004
#define DDVPD_CAPS              0x00000008
#define DDVPD_FX                0x00000010
#define DDVPD_AUTOFLIP          0x00000020
#define DDVPD_ALIGN             0x00000040
#define DDVPD_PREFERREDAUTOFLIP 0x00000080
#define DDVPD_FILTERQUALITY     0x00000100

#define DDVPD_VALID             (DDVPD_WIDTH             | \
                                 DDVPD_HEIGHT            | \
                                 DDVPD_ID                | \
                                 DDVPD_CAPS              | \
                                 DDVPD_FX                | \
                                 DDVPD_AUTOFLIP          | \
                                 DDVPD_ALIGN             | \
                                 DDVPD_PREFERREDAUTOFLIP | \
                                 DDVPD_FILTERQUALITY)

/*
 * DDVIDEOPORTCAPS dwCaps values.
 */

#define DDVPCAPS_AUTOFLIP               0x00000001
#define DDVPCAPS_INTERLACED             0x00000002
#define DDVPCAPS_NONINTERLACED          0x00000004
#define DDVPCAPS_READBACKFIELD          0x00000008
#define DDVPCAPS_READBACKLINE           0x00000010
#define DDVPCAPS_SHAREABLE              0x00000020
#define DDVPCAPS_SKIPEVENFIELDS         0x00000040
#define DDVPCAPS_SKIPODDFIELDS          0x00000080
#define DDVPCAPS_SYNCMASTER             0x00000100
#define DDVPCAPS_VBISURFACE             0x00000200
#define DDVPCAPS_COLORCONTROL           0x00000400
#define DDVPCAPS_OVERSAMPLEDVBI         0x00000800
#define DDVPCAPS_SYSTEMMEMORY           0x00001000
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT 0x00002000
#define DDVPCAPS_HARDWAREDEINTERLACE    0x00004000

#define DDVPCAPS_VALID          (DDVPCAPS_AUTOFLIP               |\
                                 DDVPCAPS_INTERLACED             |\
                                 DDVPCAPS_NONINTERLACED          |\
                                 DDVPCAPS_READBACKFIELD          |\
                                 DDVPCAPS_READBACKLINE           |\
                                 DDVPCAPS_SHAREABLE              |\
                                 DDVPCAPS_SKIPEVENFIELDS         |\
                                 DDVPCAPS_SKIPODDFIELDS          |\
                                 DDVPCAPS_SYNCMASTER             |\
                                 DDVPCAPS_VBISURFACE             |\
                                 DDVPCAPS_COLORCONTROL           |\
                                 DDVPCAPS_OVERSAMPLEDVBI         |\
                                 DDVPCAPS_SYSTEMMEMORY           |\
                                 DDVPCAPS_VBIANDVIDEOINDEPENDENT |\
                                 DDVPCAPS_HARDWAREDEINTERLACE)

/*
 * DDVIDEOPORTCAPS dwFX values.
 */

#define DDVPFX_CROPTOPDATA      0x00000001
#define DDVPFX_CROPX            0x00000002
#define DDVPFX_CROPY            0x00000004
#define DDVPFX_INTERLEAVE       0x00000008
#define DDVPFX_MIRRORLEFTRIGHT  0x00000010
#define DDVPFX_MIRRORUPDOWN     0x00000020
#define DDVPFX_PRESHRINKX       0x00000040
#define DDVPFX_PRESHRINKY       0x00000080
#define DDVPFX_PRESHRINKXB      0x00000100
#define DDVPFX_PRESHRINKYB      0x00000200
#define DDVPFX_PRESHRINKXS      0x00000400
#define DDVPFX_PRESHRINKYS      0x00000800
#define DDVPFX_PRESTRETCHX      0x00001000
#define DDVPFX_PRESTRETCHY      0x00002000
#define DDVPFX_PRESTRETCHXN     0x00004000
#define DDVPFX_PRESTRETCHYN     0x00008000
#define DDVPFX_VBICONVERT       0x00010000
#define DDVPFX_VBINOSCALE       0x00020000
#define DDVPFX_IGNOREVBIXCROP   0x00040000
#define DDVPFX_VBINOINTERLEAVE  0x00080000

#define DDVPFX_VALID            (DDVPFX_CROPTOPDATA     |\
                                 DDVPFX_CROPX           |\
                                 DDVPFX_CROPY           |\
                                 DDVPFX_INTERLEAVE      |\
                                 DDVPFX_MIRRORLEFTRIGHT |\
                                 DDVPFX_MIRRORUPDOWN    |\
                                 DDVPFX_PRESHRINKX      |\
                                 DDVPFX_PRESHRINKY      |\
                                 DDVPFX_PRESHRINKXB     |\
                                 DDVPFX_PRESHRINKYB     |\
                                 DDVPFX_PRESHRINKXS     |\
                                 DDVPFX_PRESHRINKYS     |\
                                 DDVPFX_PRESTRETCHX     |\
                                 DDVPFX_PRESTRETCHY     |\
                                 DDVPFX_PRESTRETCHXN    |\
                                 DDVPFX_PRESTRETCHYN    |\
                                 DDVPFX_VBICONVERT      |\
                                 DDVPFX_VBINOSCALE      |\
                                 DDVPFX_IGNOREVBIXCROP  |\
                                 DDVPFX_VBINOINTERLEAVE)

/*
 * DDVIDEOPORTDESC
 */

typedef struct _DDVIDEOPORTDESC
{
    DWORD              dwSize;                   // size of the DDVIDEOPORTDESC structure
    DWORD              dwFieldWidth;             // width of the video port field
    DWORD              dwVBIWidth;               // width of the VBI data
    DWORD              dwFieldHeight;            // height of the video port field
    DWORD              dwMicrosecondsPerField;   // Microseconds per video field
    DWORD              dwMaxPixelsPerSecond;     // Maximum pixel rate per second
    DWORD              dwVideoPortID;            // Video port ID (0 - (dwMaxVideoPorts -1))
    DDVIDEOPORTCONNECT VideoPortType;            // Description of video port connection

} DDVIDEOPORTDESC, * LPDDVIDEOPORTDESC;

/*
 * DDVIDEOPORTINFO
 */

typedef struct _DDVIDEOPORTINFO
{
    DWORD           dwSize;                 // Size of the structure
    DWORD           dwOriginX;              // Placement of the video data within the surface.
    DWORD           dwOriginY;              // Placement of the video data within the surface.
    DWORD           dwVPFlags;              // Video port options
    RECT            rCrop;                  // Cropping rectangle (optional).
    DWORD           dwPrescaleWidth;        // Determines pre-scaling/zooming in the X direction (optional).
    DWORD           dwPrescaleHeight;       // Determines pre-scaling/zooming in the Y direction (optional).
    LPDDPIXELFORMAT lpddpfInputFormat;      // Video format written to the video port
    LPDDPIXELFORMAT lpddpfVBIInputFormat;   // Input format of the VBI data
    LPDDPIXELFORMAT lpddpfVBIOutputFormat;  // Output format of the data
    DWORD           dwVBIHeight;            // Specifies the number of lines of data within the vertical blanking interval.

} DDVIDEOPORTINFO, * LPDDVIDEOPORTINFO;

/*
 * DDVIDEOPORTINFO dwVPFlags values.
 */

#define DDVP_AUTOFLIP               0x00000001
#define DDVP_CONVERT                0x00000002
#define DDVP_CROP                   0x00000004
#define DDVP_INTERLEAVE             0x00000008
#define DDVP_MIRRORLEFTRIGHT        0x00000010
#define DDVP_MIRRORUPDOWN           0x00000020
#define DDVP_PRESCALE               0x00000040
#define DDVP_SKIPEVENFIELDS         0x00000080
#define DDVP_SKIPODDFIELDS          0x00000100
#define DDVP_SYNCMASTER             0x00000200
#define DDVP_VBICONVERT             0x00000400
#define DDVP_VBINOSCALE             0x00000800
#define DDVP_OVERRIDEBOBWEAVE       0x00001000
#define DDVP_IGNOREVBIXCROP         0x00002000
#define DDVP_VBINOINTERLEAVE        0x00004000
#define DDVP_HARDWAREDEINTERLACE    0x00008000
#define DDVP_COLORCONTROL           0x00010000
#define DDVP_READBACKFIELD          0x00020000
#define DDVP_READBACKLINE           0x00040000

#define DDVP_VALID                  (DDVP_AUTOFLIP            | \
                                     DDVP_CONVERT             | \
                                     DDVP_CROP                | \
                                     DDVP_INTERLEAVE          | \
                                     DDVP_MIRRORLEFTRIGHT     | \
                                     DDVP_MIRRORUPDOWN        | \
                                     DDVP_PRESCALE            | \
                                     DDVP_SKIPEVENFIELDS      | \
                                     DDVP_SKIPODDFIELDS       | \
                                     DDVP_SYNCMASTER          | \
                                     DDVP_VBICONVERT          | \
                                     DDVP_VBINOSCALE          | \
                                     DDVP_OVERRIDEBOBWEAVE    | \
                                     DDVP_IGNOREVBIXCROP      | \
                                     DDVP_VBINOINTERLEAVE     | \
                                     DDVP_HARDWAREDEINTERLACE | \
                                     DDVP_COLORCONTROL        | \
                                     DDVP_READBACKFIELD       | \
                                     DDVP_READBACKLINE)

/*
 * DDVIDEOPORTBANDWIDTH
 */

typedef struct _DDVIDEOPORTBANDWIDTH
{
    DWORD dwSize;               // Size of the structure
    DWORD dwCaps;               // Caps bits.
    DWORD dwOverlay;            // Zoom factor at which overlay is supported
    DWORD dwColorkey;           // Zoom factor at which overlay w/ colorkey is supported
    DWORD dwYInterpolate;       // Zoom factor at which overlay w/ Y interpolation is supported
    DWORD dwYInterpAndColorkey; // Zoom factor at which ovelray w/ Y interpolation and colorkeying is supported

} DDVIDEOPORTBANDWIDTH, * LPDDVIDEOPORTBANDWIDTH;

/*
 * DDVIDEOPORTBANDWIDTH dwFlags values.
 */

#define DDVPB_VIDEOPORT         0x00000001
#define DDVPB_OVERLAY           0x00000002
#define DDVPB_TYPE              0x00000004

#define DDVPB_VALID             (DDVPB_VIDEOPORT | \
                                 DDVPB_OVERLAY   | \
                                 DDVPB_TYPE)

/*
 * DDVIDEOPORTBANDWIDTH dwCaps values.
 */

#define DDVPBCAPS_SOURCE        0x00000001
#define DDVPBCAPS_DESTINATION   0x00000002

#define DDVPBCAPS_VALID         (DDVPBCAPS_SOURCE      | \
                                 DDVPBCAPS_DESTINATION)

/*
 * DDVIDEOPORTSTATUS
 */

typedef struct _DDVIDEOPORTSTATUS
{
    DWORD              dwSize;          // Size of the structure
    BOOL               bInUse;          // TRUE if video port is currently being used
    DWORD              dwFlags;         // Currently not used
    DDVIDEOPORTCONNECT VideoPortType;   // Information about the connection

} DDVIDEOPORTSTATUS, * LPDDVIDEOPORTSTATUS;

/*
 * DDVIDEOPORTSTATUS dwFlags values.
 */

#define DDVPSTATUS_VBIONLY      0x00000001
#define DDVPSTATUS_VIDEOONLY    0x00000002

#define DDVPSTATUS_VALID        (DDVPSTATUS_VBIONLY | \
                                 DDVPSTATUS_VIDEOONLY)

/*
 * API's
 */

typedef HRESULT (FAR PASCAL * LPDDENUMVIDEOCALLBACK)(LPDDVIDEOPORTCAPS, LPVOID);

/*
 * IDirectDrawVideoPortContainer
 */

#undef INTERFACE
#define INTERFACE IDDVideoPortContainer
DECLARE_INTERFACE_( IDDVideoPortContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /*** IDirectDrawVideoPort methods ***/
    STDMETHOD(CreateVideoPort)(THIS_ DWORD, LPDDVIDEOPORTDESC, LPDIRECTDRAWVIDEOPORT *, IUnknown *) PURE;
    STDMETHOD(EnumVideoPorts)(THIS_ DWORD, LPDDVIDEOPORTCAPS, LPVOID, LPDDENUMVIDEOCALLBACK) PURE;
    STDMETHOD(GetVideoPortConnectInfo)(THIS_ DWORD, LPDWORD, LPDDVIDEOPORTCONNECT) PURE;
    STDMETHOD(QueryVideoPortStatus)(THIS_ DWORD, LPDDVIDEOPORTSTATUS) PURE;
};

/*
 * IDirectDrawVideoPort
 */

#undef INTERFACE
#define INTERFACE IDirectDrawVideoPort
DECLARE_INTERFACE_( IDirectDrawVideoPort, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /*** IVideoPort methods ***/
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetBandwidthInfo)(THIS_ LPDDPIXELFORMAT, DWORD, DWORD, DWORD, LPDDVIDEOPORTBANDWIDTH) PURE;
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(GetInputFormats)(THIS_ LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetOutputFormats)(THIS_ LPDDPIXELFORMAT, LPDWORD, LPDDPIXELFORMAT, DWORD) PURE;
    STDMETHOD(GetFieldPolarity)(THIS_ LPBOOL) PURE;
    STDMETHOD(GetVideoLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVideoSignalStatus)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetTargetSurface)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(StartVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(StopVideo)(THIS) PURE;
    STDMETHOD(UpdateVideo)(THIS_ LPDDVIDEOPORTINFO) PURE;
    STDMETHOD(WaitForSync)(THIS_ DWORD, DWORD, DWORD) PURE;
};

/*
 * DirectDraw Video Port method flags
 */

/*
 * Flags for IDirectDrawVideoPort::GetInputFormats and
 * IDirectDrawVideoPort::GetOutputFormats
 */

#define DDVPFORMAT_VIDEO    0x00000001
#define DDVPFORMAT_VBI      0x00000002

#define DDVPFORMAT_VALID    (DDVPFORMAT_VIDEO | \
                             DDVPFORMAT_VBI)

/*
 * Flags for IDirectDrawVideoPort::SetTargetSurface
 */

#define DDVPTARGET_VIDEO    0x00000001
#define DDVPTARGET_VBI      0x00000002

#define DDVPTARGET_VALID    (DDVPTARGET_VIDEO | \
                             DDVPTARGET_VBI)

/*
 * Flags for IDirectDrawVideoPort::WaitForSync
 */

#define DDVPWAIT_BEGIN      0x00000001
#define DDVPWAIT_END        0x00000002
#define DDVPWAIT_LINE       0x00000003

#define DDVPWAIT_VALID      (DDVPWAIT_BEGIN | \
                             DDVPWAIT_END   | \
                             DDVPWAIT_LINE)

/*
 * Flags for IDirectDrawVideoPort::Flip
 */

#define DDVPFLIP_VIDEO      0x00000001
#define DDVPFLIP_VBI        0x00000002

#define DDVPFLIP_VALID      (DDVPFLIP_VIDEO | \
                             DDVPFLIP_VBI)

/*
 * Flags for IDirectDrawVideoPort::GetVideoSignalStatus
 */

#define DDVPSQ_NOSIGNAL     0x00000001
#define DDVPSQ_SIGNALOK     0x00000002

/*
 * Flags for IDDVideoPortContainer::CreateVideoPort
 */

#define DDVPCREATE_VBIONLY      0x00000001
#define DDVPCREATE_VIDEOONLY    0x00000002

#define DDVPCREATE_VALID        (DDVPCREATE_VIDEOONLY | \
                                 DDVPCREATE_VBIONLY)

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dwnnot.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:12 2007
 */
/* Compiler settings for ..\dwnnot.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dwnnot_h__
#define __dwnnot_h__

/* Forward Declarations */ 

#ifndef __IDownloadNotify_FWD_DEFINED__
#define __IDownloadNotify_FWD_DEFINED__
typedef interface IDownloadNotify IDownloadNotify;
#endif 	/* __IDownloadNotify_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dwnnot_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// dwnnot.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IDownloadNotify Interface.


EXTERN_C const GUID CGID_DownloadHost;
#ifndef _LPDOWNLOADHOST_CMDID_DEFINED
#define _LPDOWNLOADHOST_CMDID_DEFINED
#define DWNHCMDID_SETDOWNLOADNOTIFY (0)
#endif
#ifndef _LPDOWNLOADNOTIFY_DEFINED
#define _LPDOWNLOADNOTIFY_DEFINED
#define DWNTYPE_HTM     0
#define DWNTYPE_IMG     1
#define DWNTYPE_BITS    2
#define DWNTYPE_FILE    3
#define DWNTYPE_CSS     4


extern RPC_IF_HANDLE __MIDL_itf_dwnnot_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dwnnot_0000_v0_0_s_ifspec;

#ifndef __IDownloadNotify_INTERFACE_DEFINED__
#define __IDownloadNotify_INTERFACE_DEFINED__

/* interface IDownloadNotify */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IDownloadNotify __RPC_FAR *LPDOWNLOADNOTIFY;


EXTERN_C const IID IID_IDownloadNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("caeb5d28-ae4c-11d1-ba40-00c04fb92d79")
    IDownloadNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DownloadStart( 
            /* [in] */ LPCWSTR pchUrl,
            /* [in] */ DWORD dwDownloadId,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadComplete( 
            /* [in] */ DWORD dwDownloadId,
            /* [in] */ HRESULT hrNotify,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDownloadNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDownloadNotify __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDownloadNotify __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDownloadNotify __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DownloadStart )( 
            IDownloadNotify __RPC_FAR * This,
            /* [in] */ LPCWSTR pchUrl,
            /* [in] */ DWORD dwDownloadId,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DownloadComplete )( 
            IDownloadNotify __RPC_FAR * This,
            /* [in] */ DWORD dwDownloadId,
            /* [in] */ HRESULT hrNotify,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IDownloadNotifyVtbl;

    interface IDownloadNotify
    {
        CONST_VTBL struct IDownloadNotifyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDownloadNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDownloadNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDownloadNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDownloadNotify_DownloadStart(This,pchUrl,dwDownloadId,dwType,dwReserved)	\
    (This)->lpVtbl -> DownloadStart(This,pchUrl,dwDownloadId,dwType,dwReserved)

#define IDownloadNotify_DownloadComplete(This,dwDownloadId,hrNotify,dwReserved)	\
    (This)->lpVtbl -> DownloadComplete(This,dwDownloadId,hrNotify,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDownloadNotify_DownloadStart_Proxy( 
    IDownloadNotify __RPC_FAR * This,
    /* [in] */ LPCWSTR pchUrl,
    /* [in] */ DWORD dwDownloadId,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IDownloadNotify_DownloadStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDownloadNotify_DownloadComplete_Proxy( 
    IDownloadNotify __RPC_FAR * This,
    /* [in] */ DWORD dwDownloadId,
    /* [in] */ HRESULT hrNotify,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IDownloadNotify_DownloadComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDownloadNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dwnnot_0082 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_dwnnot_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dwnnot_0082_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxatlpb.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
#ifndef dxatlpb_h
#define dxatlpb_h

#include <atlctl.h>

#ifndef DXTDbg_h
#include <dxtdbg.h>
#endif

#define COM_INTERFACE_ENTRY_DXIMPL(x)\
    COM_INTERFACE_ENTRY_IID(IID_##x, x##DXImpl<_ComMapClass>)

/*** IOleObjectDXImpl
*   This is a simplified version used to allow a transform
*   to be hosted by IE
*/
template <class T>
class ATL_NO_VTABLE IOleObjectDXImpl
{
  public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
        STDMETHOD_(ULONG,AddRef)() = 0;
        STDMETHOD_(ULONG,Release)() = 0;

    // IOleObject
    //
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::SetClientSite" );
        HRESULT hr = S_OK;
        if( pClientSite && DXIsBadInterfacePtr( pClientSite ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            T* pT = static_cast<T*>(this);
            pT->m_cpOleClientSite = pClientSite;
        }
        return hr;
    }

    STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClientSite" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( ppClientSite, sizeof( *ppClientSite )) )
        {
            hr = E_POINTER;
        }
        else
        {
            T* pT = static_cast<T*>(this);
            *ppClientSite = pT->m_cpOleClientSite;
        }
        return hr;
    }

    STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::SetHostNames" );
        return S_OK;
    }
    STDMETHOD(Close)(DWORD dwSaveOption)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::Close" );
        return S_OK;
    }
    STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::SetMoniker" );
        return E_NOTIMPL;
    }
    STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMoniker" );
        return E_NOTIMPL;
    }
    STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::InitFromData" );
        return E_NOTIMPL;
    }
    STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetClipboardData" );
        return E_NOTIMPL;
    }

    STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
                                     HWND hwndParent, LPCRECT lprcPosRect)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
        return S_OK;
    }
    STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::DoVerb" );
        return OLEOBJ_E_NOVERBS;
    }
    STDMETHOD(Update)(void)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::Update" );
        return S_OK;
    }
    STDMETHOD(IsUpToDate)(void)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::IsUpToDate" );
        return S_OK;
    }
    STDMETHOD(GetUserClassID)(CLSID *pClsid)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserClassID" );
        _ASSERTE(pClsid);
        if( DXIsBadWritePtr( pClsid, sizeof( *pClsid ) ) )
        {
            return E_POINTER;
        }
        else
        {
            *pClsid = T::GetObjectCLSID();
            return S_OK;
        }
    }
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetUserType" );
        return OLE_S_USEREG;
    }
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::SetExtent" );
        return S_OK;
    }
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetExtent" );
        HRESULT hr = S_OK;
        if( DXIsBadWritePtr( psizel, sizeof( *psizel ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            psizel->cx = 0;
            psizel->cy = 0;
        }
        return hr;
    }
    STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::Advise" );
        return S_OK;
    }
    STDMETHOD(Unadvise)(DWORD dwConnection)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::Unadvise" );
        return S_OK;
    }
    STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::EnumAdvise" );
        return E_FAIL;
    }
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::GetMiscStatus" );
        return OLE_S_USEREG;
    }
    STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
    {
        DXTDBG_FUNC( "IOleObjectDXImpl::SetColorScheme" );
        return E_NOTIMPL;
    }
};

/*** CComPropBase
*
*/
class ATL_NO_VTABLE CComPropBase
{
public:
    HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag,
        LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
    {
        USES_CONVERSION;
        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
            if (pMap[i].szDesc == NULL)
                continue;
            CComVariant var;

            if(pMap[i].piidDispatch != piidOld)
            {
                pDispatch.Release();
                if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                {
                    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
                    return E_FAIL;
                }
                piidOld = pMap[i].piidDispatch;
            }

            if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
            {
                ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                return E_FAIL;
            }
            
            HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
            if (FAILED(hr))
            {
                if (hr == E_INVALIDARG)
                {
                    ATLTRACE(_T("Property %s not in Bag\n"), OLE2CT(pMap[i].szDesc));
                }
                else
                {
                    // Many containers return different ERROR values for Member not found
                    ATLTRACE(_T("Error attempting to read Property %s from PropertyBag \n"), OLE2CT(pMap[i].szDesc));
                }
                continue;
            }

            if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
            {
                ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                return E_FAIL;
            }
        }
        return S_OK;

    }

    HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
        BOOL fClearDirty, BOOL /*fSaveAllProperties*/, ATL_PROPMAP_ENTRY* pMap)
    {
        if (pPropBag == NULL)
        {
            ATLTRACE(_T("PropBag pointer passed in was invalid\n"));
            return E_POINTER;
        }

        CComPtr<IDispatch> pDispatch;
        const IID* piidOld = NULL;
        for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
            if (pMap[i].szDesc == NULL)
                continue;
            CComVariant var;

            if(pMap[i].piidDispatch != piidOld)
            {
                pDispatch.Release();
                if(FAILED(PropQueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
                {
                    ATLTRACE(_T("Failed to get a dispatch pointer for property #%i\n"), i);
                    return E_FAIL;
                }
                piidOld = pMap[i].piidDispatch;
            }

            if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
            {
                ATLTRACE(_T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
                return E_FAIL;
            }

            if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
            {
                if (var.punkVal == NULL)
                {
                    ATLTRACE(_T("Warning skipping empty IUnknown in Save\n"));
                    continue;
                }
            }

            HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
            if (FAILED(hr))
                return hr;
        }
        m_bRequiresSave = FALSE;
        return S_OK;
    }

    HRESULT ISpecifyPropertyPages_GetPages(CAUUID* pPages,
        ATL_PROPMAP_ENTRY* pMap)
    {
        _ASSERTE(pMap != NULL);
        int nCnt = 0;
        // Get count of unique pages
            int i;
        for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
            if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                nCnt++;
        }
        pPages->pElems = NULL;
        pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
        if (pPages->pElems == NULL)
            return E_OUTOFMEMORY;
        nCnt = 0;
        for(i = 0; pMap[i].pclsidPropPage != NULL; i++)
        {
            if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
            {
                BOOL bMatch = FALSE;
                for (int j=0;j<nCnt;j++)
                {
                    if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
                    {
                        bMatch = TRUE;
                        break;
                    }
                }
                if (!bMatch)
                    pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
            }
        }
        pPages->cElems = nCnt;
        return S_OK;
    }
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv) = 0;
    BOOL m_bRequiresSave;
};


template <class T>
class ATL_NO_VTABLE CComPropertySupport :  public CComPropBase
{
public:
    virtual HRESULT PropQueryInterface(const IID& iid, void** ppv)
    {
        T* pT = static_cast<T*>(this);
    return pT->_InternalQueryInterface(iid, ppv);
    }
};


#ifdef IEMOBILE
// on ATL 80, the IPersistPropertyBag_Load and IPersistPropertyBag_Save are implemented in 
// IPersistPropertyBagImpl class, which is different with ATL 21(did NOT implement these helpers in
// IPersistPropertyBagImpl class)
// since some legacy classes may derive from both 
// CComPropBase and IPersistPropertyBagImpl, there is a name ambigious error. The derived 
// classes can use this MACRO to cover the IPersistPropertyBag_Load and 
// IPersistPropertyBag_Save in IPersistPropertyBagImpl with CComPropBase impl
// A sample is: IPERSISTPROPERTYBAG_HELPERS_IMPL(CComPropBase)
#define IPERSISTPROPERTYBAG_HELPERS_IMPL(X) \
    HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, \
        LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap) \
    { \
        return X::IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap); \
    } \
    HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, \
        BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap) \
    { \
        return X::IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap); \
    }
#endif

//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T> 
class ATL_NO_VTABLE IObjectSafetyImpl2 : public IObjectSafety
{
public:
        DWORD m_dwSafety[4];
        const IID *m_pIID[4];

        IObjectSafetyImpl2()
    {
            m_pIID[0] = &IID_IDispatch;
            m_pIID[1] = &IID_IPersistPropertyBag;
            m_pIID[2] = &IID_IPersistStorage;
            m_pIID[3] = &IID_IPersistStream;
            for (int i = 0; i < 4; i++)
            {
        m_dwSafety[i] = 0;
            }
    }

    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
    _ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl2)

    // IObjectSafety
    //
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
        
        if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
            return E_POINTER;
        
        for (int i = 0; i < 4 && m_pIID[i]; i++)
        {
            DWORD dwSupportedOptions;

            if (i == 0)
            {
                // IDispatch
                dwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
            }
            else
            {
                // IPersist*
                dwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
            }

            if (riid == *m_pIID[i]) 
            {
                *pdwSupportedOptions = dwSupportedOptions;
                *pdwEnabledOptions = m_dwSafety[i];
                return S_OK;
            }
        }
                *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        return E_NOINTERFACE;
    }
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
    {
        ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
        
        // If we're being asked to set our safe for scripting option then oblige
        for (int i = 0; (i < 4) && m_pIID[i]; i++)
        {
            if (riid == *m_pIID[i])
            {
                DWORD dwSupportedOptions;

                if (i == 0)
                {
                    // IDispatch
                    dwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
                }
                else
                {
                    // IPersist*
                    dwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
                }
                
                // If we are asked to set options we don't support then fail
                if (dwOptionSetMask & ~dwSupportedOptions)
                {
                    return E_FAIL;
                }
                DWORD dwNewSafety = (m_dwSafety[i] & ~dwOptionSetMask) | (dwOptionSetMask & dwEnabledOptions);
                // Store our current safety level to return in GetInterfaceSafetyOptions
                m_dwSafety[i] = dwNewSafety;
                return S_OK;
            }

        }
        return E_NOINTERFACE;
    }

};

#endif // This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxhelp3.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// DXHELP3.cpp : Contains routines shared by multiple 3D effects
#include "dxhelp3.h"
#include <malloc.h>
#include <math.h>
#include <stdio.h>

void Rotate::Set(D3DVECTOR d3dvctrNormal, double dAngle)
{
#ifdef _DEBUG
    float NormalSum =   d3dvctrNormal.x * d3dvctrNormal.x + 
                        d3dvctrNormal.y * d3dvctrNormal.y + 
                        d3dvctrNormal.z * d3dvctrNormal.z;
    _ASSERT(NormalSum == 0.0f || (0.99f < NormalSum && NormalSum < 1.01f));
#endif

    // The following transformation matrix routines are from
    // Graphics Gems (the first one) page 466 (Converting 
    // between Matrix and Axis-Amount Representations)
    float s = (float)sin(dAngle), c = (float)cos(dAngle);
    float t = 1.0f - c;

    m_d3dvctrXComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.x + c;
    m_d3dvctrXComponent.y = t * d3dvctrNormal.x * d3dvctrNormal.y - s * d3dvctrNormal.z;
    m_d3dvctrXComponent.z = t * d3dvctrNormal.x * d3dvctrNormal.z + s * d3dvctrNormal.y;

    m_d3dvctrYComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.y + s * d3dvctrNormal.z;
    m_d3dvctrYComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.y + c;
    m_d3dvctrYComponent.z = t * d3dvctrNormal.y * d3dvctrNormal.z - s * d3dvctrNormal.x;

    m_d3dvctrZComponent.x = t * d3dvctrNormal.x * d3dvctrNormal.z - s * d3dvctrNormal.y;
    m_d3dvctrZComponent.y = t * d3dvctrNormal.y * d3dvctrNormal.z + s * d3dvctrNormal.x;
    m_d3dvctrZComponent.z = t * d3dvctrNormal.z * d3dvctrNormal.z + c;
}

static HRESULT DecoupleOneMeshBuilder(void *lpThis /* Ignored */, 
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderOut,
				      IDirect3DRMMeshBuilder3 *lpMeshBuilderIn)
{
    HRESULT hr = lpMeshBuilderOut->SetAppData(lpMeshBuilderIn->GetAppData());

    if(FAILED(hr))
    {
	return hr;
    }

    const int ciOutputFaceCount = lpMeshBuilderOut->GetFaceCount();
    const int ciMaxFaceCount = lpMeshBuilderIn->GetFaceCount();
    if(!ciMaxFaceCount)
    {
	return hr;
    }
    CComPtr<IDirect3DRMFaceArray> cpD3DRMFaceArray;

    hr = lpMeshBuilderIn->GetFaces(&cpD3DRMFaceArray);
    if(hr != D3DRM_OK)
    {
	return hr;
    }

    D3DVECTOR *lpvctrPosition = NULL;
    D3DVECTOR *lpvctrFaceNormals = NULL;
    DWORD dwMaxVertexCount = 0;

    // By reserving space we speed things up by a factor of 20 or 30 X!

    DWORD dwTotalVertexCount = lpMeshBuilderIn->GetVertexCount();
    _ASSERT(dwTotalVertexCount >= 3);
    if (dwTotalVertexCount/ciMaxFaceCount < 3)
    {
	dwTotalVertexCount = ciMaxFaceCount * 3;  // There will be at least 3 vertices per face.
    }
    hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount);

    if(hr != D3DRM_OK)
    {
	return hr;
    }

    // Need to have seperate vertices for each face in the output mesh.
    int iFaceIndex = 0;
    do
    {
	CComPtr<IDirect3DRMFace> cpd3dInFaceTemp;
	CComPtr<IDirect3DRMFace2> cpd3dOutFace;

        if(FAILED(hr = cpD3DRMFaceArray->GetElement((DWORD)iFaceIndex, &cpd3dInFaceTemp)))
        {
            break;
        }
        _ASSERT(cpd3dInFaceTemp);

	CComPtr<IDirect3DRMFace2> cpd3dInFace;
	if(FAILED(hr = cpd3dInFaceTemp->QueryInterface(
		IID_IDirect3DRMFace2, (void **)&cpd3dInFace)))
	{
	    break;
	}

        DWORD dwVertexCount;

        cpd3dInFace->GetVertices(&dwVertexCount, NULL, NULL);
        _ASSERT(dwVertexCount >= 3);

        if(dwVertexCount > dwMaxVertexCount)
        {
            dwMaxVertexCount = dwVertexCount;

	    D3DVECTOR *lpTemp = lpvctrPosition;
            D3DVECTOR *lpNormalTemp = lpvctrFaceNormals;

	    lpvctrPosition = (D3DVECTOR *)realloc(lpvctrPosition, dwMaxVertexCount * sizeof (*lpvctrPosition));
	    lpvctrFaceNormals = (D3DVECTOR *)realloc(lpvctrFaceNormals, dwMaxVertexCount * sizeof (*lpvctrFaceNormals));

	    if(!lpvctrPosition || !lpvctrFaceNormals)
	    {
		free(lpTemp);
		free(lpNormalTemp);
		hr = E_OUTOFMEMORY;
		break;
	    }

	    // We may have a problem in the amount of space reserved in the output meshbuilder.
	    if((ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount > dwTotalVertexCount)
	    {
		dwTotalVertexCount = (ciMaxFaceCount -  iFaceIndex) * dwMaxVertexCount;
		hr = lpMeshBuilderOut->ReserveSpace(dwTotalVertexCount, dwTotalVertexCount, ciMaxFaceCount - iFaceIndex);

		if(hr != D3DRM_OK)
		{
		    break;
		}
	    }
        }

        if(FAILED(hr = cpd3dInFace->GetVertices(&dwVertexCount, lpvctrPosition, lpvctrFaceNormals)) ||
	   FAILED(hr = lpMeshBuilderOut->CreateFace(&cpd3dOutFace)) ||
	   FAILED(hr = cpd3dOutFace->SetAppData(cpd3dInFace->GetAppData())))
        {
            break;
        }


	CComPtr<IDirect3DRMMaterial2> cpMaterial;
        CComPtr<IDirect3DRMTexture3> cpTexture;
        BOOL bU, bV;

        if(hr != D3DRM_OK ||
          (hr = cpd3dInFace->GetMaterial(&cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetMaterial(cpMaterial)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetColor(cpd3dInFace->GetColor())) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTexture(&cpTexture)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTexture(cpTexture)) != D3DRM_OK ||
          (hr = cpd3dInFace->GetTextureTopology(&bU, &bV)) != D3DRM_OK ||
          (hr = cpd3dOutFace->SetTextureTopology(bU, bV)) != D3DRM_OK)
        {
            break;
        }

        DWORD dwInFaceVertex = 0;
        do
        {
            int iVIndex = lpMeshBuilderOut->AddVertex(lpvctrPosition[dwInFaceVertex].x, 
					 lpvctrPosition[dwInFaceVertex].y, 
					 lpvctrPosition[dwInFaceVertex].z);
            int iNIndex = lpMeshBuilderOut->AddNormal(lpvctrFaceNormals[dwInFaceVertex].x, 
					 lpvctrFaceNormals[dwInFaceVertex].y, 
					 lpvctrFaceNormals[dwInFaceVertex].z);

            D3DVALUE U, V;

            if(FAILED(hr = cpd3dOutFace->AddVertexAndNormalIndexed(iVIndex, iNIndex)) ||
               FAILED(hr = cpd3dInFace->GetTextureCoordinates(dwInFaceVertex, &U, &V)) ||
               FAILED(hr = cpd3dOutFace->SetTextureCoordinates(dwInFaceVertex, U, V)))
            {
                break;
            }
        } while (++dwInFaceVertex < dwVertexCount);
	dwTotalVertexCount -= dwVertexCount;
    } while (hr == D3DRM_OK && ++iFaceIndex < ciMaxFaceCount);

    free(lpvctrPosition);
    free(lpvctrFaceNormals);

    return hr;
}

HRESULT TraverseSubMeshes(  HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			    void *lpThis, 
			    IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			    IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    HRESULT hr;

    _ASSERT(lpCallBack);
    if(FAILED(hr = (*lpCallBack)(lpThis, lpMeshBuilderOut, lpMeshBuilderIn)))
	return hr;

    DWORD dwInSubMeshCount;
    hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, NULL);

    if(FAILED(hr) || dwInSubMeshCount == 0)
	return hr;

    DWORD dwOutSubMeshCount;
    if(FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, NULL)))
    {
	return hr;
    }

    const BOOL bCreateOutMeshes = (dwOutSubMeshCount == 0);
    _ASSERT(bCreateOutMeshes || dwInSubMeshCount == dwOutSubMeshCount);

    LPUNKNOWN *lplpunkInSubMeshes =
	(LPUNKNOWN *)malloc(dwInSubMeshCount * sizeof(*lplpunkInSubMeshes));

    LPUNKNOWN *lplpunkOutSubMeshes = (bCreateOutMeshes? NULL:
	(LPUNKNOWN *)malloc(dwOutSubMeshCount * sizeof(*lplpunkOutSubMeshes)));

    if(!lplpunkInSubMeshes || !bCreateOutMeshes && !lplpunkOutSubMeshes)
    {
	return E_OUTOFMEMORY;
    }

    if(FAILED(hr = lpMeshBuilderIn->GetSubMeshes(&dwInSubMeshCount, lplpunkInSubMeshes)) ||
	!bCreateOutMeshes && 
	FAILED(hr = lpMeshBuilderOut->GetSubMeshes(&dwOutSubMeshCount, lplpunkOutSubMeshes)))
    {
	return hr;
    }

    CComPtr<IDirect3DRMMeshBuilder3> cpInSubMesh, cpOutSubMesh;

    DWORD dwSubMesh;
    for(dwSubMesh = 0; SUCCEEDED(hr) && dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	cpInSubMesh = NULL;
	cpOutSubMesh = NULL;

	// Get the current input submesh.
	hr = lplpunkInSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3, 
		(void **)&cpInSubMesh);

	if(FAILED(hr))
	    break;

	if(bCreateOutMeshes)
	{
	    // Create a new submesh in the output mesh to match the input submesh.	    
	    LPUNKNOWN lpunkSubmesh;

	    if(FAILED(hr = lpMeshBuilderOut->CreateSubMesh(&lpunkSubmesh)))
		break;

	    hr = lpunkSubmesh->QueryInterface(IID_IDirect3DRMMeshBuilder3,
							(void **)&cpOutSubMesh);
	    lpunkSubmesh->Release();
	}
	else
	{
	    // Get the current output submesh.
	    hr = lplpunkOutSubMeshes[dwSubMesh]->QueryInterface(IID_IDirect3DRMMeshBuilder3,
		    (void **)&cpOutSubMesh);
	}
	if(FAILED(hr))
	    break;

	// Do all the children for these two MeshBuilders.
	hr = TraverseSubMeshes(lpCallBack, lpThis, cpOutSubMesh, cpInSubMesh);
    }

    for(dwSubMesh = 0; dwSubMesh < dwInSubMeshCount; dwSubMesh++)
    {
	lplpunkInSubMeshes[dwSubMesh]->Release();

	if(lplpunkOutSubMeshes)
	{
	    lplpunkOutSubMeshes[dwSubMesh]->Release();
	}
    }

    free(lplpunkInSubMeshes);
    free(lplpunkOutSubMeshes);

    return hr;
}

HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn)
{
    DWORD dwSubMeshCount;

    HRESULT hr = lpMeshBuilderOut->GetSubMeshes(&dwSubMeshCount, NULL);

    if(FAILED(hr))
	return hr;

    if(lpMeshBuilderOut->GetFaceCount() || dwSubMeshCount)
    {
	if(FAILED(hr = lpMeshBuilderOut->Empty(0)))
	    return hr;
    }
    hr = TraverseSubMeshes(DecoupleOneMeshBuilder, NULL,
			    lpMeshBuilderOut, lpMeshBuilderIn);
    return hr;
}

float GetDlgItemFloat(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return (float)strtod(szItemText, &pEnd);
}

BOOL SetDlgItemFloat( HWND hDlg, int id, float f )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2f"), f );
    return SetDlgItemText( hDlg, id, szItem );
}

double GetDlgItemDouble(HWND hDlg, int id)
{
    TCHAR *pEnd;
    TCHAR szItemText[20];
    GetDlgItemText(hDlg, id, szItemText, 20);
    return strtod(szItemText, &pEnd);
}

BOOL SetDlgItemDouble( HWND hDlg, int id, double d )
{
    TCHAR szItem[20];
     _stprintf( szItem, _T("%.2d"), d );
    return SetDlgItemText( hDlg, id, szItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxclrhlp.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor );

typedef struct _COLORVALUE_PAIR
{
    const CHAR  *szName;
    DWORD        dwValue;
} COLORVALUE_PAIR;

const COLORVALUE_PAIR
rgColorNames[] =
{
    { ("aliceblue"),             0xfff0f8ff },
    { ("antiquewhite"),          0xfffaebd7 },
    { ("aqua"),                  0xff00ffff },
    { ("aquamarine"),            0xff7fffd4 },
    { ("azure"),                 0xfff0ffff },
    { ("beige"),                 0xfff5f5dc },
    { ("bisque"),                0xffffe4c4 },
    { ("black"),                 0xff000000 },
    { ("blanchedalmond"),        0xffffebcd },
    { ("blue"),                  0xff0000ff },
    { ("blueviolet"),            0xff8a2be2 },
    { ("brown"),                 0xffa52a2a },
    { ("burlywood"),             0xffdeb887 },
    { ("cadetblue"),             0xff5f9ea0 },
    { ("chartreuse"),            0xff7fff00 },
    { ("chocolate"),             0xffd2691e },
    { ("coral"),                 0xffff7f50 },
    { ("cornflowerblue"),        0xff6495ed },
    { ("cornsilk"),              0xfffff8dc },
    { ("crimson"),               0xffdc143c },
    { ("cyan"),                  0xff00ffff },
    { ("darkblue"),              0xff00008b },
    { ("darkcyan"),              0xff008b8b },
    { ("darkgoldenrod"),         0xffb8860b },
    { ("darkgray"),              0xffa9a9a9 },
    { ("darkgreen"),             0xff006400 },
    { ("darkkhaki"),             0xffbdb76b },
    { ("darkmagenta"),           0xff8b008b },
    { ("darkolivegreen"),        0xff556b2f },
    { ("darkorange"),            0xffff8c00 },
    { ("darkorchid"),            0xff9932cc },
    { ("darkred"),               0xff8b0000 },
    { ("darksalmon"),            0xffe9967a },
    { ("darkseagreen"),          0xff8fbc8f },
    { ("darkslateblue"),         0xff483d8b },
    { ("darkslategray"),         0xff2f4f4f },
    { ("darkturquoise"),         0xff00ced1 },
    { ("darkviolet"),            0xff9400d3 },
    { ("deeppink"),              0xffff1493 },
    { ("deepskyblue"),           0xff00bfff },
    { ("dimgray"),               0xff696969 },
    { ("dodgerblue"),            0xff1e90ff },
    { ("firebrick"),             0xffb22222 },
    { ("floralwhite"),           0xfffffaf0 },
    { ("forestgreen"),           0xff228b22 },
    { ("fuchsia"),               0xffff00ff },
    { ("gainsboro"),             0xffdcdcdc },
    { ("ghostwhite"),            0xfff8f8ff },
    { ("gold"),                  0xffffd700 },
    { ("goldenrod"),             0xffdaa520 },
    { ("gray"),                  0xff808080 },
    { ("green"),                 0xff008000 },
    { ("greenyellow"),           0xffadff2f },
    { ("honeydew"),              0xfff0fff0 },
    { ("hotpink"),               0xffff69b4 },
    { ("indianred"),             0xffcd5c5c },
    { ("indigo"),                0xff4b0082 },
    { ("ivory"),                 0xfffffff0 },
    { ("khaki"),                 0xfff0e68c },
    { ("lavender"),              0xffe6e6fa },
    { ("lavenderblush"),         0xfffff0f5 },
    { ("lawngreen"),             0xff7cfc00 },
    { ("lemonchiffon"),          0xfffffacd },
    { ("lightblue"),             0xffadd8e6 },
    { ("lightcoral"),            0xfff08080 },
    { ("lightcyan"),             0xffe0ffff },
    { ("lightgoldenrodyellow"),  0xfffafad2 },
    { ("lightgreen"),            0xff90ee90 },
    { ("lightgrey"),             0xffd3d3d3 },
    { ("lightpink"),             0xffffb6c1 },
    { ("lightsalmon"),           0xffffa07a },
    { ("lightseagreen"),         0xff20b2aa },
    { ("lightskyblue"),          0xff87cefa },
    { ("lightslategray"),        0xff778899 },
    { ("lightsteelblue"),        0xffb0c4de },
    { ("lightyellow"),           0xffffffe0 },
    { ("lime"),                  0xff00ff00 },
    { ("limegreen"),             0xff32cd32 },
    { ("linen"),                 0xfffaf0e6 },
    { ("magenta"),               0xffff00ff },
    { ("maroon"),                0xff800000 },
    { ("mediumaquamarine"),      0xff66cdaa },
    { ("mediumblue"),            0xff0000cd },
    { ("mediumorchid"),          0xffba55d3 },
    { ("mediumpurple"),          0xff9370db },
    { ("mediumseagreen"),        0xff3cb371 },
    { ("mediumslateblue"),       0xff7b68ee },
    { ("mediumspringgreen"),     0xff00fa9a },
    { ("mediumturquoise"),       0xff48d1cc },
    { ("mediumvioletred"),       0xffc71585 },
    { ("midnightblue"),          0xff191970 },
    { ("mintcream"),             0xfff5fffa },
    { ("mistyrose"),             0xffffe4e1 },
    { ("moccasin"),              0xffffe4b5 },
    { ("navajowhite"),           0xffffdead },
    { ("navy"),                  0xff000080 },
    { ("oldlace"),               0xfffdf5e6 },
    { ("olive"),                 0xff808000 },
    { ("olivedrab"),             0xff6b8e23 },
    { ("orange"),                0xffffa500 },
    { ("orangered"),             0xffff4500 },
    { ("orchid"),                0xffda70d6 },
    { ("palegoldenrod"),         0xffeee8aa },
    { ("palegreen"),             0xff98fb98 },
    { ("paleturquoise"),         0xffafeeee },
    { ("palevioletred"),         0xffdb7093 },
    { ("papayawhip"),            0xffffefd5 },
    { ("peachpuff"),             0xffffdab9 },
    { ("peru"),                  0xffcd853f },
    { ("pink"),                  0xffffc0cb },
    { ("plum"),                  0xffdda0dd },
    { ("powderblue"),            0xffb0e0e6 },
    { ("purple"),                0xff800080 },
    { ("red"),                   0xffff0000 },
    { ("rosybrown"),             0xffbc8f8f },
    { ("royalblue"),             0xff4169e1 },
    { ("saddlebrown"),           0xff8b4513 },
    { ("salmon"),                0xfffa8072 },
    { ("sandybrown"),            0xfff4a460 },
    { ("seagreen"),              0xff2e8b57 },
    { ("seashell"),              0xfffff5ee },
    { ("sienna"),                0xffa0522d },
    { ("silver"),                0xffc0c0c0 },
    { ("skyblue"),               0xff87ceeb },
    { ("slateblue"),             0xff6a5acd },
    { ("slategray"),             0xff708090 },
    { ("snow"),                  0xfffffafa },
    { ("springgreen"),           0xff00ff7f },
    { ("steelblue"),             0xff4682b4 },
    { ("tan"),                   0xffd2b48c },
    { ("teal"),                  0xff008080 },
    { ("thistle"),               0xffd8bfd8 },
    { ("tomato"),                0xffff6347 },
    { ("turquoise"),             0xff40e0d0 },
    { ("violet"),                0xffee82ee },
    { ("wheat"),                 0xfff5deb3 },
    { ("white"),                 0xffffffff },
    { ("whitesmoke"),            0xfff5f5f5 },
    { ("yellow"),                0xffffff00 },
    { ("yellowgreen"),           0xff9acd32 }

}; // rgColorNames[]

#define SIZE_OF_COLOR_TABLE (sizeof(rgColorNames) / sizeof(COLORVALUE_PAIR))

const COLORVALUE_PAIR 
rgSystemColorNames[] =
{
    { ("activeborder"),       COLOR_ACTIVEBORDER},    // Active window border.
    { ("activecaption"),      COLOR_ACTIVECAPTION},   // Active window caption.
    { ("appworkspace"),       COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { ("background"),         COLOR_BACKGROUND},      // Desktop background.
    { ("buttonface"),         COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { ("buttonhighlight"),    COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { ("buttonshadow"),       COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { ("buttontext"),         COLOR_BTNTEXT},         // Text on push buttons.
    { ("captiontext"),        COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { ("graytext"),           COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { ("highlight"),          COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { ("highlighttext"),      COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { ("inactiveborder"),     COLOR_INACTIVEBORDER},  // Inactive window border.
    { ("inactivecaption"),    COLOR_INACTIVECAPTION}, // Inactive window caption.
    { ("inactivecaptiontext"),COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { ("infobackground"),     COLOR_INFOBK},          // Background color for tooltip controls.
    { ("infotext"),           COLOR_INFOTEXT},        // Text color for tooltip controls.
    { ("menu"),               COLOR_MENU},            // Menu background.
    { ("menutext"),           COLOR_MENUTEXT},        // Text in menus.
    { ("scrollbar"),          COLOR_SCROLLBAR},       // Scroll bar gray area.
    { ("threeddarkshadow"),   COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { ("threedface"),         COLOR_3DFACE},
    { ("threedhighlight"),    COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { ("threedlightshadow"),  COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { ("threedshadow"),       COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { ("window"),             COLOR_WINDOW},          // Window background.
    { ("windowframe"),        COLOR_WINDOWFRAME},     // Window frame.
    { ("windowtext"),         COLOR_WINDOWTEXT},      // Text in windows.
}; // rgSystemColorNames[]

#define SIZE_OF_SYSTEM_COLOR_TABLE (sizeof(rgSystemColorNames) / sizeof(COLORVALUE_PAIR))

// BUG: WinSE 107139: Define a maximum bound for the length of a color name string. This is to prevent stack overruns if
// we alloc a string of unknown size. This number must be greater than the longest color name in rgColorNames[] and
// rgSystemColorNames[].
#define LENGTH_OF_MAX_COLOR_STRING 25

//
// Used by DXColorFromBSTR to parse the hex string.
//

inline HRESULT _HexStrToDWORD( char * pch, DWORD * pdwColor )
{

    HRESULT hr = S_OK;
    short hexVals[8];
    int numVals;
    int i;
    DWORD dwmult;

    if( !pch || !pdwColor )
    {
        hr = E_FAIL;
    }
    else
    {
        //--- parse input string
        numVals = 0;
        while( *pch && numVals < 8 )
        {
            if( *pch >= '0' && *pch <= '9' )
            {
                hexVals[numVals++] = *pch++ - '0';
            }
            else if( *pch >= 'a' && *pch <= 'f' )
            {
                hexVals[numVals++] = *pch++ - 'a' + 10;
            }
            else if( *pch >= 'A' && *pch <= 'F' )
            {
                hexVals[numVals++] = *pch++ - 'A' + 10;
            }
            else
            {
                break;
            }
        }

        if( numVals < 6 )
        {
            hr = E_FAIL;
        }
        else
        {
            //--- if we were passed 7 hex digits, only use the first 6
            if( numVals == 7 )
            {
                numVals = 6;
            }

            //--- initialize multiplier
            dwmult = 1;
            *pdwColor = 0;

            //--- multiply hexVals by 16^i
            for( i = 0; i < numVals; i++ )
            {
                *pdwColor += (hexVals[numVals-(i+1)]*dwmult);
                dwmult <<= 4;
            }
        }
    }
   
    return hr;
}

// 
// Used by DXColorFromBSTR to convert a string to lower case
//

inline void StringToLowerCase( CHAR * pstrKey )
{
    if( pstrKey )
    {
        while( *pstrKey )
        {
            if( *pstrKey >= 'A' && *pstrKey <= 'Z' )
            {
                *pstrKey = 'a' + *pstrKey - 'A';
            }
            pstrKey++;
        }
    }
}


inline HRESULT WINAPI DXColorFromBSTR( BSTR Color, DWORD *pdwColor )
{
    HRESULT hr = S_OK;
    // validate arguments
    int strLen = wcslen(Color);
    if( strLen < 3 || strLen > LENGTH_OF_MAX_COLOR_STRING || DXIsBadReadPtr( Color, strLen ) || 
        DXIsBadWritePtr( pdwColor, sizeof(*pdwColor) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- first check for #AARRGGBB and #RRGGBB strings
        if( Color[0] == L'#' )
        {
            CHAR ch[11] = "0xffffffff";
            if( strLen > 9 ) strLen = 9;
            if( strLen >= 7 )
            {
                WideCharToMultiByte( CP_ACP, NULL, &Color[1], strLen-1, &ch[11-strLen], strLen, NULL, NULL );
                hr = _HexStrToDWORD( &ch[2], pdwColor);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            //--- convert the string to lower case
            CHAR strKey[LENGTH_OF_MAX_COLOR_STRING];
            WideCharToMultiByte(CP_ACP, NULL, Color, strLen+1, strKey, sizeof(strKey), NULL, NULL);
            StringToLowerCase(strKey);

            //--- search the string table using a binary search
            int nFirst = 0;
            int nLast = SIZE_OF_COLOR_TABLE - 1;
            int nCur, nCmp;
            bool bFound = false;
            while( (nFirst <= nLast) && !bFound )
            {
                nCur = (nFirst + nLast) / 2;
                nCmp = strcmp(rgColorNames[nCur].szName, strKey);
                if( nCmp < 0 )
                {
                    nFirst = nCur + 1;
                }
                else if( nCmp > 0 )
                {
                    nLast = nCur - 1;
                }
                else
                {
                    bFound = true;
                    *pdwColor = rgColorNames[nCur].dwValue;
                }
            }

            // String not in regular color table, try the system color table.

            if (!bFound)
            {
                nFirst  = 0;
                nLast   = SIZE_OF_SYSTEM_COLOR_TABLE - 1;

                while ((nFirst <= nLast) && !bFound)
                {
                    nCur = (nFirst + nLast) / 2;
                    nCmp = strcmp(rgSystemColorNames[nCur].szName, strKey);

                    if (nCmp < 0)
                    {
                        nFirst = nCur + 1;
                    }
                    else if (nCmp > 0)
                    {
                        nLast = nCur - 1;
                    }
                    else
                    {
                        bFound = true;
                        *pdwColor =  ::GetSysColor((int)rgSystemColorNames[nCur].dwValue);
                        *pdwColor |= 0xFF000000;
                    }
                }

                // String not found in regular or system color table.

                if (!bFound)
                {
                    hr = E_FAIL;
                }
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxbounds.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXBounds.h *
*------------*
*   Description:
*       This is the header file for the bounds helper class implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/22/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXBounds_h
#define DXBounds_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_FLOAT
#include <float.h>
#endif

#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif

#ifndef DXVector_h
#include <DXVector.h>
#endif

//=== Constants ====================================================

#ifdef _ASSERT
#define CHKTYPE() _ASSERT( eType == eBndType )
#else
#define CHKTYPE()
#endif

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXBnds
*
*/
#define CDXB_C CDXBnds<TYPE, USTYPE, STTYPE, eBndType>
#define CDXB_T ((STTYPE*)u.D)
#define CDXB_O( OtherBnd ) ((STTYPE*)(OtherBnd).u.D)

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
class CDXBnds : public DXBNDS
{
  public:
  /*--- Constructors ---*/
    CDXBnds() { eType = eBndType; SetEmpty(); }
    CDXBnds( BOOL bInit ) { eType = eBndType; if (bInit) SetEmpty(); }
    CDXBnds( const DXBNDS& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const CDXB_C& Other ) { eType = eBndType; Copy( Other ); }
    CDXBnds( const RECT & Rect )    { eType = eBndType; SetXYRect( Rect ); }
    CDXBnds( TYPE Width, TYPE Height ) { eType = eBndType; SetXYSize( Width, Height ); }
    CDXBnds( IDXSurface *pSurface, HRESULT & hr) { _ASSERT(eBndType == DXBT_DISCRETE); eType = eBndType; hr = pSurface->GetBounds(this); }
#ifndef IEMOBILE
    CDXBnds( IDirect3DRMMeshBuilder3 *pMesh, HRESULT & hr) { _ASSERT(eBndType == DXBT_CONTINUOUS); eType = eBndType; hr = SetToMeshBounds(pMesh); }
#endif // #ifndef IEMOBILE
    CDXBnds( const CDXV_C& VecPoint ) { eType = eBndType; *this = VecPoint; }

    HRESULT InitFromSafeArray( SAFEARRAY *psa);
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void SetEmpty();
    void Copy( const DXBNDS& Other );
    void Copy( const CDXB_C& Other );

    /*--- Type casts ---*/
    operator STTYPE *   () { CHKTYPE(); return CDXB_T; }
    operator DXDBNDS&   () { CHKTYPE(); return u.D;  }
    operator DXDBNDS64& () { CHKTYPE(); return u.LD; }
    operator DXCBNDS&   () { CHKTYPE(); return u.C;  }
    operator DXCBNDS64& () { CHKTYPE(); return u.LC; }

    //--- Access methods
    USTYPE Width( DXBNDID i ) const { CHKTYPE(); return (USTYPE)(CDXB_T[i].Max - CDXB_T[i].Min); }

    USTYPE Width()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min); }
    USTYPE Height()   const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min); }
    USTYPE Depth()    const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min); }
    USTYPE Duration() const { CHKTYPE(); return (USTYPE)(CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min); }

    TYPE  Left()     const { CHKTYPE(); return CDXB_T[DXB_X].Min; }
    TYPE  Right()    const { CHKTYPE(); return CDXB_T[DXB_X].Max; }
    TYPE  Top()      const { CHKTYPE(); return CDXB_T[DXB_Y].Min; }
    TYPE  Bottom()   const { CHKTYPE(); return CDXB_T[DXB_Y].Max; }

    void SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                    TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax );
    void SetXYRect( const RECT& xyRect);
    void SetXYSize( const SIZE& xySize);
    void SetXYSize( TYPE width, TYPE height);
    void SetXYPoint(const POINT& xyPoint);
    void Offset( TYPE x, TYPE y, TYPE z, TYPE t );
    void Offset( const CDXV_C& v );
    void SetPlacement(const CDXV_C& v);
    void SetToSize(void);
    void GetXYRect( RECT& xyRect ) const;
    void GetXYSize( SIZE& xySize ) const;
    void GetMinVector( CDXV_C& v ) const;
    void GetMaxVector( CDXV_C& v ) const;
    void GetSize( CDXB_C& SizeBounds ) const;
    CDXB_C Size( void ) const;
 


    //--- Region Functions
    void NormalizeBounds();
    BOOL BoundsAreEmpty() const;
    BOOL BoundsAreNull() const;
    BOOL TestIntersect( const CDXB_C& Other ) const;
    BOOL IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );
    BOOL IntersectBounds( const CDXB_C& OtherBounds );
    void UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 );

// Additional Operations
    STTYPE& operator[]( int index )    const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( long index )   const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( USHORT index ) const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DWORD index )  const { CHKTYPE(); return CDXB_T[index]; }
    STTYPE& operator[]( DXBNDID index) const { CHKTYPE(); return CDXB_T[index]; }

    void operator=(const CDXB_C& Bounds);
    void operator=(const CDXV_C& v);
    void operator+=(const POINT& point);
    void operator-=(const POINT& point);
    void operator+=(const SIZE& size);
    void operator-=(const SIZE& size);
    void operator+=(const CDXV_C& v);
    void operator-=(const CDXV_C& v);
    void operator+=(const CDXB_C& Bounds);
    void operator-=(const CDXB_C& Bounds);
    void operator&=(const CDXB_C& Bounds);
    void operator|=(const CDXB_C& Bounds);
    BOOL operator==(const CDXB_C& Bounds) const;
    BOOL operator!=(const CDXB_C& Bounds) const;

// Operators returning CDXDBnds values
    CDXB_C operator+(const POINT& point) const;
    CDXB_C operator-(const POINT& point) const;
    CDXB_C operator+(const SIZE& size) const;
    CDXB_C operator-(const SIZE& size) const;
    CDXB_C operator+(const CDXV_C& v) const;
    CDXB_C operator-(const CDXV_C& v) const;
    CDXB_C operator&(const CDXB_C& Bounds2) const;
    CDXB_C operator|(const CDXB_C& Bounds2) const;

//
// Helpers to grow bounds from their midpoints.
//
    void Scale(TYPE x, TYPE y = 1, TYPE z = 1, TYPE t = 1);
    void Scale(const CDXV_C& v);
    void Expand(TYPE x, TYPE y = 0, TYPE z = 0, TYPE t = 0);
    void Expand(const CDXV_C& v);

// Helpers for DXSurfaces  These functions only work with DISCRETE bounds
    HRESULT SetToSurfaceBounds(IDXSurface * pDXSurface);

#ifndef IEMOBILE
// Helpers for D3DRM Meshes.  These functions only work with CONTINUOUS bounds.
   HRESULT SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh);
#endif // #ifndef IEMOBILE
};

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetEmpty()
{
    CHKTYPE(); 
    memset(CDXB_T, 0, sizeof(STTYPE) * 4);
} /* CDXBnds::SetEmpty() */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const CDXB_C& Other )
{
    CHKTYPE();
    memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Copy( const DXBNDS& Other )
{
    CHKTYPE(); 
    if( eBndType == Other.eType )
    {
        memcpy( CDXB_T, CDXB_O(Other), sizeof( STTYPE ) * 4 );
    }
    else
    {
        int i = 4;
        switch( Other.eType )
        {
          case DXBT_DISCRETE:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.D[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.D[i].Max;
            }
            break;
          case DXBT_DISCRETE64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LD[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LD[i].Max;
            }
            break;
          case DXBT_CONTINUOUS:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.C[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.C[i].Max;
            }
            break;
          case DXBT_CONTINUOUS64:
            while( i-- )
            {
                CDXB_T[i].Min = (TYPE)Other.u.LC[i].Min;
                CDXB_T[i].Max = (TYPE)Other.u.LC[i].Max;
            }
            break;
          default:
            _ASSERT(0);
        }
    }
} /* CDXBnds::Copy constructor */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::InitFromSafeArray( SAFEARRAY *pSA )
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    TYPE *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(TYPE) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                CDXB_T[i].Min = pData[i];
                CDXB_T[i].Max = pData[i+4];
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }

    return hr;
} /* CDXBnds::InitFromSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::GetSafeArray( SAFEARRAY **ppSA ) const
{
    CHKTYPE(); 
    HRESULT hr = S_OK;
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 8;
        static VARTYPE VTypes[4] = { VT_I4, VT_I8, VT_R4, VT_R8 };

        pSA = SafeArrayCreate( VTypes[eBndType], 1, &rgsabound );

        if( pSA == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            TYPE *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = CDXB_T[i].Min;
                    pData[i+4] = CDXB_T[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }

    return hr;
} /* CDXBnds::GetSafeArray */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::NormalizeBounds()
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max < CDXB_T[i].Min )
        {
            TYPE Temp = CDXB_T[i].Min;
            CDXB_T[i].Min = CDXB_T[i].Max;
            CDXB_T[i].Max = Temp;
        }
    }
} /* CDXBnds::NormalizeBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;

    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = min( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );

        if( CDXB_T[i].Max <= CDXB_T[i].Min )
        {
            //--- no intersection
            SetEmpty();
            bDoesIntersect = FALSE;
        }
    }
    return bDoesIntersect;
} /* CDXBnds::IntersectBounds */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::TestIntersect( const CDXB_C& Other ) const
{
    CHKTYPE(); 
    BOOL bDoesIntersect = TRUE;
    TYPE BndMin, BndMax;
    for( int i = 0; i < 4; ++i )
    {
        BndMin = max( CDXB_T[i].Min, CDXB_O( Other )[i].Min );
        BndMax = min( CDXB_T[i].Max, CDXB_O( Other )[i].Max );
        if( BndMax <= BndMin ) bDoesIntersect = FALSE;
    }
    return bDoesIntersect;
} /* CDXBnds::TestIntersect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::UnionBounds( const CDXB_C& Bounds1, const CDXB_C& Bounds2 )
{
    CHKTYPE(); 
    // This assumes the bounds are already normalized.
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_O( Bounds1 )[i].Min, CDXB_O( Bounds2 )[i].Min );
        CDXB_T[i].Max = max( CDXB_O( Bounds1 )[i].Max, CDXB_O( Bounds2 )[i].Max );
    }
} /* CDXDBnds::UnionBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::IntersectBounds( const CDXB_C& OtherBounds )
{
    CHKTYPE(); 
    return IntersectBounds( *this, OtherBounds );
} /* CDXBnds::IntersectBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreEmpty() const
{
    CHKTYPE(); 
    //--- Must exist in all dimensions
    for( int i = 0; i < 4; ++i )
    {
        if( CDXB_T[i].Max <= CDXB_T[i].Min ) return TRUE;
    }
    return FALSE;
} /* CDXBnds::BoundsAreEmpty */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::BoundsAreNull() const
{
    CHKTYPE(); 
    DWORD *pTest = (DWORD *)CDXB_T;
    DWORD *pLimit = pTest + (sizeof(STTYPE) * 4 / sizeof(*pTest));
    do
    {
        if (*pTest) return FALSE;
        pTest++;
    } while (pTest < pLimit);
    return TRUE;
} /* CDXDBnds::BoundsAreNull */

// Additional Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXB_C& srcBounds )
{
    CHKTYPE(); 
    memcpy(CDXB_T, CDXB_O(srcBounds), sizeof(STTYPE)*4);
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator=( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = v[i];
        CDXB_T[i].Max = v[i] + 1;
    }
} /* CDXDBnds::operator= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator==( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return false;
        }
    }
    return true;
} /* CDXB_C::operator== */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
BOOL CDXB_C::operator!=( const CDXB_C& Bounds ) const
{
    CHKTYPE(); 
    for( ULONG i = 0; i < 4; ++i )
    {
        if( ( CDXB_T[i].Min != CDXB_O( Bounds )[i].Min ) ||
            ( CDXB_T[i].Max != CDXB_O( Bounds )[i].Max ) )
        {
            return true;
        }
    }
    return false;
} /* CDXBnds::operator!= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator&( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.IntersectBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator& */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator|( const CDXB_C& Bounds2 ) const
{
    CHKTYPE(); 
    CDXB_C Result;
    Result.UnionBounds( *this, Bounds2 );
    return Result;
} /* CDXBnds::operator| */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMinVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Min;
    }
} /* CDXBnds::GetMinVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetMaxVector( CDXV_C& v ) const
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        v[i] = CDXB_T[i].Max;
    }
} /* CDXBnds::GetMaxVector */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetSize( CDXB_C& SizeBounds ) const
{
    CHKTYPE(); 
    SizeBounds.SetEmpty();
    SizeBounds[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    SizeBounds[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    SizeBounds[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    SizeBounds[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
} /* CDXBnds::GetSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::Size( void ) const
{
    CHKTYPE(); 
    CDXB_C Size;
    Size[DXB_X].Max = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    Size[DXB_Y].Max = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
    Size[DXB_Z].Max = CDXB_T[DXB_Z].Max - CDXB_T[DXB_Z].Min;
    Size[DXB_T].Max = CDXB_T[DXB_T].Max - CDXB_T[DXB_T].Min;
    return Size;
} /* CDXBnds::Size */

// Operations
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetBounds( TYPE xmin, TYPE xmax, TYPE ymin, TYPE ymax,
                        TYPE zmin, TYPE zmax, TYPE tmin, TYPE tmax )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min = xmin;
    CDXB_T[DXB_X].Max = xmax;
    CDXB_T[DXB_Y].Min = ymin;
    CDXB_T[DXB_Y].Max = ymax;
    CDXB_T[DXB_Z].Min = zmin;
    CDXB_T[DXB_Z].Max = zmax;
    CDXB_T[DXB_T].Min = tmin;
    CDXB_T[DXB_T].Max = tmax;
} /* CDXBnds::SetBounds */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYRect( const RECT& xyRect )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyRect.left;
    CDXB_T[DXB_X].Max = (TYPE)xyRect.right;
    CDXB_T[DXB_Y].Min = (TYPE)xyRect.top;
    CDXB_T[DXB_Y].Max = (TYPE)xyRect.bottom;
    CDXB_T[DXB_Z].Max = 1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYRect( RECT& xyRect ) const
{
    CHKTYPE(); 
    xyRect.left   = CDXB_T[DXB_X].Min;
    xyRect.right  = CDXB_T[DXB_X].Max;
    xyRect.top    = CDXB_T[DXB_Y].Min;
    xyRect.bottom = CDXB_T[DXB_Y].Max;
} /* CDXBnds::GetXYRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::GetXYSize( SIZE& xySize ) const
{
    CHKTYPE(); 
    xySize.cx = CDXB_T[DXB_X].Max - CDXB_T[DXB_X].Min;
    xySize.cy = CDXB_T[DXB_Y].Max - CDXB_T[DXB_Y].Min;
} /* CDXBnds::GetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( const SIZE& xySize )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)xySize.cx;
    CDXB_T[DXB_Y].Max = (TYPE)xySize.cy;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYSize( TYPE width, TYPE height )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Max = (TYPE)width;
    CDXB_T[DXB_Y].Max = (TYPE)height;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXBnds::SetXYSize */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetXYPoint( const POINT& xyPoint )
{
    CHKTYPE(); 
    SetEmpty();
    CDXB_T[DXB_X].Min = (TYPE)xyPoint.x;
    CDXB_T[DXB_X].Max = (TYPE)xyPoint.x + 1;
    CDXB_T[DXB_Y].Min = (TYPE)xyPoint.y;
    CDXB_T[DXB_Y].Max = (TYPE)xyPoint.y + 1;
    CDXB_T[DXB_Z].Max = (TYPE)1;
    CDXB_T[DXB_T].Max = (TYPE)LONG_MAX;
} /* CDXDBnds::SetRect */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( TYPE x, TYPE y, TYPE z, TYPE t )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += x;
    CDXB_T[DXB_X].Max += x;
    CDXB_T[DXB_Y].Min += y;
    CDXB_T[DXB_Y].Max += y;
    CDXB_T[DXB_Z].Min += z;
    CDXB_T[DXB_Z].Max += z;
    CDXB_T[DXB_T].Min += t;
    CDXB_T[DXB_T].Max += t;
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetToSize(void)
{
    CHKTYPE();
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max -= CDXB_T[i].Min;
        CDXB_T[i].Min = 0;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::SetPlacement(const CDXV_C & v)
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Max += (CDXV_O( v )[i] - CDXB_T[i].Min);
        CDXB_T[i].Min = CDXV_O( v )[i];
    }
} /* CDXBnds::Offset */


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Offset( const CDXV_C& v )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min += v[i];
        CDXB_T[i].Max += v[i];
    }
} /* CDXBnds::Offset */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)point.x;
    CDXB_T[DXB_X].Max += (TYPE)point.x;
    CDXB_T[DXB_Y].Min += (TYPE)point.y;
    CDXB_T[DXB_Y].Max += (TYPE)point.y;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const POINT &point)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)point.x;
    CDXB_T[DXB_X].Max -= (TYPE)point.x;
    CDXB_T[DXB_Y].Min -= (TYPE)point.y;
    CDXB_T[DXB_Y].Max -= (TYPE)point.y;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += (TYPE)size.cx;
    CDXB_T[DXB_X].Max += (TYPE)size.cx;
    CDXB_T[DXB_Y].Min += (TYPE)size.cy;
    CDXB_T[DXB_Y].Max += (TYPE)size.cy;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const SIZE &size)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= (TYPE)size.cx;
    CDXB_T[DXB_X].Max -= (TYPE)size.cx;
    CDXB_T[DXB_Y].Min -= (TYPE)size.cy;
    CDXB_T[DXB_Y].Max -= (TYPE)size.cy;
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max += CDXV_O( v )[DXB_T];
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=(const CDXV_C& v)
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_T[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_T[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_T[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_T[DXB_T].Max -= CDXV_O( v )[DXB_T];
} /* CDXBnds::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator+=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min += CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max += CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min += CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max += CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min += CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max += CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min += CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max += CDXB_O( Bounds )[DXB_T].Max;
} /* CDXBnds::operator+= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator-=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    CDXB_T[DXB_X].Min -= CDXB_O( Bounds )[DXB_X].Min;
    CDXB_T[DXB_X].Max -= CDXB_O( Bounds )[DXB_X].Max;
    CDXB_T[DXB_Y].Min -= CDXB_O( Bounds )[DXB_Y].Min;
    CDXB_T[DXB_Y].Max -= CDXB_O( Bounds )[DXB_Y].Max;
    CDXB_T[DXB_Z].Min -= CDXB_O( Bounds )[DXB_Z].Min;
    CDXB_T[DXB_Z].Max -= CDXB_O( Bounds )[DXB_Z].Max;
    CDXB_T[DXB_T].Min -= CDXB_O( Bounds )[DXB_T].Min;
    CDXB_T[DXB_T].Max -= CDXB_O( Bounds )[DXB_T].Max;
} /* CDXB_C::operator-= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator&=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( int i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = max( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = min( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator&= */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::operator|=( const CDXB_C& Bounds )
{
    CHKTYPE(); 
    for( long i = 0; i < 4; ++i )
    {
        CDXB_T[i].Min = min( CDXB_T[i].Min, CDXB_O( Bounds )[i].Min );
        CDXB_T[i].Max = max( CDXB_T[i].Max, CDXB_O( Bounds )[i].Max );
    }
} /* CDXB_C::operator|= */


// operators returning CDXDBnds values
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += point.x;
    CDXB_O( Result )[DXB_X].Max += point.x;
    CDXB_O( Result )[DXB_Y].Min += point.y;
    CDXB_O( Result )[DXB_Y].Max += point.y;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const POINT &point) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= point.x;
    CDXB_O( Result )[DXB_X].Max -= point.x;
    CDXB_O( Result )[DXB_Y].Min -= point.y;
    CDXB_O( Result )[DXB_Y].Max -= point.y;
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const SIZE &size) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += size.cx;
    CDXB_O( Result )[DXB_X].Max += size.cx;
    CDXB_O( Result )[DXB_Y].Min += size.cy;
    CDXB_O( Result )[DXB_Y].Max += size.cy;
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-( const SIZE &size ) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= size.cx;
    CDXB_O( Result )[DXB_X].Max -= size.cx;
    CDXB_O( Result )[DXB_Y].Min -= size.cy;
    CDXB_O( Result )[DXB_Y].Max -= size.cy;
    return Result;
} /* CDXB_C::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator+(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max += CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max += CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max += CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min += CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max += CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator+ */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
CDXB_C CDXB_C::operator-(const CDXV_C& v) const
{
    CHKTYPE(); 
    CDXB_C Result( *this );
    CDXB_O( Result )[DXB_X].Min -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_X].Max -= CDXV_O( v )[DXB_X];
    CDXB_O( Result )[DXB_Y].Min -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Y].Max -= CDXV_O( v )[DXB_Y];
    CDXB_O( Result )[DXB_Z].Min -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_Z].Max -= CDXV_O( v )[DXB_Z];
    CDXB_O( Result )[DXB_T].Min -= CDXV_O( v )[DXB_T];
    CDXB_O( Result )[DXB_T].Max -= CDXV_O( v )[DXB_T];
    return Result;
} /* CDXBnds::operator- */

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToSurfaceBounds(IDXSurface * pDXSurface)
{
#if (eBndType != DXBT_DISCRETE)
#error SetToSurfacBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    return pDXSurface->GetBounds( this );
}

#ifndef IEMOBILE
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
HRESULT CDXB_C::SetToMeshBounds(IDirect3DRMMeshBuilder3 * pMesh)
{
#if (eBndType != DXBT_CONTINUOUS)
#error SetToMeshBounds requires a continuous bounds.
#endif
    CHKTYPE(); 
    D3DRMBOX Box;
    HRESULT hr = pMesh->GetBox(&Box);
    u.C[DXB_X].Min = Box.min.x;
    u.C[DXB_X].Max = Box.max.x;
    u.C[DXB_Y].Min = Box.min.y;
    u.C[DXB_Y].Max = Box.max.y;
    u.C[DXB_Z].Min = Box.min.z;
    u.C[DXB_Z].Max = Box.max.z;
    u.C[DXB_T].Min = 0;
    u.C[DXB_T].Max = 1.;
    return hr;
}
#endif // #ifndef IEMOBILE

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE mid = (CDXB_T[i].Min + CDXB_T[i].Max) / 2;
        TYPE scale = CDXV_O(v)[i] * (CDXB_T[i].Max - mid);
        CDXB_T[i].Min = mid - scale;
        CDXB_T[i].Max = mid + scale;
    }
}

template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Scale(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Scale(CDXV_C(x, y, z, t));
}


template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(const CDXV_C& v)
{
    CHKTYPE(); 
    for(long i = 0; i < 4; ++i )
    {
        TYPE scale = CDXV_O(v)[i] / 2;
        CDXB_T[i].Min -= scale;
        CDXB_T[i].Max += scale;
    }
}

    
template<class TYPE, class USTYPE, class STTYPE, DXBNDTYPE eBndType>
void CDXB_C::Expand(TYPE x, TYPE y, TYPE z, TYPE t)
{
    Expand(CDXV_C(x, y, z, t));
}


//---
typedef CDXBnds<long, unsigned long, DXDBND, DXBT_DISCRETE> CDXDBnds;
typedef CDXBnds<LONGLONG, ULONGLONG, DXDBND64, DXBT_DISCRETE64> CDXDBnds64;
typedef CDXBnds<float, float, DXCBND, DXBT_CONTINUOUS> CDXCBnds;
typedef CDXBnds<double, double, DXCBND64, DXBT_CONTINUOUS64> CDXCBnds64;

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================


//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxmplay.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for dxmplay.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxmplay_h__
#define __dxmplay_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDSPlayerEx_FWD_DEFINED__
#define __IDSPlayerEx_FWD_DEFINED__
typedef interface IDSPlayerEx IDSPlayerEx;
#endif 	/* __IDSPlayerEx_FWD_DEFINED__ */


#ifndef __IMediaPlayer_FWD_DEFINED__
#define __IMediaPlayer_FWD_DEFINED__
typedef interface IMediaPlayer IMediaPlayer;
#endif 	/* __IMediaPlayer_FWD_DEFINED__ */


#ifndef __IMediaPlayer2_FWD_DEFINED__
#define __IMediaPlayer2_FWD_DEFINED__
typedef interface IMediaPlayer2 IMediaPlayer2;
#endif 	/* __IMediaPlayer2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "enums.h"
#include "mpdvd.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_dxmplay_0000_0000 */
/* [local] */ 

typedef /* [public][uuid] */  DECLSPEC_UUID("66504301-BE0F-101A-8BBB-00AA00300CAB") DWORD VB_OLE_COLOR;

typedef /* [public] */ 
enum MPDisplayModeConstants
    {	mpTime	= 0,
	mpFrames	= ( mpTime + 1 ) 
    } 	MPDisplayModeConstants;

typedef /* [public] */ 
enum MPPlayStateConstants
    {	mpStopped	= 0,
	mpPaused	= ( mpStopped + 1 ) ,
	mpPlaying	= ( mpPaused + 1 ) ,
	mpWaiting	= ( mpPlaying + 1 ) ,
	mpScanForward	= ( mpWaiting + 1 ) ,
	mpScanReverse	= ( mpScanForward + 1 ) ,
	mpClosed	= ( mpScanReverse + 1 ) 
    } 	MPPlayStateConstants;

typedef /* [public] */ 
enum MPfDialogAvailability
    {	mpfFilePropertiesDlg	= 1,
	mpfGotoDlg	= 2
    } 	MPfDialogAvailability;

typedef /* [public] */ 
enum MPMoreInfoType
    {	mpShowURL	= 0,
	mpClipURL	= ( mpShowURL + 1 ) ,
	mpBannerURL	= ( mpClipURL + 1 ) 
    } 	MPMoreInfoType;

typedef /* [public] */ 
enum MPMediaInfoType
    {	mpShowFilename	= 0,
	mpShowTitle	= ( mpShowFilename + 1 ) ,
	mpShowAuthor	= ( mpShowTitle + 1 ) ,
	mpShowCopyright	= ( mpShowAuthor + 1 ) ,
	mpShowRating	= ( mpShowCopyright + 1 ) ,
	mpShowDescription	= ( mpShowRating + 1 ) ,
	mpShowLogoIcon	= ( mpShowDescription + 1 ) ,
	mpClipFilename	= ( mpShowLogoIcon + 1 ) ,
	mpClipTitle	= ( mpClipFilename + 1 ) ,
	mpClipAuthor	= ( mpClipTitle + 1 ) ,
	mpClipCopyright	= ( mpClipAuthor + 1 ) ,
	mpClipRating	= ( mpClipCopyright + 1 ) ,
	mpClipDescription	= ( mpClipRating + 1 ) ,
	mpClipLogoIcon	= ( mpClipDescription + 1 ) ,
	mpBannerImage	= ( mpClipLogoIcon + 1 ) ,
	mpBannerMoreInfo	= ( mpBannerImage + 1 ) ,
	mpWatermark	= ( mpBannerMoreInfo + 1 ) 
    } 	MPMediaInfoType;

typedef /* [public] */ 
enum MPDisplaySizeConstants
    {	mpDefaultSize	= 0,
	mpHalfSize	= ( mpDefaultSize + 1 ) ,
	mpDoubleSize	= ( mpHalfSize + 1 ) ,
	mpFullScreen	= ( mpDoubleSize + 1 ) ,
	mpFitToSize	= ( mpFullScreen + 1 ) ,
	mpOneSixteenthScreen	= ( mpFitToSize + 1 ) ,
	mpOneFourthScreen	= ( mpOneSixteenthScreen + 1 ) ,
	mpOneHalfScreen	= ( mpOneFourthScreen + 1 ) 
    } 	MPDisplaySizeConstants;

typedef /* [public] */ 
enum MPReadyStateConstants
    {	mpReadyStateUninitialized	= 0,
	mpReadyStateLoading	= ( mpReadyStateUninitialized + 1 ) ,
	mpReadyStateInteractive	= 3,
	mpReadyStateComplete	= ( mpReadyStateInteractive + 1 ) 
    } 	MPReadyStateConstants;

typedef /* [public] */ 
enum MPShowDialogConstants
    {	mpShowDialogHelp	= 0,
	mpShowDialogStatistics	= ( mpShowDialogHelp + 1 ) ,
	mpShowDialogOptions	= ( mpShowDialogStatistics + 1 ) ,
	mpShowDialogContextMenu	= ( mpShowDialogOptions + 1 ) 
    } 	MPShowDialogConstants;

/* [hidden] */ 
enum PlayerCompatibilityType
    {	cmDefault	= 0,
	cmActiveMovie	= ( cmDefault + 1 ) ,
	cmNetShow	= ( cmActiveMovie + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_0000_v0_0_s_ifspec;

#ifndef __IDSPlayerEx_INTERFACE_DEFINED__
#define __IDSPlayerEx_INTERFACE_DEFINED__

/* interface IDSPlayerEx */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IDSPlayerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("920F0DE0-91C5-11d1-828F-00C04FC99D4C")
    IDSPlayerEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutStatusTextEx( 
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushStatusBar( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateBrowserToURL( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestartPlaylist( 
            /* [in] */ BOOL fPlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutPreviewModeHelper( 
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UserInteraction( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPositionInternal( 
            /* [retval][out] */ double *pCurrentPosition) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CompatibilityMode( 
            /* [in] */ long lCompatibilityMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CompatibilityMode( 
            /* [retval][out] */ long *plCompatibilityMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DurationInternal( 
            /* [retval][out] */ double *pDuration) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentSeek( 
            /* [retval][out] */ long *plSegmentSeek) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanSkip( 
            /* [retval][out] */ VARIANT_BOOL *pbCanSkip) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BrowserIsIE4( 
            /* [retval][out] */ VARIANT_BOOL *pbCanSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoFullScreen( 
            BOOL bFullScreen) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSPlayerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDSPlayerEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDSPlayerEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDSPlayerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutStatusTextEx )( 
            IDSPlayerEx * This,
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *FlushStatusBar )( 
            IDSPlayerEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateBrowserToURL )( 
            IDSPlayerEx * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame);
        
        HRESULT ( STDMETHODCALLTYPE *RestartPlaylist )( 
            IDSPlayerEx * This,
            /* [in] */ BOOL fPlay);
        
        HRESULT ( STDMETHODCALLTYPE *PutPreviewModeHelper )( 
            IDSPlayerEx * This,
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserInteraction )( 
            IDSPlayerEx * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPositionInternal )( 
            IDSPlayerEx * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_CompatibilityMode )( 
            IDSPlayerEx * This,
            /* [in] */ long lCompatibilityMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CompatibilityMode )( 
            IDSPlayerEx * This,
            /* [retval][out] */ long *plCompatibilityMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_DurationInternal )( 
            IDSPlayerEx * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SegmentSeek )( 
            IDSPlayerEx * This,
            /* [retval][out] */ long *plSegmentSeek);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CanSkip )( 
            IDSPlayerEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbCanSkip);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_BrowserIsIE4 )( 
            IDSPlayerEx * This,
            /* [retval][out] */ VARIANT_BOOL *pbCanSkip);
        
        HRESULT ( STDMETHODCALLTYPE *GoFullScreen )( 
            IDSPlayerEx * This,
            BOOL bFullScreen);
        
        END_INTERFACE
    } IDSPlayerExVtbl;

    interface IDSPlayerEx
    {
        CONST_VTBL struct IDSPlayerExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSPlayerEx_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDSPlayerEx_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDSPlayerEx_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDSPlayerEx_PutStatusTextEx(This,wszText,fOverwrite,pdwCookie)	\
    ( (This)->lpVtbl -> PutStatusTextEx(This,wszText,fOverwrite,pdwCookie) ) 

#define IDSPlayerEx_FlushStatusBar(This)	\
    ( (This)->lpVtbl -> FlushStatusBar(This) ) 

#define IDSPlayerEx_NavigateBrowserToURL(This,bstrURL,bstrFrame)	\
    ( (This)->lpVtbl -> NavigateBrowserToURL(This,bstrURL,bstrFrame) ) 

#define IDSPlayerEx_RestartPlaylist(This,fPlay)	\
    ( (This)->lpVtbl -> RestartPlaylist(This,fPlay) ) 

#define IDSPlayerEx_PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished)	\
    ( (This)->lpVtbl -> PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished) ) 

#define IDSPlayerEx_put_UserInteraction(This,bVal)	\
    ( (This)->lpVtbl -> put_UserInteraction(This,bVal) ) 

#define IDSPlayerEx_get_CurrentPositionInternal(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPositionInternal(This,pCurrentPosition) ) 

#define IDSPlayerEx_put_CompatibilityMode(This,lCompatibilityMode)	\
    ( (This)->lpVtbl -> put_CompatibilityMode(This,lCompatibilityMode) ) 

#define IDSPlayerEx_get_CompatibilityMode(This,plCompatibilityMode)	\
    ( (This)->lpVtbl -> get_CompatibilityMode(This,plCompatibilityMode) ) 

#define IDSPlayerEx_get_DurationInternal(This,pDuration)	\
    ( (This)->lpVtbl -> get_DurationInternal(This,pDuration) ) 

#define IDSPlayerEx_get_SegmentSeek(This,plSegmentSeek)	\
    ( (This)->lpVtbl -> get_SegmentSeek(This,plSegmentSeek) ) 

#define IDSPlayerEx_get_CanSkip(This,pbCanSkip)	\
    ( (This)->lpVtbl -> get_CanSkip(This,pbCanSkip) ) 

#define IDSPlayerEx_get_BrowserIsIE4(This,pbCanSkip)	\
    ( (This)->lpVtbl -> get_BrowserIsIE4(This,pbCanSkip) ) 

#define IDSPlayerEx_GoFullScreen(This,bFullScreen)	\
    ( (This)->lpVtbl -> GoFullScreen(This,bFullScreen) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDSPlayerEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPlayer_INTERFACE_DEFINED__
#define __IMediaPlayer_INTERFACE_DEFINED__

/* interface IMediaPlayer */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IMediaPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D6F311-B0F6-11D0-94AB-0080C74C7E95")
    IMediaPlayer : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ double *pCurrentPosition) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ double CurrentPosition) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ double *pDuration) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceWidth( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceHeight( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MarkerCount( 
            /* [retval][out] */ long *pMarkerCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanScan( 
            /* [retval][out] */ VARIANT_BOOL *pCanScan) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeek( 
            /* [retval][out] */ VARIANT_BOOL *pCanSeek) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeekToMarkers( 
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentMarker( 
            /* [retval][out] */ long *pCurrentMarker) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentMarker( 
            /* [in] */ long CurrentMarker) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceLink( 
            /* [retval][out] */ BSTR *pbstrSourceLink) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE *pCreationDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCorrection( 
            /* [retval][out] */ BSTR *pbstrErrorCorrection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ long *pBandwidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceProtocol( 
            /* [retval][out] */ long *pSourceProtocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceivedPackets( 
            /* [retval][out] */ long *pReceivedPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RecoveredPackets( 
            /* [retval][out] */ long *pRecoveredPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LostPackets( 
            /* [retval][out] */ long *pLostPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceptionQuality( 
            /* [retval][out] */ long *pReceptionQuality) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingCount( 
            /* [retval][out] */ long *pBufferingCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBroadcast( 
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingProgress( 
            /* [retval][out] */ long *pBufferingProgress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR *pbstrChannelName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelDescription( 
            /* [retval][out] */ BSTR *pbstrChannelDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelURL( 
            /* [retval][out] */ BSTR *pbstrChannelURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactAddress( 
            /* [retval][out] */ BSTR *pbstrContactAddress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactPhone( 
            /* [retval][out] */ BSTR *pbstrContactPhone) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactEmail( 
            /* [retval][out] */ BSTR *pbstrContactEmail) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingTime( 
            /* [retval][out] */ double *pBufferingTime) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BufferingTime( 
            /* [in] */ double BufferingTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoStart( 
            /* [retval][out] */ VARIANT_BOOL *pAutoStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoStart( 
            /* [in] */ VARIANT_BOOL AutoStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoRewind( 
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoRewind( 
            /* [in] */ VARIANT_BOOL AutoRewind) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pRate) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double Rate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendKeyboardEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendKeyboardEvents( 
            /* [in] */ VARIANT_BOOL SendKeyboardEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseClickEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseClickEvents( 
            /* [in] */ VARIANT_BOOL SendMouseClickEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseMoveEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseMoveEvents( 
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayCount( 
            /* [retval][out] */ long *pPlayCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PlayCount( 
            /* [in] */ long PlayCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ClickToPlay( 
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ClickToPlay( 
            /* [in] */ VARIANT_BOOL ClickToPlay) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowScan( 
            /* [retval][out] */ VARIANT_BOOL *pAllowScan) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowScan( 
            /* [in] */ VARIANT_BOOL AllowScan) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableContextMenu( 
            /* [in] */ VARIANT_BOOL EnableContextMenu) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ long *pCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ long CursorType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CodecCount( 
            /* [retval][out] */ long *pCodecCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowChangeDisplaySize( 
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowChangeDisplaySize( 
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDurationValid( 
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_OpenState( 
            /* [retval][out] */ long *pOpenState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendOpenStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendOpenStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendWarningEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendWarningEvents( 
            /* [in] */ VARIANT_BOOL SendWarningEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendErrorEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendErrorEvents( 
            /* [in] */ VARIANT_BOOL SendErrorEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayState( 
            /* [retval][out] */ MPPlayStateConstants *pPlayState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendPlayStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendPlayStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplaySize( 
            /* [retval][out] */ MPDisplaySizeConstants *pDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplaySize( 
            /* [in] */ MPDisplaySizeConstants DisplaySize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_InvokeURLs( 
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InvokeURLs( 
            /* [in] */ VARIANT_BOOL InvokeURLs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR *pbstrBaseURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultFrame( 
            /* [retval][out] */ BSTR *pbstrDefaultFrame) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HasError( 
            /* [retval][out] */ VARIANT_BOOL *pHasError) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrErrorDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long *pErrorCode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AnimationAtStart( 
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AnimationAtStart( 
            /* [in] */ VARIANT_BOOL AnimationAtStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_TransparentAtStart( 
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TransparentAtStart( 
            /* [in] */ VARIANT_BOOL TransparentAtStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long *pVolume) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long Volume) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long *pBalance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long Balance) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ MPReadyStateConstants *pValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionStart( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionStart( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionEnd( 
            /* [retval][out] */ double *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionEnd( 
            /* [in] */ double Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowDisplay( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowDisplay( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowPositionControls( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowPositionControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTracker( 
            /* [retval][out] */ VARIANT_BOOL *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTracker( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnablePositionControls( 
            /* [retval][out] */ VARIANT_BOOL *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnablePositionControls( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableTracker( 
            /* [retval][out] */ VARIANT_BOOL *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableTracker( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL Enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayForeColor( 
            /* [retval][out] */ VB_OLE_COLOR *ForeColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayForeColor( 
            /* [in] */ VB_OLE_COLOR ForeColor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayBackColor( 
            /* [retval][out] */ VB_OLE_COLOR *BackColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayBackColor( 
            /* [in] */ VB_OLE_COLOR BackColor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayMode( 
            /* [retval][out] */ MPDisplayModeConstants *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayMode( 
            /* [in] */ MPDisplayModeConstants Value) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorder3D( 
            /* [retval][out] */ VARIANT_BOOL *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorder3D( 
            /* [in] */ VARIANT_BOOL VideoBorderWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderWidth( 
            /* [retval][out] */ long *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderWidth( 
            /* [in] */ long VideoBorderWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderColor( 
            /* [retval][out] */ VB_OLE_COLOR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderColor( 
            /* [in] */ VB_OLE_COLOR VideoBorderColor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowGotoBar( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowGotoBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowStatusBar( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowStatusBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowCaptioning( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowCaptioning( 
            /* [in] */ VARIANT_BOOL pbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowAudioControls( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowAudioControls( 
            /* [in] */ VARIANT_BOOL bBool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CaptioningID( 
            /* [retval][out] */ BSTR *pstrText) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CaptioningID( 
            /* [in] */ BSTR strText) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Mute( 
            /* [retval][out] */ VARIANT_BOOL *vbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Mute( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanPreview( 
            /* [retval][out] */ VARIANT_BOOL *pCanPreview) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PreviewMode( 
            /* [retval][out] */ VARIANT_BOOL *pPreviewMode) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PreviewMode( 
            /* [in] */ VARIANT_BOOL PreviewMode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HasMultipleItems( 
            /* [retval][out] */ VARIANT_BOOL *pHasMuliItems) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ long *pLanguage) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Language( 
            /* [in] */ long Language) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AudioStream( 
            /* [retval][out] */ long *pStream) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AudioStream( 
            /* [in] */ long Stream) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIStyle( 
            /* [retval][out] */ BSTR *pbstrStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIStyle( 
            /* [in] */ BSTR bstrStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMILang( 
            /* [retval][out] */ BSTR *pbstrLang) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMILang( 
            /* [in] */ BSTR bstrLang) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIFileName( 
            /* [retval][out] */ BSTR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIFileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_StreamCount( 
            /* [retval][out] */ long *pStreamCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ BSTR *pbstrClientId) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ConnectionSpeed( 
            /* [retval][out] */ long *plConnectionSpeed) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableFullScreenControls( 
            /* [retval][out] */ VARIANT_BOOL *pbVal) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableFullScreenControls( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveMovie( 
            /* [retval][out] */ IDispatch **ppdispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NSPlay( 
            /* [retval][out] */ IDispatch **ppdispatch) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_WindowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_WindowlessVideo( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecInstalled( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecDescription( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecURL( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMoreInfoURL( 
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR *pbstrMoreInfoURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMediaInfoString( 
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR *pbstrMediaInfo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsSoundCardEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Previous( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StreamSelect( 
            /* [in] */ long StreamNum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FastForward( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FastReverse( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR *pbstrStreamName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetStreamGroup( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ long *pStreamGroup) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL *pStreamSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPlayer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPlayer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPlayer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPlayer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPlayer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPlayer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPlayer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPlayer * This,
            /* [in] */ double CurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanScan )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pCanScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeek )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeek);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeekToMarkers )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentMarker )( 
            IMediaPlayer * This,
            /* [in] */ long CurrentMarker);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            IMediaPlayer * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceProtocol )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pSourceProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBroadcast )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingProgress )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pBufferingProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrChannelName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelDescription )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrChannelDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelURL )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrChannelURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactAddress )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrContactAddress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactPhone )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrContactPhone);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactEmail )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrContactEmail);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingTime )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BufferingTime )( 
            IMediaPlayer * This,
            /* [in] */ double BufferingTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPlayer * This,
            /* [in] */ double Rate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendKeyboardEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendKeyboardEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseClickEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseClickEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseMoveEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseMoveEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            IMediaPlayer * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClickToPlay )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClickToPlay )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowScan )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowScan )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CursorType )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CursorType )( 
            IMediaPlayer * This,
            /* [in] */ long CursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CodecCount )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pCodecCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplaySize )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplaySize )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDurationValid )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OpenState )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pOpenState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendOpenStateChangeEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendOpenStateChangeEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendWarningEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendWarningEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendErrorEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendErrorEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayState )( 
            IMediaPlayer * This,
            /* [retval][out] */ MPPlayStateConstants *pPlayState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendPlayStateChangeEvents )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendPlayStateChangeEvents )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplaySize )( 
            IMediaPlayer * This,
            /* [retval][out] */ MPDisplaySizeConstants *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplaySize )( 
            IMediaPlayer * This,
            /* [in] */ MPDisplaySizeConstants DisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InvokeURLs )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InvokeURLs )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BaseURL )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFrame )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultFrame )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasError )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pHasError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrErrorDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pErrorCode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationAtStart )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationAtStart )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TransparentAtStart )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TransparentAtStart )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IMediaPlayer * This,
            /* [in] */ long Volume);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IMediaPlayer * This,
            /* [in] */ long Balance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            IMediaPlayer * This,
            /* [retval][out] */ MPReadyStateConstants *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionStart )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionStart )( 
            IMediaPlayer * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionEnd )( 
            IMediaPlayer * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionEnd )( 
            IMediaPlayer * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowDisplay )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowDisplay )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowControls )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowControls )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPositionControls )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowPositionControls )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTracker )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTracker )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePositionControls )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePositionControls )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTracker )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTracker )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayForeColor )( 
            IMediaPlayer * This,
            /* [retval][out] */ VB_OLE_COLOR *ForeColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayForeColor )( 
            IMediaPlayer * This,
            /* [in] */ VB_OLE_COLOR ForeColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayBackColor )( 
            IMediaPlayer * This,
            /* [retval][out] */ VB_OLE_COLOR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayBackColor )( 
            IMediaPlayer * This,
            /* [in] */ VB_OLE_COLOR BackColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            IMediaPlayer * This,
            /* [retval][out] */ MPDisplayModeConstants *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            IMediaPlayer * This,
            /* [in] */ MPDisplayModeConstants Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorder3D )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorder3D )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL VideoBorderWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorderWidth )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorderWidth )( 
            IMediaPlayer * This,
            /* [in] */ long VideoBorderWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorderColor )( 
            IMediaPlayer * This,
            /* [retval][out] */ VB_OLE_COLOR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorderColor )( 
            IMediaPlayer * This,
            /* [in] */ VB_OLE_COLOR VideoBorderColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGotoBar )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowGotoBar )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowStatusBar )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowStatusBar )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowCaptioning )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowCaptioning )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL pbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowAudioControls )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowAudioControls )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL bBool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CaptioningID )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pstrText);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CaptioningID )( 
            IMediaPlayer * This,
            /* [in] */ BSTR strText);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Mute )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *vbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Mute )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanPreview )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pCanPreview);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PreviewMode )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pPreviewMode);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PreviewMode )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL PreviewMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasMultipleItems )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pHasMuliItems);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Language )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pLanguage);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Language )( 
            IMediaPlayer * This,
            /* [in] */ long Language);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AudioStream )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pStream);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AudioStream )( 
            IMediaPlayer * This,
            /* [in] */ long Stream);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMIStyle )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMIStyle )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMILang )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrLang);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMILang )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrLang);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMIFileName )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMIFileName )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_StreamCount )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *pStreamCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IMediaPlayer * This,
            /* [retval][out] */ BSTR *pbstrClientId);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionSpeed )( 
            IMediaPlayer * This,
            /* [retval][out] */ long *plConnectionSpeed);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSize )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoSize )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFullScreenControls )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbVal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFullScreenControls )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveMovie )( 
            IMediaPlayer * This,
            /* [retval][out] */ IDispatch **ppdispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NSPlay )( 
            IMediaPlayer * This,
            /* [retval][out] */ IDispatch **ppdispatch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WindowlessVideo )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WindowlessVideo )( 
            IMediaPlayer * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            IMediaPlayer * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            IMediaPlayer * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecInstalled )( 
            IMediaPlayer * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecDescription )( 
            IMediaPlayer * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecURL )( 
            IMediaPlayer * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMoreInfoURL )( 
            IMediaPlayer * This,
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR *pbstrMoreInfoURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMediaInfoString )( 
            IMediaPlayer * This,
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR *pbstrMediaInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMediaPlayer * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsSoundCardEnabled )( 
            IMediaPlayer * This,
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Previous )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StreamSelect )( 
            IMediaPlayer * This,
            /* [in] */ long StreamNum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FastForward )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FastReverse )( 
            IMediaPlayer * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamName )( 
            IMediaPlayer * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR *pbstrStreamName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamGroup )( 
            IMediaPlayer * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ long *pStreamGroup);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IMediaPlayer * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL *pStreamSelected);
        
        END_INTERFACE
    } IMediaPlayerVtbl;

    interface IMediaPlayer
    {
        CONST_VTBL struct IMediaPlayerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPlayer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPlayer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPlayer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPlayer_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaPlayer_get_CurrentPosition(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition) ) 

#define IMediaPlayer_put_CurrentPosition(This,CurrentPosition)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition) ) 

#define IMediaPlayer_get_Duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,pDuration) ) 

#define IMediaPlayer_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define IMediaPlayer_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define IMediaPlayer_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define IMediaPlayer_get_CanScan(This,pCanScan)	\
    ( (This)->lpVtbl -> get_CanScan(This,pCanScan) ) 

#define IMediaPlayer_get_CanSeek(This,pCanSeek)	\
    ( (This)->lpVtbl -> get_CanSeek(This,pCanSeek) ) 

#define IMediaPlayer_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    ( (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers) ) 

#define IMediaPlayer_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define IMediaPlayer_put_CurrentMarker(This,CurrentMarker)	\
    ( (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker) ) 

#define IMediaPlayer_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define IMediaPlayer_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define IMediaPlayer_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#define IMediaPlayer_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define IMediaPlayer_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define IMediaPlayer_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define IMediaPlayer_get_SourceProtocol(This,pSourceProtocol)	\
    ( (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol) ) 

#define IMediaPlayer_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define IMediaPlayer_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define IMediaPlayer_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define IMediaPlayer_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define IMediaPlayer_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define IMediaPlayer_get_IsBroadcast(This,pIsBroadcast)	\
    ( (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast) ) 

#define IMediaPlayer_get_BufferingProgress(This,pBufferingProgress)	\
    ( (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress) ) 

#define IMediaPlayer_get_ChannelName(This,pbstrChannelName)	\
    ( (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName) ) 

#define IMediaPlayer_get_ChannelDescription(This,pbstrChannelDescription)	\
    ( (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription) ) 

#define IMediaPlayer_get_ChannelURL(This,pbstrChannelURL)	\
    ( (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL) ) 

#define IMediaPlayer_get_ContactAddress(This,pbstrContactAddress)	\
    ( (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress) ) 

#define IMediaPlayer_get_ContactPhone(This,pbstrContactPhone)	\
    ( (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone) ) 

#define IMediaPlayer_get_ContactEmail(This,pbstrContactEmail)	\
    ( (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail) ) 

#define IMediaPlayer_get_BufferingTime(This,pBufferingTime)	\
    ( (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime) ) 

#define IMediaPlayer_put_BufferingTime(This,BufferingTime)	\
    ( (This)->lpVtbl -> put_BufferingTime(This,BufferingTime) ) 

#define IMediaPlayer_get_AutoStart(This,pAutoStart)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pAutoStart) ) 

#define IMediaPlayer_put_AutoStart(This,AutoStart)	\
    ( (This)->lpVtbl -> put_AutoStart(This,AutoStart) ) 

#define IMediaPlayer_get_AutoRewind(This,pAutoRewind)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind) ) 

#define IMediaPlayer_put_AutoRewind(This,AutoRewind)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,AutoRewind) ) 

#define IMediaPlayer_get_Rate(This,pRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pRate) ) 

#define IMediaPlayer_put_Rate(This,Rate)	\
    ( (This)->lpVtbl -> put_Rate(This,Rate) ) 

#define IMediaPlayer_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    ( (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents) ) 

#define IMediaPlayer_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    ( (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents) ) 

#define IMediaPlayer_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    ( (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents) ) 

#define IMediaPlayer_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    ( (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents) ) 

#define IMediaPlayer_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    ( (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents) ) 

#define IMediaPlayer_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    ( (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents) ) 

#define IMediaPlayer_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define IMediaPlayer_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define IMediaPlayer_get_ClickToPlay(This,pClickToPlay)	\
    ( (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay) ) 

#define IMediaPlayer_put_ClickToPlay(This,ClickToPlay)	\
    ( (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay) ) 

#define IMediaPlayer_get_AllowScan(This,pAllowScan)	\
    ( (This)->lpVtbl -> get_AllowScan(This,pAllowScan) ) 

#define IMediaPlayer_put_AllowScan(This,AllowScan)	\
    ( (This)->lpVtbl -> put_AllowScan(This,AllowScan) ) 

#define IMediaPlayer_get_EnableContextMenu(This,pEnableContextMenu)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu) ) 

#define IMediaPlayer_put_EnableContextMenu(This,EnableContextMenu)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu) ) 

#define IMediaPlayer_get_CursorType(This,pCursorType)	\
    ( (This)->lpVtbl -> get_CursorType(This,pCursorType) ) 

#define IMediaPlayer_put_CursorType(This,CursorType)	\
    ( (This)->lpVtbl -> put_CursorType(This,CursorType) ) 

#define IMediaPlayer_get_CodecCount(This,pCodecCount)	\
    ( (This)->lpVtbl -> get_CodecCount(This,pCodecCount) ) 

#define IMediaPlayer_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize) ) 

#define IMediaPlayer_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize) ) 

#define IMediaPlayer_get_IsDurationValid(This,pIsDurationValid)	\
    ( (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid) ) 

#define IMediaPlayer_get_OpenState(This,pOpenState)	\
    ( (This)->lpVtbl -> get_OpenState(This,pOpenState) ) 

#define IMediaPlayer_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents) ) 

#define IMediaPlayer_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents) ) 

#define IMediaPlayer_get_SendWarningEvents(This,pSendWarningEvents)	\
    ( (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents) ) 

#define IMediaPlayer_put_SendWarningEvents(This,SendWarningEvents)	\
    ( (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents) ) 

#define IMediaPlayer_get_SendErrorEvents(This,pSendErrorEvents)	\
    ( (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents) ) 

#define IMediaPlayer_put_SendErrorEvents(This,SendErrorEvents)	\
    ( (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents) ) 

#define IMediaPlayer_get_PlayState(This,pPlayState)	\
    ( (This)->lpVtbl -> get_PlayState(This,pPlayState) ) 

#define IMediaPlayer_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents) ) 

#define IMediaPlayer_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents) ) 

#define IMediaPlayer_get_DisplaySize(This,pDisplaySize)	\
    ( (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize) ) 

#define IMediaPlayer_put_DisplaySize(This,DisplaySize)	\
    ( (This)->lpVtbl -> put_DisplaySize(This,DisplaySize) ) 

#define IMediaPlayer_get_InvokeURLs(This,pInvokeURLs)	\
    ( (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs) ) 

#define IMediaPlayer_put_InvokeURLs(This,InvokeURLs)	\
    ( (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs) ) 

#define IMediaPlayer_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define IMediaPlayer_put_BaseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL) ) 

#define IMediaPlayer_get_DefaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame) ) 

#define IMediaPlayer_put_DefaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame) ) 

#define IMediaPlayer_get_HasError(This,pHasError)	\
    ( (This)->lpVtbl -> get_HasError(This,pHasError) ) 

#define IMediaPlayer_get_ErrorDescription(This,pbstrErrorDescription)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription) ) 

#define IMediaPlayer_get_ErrorCode(This,pErrorCode)	\
    ( (This)->lpVtbl -> get_ErrorCode(This,pErrorCode) ) 

#define IMediaPlayer_get_AnimationAtStart(This,pAnimationAtStart)	\
    ( (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart) ) 

#define IMediaPlayer_put_AnimationAtStart(This,AnimationAtStart)	\
    ( (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart) ) 

#define IMediaPlayer_get_TransparentAtStart(This,pTransparentAtStart)	\
    ( (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart) ) 

#define IMediaPlayer_put_TransparentAtStart(This,TransparentAtStart)	\
    ( (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart) ) 

#define IMediaPlayer_get_Volume(This,pVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,pVolume) ) 

#define IMediaPlayer_put_Volume(This,Volume)	\
    ( (This)->lpVtbl -> put_Volume(This,Volume) ) 

#define IMediaPlayer_get_Balance(This,pBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,pBalance) ) 

#define IMediaPlayer_put_Balance(This,Balance)	\
    ( (This)->lpVtbl -> put_Balance(This,Balance) ) 

#define IMediaPlayer_get_ReadyState(This,pValue)	\
    ( (This)->lpVtbl -> get_ReadyState(This,pValue) ) 

#define IMediaPlayer_get_SelectionStart(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionStart(This,pValue) ) 

#define IMediaPlayer_put_SelectionStart(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionStart(This,Value) ) 

#define IMediaPlayer_get_SelectionEnd(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionEnd(This,pValue) ) 

#define IMediaPlayer_put_SelectionEnd(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionEnd(This,Value) ) 

#define IMediaPlayer_get_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_ShowDisplay(This,Show) ) 

#define IMediaPlayer_put_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_ShowDisplay(This,Show) ) 

#define IMediaPlayer_get_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowControls(This,Show) ) 

#define IMediaPlayer_put_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowControls(This,Show) ) 

#define IMediaPlayer_get_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowPositionControls(This,Show) ) 

#define IMediaPlayer_put_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowPositionControls(This,Show) ) 

#define IMediaPlayer_get_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> get_ShowTracker(This,Show) ) 

#define IMediaPlayer_put_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> put_ShowTracker(This,Show) ) 

#define IMediaPlayer_get_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnablePositionControls(This,Enable) ) 

#define IMediaPlayer_put_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnablePositionControls(This,Enable) ) 

#define IMediaPlayer_get_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableTracker(This,Enable) ) 

#define IMediaPlayer_put_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableTracker(This,Enable) ) 

#define IMediaPlayer_get_Enabled(This,pEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pEnabled) ) 

#define IMediaPlayer_put_Enabled(This,Enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,Enabled) ) 

#define IMediaPlayer_get_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor) ) 

#define IMediaPlayer_put_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor) ) 

#define IMediaPlayer_get_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> get_DisplayBackColor(This,BackColor) ) 

#define IMediaPlayer_put_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> put_DisplayBackColor(This,BackColor) ) 

#define IMediaPlayer_get_DisplayMode(This,pValue)	\
    ( (This)->lpVtbl -> get_DisplayMode(This,pValue) ) 

#define IMediaPlayer_put_DisplayMode(This,Value)	\
    ( (This)->lpVtbl -> put_DisplayMode(This,Value) ) 

#define IMediaPlayer_get_VideoBorder3D(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorder3D(This,pVideoBorderWidth) ) 

#define IMediaPlayer_put_VideoBorder3D(This,VideoBorderWidth)	\
    ( (This)->lpVtbl -> put_VideoBorder3D(This,VideoBorderWidth) ) 

#define IMediaPlayer_get_VideoBorderWidth(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorderWidth(This,pVideoBorderWidth) ) 

#define IMediaPlayer_put_VideoBorderWidth(This,VideoBorderWidth)	\
    ( (This)->lpVtbl -> put_VideoBorderWidth(This,VideoBorderWidth) ) 

#define IMediaPlayer_get_VideoBorderColor(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorderColor(This,pVideoBorderWidth) ) 

#define IMediaPlayer_put_VideoBorderColor(This,VideoBorderColor)	\
    ( (This)->lpVtbl -> put_VideoBorderColor(This,VideoBorderColor) ) 

#define IMediaPlayer_get_ShowGotoBar(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowGotoBar(This,pbool) ) 

#define IMediaPlayer_put_ShowGotoBar(This,vbool)	\
    ( (This)->lpVtbl -> put_ShowGotoBar(This,vbool) ) 

#define IMediaPlayer_get_ShowStatusBar(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowStatusBar(This,pbool) ) 

#define IMediaPlayer_put_ShowStatusBar(This,vbool)	\
    ( (This)->lpVtbl -> put_ShowStatusBar(This,vbool) ) 

#define IMediaPlayer_get_ShowCaptioning(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowCaptioning(This,pbool) ) 

#define IMediaPlayer_put_ShowCaptioning(This,pbool)	\
    ( (This)->lpVtbl -> put_ShowCaptioning(This,pbool) ) 

#define IMediaPlayer_get_ShowAudioControls(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowAudioControls(This,pbool) ) 

#define IMediaPlayer_put_ShowAudioControls(This,bBool)	\
    ( (This)->lpVtbl -> put_ShowAudioControls(This,bBool) ) 

#define IMediaPlayer_get_CaptioningID(This,pstrText)	\
    ( (This)->lpVtbl -> get_CaptioningID(This,pstrText) ) 

#define IMediaPlayer_put_CaptioningID(This,strText)	\
    ( (This)->lpVtbl -> put_CaptioningID(This,strText) ) 

#define IMediaPlayer_get_Mute(This,vbool)	\
    ( (This)->lpVtbl -> get_Mute(This,vbool) ) 

#define IMediaPlayer_put_Mute(This,vbool)	\
    ( (This)->lpVtbl -> put_Mute(This,vbool) ) 

#define IMediaPlayer_get_CanPreview(This,pCanPreview)	\
    ( (This)->lpVtbl -> get_CanPreview(This,pCanPreview) ) 

#define IMediaPlayer_get_PreviewMode(This,pPreviewMode)	\
    ( (This)->lpVtbl -> get_PreviewMode(This,pPreviewMode) ) 

#define IMediaPlayer_put_PreviewMode(This,PreviewMode)	\
    ( (This)->lpVtbl -> put_PreviewMode(This,PreviewMode) ) 

#define IMediaPlayer_get_HasMultipleItems(This,pHasMuliItems)	\
    ( (This)->lpVtbl -> get_HasMultipleItems(This,pHasMuliItems) ) 

#define IMediaPlayer_get_Language(This,pLanguage)	\
    ( (This)->lpVtbl -> get_Language(This,pLanguage) ) 

#define IMediaPlayer_put_Language(This,Language)	\
    ( (This)->lpVtbl -> put_Language(This,Language) ) 

#define IMediaPlayer_get_AudioStream(This,pStream)	\
    ( (This)->lpVtbl -> get_AudioStream(This,pStream) ) 

#define IMediaPlayer_put_AudioStream(This,Stream)	\
    ( (This)->lpVtbl -> put_AudioStream(This,Stream) ) 

#define IMediaPlayer_get_SAMIStyle(This,pbstrStyle)	\
    ( (This)->lpVtbl -> get_SAMIStyle(This,pbstrStyle) ) 

#define IMediaPlayer_put_SAMIStyle(This,bstrStyle)	\
    ( (This)->lpVtbl -> put_SAMIStyle(This,bstrStyle) ) 

#define IMediaPlayer_get_SAMILang(This,pbstrLang)	\
    ( (This)->lpVtbl -> get_SAMILang(This,pbstrLang) ) 

#define IMediaPlayer_put_SAMILang(This,bstrLang)	\
    ( (This)->lpVtbl -> put_SAMILang(This,bstrLang) ) 

#define IMediaPlayer_get_SAMIFileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_SAMIFileName(This,pbstrFileName) ) 

#define IMediaPlayer_put_SAMIFileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_SAMIFileName(This,bstrFileName) ) 

#define IMediaPlayer_get_StreamCount(This,pStreamCount)	\
    ( (This)->lpVtbl -> get_StreamCount(This,pStreamCount) ) 

#define IMediaPlayer_get_ClientId(This,pbstrClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,pbstrClientId) ) 

#define IMediaPlayer_get_ConnectionSpeed(This,plConnectionSpeed)	\
    ( (This)->lpVtbl -> get_ConnectionSpeed(This,plConnectionSpeed) ) 

#define IMediaPlayer_get_AutoSize(This,pbool)	\
    ( (This)->lpVtbl -> get_AutoSize(This,pbool) ) 

#define IMediaPlayer_put_AutoSize(This,vbool)	\
    ( (This)->lpVtbl -> put_AutoSize(This,vbool) ) 

#define IMediaPlayer_get_EnableFullScreenControls(This,pbVal)	\
    ( (This)->lpVtbl -> get_EnableFullScreenControls(This,pbVal) ) 

#define IMediaPlayer_put_EnableFullScreenControls(This,bVal)	\
    ( (This)->lpVtbl -> put_EnableFullScreenControls(This,bVal) ) 

#define IMediaPlayer_get_ActiveMovie(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_ActiveMovie(This,ppdispatch) ) 

#define IMediaPlayer_get_NSPlay(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_NSPlay(This,ppdispatch) ) 

#define IMediaPlayer_get_WindowlessVideo(This,pbool)	\
    ( (This)->lpVtbl -> get_WindowlessVideo(This,pbool) ) 

#define IMediaPlayer_put_WindowlessVideo(This,vbool)	\
    ( (This)->lpVtbl -> put_WindowlessVideo(This,vbool) ) 

#define IMediaPlayer_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define IMediaPlayer_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaPlayer_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaPlayer_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define IMediaPlayer_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#define IMediaPlayer_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define IMediaPlayer_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    ( (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled) ) 

#define IMediaPlayer_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    ( (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription) ) 

#define IMediaPlayer_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    ( (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL) ) 

#define IMediaPlayer_GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)	\
    ( (This)->lpVtbl -> GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL) ) 

#define IMediaPlayer_GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)	\
    ( (This)->lpVtbl -> GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo) ) 

#define IMediaPlayer_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IMediaPlayer_Open(This,bstrFileName)	\
    ( (This)->lpVtbl -> Open(This,bstrFileName) ) 

#define IMediaPlayer_IsSoundCardEnabled(This,pbSoundCard)	\
    ( (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard) ) 

#define IMediaPlayer_Next(This)	\
    ( (This)->lpVtbl -> Next(This) ) 

#define IMediaPlayer_Previous(This)	\
    ( (This)->lpVtbl -> Previous(This) ) 

#define IMediaPlayer_StreamSelect(This,StreamNum)	\
    ( (This)->lpVtbl -> StreamSelect(This,StreamNum) ) 

#define IMediaPlayer_FastForward(This)	\
    ( (This)->lpVtbl -> FastForward(This) ) 

#define IMediaPlayer_FastReverse(This)	\
    ( (This)->lpVtbl -> FastReverse(This) ) 

#define IMediaPlayer_GetStreamName(This,StreamNum,pbstrStreamName)	\
    ( (This)->lpVtbl -> GetStreamName(This,StreamNum,pbstrStreamName) ) 

#define IMediaPlayer_GetStreamGroup(This,StreamNum,pStreamGroup)	\
    ( (This)->lpVtbl -> GetStreamGroup(This,StreamNum,pStreamGroup) ) 

#define IMediaPlayer_GetStreamSelected(This,StreamNum,pStreamSelected)	\
    ( (This)->lpVtbl -> GetStreamSelected(This,StreamNum,pStreamSelected) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowStatusBar_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbool);


void __RPC_STUB IMediaPlayer_get_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowStatusBar_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowCaptioning_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbool);


void __RPC_STUB IMediaPlayer_get_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowCaptioning_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL pbool);


void __RPC_STUB IMediaPlayer_put_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowAudioControls_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbool);


void __RPC_STUB IMediaPlayer_get_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowAudioControls_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL bBool);


void __RPC_STUB IMediaPlayer_put_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CaptioningID_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ BSTR *pstrText);


void __RPC_STUB IMediaPlayer_get_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CaptioningID_Proxy( 
    IMediaPlayer * This,
    /* [in] */ BSTR strText);


void __RPC_STUB IMediaPlayer_put_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Mute_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *vbool);


void __RPC_STUB IMediaPlayer_get_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Mute_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanPreview_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pCanPreview);


void __RPC_STUB IMediaPlayer_get_CanPreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PreviewMode_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pPreviewMode);


void __RPC_STUB IMediaPlayer_get_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_PreviewMode_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL PreviewMode);


void __RPC_STUB IMediaPlayer_put_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_HasMultipleItems_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pHasMuliItems);


void __RPC_STUB IMediaPlayer_get_HasMultipleItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Language_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ long *pLanguage);


void __RPC_STUB IMediaPlayer_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Language_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long Language);


void __RPC_STUB IMediaPlayer_put_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AudioStream_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ long *pStream);


void __RPC_STUB IMediaPlayer_get_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AudioStream_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long Stream);


void __RPC_STUB IMediaPlayer_put_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIStyle_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ BSTR *pbstrStyle);


void __RPC_STUB IMediaPlayer_get_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIStyle_Proxy( 
    IMediaPlayer * This,
    /* [in] */ BSTR bstrStyle);


void __RPC_STUB IMediaPlayer_put_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMILang_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ BSTR *pbstrLang);


void __RPC_STUB IMediaPlayer_get_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMILang_Proxy( 
    IMediaPlayer * This,
    /* [in] */ BSTR bstrLang);


void __RPC_STUB IMediaPlayer_put_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIFileName_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ BSTR *pbstrFileName);


void __RPC_STUB IMediaPlayer_get_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIFileName_Proxy( 
    IMediaPlayer * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_put_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_StreamCount_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ long *pStreamCount);


void __RPC_STUB IMediaPlayer_get_StreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ClientId_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ BSTR *pbstrClientId);


void __RPC_STUB IMediaPlayer_get_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ConnectionSpeed_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ long *plConnectionSpeed);


void __RPC_STUB IMediaPlayer_get_ConnectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoSize_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbool);


void __RPC_STUB IMediaPlayer_get_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoSize_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableFullScreenControls_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbVal);


void __RPC_STUB IMediaPlayer_get_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableFullScreenControls_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IMediaPlayer_put_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ActiveMovie_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ IDispatch **ppdispatch);


void __RPC_STUB IMediaPlayer_get_ActiveMovie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_NSPlay_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ IDispatch **ppdispatch);


void __RPC_STUB IMediaPlayer_get_NSPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_WindowlessVideo_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbool);


void __RPC_STUB IMediaPlayer_get_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_WindowlessVideo_Proxy( 
    IMediaPlayer * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Play_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Stop_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Pause_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerTime_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ double *pMarkerTime);


void __RPC_STUB IMediaPlayer_GetMarkerTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerName_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ BSTR *pbstrMarkerName);


void __RPC_STUB IMediaPlayer_GetMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_AboutBox_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecInstalled_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);


void __RPC_STUB IMediaPlayer_GetCodecInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecDescription_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR *pbstrCodecDescription);


void __RPC_STUB IMediaPlayer_GetCodecDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecURL_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR *pbstrCodecURL);


void __RPC_STUB IMediaPlayer_GetCodecURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMoreInfoURL_Proxy( 
    IMediaPlayer * This,
    /* [in] */ MPMoreInfoType MoreInfoType,
    /* [retval][out] */ BSTR *pbstrMoreInfoURL);


void __RPC_STUB IMediaPlayer_GetMoreInfoURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMediaInfoString_Proxy( 
    IMediaPlayer * This,
    /* [in] */ MPMediaInfoType MediaInfoType,
    /* [retval][out] */ BSTR *pbstrMediaInfo);


void __RPC_STUB IMediaPlayer_GetMediaInfoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Cancel_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Open_Proxy( 
    IMediaPlayer * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_IsSoundCardEnabled_Proxy( 
    IMediaPlayer * This,
    /* [retval][out] */ VARIANT_BOOL *pbSoundCard);


void __RPC_STUB IMediaPlayer_IsSoundCardEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Next_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Previous_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_StreamSelect_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long StreamNum);


void __RPC_STUB IMediaPlayer_StreamSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastForward_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_FastForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastReverse_Proxy( 
    IMediaPlayer * This);


void __RPC_STUB IMediaPlayer_FastReverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamName_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ BSTR *pbstrStreamName);


void __RPC_STUB IMediaPlayer_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamGroup_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ long *pStreamGroup);


void __RPC_STUB IMediaPlayer_GetStreamGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamSelected_Proxy( 
    IMediaPlayer * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ VARIANT_BOOL *pStreamSelected);


void __RPC_STUB IMediaPlayer_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPlayer_INTERFACE_DEFINED__ */


#ifndef __IMediaPlayer2_INTERFACE_DEFINED__
#define __IMediaPlayer2_INTERFACE_DEFINED__

/* interface IMediaPlayer2 */
/* [unique][dual][uuid][object] */ 


EXTERN_C const IID IID_IMediaPlayer2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20D4F5E0-5475-11d2-9774-0000F80855E6")
    IMediaPlayer2 : public IMediaPlayer
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DVD( 
            /* [retval][out] */ IMediaPlayerDvd **ppdispatch) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMediaParameter( 
            /* [in] */ long EntryNum,
            /* [in] */ BSTR bstrParameterName,
            /* [retval][out] */ BSTR *pbstrParameterValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMediaParameterName( 
            /* [in] */ long EntryNum,
            /* [in] */ long Index,
            /* [retval][out] */ BSTR *pbstrParameterName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EntryCount( 
            /* [retval][out] */ long *pNumberEntries) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCurrentEntry( 
            /* [retval][out] */ long *pEntryNumber) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetCurrentEntry( 
            /* [in] */ long EntryNumber) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ShowDialog( 
            /* [in] */ MPShowDialogConstants mpDialogIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPlayer2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaPlayer2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaPlayer2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaPlayer2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMediaPlayer2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMediaPlayer2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMediaPlayer2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMediaPlayer2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            IMediaPlayer2 * This,
            /* [in] */ double CurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanScan )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeek )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeek);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeekToMarkers )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentMarker )( 
            IMediaPlayer2 * This,
            /* [in] */ long CurrentMarker);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceProtocol )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pSourceProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBroadcast )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingProgress )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pBufferingProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrChannelName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelDescription )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrChannelDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelURL )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrChannelURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactAddress )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrContactAddress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactPhone )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrContactPhone);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactEmail )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrContactEmail);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingTime )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BufferingTime )( 
            IMediaPlayer2 * This,
            /* [in] */ double BufferingTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IMediaPlayer2 * This,
            /* [in] */ double Rate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendKeyboardEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendKeyboardEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseClickEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseClickEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseMoveEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseMoveEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            IMediaPlayer2 * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClickToPlay )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClickToPlay )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowScan )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowScan )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CursorType )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CursorType )( 
            IMediaPlayer2 * This,
            /* [in] */ long CursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CodecCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pCodecCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplaySize )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplaySize )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDurationValid )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OpenState )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pOpenState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendOpenStateChangeEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendOpenStateChangeEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendWarningEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendWarningEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendErrorEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendErrorEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayState )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ MPPlayStateConstants *pPlayState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendPlayStateChangeEvents )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendPlayStateChangeEvents )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplaySize )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ MPDisplaySizeConstants *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplaySize )( 
            IMediaPlayer2 * This,
            /* [in] */ MPDisplaySizeConstants DisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InvokeURLs )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InvokeURLs )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BaseURL )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFrame )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultFrame )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasError )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pHasError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrErrorDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pErrorCode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationAtStart )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationAtStart )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TransparentAtStart )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TransparentAtStart )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            IMediaPlayer2 * This,
            /* [in] */ long Volume);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            IMediaPlayer2 * This,
            /* [in] */ long Balance);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadyState )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ MPReadyStateConstants *pValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionStart )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionStart )( 
            IMediaPlayer2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelectionEnd )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ double *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelectionEnd )( 
            IMediaPlayer2 * This,
            /* [in] */ double Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowDisplay )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowDisplay )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowControls )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowControls )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPositionControls )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowPositionControls )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTracker )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTracker )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnablePositionControls )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnablePositionControls )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTracker )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTracker )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayForeColor )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VB_OLE_COLOR *ForeColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayForeColor )( 
            IMediaPlayer2 * This,
            /* [in] */ VB_OLE_COLOR ForeColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayBackColor )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VB_OLE_COLOR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayBackColor )( 
            IMediaPlayer2 * This,
            /* [in] */ VB_OLE_COLOR BackColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayMode )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ MPDisplayModeConstants *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayMode )( 
            IMediaPlayer2 * This,
            /* [in] */ MPDisplayModeConstants Value);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorder3D )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorder3D )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL VideoBorderWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorderWidth )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorderWidth )( 
            IMediaPlayer2 * This,
            /* [in] */ long VideoBorderWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_VideoBorderColor )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VB_OLE_COLOR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_VideoBorderColor )( 
            IMediaPlayer2 * This,
            /* [in] */ VB_OLE_COLOR VideoBorderColor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowGotoBar )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowGotoBar )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowStatusBar )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowStatusBar )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowCaptioning )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowCaptioning )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL pbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowAudioControls )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowAudioControls )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL bBool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CaptioningID )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pstrText);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CaptioningID )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR strText);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Mute )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *vbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Mute )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanPreview )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanPreview);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PreviewMode )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pPreviewMode);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PreviewMode )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL PreviewMode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasMultipleItems )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pHasMuliItems);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Language )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pLanguage);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Language )( 
            IMediaPlayer2 * This,
            /* [in] */ long Language);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AudioStream )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pStream);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AudioStream )( 
            IMediaPlayer2 * This,
            /* [in] */ long Stream);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMIStyle )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMIStyle )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMILang )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrLang);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMILang )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrLang);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SAMIFileName )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SAMIFileName )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_StreamCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pStreamCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClientId )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ BSTR *pbstrClientId);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionSpeed )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *plConnectionSpeed);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoSize )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoSize )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableFullScreenControls )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbVal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableFullScreenControls )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveMovie )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ IDispatch **ppdispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NSPlay )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ IDispatch **ppdispatch);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_WindowlessVideo )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_WindowlessVideo )( 
            IMediaPlayer2 * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            IMediaPlayer2 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            IMediaPlayer2 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecInstalled )( 
            IMediaPlayer2 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecDescription )( 
            IMediaPlayer2 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecURL )( 
            IMediaPlayer2 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMoreInfoURL )( 
            IMediaPlayer2 * This,
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR *pbstrMoreInfoURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMediaInfoString )( 
            IMediaPlayer2 * This,
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR *pbstrMediaInfo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IMediaPlayer2 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsSoundCardEnabled )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ VARIANT_BOOL *pbSoundCard);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Previous )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *StreamSelect )( 
            IMediaPlayer2 * This,
            /* [in] */ long StreamNum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FastForward )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *FastReverse )( 
            IMediaPlayer2 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamName )( 
            IMediaPlayer2 * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR *pbstrStreamName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamGroup )( 
            IMediaPlayer2 * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ long *pStreamGroup);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetStreamSelected )( 
            IMediaPlayer2 * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL *pStreamSelected);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DVD )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ IMediaPlayerDvd **ppdispatch);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMediaParameter )( 
            IMediaPlayer2 * This,
            /* [in] */ long EntryNum,
            /* [in] */ BSTR bstrParameterName,
            /* [retval][out] */ BSTR *pbstrParameterValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMediaParameterName )( 
            IMediaPlayer2 * This,
            /* [in] */ long EntryNum,
            /* [in] */ long Index,
            /* [retval][out] */ BSTR *pbstrParameterName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EntryCount )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pNumberEntries);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentEntry )( 
            IMediaPlayer2 * This,
            /* [retval][out] */ long *pEntryNumber);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *SetCurrentEntry )( 
            IMediaPlayer2 * This,
            /* [in] */ long EntryNumber);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ShowDialog )( 
            IMediaPlayer2 * This,
            /* [in] */ MPShowDialogConstants mpDialogIndex);
        
        END_INTERFACE
    } IMediaPlayer2Vtbl;

    interface IMediaPlayer2
    {
        CONST_VTBL struct IMediaPlayer2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPlayer2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaPlayer2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaPlayer2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaPlayer2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMediaPlayer2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMediaPlayer2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMediaPlayer2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMediaPlayer2_get_CurrentPosition(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition) ) 

#define IMediaPlayer2_put_CurrentPosition(This,CurrentPosition)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition) ) 

#define IMediaPlayer2_get_Duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,pDuration) ) 

#define IMediaPlayer2_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define IMediaPlayer2_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define IMediaPlayer2_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define IMediaPlayer2_get_CanScan(This,pCanScan)	\
    ( (This)->lpVtbl -> get_CanScan(This,pCanScan) ) 

#define IMediaPlayer2_get_CanSeek(This,pCanSeek)	\
    ( (This)->lpVtbl -> get_CanSeek(This,pCanSeek) ) 

#define IMediaPlayer2_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    ( (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers) ) 

#define IMediaPlayer2_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define IMediaPlayer2_put_CurrentMarker(This,CurrentMarker)	\
    ( (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker) ) 

#define IMediaPlayer2_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define IMediaPlayer2_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define IMediaPlayer2_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#define IMediaPlayer2_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define IMediaPlayer2_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define IMediaPlayer2_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define IMediaPlayer2_get_SourceProtocol(This,pSourceProtocol)	\
    ( (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol) ) 

#define IMediaPlayer2_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define IMediaPlayer2_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define IMediaPlayer2_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define IMediaPlayer2_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define IMediaPlayer2_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define IMediaPlayer2_get_IsBroadcast(This,pIsBroadcast)	\
    ( (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast) ) 

#define IMediaPlayer2_get_BufferingProgress(This,pBufferingProgress)	\
    ( (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress) ) 

#define IMediaPlayer2_get_ChannelName(This,pbstrChannelName)	\
    ( (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName) ) 

#define IMediaPlayer2_get_ChannelDescription(This,pbstrChannelDescription)	\
    ( (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription) ) 

#define IMediaPlayer2_get_ChannelURL(This,pbstrChannelURL)	\
    ( (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL) ) 

#define IMediaPlayer2_get_ContactAddress(This,pbstrContactAddress)	\
    ( (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress) ) 

#define IMediaPlayer2_get_ContactPhone(This,pbstrContactPhone)	\
    ( (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone) ) 

#define IMediaPlayer2_get_ContactEmail(This,pbstrContactEmail)	\
    ( (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail) ) 

#define IMediaPlayer2_get_BufferingTime(This,pBufferingTime)	\
    ( (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime) ) 

#define IMediaPlayer2_put_BufferingTime(This,BufferingTime)	\
    ( (This)->lpVtbl -> put_BufferingTime(This,BufferingTime) ) 

#define IMediaPlayer2_get_AutoStart(This,pAutoStart)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pAutoStart) ) 

#define IMediaPlayer2_put_AutoStart(This,AutoStart)	\
    ( (This)->lpVtbl -> put_AutoStart(This,AutoStart) ) 

#define IMediaPlayer2_get_AutoRewind(This,pAutoRewind)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind) ) 

#define IMediaPlayer2_put_AutoRewind(This,AutoRewind)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,AutoRewind) ) 

#define IMediaPlayer2_get_Rate(This,pRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pRate) ) 

#define IMediaPlayer2_put_Rate(This,Rate)	\
    ( (This)->lpVtbl -> put_Rate(This,Rate) ) 

#define IMediaPlayer2_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    ( (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents) ) 

#define IMediaPlayer2_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    ( (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents) ) 

#define IMediaPlayer2_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    ( (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents) ) 

#define IMediaPlayer2_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    ( (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents) ) 

#define IMediaPlayer2_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    ( (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents) ) 

#define IMediaPlayer2_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    ( (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents) ) 

#define IMediaPlayer2_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define IMediaPlayer2_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define IMediaPlayer2_get_ClickToPlay(This,pClickToPlay)	\
    ( (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay) ) 

#define IMediaPlayer2_put_ClickToPlay(This,ClickToPlay)	\
    ( (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay) ) 

#define IMediaPlayer2_get_AllowScan(This,pAllowScan)	\
    ( (This)->lpVtbl -> get_AllowScan(This,pAllowScan) ) 

#define IMediaPlayer2_put_AllowScan(This,AllowScan)	\
    ( (This)->lpVtbl -> put_AllowScan(This,AllowScan) ) 

#define IMediaPlayer2_get_EnableContextMenu(This,pEnableContextMenu)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu) ) 

#define IMediaPlayer2_put_EnableContextMenu(This,EnableContextMenu)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu) ) 

#define IMediaPlayer2_get_CursorType(This,pCursorType)	\
    ( (This)->lpVtbl -> get_CursorType(This,pCursorType) ) 

#define IMediaPlayer2_put_CursorType(This,CursorType)	\
    ( (This)->lpVtbl -> put_CursorType(This,CursorType) ) 

#define IMediaPlayer2_get_CodecCount(This,pCodecCount)	\
    ( (This)->lpVtbl -> get_CodecCount(This,pCodecCount) ) 

#define IMediaPlayer2_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize) ) 

#define IMediaPlayer2_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize) ) 

#define IMediaPlayer2_get_IsDurationValid(This,pIsDurationValid)	\
    ( (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid) ) 

#define IMediaPlayer2_get_OpenState(This,pOpenState)	\
    ( (This)->lpVtbl -> get_OpenState(This,pOpenState) ) 

#define IMediaPlayer2_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents) ) 

#define IMediaPlayer2_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents) ) 

#define IMediaPlayer2_get_SendWarningEvents(This,pSendWarningEvents)	\
    ( (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents) ) 

#define IMediaPlayer2_put_SendWarningEvents(This,SendWarningEvents)	\
    ( (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents) ) 

#define IMediaPlayer2_get_SendErrorEvents(This,pSendErrorEvents)	\
    ( (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents) ) 

#define IMediaPlayer2_put_SendErrorEvents(This,SendErrorEvents)	\
    ( (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents) ) 

#define IMediaPlayer2_get_PlayState(This,pPlayState)	\
    ( (This)->lpVtbl -> get_PlayState(This,pPlayState) ) 

#define IMediaPlayer2_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents) ) 

#define IMediaPlayer2_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents) ) 

#define IMediaPlayer2_get_DisplaySize(This,pDisplaySize)	\
    ( (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize) ) 

#define IMediaPlayer2_put_DisplaySize(This,DisplaySize)	\
    ( (This)->lpVtbl -> put_DisplaySize(This,DisplaySize) ) 

#define IMediaPlayer2_get_InvokeURLs(This,pInvokeURLs)	\
    ( (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs) ) 

#define IMediaPlayer2_put_InvokeURLs(This,InvokeURLs)	\
    ( (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs) ) 

#define IMediaPlayer2_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define IMediaPlayer2_put_BaseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL) ) 

#define IMediaPlayer2_get_DefaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame) ) 

#define IMediaPlayer2_put_DefaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame) ) 

#define IMediaPlayer2_get_HasError(This,pHasError)	\
    ( (This)->lpVtbl -> get_HasError(This,pHasError) ) 

#define IMediaPlayer2_get_ErrorDescription(This,pbstrErrorDescription)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription) ) 

#define IMediaPlayer2_get_ErrorCode(This,pErrorCode)	\
    ( (This)->lpVtbl -> get_ErrorCode(This,pErrorCode) ) 

#define IMediaPlayer2_get_AnimationAtStart(This,pAnimationAtStart)	\
    ( (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart) ) 

#define IMediaPlayer2_put_AnimationAtStart(This,AnimationAtStart)	\
    ( (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart) ) 

#define IMediaPlayer2_get_TransparentAtStart(This,pTransparentAtStart)	\
    ( (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart) ) 

#define IMediaPlayer2_put_TransparentAtStart(This,TransparentAtStart)	\
    ( (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart) ) 

#define IMediaPlayer2_get_Volume(This,pVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,pVolume) ) 

#define IMediaPlayer2_put_Volume(This,Volume)	\
    ( (This)->lpVtbl -> put_Volume(This,Volume) ) 

#define IMediaPlayer2_get_Balance(This,pBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,pBalance) ) 

#define IMediaPlayer2_put_Balance(This,Balance)	\
    ( (This)->lpVtbl -> put_Balance(This,Balance) ) 

#define IMediaPlayer2_get_ReadyState(This,pValue)	\
    ( (This)->lpVtbl -> get_ReadyState(This,pValue) ) 

#define IMediaPlayer2_get_SelectionStart(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionStart(This,pValue) ) 

#define IMediaPlayer2_put_SelectionStart(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionStart(This,Value) ) 

#define IMediaPlayer2_get_SelectionEnd(This,pValue)	\
    ( (This)->lpVtbl -> get_SelectionEnd(This,pValue) ) 

#define IMediaPlayer2_put_SelectionEnd(This,Value)	\
    ( (This)->lpVtbl -> put_SelectionEnd(This,Value) ) 

#define IMediaPlayer2_get_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> get_ShowDisplay(This,Show) ) 

#define IMediaPlayer2_put_ShowDisplay(This,Show)	\
    ( (This)->lpVtbl -> put_ShowDisplay(This,Show) ) 

#define IMediaPlayer2_get_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowControls(This,Show) ) 

#define IMediaPlayer2_put_ShowControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowControls(This,Show) ) 

#define IMediaPlayer2_get_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> get_ShowPositionControls(This,Show) ) 

#define IMediaPlayer2_put_ShowPositionControls(This,Show)	\
    ( (This)->lpVtbl -> put_ShowPositionControls(This,Show) ) 

#define IMediaPlayer2_get_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> get_ShowTracker(This,Show) ) 

#define IMediaPlayer2_put_ShowTracker(This,Show)	\
    ( (This)->lpVtbl -> put_ShowTracker(This,Show) ) 

#define IMediaPlayer2_get_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> get_EnablePositionControls(This,Enable) ) 

#define IMediaPlayer2_put_EnablePositionControls(This,Enable)	\
    ( (This)->lpVtbl -> put_EnablePositionControls(This,Enable) ) 

#define IMediaPlayer2_get_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> get_EnableTracker(This,Enable) ) 

#define IMediaPlayer2_put_EnableTracker(This,Enable)	\
    ( (This)->lpVtbl -> put_EnableTracker(This,Enable) ) 

#define IMediaPlayer2_get_Enabled(This,pEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pEnabled) ) 

#define IMediaPlayer2_put_Enabled(This,Enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,Enabled) ) 

#define IMediaPlayer2_get_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor) ) 

#define IMediaPlayer2_put_DisplayForeColor(This,ForeColor)	\
    ( (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor) ) 

#define IMediaPlayer2_get_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> get_DisplayBackColor(This,BackColor) ) 

#define IMediaPlayer2_put_DisplayBackColor(This,BackColor)	\
    ( (This)->lpVtbl -> put_DisplayBackColor(This,BackColor) ) 

#define IMediaPlayer2_get_DisplayMode(This,pValue)	\
    ( (This)->lpVtbl -> get_DisplayMode(This,pValue) ) 

#define IMediaPlayer2_put_DisplayMode(This,Value)	\
    ( (This)->lpVtbl -> put_DisplayMode(This,Value) ) 

#define IMediaPlayer2_get_VideoBorder3D(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorder3D(This,pVideoBorderWidth) ) 

#define IMediaPlayer2_put_VideoBorder3D(This,VideoBorderWidth)	\
    ( (This)->lpVtbl -> put_VideoBorder3D(This,VideoBorderWidth) ) 

#define IMediaPlayer2_get_VideoBorderWidth(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorderWidth(This,pVideoBorderWidth) ) 

#define IMediaPlayer2_put_VideoBorderWidth(This,VideoBorderWidth)	\
    ( (This)->lpVtbl -> put_VideoBorderWidth(This,VideoBorderWidth) ) 

#define IMediaPlayer2_get_VideoBorderColor(This,pVideoBorderWidth)	\
    ( (This)->lpVtbl -> get_VideoBorderColor(This,pVideoBorderWidth) ) 

#define IMediaPlayer2_put_VideoBorderColor(This,VideoBorderColor)	\
    ( (This)->lpVtbl -> put_VideoBorderColor(This,VideoBorderColor) ) 

#define IMediaPlayer2_get_ShowGotoBar(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowGotoBar(This,pbool) ) 

#define IMediaPlayer2_put_ShowGotoBar(This,vbool)	\
    ( (This)->lpVtbl -> put_ShowGotoBar(This,vbool) ) 

#define IMediaPlayer2_get_ShowStatusBar(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowStatusBar(This,pbool) ) 

#define IMediaPlayer2_put_ShowStatusBar(This,vbool)	\
    ( (This)->lpVtbl -> put_ShowStatusBar(This,vbool) ) 

#define IMediaPlayer2_get_ShowCaptioning(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowCaptioning(This,pbool) ) 

#define IMediaPlayer2_put_ShowCaptioning(This,pbool)	\
    ( (This)->lpVtbl -> put_ShowCaptioning(This,pbool) ) 

#define IMediaPlayer2_get_ShowAudioControls(This,pbool)	\
    ( (This)->lpVtbl -> get_ShowAudioControls(This,pbool) ) 

#define IMediaPlayer2_put_ShowAudioControls(This,bBool)	\
    ( (This)->lpVtbl -> put_ShowAudioControls(This,bBool) ) 

#define IMediaPlayer2_get_CaptioningID(This,pstrText)	\
    ( (This)->lpVtbl -> get_CaptioningID(This,pstrText) ) 

#define IMediaPlayer2_put_CaptioningID(This,strText)	\
    ( (This)->lpVtbl -> put_CaptioningID(This,strText) ) 

#define IMediaPlayer2_get_Mute(This,vbool)	\
    ( (This)->lpVtbl -> get_Mute(This,vbool) ) 

#define IMediaPlayer2_put_Mute(This,vbool)	\
    ( (This)->lpVtbl -> put_Mute(This,vbool) ) 

#define IMediaPlayer2_get_CanPreview(This,pCanPreview)	\
    ( (This)->lpVtbl -> get_CanPreview(This,pCanPreview) ) 

#define IMediaPlayer2_get_PreviewMode(This,pPreviewMode)	\
    ( (This)->lpVtbl -> get_PreviewMode(This,pPreviewMode) ) 

#define IMediaPlayer2_put_PreviewMode(This,PreviewMode)	\
    ( (This)->lpVtbl -> put_PreviewMode(This,PreviewMode) ) 

#define IMediaPlayer2_get_HasMultipleItems(This,pHasMuliItems)	\
    ( (This)->lpVtbl -> get_HasMultipleItems(This,pHasMuliItems) ) 

#define IMediaPlayer2_get_Language(This,pLanguage)	\
    ( (This)->lpVtbl -> get_Language(This,pLanguage) ) 

#define IMediaPlayer2_put_Language(This,Language)	\
    ( (This)->lpVtbl -> put_Language(This,Language) ) 

#define IMediaPlayer2_get_AudioStream(This,pStream)	\
    ( (This)->lpVtbl -> get_AudioStream(This,pStream) ) 

#define IMediaPlayer2_put_AudioStream(This,Stream)	\
    ( (This)->lpVtbl -> put_AudioStream(This,Stream) ) 

#define IMediaPlayer2_get_SAMIStyle(This,pbstrStyle)	\
    ( (This)->lpVtbl -> get_SAMIStyle(This,pbstrStyle) ) 

#define IMediaPlayer2_put_SAMIStyle(This,bstrStyle)	\
    ( (This)->lpVtbl -> put_SAMIStyle(This,bstrStyle) ) 

#define IMediaPlayer2_get_SAMILang(This,pbstrLang)	\
    ( (This)->lpVtbl -> get_SAMILang(This,pbstrLang) ) 

#define IMediaPlayer2_put_SAMILang(This,bstrLang)	\
    ( (This)->lpVtbl -> put_SAMILang(This,bstrLang) ) 

#define IMediaPlayer2_get_SAMIFileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_SAMIFileName(This,pbstrFileName) ) 

#define IMediaPlayer2_put_SAMIFileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_SAMIFileName(This,bstrFileName) ) 

#define IMediaPlayer2_get_StreamCount(This,pStreamCount)	\
    ( (This)->lpVtbl -> get_StreamCount(This,pStreamCount) ) 

#define IMediaPlayer2_get_ClientId(This,pbstrClientId)	\
    ( (This)->lpVtbl -> get_ClientId(This,pbstrClientId) ) 

#define IMediaPlayer2_get_ConnectionSpeed(This,plConnectionSpeed)	\
    ( (This)->lpVtbl -> get_ConnectionSpeed(This,plConnectionSpeed) ) 

#define IMediaPlayer2_get_AutoSize(This,pbool)	\
    ( (This)->lpVtbl -> get_AutoSize(This,pbool) ) 

#define IMediaPlayer2_put_AutoSize(This,vbool)	\
    ( (This)->lpVtbl -> put_AutoSize(This,vbool) ) 

#define IMediaPlayer2_get_EnableFullScreenControls(This,pbVal)	\
    ( (This)->lpVtbl -> get_EnableFullScreenControls(This,pbVal) ) 

#define IMediaPlayer2_put_EnableFullScreenControls(This,bVal)	\
    ( (This)->lpVtbl -> put_EnableFullScreenControls(This,bVal) ) 

#define IMediaPlayer2_get_ActiveMovie(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_ActiveMovie(This,ppdispatch) ) 

#define IMediaPlayer2_get_NSPlay(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_NSPlay(This,ppdispatch) ) 

#define IMediaPlayer2_get_WindowlessVideo(This,pbool)	\
    ( (This)->lpVtbl -> get_WindowlessVideo(This,pbool) ) 

#define IMediaPlayer2_put_WindowlessVideo(This,vbool)	\
    ( (This)->lpVtbl -> put_WindowlessVideo(This,vbool) ) 

#define IMediaPlayer2_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define IMediaPlayer2_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMediaPlayer2_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMediaPlayer2_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define IMediaPlayer2_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#define IMediaPlayer2_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define IMediaPlayer2_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    ( (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled) ) 

#define IMediaPlayer2_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    ( (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription) ) 

#define IMediaPlayer2_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    ( (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL) ) 

#define IMediaPlayer2_GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)	\
    ( (This)->lpVtbl -> GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL) ) 

#define IMediaPlayer2_GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)	\
    ( (This)->lpVtbl -> GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo) ) 

#define IMediaPlayer2_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define IMediaPlayer2_Open(This,bstrFileName)	\
    ( (This)->lpVtbl -> Open(This,bstrFileName) ) 

#define IMediaPlayer2_IsSoundCardEnabled(This,pbSoundCard)	\
    ( (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard) ) 

#define IMediaPlayer2_Next(This)	\
    ( (This)->lpVtbl -> Next(This) ) 

#define IMediaPlayer2_Previous(This)	\
    ( (This)->lpVtbl -> Previous(This) ) 

#define IMediaPlayer2_StreamSelect(This,StreamNum)	\
    ( (This)->lpVtbl -> StreamSelect(This,StreamNum) ) 

#define IMediaPlayer2_FastForward(This)	\
    ( (This)->lpVtbl -> FastForward(This) ) 

#define IMediaPlayer2_FastReverse(This)	\
    ( (This)->lpVtbl -> FastReverse(This) ) 

#define IMediaPlayer2_GetStreamName(This,StreamNum,pbstrStreamName)	\
    ( (This)->lpVtbl -> GetStreamName(This,StreamNum,pbstrStreamName) ) 

#define IMediaPlayer2_GetStreamGroup(This,StreamNum,pStreamGroup)	\
    ( (This)->lpVtbl -> GetStreamGroup(This,StreamNum,pStreamGroup) ) 

#define IMediaPlayer2_GetStreamSelected(This,StreamNum,pStreamSelected)	\
    ( (This)->lpVtbl -> GetStreamSelected(This,StreamNum,pStreamSelected) ) 


#define IMediaPlayer2_get_DVD(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_DVD(This,ppdispatch) ) 

#define IMediaPlayer2_GetMediaParameter(This,EntryNum,bstrParameterName,pbstrParameterValue)	\
    ( (This)->lpVtbl -> GetMediaParameter(This,EntryNum,bstrParameterName,pbstrParameterValue) ) 

#define IMediaPlayer2_GetMediaParameterName(This,EntryNum,Index,pbstrParameterName)	\
    ( (This)->lpVtbl -> GetMediaParameterName(This,EntryNum,Index,pbstrParameterName) ) 

#define IMediaPlayer2_get_EntryCount(This,pNumberEntries)	\
    ( (This)->lpVtbl -> get_EntryCount(This,pNumberEntries) ) 

#define IMediaPlayer2_GetCurrentEntry(This,pEntryNumber)	\
    ( (This)->lpVtbl -> GetCurrentEntry(This,pEntryNumber) ) 

#define IMediaPlayer2_SetCurrentEntry(This,EntryNumber)	\
    ( (This)->lpVtbl -> SetCurrentEntry(This,EntryNumber) ) 

#define IMediaPlayer2_ShowDialog(This,mpDialogIndex)	\
    ( (This)->lpVtbl -> ShowDialog(This,mpDialogIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_get_DVD_Proxy( 
    IMediaPlayer2 * This,
    /* [retval][out] */ IMediaPlayerDvd **ppdispatch);


void __RPC_STUB IMediaPlayer2_get_DVD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_GetMediaParameter_Proxy( 
    IMediaPlayer2 * This,
    /* [in] */ long EntryNum,
    /* [in] */ BSTR bstrParameterName,
    /* [retval][out] */ BSTR *pbstrParameterValue);


void __RPC_STUB IMediaPlayer2_GetMediaParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_GetMediaParameterName_Proxy( 
    IMediaPlayer2 * This,
    /* [in] */ long EntryNum,
    /* [in] */ long Index,
    /* [retval][out] */ BSTR *pbstrParameterName);


void __RPC_STUB IMediaPlayer2_GetMediaParameterName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_get_EntryCount_Proxy( 
    IMediaPlayer2 * This,
    /* [retval][out] */ long *pNumberEntries);


void __RPC_STUB IMediaPlayer2_get_EntryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_GetCurrentEntry_Proxy( 
    IMediaPlayer2 * This,
    /* [retval][out] */ long *pEntryNumber);


void __RPC_STUB IMediaPlayer2_GetCurrentEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_SetCurrentEntry_Proxy( 
    IMediaPlayer2 * This,
    /* [in] */ long EntryNumber);


void __RPC_STUB IMediaPlayer2_SetCurrentEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer2_ShowDialog_Proxy( 
    IMediaPlayer2 * This,
    /* [in] */ MPShowDialogConstants mpDialogIndex);


void __RPC_STUB IMediaPlayer2_ShowDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPlayer2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxsurfb.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXSurfB.cpp *
*------------*
*   Description:
*    This module contains the CDXBaseSurface implementaion.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include <DXTrans.h>
#include "DXSurfB.h"
#include "new.h"

CDXBaseSurface::CDXBaseSurface() :
    m_ulLocks(0),
    m_ulThreadsWaiting(0),
    m_Height(0),
    m_Width(0),
    m_pFreePtr(NULL),
    m_dwStatusFlags(DXSURF_READONLY),
    m_dwAppData(0)
{
    m_hSemaphore = CreateSemaphore(NULL, 0, MAXLONG, NULL);
    m_ulNumInRequired = m_ulMaxInputs = 0;
}

HRESULT CDXBaseSurface::FinalConstruct()
{
    return m_hSemaphore ? S_OK : E_OUTOFMEMORY;
}

void CDXBaseSurface::FinalRelease()
{
    while (m_pFreePtr)
    {
        CDXBaseARGBPtr *pNext = m_pFreePtr->m_pNext;
        DeleteARGBPointer(m_pFreePtr);
        m_pFreePtr = pNext;
    }
    if (m_hSemaphore)
    {
        CloseHandle(m_hSemaphore);
    }
}

STDMETHODIMP CDXBaseSurface::GetGenerationId(ULONG *pGenerationId)
{
    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
    {
        return E_POINTER;
    }
    Lock();
    OnUpdateGenerationId();
    *pGenerationId = m_dwGenerationId;
    Unlock();
    return S_OK;
}

STDMETHODIMP CDXBaseSurface::IncrementGenerationId(BOOL /*bRefresh */)
{
    Lock();
    m_dwGenerationId++;
    Unlock();
    return S_OK;
}


STDMETHODIMP CDXBaseSurface::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
	Lock();
        *pcbSize = OnGetObjectSize();
        Unlock();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::MapBoundsIn2Out
    (const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG /*ulOutIndex*/, DXBNDS *pOutBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pOutBounds, sizeof(*pOutBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pOutBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
}

STDMETHODIMP CDXBaseSurface::InitSurface(IUnknown *pDirectDraw,
                                         const DDSURFACEDESC * pDDSurfaceDesc,
                                         const GUID * pFormatId,
                                         const DXBNDS *pBounds,
                                         DWORD dwFlags)
{
    HRESULT hr = S_OK;
    if (pDDSurfaceDesc || DXIsBadReadPtr(pBounds, sizeof(*pBounds)) || pBounds->eType != DXBT_DISCRETE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _EnterCritWith0PtrLocks();
        if (m_Width)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
        }
        else
        {
            CDXDBnds *pbnds = (CDXDBnds *)pBounds;
            hr = OnSetSize(pbnds->Width(), pbnds->Height());
        }
        Unlock();
    }
    return hr;
}


STDMETHODIMP CDXBaseSurface::GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleFormatEnum)
{
    HRESULT hr = S_OK;
    if (DX_IS_BAD_OPTIONAL_WRITE_PTR(pFormat) ||
        DX_IS_BAD_OPTIONAL_WRITE_PTR(pSampleFormatEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        if (pFormat) *pFormat = SurfaceCLSID();
        if (pSampleFormatEnum) *pSampleFormatEnum = SampleFormatEnum();
    }
    return hr;
}

STDMETHODIMP CDXBaseSurface::GetBounds(DXBNDS* pBounds)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBounds, sizeof(*pBounds)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        new(pBounds) CDXDBnds(m_Width, m_Height);
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::GetStatusFlags(DWORD* pdwStatusFlags)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pdwStatusFlags, sizeof(*pdwStatusFlags)))
    {
        hr = E_POINTER;
    }
    else
    {
        Lock();
        *pdwStatusFlags = m_dwStatusFlags;
        Unlock();
    }
    return hr;    
} 

STDMETHODIMP CDXBaseSurface::SetStatusFlags(DWORD dwStatusFlags )
{
    _EnterCritWith0PtrLocks();
    m_dwStatusFlags = dwStatusFlags | DXSURF_READONLY;
    m_dwGenerationId++;
    Unlock();
    return S_OK;
} 

STDMETHODIMP CDXBaseSurface::GetDirectDrawSurface(REFIID riid, void **ppSurface)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDXBaseSurface::LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut,
                                         DWORD dwFlags, REFIID riid, void **ppPointer,
                                         DWORD * pGenerationId)
{
    HRESULT hr = S_OK;
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();

    if (m_Width == 0)
    {
        hr = E_FAIL;
    }
    else
    {
        RECT r;
        r.top = r.left = 0;
        r.right = m_Width;
        r.bottom = m_Height;
        if (pBounds)
        {
            if (pBounds->eType != DXBT_DISCRETE)
            {
                hr = DXTERR_INVALID_BOUNDS;
            }
            else
            {
                ((CDXDBnds *)pBounds)->GetXYRect(r);
                if (r.top < 0 || r.left < 0 || (ULONG)r.right > m_Width || (ULONG)r.bottom > m_Height || r.bottom <= r.top || r.right <= r.left)
                {
                    hr = DXTERR_INVALID_BOUNDS;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CDXBaseARGBPtr * pPtr = m_pFreePtr;
            if (pPtr)
            {
                m_pFreePtr = pPtr->m_pNext;
            }
            else
            {
                hr = CreateARGBPointer(this, &pPtr);
            }
            if (SUCCEEDED(hr))
            {
                hr = pPtr->InitFromLock(r, ulTimeOut, dwFlags, riid, ppPointer);
                if (pGenerationId)
                {
                    if (DXIsBadWritePtr(pGenerationId, sizeof(*pGenerationId)))
                    {
                        hr = E_POINTER;
                    }
                    else
                    {
                        *pGenerationId = m_dwGenerationId;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    m_ulLocks++;
                }
                else
                {
                    pPtr->m_pNext = m_pFreePtr;
                    m_pFreePtr = pPtr;
                }
            }
        }
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();
    return hr;
}

void CDXBaseSurface::_InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock)
{
    BOOL bMPLockOnly = m_bInMultiThreadWorkProc;

    if (!bMPLockOnly) Lock();
    m_MPWorkProcCrit.Lock();
    pPtrToUnlock->m_pNext = m_pFreePtr;
    m_pFreePtr = pPtrToUnlock;
    m_ulLocks--;
    if ((m_ulLocks == 0) && m_ulThreadsWaiting)
    {
        ReleaseSemaphore(m_hSemaphore, m_ulThreadsWaiting, NULL);
        m_ulThreadsWaiting = 0;
    }
    m_MPWorkProcCrit.Unlock();
    if (!bMPLockOnly) Unlock();

    IUnknown *punkOuter = GetControllingUnknown();
    punkOuter->Release();   // Release pointer's reference to us
                            // which could kill us!  Don't touch
                            // any members after this point.
}

//
//  Picking interface needs to test the appropriate point for hit testing
//
HRESULT CDXBaseSurface::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr;
    IDXARGBReadPtr *pPtr;
    hr = LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ, 
                     IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        DXPMSAMPLE val;
        pPtr->UnpackPremult(&val, 1, FALSE);
        pPtr->Release();
        hr = val.Alpha ? DXT_S_HITOUTPUT : S_FALSE;
    }
    else
    {
        if (hr == DXTERR_INVALID_BOUNDS) hr = S_FALSE;
    }
    return hr;
}

/*****************************************************************************
* RegisterSurface (STATIC member function)
*-----------------------------------------------------------------------------
*   Description:
*-----------------------------------------------------------------------------
*   Created By: RAL                                 Date: 12/10/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXBaseSurface::
RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                ULONG cCatReq, const CATID * pCatReq, BOOL bRegister)
{
    HRESULT hr = bRegister ? _Module.UpdateRegistryFromResource(ResourceId, bRegister) : S_OK;
    if (SUCCEEDED(hr))
    {
        CComPtr<ICatRegister> pCatRegister;
        HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_ALL, IID_ICatRegister, (void **)&pCatRegister);
        if (SUCCEEDED(hr))
        {
            if (bRegister)
            {
                hr = pCatRegister->RegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (SUCCEEDED(hr) && cCatReq && pCatReq) {
                    hr = pCatRegister->RegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            } 
            else
            {
                pCatRegister->UnRegisterClassImplCategories(rcid, cCatImpl, (CATID *)pCatImpl);
                if (cCatReq && pCatReq)
                {
                    pCatRegister->UnRegisterClassReqCategories(rcid, cCatReq, (CATID *)pCatReq);
                }
            }
        }
    }
    if ((!bRegister) && SUCCEEDED(hr)) 
    { 
        _Module.UpdateRegistryFromResource(ResourceId, bRegister);
    }
    return hr;
}

//
//  CDXBaseARGBPtr
//
STDMETHODIMP CDXBaseARGBPtr::QueryInterface(REFIID riid, void ** ppv)
{
    if (IsEqualGUID(riid, IID_IUnknown) ||
        IsEqualGUID(riid, IID_IDXARGBReadPtr))
    {
        *ppv = (IDXARGBReadPtr *)this;
        m_ulRefCount++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::AddRef()
{
    return ++m_ulRefCount;
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::Release()
{
    --m_ulRefCount;
    ULONG c = m_ulRefCount;
    if (c == 0)
    {
        m_pSurface->_InternalUnlock(this);  // Don't touch members after this call.
    }
    return c;
}

HRESULT STDMETHODCALLTYPE CDXBaseARGBPtr::GetSurface(REFIID riid, void **ppSurface)
{
    return m_pSurface->GetControllingUnknown()->QueryInterface(riid, ppSurface);
}


DXSAMPLEFORMATENUM STDMETHODCALLTYPE CDXBaseARGBPtr::GetNativeType(DXNATIVETYPEINFO *pInfo)
{
    if (pInfo)
    {
        memset(pInfo, 0, sizeof(pInfo));
    }
    return m_pSurface->SampleFormatEnum();
}


void STDMETHODCALLTYPE CDXBaseARGBPtr::Move(long cSamples)
{
    m_FillInfo.x += cSamples;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToRow(ULONG y)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::MoveToXY(ULONG x, ULONG y)
{
    m_FillInfo.x = x + m_LockedRect.left;
    m_FillInfo.y = y + m_LockedRect.top;
    //--- Moving one column past the end is okay
    _ASSERT((long)m_FillInfo.x <= m_LockedRect.right);
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
}

ULONG STDMETHODCALLTYPE CDXBaseARGBPtr::MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo)
{
    m_FillInfo.x = m_LockedRect.left;
    m_FillInfo.y = Row + m_LockedRect.top;
    _ASSERT((long)m_FillInfo.y < m_LockedRect.bottom);
    *ppInfo = &m_RunInfo;
    return 1;
}

DXSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = false;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

DXPMSAMPLE *STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove)
{
    m_FillInfo.pSamples = pSamples;
    m_FillInfo.cSamples = cSamples;
    m_FillInfo.bPremult = true;
    FillSamples(m_FillInfo);
    if (bMove) m_FillInfo.x += cSamples;
    return pSamples;
}

void STDMETHODCALLTYPE CDXBaseARGBPtr::UnpackRect(const DXPACKEDRECTDESC *pDesc)
{
    DXPtrFillInfo FillInfo;
    FillInfo.pSamples = pDesc->pSamples;
    FillInfo.cSamples = pDesc->rect.right - pDesc->rect.left;
    FillInfo.x = pDesc->rect.left + m_LockedRect.left;
    FillInfo.bPremult = pDesc->bPremult;
    ULONG YLimit = pDesc->rect.bottom + m_LockedRect.top;
    for (FillInfo.y = pDesc->rect.top + m_LockedRect.top;
         FillInfo.y < YLimit;
         FillInfo.y++)
    {
        FillSamples(FillInfo);
        FillInfo.pSamples += FillInfo.cSamples;
    }
}

HRESULT CDXBaseARGBPtr::InitFromLock(const RECT & rect, ULONG /*ulTimeOut*/, DWORD dwLockFlags, REFIID riid, void ** ppv)
{
    HRESULT hr = S_OK;
    if (dwLockFlags & DXLOCKF_READWRITE)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LockedRect = rect;
        m_RunInfo.Count = rect.right - rect.left;
        if (m_pSurface->SampleFormatEnum() & DXPF_TRANSPARENCY)
        {
            m_RunInfo.Type = DXRUNTYPE_UNKNOWN;
        }
        else
        {
            m_RunInfo.Type = DXRUNTYPE_OPAQUE;
        }
        m_FillInfo.x = rect.left;
        m_FillInfo.y = rect.top;
        hr = QueryInterface(riid, ppv);
        if (SUCCEEDED(hr))
        {
            m_pSurface->GetControllingUnknown()->AddRef();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxhelp3.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
// DXHELP3.cpp : Contains definitions of routines shared by multiple effects

#ifndef __DXHELP3_H_
#define __DXHELP3_H_

#include <d3d.h>
#include <d3drm.h>
#include <math.h>


#ifndef PI
#define PI 3.1415926538
#endif

/*******************
This class is used to rotate a set of points about an axis.  An example of
how this is used is in Explode.cpp.  Basically you set up the axis and the
angle with the Set() function. The angle is in radians, and the Axis given
MUST be normalized.  That is the magnitude of the vector must be one. Then
you call RotatePoint() for each point.
*******************/
class Rotate
{
public:
    Rotate(){ D3DVECTOR v; v.x = 1; v.y = 0; v.z = 0; Set(v, PI); }
    Rotate(D3DVECTOR NormalAxis, double Angle) { Set(NormalAxis, Angle); }

    D3DVECTOR RotatePoint(D3DVECTOR Org)
    {
	D3DVECTOR Result;

	Result.x = Org.x * m_d3dvctrXComponent.x + 
		   Org.y * m_d3dvctrXComponent.y + 
		   Org.z * m_d3dvctrXComponent.z;

	Result.y = Org.x * m_d3dvctrYComponent.x + 
		   Org.y * m_d3dvctrYComponent.y + 
		   Org.z * m_d3dvctrYComponent.z;

	Result.z = Org.x * m_d3dvctrZComponent.x + 
		   Org.y * m_d3dvctrZComponent.y + 
		   Org.z * m_d3dvctrZComponent.z;

	return Result;
    }

    void Set(D3DVECTOR d3dvtcrAxis, double dAngle);

private:
    D3DVECTOR m_d3dvctrXComponent, m_d3dvctrYComponent, m_d3dvctrZComponent;
};

/******************
Copy the input MeshBuilder to the Output MeshBuilder.  
But, create independent vertices for each face in the output
mesh.  That is no two faces share a single vertice.
******************/
HRESULT DecoupleVertices(IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			 IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/******************
For each MeshBuilder in lpMeshBuilderIn find the corresponding 
MeshBuilder in lpMeshBuilderOut and call (*lpCallBack)(lpThis, lpmbOutX, lpmbInX).
If there is no corresponding output mesh for the input mesh, create it.
*******************/
HRESULT TraverseSubMeshes(HRESULT (*lpCallBack)(void *lpThis,
						IDirect3DRMMeshBuilder3* lpOut,
						IDirect3DRMMeshBuilder3* lpIn),
			  void *lpThis, 
			  IDirect3DRMMeshBuilder3* lpMeshBuilderOut,
			  IDirect3DRMMeshBuilder3* lpMeshBuilderIn);

/***********************
Given three points, return the normal to the plane defined by these three points.
For a Right Handed system points A, B, and C should be in a CW order on the plane.
From CRC Standard Mathematical Tables 22nd Edition, page 380.  
Direction Numbers and Direction Cosines.
***********************/
inline D3DVECTOR ComputeNormal(D3DVECTOR d3dptA, D3DVECTOR d3dptB, D3DVECTOR d3dptC)
{
    const D3DVECTOR d3dptOne = d3dptB - d3dptA;
    const D3DVECTOR d3dptTwo = d3dptC - d3dptB;

    D3DVECTOR d3dptRetValue;
    d3dptRetValue.x = d3dptOne.y * d3dptTwo.z - d3dptOne.z * d3dptTwo.y;
    d3dptRetValue.y = d3dptOne.z * d3dptTwo.x - d3dptOne.x * d3dptTwo.z;
    d3dptRetValue.z = d3dptOne.x * d3dptTwo.y - d3dptOne.y * d3dptTwo.x;

    float Magnitude = (float)sqrt(d3dptRetValue.x * d3dptRetValue.x + 
                                  d3dptRetValue.y * d3dptRetValue.y + 
                                  d3dptRetValue.z * d3dptRetValue.z);

    // There's no good answer for how to get around this problem. The magnitude
    // here can be zero if the points given are not unique or are collinear. In
    // that case, there is no single normal, but rather there is a whole range of
    // them (either there are two unique points describing a line, or there is
    // only one describing a point).  We choose simply to return the un-normalized
    // vector, which is probably almost a zero vector.
    if (fabs(Magnitude) < 1.0e-5)
        return d3dptRetValue;
    else
        return d3dptRetValue/Magnitude;
}

float GetDlgItemFloat(HWND hDlg, int id);
BOOL SetDlgItemFloat( HWND hDlg, int id, float f );
double GetDlgItemDouble(HWND hDlg, int id);
BOOL SetDlgItemDouble( HWND hDlg, int id, double d );

#endif // __DXHELP3_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxhelper.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/11/95
*  Copyright (C) 1995 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXHelper_h
#define DXHelper_h

#include <DXTError.h>
#include <DXBounds.h>
#include <DXTrans.h>

#include <limits.h>
#include <crtdbg.h>
#include <malloc.h>
#include <math.h>

//=== Constants ==============================================================

#define DX_MMX_COUNT_CUTOFF 16

//=== Class, Enum, Struct and Union Declarations =============================

/*** DXLIMAPINFO
*   This structure is used by the array linear interpolation and image
*   filtering routines.
*/
typedef struct DXLIMAPINFO
{
    float   IndexFrac;
    USHORT  Index;
    BYTE    Weight;
} DXLIMAPINFO;

//
//  Declare this class as a global to use for determining when to call MMX optimized
//  code.  You can use MinMMXOverCount to determine if MMX instructions are present.
//  Typically, you would only want to use MMX instructions when you have a reasonably
//  large number of pixels to work on.  In this case your code can always be coded like
//  this:
//
//  if (CountOfPixelsToDo >= g_MMXInfo.MinMMXOverCount())
//  {
//      Do MMX Stuff
//  } else {
//      Do integer / float based stuff
//  }    
//  
//  If you code your MMX sequences like this, you will not have to use a special test
//  for the presence of MMX since the MinMMXOverCount will be set to 0xFFFFFFFF if there
//  is no MMX present on the processor.
//
//  You do not need to use this unless your module needs to conditionally execute MMX vs
//  non-MMX code.  If you only call the helper functions provided by DXTrans.Dll, such as
//  DXOverArrayMMX, you do NOT need this test.  You can always call these functions and they
//  will use the MMX code path only when MMX instructions are present.
//
#pragma warning( push )
#pragma warning( disable : 4793 )
class CDXMMXInfo
{
    ULONG m_MinMMXOver;
public:
    CDXMMXInfo()
    {
#ifndef _X86_
        m_MinMMXOver = 0xFFFFFFFF;
#else
        m_MinMMXOver = DX_MMX_COUNT_CUTOFF;
        __try
        {
            __asm
            {
                //--- Try the MMX exit multi-media state instruction
                EMMS;
            }
        }
        __except( GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION )
        {
            //--- MMX instructions not available
            m_MinMMXOver = 0xFFFFFFFF;
        }
#endif
    }
    inline ULONG MinMMXOverCount() { return m_MinMMXOver; }
};
#pragma warning( pop )



//=== Function Prototypes ==========================================
_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray(const DXBASESAMPLE* pSamps, 
                             DXLIMAPINFO* pMapInfo,
                             __out_ecount(dwResultCount) DXBASESAMPLE* pResults, 
                             DWORD dwResultCount);

_DXTRANS_IMPL_EXT void WINAPI
    DXLinearInterpolateArray( const DXBASESAMPLE* pSamps, PUSHORT pIndexes,
                              PBYTE pWeights, DXBASESAMPLE* pResults,
                              DWORD dwResultCount );

//
//  DXOverArray
//
//  Composits an array of source samples over the samples in the pDest buffer.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArray(__out_ecount(nCount) DXPMSAMPLE* pDest, 
                __in_ecount(nCount)  const DXPMSAMPLE* pSrc, 
                ULONG nCount);

//
//  DXOverArrayMMX
//
//  Identical to DXOverArray except that the MMX instruction set will be used for
//  large arrays of samples.  If the CPU does not support MMX, you may still call
//  this function, which will perform the same operation without the use of the MMX
//  unit.
//
//  Note that it is LESS EFFICIENT to use this function if the majority of the pixels
//  in the pSrc buffer are either clear (alpha 0) or opaque (alpha 0xFF).  This is 
//  because the MMX code must process every pixel and can not special case clear or
//  opaque pixels.  If there are a large number of translucent pixels then this function
//  is much more efficent than DXOverArray.
//
//  pDest   - Pointer to the samples that will be modified by compositing the pSrc
//            samples over the pDest samples.
//  pSrc    - The samples to composit over the pDest samples
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXOverArrayMMX(__out_ecount(nCount) DXPMSAMPLE* pDest, 
                   __in_ecount(nCount)  const DXPMSAMPLE* pSrc, 
                   ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the color (val)
//            over the pDest samples.
//  val     - The premultiplied color value to composit over the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstOverArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//
//  DXConstOverArray
//
//  Composits a single color over an array of samples.
//
//  pDest   - Pointer to the samples that will be modified by compositing the samples
//            in the buffer over the color (val).
//  val     - The premultiplied color value to composit under the pDest array.
//  nCount  - The number of samples to process
//
_DXTRANS_IMPL_EXT void WINAPI
    DXConstUnderArray(DXPMSAMPLE* pDest, const DXPMSAMPLE & val, ULONG nCount);

//===================================================================================
//
//  Dithering Helpers
//
//  Image transforms are sometimes asked to dither their output.  This helper function
//  should be used by all image transforms to enusure a consistant dither pattern.
//
//  DXDitherArray is used to dither pixels prior to writing them to a DXSurface.
//  The caller must fill in the DXDITHERDESC structure, setting X and Y to the
//  output surface X,Y coordinates that the pixels will be placed in.  The samples
//  will be modified in place.
//
//  Once the samples have been dithered, they should be written to or composited with
//  the destination surface.
//
#define DX_DITHER_HEIGHT    4       // The dither pattern is 4x4 pixels
#define DX_DITHER_WIDTH     4

typedef struct DXDITHERDESC
{
    DXBASESAMPLE *      pSamples;       // Pointer to the 32-bit samples to dither
    ULONG               cSamples;       // Count of number of samples in pSamples buffer
    ULONG               x;              // X coordinate of the output surface
    ULONG               y;              // Y coordinate of the output surface
    DXSAMPLEFORMATENUM  DestSurfaceFmt; // Pixel format of the output surface
} DXDITHERDESC;

_DXTRANS_IMPL_EXT void WINAPI
    DXDitherArray(const DXDITHERDESC *pDitherDesc);

//=== Enumerated Set Definitions =============================================


//=== Function Type Definitions ==============================================


//=== Class, Struct and Union Definitions ====================================


//=== Inline Functions =======================================================

//===================================================================================
//
//  Memory allocation helpers.
//
//  These macros are used to allocate arrays of samples from the stack (using _alloca)
//  and cast them to the appropriate type.  The ulNumSamples parameter is the count
//  of samples required.
//
#define DXBASESAMPLE_Alloca( ulNumSamples ) \
    (DXBASESAMPLE *)_alloca( (ulNumSamples) * sizeof( DXBASESAMPLE ) )

#define DXSAMPLE_Alloca( ulNumSamples ) \
    (DXSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXSAMPLE ) )

#define DXPMSAMPLE_Alloca( ulNumSamples ) \
    (DXPMSAMPLE *)_alloca( (ulNumSamples) * sizeof( DXPMSAMPLE ) )

//  These macros are used to allocate arrays of samples from the heap (using malloc)
//  and cast them to the appropriate type.  The ulNumSamples parameter is the count
//  of samples required.
//
#define DXPMSAMPLE_Malloc( ulNumSamples ) \
    (DXPMSAMPLE *)malloc( (ulNumSamples) * sizeof( DXPMSAMPLE ) )

//===================================================================================
//
//  Critical section helpers.
//
//  These C++ classes, CDXAutoObjectLock and CDXAutoCritSecLock are used within functions
//  to automatically claim critical sections upon constuction, and the critical section
//  will be released when the object is destroyed (goes out of scope).
//
//  The macros DXAUTO_OBJ_LOCK and DX_AUTO_SEC_LOCK(s) are normally used at the beginning
//  of a function that requires a critical section.  Any exit from the scope in which the
//  auto-lock was taken will automatically release the lock.
//

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used
class CDXAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CDXAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CDXAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define DXAUTO_OBJ_LOCK CDXAutoObjectLock lck(this);
#define DXAUTO_OBJ_LOCK_( t ) CDXAutoObjectLock lck(t);

class CDXAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CDXAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CDXAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define DXAUTO_SEC_LOCK( s ) CDXAutoCritSecLock lck(s);
#endif  // __ATLCOM_H__

//--- This function is used to compute the coefficient for a gaussian filter coordinate
inline float DXGaussCoeff( double x, double y, double Sigma )
{
    double TwoSigmaSq = 2 * ( Sigma * Sigma );
    return (float)(exp( ( -(x*x + y*y) / TwoSigmaSq  ) ) /
                        ( 3.1415927 * TwoSigmaSq ));
}

//--- This function is used to initialize a gaussian convolution filter
inline void DXInitGaussianFilter( float* pFilter, ULONG Width, ULONG Height, double Sigma )
{
    int i, NumCoeff = Width * Height;
    float  val, CoeffAdjust, FilterSum = 0.;
    double x, y;
    double LeftX   = -(double)(Width / 2);
    double RightX  =   Width - LeftX;
    double TopY    = -(double)(Height / 2);
    double BottomY =   Height - TopY;

    for( y = -TopY; y <= BottomY; y += 1. )
    {
        for( x = -LeftX; x <= RightX; x += 1. )
        {
            val = DXGaussCoeff( x, y, Sigma );
            pFilter[i++] = val;
        }
    }

    //--- Normalize filter (make it sum to 1.0)
    for( i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];

    if( FilterSum < 1. )
    {
        CoeffAdjust = 1.f / FilterSum;
        for( i = 0; i < NumCoeff; ++i )
        {
            pFilter[i] *= CoeffAdjust;
        }
    }

} /* DXInitGaussianFilter*/

//
//  DXConvertToGray
//
//  Translates a color sample to a gray scale sample
//
//  Sample  - The sample to convert to gray scale.
//  Return value is the gray scale sample.
//
inline DXBASESAMPLE DXConvertToGray( DXBASESAMPLE Sample )
{
    DWORD v = Sample;
    DWORD r = (BYTE)(v >> 16);
    DWORD g = (BYTE)(v >> 8);
    DWORD b = (BYTE)(v);
    DWORD sat = (r*306 + g*601 + b*117) / 1024;
    v &= 0xFF000000;
    v |= (sat << 16) | (sat << 8) | sat;
    return v;
} /* DXConvertToGray */

//--- This returns into the destination the value of the source
//  sample scaled by its own alpha (producing a premultiplied alpha sample)
//
inline DXPMSAMPLE DXPreMultSample(const DXSAMPLE & Src)
{
    if(Src.Alpha == 255 )
    {
        return (DWORD)Src;
    }
    else if(Src.Alpha == 0 )
    {
        return 0;
    }
    else
    {
        unsigned t1, t2;
        t1 = (Src & 0x00ff00ff) * Src.Alpha + 0x00800080;
        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

        t2 = (((Src >> 8) & 0x000000ff) | 0x01000000) * Src.Alpha + 0x00800080;
        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        return (t1 | t2);
    }
} /* DXPreMultSample */

inline DXPMSAMPLE * DXPreMultArray(DXSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF)
        {
            if (SrcAlpha == 0)
            {
                pBuffer[i] = 0;
            }
            else
            {
                DWORD S = pBuffer[i];
                DWORD t1 = (S & 0x00ff00ff) * SrcAlpha + 0x00800080;
                t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                DWORD t2 = (((S >> 8) & 0x000000ff) | 0x01000000) * SrcAlpha + 0x00800080;
                t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

                pBuffer[i] = (t1 | t2);
            }
        }
    }
    return (DXPMSAMPLE *)pBuffer;
}


inline DXSAMPLE DXUnPreMultSample(const DXPMSAMPLE & Src)
{
    if(Src.Alpha == 255 || Src.Alpha == 0)
    {
        return (DWORD)Src;
    }
    else
    {
        DXSAMPLE Dst;
        Dst.Blue  = (BYTE)((Src.Blue  * 255) / Src.Alpha);
        Dst.Green = (BYTE)((Src.Green * 255) / Src.Alpha);
        Dst.Red   = (BYTE)((Src.Red   * 255) / Src.Alpha);
        Dst.Alpha = Src.Alpha;
        return Dst;
    }
} /* DXUnPreMultSample */

inline DXSAMPLE * DXUnPreMultArray(DXPMSAMPLE *pBuffer, ULONG cSamples)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        BYTE SrcAlpha = pBuffer[i].Alpha;
        if (SrcAlpha != 0xFF && SrcAlpha != 0)
        {
            pBuffer[i].Blue  = (BYTE)((pBuffer[i].Blue  * 255) / SrcAlpha);
            pBuffer[i].Green = (BYTE)((pBuffer[i].Green * 255) / SrcAlpha);
            pBuffer[i].Red   = (BYTE)((pBuffer[i].Red   * 255) / SrcAlpha);
        }
    }
    return (DXSAMPLE *)pBuffer;
}


//
//  This returns the result of 255-Alpha which is computed by doing a NOT
//
inline BYTE DXInvertAlpha( BYTE Alpha ) { return (BYTE)~Alpha; }

inline DWORD DXScaleSample( DWORD Src, ULONG beta )
{
    ULONG t1, t2;

    t1 = (Src & 0x00ff00ff) * beta + 0x00800080;
    t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2 = ((Src >> 8) & 0x00ff00ff) * beta + 0x00800080;
    t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (DWORD)(t1 | t2);
}


inline DWORD DXScaleSamplePercent( DWORD Src, float Percent )
{
    if (Percent > (254.0f / 255.0f)) {
        return Src;
    }
    else
    {
        return DXScaleSample(Src, (BYTE)(Percent * 255));
    }
}

inline void DXCompositeOver(DXPMSAMPLE & Dst, const DXPMSAMPLE & Src)
{
    if (Src.Alpha)
    {
        ULONG Beta = DXInvertAlpha(Src.Alpha);
        if (Beta)
        {
            Dst = Src + DXScaleSample(Dst, Beta);
        }
        else
        {
            Dst = Src;
        }
    }
}


inline DXPMSAMPLE DXCompositeUnder(DXPMSAMPLE Dst, DXPMSAMPLE Src )
{
    return Dst + DXScaleSample(Src, DXInvertAlpha(Dst.Alpha));
}


inline DXBASESAMPLE DXApplyLookupTable(const DXBASESAMPLE Src, const BYTE * pTable)
{
    DXBASESAMPLE Dest;
    Dest.Blue   = pTable[Src.Blue];
    Dest.Green  = pTable[Src.Green];
    Dest.Red    = pTable[Src.Red];
    Dest.Alpha  = pTable[Src.Alpha];
    return Dest;
}

inline DXBASESAMPLE * DXApplyLookupTableArray(DXBASESAMPLE *pBuffer, ULONG cSamples, const BYTE * pTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        DWORD v = pBuffer[i];
        DWORD a = pTable[v >> 24];
        DWORD r = pTable[(BYTE)(v >> 16)];
        DWORD g = pTable[(BYTE)(v >> 8)];
        DWORD b = pTable[(BYTE)v];
        pBuffer[i] = (a << 24) | (r << 16) | (g << 8) | b;
    }
    return pBuffer;
}

inline DXBASESAMPLE * DXApplyColorChannelLookupArray(DXBASESAMPLE *pBuffer,
                                                     ULONG cSamples,
                                                     const BYTE * pAlphaTable,
                                                     const BYTE * pRedTable,
                                                     const BYTE * pGreenTable,
                                                     const BYTE * pBlueTable)
{
    for (ULONG i = 0; i < cSamples; i++)
    {
        pBuffer[i].Blue   = pBlueTable[pBuffer[i].Blue];
        pBuffer[i].Green  = pGreenTable[pBuffer[i].Green];
        pBuffer[i].Red    = pRedTable[pBuffer[i].Red];
        pBuffer[i].Alpha  = pAlphaTable[pBuffer[i].Alpha];
    }
    return pBuffer;
}


//
//  CDXScale helper class
//
//  This class uses a pre-computed lookup table to scale samples.  For scaling large
//  arrays of samples to a constant scale, this is much faster than using even MMX
//  instructions.  This class is usually declared as a member of another class and
//  is most often used to apply a global opacity to a set of samples.
//
//  When using this class, you must always check for the two special cases of clear
//  and opaque before calling any of the scaling member functions.  Do this by using
//  the ScaleType() inline function.  Your code should look somthing like this:
//
//  if (ScaleType() == DXRUNTYPE_CLEAR)
//      Do whatever you do for a 0 alpha set of samples -- usually just ignore them
//  else if (ScaleType() == DXRUNTYPE_OPAQUE)
//      Do whatever you would do for a non-scaled set of samples
//  else
//      Scale the samples by using ScaleSample or one of the ScaleArray members
//
//  If you call any of the scaling members when the ScaleType() is either clear or
//  opaque, you will GP fault becuase the lookup table will not be allocated.
//
//  The scale can be set using either a floating point number between 0 and 1 using:
//      CDXScale::SetScale / CDXScale::GetScale
//  or you can use a byte integer value by using:
//      CDXScale::SetScaleAlphaValue / CDXScale::GetScaleAlphaValue
//
class CDXScale
{
private:
    float       m_Scale;
    BYTE        m_AlphaScale;
    BYTE        *m_pTable;

HRESULT InternalSetScale(BYTE Scale)
{
    if (m_AlphaScale == Scale) return S_OK;
    if (Scale == 0 || Scale == 255) 
    {
        delete[] m_pTable;
        m_pTable = NULL;
    }
    else
    {
        if(!m_pTable)
        {
            m_pTable = new BYTE[256];
            if(!m_pTable )
            {
                return E_OUTOFMEMORY;
            }
        }
        for (int i = 0; i < 256; ++i )
        {
            m_pTable[i] = (BYTE)((i * Scale) / 255);
        }
    }
    m_AlphaScale = Scale;
    return S_OK;
}
public:
    CDXScale() : 
      m_Scale(1.0f),
      m_AlphaScale(0xFF),
      m_pTable(NULL)
      {}
    ~CDXScale()
    {
        delete[] m_pTable;
    }
    DXRUNTYPE ScaleType() 
    {
        if (m_AlphaScale == 0) return DXRUNTYPE_CLEAR;
        if (m_AlphaScale == 0xFF) return DXRUNTYPE_OPAQUE;
        return DXRUNTYPE_TRANS;
    }
    HRESULT SetScaleAlphaValue(BYTE Alpha)
    {
        HRESULT hr = InternalSetScale(Alpha);
        if (SUCCEEDED(hr))
        {
            m_Scale = ((float)Alpha) / 255.0f;
        }
        return hr;
    }
    BYTE GetScaleAlphaValue(void)
    {
        return m_AlphaScale;
    }
    HRESULT SetScale(float Scale)
    {
        HRESULT hr = S_OK;
        if(( Scale < 0.0f ) || ( Scale > 1.0f ) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ULONG IntScale = (ULONG)(Scale * 256.0f);     // Round up alpha (.9999 = 255 = Solid)
            if (IntScale > 255) 
            {
                IntScale = 255;
            }
            hr = SetScaleAlphaValue((BYTE)IntScale);
            if (SUCCEEDED(hr))
            {
                m_Scale = Scale;
            }
        }
        return hr;
    }
    float GetScale() const
    {
        return m_Scale;
    }
    DXRUNTYPE ScaleType() const
    {
        return (m_pTable ? DXRUNTYPE_TRANS : (m_AlphaScale ? DXRUNTYPE_OPAQUE : DXRUNTYPE_CLEAR));
    }
    DWORD ScaleSample(const DWORD s) const
    {
        return DXApplyLookupTable((DXBASESAMPLE)s, m_pTable);
    }
    DXBASESAMPLE * ScaleBaseArray(DXBASESAMPLE * pBuffer, ULONG cSamples) const
    {
        return DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXPMSAMPLE * ScalePremultArray(DXPMSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXPMSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArray(DXSAMPLE * pBuffer, ULONG cSamples) const
    {
        return (DXSAMPLE *)DXApplyLookupTableArray(pBuffer, cSamples, m_pTable);
    }
    DXSAMPLE * ScaleArrayAlphaOnly(DXSAMPLE *pBuffer, ULONG cSamples) const
    {
        const BYTE *pTable = m_pTable;
        for (ULONG i = 0; i < cSamples; i++)
        {
            pBuffer[i].Alpha  = pTable[pBuffer[i].Alpha];
        }
        return pBuffer;
    }
};

inline DWORD DXWeightedAverage( DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG Wgt )
{
    _ASSERT( Wgt < 256 );
    ULONG t1, t2;
    ULONG InvWgt = Wgt ^ 0xFF;

    t1  = (((S1 & 0x00ff00ff) * Wgt) + ((S2 & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t1  = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

    t2  = ((((S1 >> 8) & 0x00ff00ff) * Wgt) + (((S2 >> 8) & 0x00ff00ff) * InvWgt )) + 0x00800080;
    t2  = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;

    return (t1 | t2);
} /* DXWeightedAverage */

inline void DXWeightedAverageArray( DXBASESAMPLE* pS1, DXBASESAMPLE* pS2, ULONG Wgt,
                                    DXBASESAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    for( DWORD i = 0; i < dwCount; ++i )
    {
        pResults[i] = DXWeightedAverage( pS1[i], pS2[i], Wgt );
    }
} /* DXWeightedAverageArray */

inline void DXWeightedAverageArrayOver( DXPMSAMPLE* pS1, DXPMSAMPLE* pS2, ULONG Wgt,
                                        DXPMSAMPLE* pResults, DWORD dwCount )
{
    _ASSERT( pS1 && pS2 && pResults && dwCount );
    DWORD i;

    if( Wgt == 255 )
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXCompositeOver( pResults[i], pS1[i] );
        }
    }
    else
    {
        for( i = 0; i < dwCount; ++i )
        {
            DXPMSAMPLE Avg = DXWeightedAverage( (DXBASESAMPLE)pS1[i],
                                                (DXBASESAMPLE)pS2[i], Wgt );
            DXCompositeOver( pResults[i], Avg );
        }
    }

} /* DXWeightedAverageArrayOver */

inline void DXScalePremultArray(DXPMSAMPLE *pBuffer, ULONG cSamples, BYTE Weight)
{
    for (DXPMSAMPLE *pBuffLimit = pBuffer + cSamples; pBuffer < pBuffLimit; pBuffer++)
    {
        *pBuffer = DXScaleSample(*pBuffer, Weight);
    }
}



//
//
inline HRESULT DXClipToOutputWithPlacement(CDXDBnds & LogicalOutBnds, const CDXDBnds * pClipBnds, CDXDBnds & PhysicalOutBnds, const CDXDVec *pPlacement)
{
    if(pClipBnds && (!LogicalOutBnds.IntersectBounds(*pClipBnds)))
    {
        return S_FALSE;    // no intersect, we're done
    }
    else
    {
        CDXDVec vClipPos(false);
        LogicalOutBnds.GetMinVector( vClipPos );
        if (pPlacement)
        {
            vClipPos -= *pPlacement;
        }
        PhysicalOutBnds += vClipPos;
        if (!LogicalOutBnds.IntersectBounds(PhysicalOutBnds))
        {
            return S_FALSE;
        }
        PhysicalOutBnds = LogicalOutBnds;
        PhysicalOutBnds -= vClipPos;
    }
    return S_OK;
}



//
//  Helper for converting a color ref to a DXSAMPLE
//
inline DWORD DXSampleFromColorRef(COLORREF cr)
{
    DXSAMPLE Samp(0xFF, GetRValue(cr), GetGValue(cr), GetBValue(cr));
    return Samp;
}

//
//  Fill an entire surface with a color
//
inline HRESULT DXFillSurface( IDXSurface *pSurface, DXPMSAMPLE Color,
                              BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( NULL, ulTimeOut, DXLOCKF_READWRITE, 
                                        IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurface */

//
//  Fill a specified sub-rectangle of a surface with a color.
//
inline HRESULT DXFillSurfaceRect( IDXSurface *pSurface, RECT & rect, DXPMSAMPLE Color,
                                  BOOL bDoOver = FALSE, ULONG ulTimeOut = 10000 )
{
    CDXDBnds bnds(rect);
    IDXARGBReadWritePtr * pPtr;
    HRESULT hr = pSurface->LockSurface( &bnds, ulTimeOut, DXLOCKF_READWRITE, 
                                         IID_IDXARGBReadWritePtr, (void **)&pPtr, NULL);
    if( SUCCEEDED(hr) )
    {
        pPtr->FillRect(NULL, Color, bDoOver);
        pPtr->Release();
    }
    return hr;
} /* DXFillSurfaceRect */



//
//  The DestBnds height and width must be greater than or equal to the source bounds.
//
//  The dwFlags parameter uses the flags defined by IDXSurfaceFactory::BitBlt:
// 
//    DXBOF_DO_OVER
//    DXBOF_DITHER
//
inline HRESULT DXBitBlt(IDXSurface * pDest, const CDXDBnds & DestBnds, 
                        IDXSurface * pSrc, const CDXDBnds & SrcBnds, 
                        DWORD dwFlags, ULONG ulTimeout)
{
    IDXARGBReadPtr * pIn;
    HRESULT hr;
    hr = pSrc->LockSurface( &SrcBnds, INFINITE,
                            (dwFlags & DXBOF_DO_OVER) ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                            IID_IDXARGBReadPtr, (void**)&pIn, NULL);
    if(SUCCEEDED(hr))
    {
        IDXARGBReadWritePtr * pOut;
        hr = pDest->LockSurface( &DestBnds, INFINITE, DXLOCKF_READWRITE,
                                 IID_IDXARGBReadWritePtr, (void**)&pOut, NULL );
        if (SUCCEEDED(hr))
        {
            DXSAMPLEFORMATENUM InNativeType = pIn->GetNativeType(NULL);
            DXSAMPLEFORMATENUM OutNativeType = pOut->GetNativeType(NULL);
            BOOL bSrcIsOpaque = !(InNativeType & (DXPF_TRANSLUCENCY | DXPF_TRANSPARENCY));
            const ULONG Width = SrcBnds.Width();
            DXPMSAMPLE *pSrcBuff = NULL;
            if( InNativeType != DXPF_PMARGB32 )
            {
                pSrcBuff = DXPMSAMPLE_Malloc(Width);
                if( NULL == pSrcBuff )
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            if( SUCCEEDED( hr ) )
            {
                //
                //  Don't dither unless the dest has a greater error term than the source.
                //
                if ((dwFlags & DXBOF_DITHER) && 
                    ((OutNativeType & DXPF_ERRORMASK) <= (InNativeType & DXPF_ERRORMASK)))
                {
                    dwFlags &= (~DXBOF_DITHER);
                }
                if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
                {
                    //--- Allocate a working output buffer if necessary
                    DXPMSAMPLE *pDestBuff = NULL;
                    if( OutNativeType != DXPF_PMARGB32 )
                    {
                        pDestBuff = DXPMSAMPLE_Malloc(Width);
                        if( NULL == pDestBuff )
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        //--- Process each output row
                        //    Note: Output coordinates are relative to the lock region
                        const ULONG Height = SrcBnds.Height();
                        if (dwFlags & DXBOF_DITHER)
                        {
                            DXPMSAMPLE * pSrcDitherBuff = pSrcBuff;
                            if (pSrcDitherBuff == NULL)
                            {
                                pSrcDitherBuff = DXPMSAMPLE_Malloc(Width);
                                if( NULL == pSrcDitherBuff )
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }

                            if( SUCCEEDED( hr ) )
                            {
                                const BOOL bCopy = ((dwFlags & DXBOF_DO_OVER) == 0);
                                //
                                //  Set up the dither descriptor (some things are constant)
                                //
                                DXDITHERDESC dd;
                                dd.pSamples = pSrcDitherBuff;
                                dd.DestSurfaceFmt = OutNativeType;
                                for(ULONG Y = 0; Y < Height; ++Y )
                                {
                                    dd.x = DestBnds.Left();
                                    dd.y = DestBnds.Top() + Y;
                                    const DXRUNINFO *pRunInfo;
                                    ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                                    pOut->MoveToRow( Y );
                                    do
                                    {
                                        ULONG ulRunLen = pRunInfo->Count;
                                        if (pRunInfo->Type == DXRUNTYPE_CLEAR)
                                        {
                                            pIn->Move(ulRunLen);
                                            if (bCopy)
                                            {
                                                //
                                                //  The only way to avoid calling a constructor function to create
                                                //  a pmsample from 0 is to declare a variable and then assign it!
                                                //
                                                DXPMSAMPLE NullColor;
                                                NullColor = 0;
                                                pOut->FillAndMove(pSrcDitherBuff, NullColor, ulRunLen, FALSE);
                                            }
                                            else
                                            {
                                                pOut->Move(ulRunLen);
                                            }
                                            dd.x += ulRunLen;
                                        }
                                        else
                                        {
                                            pIn->UnpackPremult(pSrcDitherBuff, ulRunLen, TRUE);
                                            dd.cSamples = ulRunLen;
                                            DXDitherArray(&dd);
                                            dd.x += ulRunLen;
                                            if (bCopy || pRunInfo->Type == DXRUNTYPE_OPAQUE)
                                            {
                                                pOut->PackPremultAndMove(pSrcDitherBuff, ulRunLen);
                                            }
                                            else
                                            {
                                                pOut->OverArrayAndMove(pDestBuff, pSrcDitherBuff, ulRunLen);
                                            }
                                        }
                                        pRunInfo++;
                                        cRuns--;
                                    } while (cRuns);
                                }

                                // pSrcDitherBuff is originally initialized to pSrcBuff,
                                // so we only want to free the associated memory if it's
                                // pointing at a different chunk of memory than pSrcBuff
                                // as pSrcBuff will take care of freeing its own memory
                                // later on
                                if( NULL != pSrcDitherBuff && pSrcDitherBuff != pSrcBuff )
                                {
                                    free( pSrcDitherBuff );
                                    pSrcDitherBuff = NULL;
                                }

                            } // end of if( SUCCEEDED( hr ) ) for pSrcDitherBuff
                        }
                        else
                        {
                            for(ULONG Y = 0; Y < Height; ++Y )
                            {
                                const DXRUNINFO *pRunInfo;
                                ULONG cRuns = pIn->MoveAndGetRunInfo(Y, &pRunInfo);
                                pOut->MoveToRow( Y );
                                do
                                {
                                    ULONG ulRunLen = pRunInfo->Count;
                                    switch (pRunInfo->Type)
                                    {
                                      case DXRUNTYPE_CLEAR:
                                        pIn->Move(ulRunLen);
                                        pOut->Move(ulRunLen);
                                        break;
                                      case DXRUNTYPE_OPAQUE:
                                        pOut->CopyAndMoveBoth(pDestBuff, pIn, ulRunLen, TRUE);
                                        break;
                                      case DXRUNTYPE_TRANS:
                                      {
                                        DXPMSAMPLE *pSrc = pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE);
                                        DXPMSAMPLE *pDest = pOut->UnpackPremult(pDestBuff, ulRunLen, FALSE);                 
                                        DXOverArrayMMX(pDest, pSrc, ulRunLen);
                                        pOut->PackPremultAndMove(pDestBuff, ulRunLen);
                                        break;
                                      }

                                      case DXRUNTYPE_UNKNOWN:
                                      {
                                        pOut->OverArrayAndMove(pDestBuff,
                                                               pIn->UnpackPremult(pSrcBuff, ulRunLen, TRUE),
                                                               ulRunLen);
                                        break;
                                      }
                                    }
                                    pRunInfo++;
                                    cRuns--;
                                } while (cRuns);
                            }
                        }

                        if( NULL != pDestBuff )
                        {
                            free( pDestBuff );
                            pDestBuff = NULL;
                        }
                    }
                }
                else // if ((dwFlags & DXBOF_DITHER) || ((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque== 0))
                {
                    // This code is run if:
                    //
                    // !(dwFlags & DXBOF_DITHER) 
                    // && !((dwFlags & DXBOF_DO_OVER) && bSrcIsOpaque == 0)
                    //
                    // In English:
                    //
                    // This code is run if 1) dithering is not required
                    // and 2) blending with output is not required because it was
                    // not requested or because it's not needed because the source
                    // pixels are all opaque.

                    // hrDD is initialized to failure so that in the event that the
                    // pixel formats don't match or the pixel format supports
                    // transparency, the CopyRect will still run.

                    HRESULT             hrDD        = E_FAIL;
                    DXSAMPLEFORMATENUM  formatIn    = pIn->GetNativeType(NULL);

                    // If the pixel formats match and do not support transparency
                    // (because it's not supported by ddraw yet) try to use a 
                    // ddraw blit instead of CopyRect.

                    if ((formatIn == pOut->GetNativeType(NULL))
                        && !(formatIn & DXPF_TRANSPARENCY))
                    {
                        CComPtr<IDirectDrawSurface> cpDDSrc;

                        // Get source ddraw surface pointer.

                        hrDD = pSrc->QueryInterface(IID_IDirectDrawSurface, 
                                                    (void **)&cpDDSrc);

                        if (SUCCEEDED(hrDD))
                        {
                            CComPtr<IDirectDrawSurface> cpDDDest;

                            // Get destination ddraw surface pointer.

                            hrDD = pDest->QueryInterface(IID_IDirectDrawSurface, 
                                                         (void **)&cpDDDest);

                            if (SUCCEEDED(hrDD))
                            {
                                RECT rcSrc;
                                RECT rcDest;

                                SrcBnds.GetXYRect(rcSrc);
                                DestBnds.GetXYRect(rcDest);

                                // Attempt the ddraw blit.

                                hrDD = cpDDDest->Blt(&rcDest, cpDDSrc, &rcSrc, 
                                                     0, NULL);
                            }
                        }
                    }

                    // If hrDD has failed at this point, it means a direct draw blit
                    // was not possible and a CopyRect is needed to perform the 
                    // copy.

                    if (FAILED(hrDD))
                    {
                        pOut->CopyRect(pSrcBuff, NULL, pIn, NULL, bSrcIsOpaque);
                    }
                } // end of else

                if( NULL != pSrcBuff )
                {
                    free( pSrcBuff );
                    pSrcBuff = NULL;
                }
            }
            pOut->Release();
        } // end of if (SUCCEEDED(hr))for LockSurface for pOut
        pIn->Release();
    } // end of if(SUCCEEDED(hr)) for LockSurface for pIn
    return hr;
}

inline HRESULT DXSrcCopy(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, 
                         IDXSurface *pSrcSurface, int nXSrc, int nYSrc)
{
    IDXDCLock *pDCLock;
    HRESULT hr = pSrcSurface->LockSurfaceDC(NULL, INFINITE, DXLOCKF_READ, &pDCLock);
    if (SUCCEEDED(hr))
    {
        ::BitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, pDCLock->GetDC(), nXSrc, nYSrc, SRCCOPY);
        pDCLock->Release();
    }
    return hr;
}
//
//=== Pointer validation functions
//
inline BOOL DXIsBadReadPtr( const void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadReadPtr( pMem, Size );
#endif
}

inline BOOL DXIsBadWritePtr( void* pMem, UINT Size )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ::IsBadWritePtr( pMem, Size );
#endif
}


inline BOOL DXIsBadInterfacePtr( const IUnknown* pUnknown )
{
#if !defined( _DEBUG ) && defined( DXTRANS_NOROBUST )
    return false;
#else
    return ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
             ::IsBadCodePtr( (FARPROC)((void **)pUnknown)[0] ))?
            (true):(false);
#endif
}

#define DX_IS_BAD_OPTIONAL_WRITE_PTR(p) ((p) && DXIsBadWritePtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_READ_PTR(p) ((p) && DXIsBadReadPtr(p, sizeof(p)))
#define DX_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && DXIsBadInterfacePtr(p))


#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxsurfb.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXSurfB.h *
*----------*
*   Description:
*       This is the header file for the CDXBaseSurface implementation. It is
*   used as a base class to implement read-only procedural DXSurfaces.
*-------------------------------------------------------------------------------
*  Created By: RAL                                  Date: 02/12/1998
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

#ifndef __DXSurfB_H__
#define __DXSurfB_H__

#include "dtbase.h"

class CDXBaseSurface;
class CDXBaseARGBPtr;

class ATL_NO_VTABLE CDXBaseSurface :
    public CDXBaseNTo1, 
    public IDXSurface,
    public IDXSurfaceInit
{
    /*=== ATL Setup ===*/
    public:
        BEGIN_COM_MAP(CDXBaseSurface)
        COM_INTERFACE_ENTRY(IDXSurface)
        COM_INTERFACE_ENTRY(IDXSurfaceInit)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
        END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

    /*=== Member Data ===*/
    public:
        ULONG           m_Height;
        ULONG           m_Width;
        DWORD           m_dwStatusFlags;
        HANDLE          m_hSemaphore;
        ULONG           m_ulLocks;
        ULONG           m_ulThreadsWaiting;
        CDXBaseARGBPtr  *m_pFreePtr;
        DWORD_PTR       m_dwAppData;
        CComAutoCriticalSection m_MPWorkProcCrit;   // See comments in LockSurface for details

        CDXBaseSurface();
        HRESULT FinalConstruct();
        void FinalRelease();

        //
        //  IDXBaseObject
        //
        STDMETHODIMP GetGenerationId(ULONG *pGenId);
        STDMETHODIMP IncrementGenerationId(BOOL bRefresh);
        STDMETHODIMP GetObjectSize(ULONG *pulze);

        //
        //  Overridden methods of DXTransform
        //
        STDMETHODIMP MapBoundsIn2Out(const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                     ULONG /*ulOutIndex*/, DXBNDS *pOutBounds );

        //
        //  IDXSurfaceInit
        //
        STDMETHODIMP InitSurface(IUnknown *pDirectDraw,
                                 const DDSURFACEDESC * pDDSurfaceDesc,
                                 const GUID * pFormatId,
                                 const DXBNDS *pBounds,
                                 DWORD dwFlags);
        //
        //  IDXSurface methods
        //
        STDMETHODIMP GetPixelFormat(GUID *pFormat, DXSAMPLEFORMATENUM *pSampleEnum);
        STDMETHODIMP GetBounds(DXBNDS *pBounds);
        STDMETHODIMP GetStatusFlags(DWORD * pdwStatusFlags);
        STDMETHODIMP SetStatusFlags(DWORD dwStatusFlags);
        STDMETHODIMP GetDirectDrawSurface(REFIID riid, void **ppSurface);
        STDMETHODIMP LockSurface(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags,
                                 REFIID riid, void **ppPointer, DWORD * pGenerationId);
        STDMETHODIMP SetAppData(DWORD_PTR dwAppData)
        {
            m_dwAppData = dwAppData;
            return S_OK;
        }
        STDMETHODIMP GetAppData(DWORD_PTR *pdwAppData)
        {
            if (DXIsBadWritePtr(pdwAppData, sizeof(*pdwAppData)))
            {
                return E_POINTER;
            }
            *pdwAppData = m_dwAppData;
            return S_OK;
        }


        //
        //  These methods aren't supported by procedural surfaces...
        //
        STDMETHODIMP GetColorKey(DXSAMPLE *pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP SetColorKey(DXSAMPLE pColorKey)
        {
            return E_NOTIMPL;
        }

        STDMETHODIMP LockSurfaceDC(const DXBNDS *pBounds, ULONG ulTimeOut, DWORD dwFlags, IDXDCLock **ppDXLock)
        {
            return E_NOTIMPL;
        }

        //
        //  Surfaces should override this.
        //
        virtual ULONG OnGetObjectSize(void) { return sizeof(*this); }

        //
        //  This work procedure can be overridden by the derived class to improve performance
        //  or execution of the transform by directly producing data in large blocks if desired.
        //
        virtual HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
        {
            return DXBitBlt(OutputSurface(), WI.OutputBnds, this, WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
        }

        //
        //  Pick interface needs to test procedural surface.
        //
        virtual HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, CDXDVec & InVec);

        //
        //  Helper functions
        //

        //  _EnterCritWith0PtrLocks()
        //
        //  This function is similar to calling Lock() except that it will wait until there
        //  are no pointers to the surface before returning.  This should be used whenever you
        //  are going to change the state of a surface, for example the size or some other
        //  property that the read pointers rely on.
        //
        //  WARNING:  You must be sure that one of the following is true:
        //      1) The objects critical section has NOT been taken prior to calling this function
        //   or 2) There are no pointers to the surface taken prior to calling this function.
        //
        //  Case 2 is useful in nested function calls.  If the outer function has already used this
        //  function to enter the critical section, then it is OK to use it on the inner nested
        //  function.  If the object's lock is taken, but there are outstanding pointers, YOU WILL DEADLOCK!
        //
        inline void _EnterCritWith0PtrLocks(void)
        {
            while (TRUE)
            {
                Lock();
                if (m_ulLocks == 0) break;
                m_ulThreadsWaiting++;
                Unlock();
                WaitForSingleObject(m_hSemaphore, INFINITE);
            }
        }
        //
        //  Virtual functions derived class MUST override
        //
        virtual const GUID & SurfaceCLSID() = 0;
        virtual HRESULT CreateARGBPointer(CDXBaseSurface * pSurface, CDXBaseARGBPtr ** ppPtr) = 0;
        virtual void DeleteARGBPointer(CDXBaseARGBPtr *pPtr) = 0;
    
        //
        //  Class may override this virtual function to return a more accurate enum
        //  for example, no transparency or translucency.
        //
        virtual DXSAMPLEFORMATENUM SampleFormatEnum()
        {
            return (DXSAMPLEFORMATENUM)(DXPF_NONSTANDARD | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY);
        }

        //
        //  Class may override this virtual function to perform necessary computations
        //  when the size of the surface changes.  The base class will only call this
        //  function from InitSurface.  You may choose to call it from other interfaces
        //  you implement, for example IDXTScaleOutput.
        //
        //  This function will be called with the critical section taken and 0 outstanding
        //  surface pointers (_EnterCritWith0PtrLocks).
        //  
        virtual HRESULT OnSetSize(ULONG Width, ULONG Height)
        {
            if (m_Width != Width || m_Height != Height)
            {
                m_Width = Width;
                m_Height = Height;
                m_dwGenerationId++;
            }
            return S_OK;
        }

        //
        //  Internal functions for base class
        //
        void _InternalUnlock(CDXBaseARGBPtr *pPtrToUnlock);

        //
        //  Static member function for registering surface
        //
        static HRESULT RegisterSurface(REFCLSID rcid, int ResourceId, ULONG cCatImpl, const CATID * pCatImpl,
                                       ULONG cCatReq, const CATID * pCatReq, BOOL bRegister);
};

struct DXPtrFillInfo
{
    DXBASESAMPLE *  pSamples;
    ULONG           cSamples;
    ULONG           x;
    ULONG           y;
    BOOL            bPremult;
};


class CDXBaseARGBPtr : public IDXARGBReadPtr
{
public:
    CDXBaseARGBPtr    * m_pNext;
    CDXBaseSurface    * m_pSurface;
    ULONG               m_ulRefCount;
    DXPtrFillInfo       m_FillInfo;
    RECT                m_LockedRect;
    DXRUNINFO           m_RunInfo;
    
    CDXBaseARGBPtr(CDXBaseSurface *pSurface) :
        m_pSurface(pSurface),
        m_pNext(NULL),
        m_ulRefCount(0) {}

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    //
    //  IDXARGBReadPtr
    //
    HRESULT STDMETHODCALLTYPE GetSurface(REFIID riid, void **ppSurface);
    DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType(DXNATIVETYPEINFO *pInfo);
    void STDMETHODCALLTYPE Move(long cSamples);
    void STDMETHODCALLTYPE MoveToRow(ULONG y);
    void STDMETHODCALLTYPE MoveToXY(ULONG x, ULONG y);
    ULONG STDMETHODCALLTYPE MoveAndGetRunInfo(ULONG Row, const DXRUNINFO ** ppInfo);
    DXSAMPLE *STDMETHODCALLTYPE Unpack(DXSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    DXPMSAMPLE *STDMETHODCALLTYPE UnpackPremult(DXPMSAMPLE *pSamples, ULONG cSamples, BOOL bMove);
    void STDMETHODCALLTYPE UnpackRect(const DXPACKEDRECTDESC *pDesc);

    //
    //  Virtual function derived class MUST override
    //
    virtual void FillSamples(const DXPtrFillInfo & FillInfo) = 0;

    //
    //  Virtual functions derived class MAY want to override (but you will need to call the base class too)
    //
    virtual HRESULT InitFromLock(const RECT & rect, ULONG ulTimeOut, DWORD dwLockFlags, REFIID riid, void ** ppv);
};

//=== Macro Definitions ============================================

#define DECLARE_REGISTER_DX_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[2]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 2, cat, 0, NULL, bRegister); \
        } 

#define DECLARE_REGISTER_DX_AUTHORING_SURFACE(id)\
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
        { \
            CATID cat[3]; \
            cat[0] = CATID_DXSurface; \
            cat[1] = CATID_DXImageTransform; \
            cat[2] = CATID_DXAuthoringTransform; \
            return RegisterSurface(GetObjectCLSID(), (id), 3, cat, 0, NULL, bRegister); \
        } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtdbg.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtguid.c ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxterror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtmpl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

#ifndef PASCAL_INLINE
#ifdef _M_CEE_PURE
#define PASCAL_INLINE  __clrcall
#else
#define PASCAL_INLINE  PASCAL
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL_INLINE Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
	if ((nMax * cbElement) > (SIZE_MAX - sizeof(CDXPlex)))
	    return NULL;
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        if (p == NULL)
            return NULL;
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete [] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // oh well, it's better than crashing
        if (pNewData == NULL)
            return;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];

            // oh well, it's better than crashing
            if (pNewData == NULL)
                return;

            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];

        // oh well, it's better than crashing
        if (m_pHashTable == NULL)
            return;

        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtmsft3guid.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:26 2007
 */
/* Compiler settings for ..\dxtmsft3.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:26 2007
 */
/* Compiler settings for ..\dxtmsft3.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtrans.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Tue Mar 20 13:59:31 2007
 */
/* Compiler settings for ..\dxtrans.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtrans_h__
#define __dxtrans_h__

/* Forward Declarations */ 

#ifndef __IDXBaseObject_FWD_DEFINED__
#define __IDXBaseObject_FWD_DEFINED__
typedef interface IDXBaseObject IDXBaseObject;
#endif 	/* __IDXBaseObject_FWD_DEFINED__ */


#ifndef __IDXTransformFactory_FWD_DEFINED__
#define __IDXTransformFactory_FWD_DEFINED__
typedef interface IDXTransformFactory IDXTransformFactory;
#endif 	/* __IDXTransformFactory_FWD_DEFINED__ */


#ifndef __IDXTransform_FWD_DEFINED__
#define __IDXTransform_FWD_DEFINED__
typedef interface IDXTransform IDXTransform;
#endif 	/* __IDXTransform_FWD_DEFINED__ */


#ifndef __IDXSurfacePick_FWD_DEFINED__
#define __IDXSurfacePick_FWD_DEFINED__
typedef interface IDXSurfacePick IDXSurfacePick;
#endif 	/* __IDXSurfacePick_FWD_DEFINED__ */


#ifndef __IDXTBindHost_FWD_DEFINED__
#define __IDXTBindHost_FWD_DEFINED__
typedef interface IDXTBindHost IDXTBindHost;
#endif 	/* __IDXTBindHost_FWD_DEFINED__ */


#ifndef __IDXTaskManager_FWD_DEFINED__
#define __IDXTaskManager_FWD_DEFINED__
typedef interface IDXTaskManager IDXTaskManager;
#endif 	/* __IDXTaskManager_FWD_DEFINED__ */


#ifndef __IDXSurfaceFactory_FWD_DEFINED__
#define __IDXSurfaceFactory_FWD_DEFINED__
typedef interface IDXSurfaceFactory IDXSurfaceFactory;
#endif 	/* __IDXSurfaceFactory_FWD_DEFINED__ */


#ifndef __IDXSurfaceModifier_FWD_DEFINED__
#define __IDXSurfaceModifier_FWD_DEFINED__
typedef interface IDXSurfaceModifier IDXSurfaceModifier;
#endif 	/* __IDXSurfaceModifier_FWD_DEFINED__ */


#ifndef __IDXSurface_FWD_DEFINED__
#define __IDXSurface_FWD_DEFINED__
typedef interface IDXSurface IDXSurface;
#endif 	/* __IDXSurface_FWD_DEFINED__ */


#ifndef __IDXSurfaceInit_FWD_DEFINED__
#define __IDXSurfaceInit_FWD_DEFINED__
typedef interface IDXSurfaceInit IDXSurfaceInit;
#endif 	/* __IDXSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_FWD_DEFINED__
#define __IDXARGBSurfaceInit_FWD_DEFINED__
typedef interface IDXARGBSurfaceInit IDXARGBSurfaceInit;
#endif 	/* __IDXARGBSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBReadPtr_FWD_DEFINED__
#define __IDXARGBReadPtr_FWD_DEFINED__
typedef interface IDXARGBReadPtr IDXARGBReadPtr;
#endif 	/* __IDXARGBReadPtr_FWD_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_FWD_DEFINED__
#define __IDXARGBReadWritePtr_FWD_DEFINED__
typedef interface IDXARGBReadWritePtr IDXARGBReadWritePtr;
#endif 	/* __IDXARGBReadWritePtr_FWD_DEFINED__ */


#ifndef __IDXDCLock_FWD_DEFINED__
#define __IDXDCLock_FWD_DEFINED__
typedef interface IDXDCLock IDXDCLock;
#endif 	/* __IDXDCLock_FWD_DEFINED__ */


#ifndef __IDXTScaleOutput_FWD_DEFINED__
#define __IDXTScaleOutput_FWD_DEFINED__
typedef interface IDXTScaleOutput IDXTScaleOutput;
#endif 	/* __IDXTScaleOutput_FWD_DEFINED__ */


#ifndef __IDXGradient_FWD_DEFINED__
#define __IDXGradient_FWD_DEFINED__
typedef interface IDXGradient IDXGradient;
#endif 	/* __IDXGradient_FWD_DEFINED__ */


#ifndef __IDXTScale_FWD_DEFINED__
#define __IDXTScale_FWD_DEFINED__
typedef interface IDXTScale IDXTScale;
#endif 	/* __IDXTScale_FWD_DEFINED__ */


#ifndef __IDXEffect_FWD_DEFINED__
#define __IDXEffect_FWD_DEFINED__
typedef interface IDXEffect IDXEffect;
#endif 	/* __IDXEffect_FWD_DEFINED__ */


#ifndef __IDXLookupTable_FWD_DEFINED__
#define __IDXLookupTable_FWD_DEFINED__
typedef interface IDXLookupTable IDXLookupTable;
#endif 	/* __IDXLookupTable_FWD_DEFINED__ */


#ifndef __IDXRawSurface_FWD_DEFINED__
#define __IDXRawSurface_FWD_DEFINED__
typedef interface IDXRawSurface IDXRawSurface;
#endif 	/* __IDXRawSurface_FWD_DEFINED__ */


#ifndef __IHTMLDXTransform_FWD_DEFINED__
#define __IHTMLDXTransform_FWD_DEFINED__
typedef interface IHTMLDXTransform IHTMLDXTransform;
#endif 	/* __IHTMLDXTransform_FWD_DEFINED__ */


#ifndef __IObjectWithBehaviorSite_FWD_DEFINED__
#define __IObjectWithBehaviorSite_FWD_DEFINED__
typedef interface IObjectWithBehaviorSite IObjectWithBehaviorSite;
#endif 	/* __IObjectWithBehaviorSite_FWD_DEFINED__ */


#ifndef __ICSSFilterDispatch_FWD_DEFINED__
#define __ICSSFilterDispatch_FWD_DEFINED__
typedef interface ICSSFilterDispatch ICSSFilterDispatch;
#endif 	/* __ICSSFilterDispatch_FWD_DEFINED__ */


#ifndef __DXTransformFactory_FWD_DEFINED__
#define __DXTransformFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTransformFactory DXTransformFactory;
#else
typedef struct DXTransformFactory DXTransformFactory;
#endif /* __cplusplus */

#endif 	/* __DXTransformFactory_FWD_DEFINED__ */


#ifndef __DXTaskManager_FWD_DEFINED__
#define __DXTaskManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTaskManager DXTaskManager;
#else
typedef struct DXTaskManager DXTaskManager;
#endif /* __cplusplus */

#endif 	/* __DXTaskManager_FWD_DEFINED__ */


#ifndef __DXTScale_FWD_DEFINED__
#define __DXTScale_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTScale DXTScale;
#else
typedef struct DXTScale DXTScale;
#endif /* __cplusplus */

#endif 	/* __DXTScale_FWD_DEFINED__ */


#ifndef __DXSurface_FWD_DEFINED__
#define __DXSurface_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurface DXSurface;
#else
typedef struct DXSurface DXSurface;
#endif /* __cplusplus */

#endif 	/* __DXSurface_FWD_DEFINED__ */


#ifndef __DXSurfaceModifier_FWD_DEFINED__
#define __DXSurfaceModifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurfaceModifier DXSurfaceModifier;
#else
typedef struct DXSurfaceModifier DXSurfaceModifier;
#endif /* __cplusplus */

#endif 	/* __DXSurfaceModifier_FWD_DEFINED__ */


#ifndef __DXGradient_FWD_DEFINED__
#define __DXGradient_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXGradient DXGradient;
#else
typedef struct DXGradient DXGradient;
#endif /* __cplusplus */

#endif 	/* __DXGradient_FWD_DEFINED__ */


#ifndef __DXTFilter_FWD_DEFINED__
#define __DXTFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilter DXTFilter;
#else
typedef struct DXTFilter DXTFilter;
#endif /* __cplusplus */

#endif 	/* __DXTFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "servprov.h"
#include "comcat.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtrans_0000 */
/* [local] */ 

#include <servprov.h>
#include <ddraw.h>
#include <urlmon.h>
#if 0
// Bogus definition used to make MIDL compiler happy
typedef void DDSURFACEDESC;

typedef void D3DRMBOX;

typedef void D3DVECTOR;

typedef void D3DRMMATRIX4D;

typedef void __RPC_FAR *LPSECURITY_ATTRIBUTES;

#endif
#ifdef _DXTRANSIMPL
    #define _DXTRANS_IMPL_EXT _declspec(dllexport)
#else
    #define _DXTRANS_IMPL_EXT _declspec(dllimport)
#endif
















//
//   All GUIDs for DXTransform are declared in DXTGUID.C in the SDK include directory
//
EXTERN_C const GUID DDPF_RGB1;
EXTERN_C const GUID DDPF_RGB2;
EXTERN_C const GUID DDPF_RGB4;
EXTERN_C const GUID DDPF_RGB8;
EXTERN_C const GUID DDPF_RGB332;
EXTERN_C const GUID DDPF_ARGB4444;
EXTERN_C const GUID DDPF_RGB565;
EXTERN_C const GUID DDPF_BGR565;
EXTERN_C const GUID DDPF_RGB555;
EXTERN_C const GUID DDPF_ARGB1555;
EXTERN_C const GUID DDPF_RGB24;
EXTERN_C const GUID DDPF_BGR24;
EXTERN_C const GUID DDPF_RGB32;
EXTERN_C const GUID DDPF_BGR32;
EXTERN_C const GUID DDPF_ABGR32;
EXTERN_C const GUID DDPF_ARGB32;
EXTERN_C const GUID DDPF_PMARGB32;
EXTERN_C const GUID DDPF_A1;
EXTERN_C const GUID DDPF_A2;
EXTERN_C const GUID DDPF_A4;
EXTERN_C const GUID DDPF_A8;
EXTERN_C const GUID DDPF_Z8;
EXTERN_C const GUID DDPF_Z16;
EXTERN_C const GUID DDPF_Z24;
EXTERN_C const GUID DDPF_Z32;
//
//   Component categories
//
EXTERN_C const GUID CATID_DXImageTransform;
EXTERN_C const GUID CATID_DX3DTransform;
EXTERN_C const GUID CATID_DXAuthoringTransform;
EXTERN_C const GUID CATID_DXSurface;
//
//   Service IDs
//
EXTERN_C const GUID SID_SDirectDraw;
EXTERN_C const GUID SID_SDirect3DRM;
#define SID_SDXTaskManager CLSID_DXTaskManager
#define SID_SDXSurfaceFactory IID_IDXSurfaceFactory
#define SID_SDXTransformFactory IID_IDXTransformFactory
//
//   DXTransforms Core Type Library Version Info
//
#define DXTRANS_TLB_MAJOR_VER 1
#define DXTRANS_TLB_MINOR_VER 1


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_s_ifspec;

#ifndef __IDXBaseObject_INTERFACE_DEFINED__
#define __IDXBaseObject_INTERFACE_DEFINED__

/* interface IDXBaseObject */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17B59B2B-9CC8-11d1-9053-00C04FD9189D")
    IDXBaseObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGenerationId( 
            /* [out] */ ULONG __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncrementGenerationId( 
            /* [in] */ BOOL bRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        END_INTERFACE
    } IDXBaseObjectVtbl;

    interface IDXBaseObject
    {
        CONST_VTBL struct IDXBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBaseObject_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXBaseObject_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXBaseObject_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXBaseObject_GetGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pID);


void __RPC_STUB IDXBaseObject_GetGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_IncrementGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [in] */ BOOL bRefresh);


void __RPC_STUB IDXBaseObject_IncrementGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_GetObjectSize_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IDXBaseObject_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBaseObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0165 */
/* [local] */ 

typedef 
enum DXBNDID
    {	DXB_X	= 0,
	DXB_Y	= 1,
	DXB_Z	= 2,
	DXB_T	= 3
    }	DXBNDID;

typedef 
enum DXBNDTYPE
    {	DXBT_DISCRETE	= 0,
	DXBT_DISCRETE64	= DXBT_DISCRETE + 1,
	DXBT_CONTINUOUS	= DXBT_DISCRETE64 + 1,
	DXBT_CONTINUOUS64	= DXBT_CONTINUOUS + 1
    }	DXBNDTYPE;

typedef struct DXDBND
    {
    long Min;
    long Max;
    }	DXDBND;

typedef DXDBND __RPC_FAR DXDBNDS[ 4 ];

typedef struct DXDBND64
    {
    LONGLONG Min;
    LONGLONG Max;
    }	DXDBND64;

typedef DXDBND64 __RPC_FAR DXDBNDS64[ 4 ];

typedef struct DXCBND
    {
    float Min;
    float Max;
    }	DXCBND;

typedef DXCBND __RPC_FAR DXCBNDS[ 4 ];

typedef struct DXCBND64
    {
    double Min;
    double Max;
    }	DXCBND64;

typedef DXCBND64 __RPC_FAR DXCBNDS64[ 4 ];

typedef struct DXBNDS
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0165_0001
        {
        /* [case()] */ DXDBND D[ 4 ];
        /* [case()] */ DXDBND64 LD[ 4 ];
        /* [case()] */ DXCBND C[ 4 ];
        /* [case()] */ DXCBND64 LC[ 4 ];
        }	u;
    }	DXBNDS;

typedef long __RPC_FAR DXDVEC[ 4 ];

typedef LONGLONG __RPC_FAR DXDVEC64[ 4 ];

typedef float __RPC_FAR DXCVEC[ 4 ];

typedef double __RPC_FAR DXCVEC64[ 4 ];

typedef struct DXVEC
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0165_0002
        {
        /* [case()] */ long D[ 4 ];
        /* [case()] */ LONGLONG LD[ 4 ];
        /* [case()] */ float C[ 4 ];
        /* [case()] */ double LC[ 4 ];
        }	u;
    }	DXVEC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0165_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0165_v0_0_s_ifspec;

#ifndef __IDXTransformFactory_INTERFACE_DEFINED__
#define __IDXTransformFactory_INTERFACE_DEFINED__

/* interface IDXTransformFactory */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTransformFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A950B2B-A971-11d1-81C8-0000F87557DB")
    IDXTransformFactory : public IServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTransform( 
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeTransform( 
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransformFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransformFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog);
        
        END_INTERFACE
    } IDXTransformFactoryVtbl;

    interface IDXTransformFactory
    {
        CONST_VTBL struct IDXTransformFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransformFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransformFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransformFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransformFactory_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)


#define IDXTransformFactory_SetService(This,guidService,pUnkService,bWeakReference)	\
    (This)->lpVtbl -> SetService(This,guidService,pUnkService,bWeakReference)

#define IDXTransformFactory_CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)	\
    (This)->lpVtbl -> CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)

#define IDXTransformFactory_InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)	\
    (This)->lpVtbl -> InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransformFactory_SetService_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ IUnknown __RPC_FAR *pUnkService,
    /* [in] */ BOOL bWeakReference);


void __RPC_STUB IDXTransformFactory_SetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_CreateTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog,
    /* [in] */ REFCLSID TransCLSID,
    /* [in] */ REFIID TransIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);


void __RPC_STUB IDXTransformFactory_CreateTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_InitializeTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ IDXTransform __RPC_FAR *pTransform,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog);


void __RPC_STUB IDXTransformFactory_InitializeTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransformFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0166 */
/* [local] */ 

typedef 
enum DXTMISCFLAGS
    {	DXTMF_BLEND_WITH_OUTPUT	= 1L << 0,
	DXTMF_DITHER_OUTPUT	= 1L << 1,
	DXTMF_OPTION_MASK	= 0xffff,
	DXTMF_VALID_OPTIONS	= DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT,
	DXTMF_BLEND_SUPPORTED	= 1L << 16,
	DXTMF_DITHER_SUPPORTED	= 1L << 17,
	DXTMF_INPLACE_OPERATION	= 1L << 24,
	DXTMF_BOUNDS_SUPPORTED	= 1L << 25,
	DXTMF_PLACEMENT_SUPPORTED	= 1L << 26,
	DXTMF_QUALITY_SUPPORTED	= 1L << 27,
	DXTMF_OPAQUE_RESULT	= 1L << 28
    }	DXTMISCFLAGS;

typedef 
enum DXINOUTINFOFLAGS
    {	DXINOUTF_OPTIONAL	= 1L << 0
    }	DXINOUTINFOFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0166_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0166_v0_0_s_ifspec;

#ifndef __IDXTransform_INTERFACE_DEFINED__
#define __IDXTransform_INTERFACE_DEFINED__

/* interface IDXTransform */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB78-E11F-11d1-9064-00C04FD9189D")
    IDXTransform : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Setup( 
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMiscFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInOutInfo( 
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ float fQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ float __RPC_FAR *fQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransform __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransform __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Setup )( 
            IDXTransform __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsIn2Out )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsOut2In )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInOutInfo )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ float fQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *fQuality);
        
        END_INTERFACE
    } IDXTransformVtbl;

    interface IDXTransform
    {
        CONST_VTBL struct IDXTransformVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransform_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXTransform_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXTransform_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXTransform_Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)	\
    (This)->lpVtbl -> Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)

#define IDXTransform_Execute(This,pRequestID,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> Execute(This,pRequestID,pClipBnds,pPlacement)

#define IDXTransform_MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)

#define IDXTransform_MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)

#define IDXTransform_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTransform_GetMiscFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetMiscFlags(This,pdwMiscFlags)

#define IDXTransform_GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)	\
    (This)->lpVtbl -> GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)

#define IDXTransform_SetQuality(This,fQuality)	\
    (This)->lpVtbl -> SetQuality(This,fQuality)

#define IDXTransform_GetQuality(This,fQuality)	\
    (This)->lpVtbl -> GetQuality(This,fQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransform_Setup_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTransform_Setup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_Execute_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *pRequestID,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTransform_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsIn2Out_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
    /* [in] */ ULONG ulNumInBnds,
    /* [in] */ ULONG ulOutIndex,
    /* [out] */ DXBNDS __RPC_FAR *pOutBounds);


void __RPC_STUB IDXTransform_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsOut2In_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ ULONG ulOutIndex,
    /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
    /* [in] */ ULONG ulInIndex,
    /* [out] */ DXBNDS __RPC_FAR *pInBounds);


void __RPC_STUB IDXTransform_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTransform_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);


void __RPC_STUB IDXTransform_GetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetInOutInfo_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ BOOL bIsOutput,
    /* [in] */ ULONG ulIndex,
    /* [out] */ DWORD __RPC_FAR *pdwFlags,
    /* [size_is][out] */ GUID __RPC_FAR *pIDs,
    /* [out][in] */ ULONG __RPC_FAR *pcIDs,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);


void __RPC_STUB IDXTransform_GetInOutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ float fQuality);


void __RPC_STUB IDXTransform_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *fQuality);


void __RPC_STUB IDXTransform_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransform_INTERFACE_DEFINED__ */


#ifndef __IDXSurfacePick_INTERFACE_DEFINED__
#define __IDXSurfacePick_INTERFACE_DEFINED__

/* interface IDXSurfacePick */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXSurfacePick;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB79-E11F-11d1-9064-00C04FD9189D")
    IDXSurfacePick : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PointPick( 
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfacePickVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfacePick __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfacePick __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PointPick )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint);
        
        END_INTERFACE
    } IDXSurfacePickVtbl;

    interface IDXSurfacePick
    {
        CONST_VTBL struct IDXSurfacePickVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfacePick_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfacePick_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfacePick_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfacePick_PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)	\
    (This)->lpVtbl -> PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfacePick_PointPick_Proxy( 
    IDXSurfacePick __RPC_FAR * This,
    /* [in] */ const DXVEC __RPC_FAR *pPoint,
    /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
    /* [out] */ DXVEC __RPC_FAR *pInputPoint);


void __RPC_STUB IDXSurfacePick_PointPick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfacePick_INTERFACE_DEFINED__ */


#ifndef __IDXTBindHost_INTERFACE_DEFINED__
#define __IDXTBindHost_INTERFACE_DEFINED__

/* interface IDXTBindHost */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D26BCE55-E9DC-11d1-9066-00C04FD9189D")
    IDXTBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBindHost( 
            /* [in] */ IBindHost __RPC_FAR *pBindHost) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBindHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBindHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBindHost )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ IBindHost __RPC_FAR *pBindHost);
        
        END_INTERFACE
    } IDXTBindHostVtbl;

    interface IDXTBindHost
    {
        CONST_VTBL struct IDXTBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBindHost_SetBindHost(This,pBindHost)	\
    (This)->lpVtbl -> SetBindHost(This,pBindHost)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTBindHost_SetBindHost_Proxy( 
    IDXTBindHost __RPC_FAR * This,
    /* [in] */ IBindHost __RPC_FAR *pBindHost);


void __RPC_STUB IDXTBindHost_SetBindHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0169 */
/* [local] */ 

typedef void __stdcall __stdcall DXTASKPROC( 
    void __RPC_FAR *pTaskData,
    BOOL __RPC_FAR *pbContinueProcessing);

typedef DXTASKPROC __RPC_FAR *PFNDXTASKPROC;

typedef void __stdcall __stdcall DXAPCPROC( 
    DWORD dwData);

typedef DXAPCPROC __RPC_FAR *PFNDXAPCPROC;

#ifdef __cplusplus
typedef struct DXTMTASKINFO
{
    PFNDXTASKPROC pfnTaskProc;       // Pointer to function to execute
    PVOID         pTaskData;         // Pointer to argument data
    PFNDXAPCPROC  pfnCompletionAPC;  // Pointer to completion APC proc
    DWORD         dwCompletionData;  // Pointer to APC proc data
    const GUID*   pRequestID;        // Used to identify groups of tasks
} DXTMTASKINFO;
#else
typedef struct DXTMTASKINFO
    {
    PVOID pfnTaskProc;
    PVOID pTaskData;
    PVOID pfnCompletionAPC;
    DWORD dwCompletionData;
    const GUID __RPC_FAR *pRequestID;
    }	DXTMTASKINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0169_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0169_v0_0_s_ifspec;

#ifndef __IDXTaskManager_INTERFACE_DEFINED__
#define __IDXTaskManager_INTERFACE_DEFINED__

/* interface IDXTaskManager */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("254DBBC1-F922-11d0-883A-3C8B00C10000")
    IDXTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNumProcessors( 
            /* [out] */ ULONG __RPC_FAR *pulNumProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadPoolSize( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadPoolSize( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConcurrencyLimit( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcurrencyLimit( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleTasks( 
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateTasks( 
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateRequest( 
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTaskManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTaskManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNumProcessors )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumProc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScheduleTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateRequest )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut);
        
        END_INTERFACE
    } IDXTaskManagerVtbl;

    interface IDXTaskManager
    {
        CONST_VTBL struct IDXTaskManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTaskManager_QueryNumProcessors(This,pulNumProc)	\
    (This)->lpVtbl -> QueryNumProcessors(This,pulNumProc)

#define IDXTaskManager_SetThreadPoolSize(This,ulNumThreads)	\
    (This)->lpVtbl -> SetThreadPoolSize(This,ulNumThreads)

#define IDXTaskManager_GetThreadPoolSize(This,pulNumThreads)	\
    (This)->lpVtbl -> GetThreadPoolSize(This,pulNumThreads)

#define IDXTaskManager_SetConcurrencyLimit(This,ulNumThreads)	\
    (This)->lpVtbl -> SetConcurrencyLimit(This,ulNumThreads)

#define IDXTaskManager_GetConcurrencyLimit(This,pulNumThreads)	\
    (This)->lpVtbl -> GetConcurrencyLimit(This,pulNumThreads)

#define IDXTaskManager_ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)	\
    (This)->lpVtbl -> ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)

#define IDXTaskManager_TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)	\
    (This)->lpVtbl -> TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)

#define IDXTaskManager_TerminateRequest(This,RequestID,ulTimeOut)	\
    (This)->lpVtbl -> TerminateRequest(This,RequestID,ulTimeOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTaskManager_QueryNumProcessors_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumProc);


void __RPC_STUB IDXTaskManager_QueryNumProcessors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_ScheduleTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
    /* [in] */ HANDLE __RPC_FAR Events[  ],
    /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulNumTasks,
    /* [in] */ ULONG ulWaitPeriod);


void __RPC_STUB IDXTaskManager_ScheduleTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulCount,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateRequest_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ REFIID RequestID,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTaskManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0170 */
/* [local] */ 

#ifdef __cplusplus
/////////////////////////////////////////////////////

class DXBASESAMPLE;
class DXSAMPLE;
class DXPMSAMPLE;

/////////////////////////////////////////////////////

class DXBASESAMPLE
{
public:
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    DXBASESAMPLE() {}
    DXBASESAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
        Alpha(alpha),
        Red(red),
        Green(green),
        Blue(blue) {}
    DXBASESAMPLE(const DWORD val) { *this = (*(DXBASESAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXBASESAMPLE *)&val); }
}; // DXBASESAMPLE

/////////////////////////////////////////////////////

class DXSAMPLE : public DXBASESAMPLE
{
public:
    DXSAMPLE() {}
    DXSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXSAMPLE(const DWORD val) { *this = (*(DXSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXSAMPLE *)&val); }
    operator DXPMSAMPLE() const;
}; // DXSAMPLE

/////////////////////////////////////////////////////

class DXPMSAMPLE : public DXBASESAMPLE
{
public:
    DXPMSAMPLE() {}
    DXPMSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXPMSAMPLE(const DWORD val) { *this = (*(DXPMSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXPMSAMPLE *)&val); }
    operator DXSAMPLE() const;
}; // DXPMSAMPLE

//
// The following cast operators are to prevent a direct assignment of a DXSAMPLE to a DXPMSAMPLE
//
inline DXSAMPLE::operator DXPMSAMPLE() const { return *((DXPMSAMPLE *)this); }
inline DXPMSAMPLE::operator DXSAMPLE() const { return *((DXSAMPLE *)this); }
#else // !__cplusplus
typedef struct DXBASESAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXBASESAMPLE;

typedef struct DXSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXSAMPLE;

typedef struct DXPMSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXPMSAMPLE;

#endif // !__cplusplus
typedef 
enum DXRUNTYPE
    {	DXRUNTYPE_CLEAR	= 0,
	DXRUNTYPE_OPAQUE	= 1,
	DXRUNTYPE_TRANS	= 2,
	DXRUNTYPE_UNKNOWN	= 3
    }	DXRUNTYPE;

#define	DX_MAX_RUN_INFO_COUNT	( 128 )

// Ignore the definition used by MIDL for TLB generation
#if 0
typedef struct DXRUNINFO
    {
    ULONG Bitfields;
    }	DXRUNINFO;

#endif // 0
typedef struct DXRUNINFO
{
    ULONG   Type  : 2;   // Type
    ULONG   Count : 30;  // Number of samples in run
} DXRUNINFO;
typedef 
enum DXSFCREATE
    {	DXSF_FORMAT_IS_CLSID	= 1L << 0,
	DXSF_NO_LAZY_DDRAW_LOCK	= 1L << 1
    }	DXSFCREATE;

typedef 
enum DXBLTOPTIONS
    {	DXBOF_DO_OVER	= 1L << 0,
	DXBOF_DITHER	= 1L << 1
    }	DXBLTOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0170_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0170_v0_0_s_ifspec;

#ifndef __IDXSurfaceFactory_INTERFACE_DEFINED__
#define __IDXSurfaceFactory_INTERFACE_DEFINED__

/* interface IDXSurfaceFactory */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXSurfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("144946F5-C4D4-11d1-81D1-0000F87557DB")
    IDXSurfaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadImage( 
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadImageFromStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopySurfaceToNewFormat( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateD3DRMTexture( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BitBlt( 
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromDDSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImage )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImageFromStream )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopySurfaceToNewFormat )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateD3DRMTexture )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BitBlt )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceFactoryVtbl;

    interface IDXSurfaceFactory
    {
        CONST_VTBL struct IDXSurfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceFactory_CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)	\
    (This)->lpVtbl -> CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)

#define IDXSurfaceFactory_CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)	\
    (This)->lpVtbl -> CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)

#define IDXSurfaceFactory_BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)	\
    (This)->lpVtbl -> BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateFromDDSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImage_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ const LPWSTR pszFileName,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImageFromStream_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CopySurfaceToNewFormat_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pDestFormatID,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);


void __RPC_STUB IDXSurfaceFactory_CopySurfaceToNewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateD3DRMTexture_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);


void __RPC_STUB IDXSurfaceFactory_CreateD3DRMTexture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_BitBlt_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDest,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceFactory_BitBlt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0171 */
/* [local] */ 

typedef 
enum DXSURFMODCOMPOP
    {	DXSURFMOD_COMP_OVER	= 0,
	DXSURFMOD_COMP_ALPHA_MASK	= 1,
	DXSURFMOD_COMP_MAX_VALID	= 1
    }	DXSURFMODCOMPOP;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0171_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0171_v0_0_s_ifspec;

#ifndef __IDXSurfaceModifier_INTERFACE_DEFINED__
#define __IDXSurfaceModifier_INTERFACE_DEFINED__

/* interface IDXSurfaceModifier */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXSurfaceModifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B637-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceModifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE Color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBounds( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositeOperation( 
            /* [in] */ DXSURFMODCOMPOP CompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositeOperation( 
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForeground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float Opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pOpacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLookup( 
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLookup( 
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceModifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSAMPLE Color);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBounds )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSURFMODCOMPOP CompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ float Opacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pOpacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);
        
        END_INTERFACE
    } IDXSurfaceModifierVtbl;

    interface IDXSurfaceModifier
    {
        CONST_VTBL struct IDXSurfaceModifierVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceModifier_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceModifier_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceModifier_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceModifier_SetFillColor(This,Color)	\
    (This)->lpVtbl -> SetFillColor(This,Color)

#define IDXSurfaceModifier_GetFillColor(This,pColor)	\
    (This)->lpVtbl -> GetFillColor(This,pColor)

#define IDXSurfaceModifier_SetBounds(This,pBounds)	\
    (This)->lpVtbl -> SetBounds(This,pBounds)

#define IDXSurfaceModifier_SetBackground(This,pSurface)	\
    (This)->lpVtbl -> SetBackground(This,pSurface)

#define IDXSurfaceModifier_GetBackground(This,ppSurface)	\
    (This)->lpVtbl -> GetBackground(This,ppSurface)

#define IDXSurfaceModifier_SetCompositeOperation(This,CompOp)	\
    (This)->lpVtbl -> SetCompositeOperation(This,CompOp)

#define IDXSurfaceModifier_GetCompositeOperation(This,pCompOp)	\
    (This)->lpVtbl -> GetCompositeOperation(This,pCompOp)

#define IDXSurfaceModifier_SetForeground(This,pSurface,bTile,pOrigin)	\
    (This)->lpVtbl -> SetForeground(This,pSurface,bTile,pOrigin)

#define IDXSurfaceModifier_GetForeground(This,ppSurface,pbTile,pOrigin)	\
    (This)->lpVtbl -> GetForeground(This,ppSurface,pbTile,pOrigin)

#define IDXSurfaceModifier_SetOpacity(This,Opacity)	\
    (This)->lpVtbl -> SetOpacity(This,Opacity)

#define IDXSurfaceModifier_GetOpacity(This,pOpacity)	\
    (This)->lpVtbl -> GetOpacity(This,pOpacity)

#define IDXSurfaceModifier_SetLookup(This,pLookupTable)	\
    (This)->lpVtbl -> SetLookup(This,pLookupTable)

#define IDXSurfaceModifier_GetLookup(This,ppLookupTable)	\
    (This)->lpVtbl -> GetLookup(This,ppLookupTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSAMPLE Color);


void __RPC_STUB IDXSurfaceModifier_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pColor);


void __RPC_STUB IDXSurfaceModifier_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBounds_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurfaceModifier_SetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface);


void __RPC_STUB IDXSurfaceModifier_SetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurfaceModifier_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSURFMODCOMPOP CompOp);


void __RPC_STUB IDXSurfaceModifier_SetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);


void __RPC_STUB IDXSurfaceModifier_GetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ BOOL bTile,
    /* [in] */ const POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_SetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ BOOL __RPC_FAR *pbTile,
    /* [out] */ POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ float Opacity);


void __RPC_STUB IDXSurfaceModifier_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pOpacity);


void __RPC_STUB IDXSurfaceModifier_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);


void __RPC_STUB IDXSurfaceModifier_SetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);


void __RPC_STUB IDXSurfaceModifier_GetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceModifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0172 */
/* [local] */ 

typedef 
enum DXSAMPLEFORMATENUM
    {	DXPF_FLAGSMASK	= 0xffff0000,
	DXPF_NONPREMULT	= 0x10000,
	DXPF_TRANSPARENCY	= 0x20000,
	DXPF_TRANSLUCENCY	= 0x40000,
	DXPF_2BITERROR	= 0x200000,
	DXPF_3BITERROR	= 0x300000,
	DXPF_4BITERROR	= 0x400000,
	DXPF_5BITERROR	= 0x500000,
	DXPF_ERRORMASK	= 0x700000,
	DXPF_NONSTANDARD	= 0,
	DXPF_PMARGB32	= 1 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB32	= 2 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB4444	= 3 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY | DXPF_4BITERROR,
	DXPF_A8	= 4 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_RGB32	= 5,
	DXPF_RGB24	= 6,
	DXPF_RGB565	= 7 | DXPF_3BITERROR,
	DXPF_RGB555	= 8 | DXPF_3BITERROR,
	DXPF_RGB8	= 9 | DXPF_5BITERROR,
	DXPF_ARGB1555	= 10 | DXPF_TRANSPARENCY | DXPF_3BITERROR,
	DXPF_RGB32_CK	= DXPF_RGB32 | DXPF_TRANSPARENCY,
	DXPF_RGB24_CK	= DXPF_RGB24 | DXPF_TRANSPARENCY,
	DXPF_RGB555_CK	= DXPF_RGB555 | DXPF_TRANSPARENCY,
	DXPF_RGB565_CK	= DXPF_RGB565 | DXPF_TRANSPARENCY,
	DXPF_RGB8_CK	= DXPF_RGB8 | DXPF_TRANSPARENCY
    }	DXSAMPLEFORMATENUM;

typedef 
enum DXLOCKSURF
    {	DXLOCKF_READ	= 0,
	DXLOCKF_READWRITE	= 1 << 0,
	DXLOCKF_EXISTINGINFOONLY	= 1 << 1,
	DXLOCKF_WANTRUNINFO	= 1 << 2,
	DXLOCKF_NONPREMULT	= 1 << 16,
	DXLOCKF_VALIDFLAGS	= DXLOCKF_READWRITE | DXLOCKF_EXISTINGINFOONLY | DXLOCKF_WANTRUNINFO | DXLOCKF_NONPREMULT
    }	DXLOCKSURF;

typedef 
enum DXSURFSTATUS
    {	DXSURF_TRANSIENT	= 1 << 0,
	DXSURF_READONLY	= 1 << 1,
	DXSURF_VALIDFLAGS	= DXSURF_TRANSIENT | DXSURF_READONLY
    }	DXSURFSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0172_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0172_v0_0_s_ifspec;

#ifndef __IDXSurface_INTERFACE_DEFINED__
#define __IDXSurface_INTERFACE_DEFINED__

/* interface IDXSurface */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD73F-E139-11d1-9065-00C04FD9189D")
    IDXSurface : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusFlags( 
            /* [in] */ DWORD dwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDrawSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            DXSAMPLE __RPC_FAR *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            DXSAMPLE ColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurfaceDC( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppData( 
            DWORD_PTR dwAppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppData( 
            DWORD_PTR __RPC_FAR *pdwAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPixelFormat )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ DWORD dwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectDrawSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE __RPC_FAR *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE ColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurfaceDC )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD_PTR dwAppData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD_PTR __RPC_FAR *pdwAppData);
        
        END_INTERFACE
    } IDXSurfaceVtbl;

    interface IDXSurface
    {
        CONST_VTBL struct IDXSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurface_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXSurface_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXSurface_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXSurface_GetPixelFormat(This,pFormatID,pSampleFormatEnum)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormatID,pSampleFormatEnum)

#define IDXSurface_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#define IDXSurface_GetStatusFlags(This,pdwStatusFlags)	\
    (This)->lpVtbl -> GetStatusFlags(This,pdwStatusFlags)

#define IDXSurface_SetStatusFlags(This,dwStatusFlags)	\
    (This)->lpVtbl -> SetStatusFlags(This,dwStatusFlags)

#define IDXSurface_LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)	\
    (This)->lpVtbl -> LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)

#define IDXSurface_GetDirectDrawSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetDirectDrawSurface(This,riid,ppSurface)

#define IDXSurface_GetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetColorKey(This,pColorKey)

#define IDXSurface_SetColorKey(This,ColorKey)	\
    (This)->lpVtbl -> SetColorKey(This,ColorKey)

#define IDXSurface_LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)	\
    (This)->lpVtbl -> LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)

#define IDXSurface_SetAppData(This,dwAppData)	\
    (This)->lpVtbl -> SetAppData(This,dwAppData)

#define IDXSurface_GetAppData(This,pdwAppData)	\
    (This)->lpVtbl -> GetAppData(This,pdwAppData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurface_GetPixelFormat_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pFormatID,
    /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);


void __RPC_STUB IDXSurface_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetBounds_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurface_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);


void __RPC_STUB IDXSurface_GetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ DWORD dwStatusFlags);


void __RPC_STUB IDXSurface_SetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
    /* [out] */ ULONG __RPC_FAR *pulGenerationId);


void __RPC_STUB IDXSurface_LockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetDirectDrawSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurface_GetDirectDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE __RPC_FAR *pColorKey);


void __RPC_STUB IDXSurface_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE ColorKey);


void __RPC_STUB IDXSurface_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurfaceDC_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);


void __RPC_STUB IDXSurface_LockSurfaceDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD_PTR dwAppData);


void __RPC_STUB IDXSurface_SetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD_PTR __RPC_FAR *pdwAppData);


void __RPC_STUB IDXSurface_GetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurface_INTERFACE_DEFINED__ */


#ifndef __IDXSurfaceInit_INTERFACE_DEFINED__
#define __IDXSurfaceInit_INTERFACE_DEFINED__

/* interface IDXSurfaceInit */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B639-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceInitVtbl;

    interface IDXSurfaceInit
    {
        CONST_VTBL struct IDXSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceInit_InitSurface_Proxy( 
    IDXSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceInit_InitSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceInit_INTERFACE_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_INTERFACE_DEFINED__
#define __IDXARGBSurfaceInit_INTERFACE_DEFINED__

/* interface IDXARGBSurfaceInit */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXARGBSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B63A-C37D-11d1-905E-00C04FD9189D")
    IDXARGBSurfaceInit : public IDXSurfaceInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitFromRawSurface( 
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromDDSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromRawSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);
        
        END_INTERFACE
    } IDXARGBSurfaceInitVtbl;

    interface IDXARGBSurfaceInit
    {
        CONST_VTBL struct IDXARGBSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)


#define IDXARGBSurfaceInit_InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)	\
    (This)->lpVtbl -> InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)

#define IDXARGBSurfaceInit_InitFromRawSurface(This,pRawSurface)	\
    (This)->lpVtbl -> InitFromRawSurface(This,pRawSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromDDSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXARGBSurfaceInit_InitFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromRawSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);


void __RPC_STUB IDXARGBSurfaceInit_InitFromRawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBSurfaceInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0175 */
/* [local] */ 

typedef struct tagDXNATIVETYPEINFO
    {
    BYTE __RPC_FAR *pCurrentData;
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    DWORD dwColorKey;
    }	DXNATIVETYPEINFO;

typedef struct tagDXPACKEDRECTDESC
    {
    DXBASESAMPLE __RPC_FAR *pSamples;
    BOOL bPremult;
    RECT rect;
    long lRowPadding;
    }	DXPACKEDRECTDESC;

typedef struct tagDXOVERSAMPLEDESC
    {
    POINT p;
    DXPMSAMPLE Color;
    }	DXOVERSAMPLEDESC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0175_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0175_v0_0_s_ifspec;

#ifndef __IDXARGBReadPtr_INTERFACE_DEFINED__
#define __IDXARGBReadPtr_INTERFACE_DEFINED__

/* interface IDXARGBReadPtr */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXARGBReadPtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D6-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadPtr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType( 
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo) = 0;
        
        virtual void STDMETHODCALLTYPE Move( 
            /* [in] */ long cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToRow( 
            /* [in] */ ULONG y) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToXY( 
            /* [in] */ ULONG x,
            /* [in] */ ULONG y) = 0;
        
        virtual ULONG STDMETHODCALLTYPE MoveAndGetRunInfo( 
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo) = 0;
        
        virtual DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE Unpack( 
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE UnpackPremult( 
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual void STDMETHODCALLTYPE UnpackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadPtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        END_INTERFACE
    } IDXARGBReadPtrVtbl;

    interface IDXARGBReadPtr
    {
        CONST_VTBL struct IDXARGBReadPtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadPtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadPtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadPtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadPtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadPtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadPtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadPtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadPtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadPtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadPtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBReadPtr_GetSurface_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXARGBReadPtr_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLEFORMATENUM STDMETHODCALLTYPE IDXARGBReadPtr_GetNativeType_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);


void __RPC_STUB IDXARGBReadPtr_GetNativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_Move_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ long cSamples);


void __RPC_STUB IDXARGBReadPtr_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToRow_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToXY_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG x,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IDXARGBReadPtr_MoveAndGetRunInfo_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG Row,
    /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);


void __RPC_STUB IDXARGBReadPtr_MoveAndGetRunInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_Unpack_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_Unpack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_UnpackPremult_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_UnpackPremult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_UnpackRect_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadPtr_UnpackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadPtr_INTERFACE_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_INTERFACE_DEFINED__
#define __IDXARGBReadWritePtr_INTERFACE_DEFINED__

/* interface IDXARGBReadWritePtr */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXARGBReadWritePtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D7-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadWritePtr : public IDXARGBReadPtr
    {
    public:
        virtual void STDMETHODCALLTYPE PackAndMove( 
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackPremultAndMove( 
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
        virtual void STDMETHODCALLTYPE CopyAndMoveBoth( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE CopyRect( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE FillAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE FillRect( 
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE OverSample( 
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc) = 0;
        
        virtual void STDMETHODCALLTYPE OverArrayAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadWritePtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackPremultAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyAndMoveBoth )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverSample )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverArrayAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXARGBReadWritePtrVtbl;

    interface IDXARGBReadWritePtr
    {
        CONST_VTBL struct IDXARGBReadWritePtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadWritePtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadWritePtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadWritePtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadWritePtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadWritePtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadWritePtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadWritePtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadWritePtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadWritePtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadWritePtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)


#define IDXARGBReadWritePtr_PackAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackPremultAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackPremultAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackRect(This,pRectDesc)	\
    (This)->lpVtbl -> PackRect(This,pRectDesc)

#define IDXARGBReadWritePtr_CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)	\
    (This)->lpVtbl -> CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)

#define IDXARGBReadWritePtr_CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)	\
    (This)->lpVtbl -> CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)

#define IDXARGBReadWritePtr_FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)	\
    (This)->lpVtbl -> FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)

#define IDXARGBReadWritePtr_FillRect(This,pRect,SampVal,bDoOver)	\
    (This)->lpVtbl -> FillRect(This,pRect,SampVal,bDoOver)

#define IDXARGBReadWritePtr_OverSample(This,pOverDesc)	\
    (This)->lpVtbl -> OverSample(This,pOverDesc)

#define IDXARGBReadWritePtr_OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)	\
    (This)->lpVtbl -> OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackPremultAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackPremultAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadWritePtr_PackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyAndMoveBoth_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyAndMoveBoth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const RECT __RPC_FAR *pDestRect,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const RECT __RPC_FAR *pRect,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverSample_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);


void __RPC_STUB IDXARGBReadWritePtr_OverSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverArrayAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_OverArrayAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadWritePtr_INTERFACE_DEFINED__ */


#ifndef __IDXDCLock_INTERFACE_DEFINED__
#define __IDXDCLock_INTERFACE_DEFINED__

/* interface IDXDCLock */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXDCLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F619456-CF39-11d1-905E-00C04FD9189D")
    IDXDCLock : public IUnknown
    {
    public:
        virtual HDC STDMETHODCALLTYPE GetDC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDCLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDCLock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDCLock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDCLock __RPC_FAR * This);
        
        HDC ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDXDCLock __RPC_FAR * This);
        
        END_INTERFACE
    } IDXDCLockVtbl;

    interface IDXDCLock
    {
        CONST_VTBL struct IDXDCLockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDCLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDCLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDCLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDCLock_GetDC(This)	\
    (This)->lpVtbl -> GetDC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HDC STDMETHODCALLTYPE IDXDCLock_GetDC_Proxy( 
    IDXDCLock __RPC_FAR * This);


void __RPC_STUB IDXDCLock_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDCLock_INTERFACE_DEFINED__ */


#ifndef __IDXTScaleOutput_INTERFACE_DEFINED__
#define __IDXTScaleOutput_INTERFACE_DEFINED__

/* interface IDXTScaleOutput */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTScaleOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B50-EE77-11d1-9066-00C04FD9189D")
    IDXTScaleOutput : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputSize( 
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleOutputVtbl;

    interface IDXTScaleOutput
    {
        CONST_VTBL struct IDXTScaleOutputVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScaleOutput_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScaleOutput_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScaleOutput_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScaleOutput_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScaleOutput_SetOutputSize_Proxy( 
    IDXTScaleOutput __RPC_FAR * This,
    /* [in] */ const SIZE OutSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScaleOutput_SetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScaleOutput_INTERFACE_DEFINED__ */


#ifndef __IDXGradient_INTERFACE_DEFINED__
#define __IDXGradient_INTERFACE_DEFINED__

/* interface IDXGradient */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXGradient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B51-EE77-11d1-9066-00C04FD9189D")
    IDXGradient : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGradient( 
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSize( 
            /* [out] */ SIZE __RPC_FAR *pOutSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        END_INTERFACE
    } IDXGradientVtbl;

    interface IDXGradient
    {
        CONST_VTBL struct IDXGradientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient_SetGradient_Proxy( 
    IDXGradient __RPC_FAR * This,
    DXSAMPLE StartColor,
    DXSAMPLE EndColor,
    BOOL bHorizontal);


void __RPC_STUB IDXGradient_SetGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient_GetOutputSize_Proxy( 
    IDXGradient __RPC_FAR * This,
    /* [out] */ SIZE __RPC_FAR *pOutSize);


void __RPC_STUB IDXGradient_GetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient_INTERFACE_DEFINED__ */


#ifndef __IDXTScale_INTERFACE_DEFINED__
#define __IDXTScale_INTERFACE_DEFINED__

/* interface IDXTScale */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTScale;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD742-E139-11d1-9065-00C04FD9189D")
    IDXTScale : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScales( 
            /* [in] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScales( 
            /* [out] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleFitToSize( 
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScale __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScale __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [out] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScaleFitToSize )( 
            IDXTScale __RPC_FAR * This,
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleVtbl;

    interface IDXTScale
    {
        CONST_VTBL struct IDXTScaleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScale_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScale_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScale_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScale_SetScales(This,Scales)	\
    (This)->lpVtbl -> SetScales(This,Scales)

#define IDXTScale_GetScales(This,Scales)	\
    (This)->lpVtbl -> GetScales(This,Scales)

#define IDXTScale_ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)	\
    (This)->lpVtbl -> ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScale_SetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [in] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_SetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_GetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_GetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_ScaleFitToSize_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ SIZE FitToSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScale_ScaleFitToSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScale_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0181 */
/* [local] */ 

typedef 
enum DISPIDDXEFFECT
    {	DISPID_DXECAPABILITIES	= 10000,
	DISPID_DXEPROGRESS	= DISPID_DXECAPABILITIES + 1,
	DISPID_DXESTEP	= DISPID_DXEPROGRESS + 1,
	DISPID_DXEDURATION	= DISPID_DXESTEP + 1,
	DISPID_DXE_NEXT_ID	= DISPID_DXEDURATION + 1
    }	DISPIDDXBOUNDEDEFFECT;

typedef 
enum DXEFFECTTYPE
    {	DXTET_PERIODIC	= 1 << 0,
	DXTET_MORPH	= 1 << 1
    }	DXEFFECTTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0181_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0181_v0_0_s_ifspec;

#ifndef __IDXEffect_INTERFACE_DEFINED__
#define __IDXEffect_INTERFACE_DEFINED__

/* interface IDXEffect */
/* [dual][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E31FB81B-1335-11d1-8189-0000F87557DB")
    IDXEffect : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Capabilities( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Progress( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StepResolution( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXEffect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXEffect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXEffect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXEffectVtbl;

    interface IDXEffect
    {
        CONST_VTBL struct IDXEffectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXEffect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXEffect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXEffect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXEffect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXEffect_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXEffect_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXEffect_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXEffect_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXEffect_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXEffect_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Capabilities_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Capabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_StepResolution_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_StepResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXEffect_INTERFACE_DEFINED__ */


#ifndef __IDXLookupTable_INTERFACE_DEFINED__
#define __IDXLookupTable_INTERFACE_DEFINED__

/* interface IDXLookupTable */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXLookupTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01BAFC7F-9E63-11d1-9053-00C04FD9189D")
    IDXLookupTable : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTables( 
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsChannelIdentity( 
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexValues( 
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyTables( 
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLookupTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLookupTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLookupTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsChannelIdentity )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexValues )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXLookupTableVtbl;

    interface IDXLookupTable
    {
        CONST_VTBL struct IDXLookupTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLookupTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLookupTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLookupTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLookupTable_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXLookupTable_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXLookupTable_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXLookupTable_GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)	\
    (This)->lpVtbl -> GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)

#define IDXLookupTable_IsChannelIdentity(This,pSampleBools)	\
    (This)->lpVtbl -> IsChannelIdentity(This,pSampleBools)

#define IDXLookupTable_GetIndexValues(This,Index,pSample)	\
    (This)->lpVtbl -> GetIndexValues(This,Index,pSample)

#define IDXLookupTable_ApplyTables(This,pSamples,cSamples)	\
    (This)->lpVtbl -> ApplyTables(This,pSamples,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLookupTable_GetTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);


void __RPC_STUB IDXLookupTable_GetTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_IsChannelIdentity_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);


void __RPC_STUB IDXLookupTable_IsChannelIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_GetIndexValues_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [in] */ ULONG Index,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);


void __RPC_STUB IDXLookupTable_GetIndexValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_ApplyTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXLookupTable_ApplyTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLookupTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0183 */
/* [local] */ 

typedef struct DXRAWSURFACEINFO
    {
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    ULONG Width;
    ULONG Height;
    const GUID __RPC_FAR *pPixelFormat;
    HDC hdc;
    DWORD dwColorKey;
    DXBASESAMPLE __RPC_FAR *pPalette;
    }	DXRAWSURFACEINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0183_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0183_v0_0_s_ifspec;

#ifndef __IDXRawSurface_INTERFACE_DEFINED__
#define __IDXRawSurface_INTERFACE_DEFINED__

/* interface IDXRawSurface */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXRawSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09756C8A-D96A-11d1-9062-00C04FD9189D")
    IDXRawSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRawSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRawSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRawSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRawSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurfaceInfo )( 
            IDXRawSurface __RPC_FAR * This,
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);
        
        END_INTERFACE
    } IDXRawSurfaceVtbl;

    interface IDXRawSurface
    {
        CONST_VTBL struct IDXRawSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRawSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRawSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRawSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRawSurface_GetSurfaceInfo(This,pSurfaceInfo)	\
    (This)->lpVtbl -> GetSurfaceInfo(This,pSurfaceInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRawSurface_GetSurfaceInfo_Proxy( 
    IDXRawSurface __RPC_FAR * This,
    DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);


void __RPC_STUB IDXRawSurface_GetSurfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRawSurface_INTERFACE_DEFINED__ */


#ifndef __IHTMLDXTransform_INTERFACE_DEFINED__
#define __IHTMLDXTransform_INTERFACE_DEFINED__

/* interface IHTMLDXTransform */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHTMLDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30E2AB7D-4FDD-4159-B7EA-DC722BF4ADE5")
    IHTMLDXTransform : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHostUrl( 
            BSTR bstrHostUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHTMLDXTransform __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHTMLDXTransform __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHTMLDXTransform __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHostUrl )( 
            IHTMLDXTransform __RPC_FAR * This,
            BSTR bstrHostUrl);
        
        END_INTERFACE
    } IHTMLDXTransformVtbl;

    interface IHTMLDXTransform
    {
        CONST_VTBL struct IHTMLDXTransformVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLDXTransform_SetHostUrl(This,bstrHostUrl)	\
    (This)->lpVtbl -> SetHostUrl(This,bstrHostUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLDXTransform_SetHostUrl_Proxy( 
    IHTMLDXTransform __RPC_FAR * This,
    BSTR bstrHostUrl);


void __RPC_STUB IHTMLDXTransform_SetHostUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLDXTransform_INTERFACE_DEFINED__ */


#ifndef __IObjectWithBehaviorSite_INTERFACE_DEFINED__
#define __IObjectWithBehaviorSite_INTERFACE_DEFINED__

/* interface IObjectWithBehaviorSite */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithBehaviorSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B03DCBE3-DDDB-48cc-9961-74DCA693BFB2")
    IObjectWithBehaviorSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBehaviorSite( 
            IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBehaviorSite( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppvSite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithBehaviorSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IObjectWithBehaviorSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IObjectWithBehaviorSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IObjectWithBehaviorSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBehaviorSite )( 
            IObjectWithBehaviorSite __RPC_FAR * This,
            IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBehaviorSite )( 
            IObjectWithBehaviorSite __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppvSite);
        
        END_INTERFACE
    } IObjectWithBehaviorSiteVtbl;

    interface IObjectWithBehaviorSite
    {
        CONST_VTBL struct IObjectWithBehaviorSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithBehaviorSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithBehaviorSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithBehaviorSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithBehaviorSite_SetBehaviorSite(This,punk)	\
    (This)->lpVtbl -> SetBehaviorSite(This,punk)

#define IObjectWithBehaviorSite_GetBehaviorSite(This,riid,ppvSite)	\
    (This)->lpVtbl -> GetBehaviorSite(This,riid,ppvSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectWithBehaviorSite_SetBehaviorSite_Proxy( 
    IObjectWithBehaviorSite __RPC_FAR * This,
    IUnknown __RPC_FAR *punk);


void __RPC_STUB IObjectWithBehaviorSite_SetBehaviorSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectWithBehaviorSite_GetBehaviorSite_Proxy( 
    IObjectWithBehaviorSite __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppvSite);


void __RPC_STUB IObjectWithBehaviorSite_GetBehaviorSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithBehaviorSite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0186 */
/* [local] */ 

typedef 
enum DXTFILTER_STATUS
    {	DXTFILTER_STATUS_Stopped	= 0,
	DXTFILTER_STATUS_Applied	= DXTFILTER_STATUS_Stopped + 1,
	DXTFILTER_STATUS_Playing	= DXTFILTER_STATUS_Applied + 1,
	DXTFILTER_STATUS_MAX	= DXTFILTER_STATUS_Playing + 1
    }	DXTFILTER_STATUS;

typedef 
enum DXTFILTER_DISPID
    {	DISPID_DXTFilter_Percent	= 1,
	DISPID_DXTFilter_Duration	= DISPID_DXTFilter_Percent + 1,
	DISPID_DXTFilter_Enabled	= DISPID_DXTFilter_Duration + 1,
	DISPID_DXTFilter_Status	= DISPID_DXTFilter_Enabled + 1,
	DISPID_DXTFilter_Apply	= DISPID_DXTFilter_Status + 1,
	DISPID_DXTFilter_Play	= DISPID_DXTFilter_Apply + 1,
	DISPID_DXTFilter_Stop	= DISPID_DXTFilter_Play + 1,
	DISPID_DXTFilter_MAX	= DISPID_DXTFilter_Stop + 1
    }	DXTFILTER_DISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0186_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0186_v0_0_s_ifspec;

#ifndef __ICSSFilterDispatch_INTERFACE_DEFINED__
#define __ICSSFilterDispatch_INTERFACE_DEFINED__

/* interface ICSSFilterDispatch */
/* [dual][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICSSFilterDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9519152B-9484-4A6C-B6A7-4F25E92D6C6B")
    ICSSFilterDispatch : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Percent( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Percent( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL fVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ DXTFILTER_STATUS __RPC_FAR *peVal) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Apply( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Play( 
            /* [optional][in] */ VARIANT varDuration) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICSSFilterDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICSSFilterDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICSSFilterDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Percent )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Percent )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [retval][out] */ DXTFILTER_STATUS __RPC_FAR *peVal);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Apply )( 
            ICSSFilterDispatch __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            ICSSFilterDispatch __RPC_FAR * This,
            /* [optional][in] */ VARIANT varDuration);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            ICSSFilterDispatch __RPC_FAR * This);
        
        END_INTERFACE
    } ICSSFilterDispatchVtbl;

    interface ICSSFilterDispatch
    {
        CONST_VTBL struct ICSSFilterDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICSSFilterDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICSSFilterDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICSSFilterDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICSSFilterDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICSSFilterDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICSSFilterDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICSSFilterDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICSSFilterDispatch_get_Percent(This,pVal)	\
    (This)->lpVtbl -> get_Percent(This,pVal)

#define ICSSFilterDispatch_put_Percent(This,newVal)	\
    (This)->lpVtbl -> put_Percent(This,newVal)

#define ICSSFilterDispatch_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICSSFilterDispatch_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)

#define ICSSFilterDispatch_get_Enabled(This,pfVal)	\
    (This)->lpVtbl -> get_Enabled(This,pfVal)

#define ICSSFilterDispatch_put_Enabled(This,fVal)	\
    (This)->lpVtbl -> put_Enabled(This,fVal)

#define ICSSFilterDispatch_get_Status(This,peVal)	\
    (This)->lpVtbl -> get_Status(This,peVal)

#define ICSSFilterDispatch_Apply(This)	\
    (This)->lpVtbl -> Apply(This)

#define ICSSFilterDispatch_Play(This,varDuration)	\
    (This)->lpVtbl -> Play(This,varDuration)

#define ICSSFilterDispatch_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_get_Percent_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICSSFilterDispatch_get_Percent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_put_Percent_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICSSFilterDispatch_put_Percent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_get_Duration_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICSSFilterDispatch_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_put_Duration_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICSSFilterDispatch_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_get_Enabled_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfVal);


void __RPC_STUB ICSSFilterDispatch_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_put_Enabled_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fVal);


void __RPC_STUB ICSSFilterDispatch_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_get_Status_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [retval][out] */ DXTFILTER_STATUS __RPC_FAR *peVal);


void __RPC_STUB ICSSFilterDispatch_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_Apply_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This);


void __RPC_STUB ICSSFilterDispatch_Apply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_Play_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This,
    /* [optional][in] */ VARIANT varDuration);


void __RPC_STUB ICSSFilterDispatch_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ICSSFilterDispatch_Stop_Proxy( 
    ICSSFilterDispatch __RPC_FAR * This);


void __RPC_STUB ICSSFilterDispatch_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICSSFilterDispatch_INTERFACE_DEFINED__ */



#ifndef __DXTRANSLib_LIBRARY_DEFINED__
#define __DXTRANSLib_LIBRARY_DEFINED__

/* library DXTRANSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSLib;

EXTERN_C const CLSID CLSID_DXTransformFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("D1FE6762-FC48-11D0-883A-3C8B00C10000")
DXTransformFactory;
#endif

EXTERN_C const CLSID CLSID_DXTaskManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB26C03-FF93-11d0-817E-0000F87557DB")
DXTaskManager;
#endif

EXTERN_C const CLSID CLSID_DXTScale;

#ifdef __cplusplus

class DECLSPEC_UUID("555278E2-05DB-11D1-883A-3C8B00C10000")
DXTScale;
#endif

EXTERN_C const CLSID CLSID_DXSurface;

#ifdef __cplusplus

class DECLSPEC_UUID("0E890F83-5F79-11D1-9043-00C04FD9189D")
DXSurface;
#endif

EXTERN_C const CLSID CLSID_DXSurfaceModifier;

#ifdef __cplusplus

class DECLSPEC_UUID("3E669F1D-9C23-11d1-9053-00C04FD9189D")
DXSurfaceModifier;
#endif

EXTERN_C const CLSID CLSID_DXGradient;

#ifdef __cplusplus

class DECLSPEC_UUID("C6365470-F667-11d1-9067-00C04FD9189D")
DXGradient;
#endif

EXTERN_C const CLSID CLSID_DXTFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("385A91BC-1E8A-4e4a-A7A6-F4FC1E6CA1BD")
DXTFilter;
#endif
#endif /* __DXTRANSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\eaphostpeerapis.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for eaphostpeerapis.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __eaphostpeerapis_h__
#define __eaphostpeerapis_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEapHostPeerSessionApis_FWD_DEFINED__
#define __IEapHostPeerSessionApis_FWD_DEFINED__
typedef interface IEapHostPeerSessionApis IEapHostPeerSessionApis;
#endif 	/* __IEapHostPeerSessionApis_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "EapTypes.h"
#include "EapHostPeerTypes.h"
#ifdef UNDER_CE
#define __int3264 __int32
#define __RPC__in
#define __RPC__in_ecount_full_opt(x)
#define __RPC__in_opt
#define __RPC__out
#define __RPC__deref_opt_inout_opt
#define __RPC__in_ecount_full(x)
#define __RPC__out_ecount_full(x)
#define __RPC__deref_out_opt_string
#endif

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_eaphostpeerapis_0000_0000 */
/* [local] */ 


EXTERN_C const CLSID CLSID_HostPeerApis;



extern RPC_IF_HANDLE __MIDL_itf_eaphostpeerapis_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_eaphostpeerapis_0000_0000_v0_0_s_ifspec;

#ifndef __IEapHostPeerSessionApis_INTERFACE_DEFINED__
#define __IEapHostPeerSessionApis_INTERFACE_DEFINED__

/* interface IEapHostPeerSessionApis */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEapHostPeerSessionApis;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09DBBC77-588F-4517-A485-74A29759F54C")
    IEapHostPeerSessionApis : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerBeginSession( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ EAP_METHOD_TYPE eapType,
            /* [unique][in] */ __RPC__in_opt const EapAttributes *const pAttributeArray,
            /* [in] */ DWORD hTargetProcessId,
            /* [in] */ __int3264 hTokenImpersonateUser,
            /* [in] */ DWORD dwSizeofConfigData,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwSizeofConfigData) const BYTE *const pConfigData,
            /* [in] */ DWORD dwSizeofUserCreds,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwSizeofUserCreds) const BYTE *const pUserCreds,
            /* [in] */ DWORD dwMaxSendPacketSize,
            /* [unique][in] */ __RPC__in_opt const GUID *const connectionId,
            /* [ref][out] */ __RPC__out EAP_SESSIONID *pSessionId,
            /* [ref][unique][out] */ __RPC__out __int3264 *reauthEventHandle,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerProcessReceivedPacket( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ DWORD cbReceivePacket,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReceivePacket) const BYTE *const pReceivePacket,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetSendPacket( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out DWORD *pcbSendPacket,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **pSendPacket,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetResult( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ EapHostPeerMethodResultReason reason,
            /* [out] */ __RPC__out EapHostPeerMethodResult *ppResult,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetUIContext( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out DWORD *pdwSizeOfUIContextData,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppUIContextData,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerSetUIContext( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ DWORD dwSizeOfUIContextData,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSizeOfUIContextData) const BYTE *const pUIContextData,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetResponseAttributes( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out EapAttributes *pAttribs,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerSetResponseAttributes( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ __RPC__in const EapAttributes *const pAttribs,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetAuthStatus( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ EapHostPeerAuthParams authParam,
            /* [out] */ __RPC__out DWORD *pcbAuthData,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppAuthData,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerEndSession( 
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerClearConnection( 
            /* [in] */ GUID connectionId,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EapHostPeerGetIdentity( 
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ EAP_METHOD_TYPE eapMethodType,
            /* [in] */ DWORD dwSizeofConnectionData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(dwSizeofConnectionData) const BYTE *pConnectionData,
            /* [in] */ DWORD dwSizeofUserData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(dwSizeofUserData) const BYTE *pUserData,
            /* [in] */ DWORD hTargetProcessId,
            /* [in] */ __int3264 hTokenImpersonateUser,
            /* [out] */ __RPC__out BOOL *pfInvokeUI,
            /* [out] */ __RPC__out DWORD *pdwSizeOfUserDataOut,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppUserDataOut,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIdentity,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **ppEapError,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BYTE **ppvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEapHostPeerSessionApisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEapHostPeerSessionApis * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEapHostPeerSessionApis * This);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerBeginSession )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ EAP_METHOD_TYPE eapType,
            /* [unique][in] */ __RPC__in_opt const EapAttributes *const pAttributeArray,
            /* [in] */ DWORD hTargetProcessId,
            /* [in] */ __int3264 hTokenImpersonateUser,
            /* [in] */ DWORD dwSizeofConfigData,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwSizeofConfigData) const BYTE *const pConfigData,
            /* [in] */ DWORD dwSizeofUserCreds,
            /* [size_is][unique][in] */ __RPC__in_ecount_full_opt(dwSizeofUserCreds) const BYTE *const pUserCreds,
            /* [in] */ DWORD dwMaxSendPacketSize,
            /* [unique][in] */ __RPC__in_opt const GUID *const connectionId,
            /* [ref][out] */ __RPC__out EAP_SESSIONID *pSessionId,
            /* [ref][unique][out] */ __RPC__out __int3264 *reauthEventHandle,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerProcessReceivedPacket )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ DWORD cbReceivePacket,
            /* [size_is][in] */ __RPC__in_ecount_full(cbReceivePacket) const BYTE *const pReceivePacket,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetSendPacket )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out DWORD *pcbSendPacket,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **pSendPacket,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetResult )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ EapHostPeerMethodResultReason reason,
            /* [out] */ __RPC__out EapHostPeerMethodResult *ppResult,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetUIContext )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out DWORD *pdwSizeOfUIContextData,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppUIContextData,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerSetUIContext )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ DWORD dwSizeOfUIContextData,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSizeOfUIContextData) const BYTE *const pUIContextData,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetResponseAttributes )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [out] */ __RPC__out EapAttributes *pAttribs,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerSetResponseAttributes )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ __RPC__in const EapAttributes *const pAttribs,
            /* [out] */ __RPC__out EapHostPeerResponseAction *pEapOutput,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetAuthStatus )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [in] */ EapHostPeerAuthParams authParam,
            /* [out] */ __RPC__out DWORD *pcbAuthData,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppAuthData,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerEndSession )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ EAP_SESSIONID sessionHandle,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerClearConnection )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ GUID connectionId,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **pEapError);
        
        HRESULT ( STDMETHODCALLTYPE *EapHostPeerGetIdentity )( 
            IEapHostPeerSessionApis * This,
            /* [in] */ DWORD dwVersion,
            /* [in] */ DWORD dwFlags,
            /* [in] */ EAP_METHOD_TYPE eapMethodType,
            /* [in] */ DWORD dwSizeofConnectionData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(dwSizeofConnectionData) const BYTE *pConnectionData,
            /* [in] */ DWORD dwSizeofUserData,
            /* [unique][size_is][in] */ __RPC__in_ecount_full_opt(dwSizeofUserData) const BYTE *pUserData,
            /* [in] */ DWORD hTargetProcessId,
            /* [in] */ __int3264 hTokenImpersonateUser,
            /* [out] */ __RPC__out BOOL *pfInvokeUI,
            /* [out] */ __RPC__out DWORD *pdwSizeOfUserDataOut,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BYTE **ppUserDataOut,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppwszIdentity,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt EAP_ERROR **ppEapError,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BYTE **ppvReserved);
        
        END_INTERFACE
    } IEapHostPeerSessionApisVtbl;

    interface IEapHostPeerSessionApis
    {
        CONST_VTBL struct IEapHostPeerSessionApisVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEapHostPeerSessionApis_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEapHostPeerSessionApis_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEapHostPeerSessionApis_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEapHostPeerSessionApis_EapHostPeerBeginSession(This,dwFlags,eapType,pAttributeArray,hTargetProcessId,hTokenImpersonateUser,dwSizeofConfigData,pConfigData,dwSizeofUserCreds,pUserCreds,dwMaxSendPacketSize,connectionId,pSessionId,reauthEventHandle,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerBeginSession(This,dwFlags,eapType,pAttributeArray,hTargetProcessId,hTokenImpersonateUser,dwSizeofConfigData,pConfigData,dwSizeofUserCreds,pUserCreds,dwMaxSendPacketSize,connectionId,pSessionId,reauthEventHandle,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerProcessReceivedPacket(This,sessionHandle,cbReceivePacket,pReceivePacket,pEapOutput,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerProcessReceivedPacket(This,sessionHandle,cbReceivePacket,pReceivePacket,pEapOutput,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetSendPacket(This,sessionHandle,pcbSendPacket,pSendPacket,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerGetSendPacket(This,sessionHandle,pcbSendPacket,pSendPacket,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetResult(This,sessionHandle,reason,ppResult,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerGetResult(This,sessionHandle,reason,ppResult,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetUIContext(This,sessionHandle,pdwSizeOfUIContextData,ppUIContextData,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerGetUIContext(This,sessionHandle,pdwSizeOfUIContextData,ppUIContextData,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerSetUIContext(This,sessionHandle,dwSizeOfUIContextData,pUIContextData,pEapOutput,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerSetUIContext(This,sessionHandle,dwSizeOfUIContextData,pUIContextData,pEapOutput,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetResponseAttributes(This,sessionHandle,pAttribs,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerGetResponseAttributes(This,sessionHandle,pAttribs,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerSetResponseAttributes(This,sessionHandle,pAttribs,pEapOutput,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerSetResponseAttributes(This,sessionHandle,pAttribs,pEapOutput,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetAuthStatus(This,sessionHandle,authParam,pcbAuthData,ppAuthData,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerGetAuthStatus(This,sessionHandle,authParam,pcbAuthData,ppAuthData,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerEndSession(This,sessionHandle,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerEndSession(This,sessionHandle,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerClearConnection(This,connectionId,pEapError)	\
    ( (This)->lpVtbl -> EapHostPeerClearConnection(This,connectionId,pEapError) ) 

#define IEapHostPeerSessionApis_EapHostPeerGetIdentity(This,dwVersion,dwFlags,eapMethodType,dwSizeofConnectionData,pConnectionData,dwSizeofUserData,pUserData,hTargetProcessId,hTokenImpersonateUser,pfInvokeUI,pdwSizeOfUserDataOut,ppUserDataOut,ppwszIdentity,ppEapError,ppvReserved)	\
    ( (This)->lpVtbl -> EapHostPeerGetIdentity(This,dwVersion,dwFlags,eapMethodType,dwSizeofConnectionData,pConnectionData,dwSizeofUserData,pUserData,hTargetProcessId,hTokenImpersonateUser,pfInvokeUI,pdwSizeOfUserDataOut,ppUserDataOut,ppwszIdentity,ppEapError,ppvReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEapHostPeerSessionApis_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxvector.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the vector helper classes.
*
*******************************************************************************/
#ifndef DXVector_h
#define DXVector_h

//=== Constants ====================================================


//=== Class, Struct and Union Definitions ==========================

/*** CDXVec ************
*   This template implements basic vector operations for each of the
*   union types
*/
#define CDXV_C CDXVec<TYPE, eBndType>
#define CDXV_T ((TYPE*)u.D)
#define CDXV_O( OtherVec ) ((TYPE*)OtherVec.u.D)

template<class TYPE, DXBNDTYPE eBndType>
class CDXVec : public DXVEC
{
  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    CDXVec() { eType = eBndType; ZeroVector(); }
    CDXVec(BOOL bInit) { eType = eBndType; if (bInit) ZeroVector(); }
    CDXVec( TYPE x, TYPE y, TYPE z, TYPE t )
        { eType = eBndType; CDXV_T[DXB_X] = x; CDXV_T[DXB_Y] = y;
                            CDXV_T[DXB_Z] = z; CDXV_T[DXB_T] = t; }
    CDXVec( const CDXVec& Other ) { memcpy( this, (void *)&Other, sizeof(DXVEC) ); }
    CDXVec( const DXVEC Other ) { memcpy( this, &Other, sizeof(DXVEC) ); }
    operator TYPE *() { return CDXV_T; }
    operator const TYPE *() { return CDXV_T; }

    /*--- operations ---*/
    void ZeroVector( void ) { memset( u.D, 0, sizeof(TYPE) * 4); }

    /*--- operators ---*/
    TYPE&  operator[]( int index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( long index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( USHORT index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( DWORD index ) const { return CDXV_T[index]; }
    CDXV_C operator+(const CDXV_C& v);
    CDXV_C operator-(const CDXV_C& v);
    void   operator=(const CDXV_C& srcVector);
    void   operator+=(const CDXV_C& vOther);
    void   operator-=(const CDXV_C& vOther);
    BOOL   operator==(const CDXV_C& otherVector) const;
    BOOL   operator!=(const CDXV_C& otherVector) const;
};

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator+( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] += CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] += CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] += CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] += CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator+ */

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator-( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] -= CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] -= CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] -= CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] -= CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator- */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator=( const CDXV_C& srcVector )
{
    memcpy( this, &srcVector, sizeof(CDXVec) );
} /* CDXVec::operator= */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator==(const CDXV_C& otherVector) const
{
    return !memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator== */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator!=(const CDXV_C& otherVector) const
{
    return memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator!= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator+=(const CDXV_C& vOther)
{
    CDXV_T[DXB_X] += CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] += CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] += CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] += CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator+= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator-=(const CDXVec& vOther)
{
    CDXV_T[DXB_X] -= CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] -= CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] -= CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] -= CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator-= */

typedef CDXVec<long, DXBT_DISCRETE> CDXDVec;
typedef CDXVec<LONGLONG, DXBT_DISCRETE64> CDXDVec64;
typedef CDXVec<float, DXBT_CONTINUOUS> CDXCVec;
typedef CDXVec<double, DXBT_CONTINUOUS64> CDXCVec64;

#endif  // DXVector_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\dxtmsft.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:13:22 2007
 */
/* Compiler settings for ..\dxtmsft.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft_h__
#define __dxtmsft_h__

/* Forward Declarations */ 

#ifndef __IDXLUTBuilder_FWD_DEFINED__
#define __IDXLUTBuilder_FWD_DEFINED__
typedef interface IDXLUTBuilder IDXLUTBuilder;
#endif 	/* __IDXLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXDLUTBuilder_FWD_DEFINED__
#define __IDXDLUTBuilder_FWD_DEFINED__
typedef interface IDXDLUTBuilder IDXDLUTBuilder;
#endif 	/* __IDXDLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXTGradientD_FWD_DEFINED__
#define __IDXTGradientD_FWD_DEFINED__
typedef interface IDXTGradientD IDXTGradientD;
#endif 	/* __IDXTGradientD_FWD_DEFINED__ */


#ifndef __IDXTConvolution_FWD_DEFINED__
#define __IDXTConvolution_FWD_DEFINED__
typedef interface IDXTConvolution IDXTConvolution;
#endif 	/* __IDXTConvolution_FWD_DEFINED__ */


#ifndef __IDXTComposite_FWD_DEFINED__
#define __IDXTComposite_FWD_DEFINED__
typedef interface IDXTComposite IDXTComposite;
#endif 	/* __IDXTComposite_FWD_DEFINED__ */


#ifndef __IDXTWipe_FWD_DEFINED__
#define __IDXTWipe_FWD_DEFINED__
typedef interface IDXTWipe IDXTWipe;
#endif 	/* __IDXTWipe_FWD_DEFINED__ */


#ifndef __IDXTWipe2_FWD_DEFINED__
#define __IDXTWipe2_FWD_DEFINED__
typedef interface IDXTWipe2 IDXTWipe2;
#endif 	/* __IDXTWipe2_FWD_DEFINED__ */


#ifndef __ICrBlur_FWD_DEFINED__
#define __ICrBlur_FWD_DEFINED__
typedef interface ICrBlur ICrBlur;
#endif 	/* __ICrBlur_FWD_DEFINED__ */


#ifndef __ICrEngrave_FWD_DEFINED__
#define __ICrEngrave_FWD_DEFINED__
typedef interface ICrEngrave ICrEngrave;
#endif 	/* __ICrEngrave_FWD_DEFINED__ */


#ifndef __ICrEmboss_FWD_DEFINED__
#define __ICrEmboss_FWD_DEFINED__
typedef interface ICrEmboss ICrEmboss;
#endif 	/* __ICrEmboss_FWD_DEFINED__ */


#ifndef __IDXTFade_FWD_DEFINED__
#define __IDXTFade_FWD_DEFINED__
typedef interface IDXTFade IDXTFade;
#endif 	/* __IDXTFade_FWD_DEFINED__ */


#ifndef __IDXBasicImage_FWD_DEFINED__
#define __IDXBasicImage_FWD_DEFINED__
typedef interface IDXBasicImage IDXBasicImage;
#endif 	/* __IDXBasicImage_FWD_DEFINED__ */


#ifndef __IDXPixelate_FWD_DEFINED__
#define __IDXPixelate_FWD_DEFINED__
typedef interface IDXPixelate IDXPixelate;
#endif 	/* __IDXPixelate_FWD_DEFINED__ */


#ifndef __ICrIris_FWD_DEFINED__
#define __ICrIris_FWD_DEFINED__
typedef interface ICrIris ICrIris;
#endif 	/* __ICrIris_FWD_DEFINED__ */


#ifndef __ICrIris2_FWD_DEFINED__
#define __ICrIris2_FWD_DEFINED__
typedef interface ICrIris2 ICrIris2;
#endif 	/* __ICrIris2_FWD_DEFINED__ */


#ifndef __ICrSlide_FWD_DEFINED__
#define __ICrSlide_FWD_DEFINED__
typedef interface ICrSlide ICrSlide;
#endif 	/* __ICrSlide_FWD_DEFINED__ */


#ifndef __ICrRadialWipe_FWD_DEFINED__
#define __ICrRadialWipe_FWD_DEFINED__
typedef interface ICrRadialWipe ICrRadialWipe;
#endif 	/* __ICrRadialWipe_FWD_DEFINED__ */


#ifndef __ICrBarn_FWD_DEFINED__
#define __ICrBarn_FWD_DEFINED__
typedef interface ICrBarn ICrBarn;
#endif 	/* __ICrBarn_FWD_DEFINED__ */


#ifndef __ICrBarn2_FWD_DEFINED__
#define __ICrBarn2_FWD_DEFINED__
typedef interface ICrBarn2 ICrBarn2;
#endif 	/* __ICrBarn2_FWD_DEFINED__ */


#ifndef __ICrBlinds_FWD_DEFINED__
#define __ICrBlinds_FWD_DEFINED__
typedef interface ICrBlinds ICrBlinds;
#endif 	/* __ICrBlinds_FWD_DEFINED__ */


#ifndef __ICrBlinds2_FWD_DEFINED__
#define __ICrBlinds2_FWD_DEFINED__
typedef interface ICrBlinds2 ICrBlinds2;
#endif 	/* __ICrBlinds2_FWD_DEFINED__ */


#ifndef __ICrInset_FWD_DEFINED__
#define __ICrInset_FWD_DEFINED__
typedef interface ICrInset ICrInset;
#endif 	/* __ICrInset_FWD_DEFINED__ */


#ifndef __ICrStretch_FWD_DEFINED__
#define __ICrStretch_FWD_DEFINED__
typedef interface ICrStretch ICrStretch;
#endif 	/* __ICrStretch_FWD_DEFINED__ */


#ifndef __IDXTGridSize_FWD_DEFINED__
#define __IDXTGridSize_FWD_DEFINED__
typedef interface IDXTGridSize IDXTGridSize;
#endif 	/* __IDXTGridSize_FWD_DEFINED__ */


#ifndef __ICrSpiral_FWD_DEFINED__
#define __ICrSpiral_FWD_DEFINED__
typedef interface ICrSpiral ICrSpiral;
#endif 	/* __ICrSpiral_FWD_DEFINED__ */


#ifndef __ICrZigzag_FWD_DEFINED__
#define __ICrZigzag_FWD_DEFINED__
typedef interface ICrZigzag ICrZigzag;
#endif 	/* __ICrZigzag_FWD_DEFINED__ */


#ifndef __ICrWheel_FWD_DEFINED__
#define __ICrWheel_FWD_DEFINED__
typedef interface ICrWheel ICrWheel;
#endif 	/* __ICrWheel_FWD_DEFINED__ */


#ifndef __IDXTChroma_FWD_DEFINED__
#define __IDXTChroma_FWD_DEFINED__
typedef interface IDXTChroma IDXTChroma;
#endif 	/* __IDXTChroma_FWD_DEFINED__ */


#ifndef __IDXTDropShadow_FWD_DEFINED__
#define __IDXTDropShadow_FWD_DEFINED__
typedef interface IDXTDropShadow IDXTDropShadow;
#endif 	/* __IDXTDropShadow_FWD_DEFINED__ */


#ifndef __IDXTCheckerBoard_FWD_DEFINED__
#define __IDXTCheckerBoard_FWD_DEFINED__
typedef interface IDXTCheckerBoard IDXTCheckerBoard;
#endif 	/* __IDXTCheckerBoard_FWD_DEFINED__ */


#ifndef __IDXTRevealTrans_FWD_DEFINED__
#define __IDXTRevealTrans_FWD_DEFINED__
typedef interface IDXTRevealTrans IDXTRevealTrans;
#endif 	/* __IDXTRevealTrans_FWD_DEFINED__ */


#ifndef __IDXTMask_FWD_DEFINED__
#define __IDXTMask_FWD_DEFINED__
typedef interface IDXTMask IDXTMask;
#endif 	/* __IDXTMask_FWD_DEFINED__ */


#ifndef __IDXTAlphaImageLoader_FWD_DEFINED__
#define __IDXTAlphaImageLoader_FWD_DEFINED__
typedef interface IDXTAlphaImageLoader IDXTAlphaImageLoader;
#endif 	/* __IDXTAlphaImageLoader_FWD_DEFINED__ */


#ifndef __IDXTRandomBars_FWD_DEFINED__
#define __IDXTRandomBars_FWD_DEFINED__
typedef interface IDXTRandomBars IDXTRandomBars;
#endif 	/* __IDXTRandomBars_FWD_DEFINED__ */


#ifndef __IDXTStrips_FWD_DEFINED__
#define __IDXTStrips_FWD_DEFINED__
typedef interface IDXTStrips IDXTStrips;
#endif 	/* __IDXTStrips_FWD_DEFINED__ */


#ifndef __IDXTAlpha_FWD_DEFINED__
#define __IDXTAlpha_FWD_DEFINED__
typedef interface IDXTAlpha IDXTAlpha;
#endif 	/* __IDXTAlpha_FWD_DEFINED__ */


#ifndef __IDXTGlow_FWD_DEFINED__
#define __IDXTGlow_FWD_DEFINED__
typedef interface IDXTGlow IDXTGlow;
#endif 	/* __IDXTGlow_FWD_DEFINED__ */


#ifndef __IDXTShadow_FWD_DEFINED__
#define __IDXTShadow_FWD_DEFINED__
typedef interface IDXTShadow IDXTShadow;
#endif 	/* __IDXTShadow_FWD_DEFINED__ */


#ifndef __IDXTWave_FWD_DEFINED__
#define __IDXTWave_FWD_DEFINED__
typedef interface IDXTWave IDXTWave;
#endif 	/* __IDXTWave_FWD_DEFINED__ */


#ifndef __IDXTLight_FWD_DEFINED__
#define __IDXTLight_FWD_DEFINED__
typedef interface IDXTLight IDXTLight;
#endif 	/* __IDXTLight_FWD_DEFINED__ */


#ifndef __IDXTMotionBlur_FWD_DEFINED__
#define __IDXTMotionBlur_FWD_DEFINED__
typedef interface IDXTMotionBlur IDXTMotionBlur;
#endif 	/* __IDXTMotionBlur_FWD_DEFINED__ */


#ifndef __IDXTMatrix_FWD_DEFINED__
#define __IDXTMatrix_FWD_DEFINED__
typedef interface IDXTMatrix IDXTMatrix;
#endif 	/* __IDXTMatrix_FWD_DEFINED__ */


#ifndef __IDXTICMFilter_FWD_DEFINED__
#define __IDXTICMFilter_FWD_DEFINED__
typedef interface IDXTICMFilter IDXTICMFilter;
#endif 	/* __IDXTICMFilter_FWD_DEFINED__ */


#ifndef __DXTComposite_FWD_DEFINED__
#define __DXTComposite_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTComposite DXTComposite;
#else
typedef struct DXTComposite DXTComposite;
#endif /* __cplusplus */

#endif 	/* __DXTComposite_FWD_DEFINED__ */


#ifndef __DXLUTBuilder_FWD_DEFINED__
#define __DXLUTBuilder_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXLUTBuilder DXLUTBuilder;
#else
typedef struct DXLUTBuilder DXLUTBuilder;
#endif /* __cplusplus */

#endif 	/* __DXLUTBuilder_FWD_DEFINED__ */


#ifndef __DXTGradientD_FWD_DEFINED__
#define __DXTGradientD_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientD DXTGradientD;
#else
typedef struct DXTGradientD DXTGradientD;
#endif /* __cplusplus */

#endif 	/* __DXTGradientD_FWD_DEFINED__ */


#ifndef __DXTWipe_FWD_DEFINED__
#define __DXTWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipe DXTWipe;
#else
typedef struct DXTWipe DXTWipe;
#endif /* __cplusplus */

#endif 	/* __DXTWipe_FWD_DEFINED__ */


#ifndef __DXTGradientWipe_FWD_DEFINED__
#define __DXTGradientWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientWipe DXTGradientWipe;
#else
typedef struct DXTGradientWipe DXTGradientWipe;
#endif /* __cplusplus */

#endif 	/* __DXTGradientWipe_FWD_DEFINED__ */


#ifndef __DXTConvolution_FWD_DEFINED__
#define __DXTConvolution_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTConvolution DXTConvolution;
#else
typedef struct DXTConvolution DXTConvolution;
#endif /* __cplusplus */

#endif 	/* __DXTConvolution_FWD_DEFINED__ */


#ifndef __CrBlur_FWD_DEFINED__
#define __CrBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlur CrBlur;
#else
typedef struct CrBlur CrBlur;
#endif /* __cplusplus */

#endif 	/* __CrBlur_FWD_DEFINED__ */


#ifndef __CrEmboss_FWD_DEFINED__
#define __CrEmboss_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEmboss CrEmboss;
#else
typedef struct CrEmboss CrEmboss;
#endif /* __cplusplus */

#endif 	/* __CrEmboss_FWD_DEFINED__ */


#ifndef __CrEngrave_FWD_DEFINED__
#define __CrEngrave_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEngrave CrEngrave;
#else
typedef struct CrEngrave CrEngrave;
#endif /* __cplusplus */

#endif 	/* __CrEngrave_FWD_DEFINED__ */


#ifndef __DXFade_FWD_DEFINED__
#define __DXFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXFade DXFade;
#else
typedef struct DXFade DXFade;
#endif /* __cplusplus */

#endif 	/* __DXFade_FWD_DEFINED__ */


#ifndef __BasicImageEffects_FWD_DEFINED__
#define __BasicImageEffects_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffects BasicImageEffects;
#else
typedef struct BasicImageEffects BasicImageEffects;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffects_FWD_DEFINED__ */


#ifndef __Pixelate_FWD_DEFINED__
#define __Pixelate_FWD_DEFINED__

#ifdef __cplusplus
typedef class Pixelate Pixelate;
#else
typedef struct Pixelate Pixelate;
#endif /* __cplusplus */

#endif 	/* __Pixelate_FWD_DEFINED__ */


#ifndef __CrIris_FWD_DEFINED__
#define __CrIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIris CrIris;
#else
typedef struct CrIris CrIris;
#endif /* __cplusplus */

#endif 	/* __CrIris_FWD_DEFINED__ */


#ifndef __DXTIris_FWD_DEFINED__
#define __DXTIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTIris DXTIris;
#else
typedef struct DXTIris DXTIris;
#endif /* __cplusplus */

#endif 	/* __DXTIris_FWD_DEFINED__ */


#ifndef __CrSlide_FWD_DEFINED__
#define __CrSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlide CrSlide;
#else
typedef struct CrSlide CrSlide;
#endif /* __cplusplus */

#endif 	/* __CrSlide_FWD_DEFINED__ */


#ifndef __DXTSlide_FWD_DEFINED__
#define __DXTSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSlide DXTSlide;
#else
typedef struct DXTSlide DXTSlide;
#endif /* __cplusplus */

#endif 	/* __DXTSlide_FWD_DEFINED__ */


#ifndef __CrRadialWipe_FWD_DEFINED__
#define __CrRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipe CrRadialWipe;
#else
typedef struct CrRadialWipe CrRadialWipe;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipe_FWD_DEFINED__ */


#ifndef __DXTRadialWipe_FWD_DEFINED__
#define __DXTRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRadialWipe DXTRadialWipe;
#else
typedef struct DXTRadialWipe DXTRadialWipe;
#endif /* __cplusplus */

#endif 	/* __DXTRadialWipe_FWD_DEFINED__ */


#ifndef __CrBarn_FWD_DEFINED__
#define __CrBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBarn CrBarn;
#else
typedef struct CrBarn CrBarn;
#endif /* __cplusplus */

#endif 	/* __CrBarn_FWD_DEFINED__ */


#ifndef __DXTBarn_FWD_DEFINED__
#define __DXTBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBarn DXTBarn;
#else
typedef struct DXTBarn DXTBarn;
#endif /* __cplusplus */

#endif 	/* __DXTBarn_FWD_DEFINED__ */


#ifndef __CrBlinds_FWD_DEFINED__
#define __CrBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlinds CrBlinds;
#else
typedef struct CrBlinds CrBlinds;
#endif /* __cplusplus */

#endif 	/* __CrBlinds_FWD_DEFINED__ */


#ifndef __DXTBlinds_FWD_DEFINED__
#define __DXTBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlinds DXTBlinds;
#else
typedef struct DXTBlinds DXTBlinds;
#endif /* __cplusplus */

#endif 	/* __DXTBlinds_FWD_DEFINED__ */


#ifndef __CrStretch_FWD_DEFINED__
#define __CrStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretch CrStretch;
#else
typedef struct CrStretch CrStretch;
#endif /* __cplusplus */

#endif 	/* __CrStretch_FWD_DEFINED__ */


#ifndef __DXTStretch_FWD_DEFINED__
#define __DXTStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTStretch DXTStretch;
#else
typedef struct DXTStretch DXTStretch;
#endif /* __cplusplus */

#endif 	/* __DXTStretch_FWD_DEFINED__ */


#ifndef __CrInset_FWD_DEFINED__
#define __CrInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrInset CrInset;
#else
typedef struct CrInset CrInset;
#endif /* __cplusplus */

#endif 	/* __CrInset_FWD_DEFINED__ */


#ifndef __DXTInset_FWD_DEFINED__
#define __DXTInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTInset DXTInset;
#else
typedef struct DXTInset DXTInset;
#endif /* __cplusplus */

#endif 	/* __DXTInset_FWD_DEFINED__ */


#ifndef __CrSpiral_FWD_DEFINED__
#define __CrSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiral CrSpiral;
#else
typedef struct CrSpiral CrSpiral;
#endif /* __cplusplus */

#endif 	/* __CrSpiral_FWD_DEFINED__ */


#ifndef __DXTSpiral_FWD_DEFINED__
#define __DXTSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpiral DXTSpiral;
#else
typedef struct DXTSpiral DXTSpiral;
#endif /* __cplusplus */

#endif 	/* __DXTSpiral_FWD_DEFINED__ */


#ifndef __CrZigzag_FWD_DEFINED__
#define __CrZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzag CrZigzag;
#else
typedef struct CrZigzag CrZigzag;
#endif /* __cplusplus */

#endif 	/* __CrZigzag_FWD_DEFINED__ */


#ifndef __DXTZigzag_FWD_DEFINED__
#define __DXTZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTZigzag DXTZigzag;
#else
typedef struct DXTZigzag DXTZigzag;
#endif /* __cplusplus */

#endif 	/* __DXTZigzag_FWD_DEFINED__ */


#ifndef __CrWheel_FWD_DEFINED__
#define __CrWheel_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheel CrWheel;
#else
typedef struct CrWheel CrWheel;
#endif /* __cplusplus */

#endif 	/* __CrWheel_FWD_DEFINED__ */


#ifndef __DXTChroma_FWD_DEFINED__
#define __DXTChroma_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChroma DXTChroma;
#else
typedef struct DXTChroma DXTChroma;
#endif /* __cplusplus */

#endif 	/* __DXTChroma_FWD_DEFINED__ */


#ifndef __DXTDropShadow_FWD_DEFINED__
#define __DXTDropShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadow DXTDropShadow;
#else
typedef struct DXTDropShadow DXTDropShadow;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadow_FWD_DEFINED__ */


#ifndef __DXTCheckerBoard_FWD_DEFINED__
#define __DXTCheckerBoard_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTCheckerBoard DXTCheckerBoard;
#else
typedef struct DXTCheckerBoard DXTCheckerBoard;
#endif /* __cplusplus */

#endif 	/* __DXTCheckerBoard_FWD_DEFINED__ */


#ifndef __DXTRevealTrans_FWD_DEFINED__
#define __DXTRevealTrans_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRevealTrans DXTRevealTrans;
#else
typedef struct DXTRevealTrans DXTRevealTrans;
#endif /* __cplusplus */

#endif 	/* __DXTRevealTrans_FWD_DEFINED__ */


#ifndef __DXTMaskFilter_FWD_DEFINED__
#define __DXTMaskFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMaskFilter DXTMaskFilter;
#else
typedef struct DXTMaskFilter DXTMaskFilter;
#endif /* __cplusplus */

#endif 	/* __DXTMaskFilter_FWD_DEFINED__ */


#ifndef __DXTAlphaImageLoader_FWD_DEFINED__
#define __DXTAlphaImageLoader_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlphaImageLoader DXTAlphaImageLoader;
#else
typedef struct DXTAlphaImageLoader DXTAlphaImageLoader;
#endif /* __cplusplus */

#endif 	/* __DXTAlphaImageLoader_FWD_DEFINED__ */


#ifndef __DXTRandomDissolve_FWD_DEFINED__
#define __DXTRandomDissolve_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRandomDissolve DXTRandomDissolve;
#else
typedef struct DXTRandomDissolve DXTRandomDissolve;
#endif /* __cplusplus */

#endif 	/* __DXTRandomDissolve_FWD_DEFINED__ */


#ifndef __DXTRandomBars_FWD_DEFINED__
#define __DXTRandomBars_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRandomBars DXTRandomBars;
#else
typedef struct DXTRandomBars DXTRandomBars;
#endif /* __cplusplus */

#endif 	/* __DXTRandomBars_FWD_DEFINED__ */


#ifndef __DXTStrips_FWD_DEFINED__
#define __DXTStrips_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTStrips DXTStrips;
#else
typedef struct DXTStrips DXTStrips;
#endif /* __cplusplus */

#endif 	/* __DXTStrips_FWD_DEFINED__ */


#ifndef __DXTGlow_FWD_DEFINED__
#define __DXTGlow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGlow DXTGlow;
#else
typedef struct DXTGlow DXTGlow;
#endif /* __cplusplus */

#endif 	/* __DXTGlow_FWD_DEFINED__ */


#ifndef __DXTShadow_FWD_DEFINED__
#define __DXTShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShadow DXTShadow;
#else
typedef struct DXTShadow DXTShadow;
#endif /* __cplusplus */

#endif 	/* __DXTShadow_FWD_DEFINED__ */


#ifndef __DXTAlpha_FWD_DEFINED__
#define __DXTAlpha_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTAlpha DXTAlpha;
#else
typedef struct DXTAlpha DXTAlpha;
#endif /* __cplusplus */

#endif 	/* __DXTAlpha_FWD_DEFINED__ */


#ifndef __DXTWave_FWD_DEFINED__
#define __DXTWave_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWave DXTWave;
#else
typedef struct DXTWave DXTWave;
#endif /* __cplusplus */

#endif 	/* __DXTWave_FWD_DEFINED__ */


#ifndef __DXTLight_FWD_DEFINED__
#define __DXTLight_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLight DXTLight;
#else
typedef struct DXTLight DXTLight;
#endif /* __cplusplus */

#endif 	/* __DXTLight_FWD_DEFINED__ */


#ifndef __DXTMotionBlur_FWD_DEFINED__
#define __DXTMotionBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMotionBlur DXTMotionBlur;
#else
typedef struct DXTMotionBlur DXTMotionBlur;
#endif /* __cplusplus */

#endif 	/* __DXTMotionBlur_FWD_DEFINED__ */


#ifndef __DXTMatrix_FWD_DEFINED__
#define __DXTMatrix_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMatrix DXTMatrix;
#else
typedef struct DXTMatrix DXTMatrix;
#endif /* __cplusplus */

#endif 	/* __DXTMatrix_FWD_DEFINED__ */


#ifndef __DXTICMFilter_FWD_DEFINED__
#define __DXTICMFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTICMFilter DXTICMFilter;
#else
typedef struct DXTICMFilter DXTICMFilter;
#endif /* __cplusplus */

#endif 	/* __DXTICMFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft_0000 */
/* [local] */ 

#include <dxtmsft3.h>





//
//   DXTransforms Image Transforms Type Library Version Info
//
#define DXTMSFT_TLB_MAJOR_VER 1
#define DXTMSFT_TLB_MINOR_VER 1
typedef 
enum OPIDDXLUTBUILDER
    {	OPID_DXLUTBUILDER_Gamma	= 0,
	OPID_DXLUTBUILDER_Opacity	= OPID_DXLUTBUILDER_Gamma + 1,
	OPID_DXLUTBUILDER_Brightness	= OPID_DXLUTBUILDER_Opacity + 1,
	OPID_DXLUTBUILDER_Contrast	= OPID_DXLUTBUILDER_Brightness + 1,
	OPID_DXLUTBUILDER_ColorBalance	= OPID_DXLUTBUILDER_Contrast + 1,
	OPID_DXLUTBUILDER_Posterize	= OPID_DXLUTBUILDER_ColorBalance + 1,
	OPID_DXLUTBUILDER_Invert	= OPID_DXLUTBUILDER_Posterize + 1,
	OPID_DXLUTBUILDER_Threshold	= OPID_DXLUTBUILDER_Invert + 1,
	OPID_DXLUTBUILDER_NUM_OPS	= OPID_DXLUTBUILDER_Threshold + 1
    }	OPIDDXLUTBUILDER;

typedef 
enum DXLUTCOLOR
    {	DXLUTCOLOR_RED	= 0,
	DXLUTCOLOR_GREEN	= DXLUTCOLOR_RED + 1,
	DXLUTCOLOR_BLUE	= DXLUTCOLOR_GREEN + 1
    }	DXLUTCOLOR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_s_ifspec;

#ifndef __IDXLUTBuilder_INTERFACE_DEFINED__
#define __IDXLUTBuilder_INTERFACE_DEFINED__

/* interface IDXLUTBuilder */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4370FC1-CADB-11D0-B52C-00A0C9054373")
    IDXLUTBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumBuildSteps( 
            /* [out] */ ULONG __RPC_FAR *pulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuildOrder( 
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBuildOrder( 
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGamma( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGamma( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrightness( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrightness( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContrast( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContrast( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevelsPerChannel( 
            /* [out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLevelsPerChannel( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInvert( 
            /* [out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInvert( 
            /* [in] */ float Threshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreshold( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumBuildSteps )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pThreshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXLUTBuilderVtbl;

    interface IDXLUTBuilder
    {
        CONST_VTBL struct IDXLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLUTBuilder_GetNumBuildSteps(This,pulNumSteps)	\
    (This)->lpVtbl -> GetNumBuildSteps(This,pulNumSteps)

#define IDXLUTBuilder_GetBuildOrder(This,OpOrder,ulSize)	\
    (This)->lpVtbl -> GetBuildOrder(This,OpOrder,ulSize)

#define IDXLUTBuilder_SetBuildOrder(This,OpOrder,ulNumSteps)	\
    (This)->lpVtbl -> SetBuildOrder(This,OpOrder,ulNumSteps)

#define IDXLUTBuilder_SetGamma(This,newVal)	\
    (This)->lpVtbl -> SetGamma(This,newVal)

#define IDXLUTBuilder_GetGamma(This,pVal)	\
    (This)->lpVtbl -> GetGamma(This,pVal)

#define IDXLUTBuilder_GetOpacity(This,pVal)	\
    (This)->lpVtbl -> GetOpacity(This,pVal)

#define IDXLUTBuilder_SetOpacity(This,newVal)	\
    (This)->lpVtbl -> SetOpacity(This,newVal)

#define IDXLUTBuilder_GetBrightness(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetBrightness(This,pulCount,Weights)

#define IDXLUTBuilder_SetBrightness(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetBrightness(This,ulCount,Weights)

#define IDXLUTBuilder_GetContrast(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetContrast(This,pulCount,Weights)

#define IDXLUTBuilder_SetContrast(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetContrast(This,ulCount,Weights)

#define IDXLUTBuilder_GetColorBalance(This,Color,pulCount,Weights)	\
    (This)->lpVtbl -> GetColorBalance(This,Color,pulCount,Weights)

#define IDXLUTBuilder_SetColorBalance(This,Color,ulCount,Weights)	\
    (This)->lpVtbl -> SetColorBalance(This,Color,ulCount,Weights)

#define IDXLUTBuilder_GetLevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> GetLevelsPerChannel(This,pVal)

#define IDXLUTBuilder_SetLevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> SetLevelsPerChannel(This,newVal)

#define IDXLUTBuilder_GetInvert(This,pThreshold)	\
    (This)->lpVtbl -> GetInvert(This,pThreshold)

#define IDXLUTBuilder_SetInvert(This,Threshold)	\
    (This)->lpVtbl -> SetInvert(This,Threshold)

#define IDXLUTBuilder_GetThreshold(This,pVal)	\
    (This)->lpVtbl -> GetThreshold(This,pVal)

#define IDXLUTBuilder_SetThreshold(This,newVal)	\
    (This)->lpVtbl -> SetThreshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetNumBuildSteps_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumSteps);


void __RPC_STUB IDXLUTBuilder_GetNumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulSize);


void __RPC_STUB IDXLUTBuilder_GetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulNumSteps);


void __RPC_STUB IDXLUTBuilder_SetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IDXLUTBuilder_SetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXLUTBuilder_GetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXLUTBuilder_SetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLUTBuilder_INTERFACE_DEFINED__ */


#ifndef __IDXDLUTBuilder_INTERFACE_DEFINED__
#define __IDXDLUTBuilder_INTERFACE_DEFINED__

/* interface IDXDLUTBuilder */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73068231-35EE-11d1-81A1-0000F87557DB")
    IDXDLUTBuilder : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumBuildSteps( 
            /* [retval][out] */ long __RPC_FAR *pNumSteps) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BuildOrder( 
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BuildOrder( 
            /* [in] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Gamma( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Gamma( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Brightness( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Brightness( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Contrast( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Contrast( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LevelsPerChannel( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LevelsPerChannel( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ float Threshold) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Threshold( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Threshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumBuildSteps )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pNumSteps);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pThreshold);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXDLUTBuilderVtbl;

    interface IDXDLUTBuilder
    {
        CONST_VTBL struct IDXDLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDLUTBuilder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDLUTBuilder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDLUTBuilder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDLUTBuilder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDLUTBuilder_get_NumBuildSteps(This,pNumSteps)	\
    (This)->lpVtbl -> get_NumBuildSteps(This,pNumSteps)

#define IDXDLUTBuilder_get_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> get_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_put_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> put_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_get_Gamma(This,pVal)	\
    (This)->lpVtbl -> get_Gamma(This,pVal)

#define IDXDLUTBuilder_put_Gamma(This,newVal)	\
    (This)->lpVtbl -> put_Gamma(This,newVal)

#define IDXDLUTBuilder_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXDLUTBuilder_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXDLUTBuilder_get_Brightness(This,pWeights)	\
    (This)->lpVtbl -> get_Brightness(This,pWeights)

#define IDXDLUTBuilder_put_Brightness(This,pWeights)	\
    (This)->lpVtbl -> put_Brightness(This,pWeights)

#define IDXDLUTBuilder_get_Contrast(This,pWeights)	\
    (This)->lpVtbl -> get_Contrast(This,pWeights)

#define IDXDLUTBuilder_put_Contrast(This,pWeights)	\
    (This)->lpVtbl -> put_Contrast(This,pWeights)

#define IDXDLUTBuilder_get_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> get_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_put_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> put_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_get_LevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> get_LevelsPerChannel(This,pVal)

#define IDXDLUTBuilder_put_LevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> put_LevelsPerChannel(This,newVal)

#define IDXDLUTBuilder_get_Invert(This,pThreshold)	\
    (This)->lpVtbl -> get_Invert(This,pThreshold)

#define IDXDLUTBuilder_put_Invert(This,Threshold)	\
    (This)->lpVtbl -> put_Invert(This,Threshold)

#define IDXDLUTBuilder_get_Threshold(This,pVal)	\
    (This)->lpVtbl -> get_Threshold(This,pVal)

#define IDXDLUTBuilder_put_Threshold(This,newVal)	\
    (This)->lpVtbl -> put_Threshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_NumBuildSteps_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pNumSteps);


void __RPC_STUB IDXDLUTBuilder_get_NumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_get_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_put_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXDLUTBuilder_put_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXDLUTBuilder_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXDLUTBuilder_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDLUTBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0184 */
/* [local] */ 

typedef 
enum DXGRADIENTTYPE
    {	DXGRADIENT_VERTICAL	= 0,
	DXGRADIENT_HORIZONTAL	= DXGRADIENT_VERTICAL + 1,
	DXGRADIENT_NUM_GRADIENTS	= DXGRADIENT_HORIZONTAL + 1
    }	DXGRADIENTTYPE;

typedef 
enum DXGRADDISPID
    {	DISPID_GradientType	= 1,
	DISPID_StartColor	= DISPID_GradientType + 1,
	DISPID_EndColor	= DISPID_StartColor + 1,
	DISPID_GradientWidth	= DISPID_EndColor + 1,
	DISPID_GradientHeight	= DISPID_GradientWidth + 1,
	DISPID_GradientAspect	= DISPID_GradientHeight + 1,
	DISPID_StartColorStr	= DISPID_GradientAspect + 1,
	DISPID_EndColorStr	= DISPID_StartColorStr + 1
    }	DXGRADDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0184_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0184_v0_0_s_ifspec;

#ifndef __IDXTGradientD_INTERFACE_DEFINED__
#define __IDXTGradientD_INTERFACE_DEFINED__

/* interface IDXTGradientD */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGradientD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("623E2881-FC0E-11d1-9A77-0000F8756A10")
    IDXTGradientD : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientType( 
            /* [in] */ DXGRADIENTTYPE eType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientType( 
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientHeight( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColorStr( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColorStr( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGradientDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTGradientD __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTGradientD __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTGradientD __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DXGRADIENTTYPE eType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDXTGradientDVtbl;

    interface IDXTGradientD
    {
        CONST_VTBL struct IDXTGradientDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGradientD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGradientD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGradientD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGradientD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGradientD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGradientD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGradientD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGradientD_put_GradientType(This,eType)	\
    (This)->lpVtbl -> put_GradientType(This,eType)

#define IDXTGradientD_get_GradientType(This,peType)	\
    (This)->lpVtbl -> get_GradientType(This,peType)

#define IDXTGradientD_put_StartColor(This,newVal)	\
    (This)->lpVtbl -> put_StartColor(This,newVal)

#define IDXTGradientD_get_StartColor(This,pVal)	\
    (This)->lpVtbl -> get_StartColor(This,pVal)

#define IDXTGradientD_put_EndColor(This,newVal)	\
    (This)->lpVtbl -> put_EndColor(This,newVal)

#define IDXTGradientD_get_EndColor(This,pVal)	\
    (This)->lpVtbl -> get_EndColor(This,pVal)

#define IDXTGradientD_put_GradientWidth(This,newVal)	\
    (This)->lpVtbl -> put_GradientWidth(This,newVal)

#define IDXTGradientD_get_GradientWidth(This,pVal)	\
    (This)->lpVtbl -> get_GradientWidth(This,pVal)

#define IDXTGradientD_put_GradientHeight(This,newVal)	\
    (This)->lpVtbl -> put_GradientHeight(This,newVal)

#define IDXTGradientD_get_GradientHeight(This,pVal)	\
    (This)->lpVtbl -> get_GradientHeight(This,pVal)

#define IDXTGradientD_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#define IDXTGradientD_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTGradientD_put_StartColorStr(This,newVal)	\
    (This)->lpVtbl -> put_StartColorStr(This,newVal)

#define IDXTGradientD_get_StartColorStr(This,pVal)	\
    (This)->lpVtbl -> get_StartColorStr(This,pVal)

#define IDXTGradientD_put_EndColorStr(This,newVal)	\
    (This)->lpVtbl -> put_EndColorStr(This,newVal)

#define IDXTGradientD_get_EndColorStr(This,pVal)	\
    (This)->lpVtbl -> get_EndColorStr(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ DXGRADIENTTYPE eType);


void __RPC_STUB IDXTGradientD_put_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTGradientD_get_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTGradientD_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGradientD_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0185 */
/* [local] */ 

typedef 
enum DXCONVFILTERTYPE
    {	DXCFILTER_SRCCOPY	= 0,
	DXCFILTER_BOX7X7	= DXCFILTER_SRCCOPY + 1,
	DXCFILTER_BLUR3X3	= DXCFILTER_BOX7X7 + 1,
	DXCFILTER_SHARPEN	= DXCFILTER_BLUR3X3 + 1,
	DXCFILTER_EMBOSS	= DXCFILTER_SHARPEN + 1,
	DXCFILTER_ENGRAVE	= DXCFILTER_EMBOSS + 1,
	DXCFILTER_NUM_FILTERS	= DXCFILTER_ENGRAVE + 1,
	DXCFILTER_CUSTOM	= DXCFILTER_NUM_FILTERS + 1
    }	DXCONVFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0185_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0185_v0_0_s_ifspec;

#ifndef __IDXTConvolution_INTERFACE_DEFINED__
#define __IDXTConvolution_INTERFACE_DEFINED__

/* interface IDXTConvolution */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTConvolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7BA7F8AF-E5EA-11d1-81DD-0000F87557DB")
    IDXTConvolution : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXCONVFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomFilter( 
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConvertToGray( 
            /* [in] */ BOOL bConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConvertToGray( 
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBias( 
            /* [in] */ float Bias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBias( 
            /* [out] */ float __RPC_FAR *pBias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExcludeAlpha( 
            /* [in] */ BOOL bExcludeAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExcludeAlpha( 
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTConvolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTConvolution __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTConvolution __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ DXCONVFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomFilter )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float Bias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pBias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bExcludeAlpha);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);
        
        END_INTERFACE
    } IDXTConvolutionVtbl;

    interface IDXTConvolution
    {
        CONST_VTBL struct IDXTConvolutionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTConvolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTConvolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTConvolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTConvolution_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXTConvolution_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXTConvolution_SetCustomFilter(This,pFilter,Size)	\
    (This)->lpVtbl -> SetCustomFilter(This,pFilter,Size)

#define IDXTConvolution_SetConvertToGray(This,bConvertToGray)	\
    (This)->lpVtbl -> SetConvertToGray(This,bConvertToGray)

#define IDXTConvolution_GetConvertToGray(This,pbConvertToGray)	\
    (This)->lpVtbl -> GetConvertToGray(This,pbConvertToGray)

#define IDXTConvolution_SetBias(This,Bias)	\
    (This)->lpVtbl -> SetBias(This,Bias)

#define IDXTConvolution_GetBias(This,pBias)	\
    (This)->lpVtbl -> GetBias(This,pBias)

#define IDXTConvolution_SetExcludeAlpha(This,bExcludeAlpha)	\
    (This)->lpVtbl -> SetExcludeAlpha(This,bExcludeAlpha)

#define IDXTConvolution_GetExcludeAlpha(This,pbExcludeAlpha)	\
    (This)->lpVtbl -> GetExcludeAlpha(This,pbExcludeAlpha)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTConvolution_SetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ DXCONVFILTERTYPE eType);


void __RPC_STUB IDXTConvolution_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTConvolution_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetCustomFilter_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float __RPC_FAR *pFilter,
    /* [in] */ SIZE Size);


void __RPC_STUB IDXTConvolution_SetCustomFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bConvertToGray);


void __RPC_STUB IDXTConvolution_SetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbConvertToGray);


void __RPC_STUB IDXTConvolution_GetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float Bias);


void __RPC_STUB IDXTConvolution_SetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pBias);


void __RPC_STUB IDXTConvolution_GetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bExcludeAlpha);


void __RPC_STUB IDXTConvolution_SetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);


void __RPC_STUB IDXTConvolution_GetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTConvolution_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0186 */
/* [local] */ 

typedef 
enum DXCOMPFUNC
    {	DXCOMPFUNC_SWAP_AB	= 0x10,
	DXCOMPFUNC_FUNCMASK	= 0xf,
	DXCOMPFUNC_CLEAR	= 0,
	DXCOMPFUNC_MIN	= DXCOMPFUNC_CLEAR + 1,
	DXCOMPFUNC_MAX	= DXCOMPFUNC_MIN + 1,
	DXCOMPFUNC_A	= DXCOMPFUNC_MAX + 1,
	DXCOMPFUNC_A_OVER_B	= DXCOMPFUNC_A + 1,
	DXCOMPFUNC_A_IN_B	= DXCOMPFUNC_A_OVER_B + 1,
	DXCOMPFUNC_A_OUT_B	= DXCOMPFUNC_A_IN_B + 1,
	DXCOMPFUNC_A_ATOP_B	= DXCOMPFUNC_A_OUT_B + 1,
	DXCOMPFUNC_A_SUBTRACT_B	= DXCOMPFUNC_A_ATOP_B + 1,
	DXCOMPFUNC_A_ADD_B	= DXCOMPFUNC_A_SUBTRACT_B + 1,
	DXCOMPFUNC_A_XOR_B	= DXCOMPFUNC_A_ADD_B + 1,
	DXCOMPFUNC_B	= DXCOMPFUNC_A | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OVER_A	= DXCOMPFUNC_A_OVER_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_IN_A	= DXCOMPFUNC_A_IN_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OUT_A	= DXCOMPFUNC_A_OUT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ATOP_A	= DXCOMPFUNC_A_ATOP_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_SUBTRACT_A	= DXCOMPFUNC_A_SUBTRACT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ADD_A	= DXCOMPFUNC_A_ADD_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_NUMFUNCS	= DXCOMPFUNC_B_ADD_A + 1
    }	DXCOMPFUNC;

typedef 
enum DXCOMPOSITEDISPID
    {	DISPID_DXCOMPOSITE_Function	= 1
    }	DXCOMPOSITEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0186_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0186_v0_0_s_ifspec;

#ifndef __IDXTComposite_INTERFACE_DEFINED__
#define __IDXTComposite_INTERFACE_DEFINED__

/* interface IDXTComposite */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTComposite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A43A843-0831-11D1-817F-0000F87557DB")
    IDXTComposite : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Function( 
            /* [in] */ DXCOMPFUNC eFunc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Function( 
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCompositeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTComposite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTComposite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTComposite __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DXCOMPFUNC eFunc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);
        
        END_INTERFACE
    } IDXTCompositeVtbl;

    interface IDXTComposite
    {
        CONST_VTBL struct IDXTCompositeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTComposite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTComposite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTComposite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTComposite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTComposite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTComposite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTComposite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTComposite_put_Function(This,eFunc)	\
    (This)->lpVtbl -> put_Function(This,eFunc)

#define IDXTComposite_get_Function(This,peFunc)	\
    (This)->lpVtbl -> get_Function(This,peFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTComposite_put_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [in] */ DXCOMPFUNC eFunc);


void __RPC_STUB IDXTComposite_put_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTComposite_get_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);


void __RPC_STUB IDXTComposite_get_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTComposite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0187 */
/* [local] */ 

typedef 
enum DXWIPEDIRECTION
    {	DXWD_HORIZONTAL	= 0,
	DXWD_VERTICAL	= DXWD_HORIZONTAL + 1
    }	DXWIPEDIRECTION;

typedef 
enum DXWIPEDISPID
    {	DISPID_DXW_GradientSize	= DISPID_DXE_NEXT_ID,
	DISPID_DXW_WipeStyle	= DISPID_DXW_GradientSize + 1,
	DISPID_DXW_Motion	= DISPID_DXW_WipeStyle + 1
    }	DXWIPEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0187_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0187_v0_0_s_ifspec;

#ifndef __IDXTWipe_INTERFACE_DEFINED__
#define __IDXTWipe_INTERFACE_DEFINED__

/* interface IDXTWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF279B2F-86EB-11D1-81BF-0000F87557DB")
    IDXTWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientSize( 
            /* [retval][out] */ float __RPC_FAR *pPercentSize) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientSize( 
            /* [in] */ float PercentSize) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WipeStyle( 
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WipeStyle( 
            /* [in] */ DXWIPEDIRECTION newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        END_INTERFACE
    } IDXTWipeVtbl;

    interface IDXTWipe
    {
        CONST_VTBL struct IDXTWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPercentSize);


void __RPC_STUB IDXTWipe_get_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ float PercentSize);


void __RPC_STUB IDXTWipe_put_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);


void __RPC_STUB IDXTWipe_get_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ DXWIPEDIRECTION newVal);


void __RPC_STUB IDXTWipe_put_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTWipe2_INTERFACE_DEFINED__
#define __IDXTWipe2_INTERFACE_DEFINED__

/* interface IDXTWipe2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E1FF8091-442B-4801-88B6-2B47B1611FD2")
    IDXTWipe2 : public IDXTWipe
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipe2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTWipe2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTWipe2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientSize )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientSize )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WipeStyle )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WipeStyle )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Motion )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Motion )( 
            IDXTWipe2 __RPC_FAR * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } IDXTWipe2Vtbl;

    interface IDXTWipe2
    {
        CONST_VTBL struct IDXTWipe2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe2_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe2_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe2_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe2_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)


#define IDXTWipe2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define IDXTWipe2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe2_get_Motion_Proxy( 
    IDXTWipe2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);


void __RPC_STUB IDXTWipe2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe2_put_Motion_Proxy( 
    IDXTWipe2 __RPC_FAR * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB IDXTWipe2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0189 */
/* [local] */ 

typedef 
enum CRBLURDISPID
    {	DISPID_CRB_MakeShadow	= 1,
	DISPID_CRB_ShadowOpacity	= DISPID_CRB_MakeShadow + 1,
	DISPID_CRB_PixelRadius	= DISPID_CRB_ShadowOpacity + 1
    }	CRBLURDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0189_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0189_v0_0_s_ifspec;

#ifndef __ICrBlur_INTERFACE_DEFINED__
#define __ICrBlur_INTERFACE_DEFINED__

/* interface ICrBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F7C7827-E87A-11d1-81E0-0000F87557DB")
    ICrBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MakeShadow( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MakeShadow( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShadowOpacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShadowOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PixelRadius( 
            /* [retval][out] */ float __RPC_FAR *pPixelRadius) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PixelRadius( 
            /* [in] */ float PixelRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlur __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlur __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlur __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPixelRadius);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float PixelRadius);
        
        END_INTERFACE
    } ICrBlurVtbl;

    interface ICrBlur
    {
        CONST_VTBL struct ICrBlurVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlur_get_MakeShadow(This,pVal)	\
    (This)->lpVtbl -> get_MakeShadow(This,pVal)

#define ICrBlur_put_MakeShadow(This,newVal)	\
    (This)->lpVtbl -> put_MakeShadow(This,newVal)

#define ICrBlur_get_ShadowOpacity(This,pVal)	\
    (This)->lpVtbl -> get_ShadowOpacity(This,pVal)

#define ICrBlur_put_ShadowOpacity(This,newVal)	\
    (This)->lpVtbl -> put_ShadowOpacity(This,newVal)

#define ICrBlur_get_PixelRadius(This,pPixelRadius)	\
    (This)->lpVtbl -> get_PixelRadius(This,pPixelRadius)

#define ICrBlur_put_PixelRadius(This,PixelRadius)	\
    (This)->lpVtbl -> put_PixelRadius(This,PixelRadius)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB ICrBlur_put_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrBlur_put_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPixelRadius);


void __RPC_STUB ICrBlur_get_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float PixelRadius);


void __RPC_STUB ICrBlur_put_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0190 */
/* [local] */ 

typedef 
enum CRENGRAVEDISPID
    {	DISPID_CREN_Bias	= 1
    }	CRENGRAVEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0190_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0190_v0_0_s_ifspec;

#ifndef __ICrEngrave_INTERFACE_DEFINED__
#define __ICrEngrave_INTERFACE_DEFINED__

/* interface ICrEngrave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEngrave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB7F-053E-11d2-81EA-0000F87557DB")
    ICrEngrave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEngraveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEngrave __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEngrave __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEngrave __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEngraveVtbl;

    interface ICrEngrave
    {
        CONST_VTBL struct ICrEngraveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEngrave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEngrave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEngrave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEngrave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEngrave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEngrave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEngrave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEngrave_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEngrave_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEngrave_get_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEngrave_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEngrave_put_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEngrave_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEngrave_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0191 */
/* [local] */ 

typedef 
enum CREMBOSSDISPID
    {	DISPID_CREM_Bias	= 1
    }	CREMBOSSDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0191_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0191_v0_0_s_ifspec;

#ifndef __ICrEmboss_INTERFACE_DEFINED__
#define __ICrEmboss_INTERFACE_DEFINED__

/* interface ICrEmboss */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEmboss;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB80-053E-11d2-81EA-0000F87557DB")
    ICrEmboss : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEmbossVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEmboss __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEmboss __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEmboss __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEmbossVtbl;

    interface ICrEmboss
    {
        CONST_VTBL struct ICrEmbossVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEmboss_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEmboss_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEmboss_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEmboss_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEmboss_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEmboss_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEmboss_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEmboss_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEmboss_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEmboss_get_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEmboss_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEmboss_put_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEmboss_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEmboss_INTERFACE_DEFINED__ */


#ifndef __IDXTFade_INTERFACE_DEFINED__
#define __IDXTFade_INTERFACE_DEFINED__

/* interface IDXTFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C4-EE70-11D1-9066-00C04FD9189D")
    IDXTFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Overlap( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Overlap( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Center( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Center( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTFade __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTFade __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTFade __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IDXTFadeVtbl;

    interface IDXTFade
    {
        CONST_VTBL struct IDXTFadeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTFade_get_Overlap(This,pVal)	\
    (This)->lpVtbl -> get_Overlap(This,pVal)

#define IDXTFade_put_Overlap(This,newVal)	\
    (This)->lpVtbl -> put_Overlap(This,newVal)

#define IDXTFade_get_Center(This,pVal)	\
    (This)->lpVtbl -> get_Center(This,pVal)

#define IDXTFade_put_Center(This,newVal)	\
    (This)->lpVtbl -> put_Center(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTFade_put_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXTFade_put_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFade_INTERFACE_DEFINED__ */


#ifndef __IDXBasicImage_INTERFACE_DEFINED__
#define __IDXBasicImage_INTERFACE_DEFINED__

/* interface IDXBasicImage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXBasicImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C7-EE70-11D1-9066-00C04FD9189D")
    IDXBasicImage : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotation( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotation( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mirror( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mirror( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrayScale( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrayScale( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XRay( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XRay( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mask( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mask( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskColor( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskColor( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBasicImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBasicImage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBasicImage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXBasicImage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXBasicImageVtbl;

    interface IDXBasicImage
    {
        CONST_VTBL struct IDXBasicImageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBasicImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBasicImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBasicImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBasicImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXBasicImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXBasicImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXBasicImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXBasicImage_get_Rotation(This,pVal)	\
    (This)->lpVtbl -> get_Rotation(This,pVal)

#define IDXBasicImage_put_Rotation(This,newVal)	\
    (This)->lpVtbl -> put_Rotation(This,newVal)

#define IDXBasicImage_get_Mirror(This,pVal)	\
    (This)->lpVtbl -> get_Mirror(This,pVal)

#define IDXBasicImage_put_Mirror(This,newVal)	\
    (This)->lpVtbl -> put_Mirror(This,newVal)

#define IDXBasicImage_get_GrayScale(This,pVal)	\
    (This)->lpVtbl -> get_GrayScale(This,pVal)

#define IDXBasicImage_put_GrayScale(This,newVal)	\
    (This)->lpVtbl -> put_GrayScale(This,newVal)

#define IDXBasicImage_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXBasicImage_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXBasicImage_get_Invert(This,pVal)	\
    (This)->lpVtbl -> get_Invert(This,pVal)

#define IDXBasicImage_put_Invert(This,newVal)	\
    (This)->lpVtbl -> put_Invert(This,newVal)

#define IDXBasicImage_get_XRay(This,pVal)	\
    (This)->lpVtbl -> get_XRay(This,pVal)

#define IDXBasicImage_put_XRay(This,newVal)	\
    (This)->lpVtbl -> put_XRay(This,newVal)

#define IDXBasicImage_get_Mask(This,pVal)	\
    (This)->lpVtbl -> get_Mask(This,pVal)

#define IDXBasicImage_put_Mask(This,newVal)	\
    (This)->lpVtbl -> put_Mask(This,newVal)

#define IDXBasicImage_get_MaskColor(This,pVal)	\
    (This)->lpVtbl -> get_MaskColor(This,pVal)

#define IDXBasicImage_put_MaskColor(This,newVal)	\
    (This)->lpVtbl -> put_MaskColor(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXBasicImage_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBasicImage_INTERFACE_DEFINED__ */


#ifndef __IDXPixelate_INTERFACE_DEFINED__
#define __IDXPixelate_INTERFACE_DEFINED__

/* interface IDXPixelate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXPixelate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D33E180F-FBE9-11d1-906A-00C04FD9189D")
    IDXPixelate : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSquare( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSquare( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXPixelateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXPixelate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXPixelate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXPixelate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXPixelateVtbl;

    interface IDXPixelate
    {
        CONST_VTBL struct IDXPixelateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXPixelate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXPixelate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXPixelate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXPixelate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXPixelate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXPixelate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXPixelate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXPixelate_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXPixelate_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXPixelate_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXPixelate_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXPixelate_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXPixelate_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXPixelate_get_MaxSquare(This,pVal)	\
    (This)->lpVtbl -> get_MaxSquare(This,pVal)

#define IDXPixelate_put_MaxSquare(This,newVal)	\
    (This)->lpVtbl -> put_MaxSquare(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXPixelate_get_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXPixelate_get_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXPixelate_put_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXPixelate_put_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXPixelate_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0195 */
/* [local] */ 

typedef 
enum DISPID_CRIRIS
    {	DISPID_CRIRIS_IRISSTYLE	= 1,
	DISPID_CRIRIS_MOTION	= DISPID_CRIRIS_IRISSTYLE + 1
    }	DISPID_CRIRIS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0195_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0195_v0_0_s_ifspec;

#ifndef __ICrIris_INTERFACE_DEFINED__
#define __ICrIris_INTERFACE_DEFINED__

/* interface ICrIris */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F69F350-0379-11D2-A484-00C04F8EFB69")
    ICrIris : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_irisStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_irisStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIrisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrIris __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrIris __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrIris __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrIrisVtbl;

    interface ICrIris
    {
        CONST_VTBL struct ICrIrisVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris_get_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrIris_get_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris_put_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrIris_put_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris_INTERFACE_DEFINED__ */


#ifndef __ICrIris2_INTERFACE_DEFINED__
#define __ICrIris2_INTERFACE_DEFINED__

/* interface ICrIris2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7B06961-BA8C-4970-918B-1C60CB9FF180")
    ICrIris2 : public ICrIris
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIris2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrIris2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrIris2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrIris2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_irisStyle )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_irisStyle )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Motion )( 
            ICrIris2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Motion )( 
            ICrIris2 __RPC_FAR * This,
            /* [in] */ BSTR bstrMotion);
        
        END_INTERFACE
    } ICrIris2Vtbl;

    interface ICrIris2
    {
        CONST_VTBL struct ICrIris2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris2_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris2_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)


#define ICrIris2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define ICrIris2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris2_get_Motion_Proxy( 
    ICrIris2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);


void __RPC_STUB ICrIris2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris2_put_Motion_Proxy( 
    ICrIris2 __RPC_FAR * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB ICrIris2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris2_INTERFACE_DEFINED__ */


#ifndef __ICrSlide_INTERFACE_DEFINED__
#define __ICrSlide_INTERFACE_DEFINED__

/* interface ICrSlide */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSlide;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("810E402E-056B-11D2-A484-00C04F8EFB69")
    ICrSlide : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_slideStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_slideStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSlideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSlide __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSlide __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSlide __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrSlideVtbl;

    interface ICrSlide
    {
        CONST_VTBL struct ICrSlideVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSlide_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSlide_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSlide_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSlide_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSlide_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSlide_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSlide_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSlide_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSlide_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSlide_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSlide_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSlide_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSlide_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSlide_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrSlide_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#define ICrSlide_get_slideStyle(This,pVal)	\
    (This)->lpVtbl -> get_slideStyle(This,pVal)

#define ICrSlide_put_slideStyle(This,newVal)	\
    (This)->lpVtbl -> put_slideStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrSlide_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrSlide_put_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSlide_INTERFACE_DEFINED__ */


#ifndef __ICrRadialWipe_INTERFACE_DEFINED__
#define __ICrRadialWipe_INTERFACE_DEFINED__

/* interface ICrRadialWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrRadialWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("424B71AE-0695-11D2-A484-00C04F8EFB69")
    ICrRadialWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_wipeStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_wipeStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrRadialWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrRadialWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrRadialWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrRadialWipeVtbl;

    interface ICrRadialWipe
    {
        CONST_VTBL struct ICrRadialWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrRadialWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrRadialWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrRadialWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrRadialWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrRadialWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrRadialWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrRadialWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrRadialWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrRadialWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrRadialWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrRadialWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrRadialWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrRadialWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrRadialWipe_get_wipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_wipeStyle(This,pVal)

#define ICrRadialWipe_put_wipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_wipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_get_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrRadialWipe_get_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_put_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrRadialWipe_put_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrRadialWipe_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0199 */
/* [local] */ 

typedef 
enum DISPID_CRBARN
    {	DISPID_CRBARN_MOTION	= 1,
	DISPID_CRBARN_ORIENTATION	= DISPID_CRBARN_MOTION + 1
    }	DISPID_CRBARN;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0199_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0199_v0_0_s_ifspec;

#ifndef __ICrBarn_INTERFACE_DEFINED__
#define __ICrBarn_INTERFACE_DEFINED__

/* interface ICrBarn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("276A2EE0-0B5D-11D2-A484-00C04F8EFB69")
    ICrBarn : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrBarnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBarn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBarn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBarn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrBarnVtbl;

    interface ICrBarn
    {
        CONST_VTBL struct ICrBarnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrBarn_INTERFACE_DEFINED__ */


#ifndef __ICrBarn2_INTERFACE_DEFINED__
#define __ICrBarn2_INTERFACE_DEFINED__

/* interface ICrBarn2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B66A7A1B-8FC6-448C-A2EB-3C55957478A1")
    ICrBarn2 : public ICrBarn
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Motion( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Motion( 
            /* [in] */ BSTR bstrMotion) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Orientation( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Orientation( 
            /* [in] */ BSTR bstrOrientation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBarn2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBarn2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBarn2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBarn2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Motion )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Motion )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ BSTR bstrMotion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Orientation )( 
            ICrBarn2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Orientation )( 
            ICrBarn2 __RPC_FAR * This,
            /* [in] */ BSTR bstrOrientation);
        
        END_INTERFACE
    } ICrBarn2Vtbl;

    interface ICrBarn2
    {
        CONST_VTBL struct ICrBarn2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)



#define ICrBarn2_get_Motion(This,pbstrMotion)	\
    (This)->lpVtbl -> get_Motion(This,pbstrMotion)

#define ICrBarn2_put_Motion(This,bstrMotion)	\
    (This)->lpVtbl -> put_Motion(This,bstrMotion)

#define ICrBarn2_get_Orientation(This,pbstrOrientation)	\
    (This)->lpVtbl -> get_Orientation(This,pbstrOrientation)

#define ICrBarn2_put_Orientation(This,bstrOrientation)	\
    (This)->lpVtbl -> put_Orientation(This,bstrOrientation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBarn2_get_Motion_Proxy( 
    ICrBarn2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMotion);


void __RPC_STUB ICrBarn2_get_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBarn2_put_Motion_Proxy( 
    ICrBarn2 __RPC_FAR * This,
    /* [in] */ BSTR bstrMotion);


void __RPC_STUB ICrBarn2_put_Motion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBarn2_get_Orientation_Proxy( 
    ICrBarn2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrOrientation);


void __RPC_STUB ICrBarn2_get_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBarn2_put_Orientation_Proxy( 
    ICrBarn2 __RPC_FAR * This,
    /* [in] */ BSTR bstrOrientation);


void __RPC_STUB ICrBarn2_put_Orientation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBarn2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0201 */
/* [local] */ 

typedef 
enum DISPID_CRBLINDS
    {	DISPID_CRBLINDS_BANDS	= 1,
	DISPID_CRBLINDS_DIRECTION	= DISPID_CRBLINDS_BANDS + 1
    }	DISPID_CRBLINDS;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0201_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0201_v0_0_s_ifspec;

#ifndef __ICrBlinds_INTERFACE_DEFINED__
#define __ICrBlinds_INTERFACE_DEFINED__

/* interface ICrBlinds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AF5C340-0BA9-11d2-A484-00C04F8EFB69")
    ICrBlinds : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlindsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlinds __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlinds __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlinds __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrBlindsVtbl;

    interface ICrBlinds
    {
        CONST_VTBL struct ICrBlindsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds_get_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrBlinds_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds_put_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrBlinds_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds_INTERFACE_DEFINED__ */


#ifndef __ICrBlinds2_INTERFACE_DEFINED__
#define __ICrBlinds2_INTERFACE_DEFINED__

/* interface ICrBlinds2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7059D403-599A-4264-8140-641EB8AE1F64")
    ICrBlinds2 : public ICrBlinds
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ BSTR bstrDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlinds2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlinds2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlinds2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Direction )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Direction )( 
            ICrBlinds2 __RPC_FAR * This,
            /* [in] */ BSTR bstrDirection);
        
        END_INTERFACE
    } ICrBlinds2Vtbl;

    interface ICrBlinds2
    {
        CONST_VTBL struct ICrBlinds2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds2_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds2_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)


#define ICrBlinds2_get_Direction(This,pbstrDirection)	\
    (This)->lpVtbl -> get_Direction(This,pbstrDirection)

#define ICrBlinds2_put_Direction(This,bstrDirection)	\
    (This)->lpVtbl -> put_Direction(This,bstrDirection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds2_get_Direction_Proxy( 
    ICrBlinds2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDirection);


void __RPC_STUB ICrBlinds2_get_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds2_put_Direction_Proxy( 
    ICrBlinds2 __RPC_FAR * This,
    /* [in] */ BSTR bstrDirection);


void __RPC_STUB ICrBlinds2_put_Direction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds2_INTERFACE_DEFINED__ */


#ifndef __ICrInset_INTERFACE_DEFINED__
#define __ICrInset_INTERFACE_DEFINED__

/* interface ICrInset */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrInset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05C5EE20-0BA6-11d2-A484-00C04F8EFB69")
    ICrInset : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrInsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrInset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrInset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrInset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrInsetVtbl;

    interface ICrInset
    {
        CONST_VTBL struct ICrInsetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrInset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrInset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrInset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrInset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrInset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrInset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrInset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrInset_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrInset_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrInset_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrInset_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrInset_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrInset_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrInset_INTERFACE_DEFINED__ */


#ifndef __ICrStretch_INTERFACE_DEFINED__
#define __ICrStretch_INTERFACE_DEFINED__

/* interface ICrStretch */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrStretch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6684AF00-0A87-11d2-A484-00C04F8EFB69")
    ICrStretch : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stretchStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_stretchStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrStretchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrStretch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrStretch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrStretch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrStretchVtbl;

    interface ICrStretch
    {
        CONST_VTBL struct ICrStretchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrStretch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrStretch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrStretch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrStretch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrStretch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrStretch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrStretch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrStretch_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrStretch_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrStretch_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrStretch_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrStretch_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrStretch_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrStretch_get_stretchStyle(This,pVal)	\
    (This)->lpVtbl -> get_stretchStyle(This,pVal)

#define ICrStretch_put_stretchStyle(This,newVal)	\
    (This)->lpVtbl -> put_stretchStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrStretch_get_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrStretch_get_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrStretch_put_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrStretch_put_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrStretch_INTERFACE_DEFINED__ */


#ifndef __IDXTGridSize_INTERFACE_DEFINED__
#define __IDXTGridSize_INTERFACE_DEFINED__

/* interface IDXTGridSize */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGridSize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6BBE91E-FF60-11d2-8F6E-00A0C9697274")
    IDXTGridSize : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short __RPC_FAR *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGridSizeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTGridSize __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTGridSize __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTGridSize __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            IDXTGridSize __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            IDXTGridSize __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } IDXTGridSizeVtbl;

    interface IDXTGridSize
    {
        CONST_VTBL struct IDXTGridSizeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGridSize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGridSize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGridSize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGridSize_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGridSize_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGridSize_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGridSize_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGridSize_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTGridSize_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTGridSize_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTGridSize_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTGridSize_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTGridSize_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTGridSize_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define IDXTGridSize_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define IDXTGridSize_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define IDXTGridSize_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_get_gridSizeX_Proxy( 
    IDXTGridSize __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB IDXTGridSize_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_put_gridSizeX_Proxy( 
    IDXTGridSize __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB IDXTGridSize_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_get_gridSizeY_Proxy( 
    IDXTGridSize __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pY);


void __RPC_STUB IDXTGridSize_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGridSize_put_gridSizeY_Proxy( 
    IDXTGridSize __RPC_FAR * This,
    /* [in] */ short newY);


void __RPC_STUB IDXTGridSize_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGridSize_INTERFACE_DEFINED__ */


#ifndef __ICrSpiral_INTERFACE_DEFINED__
#define __ICrSpiral_INTERFACE_DEFINED__

/* interface ICrSpiral */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSpiral;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DE527A0-0C7E-11d2-A484-00C04F8EFB69")
    ICrSpiral : public IDXTGridSize
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrSpiralVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSpiral __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSpiral __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSpiral __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrSpiralVtbl;

    interface ICrSpiral
    {
        CONST_VTBL struct ICrSpiralVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSpiral_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSpiral_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSpiral_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSpiral_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSpiral_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSpiral_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSpiral_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSpiral_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSpiral_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSpiral_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSpiral_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSpiral_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSpiral_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSpiral_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrSpiral_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrSpiral_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrSpiral_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrSpiral_INTERFACE_DEFINED__ */


#ifndef __ICrZigzag_INTERFACE_DEFINED__
#define __ICrZi