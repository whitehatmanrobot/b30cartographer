)
                        dialog.SetPathToConsoleRoot();                    
                }

                // select the snap-in
                dialog.SelectAvailableSnapIn(snapIn);

                // Wait up to 1 second for the snapin to be selected
                UISynchronization.WaitForUIObjectReady(dialog, timeout);

                // we need this below to determine if the snap-in has finished adding
                int addedCount = dialog.Controls.AddedSnapinsList.Count;

                // add the snap-in
                dialog.ClickAdd();

                // if there is a wizard handler, handle the wizard
                if (snapIn.WizardHandler != null)
                {
                    // handle snap-in Wizard, if handler is provided
                    snapIn.WizardHandler(this, snapIn, new SnapinWizard(this, dialog));
                }

                // Wait until the snap-in is added to the added list
                {
                    DateTime addTimeout = DateTime.Now.AddMilliseconds(snapIn.AddSnapInInitializationTimeout);                                          
                    while ((dialog.Controls.AddedSnapinsList.Count.CompareTo(addedCount) == 0) &&
                        (addTimeout.CompareTo(DateTime.Now)>0))
                    {
                        Sleeper.Delay(timeout); // wait the normal timeout length, and then check again                        
                    }
                }

                // if extensions are specified - select them, otherwise all extensions will be enabled
                if (snapIn.Extensions != null)
                {
                    // Select it in the Added list                
                    if (snapIn.AddedName != null)
                    {
                        dialog.SelectAddedSnapIn(snapIn);

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    else
                    {
                        //BUGBUG Throw and exception here
                    }

                    // Open the Extensions dialog
                    Extensions extensionsDialog = new Extensions(this, dialog);

                    // check if extensions are resource ID-s and convert them
                    for (int i = 0; i < snapIn.Extensions.Length; i++)
                        if (snapIn.Extensions[i].StartsWith(";"))
                            snapIn.Extensions[i] = GetIntlStr(snapIn.Extensions[i]);

                    // say we don't want all extensions
                    extensionsDialog.EnableOnlySelectedExtensions();

                    // initially disable every extension.  We will enable specific extensions in the next block.
                    foreach (ListViewItem extensionItem in extensionsDialog.Controls.ExtensionsList.Items)
                    {
                        extensionItem.Checked = false;
                    }

                    // choose extensions to include                    
                    foreach (string extensionName in snapIn.Extensions)
                    {
                        // enable each extension that we want to include
                        extensionsDialog.EnableExtension(extensionName);
                    }

                    // close the extensions dialog
                    extensionsDialog.ClickOK();
                }

                // if a snapin position is specified, check the current position under the
                // parent and move it up or down until it is at the specified position
                if (snapIn.Position != 0)
                {
                    // Select it in the Added list                
                    if (snapIn.AddedName != null)
                    {
                        dialog.SelectAddedSnapIn(snapIn);

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    else
                    {
                        //BUGBUG Throw and exception here
                    }

                    // the number of items at the same indent level as the added snap-in
                    int indentLevelItems = 0;

                    // obtain the indent level of the added snap-in
                    int indentLevel = dialog.Controls.AddedSnapinsList.Items[snapIn.AddedName].Indentation;

                    // get the starting index number
                    int currentIndex = dialog.Controls.AddedSnapinsList.Items[snapIn.Path].Index +1 ;

                    // get the first item to evaluate
                    ListViewItem currentItem = dialog.Controls.AddedSnapinsList.Items[currentIndex];

                    // as long as we don't drop down to the level of the parent and have more items, keep looking
                    while ((currentItem.Indentation >= indentLevel) && (currentIndex < dialog.Controls.AddedSnapinsList.Items.Count))
                    {
                        // evaluate the next item
                        currentIndex++;                        
                        currentItem = dialog.Controls.AddedSnapinsList.Items[currentIndex];

                        // if it is on the same level, count it so we know how many items are siblings
                        if (currentItem.Indentation == indentLevel)
                        {
                            indentLevelItems++;
                        }
                    }

                    // Move the item up if it is too far down
                    if (indentLevelItems < snapIn.Position)
                        for (int i = indentLevelItems; i < snapIn.Position; i++)
                        {
                            dialog.ClickMoveUp();
                        }

                    // Move the item down if it is too far up
                    if (indentLevelItems > snapIn.Position)
                        for (int i = snapIn.Position; i < indentLevelItems; i++)
                        {
                            dialog.ClickMoveDown();
                        }
                }
            }

            // close the add or remove snapins dialog and wait for app to load everything
            dialog.ClickOK();
        }

        /// <summary>
        ///		Adds particular snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to add.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///     [faisalb]   3/22/2005   Added WaitFor methods. MMC is now block the UI after adding SnapIn and waits for SnapIn to complete.
        /// </history>
        private void AddStandaloneSnapin(Snapin snapIn)
        {
            int timeout = 5000;
            int IdleTime = 500;
            // Open the Add Standalone Snapin Dialog
            AddStandaloneSnapinDialog stdDialog = new AddStandaloneSnapinDialog(this);
            stdDialog.Snapin = snapIn.Name;

            stdDialog.ClickAdd();
            if (snapIn.WizardHandler != null)
            {
                // handle snap-in Wizard, if handler is provided
                snapIn.WizardHandler(this, snapIn, new SnapinWizard(this, stdDialog));
            }
            this.Process.WaitForIdle(IdleTime, timeout);
            UISynchronization.WaitForUIObjectReady(stdDialog, timeout);
            stdDialog.ClickClose();
        }

        /// <summary>
        /// Removes specified snap-in.
        /// </summary>
        /// <param name="snapIn">Snap-in to remove.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void RemoveSnapin(Snapin snapIn)
        {
            RemoveSnapins(new Snapin[] { snapIn });
        }

        //BUGBUG - Add an overload for Remove that removes a specific instance.

        /// <summary>
        /// Removes specified snap-ins.
        /// </summary>
        /// <param name="snapIns">Snap-ins to remove.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///             [michsny]   12/28/2004  Added handling for new dialog and path in old dialog
        /// </history>
        public void RemoveSnapins(Snapin[] snapIns)
        {
            Boolean usingNewUI = AddRemoveIsUsingNewUI();

            if (usingNewUI == false)
            {
                // launch the MMC 2.0 add/remove dialog
                AddRemoveSnapinDialog dialog = new AddRemoveSnapinDialog(this);

                // remove snap-ins one-by-one
                foreach (Snapin snapIn in snapIns)
                {
                    // check if snap-in name is resource ID - then convert it
                    if (snapIn.Name.StartsWith(";"))
                        snapIn.Name = GetIntlStr(snapIn.Name);

                    // select the path
                    if (snapIn.Path != null)
                        dialog.SetPath(snapIn.Path);                    

                    // select the snap-in                    
                    dialog.Controls.AddedSnapinsListView.Items[snapIn.Name].Select();

                    // remove the snap-in
                    dialog.ClickRemove();
                }

                // close the dialog and wait for app to load everything
                dialog.ClickOK();
            }
            else
            {
                // remove the snap-ins using the new add/remove dialog
                // launch the MMC 2.1 add/remove dialog
                AddOrRemoveSnapInsDialog dialog = new AddOrRemoveSnapInsDialog(this);

                // remove snap-ins one-by-one
                foreach (Snapin snapIn in snapIns)
                {
                    // check if snap-in name is resource ID - then convert it
                    if (snapIn.Name.StartsWith(";"))
                        snapIn.Name = GetIntlStr(snapIn.Name);

                    // select the snap-in in the added list
                    dialog.SelectAddedSnapIn(snapIn);      
              
                    // remove it
                    dialog.ClickRemove();
                }

                // close the dialog and wait for app to load everything
                dialog.ClickOK();
            }
        }

        private Boolean AddRemoveIsUsingNewUI()
        {
            const int osVersionLonghorn = 6;
            const string useNewUIRegKey = "Software\\Microsoft\\MMC\\UseNewUI";

            Boolean usingNewUI = false;
            int osVersion = System.Environment.OSVersion.Version.Major;

            if (osVersion == osVersionLonghorn)
            {
                usingNewUI = true;
            }
            else
            {
                try
                {                    
                    if (Microsoft.Win32.Registry.LocalMachine.OpenSubKey(useNewUIRegKey, false) != null)
                        usingNewUI = true;
                }
                catch (Registry.Exceptions.RegistryKeyNotFoundException)
                {                    
                }
            }
            return usingNewUI;
        }
        #endregion

        #region File menu commands
        /// <summary>
        ///		Handles Save alert.
        /// </summary>
        /// <param name="alertAction">How to handle the alert.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private void HandleSaveAlert(AlertAction alertAction)
        {
            Alert alert = null;
            try
            {
                string text = GetIntlStr(Strings.SaveAlertText);
                text = text.Replace("%1", MainWindow.Caption);
                alert = Alert.HandleAlert(text, alertAction, this.MainWindow, 2000);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                return;
            }
            catch (Window.Exceptions.InvalidHWndException)
            {
                return;
            }
            if (alert == null)
                return;
            else if (alertAction != AlertAction.NoAction)
                alert.PerformAlertAction(alertAction);
            else
                throw new GlobalExceptions.MauiException("There is unhandled Save alert dialog.");
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole()
        {
            NewConsole(AlertAction.ClickNo, CommandMethod.Default);
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <param name="handleSaveAlert">How to handle Save alert dialog if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole(AlertAction handleSaveAlert)
        {
            NewConsole(handleSaveAlert, CommandMethod.Default);
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <param name="handleSaveAlert">How to handle Save alert dialog if any.</param>
        /// <param name="method">Method to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole(AlertAction handleSaveAlert, CommandMethod method)
        {
            Commands.FileNew.Execute(this, method);
            HandleSaveAlert(handleSaveAlert);

            UISynchronization.WaitForUIObjectReady(MainWindow);
            MainWindow.WaitForResponse();
        }

        /// <summary>
        /// Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console file name.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName)
        {
            OpenConsole(fileName, AlertAction.ClickNo, CommandMethod.Default);
        }

        /// <summary>
        ///		Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console to open.</param>
        /// <param name="saveAlertAction">How to handle save alert if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName, AlertAction saveAlertAction)
        {
            OpenConsole(fileName, saveAlertAction, CommandMethod.Default);
        }

        /// <summary>
        ///		Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console to open.</param>
        /// <param name="saveAlertAction">How to handle save alert if any.</param>
        /// <param name="method">Command method to invoke command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName, AlertAction saveAlertAction, CommandMethod method)
        {
            Commands.FileOpen.Execute(this, method);
            HandleSaveAlert(saveAlertAction);

            // HACK: use the actual Open dialog when it's implemented in Maui.Windows
            Window wnd = new Window("Open", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, this, 3000);
            new TextBox(wnd, 0x47C).Text = fileName;
            new Button(wnd, "Open*", StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch).Click();
            wnd.WaitForInvalid();
            // END HACK

            HandleSaveAlert(saveAlertAction);

            UISynchronization.WaitForUIObjectReady(MainWindow);
            MainWindow.WaitForResponse();
        }

        ///-----------------------------------------------------------------------------
        /// <summary>
        /// Send an ALT+F4 and wait for process to go away
        /// </summary>
        /// <returns>If an alert appears, we'll return an intialized Alert object</returns>
        /// <remarks>Any more involved functionality should be overridden in inherited classes</remarks>
        /// <history>
        ///		[yiqingdu]   906/17/2004    Converted old Quit method of App.vb to C# from VB.
        /// </history>
        ///-----------------------------------------------------------------------------
        private Alert QuitStart()
        {
            Sleeper quitSleeper = new Sleeper(Strings.QuitTimeout);
            Alert objAlert = null;
            try
            {
                this.SendKeys("%{F4}");
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // We expect this exception since we've shut it down
            }


            while ((objAlert == null) && (quitSleeper.IsNotExpired) && this.IsRunning)
            {
                try
                {
                    objAlert = Alert.HandleAlert("", AlertAction.NoAction, this.MainWindow, 200);
                }
                catch (Window.Exceptions.WindowNotFoundException)
                {
                    // We expect this exception since we've shut it down
                }
                catch (Window.Exceptions.InvalidHWndException)
                {
                    // We expect this exception since we've shut it down
                }

                quitSleeper.Sleep();
            }

            if (objAlert != null)
                return objAlert;

            if (this.IsRunning)
                throw new Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");

            return null;
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[yiqingdu]	6/17/2004	Modified to use QuitStart.
        /// </history>
        public override void Quit()
        {
            Alert alert = QuitStart();
            if (alert != null)
                alert.PerformAlertAction(AlertAction.ClickNo);

            Sleeper sleeper = new Sleeper(Strings.QuitTimeout);
            while (this.IsRunning && sleeper.IsNotExpired)
            {
                sleeper.Sleep();
            }

            if (this.IsRunning)
                throw new Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <param name="saveAlertAction">How to handle Save alert if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Quit(AlertAction saveAlertAction)
        {
            Quit(saveAlertAction, CommandMethod.MainMenu);
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <param name="saveAlertAction">How to handle Save alert if any.</param>
        /// <param name="method">How to invoke Quit command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Quit(AlertAction saveAlertAction, CommandMethod method)
        {
            Commands.FileExit.Execute(this, method);
            Sleeper quitSleeper = new Sleeper(10000);

            while (quitSleeper.IsNotExpired && IsRunning)
                HandleSaveAlert(saveAlertAction);

            if (IsRunning)
                throw new App.Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");
        }
        #endregion

        #region Window menu commands
        /// <summary>
        ///		Layouts console windows in cascade.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Cascade()
        {
            Commands.WindowCascade.Execute(this);
        }

        /// <summary>
        ///		Tiles console windows horizontally.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void TileHorizontally()
        {
            Commands.WindowTileHorizontally.Execute(this);
        }

        /// <summary>
        ///		Arranges console window icons in the MDI container.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void ArrangeIcons()
        {
            Commands.WindowArrangeIcons.Execute(this);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\AddStandaloneSnapInDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region IAddStandaloneSnapinDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddStandaloneSnapinDialogControls
    {
        ListView AvailableStandaloneSnapinsListView  {get;}
        Button AddButton  {get;}
        Button CloseButton  {get;}
        TextBox DescriptionTextBox  {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddStandaloneSnapinDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Add Stand-alone snap-in dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddStandaloneSnapinDialog : Dialog, IAddStandaloneSnapinDialogControls
    {
		#region Constants
		private const string DialogTitle = ";Add Standalone Snap-in;Win32DialogString;mmcndmgr.dll;159";
        
        private class ControlIDs
        {
            public const int AvailableStandaloneSnapinsListView = 1049;
            public const int AddButton = 1;
            public const int CloseButton = 2;
            public const int DescriptionTextBox = 0xFA7;
        }
		#endregion

		#region Member Variables
        private ListView m_cachedAvailableStandaloneSnapinsListView;
        private Button m_cachedAddButton;
        private Button m_cachedCloseButton;
        private TextBox m_cachedDescriptionTextBox;
		#endregion

		#region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddStandaloneSnapinDialog(MmcApp app) : base(app, Init(app))
        {
			UISynchronization.WaitForUIObjectReady(this);
        }
      
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app)
        {
            return new Window(app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
				WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddStandaloneSnapinDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to get the text in control DescriptionTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string Description
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
        }

		/// <summary>
		///		Gets or sets Snap-in selected in the list-view.
		/// </summary>
		public string Snapin
		{
			get
			{
				return Controls.AvailableStandaloneSnapinsListView.SelectedItem.Text;
			}
			set
			{
				Controls.AvailableStandaloneSnapinsListView.Items[value].Select();
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableStandaloneSnapinsListView control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddStandaloneSnapinDialogControls.AvailableStandaloneSnapinsListView
        {
            get
            {
                if ((m_cachedAvailableStandaloneSnapinsListView == null))
                {
                    m_cachedAvailableStandaloneSnapinsListView = new ListView(this, ControlIDs.AvailableStandaloneSnapinsListView);
                }
                return m_cachedAvailableStandaloneSnapinsListView;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddStandaloneSnapinDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CloseButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddStandaloneSnapinDialogControls.CloseButton
        {
            get
            {
                if ((m_cachedCloseButton == null))
                {
                    m_cachedCloseButton = new Button(this, ControlIDs.CloseButton);
                }
                return m_cachedCloseButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddStandaloneSnapinDialogControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Close
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickClose()
        {
            Controls.CloseButton.Click();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\PropertiesDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region IPropertiesDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IPropertiesDialogControls
    {
        Button OKButton  {get;}
        Button CancelButton  {get;}
        Button ApplyButton  {get;}
        Button HelpButton  {get;}
        TabControl TabControl {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: PropertiesDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Property Pages Dialog for MMC.
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class PropertiesDialog : Dialog, IPropertiesDialogControls
    {
		#region Control IDs
        public class ControlIDs
        {
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int ApplyButton = 12321;
            public const int HelpButton = 9;
            public const int TabControl = 0x3020;
        }
		#endregion

		#region Member Variables
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private Button m_cachedApplyButton;
        private Button m_cachedHelpButton;
        private TabControl m_cachedTabControl;
		#endregion

		#region Constructor and Init function
		/// -----------------------------------------------------------------------------
		///	 <summary>
		///  Constructor to create dialog.
		///  </summary>
		///  <param name="app">MmcApp object owning the dialog.</param>
		///  <history>
		/// 	[dmitriv] 6/16/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public PropertiesDialog(MmcApp app) : base(app, Init(app, null))
		{			
		}

        /// -----------------------------------------------------------------------------
        ///	 <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public PropertiesDialog(MmcApp app, Window previousWindow) : base(app, Init(app, previousWindow))
        {			
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="app">MmcApp object owning the dialog.</param>
        /// <param name="previousWindow">Main window</param>
        /// <param name="className">expected window class type</param>
        /// <param name="classNameMatchSyntax">expected window class type match string syntax</param>
        ///  <history>
        /// 	[carolli] 11/23/2004 Created
        ///  </history> 
        public PropertiesDialog(MmcApp app, Window previousWindow, string className, StringMatchSyntax classNameMatchSyntax) : base(app, Init(app, previousWindow, className, classNameMatchSyntax))
        {			
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        /// 	[carolli] 11/23/2004 updated.
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow)
        {
			return Init (app, previousWindow, WindowClassNames.Alert, StringMatchSyntax.WildCard);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        /// 	[carolli] 11/23/2004 Add new parameter className and classNameMatchSyntax for allowing users to specify the expected dialog.
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow, string className, StringMatchSyntax classNameMatchSyntax)
        {
			if (previousWindow == null)
			{
				previousWindow = new Window(WindowType.Foreground);
				new Menu(ContextMenuAccessMethod.ShiftF10)["Properties"].Execute();
			}
			
			Sleeper sleeper = new Sleeper(3000);
			while (sleeper.IsNotExpired)
			{				
				WindowCollection windows = new WindowCollection(
					"*", StringMatchSyntax.WildCard,
					className, classNameMatchSyntax, 
					app
					);
				foreach (Window wnd in windows)
					if (!wnd.Extended.HWnd.Equals(previousWindow.Extended.HWnd) &&
						wnd.Extended.IsForeground)
					{
						return wnd;
					}
                sleeper.Sleep();
			}
			throw new Window.Exceptions.WindowNotFoundException("Unable to find new MMC Property Pages dialog.");
		}
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IPropertiesDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplyButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.ApplyButton
        {
            get
            {
                if ((m_cachedApplyButton == null))
                {
                    m_cachedApplyButton = new Button(this, ControlIDs.ApplyButton);
                }
                return m_cachedApplyButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the HelpButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.HelpButton
        {
            get
            {
                if ((m_cachedHelpButton == null))
                {
                    m_cachedHelpButton = new Button(this, ControlIDs.HelpButton);
                }
                return m_cachedHelpButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Tab0TabControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IPropertiesDialogControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Apply
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickApply()
        {
            Controls.ApplyButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Help
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickHelp()
        {
            Controls.HelpButton.Click();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\SnapInWizard.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region ISnapinWizardControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISnapinWizardControls
    {
        RadioButton LocalComputerRadioButton  {get;}
        RadioButton AnotherComputerRadioButton  {get;}
        TextBox ComputerNameTextBox  {get;}
        Button BrowseButton  {get;}
        CheckBox AllowComputerChangeFromCommandLineCheckBox {get;}
        TabControl TabControl  {get;}
        Button BackButton  {get;}
		Button NextButton {get;}
        Button FinishButton  {get;}
        Button CancelButton  {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: SnapinWizard
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Snap-in Add Wizard.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SnapinWizard : Dialog, ISnapinWizardControls
    {
		#region Constants
        private class ControlIDs
        {
            public const int LocalComputerRadioButton = 972;
            public const int AnotherComputerRadioButton = 973;
            public const int ComputerNameTextBox = 0x3CE;
            public const int BrowseButton = 975;
            public const int AllowComputerChangeFromCommandLineCheckBox = 976;
            public const int TabControl = 0x3020;
			public const int NextButton = 12324;
            public const int BackButton = 12323;
            public const int FinishButton = 12325;
            public const int CancelButton = 2;
        }
		#endregion

		#region Member Variables
        private RadioButton m_cachedLocalComputerRadioButton;
        private RadioButton m_cachedAnotherComputerRadioButton;
        private TextBox m_cachedComputerNameTextBox;
        private Button m_cachedBrowseButton;
        private CheckBox m_cachedAllowComputerChangeFromCommandLineCheckBox;
        private TabControl m_cachedTabControl;
        private Button m_cachedBackButton;
		private Button m_cachedNextButton;
        private Button m_cachedFinishButton;
        private Button m_cachedCancelButton;
		#endregion

		#region Constructor
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SnapinWizard(MmcApp app, Window previousWindow) : base(app, Init(app, previousWindow))
        {
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow)
        {
			Sleeper sleeper = new Sleeper(3000);
			while (sleeper.IsNotExpired)
			{
				WindowCollection windows = new WindowCollection(
					"*", StringMatchSyntax.WildCard, WindowClassNames.Alert,
					StringMatchSyntax.ExactMatch, app);
				foreach (Window wnd in windows)
					if (!wnd.Extended.HWnd.Equals(previousWindow.Extended.HWnd) &&
						wnd.Extended.IsForeground)
					{
						return wnd;
					}
				sleeper.Sleep();
			}
			throw new Window.Exceptions.WindowNotFoundException("Unable to find Snap-in Add Wizard.");
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISnapinWizardControls Controls
        {
            get
            {
                return this;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Name of computer to be used. Null if current computer radio button is checked.
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ComputerName
        {
            get
            {
				if (Controls.LocalComputerRadioButton.ButtonState == ButtonState.Checked)
					return null;
				else
					return Controls.ComputerNameTextBox.Text;
            }
            set
            {
				if (value == null)
				{
					ClickLocalComputer();
				}
				else
				{
					ClickAnotherComputer();
					Controls.ComputerNameTextBox.Text = value;
				}
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocalComputerRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISnapinWizardControls.LocalComputerRadioButton
        {
            get
            {
                if ((m_cachedLocalComputerRadioButton == null))
                {
                    m_cachedLocalComputerRadioButton = new RadioButton(this, ControlIDs.LocalComputerRadioButton);
                }
                return m_cachedLocalComputerRadioButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AnotherComputerRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISnapinWizardControls.AnotherComputerRadioButton
        {
            get
            {
                if ((m_cachedAnotherComputerRadioButton == null))
                {
                    m_cachedAnotherComputerRadioButton = new RadioButton(this, ControlIDs.AnotherComputerRadioButton);
                }
                return m_cachedAnotherComputerRadioButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ComputerNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISnapinWizardControls.ComputerNameTextBox
        {
            get
            {
                if ((m_cachedComputerNameTextBox == null))
                {
                    m_cachedComputerNameTextBox = new TextBox(this, ControlIDs.ComputerNameTextBox);
                }
                return m_cachedComputerNameTextBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.BrowseButton
        {
            get
            {
                if ((m_cachedBrowseButton == null))
                {
                    m_cachedBrowseButton = new Button(this, ControlIDs.BrowseButton);
                }
                return m_cachedBrowseButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowComputerChangeFromCommandLineCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ISnapinWizardControls.AllowComputerChangeFromCommandLineCheckBox
        {
            get
            {
                if ((m_cachedAllowComputerChangeFromCommandLineCheckBox == null))
                {
                    m_cachedAllowComputerChangeFromCommandLineCheckBox = new CheckBox(this, ControlIDs.AllowComputerChangeFromCommandLineCheckBox);
                }
                return m_cachedAllowComputerChangeFromCommandLineCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl ISnapinWizardControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BackButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.BackButton
        {
            get
            {
                if ((m_cachedBackButton == null))
                {
                    m_cachedBackButton = new Button(this, ControlIDs.BackButton);
                }
                return m_cachedBackButton;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the NextButton control
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/16/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button ISnapinWizardControls.NextButton
		{
			get
			{
				if ((m_cachedNextButton == null))
				{
					m_cachedNextButton = new Button(this, ControlIDs.NextButton);
				}
				return m_cachedNextButton;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FinishButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.FinishButton
        {
            get
            {
                if ((m_cachedFinishButton == null))
                {
                    m_cachedFinishButton = new Button(this, ControlIDs.FinishButton);
                }
                return m_cachedFinishButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button LocalComputer
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickLocalComputer()
        {
            Controls.LocalComputerRadioButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button AnotherComputer
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAnotherComputer()
        {
            Controls.AnotherComputerRadioButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Browse
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickBrowse()
        {
            Controls.BrowseButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button AllowComputerChangeFromCommandLine
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAllowComputerChangeFromCommandLine()
        {
            Controls.AllowComputerChangeFromCommandLineCheckBox.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Back
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickBack()
        {
            Controls.BackButton.Click();
			WaitForResponse();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Next
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/16/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickNext()
		{
			Controls.NextButton.Click();
			WaitForResponse();
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Finish
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickFinish()
        {
            Controls.FinishButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\OptionsDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
	using System;
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	/// <summary>
	///		Console Mode to be used with this dialog.
	/// </summary>
	public enum ConsoleAccessMode
	{
		AuthorMode,
		UserModeFullAccess,
		UserModeLimitedAccessMultipleWindows,
		UserModeLimitedAccessSingleWindow
	}

	#region IOptionsDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IOptionsDialogControls
    {
        TextBox ConsoleNameTextBox  {get;}
        Button ChangeIconButton  {get;}
        EditComboBox ConsoleAccessModeEditComboBox  {get;}
        CheckBox SaveChangedCheckBox  {get;}
        CheckBox AllowCustomizeViewsCheckBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
        Button ApplyButton  {get;}
		Button DeleteFilesButton  {get;}
		TabControl TabControl {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: OptionsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Console Options dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class OptionsDialog : Dialog, IOptionsDialogControls
    {
		#region Constants
		private class Strings
		{
			public const string DialogTitle = ";Options;Win32String;mmcbase.dll;13343";
			public const string AuthorMode = ";Author mode;Win32String;mmcbase.dll;13313";
			public const string UserModeFullAccess = ";User mode - full access;Win32String;mmcbase.dll;13314";
			public const string UserModeLimitedAccessMultipleWindows = ";User mode - limited access, multiple window;Win32String;mmcbase.dll;13315";
			public const string UserModeLimitedAccessSignleWindow = ";User mode - limited access, single window;Win32String;mmcbase.dll;13316";
		}

        private class ControlIDs
        {
            public const int ConsoleNameTextBox = 0x403;
            public const int ChangeIconButton = 1025;
            public const int ConsoleAccessModeEditComboBox = 1022;
            public const int SaveChangedCheckBox = 1024;
            public const int AllowCustomizeViewsCheckBox = 1029;
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int ApplyButton = 12321;
			public const int DeleteFilesButton = 1031;
            public const int TabControl = 0x3020;
        }
		#endregion

		#region Member Variables
        private TextBox m_cachedConsoleNameTextBox;
        private Button m_cachedChangeIconButton;
        private EditComboBox m_cachedConsoleAccessModeEditComboBox;
        private CheckBox m_cachedSaveChangedCheckBox;
        private CheckBox m_cachedAllowCustomizeViewsCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private Button m_cachedApplyButton;
		private Button m_cachedDeleteFilesButton;
        private TabControl m_cachedTabControl;
		#endregion

		#region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public OptionsDialog(MmcApp app) : base(app, Init(app, CommandMethod.Default))
        {
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Constructor.
		///  </summary>
		///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="method">How to invoke the command.</param>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public OptionsDialog(MmcApp app, CommandMethod method) : base(app, Init(app, method))
		{
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
				UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            catch (Exceptions.WindowNotFoundException)
            {
				Commands.FileOptions.Execute(app, method);
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            return tempWindow;
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IOptionsDialogControls Controls
        {
            get
            {
                return this;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConsoleNameTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ConsoleName
        {
            get
            {
                return Controls.ConsoleNameTextBox.Text;
            }
            set
            {
                Controls.ConsoleNameTextBox.Text = value;
            }
        }

		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConsoleAccessMode
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ConsoleAccessMode ConsoleAccessMode
        {
            get
            {
				string value = Controls.ConsoleAccessModeEditComboBox.Text;
				if (value == App.GetIntlStr(Strings.AuthorMode))
					return ConsoleAccessMode.AuthorMode;
				else if (value == App.GetIntlStr(Strings.UserModeFullAccess))
					return ConsoleAccessMode.UserModeFullAccess;
				else if (value == App.GetIntlStr(Strings.UserModeLimitedAccessMultipleWindows))
					return ConsoleAccessMode.UserModeLimitedAccessMultipleWindows;
				else if (value == App.GetIntlStr(Strings.UserModeLimitedAccessSignleWindow))
					return ConsoleAccessMode.UserModeLimitedAccessSingleWindow;
				else
					throw new NotSupportedException("Console mode " + value + " is not supported by this dialog class.");
            }
            set
            {
				switch (value)
				{
					case ConsoleAccessMode.AuthorMode:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.AuthorMode));
						break;
					case ConsoleAccessMode.UserModeFullAccess:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeFullAccess));
						break;
					case ConsoleAccessMode.UserModeLimitedAccessMultipleWindows:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeLimitedAccessMultipleWindows));
						break;
					case ConsoleAccessMode.UserModeLimitedAccessSingleWindow:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeLimitedAccessSignleWindow));
						break;
				}
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Gets or sets whether to save changes to console.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public bool SaveChangesToConsole
		{
			get
			{
				return Controls.SaveChangedCheckBox.Checked;
			}
			set
			{
				Controls.SaveChangedCheckBox.Checked = value;
			}
		}
        
		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Gets or sets whether to allows user to customize console views.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public bool AllowUserToCustomizeViews
		{
			get
			{
				return Controls.AllowCustomizeViewsCheckBox.Checked;
			}
			set
			{
				Controls.AllowCustomizeViewsCheckBox.Checked = value;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConsoleNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IOptionsDialogControls.ConsoleNameTextBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedConsoleNameTextBox == null))
                {
                    m_cachedConsoleNameTextBox = new TextBox(this, ControlIDs.ConsoleNameTextBox);
                }
                return m_cachedConsoleNameTextBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ChangeIconButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.ChangeIconButton
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedChangeIconButton == null))
                {
                    m_cachedChangeIconButton = new Button(this, ControlIDs.ChangeIconButton);
                }
                return m_cachedChangeIconButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConsoleAccessModeEditComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOptionsDialogControls.ConsoleAccessModeEditComboBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedConsoleAccessModeEditComboBox == null))
                {
                    m_cachedConsoleAccessModeEditComboBox = new EditComboBox(this, ControlIDs.ConsoleAccessModeEditComboBox);
                }
                return m_cachedConsoleAccessModeEditComboBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveChangedCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IOptionsDialogControls.SaveChangedCheckBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedSaveChangedCheckBox == null))
                {
                    m_cachedSaveChangedCheckBox = new CheckBox(this, ControlIDs.SaveChangedCheckBox);
                }
                return m_cachedSaveChangedCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowCustomizeViewsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IOptionsDialogControls.AllowCustomizeViewsCheckBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedAllowCustomizeViewsCheckBox == null))
                {
                    m_cachedAllowCustomizeViewsCheckBox = new CheckBox(this, ControlIDs.AllowCustomizeViewsCheckBox);
                }
                return m_cachedAllowCustomizeViewsCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.OKButton
        {
            get
            {
				if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.CancelButton
        {
            get
            {
				if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplyButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.ApplyButton
        {
            get
            {
				if ((m_cachedApplyButton == null))
                {
                    m_cachedApplyButton = new Button(this, ControlIDs.ApplyButton);
                }
                return m_cachedApplyButton;
            }
        }      
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Exposes access to the DeleteFilesButton control
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IOptionsDialogControls.DeleteFilesButton
		{
			get
			{
				if (Controls.TabControl.SelectedIndex != 1)
					Controls.TabControl.Tabs[1].Select();
				if ((m_cachedDeleteFilesButton == null))
				{
					m_cachedDeleteFilesButton = new Button(this, ControlIDs.DeleteFilesButton);
				}
				return m_cachedDeleteFilesButton;
			}
		}

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IOptionsDialogControls.TabControl
        {
            get
            {
				if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button ChangeIcon
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickChangeIcon()
        {
            Controls.ChangeIconButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Apply
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickApply()
        {
            Controls.ApplyButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Routine to click on button DeleteFiles.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickDeleteFiles()
		{
			Controls.DeleteFilesButton.Click();
		}
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\NewDialogs\Advanced.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IAdvancedDialogControls interface definition"

    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAdvancedDialogControls
    {
        CheckBox AllowChangingTheParentSnapInCheckBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AdvancedDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Open and manipulate the Advanced dialog, reachable from the Add or Remove Snap-ins
    ///  dialog added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 12/17/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AdvancedDialog : Dialog, IAdvancedDialogControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Advanced;Win32DialogString;mmcndmgr.dll;4187";
            public const string AddDialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string ByDefaultSnapInsAreAddedUnderTheConsoleRootNodeSelectingThisCheckBoxEnablesYouToChooseTheParentSnapI = ";By default, snap-ins are added under the console root node.  Selecting this check box enables you to choose the parent snap-in under which snap-ins will be added.;Win32DialogItemString;mmcndmgr.dll;4187;-1";
            public const string AllowChangingTheParentSnapIn = ";&Allow changing the parent snap-in;Win32DialogItemString;mmcndmgr.dll;4187;4188";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";
        }

        #endregion

        #region "Constants"
        private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AllowChangingTheParentSnapInCheckBox = 0x105C;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private StaticControl m_cachedByDefaultSnapInsAreAddedUnderTheConsoleRootNodeIStaticControl;
        private CheckBox m_cachedAllowChangingTheParentSnapInCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Find and manipulate the Advanced Dialog
        ///  </summary>
        //  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AdvancedDialog(App app, AddOrRemoveSnapInsDialog dialog) :  
            base(app, Init(app, dialog))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, AddOrRemoveSnapInsDialog dialog)
        {
            Window tempWindow;

            // open the advanced dialog
            dialog.ClickAdvanced();

            // find the window
            tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);

            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAdvancedDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox AllowChangingTheParentSnapIn
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool AllowChangingTheParentSnapIn
        {
            get
            {
                return Controls.AllowChangingTheParentSnapInCheckBox.Checked;
            }
            set
            {
                Controls.AllowChangingTheParentSnapInCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowChangingTheParentSnapInCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IAdvancedDialogControls.AllowChangingTheParentSnapInCheckBox
        {
            get
            {
                if ((m_cachedAllowChangingTheParentSnapInCheckBox == null))
                {
                    m_cachedAllowChangingTheParentSnapInCheckBox = new CheckBox(this, ControlIDs.AllowChangingTheParentSnapInCheckBox);
                }
                return m_cachedAllowChangingTheParentSnapInCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAdvancedDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAdvancedDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// <summary>
        /// Check the checkbox to enable changing the parent snap-in
        /// </summary>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void EnableAllowChangingTheParentSnapIn()
        {
            Controls.AllowChangingTheParentSnapInCheckBox.Checked = true;
        }

        /// <summary>
        /// Un-Check the checkbox to enable changing the parent snap-in
        /// </summary>        
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void DisableAllowChangingTheParentSnapIn()
        {
            Controls.AllowChangingTheParentSnapInCheckBox.Checked = false;
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\CustomizeViewDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region ICustomizeViewDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ICustomizeViewDialogControls
    {
        CheckBox ConsoleTreeCheckBox { get;}
        CheckBox StandardMenusCheckBox { get;}
        CheckBox StandardToolbarCheckBox { get;}
        CheckBox StatusbarCheckBox { get;}
        CheckBox DescriptionBarCheckBox { get;}
        CheckBox TaskPadNavigationTabsCheckBox { get;}
        CheckBox SnapinMenusCheckBox { get;}
        CheckBox SnapinToolbarsCheckBox { get;}
        CheckBox ActionsPaneCheckBox { get;}
        Button OKButton { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: CustomizeViewDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Customize View dialog for MMC.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/10/2003 Created
    /// 	[faisalb] 10/28/2003 Added Actions Pane Options
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class CustomizeViewDialog : Dialog, ICustomizeViewDialogControls
    {
        #region Constants, member variables
        private const string DialogTitle = ";Customize View;Win32DialogString;mmcndmgr.dll;1086";

        private class ControlIDs
        {
            public const int ConsoleTreeCheckBox = 4143;
            public const int StandardMenusCheckBox = 4144;
            public const int StandardToolbarCheckBox = 4139;
            public const int StatusbarCheckBox = 4141;
            public const int DescriptionBarCheckBox = 4142;
            public const int TaskPadNavigationTabsCheckBox = 4145;
            public const int SnapinMenusCheckBox = 4138;
            public const int SnapinToolbarsCheckBox = 4140;
            public const int ActionsPaneCheckBox = 4172;
            public const int OKButton = 1;
        }

        private CheckBox m_cachedConsoleTreeCheckBox;
        private CheckBox m_cachedStandardMenusCheckBox;
        private CheckBox m_cachedStandardToolbarCheckBox;
        private CheckBox m_cachedStatusbarCheckBox;
        private CheckBox m_cachedDescriptionBarCheckBox;
        private CheckBox m_cachedTaskPadNavigationTabsCheckBox;
        private CheckBox m_cachedActionsPaneCheckBox;
        private CheckBox m_cachedSnapinMenusCheckBox;
        private CheckBox m_cachedSnapinToolbarsCheckBox;
        private Button m_cachedOKButton;
        #endregion

        #region Constructor and Init function
        ///  <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public CustomizeViewDialog(MmcApp app) : 
                base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public CustomizeViewDialog(MmcApp app, CommandMethod method) : 
			base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Find to brings up Customize View dialog.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="method">How to invoke the command.</param>
        /// <returns>Dialog window.</returns>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(
                    app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
                    WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
                    app, 200);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                Commands.ViewCustomize.Execute(app, method);
                tempWindow = new Window(
                    app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
                    WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
                    app, 2000);
            }
            return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ICustomizeViewDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the ConsoleTreeCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.ConsoleTreeCheckBox
        {
            get
            {
                if ((m_cachedConsoleTreeCheckBox == null))
                {
                    m_cachedConsoleTreeCheckBox = new CheckBox(this, ControlIDs.ConsoleTreeCheckBox);
                }
                return m_cachedConsoleTreeCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StandardMenusCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StandardMenusCheckBox
        {
            get
            {
                if ((m_cachedStandardMenusCheckBox == null))
                {
                    m_cachedStandardMenusCheckBox = new CheckBox(this, ControlIDs.StandardMenusCheckBox);
                }
                return m_cachedStandardMenusCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StandardToolbarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StandardToolbarCheckBox
        {
            get
            {
                if ((m_cachedStandardToolbarCheckBox == null))
                {
                    m_cachedStandardToolbarCheckBox = new CheckBox(this, ControlIDs.StandardToolbarCheckBox);
                }
                return m_cachedStandardToolbarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StatusbarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StatusbarCheckBox
        {
            get
            {
                if ((m_cachedStatusbarCheckBox == null))
                {
                    m_cachedStatusbarCheckBox = new CheckBox(this, ControlIDs.StatusbarCheckBox);
                }
                return m_cachedStatusbarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the DescriptionBarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.DescriptionBarCheckBox
        {
            get
            {
                if ((m_cachedDescriptionBarCheckBox == null))
                {
                    m_cachedDescriptionBarCheckBox = new CheckBox(this, ControlIDs.DescriptionBarCheckBox);
                }
                return m_cachedDescriptionBarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the TaskPadNavigationTabsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.TaskPadNavigationTabsCheckBox
        {
            get
            {
                if ((m_cachedTaskPadNavigationTabsCheckBox == null))
                {
                    m_cachedTaskPadNavigationTabsCheckBox = new CheckBox(this, ControlIDs.TaskPadNavigationTabsCheckBox);
                }
                return m_cachedTaskPadNavigationTabsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the SnapinMenusCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.SnapinMenusCheckBox
        {
            get
            {
                if ((m_cachedSnapinMenusCheckBox == null))
                {
                    m_cachedSnapinMenusCheckBox = new CheckBox(this, ControlIDs.SnapinMenusCheckBox);
                }
                return m_cachedSnapinMenusCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the ActionsPaneCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[faisalb] 10/28/2004 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.ActionsPaneCheckBox
        {
            get
            {
                if ((m_cachedActionsPaneCheckBox == null))
                {
                    m_cachedActionsPaneCheckBox = new CheckBox(this, ControlIDs.ActionsPaneCheckBox);
                }
                return m_cachedActionsPaneCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the SnapinToolbarsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.SnapinToolbarsCheckBox
        {
            get
            {
                if ((m_cachedSnapinToolbarsCheckBox == null))
                {
                    m_cachedSnapinToolbarsCheckBox = new CheckBox(this, ControlIDs.SnapinToolbarsCheckBox);
                }
                return m_cachedSnapinToolbarsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ICustomizeViewDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
            UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\NewDialogs\Extensions.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IExtensionsControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IExtensionsControls
    {
        RadioButton AlwaysEnableAllAvailableExtensionsRadioButton { get;}
        RadioButton EnableOnlySelectedExtensionsRadioButton { get;}
        ListView ExtensionsList { get;}
        Button InstallButton { get;}
        Button EditExtensionsButton { get;}
        TextBox DescriptionTextBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    #region "Enums for RadioButton groups"

    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group AllExtensionsWillBeEnabled
    ///  </summary>
    ///  <history>
    /// 	[michsny] 1/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum AllExtensionsWillBeEnabled
    {
        AlwaysEnableAllAvailableExtensions = 0,
        EnableOnlySelectedExtensions = 1,
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: Extensions
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Open and manipulate the Extensions dialog added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 1/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class Extensions : Dialog, IExtensionsControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Extensions for %s;Win32String;mmcbase.dll;14179";
            public const string AddDialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string YouCanSpecifyWhichExtensionsToEnableInOrderToAddOrRemoveFunctionalityInYourConsoleSnapInOrExtensionI = ";You can specify which extensions to enable, in order to add or remove functionality in your console, snap-in, or extension. If an extension is not installed, you can install it by highlighting it and then clicking Install. ;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string AlwaysEnableAllAvailableExtensions = ";&Always enable all available extensions;Win32DialogItemString;mmcndmgr.dll;161;4189";
            public const string EnableOnlySelectedExtensions = ";&Enable only selected extensions;Win32DialogItemString;mmcndmgr.dll;161;4190";
            public const string AllCurrentlyAvailableExtensionsAsWellAsAnyExtensionsThatAreInstalledInTheFutureWillBeEnabled = ";All currently available extensions, as well as any extensions that are installed in the future, will be enabled.;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string OnlyTheFollowingSelectedExtensionsWillBeEnabledExtensionsThatAreInstalledInTheFutureWillNotBeEnabled = ";Only the following selected extensions will be enabled. Extensions that are installed in the future will not be enabled.;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string ExtensionsList = ";Extensions list;Win32DialogItemString;mmcndmgr.dll;161;4020";
            public const string Install = ";I&nstall;Win32DialogItemString;mmcndmgr.dll;161;4026";
            public const string EditExtensions = ";Edit E&xtensions...;Win32DialogItemString;mmcndmgr.dll;160;4176";
            public const string Description = ";Description:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";

        }

        #endregion

        #region "Constants"
            private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AlwaysEnableAllAvailableExtensionsRadioButton = 0x105D;
            public const int EnableOnlySelectedExtensionsRadioButton = 0x105E;
            public const int ExtensionsList = 0xFB4;
            public const int InstallButton = 0xFBA;
            public const int EditExtensionsButton = 0x1050;
            public const int DescriptionTextBox = 0xFA7;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private RadioButton m_cachedAlwaysEnableAllAvailableExtensionsRadioButton;
        private RadioButton m_cachedEnableOnlySelectedExtensionsRadioButton;
        private ListView m_cachedExtensionsList;
        private Button m_cachedInstallButton;
        private Button m_cachedEditExtensionsButton;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private const int Timeout = 1000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Find and manipulate the extensions dialog
        ///  </summary>
        //  <param name="app">App object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public Extensions(App app, AddOrRemoveSnapInsDialog dialog) : 
                base(app, Init(app, dialog))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">App owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, AddOrRemoveSnapInsDialog dialog)
        {
            Window tempWindow;
            string tempWindowTitle = app.GetIntlStr(Strings.DialogTitle);

            // replace the %s in the title with *
            tempWindowTitle = tempWindowTitle.Replace("%s", "*");

            // Click the button to open the extensions dialog
            dialog.ClickEditExtensions();

            // find the Extensions window
            tempWindow = new Window(tempWindowTitle, StringMatchSyntax.WildCard, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);

            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IExtensionsControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group AllExtensionsWillBeEnabled
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual AllExtensionsWillBeEnabled AllExtensionsWillBeEnabled
        {
            get
            {
                if ((Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState == ButtonState.Checked))
                    return AllExtensionsWillBeEnabled.AlwaysEnableAllAvailableExtensions;

                if ((Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState == ButtonState.Checked))
                    return AllExtensionsWillBeEnabled.EnableOnlySelectedExtensions;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == AllExtensionsWillBeEnabled.AlwaysEnableAllAvailableExtensions))
                    Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == AllExtensionsWillBeEnabled.EnableOnlySelectedExtensions))
                    Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState = ButtonState.Checked;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Description
        ///  </summary>
        ///  <value>Description Text</value>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DescriptionText
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
            set
            {
                Controls.DescriptionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AlwaysEnableAllAvailableExtensionsRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IExtensionsControls.AlwaysEnableAllAvailableExtensionsRadioButton
        {
            get
            {
                if ((m_cachedAlwaysEnableAllAvailableExtensionsRadioButton == null))
                {
                    m_cachedAlwaysEnableAllAvailableExtensionsRadioButton = new RadioButton(this, ControlIDs.AlwaysEnableAllAvailableExtensionsRadioButton);
                }
                return m_cachedAlwaysEnableAllAvailableExtensionsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EnableOnlySelectedExtensionsRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IExtensionsControls.EnableOnlySelectedExtensionsRadioButton
        {
            get
            {
                if ((m_cachedEnableOnlySelectedExtensionsRadioButton == null))
                {
                    m_cachedEnableOnlySelectedExtensionsRadioButton = new RadioButton(this, ControlIDs.EnableOnlySelectedExtensionsRadioButton);
                }
                return m_cachedEnableOnlySelectedExtensionsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IExtensionsControls.ExtensionsList
        {
            get
            {
                if ((m_cachedExtensionsList == null))
                {
                    m_cachedExtensionsList = new ListView(this, ControlIDs.ExtensionsList);
                }
                return m_cachedExtensionsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the InstallButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.InstallButton
        {
            get
            {
                if ((m_cachedInstallButton == null))
                {
                    m_cachedInstallButton = new Button(this, ControlIDs.InstallButton);
                }
                return m_cachedInstallButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditExtensionsButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.EditExtensionsButton
        {
            get
            {
                if ((m_cachedEditExtensionsButton == null))
                {
                    m_cachedEditExtensionsButton = new Button(this, ControlIDs.EditExtensionsButton);
                }
                return m_cachedEditExtensionsButton;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IExtensionsControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Install
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickInstall()
        {
            Controls.InstallButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button EditExtensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEditExtensions()
        {
            Controls.EditExtensionsButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable only selected extensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void EnableOnlySelectedExtensions()
        {
            Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState = ButtonState.Checked;
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable all extensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void EnableAllExtensions()
        {
            Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState = ButtonState.Checked;
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable a specified
        ///  </summary>
        /// <param name="extensionName">string extensionName</param>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void EnableExtension(string extensionName)
        {
            try
            {
                Controls.ExtensionsList.Items[extensionName].Checked = true;
            }
            catch (Maui.Core.WinControls.ListView.Exceptions.ItemNotFoundException)
            {
                //This was ignored in the code for the old UI.
                //The test code should catch this exception and handle it if an expected extension is not available.
                throw (new Maui.GlobalExceptions.MauiException("ExtensionToEnableWasNotFound"));
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\NewDialogs\AddOrRemoveSnapIns.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IAddOrRemoveSnapInsDialogControls interface definition"


    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddOrRemoveSnapInsDialogControls
    {
        ListView AvailableSnapinsList { get;}
        Button AddButton { get;}
        EditComboBox ParentSnapInEditComboBox { get;}
        ListView AddedSnapinsList { get;}
        Button EditExtensionsButton { get;}
        Button RemoveButton { get;}
        Button MoveUpButton { get;}
        Button MoveDownButton { get;}
        Button AdvancedButton { get;}
        TextBox DescriptionTextBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AddOrRemoveSnapInsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to open and manipulate the "Add or Remove Snap-ins" dialog that was 
    ///     added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 12/14/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddOrRemoveSnapInsDialog : Dialog, IAddOrRemoveSnapInsDialogControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string YouCanSelectSnapInsForThisConsoleTitleText = ";You can select snap-ins for this console from those available on your computer and configure the selected set of snap-ins. For extensible snap-ins, you can configure which extensions are enabled.;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string AvailableSnapIns = ";Available &snap-ins:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string AvailableSnapinsList = ";AvailableSnapinsList;Win32DialogItemString;mmcndmgr.dll;160;4173";
            public const string Add = ";&Add >;Win32DialogItemString;mmcndmgr.dll;160;4008";
            public const string ParentSnapIn = ";&Parent snap-in:;Win32DialogItemString;mmcndmgr.dll;160;4182";
            public const string SelectedSnapIns = ";S&elected snap-ins:;Win32DialogItemString;mmcndmgr.dll;160;4174";
            public const string AddedSnapinsList = ";AddedSnapinsList;Win32DialogItemString;mmcndmgr.dll;160;4175";
            public const string EditExtensions = ";Edit E&xtensions...;Win32DialogItemString;mmcndmgr.dll;160;4176";
            public const string Remove = "&;Remove;Win32DialogItemString;mmcndmgr.dll;1090;1015";
            public const string MoveUp = ";Move &Up;Win32DialogItemString;mmcndmgr.dll;108;1020";
            public const string MoveDown = ";Move &Down;Win32DialogItemString;mmcndmgr.dll;108;1021";
            public const string Advanced = ";Ad&vanced...;Win32DialogItemString;mmcndmgr.dll;160;4186";
            public const string Description = ";Description:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";
        }

        #endregion

        #region "Constants"
            private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AvailableSnapinsList = 0x104D;
            public const int AddButton = 0xFA8;
            public const int ParentSnapInStaticControl = 0x1056;
            public const int ParentSnapInEditComboBox = 0x1054;
            public const int SelectedSnapInsStaticControl = 0x104E;
            public const int AddedSnapinsList = 0x104F;
            public const int EditExtensionsButton = 0x1050;
            public const int RemoveButton = 0x1053;
            public const int MoveUpButton = 0x1051;
            public const int MoveDownButton = 0x1052;
            public const int AdvancedButton = 0x105A;
            public const int DescriptionTextBox = 0xFA7;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private ListView m_cachedAvailableSnapinsList;
        private Button m_cachedAddButton;
        private EditComboBox m_cachedParentSnapInEditComboBox;
        private ListView m_cachedAddedSnapinsList;
        private Button m_cachedEditExtensionsButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedMoveUpButton;
        private Button m_cachedMoveDownButton;
        private Button m_cachedAdvancedButton;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor - Opens the dialog and finds the window
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddOrRemoveSnapInsDialog(App app) : base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor - Opens the dialog and finds the window
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <param name="method">CommandMethod for controling the menu.</param>    
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddOrRemoveSnapInsDialog(App app, CommandMethod method) : base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, CommandMethod method)
        {
            Window tempWindow;
            // First check if the dialog is already up.
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // The line below is throwing an exception...it is clicking at 0,0 instead of on the menu
                // Dmitry is investigating.
                // Commands.FileAddRemoveSnapIn.Execute(app,CommandMethod.MainMenuHotKey);
                //BUGBUG this is a temporary workaround to the problem above
                app.SendKeys("^m");
                Maui.TestLog.LogManager.LogHack("Init", "Hardcoded sendkeys method of opening the dialog is not localizable: Fail this after 4/1/05");                

                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);
            }
            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddOrRemoveSnapInsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control YouCanSelectSnapInsForThisConsoleTitleText
        ///  </summary>
        ///  <value>Control Text</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string YouCanSelectSnapInsForThisConsoleTitleTextText
        {
            get
            {
                return Controls.ParentSnapInEditComboBox.Text;
            }
            set
            {
                Controls.ParentSnapInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Description
        ///  </summary>
        ///  <value>Description Text</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DescriptionText
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
            set
            {
                Controls.DescriptionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableSnapinsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddOrRemoveSnapInsDialogControls.AvailableSnapinsList
        {
            get
            {
                if ((m_cachedAvailableSnapinsList == null))
                {
                    m_cachedAvailableSnapinsList = new ListView(this, ControlIDs.AvailableSnapinsList);
                }
                return m_cachedAvailableSnapinsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ParentSnapInEditComboBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddOrRemoveSnapInsDialogControls.ParentSnapInEditComboBox
        {
            get
            {
                if ((m_cachedParentSnapInEditComboBox == null))
                {
                    m_cachedParentSnapInEditComboBox = new EditComboBox(this, ControlIDs.ParentSnapInEditComboBox);
                }
                return m_cachedParentSnapInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddedSnapinsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddOrRemoveSnapInsDialogControls.AddedSnapinsList
        {
            get
            {
                if ((m_cachedAddedSnapinsList == null))
                {
                    m_cachedAddedSnapinsList = new ListView(this, ControlIDs.AddedSnapinsList);
                }
                return m_cachedAddedSnapinsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditExtensionsButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.EditExtensionsButton
        {
            get
            {
                if ((m_cachedEditExtensionsButton == null))
                {
                    m_cachedEditExtensionsButton = new Button(this, ControlIDs.EditExtensionsButton);
                }
                return m_cachedEditExtensionsButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveUpButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.MoveUpButton
        {
            get
            {
                if ((m_cachedMoveUpButton == null))
                {
                    m_cachedMoveUpButton = new Button(this, ControlIDs.MoveUpButton);
                }
                return m_cachedMoveUpButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveDownButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.MoveDownButton
        {
            get
            {
                if ((m_cachedMoveDownButton == null))
                {
                    m_cachedMoveDownButton = new Button(this, ControlIDs.MoveDownButton);
                }
                return m_cachedMoveDownButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AdvancedButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.AdvancedButton
        {
            get
            {
                if ((m_cachedAdvancedButton == null))
                {
                    m_cachedAdvancedButton = new Button(this, ControlIDs.AdvancedButton);
                }
                return m_cachedAdvancedButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddOrRemoveSnapInsDialogControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button EditExtensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEditExtensions()
        {
            Controls.EditExtensionsButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveUp
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveUp()
        {
            Controls.MoveUpButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveDown
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveDown()
        {
            Controls.MoveDownButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Advanced
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdvanced()
        {
            Controls.AdvancedButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {            
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// <summary>
        /// Set the Parent snap-in path
        /// </summary>
        /// <param name="path">Snap-in to select as parent</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SetPath(string path)
        {
            Controls.ParentSnapInEditComboBox.SelectByText(path);
        }

        /// <summary>
        /// Set the Parent snap-in path to the Console Root
        /// </summary>        
        /// <history>
        ///     [michsny] 1/20/2004 Created
        /// </history>
        public void SetPathToConsoleRoot()
        {
            Controls.ParentSnapInEditComboBox.SelectByIndex(0);
        }

        /// <summary>
        /// Select the specified snap-in in the available snap-ins list
        /// </summary>
        /// <param name="snapIn">SnapIn object</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SelectAvailableSnapIn(Snapin snapIn)
        {
            Controls.AvailableSnapinsList.Items[snapIn.Name].Select();
        }

        /// <summary>
        /// Select the specified snap-in in the added snap-ins list
        /// </summary>
        /// <param name="snapIn">SnapIn object</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SelectAddedSnapIn(Snapin snapIn)
        {
            Controls.AddedSnapinsList.Items[snapIn.AddedName].Select();
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyName("")]
#if STRONGNAME
	[assembly: AssemblyKeyFile("..\\..\\maui.snk")]
#else
	[assembly: AssemblyKeyFile("")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Enc.cs ===
//*********************************************************
// Owner : Mkoller
// Class name : Enc
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger
{
	/// <summary>
	/// Summary description for Enc.
	/// </summary>
	public class Enc
	{
		public Enc(IDEApp application)
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\DebuggerHelper.cs ===
using System;
using Maui.VisualStudio.Everett.Debugger.ToolWindows;
using Maui.VisualStudio.Everett.Debugger.Dialogs;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggerHelper
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Helper class for easy access to all debugger windows.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[bboris]	10/30/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class DebuggerHelper
	{

#region memberVars

		private IDEApp m_App;

#endregion

#region Constructors

		public DebuggerHelper(IDEApp app)
		{
			this.App = app;
		}

		public DebuggerHelper()
		{
			this.App = CoreManager.ActiveApp;
		}

#endregion

#region properties

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return IDEApp object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDEApp App
		{
			get
			{
				return m_App;
			}
			set
			{
				m_App = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Autos object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AutosWindow Autos
		{
			get
			{
				return new AutosWindow(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return BreakPointPropertiesDialog object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPointPropertiesDialog BreakPointPropertiesDialog
		{
			get
			{
				return new BreakPointPropertiesDialog(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return BreakPoints object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPoints BreakPoints
		{
			get
			{
				return new BreakPoints(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return BreakPoints object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[DaveBarn] 	1/30/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointWindow BreakpointWindow
		{
			get
			{
				return new BreakpointWindow(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return CallStack object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public CallStack CallStack
		{
			get
			{
				return new CallStack(this.App);
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return DebugLocation object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebugLocation DebugLocation
		{
			get
			{
				return new DebugLocation(this.App);
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Disassembly object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Disassembly Disassembly
		{
			get
			{
				return new Disassembly(this.App);
			}
		}
			
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Enc object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Enc Enc
		{
			get
			{
				return new Enc(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Exception object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionsDialog Exceptions
		{
			get
			{
				return new ExceptionsDialog(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ExceptionHandle object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionHandle ExceptionHandle
		{
			get
			{
				return new ExceptionHandle(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ExceptionPass object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionPass ExceptionPass
		{
			get
			{
				return new ExceptionPass(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Execution object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.VisualStudio.Everett.Debugger.Debugger Debugger
		{
			get
			{
				return new Maui.VisualStudio.Everett.Debugger.Debugger(this.App);
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Immediate object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ImmediateWindow Immediate
		{
			get
			{
				return new ImmediateWindow(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Jit object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Jit Jit
		{
			get
			{
				return new Jit(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Locals object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public LocalsWindow Locals
		{
			get
			{
				return new LocalsWindow(this.App);
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Memory1 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory Memory1
		{
			get
			{
				return new Memory(this.App,1);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Memory2 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory Memory2
		{
			get
			{
				return new Memory(this.App,2);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Memory3 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory Memory3
		{
			get
			{
				return new Memory(this.App,3);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Memory4 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory Memory4
		{
			get
			{
				return new Memory(this.App,4);
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Modules object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Modules Modules
		{
			get
			{
				return new Modules(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachToProcessDialog object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachToProcessDialog AttachToProcessDialog
		{
			get
			{
				return new AttachToProcessDialog(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachedProcessesWindow object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachedProcessesWindow AttachedProcessesWindow
		{
			get
			{
				return new AttachedProcessesWindow(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return QuickWatch object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatch QuickWatch
		{
			get
			{
				return new QuickWatch(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Registers object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Registers Registers
		{
			get
			{
				return new Registers(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return RemoteDebugging object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RemoteDebugging RemoteDebugging
		{
			get
			{
				return new RemoteDebugging(this.App);
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return RunningDoc object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RunningDoc RunningDoc
		{
			get
			{
				return new RunningDoc(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return SQLDebug object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public SQLDebug SQLDebug
		{
			get
			{
				return new SQLDebug(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return SQLDebugAttachDialog object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public SQLDebugAttachDialog SQLDebugAttachDialog
		{
			get
			{
				return new SQLDebugAttachDialog(this.App);
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Thread object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Threads Threads
		{
			get
			{
				return new Threads(this.App);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Watch1 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow Watch1
		{
			get
			{
				return new WatchWindow(this.App, 1);
			}
		}
		

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Watch2 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow Watch2
		{
			get
			{
				return new WatchWindow(this.App, 2);
			}
		}
		

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Watch3 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow Watch3
		{
			get
			{
				return new WatchWindow(this.App, 3);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Watch4 object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow Watch4
		{
			get
			{
				return new WatchWindow(this.App, 4);
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\DebugLocation.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.VSControls;

namespace Maui.VisualStudio.Everett.Debugger
{
	#region Interface definitions
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDebugLocationControls
	{
		VSToolbarItem ProgramComboBox
		{
			get;
		}

		VSToolbarItem ThreadComboBox
		{
			get;
		}

		VSToolbarItem CallstackComboBox
		{
			get;
		}
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebugLocation
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you use the toolbar window you get when you execute the
	///   "View.Toolbar widnows.Debug location" menu.
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 11/4/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class DebugLocation : Maui.VisualStudio.Everett.Ide.VSControls.VSToolbar, IDebugLocationControls
	{
		#region private members and constants
		// need to set it after debugging. 
		private const int ProgramComboBoxID = 0;
		private const int ThreadComboBoxID = 1;
		private const int CallstackComboBoxID = 2;
		#endregion

		#region constructors and helper
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open DebugLocation toolbar with default app 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebugLocation() : base(DefaultToolbars.DebugLocation)
		{
			
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open DebugLocation toolbar 
		/// </summary>
		/// <param name="application">IDEApp</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebugLocation(IDEApp application):base(application, DefaultToolbars.DebugLocation)
		{
		}
		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property IDebugLocationControls
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 12/6/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDebugLocationControls Controls
		{
			get
			{
				return this;
			}
		}
		#endregion

		#region Implementation of IDebugLocationControls
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property ProgramComboBox (VSToolbarItem)
		/// if you want to see the real value of this control, you need to read
		///		ProgramComboBox.AccessibleObject.Value
		///	in your test code.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 12/6/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		VSToolbarItem IDebugLocationControls.ProgramComboBox
		{
			get
			{
				return this.ToolbarItems[ProgramComboBoxID];
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property ThreadComboBox (VSToolbarItem)
		/// if you want to see the real value of this control, you need to read
		///		ThreadComboBox.AccessibleObject.Value
		///	in your test code.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 12/6/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		VSToolbarItem IDebugLocationControls.ThreadComboBox
		{
			get
			{
				return this.ToolbarItems[ThreadComboBoxID];
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property CallstackComboBox (VSToolbarItem)
		/// if you want to see the real value of this control, you need to read
		///		CallstackComboBox.AccessibleObject.Value
		///	in your test code.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 12/6/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		VSToolbarItem IDebugLocationControls.CallstackComboBox
		{
			get
			{
				return this.ToolbarItems[CallstackComboBoxID];
			}
		}
		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Disassembly.cs ===
using System;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger
{
	#region Interfaces for Disassembly window.
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDisassemblyControls
	{
		Maui.Core.WinControls.EditComboBox AddressComboBox
		{
			get;
		}

		Maui.VisualStudio.Everett.Ide.Editors.BaseEditor DisassemblyEdit
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDisassemblyVerify
	{
		bool CurrentCodeLine(string disassemblyCode);
		bool CodeLines(string[] disassemblyCodeLines);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDisassemblyAttributes
	{
		bool ShowAddress
		{
			get;
			set;
		}
		bool ShowSourceCode
		{
			get;
			set;
		}
		bool ShowCodeBytes
		{
			get;
			set;
		}
		bool ShowSymbolNames
		{
			get;
			set;
		}
		bool ShowLineNumbers
		{
			get;
			set;
		}
		bool ShowToolBar
		{
			get;
			set;
		}
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Disassembly
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you use the Document window you get when you execute the
	///   "Debug.Disassembly" command.
	///   this dialog can be based on "ToolWindow" because it can be docked. if it is needed
	///   later, it can be inherited from "ToolWindow". for now, we don't need this. 
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Disassembly : Maui.Core.RemotingObject, IDisassemblyControls, IDisassemblyVerify, IDisassemblyAttributes
	{
		#region Constant(control ID/command), private members
		private const string Caption = "VSDebugUI.dll:6:1:4";

		// const strings for context menus....
		private const string ShowAddressMenu = ":Show &Address:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8194";
		private const string ShowSourceCodeMenu = ":Show Source &Code:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8195";
		private const string ShowCodeBytesMenu = ":Show Code &Bytes:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8196";
		private const string ShowSymbolNamesMenu = ":Show Symbol &Names:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8197";
		private const string ShowLineNumbersMenu = ":Show &Line Numbers:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8198";
		private const string ShowToolBarMenu = ":Show &Toolbar:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8199";
		private const string GoToSourceCodeMenu = ":&Go To Source Code:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8193";
		private const string InsertBreakpointMenu = ":Insert B&reakpoint:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:375";
		private const string DisableBreakpointMenu = "";
		private const string RemoveBreakpointMenu = "";
		private const string BreakpointPropertiesMenu = ":&Breakpoint Properties...:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:260";
		private const string ShowNextStatementMenu = ":S&how Next Statement:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:259";
		private const string RunToCursorMenu = ":Ru&n To Cursor:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:251";
		private const string SetNextStatementMenu = ":Set Ne&xt Statement:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:258";
		
		private Maui.VisualStudio.Everett.Ide.Editors.TextEditor m_vsTextEditor = null;
		private int m_defaultTimeOut = 10000;
		private Maui.VisualStudio.Everett.IDEApp m_app;
		private int AddressComboBoxID = 0x019fe4e8;
		#endregion

		#region public members
		#endregion

		#region constructors and help functions for constructors. 
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open disassembly window with default application. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Disassembly()
		{
			RealConstrutor(CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open disassembly window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.VisualStudio.Everett.IDEApp</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Disassembly(Maui.VisualStudio.Everett.IDEApp application)
		{
			RealConstrutor(application);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function. because disassembly is not from project we need to have
		/// our own way to construct it instead of inherting from Edit control.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void RealConstrutor(Maui.VisualStudio.Everett.IDEApp application)
		{
			Maui.Core.Window window = null;

			// set app
			m_app = application;

			// call command to bring up disassembly window. 
			application.RaiseCmd(Constants.Commands.ViewDebugWindowsDisassembly);

			// get the window object with caption. 
			window = new Maui.Core.Window(application.GetIntlStr(Caption), StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch, m_app,DefaultTimeOut);
			if(window == null)
			{
				throw new Maui.GlobalExceptions.MauiException("Disassembly window doesn't come up");
			}
			else
			{
				// construct texteditor class with the window object.
				m_vsTextEditor = new Maui.VisualStudio.Everett.Ide.Editors.TextEditor(application,window);
				// set focus on window. 
				window.Extended.SetFocus();
			}
		}
		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IDisassemblyVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDisassemblyVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IDisassemblyAttributes interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/26/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDisassemblyAttributes Attributes
		{
			get
			{
				return this;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IDisassemblyControls interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/11/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDisassemblyControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return App
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.VisualStudio.Everett.IDEApp App
		{
			get
			{
				return m_app;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/11/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// return Context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/25/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.Core.WinControls.Menu ContextMenu
		{
			get
			{
				return new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			}
		}
		#endregion

		#region implementation of  IDisassemblyAttributes
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowAddress context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowAddress
		{
			get
			{
				return GetStatusOfContext(App.GetIntlStr(ShowAddressMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowAddressMenu),value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowSourceCode context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowSourceCode
		{
			get
			{
				return this.GetStatusOfContext(App.GetIntlStr(ShowSourceCodeMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowSourceCodeMenu),value);
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowCodeBytes context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowCodeBytes
		{
			get
			{
				return GetStatusOfContext(App.GetIntlStr(ShowCodeBytesMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowCodeBytesMenu),value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowSymbolName context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowSymbolNames
		{
			get
			{
				return GetStatusOfContext(App.GetIntlStr(ShowSymbolNamesMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowSymbolNamesMenu),value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowLineNumbers context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowLineNumbers
		{
			get
			{
				return GetStatusOfContext(App.GetIntlStr(ShowLineNumbersMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowLineNumbersMenu),value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowToolBar context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyAttributes.ShowToolBar
		{
			get
			{
				return GetStatusOfContext(App.GetIntlStr(ShowToolBarMenu));
			}

			set
			{
				SetStatusOfContext(App.GetIntlStr(ShowToolBarMenu),value);
			}
		}
		#endregion

		#region Implementation of IDisassemblyControls
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Address edit combo box is accessed. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.EditComboBox IDisassemblyControls.AddressComboBox
		{
			get
			{
				return new Maui.Core.WinControls.EditComboBox(m_vsTextEditor,AddressComboBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disassembly edit pane.  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.VisualStudio.Everett.Ide.Editors.BaseEditor IDisassemblyControls.DisassemblyEdit
		{
			get
			{
				return m_vsTextEditor;
			}
		}
		#endregion

		#region implementation of IDisassemblyVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify Current line on disassembly window.  
		/// </summary>
		/// <param name="disAsmCode">Current line as string</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/11/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyVerify.CurrentCodeLine(string disassemblyCode)
		{
			return	this.m_vsTextEditor.Verify.CurrentLine(disassemblyCode,true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify multi lines on disassembly window.  
		/// </summary>
		/// <param name="disAsmCode">lines as string and they should be down-ward.</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDisassemblyVerify.CodeLines(string[] disassemblyCodeLines)
		{
			bool returnValue = false;
			for(int i = disassemblyCodeLines.GetLowerBound(0); i < disassemblyCodeLines.GetUpperBound(0) ; i++)
			{
				returnValue = this.Verify.CurrentCodeLine(disassemblyCodeLines[i]);
				if(!returnValue)
				{
					break;
				}
				this.m_vsTextEditor.SendKeys("{DOWN}");
			}
			return returnValue;
		}
		#endregion

		#region Public Member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Go to source code.  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GoToSourceCode()
		{
			ContextMenu[App.GetIntlStr(GoToSourceCodeMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Insert breakpoint : it is available when there is not BP on the current line. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void InsertBreakpoint()
		{
			ContextMenu[App.GetIntlStr(InsertBreakpointMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disable breakpoint  : it is available when there is BP on the current line. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableBreakpoint()
		{
			ContextMenu[App.GetIntlStr(DisableBreakpointMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Remove breakpoint : it is available when there is BP on the current line. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RemoveBreakpoint()
		{
			ContextMenu[App.GetIntlStr(RemoveBreakpointMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Breakpoint properties : when there is breakpoint on current line. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public  Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog BreakpointProperties()
		{
			// Mkpark : Is this really correct design?
			// I'm not sure whether this should create BP Properties dialog here and return the instance. 
			Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog BPPropertiesDlg = null;
			ContextMenu[BreakpointPropertiesMenu].Execute();
			BPPropertiesDlg = new Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog(App);
			return BPPropertiesDlg;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show next statement 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public  void ShowNextStatement()
		{
			ContextMenu[App.GetIntlStr(ShowNextStatementMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to cursor 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor()
		{
			ContextMenu[App.GetIntlStr(RunToCursorMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Set next statement 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public  void SetNextStatement()
		{
			ContextMenu[App.GetIntlStr(SetNextStatementMenu)].Execute();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return current address of IP(current caret position.)   
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string GetCurrentAddressOfIP()
		{
				string currentLine;
				string[] arrayDisassembly = null;
				char[] delimiters = {' '};
				// make sure that Address is shown properly.
				this.Attributes.ShowAddress = true;
				// select line and get the current line.
				m_vsTextEditor.Cursor.SelectCurrentLine();
				currentLine = m_vsTextEditor.Cursor.SelectedText(true);
				
				// atomize the line. 
				arrayDisassembly = currentLine.Split(delimiters);
				// the first item should be address.
				return arrayDisassembly[0];
		}
		#endregion

		#region Private Member Functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get the status of menu item in context menu.  after get the status, it closes
		/// the menu. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private bool GetStatusOfContext(string menuName)
		{
			Maui.Core.WinControls.Menu menu = this.ContextMenu;
			bool returnValue = false;
			
			returnValue = menu[menuName].Checked;
			this.m_vsTextEditor.SendKeys("{ESC}");

			return returnValue;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Set the status of menu item in context menu.  after get the status, it closes
		/// the menu. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void SetStatusOfContext(string menuName,bool status)
		{
			Maui.Core.WinControls.Menu menu = this.ContextMenu;
			bool currentStatus = false;
			
			currentStatus = menu[menuName].Checked;
			if(currentStatus == status)
			{
				this.m_vsTextEditor.SendKeys("{ESC}");
			}
			else
			{
				menu[menuName].Checked = status;
			}
		}

		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Debugger.cs ===
//*********************************************************
// Owner : DaveBarn
// Class name : Debugger
// Description: 
//*********************************************************
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.VisualStudio.Everett.Ide.Editors;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger
{

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDebuggerSupport
	{
		void StartDbgProxy();
		void StopDbgProxy();
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Debugger
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Methods for Stepping, running and misc debugger settings.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn] 11/12/2002 Created
	/// 	[davebarn] 2/21/2003  Touched most methods to add EnC Dialog Handling
	/// </history>
	///-----------------------------------------------------------------------------
	public class Debugger: IDebuggerSupport
	{

		#region Exceptions
		public class Exceptions
		{
			[Serializable]
				public class General : MauiException
			{	
				public General(string message) : base(message) {}

				protected General(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class ModeException : MauiException
			{
				public ModeException(string message) : base(message) {}

				protected ModeException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class SetNextException : MauiException
			{
				public SetNextException(string message) : base(message) {}

				protected SetNextException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class EnCException : MauiException
			{
				public EnCException(string message) : base(message) {}

				protected EnCException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

#region Constants

		protected class Strings
		{
			public const string Dbgproxy =  "dbgproxy";
			public const string BreakMode = "msenvui.dll:6:822:3";	// 'Break' in titlebar 
			public const string RunMode = "msenvui.dll:6:822:2";	// 'Run' in titlebar 
			public const string DesignMode = "msenvui.dll:6:822:1";	// 'Design' in titlebar 
		}

		private const int DefaultTimeout = 30;
		private const int EnCTimeout = 1;
		private IDEApp m_app;

#endregion

#region Constructors

		public Debugger()
		{
			m_app = CoreManager.ActiveApp;
		}

		public Debugger(Maui.VisualStudio.Everett.IDEApp app)
		{
			m_app = app;
		}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Breaks execution at the currently runnning line (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Break()
		{
			Break(DebugMode.None, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Breaks execution at the currently runnning line
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Break(DebugMode ExpectedMode)
		{
			Break(ExpectedMode, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Breaks execution at the currently runnning line
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Break(DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Constants.Commands.DebugBreak, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5) (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue()
		{
			Continue(DebugMode.None, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue(DebugMode ExpectedMode)
		{
			Continue(ExpectedMode, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue(DebugMode ExpectedMode, int Timeout)
		{
			Continue(ExpectedMode, Timeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue(DebugMode ExpectedMode, EnCDialogAction encAction)
		{
			Continue(ExpectedMode, DefaultTimeout, 1, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue(DebugMode ExpectedMode, short Iterations)
		{
			Continue(ExpectedMode, DefaultTimeout, Iterations, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Continue execution of the debuggee (F5)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Continue(DebugMode ExpectedMode, int Timeout, short Iterations, EnCDialogAction encAction)
		{
			for( int i=0; i<Iterations; i++ )
				ModeAction(Constants.Commands.DebugStart, ExpectedMode, Timeout, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EndDebug()
		{
			EndDebug(DebugMode.None, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EndDebug(DebugMode ExpectedMode)
		{
			EndDebug(ExpectedMode, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EndDebug(DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Constants.Commands.DebugEnd, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging and step into the first line of code (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Restart()
		{
			Restart(DebugMode.None, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging and step into the first line of code
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Restart(DebugMode ExpectedMode)
		{
			Restart(ExpectedMode, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Stop debugging and step into the first line of code
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Restart(DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Constants.Commands.DebugRestart, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the current cursor position
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor()
		{
			RunToCursor(DebugMode.None, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the current cursor position
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor(DebugMode ExpectedMode)
		{
			RunToCursor(ExpectedMode, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the current cursor position
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor(DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Constants.Commands.DebugRunToCursor, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the current cursor position
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor(DebugMode ExpectedMode, EnCDialogAction encAction)
		{
			ModeAction(Constants.Commands.DebugRunToCursor, ExpectedMode, DefaultTimeout, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the specified cursor position
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="line">new cursor line position</param>
		/// <param name="column">new cursor column position</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor(DebugMode ExpectedMode, int Timeout, BaseEditor editor, int line, int column)
		{
			editor.SetFocus();
			editor.Cursor.Move(line, column);
			editor.WaitForResponse();

			ModeAction(Constants.Commands.DebugRunToCursor, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run to the cursor position with the specified text
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="text">text to search for</param>
		/// <param name="instance">instance of the specified text to find</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor(DebugMode ExpectedMode, int Timeout, BaseEditor editor, string text, int instance)
		{
			editor.SetFocus();
			m_app.ExtensibilityObject.Find(text, Maui.VisualStudio.Everett.MauiDTE.FindOption.FromStart, instance);

			ModeAction(Constants.Commands.DebugRunToCursor, ExpectedMode, Timeout);
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts the target application but does not attach the debugger (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StartWithoutDebugging()
		{
			StartWithoutDebugging(DebugMode.None, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts the target application but does not attach the debugger
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StartWithoutDebugging(DebugMode ExpectedMode)
		{
			StartWithoutDebugging(ExpectedMode, DefaultTimeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts the target application but does not attach the debugger
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StartWithoutDebugging(DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Constants.Commands.DebugStartWithoutDebugging, ExpectedMode, Timeout);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto()
		{
			StepInto(DebugMode.None, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto(DebugMode ExpectedMode)
		{
			StepInto(ExpectedMode, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto(DebugMode ExpectedMode, int Timeout)
		{
			StepInto(ExpectedMode, Timeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto(DebugMode ExpectedMode, EnCDialogAction encAction)
		{
			StepInto(ExpectedMode, DefaultTimeout, 1, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto(DebugMode ExpectedMode, short Iterations)
		{
			StepInto(ExpectedMode, DefaultTimeout, Iterations, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepInto(DebugMode ExpectedMode, int Timeout, short Iterations, EnCDialogAction encAction)
		{
			for( int i=0; i<Iterations; i++ )
				ModeAction(Constants.Commands.DebugStepInto, ExpectedMode, Timeout, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut()
		{
			StepOut(DebugMode.None, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut(DebugMode ExpectedMode)
		{
			StepOut(ExpectedMode, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut(DebugMode ExpectedMode, int Timeout)
		{
			StepOut(ExpectedMode, Timeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut(DebugMode ExpectedMode, EnCDialogAction encAction)
		{
			StepOut(ExpectedMode, DefaultTimeout, 1, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut(DebugMode ExpectedMode, short Iterations)
		{
			StepOut(ExpectedMode, DefaultTimeout, Iterations, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Steps to the first line outside of current method
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOut(DebugMode ExpectedMode, int Timeout, short Iterations, EnCDialogAction encAction)
		{
			for( int i=0; i<Iterations; i++ )
				ModeAction(Constants.Commands.DebugStepOut, ExpectedMode, Timeout, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods (no mode verification)
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver()
		{
			StepOver(DebugMode.None, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver(DebugMode ExpectedMode)
		{
			StepOver(ExpectedMode, DefaultTimeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver(DebugMode ExpectedMode, int Timeout)
		{
			StepOver(ExpectedMode, Timeout, 1, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver(DebugMode ExpectedMode, EnCDialogAction encAction)
		{
			StepOver(ExpectedMode, DefaultTimeout, 1, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver(DebugMode ExpectedMode, short Iterations)
		{
			StepOver(ExpectedMode, DefaultTimeout, Iterations, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes a single step but does not step into any other methods
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="Iterations">Number of times to execute command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StepOver(DebugMode ExpectedMode, int Timeout, short Iterations, EnCDialogAction encAction)
		{
			for( int i=0; i<Iterations; i++ )
				ModeAction(Constants.Commands.DebugStepOver, ExpectedMode, Timeout, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts Debugging (no mode verification)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Start()
		{
			Start(DebugMode.None, DefaultTimeout, -1);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts Debugging
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Start(DebugMode ExpectedMode)
		{
			Start(ExpectedMode, DefaultTimeout, -1);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts Debugging
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Start(DebugMode ExpectedMode, int SecondsToTimeout)
		{
			Start(ExpectedMode, SecondsToTimeout, -1);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Starts Debugging
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="SecondsToWaitForStart">Seconds to wait before checking for expected mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Start(DebugMode ExpectedMode, int Timeout, int SecondsToWaitForStart)
		{
			if( SecondsToWaitForStart == -1 )
				ModeAction(Constants.Commands.DebugStart, ExpectedMode, Timeout);
			else
			{
				// After F5, wait to get out of Design mode and then wait for the expected mode
				m_app.BringToForeground();
				m_app.RaiseCmd(Constants.Commands.DebugStart);
				m_app.MainWindow.WaitForResponse();

				// Wait to leave Design mode
				for( int i=0; i<SecondsToWaitForStart; i++)
				{
					if( this.Mode != DebugMode.Design )
					{
						m_app.MainWindow.WaitForResponse();
						break;
					}
					else
						Sleeper.Delay(1000);
				}

				// Wait to get to Expected Mode
				for(int i=0; i<Timeout; i++)
				{
					if( this.Mode == ExpectedMode )
					{
						m_app.MainWindow.WaitForResponse();
						return;
					}
					else
						Sleeper.Delay(1000);
				}

				// Return an error if expected mode can't be verified
				throw new Exceptions.ModeException("Could not verify expected mode");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to execute most step/start/end  methods
		/// </summary>
		/// <param name="Cmd">DTE Command to send</param>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void ModeAction(string Cmd, DebugMode ExpectedMode, int Timeout)
		{
			ModeAction(Cmd, ExpectedMode, Timeout, null, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to execute most step/start/end  methods
		/// </summary>
		/// <param name="Cmd">DTE Command to send</param>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait to the Expected Mode</param>
		/// <param name="encAction">action to take when EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void ModeAction(string Cmd, DebugMode ExpectedMode, int Timeout, EnCDialogAction encAction)
		{
			ModeAction(Cmd, ExpectedMode, Timeout, null, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to execute most step/start/end  methods
		/// </summary>
		/// <param name="Cmd">DTE Command to send</param>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">>Seconds to wait to the Expected Mode</param>
		/// <param name="FocusWindow">Window to place focus on before executing command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void ModeAction(string Cmd, DebugMode ExpectedMode, int Timeout, Core.Window FocusWindow, EnCDialogAction encAction)
		{
			if( FocusWindow == null )
				m_app.BringToForeground();
			else
				FocusWindow.Extended.SetFocus();
		
			m_app.MainWindow.WaitForResponse();
			m_app.RaiseCmd(Cmd);
			m_app.MainWindow.WaitForResponse();

			// Deal with possible EnC Dialog
			this.HandleEnCDialog(encAction);
			
			if( ExpectedMode != DebugMode.None )
			{
				// The IDE waits one second before updating the title bar
				Sleeper.Delay(1000);    // is this needed because of EnC Dialog check?

				// If expecting run mode, then a form, etc could be on top, so SetFocus back to IDE
				if( ExpectedMode == DebugMode.Run )
					m_app.BringToForeground();

				// Wait until we get expected mode (or timeout)
				for( int i=0; i<Timeout; i++)
					if( this.Mode == ExpectedMode )
					{
						m_app.MainWindow.WaitForResponse();
						return;
					}
					else
						Sleeper.Delay(1000);

				// Return an error if expected mode can't be verified
				throw new Exceptions.ModeException("Could not verify expected mode");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the current mode of the IDE - design, run, or break
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebugMode Mode 
		{
			get
			{
				// IntlStr returns " [%sbreak]", so ignore first 4 chars
				string Caption = m_app.MainWindow.Caption;

				if( Caption.IndexOf(m_app.GetIntlStr(Debugger.Strings.BreakMode).Substring(5)) > 0 )
					return DebugMode.Break;
				else if( Caption.IndexOf(m_app.GetIntlStr(Debugger.Strings.RunMode).Substring(5)) > 0 )
					return DebugMode.Run;
				else if( Caption.IndexOf(m_app.GetIntlStr(Debugger.Strings.DesignMode).Substring(5)) > 0 )
					return DebugMode.Design;
				else
					return DebugMode.None;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Method to wait for mode to change to ExpectedMode.
		/// </summary>
		/// <param name="ExpectedMode">Mode the IDE should be in after command is completed</param>
		/// <param name="Timeout">Seconds to wait for the Expected Mode</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void WaitForModeChange(DebugMode ExpectedMode, int Timeout)
		{
			int Count = 0;

			while( Count<Timeout )
			{
				if( this.Mode != ExpectedMode )
				{						   
					Sleeper.Delay(1000);
					Count++;
				}
				else
				{
					m_app.MainWindow.WaitForResponse();
					return;
				}
			}

			throw new Exceptions.ModeException("Could not verify expected mode");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the editor for and moves to the next line to be executed
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ShowNextStatement()
		{
			m_app.RaiseCmd(Constants.Commands.DebugShowNextStatement);
			m_app.MainWindow.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the specified line and column
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="line">new cursor line position</param>
		/// <param name="column">new cursor column position</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, int line, int column)
		{
			SetNextStatement(editor, line, column, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the specified line and column
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="line">new cursor line position</param>
		/// <param name="column">new cursor column position</param>
		/// <param name="encAction">action to take if EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, int line, int column, EnCDialogAction encAction)
		{
			editor.SetFocus();
			editor.Cursor.Move(line, column);

			SetNextWorker(editor, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the line with the specified text
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="text">text to search for</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, string text)
		{
			SetNextStatement(editor, text, 1);
		}
	
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the line with the specified text
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="text">text to search for</param>
		/// <param name="instance">instance of the specified text to find</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, string text, int instance)
		{
			SetNextStatement(editor, text, instance, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the line with the specified text
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="text">text to search for</param>
		/// <param name="instance">instance of the specified text to find</param>
		/// <param name="encAction">action to take if EnC Dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, string text, int instance, EnCDialogAction encAction)
		{
			editor.SetFocus();
			m_app.ExtensibilityObject.Find(text, Maui.VisualStudio.Everett.MauiDTE.FindOption.FromStart, instance);

			SetNextWorker(editor, encAction);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the PC to the line with the specified text
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <param name="text">text to search for</param>
		/// <param name="moveToStartOfLine">moves the cursor to the first char in the line</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNextStatement(BaseEditor editor, string text, bool moveToStartOfLine)
		{
			editor.SetFocus();
			m_app.ExtensibilityObject.Find(text, Maui.VisualStudio.Everett.MauiDTE.FindOption.FromStart, 1);

			if( moveToStartOfLine ) 
				Keyboard.SendKeys("{HOME}");

			SetNextWorker(editor, EnCDialogAction.NotExpected);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to send SetNext command and look for error dialog
		/// </summary>
		/// <param name="editor">editor to move the cursor postion in</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void SetNextWorker(BaseEditor editor, EnCDialogAction encAction)
		{
			m_app.RaiseCmd(Constants.Commands.DebugSetNextStatement);
			editor.WaitForResponse();

			// Deal with possible EnC Dialog
			HandleEnCDialog(encAction);

			// Throw exception if Unable to set next at this location
			Alert alert = Alert.HandleAlert(null, AlertAction.NoAction, m_app.MainWindow, 1000, false);
			if( null != alert )
			{
				alert.Controls.OKButton.Click();
				throw new Exception("Unable to Set Next at this location");
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to deal with the EnCDialog
		/// </summary>
		/// <param name="encAction">Action to take when dialog comes up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 2/21/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void HandleEnCDialog(EnCDialogAction encAction)
		{
			// Check for EnC Dialog
			try 
			{
				Dialogs.EditAndContinueDialog encDialog = new Dialogs.EditAndContinueDialog(EnCTimeout);

				if( encAction == EnCDialogAction.NotExpected )
					throw new Exceptions.EnCException("Unexpected EnC dialog found.");
				else
				{
					switch( encAction )
					{
						case EnCDialogAction.EditCode :
							encDialog.ClickEditCodeButton();
							break;
						case EnCDialogAction.Help :
							encDialog.ClickHelpButton();
							break;
						case EnCDialogAction.Ignore :
							encDialog.ClickIgnoreButton();
							break;
					}
				}
			}
			catch
			{
				// exception happens if dialog is not found. If we expect it, then throw to testcase
				if( encAction != EnCDialogAction.NotExpected )
				{
					throw new Exceptions.EnCException("Expected EnC dialog not found.");
				}
			}
		}

		#region IDebuggerSupport implementation

		///-----------------------------------------------------------------------------
		/// <summary>
		/// StartDbgProxy method handles the starting of the dbgproxy service.  This is 
		/// needed for detaching native apps on win2k
		/// </summary>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IDebuggerSupport.StartDbgProxy()
		{

			// Win2k check, this function only supports Win2k
			if ( (SystemInfo.Platform.Version.Major != 5) && (SystemInfo.Platform.Version.Minor != 0))
			{
				throw new Exceptions.General("Calling SetDbgProxy on a non Win2k machine.");
			}

            System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(Strings.Dbgproxy);

            serviceController.Start();
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// StopDbgProxy method handles the stopping of the dbgproxy service.  This is 
		/// needed for detaching native apps on win2k
		/// </summary>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IDebuggerSupport.StopDbgProxy()
		{

			// Win2k check, this function only supports Win2k
			if ( (SystemInfo.Platform.Version.Major != 5) && (SystemInfo.Platform.Version.Minor != 0))
			{
				throw new Exceptions.General("Calling SetDbgProxy on a non Win2k machine.");
			}

			System.ServiceProcess.ServiceController serviceController = new System.ServiceProcess.ServiceController(Strings.Dbgproxy);
			serviceController.Stop();
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\BreakPoints.cs ===
using System;
using System.Runtime.Serialization;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett.Ide.Editors;
 
namespace Maui.VisualStudio.Everett.Debugger
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: BreakPoints
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class implements the Breakpoints conceptual layer
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/5/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------

	public class BreakPoints : Maui.Core.RemotingObject
	{
		#region Exceptions
        public class Exceptions
		{
			[Serializable]
				public class TextNotFoundException : MauiException
			{
				public TextNotFoundException(string message) : base(message) {}

				protected TextNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class BreakpointWindowException : MauiException
			{
				public BreakpointWindowException(string message) : base(message) {}

				protected BreakpointWindowException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		private IDEApp m_app;
		#region strings
		private const string DisableBreakpointMenu = ":&Disable Breakpoint:Win32String:vsdebugui.dll:132";
		private const string EnableBreakpointMenu = ":Enab&le Breakpoint:CTMenuString:vsdebugui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:376";
		private const string NewBreakpointMenu = ":New &Breakpoint...:CTMenuString:vsdebugui.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:4097";
		private const string BreakpointPropertiesMenu = ":&Breakpoint Properties...:CTMenuString:vsdebugui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:260";
		private const string DoYouWantToClearAllBreakpointsErrMsg = ":Do you want to clear all breakpoints?:Win32String:VSDebugUI.dll:225";
		private const int m_timeout = 5000;
		#endregion
		#region constructors and help functions for constructors. 
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default constructor with the defualt appliction
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------		

		public BreakPoints()
		{
			Init(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor with a given application
		/// </summary>
		/// <param name="application">given application </param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------	
		public BreakPoints(IDEApp application)
		{
			Init(application);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(Maui.VisualStudio.Everett.IDEApp application)
		{
			this.App = application;

		}
		#endregion
		#region properties


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return IDEApp object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkoller] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDEApp App
		{
			get
			{
				return m_app;
			}
			set
			{
				m_app = value;
			}
		}
		#endregion

		#region Member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets BP on current line in the active window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ToggleBreakpoint()
		{
			App.RaiseCmd(Constants.Commands.DebugInsertBreakpoint);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets a location bp at the specified line and column in the active window
		/// </summary>
		/// <param name="LineNo">line to set the BP at</param>
		/// <param name="ColumnNo">column to set the BP at</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ToggleBreakpoint(int LineNo, int ColumnNo)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.GoToLine(0);
			codeobj.Cursor.Move(LineNo,ColumnNo);
			ToggleBreakpoint();

		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets a BP on the line containing the specified comment
		/// </summary>
		/// <returns>the line where the BP was set</returns>
		/// <param name="Comment">comment to look for in the editor</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ToggleBreakpoint(string Comment)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor editor = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			return ToggleBreakpoint(editor, Comment);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets a BP on the line containing the specified comment
		/// </summary>
		/// <returns>the line where the BP was set</returns>
		/// <param name="editor">editor to search for text in</param>
		/// <param name="Comment">text to search for</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ToggleBreakpoint(BaseEditor editor, string Comment)
		{
			editor.SetFocus();
			editor.Cursor.Move(1,1);

			if( m_app.ExtensibilityObject.Find(Comment) == Maui.VisualStudio.Everett.MauiDTE.FindResult.Found)
			{
				editor.WaitForResponse();
				editor.SendKeys("{LEFT}");
				m_app.RaiseCmd(Constants.Commands.DebugInsertBreakpoint);
				editor.WaitForResponse();

				return editor.Cursor.Line();
			}
			else
				throw new Exceptions.TextNotFoundException("Specified text was not found.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Enable the BP on the current line
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EnableLocationBreakpoint()
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(EnableBreakpointMenu)].Execute();
			codeobj.WaitForResponse();

		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Enables the location bp at the specified line and column in the source code 
		/// </summary>
		/// <param name="LineNo">line of the BP</param>
		/// <param name="ColumnNo">column of the BP</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EnableLocationBreakpoint(int LineNo, int ColumnNo)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			codeobj.GoToLine(0);
			codeobj.Cursor.Move(LineNo,ColumnNo);
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(EnableBreakpointMenu)].Execute();
			codeobj.WaitForResponse();			
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Enables the BP on the line containing the specified comment
		/// </summary>
		/// <param name="Comment">comment to look for in the editor</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EnableLocationBreakpoint(string Comment)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor editor = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			EnableLocationBreakpoint(editor, Comment);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Enables the BP on the line containing the specified comment
		/// </summary>
		/// <param name="editor">editor to search for text in</param>
		/// <param name="Comment">text to search for</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EnableLocationBreakpoint(BaseEditor editor, string Comment)
		{
			editor.SetFocus();
			editor.Cursor.Move(1,1);

			if( m_app.ExtensibilityObject.Find(Comment) == Maui.VisualStudio.Everett.MauiDTE.FindResult.Found)
			{
				editor.WaitForResponse();

				Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
				contextMenu[App.GetIntlStr(EnableBreakpointMenu)].Execute();
				editor.WaitForResponse();
			}
			else
				throw new Exceptions.TextNotFoundException("Specified text was not found.");
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the BP on the current line
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableLocationBreakpoint()
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(DisableBreakpointMenu)].Execute();
			codeobj.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the bp at the specified line and column in the source code 
		/// </summary>
		/// <param name="LineNo">line of the BP</param>
		/// <param name="ColumnNo">column of the BP</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableLocationBreakpoint(int LineNo, int ColumnNo)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			codeobj.GoToLine(0);
			codeobj.Cursor.Move(LineNo,ColumnNo);
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(DisableBreakpointMenu)].Execute();
			codeobj.WaitForResponse();					
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the BP on the line containing the specified comment
		/// </summary>
		/// <param name="Comment">comment to look for in the editor</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableLocationBreakpoint(string Comment)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor editor = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			DisableLocationBreakpoint(editor, Comment);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the BP on the line containing the specified comment
		/// </summary>
		/// <param name="editor">editor to search for text in</param>
		/// <param name="Comment">text to search for</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableLocationBreakpoint(BaseEditor editor, string Comment)
		{
			editor.SetFocus();
			editor.Cursor.Move(1,1);

			if( m_app.ExtensibilityObject.Find(Comment) == Maui.VisualStudio.Everett.MauiDTE.FindResult.Found)
			{
				editor.WaitForResponse();

				Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
				contextMenu[App.GetIntlStr(DisableBreakpointMenu)].Execute();
				editor.WaitForResponse();
			}
			else
				throw new Exceptions.TextNotFoundException("Specified text was not found.");
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes all the BPs; dismisses the error message that comes up with yes
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		///				  [mkpark] 02/21/2003 the confirmation dlg doesn't come up when there is not any BP at all. so I put try/catch around it.
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClearAllBreakpoints()
		{
			App.RaiseCmd(Constants.Commands.DebugClearAllBreakpoints);
			try
			{
				Alert.HandleAlert(App.GetIntlStr(DoYouWantToClearAllBreakpointsErrMsg), AlertAction.ClickYes,App.MainWindow, m_timeout, true);
			}
			catch
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Verbose,"Confirmation dialog doesn't come up");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes all the BPs
		/// </summary>
		/// <param name="ClearAllBreakpoints">if true, dismisses the "Do you want to clear all breakpoints?" message with Yes; or with No if false</param>
		/// <param name="focusThisWnd">window to se the focus on after the "Do you want to clear all breakpoints?" message is dismissed</param>
		/// <param name="ErrorIfMessageNotUp">if true, throws an exception if the "Do you want to clear all breakpoints?" is not up after m_timeout miliseconds</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClearAllBreakpoints(bool ClearAllBreakpoints, Maui.Core.Window focusThisWnd, bool ErrorIfMessageNotUp)
		{
			App.RaiseCmd(Constants.Commands.DebugClearAllBreakpoints);
			try
			{
			Alert.HandleAlert(App.GetIntlStr(DoYouWantToClearAllBreakpointsErrMsg), ClearAllBreakpoints ? AlertAction.ClickYes : AlertAction.ClickNo, focusThisWnd, m_timeout, ErrorIfMessageNotUp);
			}
			catch
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Verbose,"Confirmation dialog doesn't come up");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Setd a function BP
		/// </summary>
		/// <param name="FuncName">Name of the function to set the BP at</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetFunctionBreakpoint(string FuncName)
		{
			App.MainWindow.WaitForResponse();
			App.RaiseCmd(Constants.Commands.BreakpointWindowNewBreakpoint);
			App.MainWindow.WaitForResponse();
			Dialogs.BreakPointPropertiesDialog BPProp=new Dialogs.BreakPointPropertiesDialog(true);
			BPProp.BreakpointTypesTabControlTabValue = BreakpointInfo.BreakpointType.Function;
			BPProp.FunctionTextBoxText = FuncName;
			BPProp.ClickOK();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the properties of the specified BP
		/// </summary>
		/// <param name="BreakpointIndex">0-based index of the BP in the Breakpoints window</param>
		/// <param name="bp">BreakpointInfo struct that contains the information to set</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetBreakpointProperties(int BreakpointIndex, BreakpointInfo bp)
		{
			ToolWindows.BreakpointWindow BPWnd = new ToolWindows.BreakpointWindow();
			Dialogs.BreakPointPropertiesDialog BPProp = BPWnd[BreakpointIndex].OpenBreakpointPropertiesDialog();
			SetProperties(BPProp, bp);
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets a new BP
		/// </summary>
		/// <param name="bp">BreakpointInfo struct that contains the information to set</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		///				  [mkpark] 3/31/2003   changed to use DTE command. 
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetNewBreakpoint(BreakpointInfo bp)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			App.RaiseCmd(Maui.VisualStudio.Everett.Constants.Commands.DebugNewBreakpoint);
			Dialogs.BreakPointPropertiesDialog BPProp = new Dialogs.BreakPointPropertiesDialog(true);
			SetProperties(BPProp, bp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// gets the properties of the specified BP
		/// </summary>
		/// <param name="BreakpointIndex">0-based index of the BP in the Breakpoints window</param>
		/// <param name="bp">BreakpointInfo struct that will contain the information to get</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GetBreakpointProperties(int BreakpointIndex, ref BreakpointInfo bp)
		{
			ToolWindows.BreakpointWindow BPWnd = new ToolWindows.BreakpointWindow();
			Dialogs.BreakPointPropertiesDialog BPProp = BPWnd[BreakpointIndex].OpenBreakpointPropertiesDialog();
			GetProperties(BPProp, ref bp);
		
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// gets the properties of the specified BP
		/// </summary>
		/// <param name="BreakpointString">text of the BP in the Breapoints window</param>
		/// <param name="bp">BreakpointInfo struct that will contain the information to get</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GetBreakpointProperties(string BreakpointString, ref BreakpointInfo bp)
		{
			ToolWindows.BreakpointWindow BPWnd = new ToolWindows.BreakpointWindow();
			Dialogs.BreakPointPropertiesDialog BPProp = BPWnd[BreakpointString].OpenBreakpointPropertiesDialog();
			GetProperties(BPProp, ref bp);		
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// gets the properties of the BP at the current cursor location
		/// </summary>
		/// <param name="bp">BreakpointInfo struct that will contain the information to get</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GetBreakpointProperties(ref BreakpointInfo bp)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(BreakpointPropertiesMenu)].Execute();
			Dialogs.BreakPointPropertiesDialog BPProp = new Dialogs.BreakPointPropertiesDialog();
			GetProperties(BPProp, ref bp);	
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// gets the properties of the BP at the cursor location specified by iLineNo and iColumnNo
		/// </summary>
		/// <param name="LineNo">line of the BP</param>
		/// <param name="ColumnNo">column of the BP</param>
		/// <param name="bp">BreakpointInfo struct that will contain the information to get</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GetBreakpointProperties(int LineNo, int ColumnNo, ref BreakpointInfo bp)
		{
			Maui.VisualStudio.Everett.Ide.Editors.BaseEditor codeobj = new Maui.VisualStudio.Everett.Ide.Editors.CodeEditor();
			codeobj.SetFocus();
			codeobj.GoToLine(0);
			codeobj.Cursor.Move(LineNo,ColumnNo);
			Maui.Core.WinControls.Menu contextMenu = new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			contextMenu[App.GetIntlStr(BreakpointPropertiesMenu)].Execute();
			Dialogs.BreakPointPropertiesDialog BPProp = new Dialogs.BreakPointPropertiesDialog();
			GetProperties(BPProp, ref bp);	
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Resets the HiCount property of the breakpoint with the given index in the Breakpoints window
		/// </summary>
		/// <param name="BreakpointIndex">0-based index of the BP in the Breakpoints window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ResetHitCount(int BreakpointIndex)
		{
			ToolWindows.BreakpointWindow BPWnd = new ToolWindows.BreakpointWindow();
			Dialogs.BreakPointPropertiesDialog BPPropDlg = BPWnd[BreakpointIndex].OpenBreakpointPropertiesDialog();
			BPPropDlg.ClickHitCount();
			Dialogs.HitCountDialog HitCountDlg = new Dialogs.HitCountDialog();
			HitCountDlg.ClickResetHitCount();
			HitCountDlg.ClickOK();
			BPPropDlg.ClickOK();

		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// gets the data in the Breakpoint Properties dialog
		/// </summary>
		/// <param name="BPProp">Breakpoint Properties window object to get the data from </param>
		/// <param name="bp">BreakpointInfo structure to put the data into </param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void GetProperties(Dialogs.BreakPointPropertiesDialog BPProp, ref BreakpointInfo bp)
		{
			bp.BPType = BPProp.BreakpointTypesTabControlTabValue;
			switch(bp.BPType)
			{
					//the properties inside the tab control
				case BreakpointInfo.BreakpointType.File:
					bp.FileName = BPProp.FileTextBoxText;
					bp.LineNo = System.Convert.ToInt32(BPProp.FileLineTextBoxText);
					bp.Character = System.Convert.ToInt32(BPProp.FileCharacterTextBoxText);
					break;
				case BreakpointInfo.BreakpointType.Function:
					bp.FunctionName = BPProp.FunctionTextBoxText;
					bp.FileName = BPProp.FileTextBoxText;
					bp.Character = System.Convert.ToInt32(BPProp.FileCharacterTextBoxText);
					bp.BPLanguage = BPProp.LanguageEditComboBoxValue;
					break;
				case BreakpointInfo.BreakpointType.Address:
					bp.Address = BPProp.AddressTextBoxText;
					bp.BPLanguage = BPProp.LanguageEditComboBoxValue;
					break;
				case BreakpointInfo.BreakpointType.Data:
					bp.Variable = BPProp.DataVariableTextBoxText;
					bp.items = System.Convert.ToInt32(BPProp.DataItemsTextBoxText);
					bp.context = BPProp.DataContextTextBoxText;
					bp.BPLanguage = BPProp.LanguageEditComboBoxValue;
					break;		
			}

			//condition
			if(BPProp.ConditionStaticControlText != "")
			{
				BPProp.ClickCondition();
				Dialogs.ConditionDialog BPCondDlg = new Dialogs.ConditionDialog();
				bp.ConditionText = BPCondDlg.ConditionTextBoxText;
				bp.BPConditionType = BPCondDlg.BreakpointConditionType;
				BPCondDlg.ClickOK();
			}
			//hitCount
			if(BPProp.HitCountStaticControlText != "")
			{
				BPProp.ClickHitCount();
				Dialogs.HitCountDialog BPHitCountDlg = new Dialogs.HitCountDialog();
				bp.BPHitType = BPHitCountDlg.WhenTheBreakpointIsHitEditComboBoxValue;
				if(bp.BPHitType != BreakpointInfo.HitCountType.Always)
					bp.hitCount = System.Convert.ToInt32(BPHitCountDlg.HitCountIsTextBoxText);
				BPHitCountDlg.ClickOK();
			}
			//hit OK in the BP Properties dialog
			BPProp.ClickOK();		
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets the data in the Breakpoint Properties dialog
		/// </summary>
		/// <param name="BPProp">Breakpoint Properties window object to get the data from </param>
		/// <param name="bp">BreakpointInfo structure to get the data from </param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void SetProperties(Dialogs.BreakPointPropertiesDialog BPProp, BreakpointInfo bp)
		{
			BPProp.BreakpointTypesTabControlTabValue = bp.BPType;
			switch(bp.BPType)
			{
					//the properties inside the tab control
				case BreakpointInfo.BreakpointType.File:
					if(bp.FileName != "")
						BPProp.FileTextBoxText = bp.FileName;
					if(bp.LineNo != -1)
						BPProp.FileLineTextBoxText = bp.LineNo.ToString();
					if(bp.Character != -1)
						BPProp.FileCharacterTextBoxText = bp.Character.ToString();
					break;
				case BreakpointInfo.BreakpointType.Function:
					if(bp.FunctionName != "")
						BPProp.FunctionTextBoxText = bp.FunctionName;
					if(bp.LineNo != -1)
						BPProp.FileTextBoxText = bp.FileName;
					if(bp.Character != -1)
						BPProp.FileCharacterTextBoxText = bp.Character.ToString();
					if(bp.BPLanguage != BreakpointInfo.Language.None)
						BPProp.LanguageEditComboBoxValue = bp.BPLanguage;
					break;
				case BreakpointInfo.BreakpointType.Address:
					if(bp.Address != "")
						BPProp.AddressTextBoxText = bp.Address;
					if(bp.BPLanguage != BreakpointInfo.Language.None)
						BPProp.LanguageEditComboBoxValue = bp.BPLanguage;
					break;
				case BreakpointInfo.BreakpointType.Data:
					if(bp.Variable != "")
						BPProp.DataVariableTextBoxText = bp.Variable;
					if(bp.items != -1)
						BPProp.DataItemsTextBoxText = bp.items;
					if(bp.context != "")
						BPProp.DataContextTextBoxText = bp.context;
					if(bp.BPLanguage != BreakpointInfo.Language.None)
						BPProp.LanguageEditComboBoxValue = bp.BPLanguage;
					break;
			}
			//condition
			if(bp.BPConditionType != BreakpointInfo.ConditionType.None)
			{
				BPProp.ClickCondition();
				Dialogs.ConditionDialog BPCondDlg = new Dialogs.ConditionDialog();
				BPCondDlg.ConditionTextBoxText = bp.ConditionText;
				if(bp.BPConditionType == BreakpointInfo.ConditionType.IsTrue)
					BPCondDlg.ClickIsTrue();
				else
					BPCondDlg.ClickHasChanged();
				BPCondDlg.ClickOK();
			}
			//hitCount
			if(bp.BPHitType != BreakpointInfo.HitCountType.None)
			{
				BPProp.ClickHitCount();
				Dialogs.HitCountDialog BPHitCountDlg = new Dialogs.HitCountDialog();
				BPHitCountDlg.WhenTheBreakpointIsHitEditComboBoxValue = bp.BPHitType;

				if(bp.hitCount!= -1 && bp.BPHitType != BreakpointInfo.HitCountType.Always)
					BPHitCountDlg.HitCountIsTextBoxText = bp.hitCount.ToString();
				BPHitCountDlg.ClickOK();
			}
			//hit OK in the BP Properties dialog
			BPProp.ClickOK();		
		}

		#endregion
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Class that defines all the properties of a breakpoint object
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/03/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class BreakpointInfo : Maui.Core.RemotingObject
	{
		public enum BreakpointType
		{
			File,
			Data,
			Function,
			Address
		}
		public enum Language
		{
			Basic,
			CS,
			CPP,
			JScript,
			Script,
			SQL,
			Unknown,
			VJS,
			None
		}

		public enum ConditionType
		{
			IsTrue,
			HasChanged,
			None
		}

		public enum HitCountType
		{
			Always,
			Equal,
			MultipleOf,
			GreaterThanEqual,
			None
		}
		#region private members
		private int m_character;
		private int m_line;
		private int m_column;
		private int m_hitCount;
		#endregion
		
		#region properties

		///-----------------------------------------------------------------------------
		/// <summary>
		///properties for the BreakpointObject
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkoller] 	11/05/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		
	
		public BreakpointType BPType;
		public Language BPLanguage;
		
		//Line BP
		public string FileName;
		public int LineNo
		{
			get
			{return m_line;}
			set
			{m_line=value;}
		}
		public int ColumnNo
		{
			get
			{return m_column;}
			set
			{m_column=value;}
		}

		//Condition BP
		public ConditionType BPConditionType;
		public string ConditionText;

		//HitCount BP
		public HitCountType BPHitType;
		public int hitCount
		{
			get
			{return m_hitCount;}
			set
			{m_hitCount=value;}
		}

		//Function BP
		public string FunctionName;
		public int Character
		{
			get
			{return m_character;}
			set
			{m_character=value;}
		}
	

		//Address BP
		public string Address;

		//Data BP
		public string Variable;
		public int items;
		public string context;
	
		#endregion	
		#region constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default constructor with the defualt appliction
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/03/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointInfo()
		{
			//Line BP
			FileName = "";
			LineNo = -1;
			ColumnNo = -1;

			hitCount = -1;

			//Function BP
			FunctionName = "";
			Character = -1;

			//Address BP
			Address = "";

			//Data BP
			Variable = "";
			items = -1;
			context = "";	
			
			BPConditionType = ConditionType.None;
			BPHitType = HitCountType.None;
			ConditionText = "";

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Enums.cs ===
using System;

namespace Maui.VisualStudio.Everett.Debugger
{
	///-----------------------------------------------------------------------------
	/// <summary>
	/// "Debugger Modes enum"
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum DebugMode
	{
		Break,
		Design,
		Run,
		None
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// "Variable Window Row states enum"
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum RowExpandState
	{
		Expanded,
		Collapsed,
		NotExpandable,
		DontCare
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// "Breakpoint languages"
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum BreakpointLanguages
	{
		Basic,
		C,
		CSharp,
		Cxx,
		FoxPro,
		JScript,
		Script,
		SQL,
		Unknown
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// "Actions for dealing with EnC dialog after step/run"
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum EnCDialogAction
	{
		EditCode,
		Ignore,
		Help,
		NotExpected
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Controls\DebuggerToolTreeGrid.cs ===
using System;
using Maui.Core;

namespace Maui.VisualStudio.Everett.Debugger.Controls
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggerToolTreeGrid
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// TreeGrid implementation specific to a Debugger Tool window - CallStack, Threads, Modules
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[mkoller]	11/12/2002	Created
	/// </history>
	public class DebuggerToolTreeGrid : DebuggerTreeGrid
	{

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new TreeGrid for a variable window
		/// </summary>
		/// <param name="startWnd">Window to start searching from</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolTreeGrid(Window startWnd) : base(startWnd)
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that returns a DebuggerToolRow based on specified index
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow this[int index]
		{
			get
			{
				// set focus or send dte command here?
				return new DebuggerToolRow(this, index);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that returns a DebuggerToolRow based on specified name (i.e first column value)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow this[string name]
		{
			get
			{
				// set focus or send dte command here?
				return new DebuggerToolRow(this, name);
			}
		}


		protected override int NameColumnIndex
		{
			get
			{
				return 1;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to select the specified row
		/// </summary>
		/// <param name="index">index of row in the window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void SelectRow(int index)
		{
			//TODO: ugh, focus issues
			Keyboard.SendKeys("{HOME}");
			if( index > 0 )
				Keyboard.SendKeys("{DOWN " + index + "}");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Jit.cs ===
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.VisualStudio.Everett;


namespace Maui.VisualStudio.Everett.Debugger
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Jit
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This is conceptual class to handle JIT debugging scenario. 
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 11/4/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Jit : Maui.Core.RemotingObject
	{

		#region Exceptions
		public class Exceptions
		{
			[Serializable]
				public class VsJitDebuggerIsNotRunning : MauiException
			{	
				public VsJitDebuggerIsNotRunning(string message) : base(message) {}

				protected VsJitDebuggerIsNotRunning(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region privates and constants
		private Maui.VisualStudio.Everett.IDEApp app = null;
		const int WaitTime = 1000; // 10 seconds
		const int NumberOfTry = 5;
		const int ExpectedNumberOfVsJitDebugger = 2;
		const string VsJitDebuggerExe = "vsjitdebugger";
		const string NativeJitKeyString = "Software\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug";
		const string NativeJitAutoValueString = "Auto";
		const string ManagedJitKeyString ="Software\\Microsoft\\.NetFramework"; 
		const string ManagedJitAutoValueString = "DbgJitDebugLaunchSetting";
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Construct JIT object wihtout any parameter. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Jit() :this(CoreManager.ActiveApp)
		{
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Construct JIT object wiht WhidbeApp
		/// </summary>
		/// <param name="application">IDEApp</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Jit(IDEApp application)
		{
			app = application;
		}
		#endregion

		#region public Methods
		///-----------------------------------------------------------------------------
		/// <summary>
		/// it handle JIT dialog from VSJitDebugger.exe
		/// but it doesn't deal with "AttachToProcess" dialog because test can start new 
		/// instance of Jit debugger. 
		/// "AttachToProcess" dialog should be dealt by test code. 
		/// </summary>
		/// <param name="jitDebuggeePath">Path of the JIT debuggee</param>
		/// <param name="hasWindow">indicate whether the Jit debuggee has window or not</param>
		/// <param name="jitDebuggerName">indicate the JIt debugger name. 
		/// if you want to use new instance, you can use constant string from VsJitDebuggerWindow class to indicate the debugger type
		/// if you want to use first instance of any running debugger, you just need to pass "null". </param>
		/// <param name="isNewInstanceOfJitDebugger">indicate whether you want to use new instance or not.</param>
		/// <param name="manualDESelect">if you want to select DE(Debug Engine) when JIT debugging session is started by this method. set it as "True"</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/13/2003 Created
		///				  [mkpark] 2/24/2003 updated for new UI 
  		///          [JunyuZho]2/24/2003 Modified - change to use Maui.OS.Process.GetProcessesIDsByName
		/// </history>
		///-----------------------------------------------------------------------------
		public VsJitDebugger.JitDebuggeeApp StartJitDebugging(string jitDebuggeePath,bool hasWindow,string jitDebuggerName,bool isNewInstanceOfJitDebugger,bool manualDESelect)
		{
			VsJitDebugger.VsJitDebuggerApp vsJitDebuggerApp = null; 
			VsJitDebugger.VsJitDebuggerWindow jitWindow = null;
			VsJitDebugger.JitDebuggeeApp jitDebuggeeApp = null;
			System.Int32[] processIDArray = null;

			// Change JIt setting to by pass JIT dialog from app. 
			// ToDo : later if it is needed, we will deal with dialog directly.
			SetBypassJITDialog(true);

			jitDebuggeeApp = new VsJitDebugger.JitDebuggeeApp(jitDebuggeePath,hasWindow);

			for(int i = 0 ; i < NumberOfTry && processIDArray == null;i++)
			{
				// wait for JIT debuggee is started
				// need to make sure the debuggee is running. 
				System.Threading.Thread.Sleep(WaitTime);
				processIDArray = Process.GetProcessesIdsByName(VsJitDebuggerExe);
			}

			if(processIDArray.GetLength(0) != ExpectedNumberOfVsJitDebugger)
			{
				throw new Maui.VisualStudio.Everett.Debugger.Jit.Exceptions.VsJitDebuggerIsNotRunning("vsjitdebugger.exe is not running properly : " + processIDArray.GetLength(0));
			}
			else
			{
				bool isThereProperVsJitDebuggerExe = false;

				for(int j = 0 ; j < ExpectedNumberOfVsJitDebugger; j++)
				{
					try
					{
						vsJitDebuggerApp = new VsJitDebugger.VsJitDebuggerApp(processIDArray[j]);
						isThereProperVsJitDebuggerExe = true;
						break;
					}
					catch
					{
						isThereProperVsJitDebuggerExe = false;
						continue;
					}
				}

				if(isThereProperVsJitDebuggerExe == false)
				{
					new Exceptions.VsJitDebuggerIsNotRunning("all vsjitdebugger.exe don't have UI"); 
				}
			}
			jitWindow = new VsJitDebugger.VsJitDebuggerWindow(vsJitDebuggerApp);
			jitWindow.StartJITDebuggingWith(isNewInstanceOfJitDebugger,jitDebuggerName,manualDESelect);
			// may need to detect whether the vsjitdebugger.exe is terminated or not. 
			// the code maybe like
			// System.Threading.Thread.Sleep(WaitTime);
			// if(jitApp.IsRunning)
			// {
			// 	jitApp.Kill();
			//	throw new Exception("vsjitdebugger.exe is not terminated, yet");
			// }


			return jitDebuggeeApp;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Clean up Jit debuggee app. and make sure that all setting is rolled back. 
		/// </summary>
		/// <param name="jitDebuggeeApp">Pass the Jit debuggee app which is returned from StartJitDebugging()</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/13/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void  StopJitDebugging(VsJitDebugger.JitDebuggeeApp jitDebuggeeApp)
		{
			SetBypassJITDialog(false);
			if(jitDebuggeeApp.IsRunning == true)
			{
				jitDebuggeeApp.Kill();
			}
		}
		#endregion

		#region Private methods
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Change JIT debugging setting of both of Native and Managed.
		/// </summary>
		/// <param name="isByPassJITDialog">true : by-Pass confirmation dialog
		///									false : confirmation dialog is up</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/13/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void SetBypassJITDialog(bool isByPassJITDialog)
		{
			ChangeNativeJitSetting(isByPassJITDialog);
			ChangeManagedJitSetting(isByPassJITDialog);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Change Native JIT debugging setting of both of Native and Managed.
		/// </summary>
		/// <param name="isByPassJITDialog">true : by-Pass confirmation dialog
		///									false : confirmation dialog is up</param>
		/// <remarks></remarks>
		/// <history>
		///	[mkpark] 2/13/2003 Created
		///	[dmitriv]	2/27/2003	Updated to use new Registry class
		/// </history>
		///-----------------------------------------------------------------------------
		private void ChangeNativeJitSetting(bool isByPassJITDialog)
		{
			Registry.SetValue(RegistryHive.Win32LocalMachine, NativeJitKeyString, NativeJitAutoValueString, ( isByPassJITDialog == true ? "1" : "0"));
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Change Managed JIT debugging setting of both of Native and Managed.
		/// </summary>
		/// <param name="isByPassJITDialog">true : by-Pass confirmation dialog
		///									false : confirmation dialog is up</param>
		/// <remarks></remarks>
		/// <history>
		///	[mkpark] 2/13/2003 Created
		///	[dmitriv]	2/27/2003	Updated to use new Registry class
		/// </history>
		///-----------------------------------------------------------------------------
		private void ChangeManagedJitSetting(bool isByPassJitDialog)
		{
			Registry.SetValue(RegistryHive.Win32LocalMachine, ManagedJitKeyString, ManagedJitAutoValueString,( isByPassJitDialog == true ? 2 : 0));
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Controls\DebuggerTreeGrid.cs ===
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.Core;
using Maui.Core.Utilities;

namespace Maui.VisualStudio.Everett.Debugger.Controls
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggerTreeGrid
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Base control for the TreeGrid used in the debugger windows
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	///     [dmitriv]	22/11/2002	Changed Enums.XXX.YYY to XXX.YYY, added using Enums.
	/// </history>
	///-----------------------------------------------------------------------------
	public abstract class DebuggerTreeGrid : Maui.Core.WinControls.Control
	{

		#region Exceptions
		public new class Exceptions : Maui.Core.WinControls.Control.Exceptions
		{
			[Serializable]
				public class NameNotFoundException : MauiException
			{
				public NameNotFoundException(string message) : base(message) {}

				protected NameNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class IndexException : MauiException
			{
				public IndexException(string message) : base(message) {}

				protected IndexException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class RowExpandException : MauiException
			{
				public RowExpandException(string message) : base(message) {}

				protected RowExpandException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

#region Constants

		private const string TreeGridAAName = "Treegrid Accessibility";

		private ActiveAccessibility m_accObj = null;
		private string[] m_columns = null;

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new base DebuggerTreeGrid
		/// </summary>
		/// <param name="startWnd">Parent window to start looking from</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerTreeGrid(Window startWnd) : base(startWnd, "",StringMatchSyntax.ExactMatch, Everett.Constants.EverettWindowClassNames.DebugTreeGrid,StringMatchSyntax.ExactMatch)
		{ }

#endregion

		protected abstract int NameColumnIndex
		{ get; }

		///-----------------------------------------------------------------------------
		/// <summary>
		/// AA object of the TreeGrid
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected override ActiveAccessibility AccessibleObject
		{
			get
			{
				if( m_accObj == null)
				{
					ActiveAccessibility aa = this.Parent.Extended.AccessibleObject;
					m_accObj = aa.FindChild(TreeGridAAName);
				}
				
				return m_accObj;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Array of the columns in the TreeGrid
		/// </summary>
		/// <returns>1D array containing column names</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public String[] GetColumns()
		{
			if( m_columns == null )
			{
				ActiveAccessibility aa  = this.AccessibleObject;
				string columns = "";

				foreach( ActiveAccessibility childMSAA in aa.Children )
					if( childMSAA.Role ==  (int)MsaaRole.ColumnHeader )
						columns += childMSAA.Name + ",";
					else
						break;

				m_columns = columns.TrimEnd(',').Split(',');
			}
			return m_columns;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Expand state of the specified row
		/// </summary>
		/// <param name="row">index of the row in window (0-based)</param>
		/// <returns>enum describing current expand state - expanded, collapsed, or not-expandable</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal RowExpandState GetExpandState(int row)
		{
			try
			{
				ActiveAccessibility aa = this.AccessibleObject;
				int cellIndex  = this.ColumnCount + (this.ColumnCount * row);
				ActiveAccessibility aaChild  = aa.Children[cellIndex];
				return GetExpandState(aaChild);
			}
			catch
			{
				throw new Exceptions.IndexException("Row index greater than number of rows.");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Expand state of the specified row
		/// </summary>
		/// <param name="accObj">AA object of Name cell, which contains the expand info</param>
		/// <returns>enum describing current expand state - expanded, collapsed, or not-expandable</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected RowExpandState GetExpandState(ActiveAccessibility accObj)
		{
			if( ((MsaaStates)accObj.State & MsaaStates.Collapsed) == MsaaStates.Collapsed )
				return RowExpandState.Collapsed;
			else if( ((MsaaStates)accObj.State & MsaaStates.Expanded) == MsaaStates.Expanded )
				return RowExpandState.Expanded;
			else
				return RowExpandState.NotExpandable;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Expand text ("+", "-", "") of the specified row
		/// </summary>
		/// <param name="accObj">AA object of Name cell, which contains the expand info</param>
		/// <returns>string representing the current expand state </returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal string GetExpandText(ActiveAccessibility accObj)
		{
			if( ((MsaaStates)accObj.State & MsaaStates.Collapsed) == MsaaStates.Collapsed )
				return "+";
			else if( ((MsaaStates)accObj.State & MsaaStates.Expanded) == MsaaStates.Expanded )
				return "-";
			else
				return "";
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Expands the specified row
		/// </summary>
		/// <param name="row">index of the row in window (0-based)</param>
		/// <remarks>Only really useful with Variable windows</remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void Expand(int row)
		{
			if( row > this.RowCount - 1 || row < 0 )
				throw new Exceptions.IndexException("Row index greater than number of rows.");
			else
			{
				ActiveAccessibility aa  = this.AccessibleObject;
				int cellIndex = this.ColumnCount + (this.ColumnCount * row);
				ActiveAccessibility aaChild = aa.Children[cellIndex];

				switch( this.GetExpandState(aaChild) )
				{
					case RowExpandState.Collapsed:
						aaChild.DoDefaultAction();

						if( this.GetExpandState(aaChild) != RowExpandState.Expanded )
							throw new Exceptions.RowExpandException("Row did not expand.");
						
						break;

					case RowExpandState.Expanded:
						throw new Exceptions.RowExpandException("Row already expanded.");
					case RowExpandState.NotExpandable:
						throw new Exceptions.RowExpandException("Row is not expandable.");
				}
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Collapses the specified row
		/// </summary>
		/// <param name="row">index of the row in window (0-based)</param>
		/// <remarks>Only really useful with Variable windows</remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void Collapse(int row)
		{
			if( row > this.RowCount - 1 || row < 0)
				throw new Exceptions.IndexException("Row index greater than number of rows.");
			else
			{
				ActiveAccessibility aa  = this.AccessibleObject;
				int cellIndex = this.ColumnCount + (this.ColumnCount * row);
				ActiveAccessibility aaChild = aa.Children[cellIndex];

				switch( this.GetExpandState(aaChild) )
				{
					case RowExpandState.Collapsed:
						throw new Exceptions.RowExpandException("Row already collapsed.");
					case RowExpandState.Expanded:
						aaChild.DoDefaultAction();

						if( this.GetExpandState(aaChild) != RowExpandState.Collapsed )
							throw new Exceptions.RowExpandException("Row did not collapse.");
						
						break;
						
					case RowExpandState.NotExpandable:
						throw new Exceptions.RowExpandException("Row is not collapsable.");
				}
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets focus to current cell
		/// </summary>
		/// <param name="row">row to select (0-based)</param>
		/// <param name="col">column to select (0-based)</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void SelectCell(int row, int col)
		{
			ActiveAccessibility aa = this.AccessibleObject;
			aa.Select((int)(MsaaSelectFlags.TakeFocus | MsaaSelectFlags.TakeSelection), this.ColumnCount + this.ColumnCount * row + col + 1);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the number of rows in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int RowCount
		{
			get
			{
				ActiveAccessibility aa = this.AccessibleObject;
				return (aa.ChildCount - this.ColumnCount) / this.ColumnCount;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the number of Columns in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ColumnCount
		{
			get
			{
				if( m_columns == null )
					m_columns = this.GetColumns();

				return m_columns.Length;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the contents of the cell at the specified row and col
		/// </summary>
		/// <param name="row">Row in grid to go to</param>
		/// <param name="col">Column in grid to go to</param>
		/// <returns>Contents of the cell</returns>
		/// <remarks>The first column is the expand column - it contains "+", "-", or ""</remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal string GetCell(int row, int col)
		{
			ActiveAccessibility aa = this.AccessibleObject;
			int cellIndex = (row+1) * this.ColumnCount + (col-1);
			return aa[cellIndex].Name;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns an array containing the Row info
		/// </summary>
		/// <param name="index">index of the row in the window</param>
		/// <returns>1D string array of row info</returns>
		/// <remarks>The first column is the expand column - it contains "+", "-", or ""</remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal string[] GetRow(int index)
		{
			ActiveAccessibility aa = this.AccessibleObject;
			int cols = this.ColumnCount;
			int cellIndex = cols + (cols * index);

			string[] rg = new string[cols+1];

			rg[0] = GetExpandText(aa.Children[cellIndex]);

			for( int i=0;i<cols; i++ )
				rg[i+1] = aa.Children[cellIndex + i].Name;

			return rg;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns all row info
		/// </summary>
		/// <returns>2D string array of all row info</returns>
		/// <remarks>The first column is the expand column - it contains "+", "-", or ""</remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal string[,] GetRows()
		{
			ActiveAccessibility aa = this.AccessibleObject;

			if( aa.ChildCount == this.ColumnCount )
			{
				// return nothing if only row is the column headers
				return null;
			}
			else
			{
				// calc size of Row array
				int colCount = this.ColumnCount;
				string[,] rgRows = new string[(aa.ChildCount - colCount) / colCount, colCount+1];

				int rowIdx = 0, colIdx = 0;

				// loop through children and build rows array
				foreach( ActiveAccessibility childMSAA in aa.Children )
				{
					if( ((MsaaRole)childMSAA.Role & MsaaRole.Cell) == MsaaRole.Cell )
					{
						if( colIdx == 0 )
						{
							rgRows[rowIdx, 0] = GetExpandText(childMSAA);
							colIdx++;
						}

						rgRows[rowIdx, colIdx] = childMSAA.Name;
						colIdx++;

						if( colIdx == (colCount + 1) )
						{
							colIdx = 0;
							rowIdx++;
						}
					}
				}

				return rgRows;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to find row's index if name specified
		/// </summary>
		/// <param name="name">Text in Name column to find</param>
		/// <param name="instance">Instance of text to find</param>
		/// <returns></returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal int FindRowByName(string name, int instance)
		{
			// TODO: This needs a MatchWholeString option
			int findCount = 0;
			string[,] rg = this.GetRows();

			for( int i=0; i<this.RowCount; i++)
				if( rg[i, this.NameColumnIndex] == name )
				{
					if( ++findCount == instance )
						return i;
				}

			throw new Exceptions.NameNotFoundException("Variable not found.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to supplement StrMatch 
		/// </summary>
		/// <param name="expected">Text to look for</param>
		/// <param name="actual">Text to search</param>
		/// <param name="caseSensitive">perfrom case sensitive match</param>
		/// <param name="matchWholeString">match entire string</param>
		/// <returns>true if strings match</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal bool CompareText(string expected, string actual, bool caseSensitive, bool matchWholeString)
		{
			if( matchWholeString )
				return StringHelper.Match(expected, actual, caseSensitive, true, null);
			else
				return StringHelper.Match("*" + expected + "*", actual, caseSensitive, true, null);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\SQLDebug.cs ===
//*********************************************************
// Owner : JohnBain
// Class name : SQLDebug
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger
{
	/// <summary>
	/// Summary description for SQLDebug.
	/// </summary>
	public class SQLDebug
	{
		public SQLDebug(IDEApp application)
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Controls\DebuggerToolRow.cs ===
using System;
using System.ComponentModel;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;

///-----------------------------------------------------------------------------
/// Project		: Maui.VisualStudio.Everett.Debugger
/// Class		: DebuggerToolRow
///
/// Copyright (C) 2002, Microsoft Corporation
///-----------------------------------------------------------------------------
namespace Maui.VisualStudio.Everett.Debugger.Controls
{
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Verification methods.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[mkoller]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDebuggerToolRowVerify
	{
		bool Verify(string name);
		bool Verify(string name, bool matchWholeString, bool caseSensitive);
		bool Verify(string[] expectedValues, bool matchWholeString, bool caseSensitive);
	}


	///-----------------------------------------------------------------------------
	/// <summary>
	/// Exposes methods for rows in the various Debugger Tool windows - CllStack, Threads, Modules.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[mkoller]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class DebuggerToolRow : IDebuggerToolRowVerify
	{

#region Constants, Member vars

		private DebuggerToolTreeGrid m_parent;
		private int m_index = -1;
		private const int NameIndex = 1;


#endregion

#region Constructors
						
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new tool row
		/// </summary>
		/// <param name="parent">DebuggerToolWindow that the row belongs to</param>
		/// <param name="index">Index of Row in the VariableWindow (0-based)</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow(DebuggerToolTreeGrid parent, int index)
		{
			m_parent = parent;
			m_index = index;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new variable row
		/// </summary>
		/// <param name="parent">DebuggerToolWindow that the row belongs to</param>
		/// <param name="name">Name of entry to look for (value of the first column in the window)</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow(DebuggerToolTreeGrid parent, string name)
		{
			m_parent = parent;
			m_index = m_parent.FindRowByName(name, 1);
		}



#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verification method container
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDebuggerToolRowVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the Variable window that the row belongs too
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolTreeGrid Parent
		{
			get
			{
				return m_parent;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the contents of a given row
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string[] Value
		{
			get
			{
				string[] val = this.Parent.GetRow(m_index);
				string[] rowVal=new string[val.Length-1];
				for(int i=0; i < rowVal.Length; i++)
					rowVal[i]=val[i+1];
				return rowVal;
			}

		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Selects the specified row in the grid
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Select()
		{
			this.Parent.SelectRow(m_index);
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies exact value of first column in current row (case seinsitive)
		/// </summary>
		/// <param name="name">Expected value of Name (i.e the first column)</param>
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolRowVerify.Verify(string name)
		{
			string[] arrName = new string[1];
			arrName[0] = name;
			return this.Verify.Verify(arrName, true, true);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="name">Expected value of Name (i.e the first column)</param>
		/// <param name="matchWholeString">match the entire string</param>	
		/// <param name="caseSensitive">perform a case-sensitive compare</param>	 
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolRowVerify.Verify(string name, bool matchWholeString, bool caseSensitive)
		{
			string[] arrName = new string[1];
			arrName[0] = name;
			return this.Verify.Verify(arrName, matchWholeString, caseSensitive);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="expectedValues">Expected values of the first specified columns in the row</param>
		/// <param name="caseSensitive">perform a case-sensitive compare</param>
		/// <param name="matchWholeString">match the entire string</param>		 
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolRowVerify.Verify(string[] expectedValues, bool matchWholeString, bool caseSensitive)
		{
			string[] rg = this.Parent.GetRow(m_index);
			string[] columns = this.Parent.GetColumns();
			int columnCount = expectedValues.Length;
			bool verified = true;
			if(columnCount > rg.Length)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Number of specified values: " + columnCount + " is greater than the number of columns in the window: " + rg.Length);
				return false;		
			}

			for(int i=0; i < columnCount; i++)
			{
				if( !m_parent.CompareText(expectedValues[i], rg[i+1], caseSensitive, matchWholeString) )
				{
					LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Value of column " + columns[i] + ":" + rg[i+1] + " does not match expected value: " + expectedValues[i]);
					verified = false;
				}

			}
			return verified;			
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Controls\VariableRow.cs ===
using System;
using System.ComponentModel;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;

///-----------------------------------------------------------------------------
/// Project		: Maui.VisualStudio.Everett.Debugger
/// Class		: VariableRow
///
/// Copyright (C) 2002, Microsoft Corporation
///-----------------------------------------------------------------------------
namespace Maui.VisualStudio.Everett.Debugger.Controls
{
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Verification methods.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IVariableRowVerify
	{
		bool Verify(string name, string varValue, string type);
		bool Verify(RowExpandState expandState, string name, string varValue, string type);
		bool Verify(string name, string varValue, string type, bool caseSensitive, bool matchWholeString);
		bool Verify(RowExpandState expandState, string name, string varValue, string type, bool caseSensitive, bool matchWholeString);
		bool ModifyValue(string newExpression);
		bool ModifyValue(string newExpression, string expectedValue);
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Exposes methods for rows in the various Variable windows - Autos, Locals, Watch1-4.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class VariableRow : IVariableRowVerify
	{

#region Constants, Member vars

		private VariableTreeGrid m_parent;
		private int m_index = -1;

		private const int NameIndex = 1;
		private const int ValueIndex = 2;
		private const int TypeIndex = 3;

#endregion

#region Constructors
						
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new variable row
		/// </summary>
		/// <param name="parent">VariableWindow that the row belongs to</param>
		/// <param name="index">Index of Row in the VariableWindow (0-based)</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow(VariableTreeGrid parent, int index)
		{
			m_parent = parent;
			m_index = index;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new variable row
		/// </summary>
		/// <param name="parent">VariableWindow that the row belonds to</param>
		/// <param name="name">Name of Variable to look for</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow(VariableTreeGrid parent, string name)
		{
			m_parent = parent;
			m_index = m_parent.FindRowByName(name, 1);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new variable row
		/// </summary>
		/// <param name="parent">VariableWindow that the row belonds to</param>
		/// <param name="name">Name of Variable to look for</param>
		/// <param name="instance">Instance of variable name to look for (1-based)</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow(VariableTreeGrid parent, string name, int instance)
		{
			m_parent = parent;
			m_index = m_parent.FindRowByName(name, instance);
		}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verification method container
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IVariableRowVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the Variable window that the row belongs too
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableTreeGrid Parent
		{
			get
			{
				return m_parent;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the current expand state
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RowExpandState ExpandState
		{
			get
			{
				return this.Parent.GetExpandState(m_index);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Sets (watch only) or Gets the contents of Name column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Name
		{
			get
			{
				return this.Parent.GetCell(m_index, NameIndex);
			}

			set
			{
				this.Parent.SendKeys("{HOME}");
				if( m_index > 0 )
					this.Parent.SendKeys("{DOWN " + m_index + "}");
				m_parent.WaitForResponse();

				// Put cell in edit mode
				this.Parent.SendKeys("+{ENTER}");
				this.Parent.WaitForResponse();

				// send the new value
				value = Keyboard.EscapeSpecialCharacters(value);
				this.Parent.SendKeys(value + "{ENTER}");
				this.Parent.WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Set or Gets the contents of Value column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		///				 [mkpark]   Because SendKeys() sets focus, it couldn't enter value correctly. so "^{Enter}" and value is typed together. 
		/// </history>
		///-----------------------------------------------------------------------------
		public string Value
		{
			get
			{
				return this.Parent.GetCell(m_index, ValueIndex);
			}

			set
			{
				this.Parent.SendKeys("{HOME}");
				if( m_index > 0 )
					this.Parent.SendKeys("{DOWN " + m_index + "}");

				m_parent.WaitForResponse();

				// Put cell in edit mode
				value = Keyboard.EscapeSpecialCharacters(value);
				this.Parent.SendKeys("^{ENTER}" + value +"{ENTER}");
				this.Parent.WaitForResponse();
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the contents of Type column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Type
		{
			get
			{
				return this.Parent.GetCell(m_index, TypeIndex);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Collapses Row if possible
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Expand()
		{
			this.Parent.Expand(m_index);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Expands Row if possible
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Collapse()
		{
			this.Parent.Collapse(m_index);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes the current row (Watch only)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Delete()
		{
			this.Parent.Delete(m_index);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Selects the specified row in the grid
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Select()
		{
			this.Parent.SelectRow(m_index);
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Modifies and verifies the value of a variable row
		/// </summary>
		/// <param name="newExpression">Expression to change the variable value to</param>
		/// <returns>true if verification succeeds</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.ModifyValue(string newExpression)
		{
			return this.Verify.ModifyValue(newExpression, newExpression);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Modifies and verifies the value of a variable row
		/// </summary>
		/// <param name="newExpression">Expression to change the variable value to</param>
		/// <param name="expectedValue">Expected value of the variable after modification</param>
		/// <returns>true if verification succeeds</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.ModifyValue(string newExpression, string expectedValue)
		{
			this.Value = newExpression;
			return this.Verify.Verify(RowExpandState.DontCare, this.Name, expectedValue, this.Value);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="name">Expected value of Name column</param>
		/// <param name="value">Expected value of Value column</param>
		/// <param name="type">Expected value of Type column</param>
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.Verify(string name, string varValue, string type)
		{
			return this.Verify.Verify(RowExpandState.DontCare, name, varValue, type, true, true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="expandState">Expected expand state</param>
		/// <param name="name">Expected value of Name column</param>
		/// <param name="value">Expected value of Value column</param>
		/// <param name="type">Expected value of Type column</</param>
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.Verify(RowExpandState expandState, string name, string varValue, string type)
		{
			return this.Verify.Verify(expandState, name, varValue, type, true, true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="name">Expected value of Name column</param>
		/// <param name="value">Expected value of Value column</param>
		/// <param name="type">Expected value of Type column</</param>
		/// <param name="caseSensitive">perform a case-sensitive compare</param>
		/// <param name="matchWholeString">match the entire string</param>
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.Verify(string name, string varValue, string type, bool caseSensitive, bool matchWholeString)
		{
			return this.Verify.Verify(RowExpandState.DontCare, name, varValue, type, caseSensitive, matchWholeString);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies values in current row
		/// </summary>
		/// <param name="expandState">Expected expand state</param>
		/// <param name="name">Expected value of Name column</param>
		/// <param name="value">Expected value of Value column</param>
		/// <param name="type">Expected value of Type column</</param>
		/// <param name="caseSensitive">perform a case-sensitive compare</param>
		/// <param name="matchWholeString">match the entire string</param>
		/// <returns>true if all verifications passed, otherwise false</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		///			 [mkpark] 1/21/2003 fixed for logical issue with return value test case. 
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableRowVerify.Verify(RowExpandState expandState, string name, string varValue, string type, bool caseSensitive, bool matchWholeString)
		{
			string[] rg = this.Parent.GetRow(m_index);

			bool verified = true;

			if( expandState != RowExpandState.DontCare)
			{
				RowExpandState ActualExpandState = GetExpandStateFromText(rg[0]);

				if(ExpandState != ActualExpandState )
				{
					LogManager.LogFailure("Variable ExpandState does not match expected.", ExpandState.ToString(), ActualExpandState.ToString(), "");
					verified = false;
				}
			}

			if( !m_parent.CompareText(name, rg[NameIndex], caseSensitive, matchWholeString) )
			{
				LogManager.LogFailure("Variable Name does not match expected.", Name, rg[NameIndex], "");
				verified = false;
			}

			if( !m_parent.CompareText(varValue, rg[ValueIndex], caseSensitive, matchWholeString) )
			{
				LogManager.LogFailure("Variable Value does not match expected.", Name, rg[ValueIndex], "");
				verified = false;
			}

			if( !m_parent.CompareText(type, rg[TypeIndex], caseSensitive, matchWholeString) )
			{
				LogManager.LogFailure("Variable Type does not match expected.", Name, rg[TypeIndex], "");
				verified = false;
			}

			return verified;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to convert "+", "-", "" into correct RowState enum
		/// </summary>
		/// <param name="text">Text to convert</param>
		/// <returns>RowExpandState value text matches</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal RowExpandState GetExpandStateFromText(string text)
		{
			switch( text )
			{
				case "+":
					return RowExpandState.Collapsed;
				case "-":
					return RowExpandState.Expanded;
				case "":
					return RowExpandState.NotExpandable;
				default:
					throw new Exception("Invalid text.");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Controls\VariableTreeGrid.cs ===
using System;
using Maui.Core;

namespace Maui.VisualStudio.Everett.Debugger.Controls
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggerTreeGrid
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// TreeGrid implementation specific to a Variable window - Autos, Locals, Watch
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	public class VariableTreeGrid : DebuggerTreeGrid
	{

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new TreeGrid for a variable window
		/// </summary>
		/// <param name="startWnd">Window to start searching from</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableTreeGrid(Window startWnd) : base(startWnd)
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that returns a VariableRow based on specified index
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[int index]
		{
			get
			{
				// set focus or send dte command here?
				return new VariableRow(this, index);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that returns a VariableRow based on specified variable name
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[string name]
		{
			get
			{
				// set focus or send dte command here?
				return new VariableRow(this, name);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that returns a VariableRow based on specified variable name
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[string name, int instance]
		{
			get
			{
				// set focus or send dte command here?
				return new VariableRow(this, name, instance);
			}
		}

		protected override int NameColumnIndex
		{
			get
			{
				return 1;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets number of rows in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int VariableCount 
		{
			get
			{
				return base.RowCount;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes the specified row (watch only)
		/// </summary>
		/// <param name="row">index of the row in the window</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void Delete(int row)
		{
			// TODO: probably focus problems here
			this.SelectRow(row);
			Keyboard.SendKeys("{DELETE}");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to select the specified row
		/// </summary>
		/// <param name="index">index of row in the window</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		internal void SelectRow(int index)
		{
			//TODO: ugh, focus issues
			Keyboard.SendKeys("{HOME}");
			if( index > 0 )
				Keyboard.SendKeys("{DOWN " + index + "}");

			//Me.VariableWindowTreeGrid.SelectCell(Index, 0)
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\DebuggingEngineSelectDialog.cs ===
//*********************************************************
// Owner : Yiqingdu
// Class name : DebuggingEngineSelectDialog
// Description: 
//*********************************************************
using System;
using System.Collections;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	#region interfaces for DebuggingEngineSelectDialog
	public interface DebuggingEngineSelectDialogControls
	{
		Maui.Core.WinControls.ListView DETypeListView
		{
			get;
		}

		Maui.Core.WinControls.Button OKButton
		{
			get;
		}

		Maui.Core.WinControls.Button CancelButton
		{
			get;
		}

		Maui.Core.WinControls.Button HelpButton
		{
			get;
		}
	}
	#endregion

	#region enum types
	/// <summary>
	/// Debug Engine types. 
	/// </summary>
	[Flags()]
	public enum DeType
	{
		Auto = 0x0,
		Clr = 0x1,
		Tsql = 0x2,
		Native = 0x4,
		Script = 0x8,
		Yukon_Tsql = 0x10
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggingEngineSelectDialog
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you choose the debug engines you want to use to attach
	/// to the process(es) you choose on the Processes dialog box. 
	/// </summary>
	/// <history>
	///		[yiqingdu] 10/31/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class DebuggingEngineSelectDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, DebuggingEngineSelectDialogControls
	{
		#region Exceptions
		public new class Exceptions : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog.Exceptions
		{
			[Serializable]
				public class OKButtonNotEnabled : MauiException
			{
				public OKButtonNotEnabled(string message) : base(message) {}

				protected OKButtonNotEnabled(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region member variables
		//string
		private const string DialogTitle = ";Debugging Engine Selection;Win32DialogString;VSDebugUI.dll;5013";

		//controls
		private const int DETypeListViewID = 0x3ed;
		private const int OKButtonID = 0x1;
		private const int CancelButtonID = 0x2;
		private const int HelpButtonID = 0x9;

		//hashtable to relate DE type and its name in the DETypeListViewID 
		private Hashtable  m_deTypeTable = new Hashtable();
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return DebuggingEngineSelectDialogControls object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggingEngineSelectDialogControls Controls
		{
			get
			{
				return this;
			}
		}
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in the specified app.  indicate whehter the dlg is already open or not. 
		/// </summary>
		/// <param name="application">Running instance of VS</param>
		/// <param name="isAlreadyOpen">Indicate whether the dialog is already up or not</param>
		/// <history>
		///		[yiqingdu] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggingEngineSelectDialog(IDEApp application, bool isAlreadyOpen) : base(application,application.GetIntlStr(DialogTitle),isAlreadyOpen)
		{
			DataInit();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Initiate hashtable m_deTypeTable
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/13/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void DataInit()
		{
			m_deTypeTable.Clear();
			// All the debugger engine types are from registry, and
			// they are not localized. So we can hard-code them
			m_deTypeTable.Add(DeType.Clr, "Common Language Runtime");
			m_deTypeTable.Add(DeType.Native, "Native");
			m_deTypeTable.Add(DeType.Script, "Script");
			m_deTypeTable.Add(DeType.Tsql, "Microsoft T-SQL");
			m_deTypeTable.Add(DeType.Yukon_Tsql, "Yukon Microsoft T-SQL");
		}
		#endregion

		#region DebuggingEngineSelectDialogControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return DETypeListView object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ListView DebuggingEngineSelectDialogControls.DETypeListView
		{
			get
			{
				return new Maui.Core.WinControls.ListView(this, DETypeListViewID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return OKButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button DebuggingEngineSelectDialogControls.OKButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, OKButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return CancelButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button DebuggingEngineSelectDialogControls.CancelButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, CancelButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return HelpButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button DebuggingEngineSelectDialogControls.HelpButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, HelpButtonID);
			}
		}
		#endregion

		#region member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Select debugging engine type(s)
		/// </summary>
		/// <param name="deType"> DE (Debugger Engine) type. Can also use | to combine flags.</param>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SelectDE(DeType deType)
		{
			try
			{
				//clear what's selected before
				ClearAllDEs();

				//select the specified type
				if((deType & DeType.Clr) == DeType.Clr)
				{
					this.Controls.DETypeListView[(string)m_deTypeTable[DeType.Clr]].Select();
					this.SendKeys(" ");
				}
				if((deType & DeType.Tsql) == DeType.Tsql)
				{
					this.Controls.DETypeListView[(string)m_deTypeTable[DeType.Tsql]].Select();
					this.SendKeys(" ");
				}
				if((deType & DeType.Native) == DeType.Native)
				{
					this.Controls.DETypeListView[(string)m_deTypeTable[DeType.Native]].Select();
					this.SendKeys(" ");
				}
				if((deType & DeType.Script) == DeType.Script)
				{
					this.Controls.DETypeListView[(string)m_deTypeTable[DeType.Script]].Select();
					this.SendKeys(" ");
				}
				if((deType & DeType.Yukon_Tsql) == DeType.Yukon_Tsql)
				{
					
					this.Controls.DETypeListView[(string)m_deTypeTable[DeType.Yukon_Tsql]].Select();
					this.SendKeys(" ");
				}
				
				if(this.Controls.OKButton.Extended.IsEnabled)
					this.Controls.OKButton.Click();
				else
					throw new Exceptions.OKButtonNotEnabled("OK button is not enabled.");
			}
			catch (System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling AttachToProcess(DeType deType)"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Clear all pre-selected DEs
		/// </summary>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void ClearAllDEs()
		{
			try
			{
				//clear what's selected before
				for (int i = 0; i< m_deTypeTable.Count; i++)
				{
					if(this.Controls.DETypeListView[i].Checked)
					{
						this.Controls.DETypeListView[i].Select();
						this.SendKeys(" ");
					}
					this.Controls.DETypeListView.WaitForResponse();
				}
			}
			catch (System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling ClearAllDEs()"); 
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\ExceptionHandle.cs ===
//*********************************************************
// Owner : bboris
// Class name : ExceptionHandle
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

		
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IExceptionHandleControls
	{
    
		TextBox ExceptionTextBox
		{
			get;
		}
    
		Button BreakButton
		{
			get;
		}
    
		Button ContinueButton
		{
			get;
		}
    
		Button IgnoreButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}




	/// <summary>
	/// This class is used to handle the exception dialog thrown up by Visual Stuido in the event 
	/// that the users program throws and unhandled exception
	/// </summary>
	public class ExceptionHandle: Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog,IExceptionHandleControls
	{
		#region "Control IDs"
		public class ControlIDs
		{
        
			public const int ExceptionTextBox = 4941;
        
			public const int BreakButton = 2;
        
			public const int ContinueButton = 4802;
        
			public const int IgnoreButton = 4803;
        
			public const int HelpButton = 1098;
		}

		
		#endregion

		#region member variables
		private const string m_DialogTitle = "msenvmui.dll:6:188:8"; 
		
		protected TextBox m_CachedExceptionTextBox;
    
		protected Button m_CachedBreakButton;
    
		protected Button m_CachedContinueButton;
    
		protected Button m_CachedIgnoreButton;
    
		protected Button m_CachedHelpButton;

		private int m_defaultTimeOut = 10000; // milliseconds. 

		#endregion 

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		#endregion 

		#region Constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for ExceptionHandle Class
		/// </summary>
		/// <param name="app">IDEApp to be passed on to base class</param>
		/// <remarks></remarks>
		/// <history>[bboris] 1/9/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionHandle(IDEApp app): base(app,app.GetIntlStr(m_DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default Constructor for ExceptionHandle Class
		/// </summary>
		/// <param name="app">IDEApp to be passed on to base class</param>
		/// <remarks></remarks>
		/// <history>[bboris] 1/9/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionHandle(): base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(m_DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}
		#endregion

		#region IExceptionHandle implementation
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IExceptionHandleControls Controls
		{
			get
			{
				return this;
			}
		}

		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control ExceptionTextBox
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string ExceptionTextBoxText
		{
			get
			{
				return Controls.ExceptionTextBox.Text;
			}
			set
			{
				Controls.ExceptionTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ExceptionTextBox control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox IExceptionHandleControls.ExceptionTextBox
		{
			get
			{
				if ((m_CachedExceptionTextBox == null))
				{
					m_CachedExceptionTextBox = new TextBox(this, ControlIDs.ExceptionTextBox);
				}
				return m_CachedExceptionTextBox;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the BreakButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionHandleControls.BreakButton
		{
			get
			{
				if ((m_CachedBreakButton == null))
				{
					m_CachedBreakButton = new Button(this, ControlIDs.BreakButton);
				}
				return m_CachedBreakButton;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ContinueButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionHandleControls.ContinueButton
		{
			get
			{
				if ((m_CachedContinueButton == null))
				{
					m_CachedContinueButton = new Button(this, ControlIDs.ContinueButton);
				}
				return m_CachedContinueButton;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IgnoreButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionHandleControls.IgnoreButton
		{
			get
			{
				if ((m_CachedIgnoreButton == null))
				{
					m_CachedIgnoreButton = new Button(this, ControlIDs.IgnoreButton);
				}
				return m_CachedIgnoreButton;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionHandleControls.HelpButton
		{
			get
			{
				if ((m_CachedHelpButton == null))
				{
					m_CachedHelpButton = new Button(this, ControlIDs.HelpButton);
				}
				return m_CachedHelpButton;
			}
		}
    

		#endregion 

		#region member functions
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Break
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickBreak()
		{
			Controls.BreakButton.Click();
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Continue
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickContinue()
		{
			Controls.ContinueButton.Click();
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Ignore
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickIgnore()
		{
			Controls.IgnoreButton.Click();
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
		}
    
		#endregion 

		
	}

	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\AttachToProcessDialog.cs ===
//*********************************************************
// Owner : Yiqingdu
// Class name : AttachToProcessDialog
// Description: 
//*********************************************************
using System;
using System.Runtime.Serialization;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;
using System.ComponentModel;
using System.Collections;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	#region Interfaces for AttachToProcessDialog 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAttachToProcessDialogControls
	{
		Maui.Core.WinControls.ComboBox TransportComboBox
		{
			get;
		}

		Maui.Core.WinControls.EditComboBox NameEditComboBox
		{
			get;
		}

		Maui.Core.WinControls.CheckBox AttachWithCheckBox
		{
			get;
		}

		Maui.Core.WinControls.TextBox AttachWithTextBox
		{
			get;
		}

		Maui.Core.WinControls.Button DebuggingEngineSelectButton
		{
			get;
		}

		Maui.Core.WinControls.ListView AvailableProcessesListView
		{
			get;
		}

		Maui.Core.WinControls.CheckBox ShowSystemProcessesCheckBox
		{
			get;
		}

		Maui.Core.WinControls.CheckBox ShowProcessesInAllSessionsCheckBox
		{
			get;
		}

		Maui.Core.WinControls.Button AttachButton
		{
			get;
		}

		Maui.Core.WinControls.Button CancelButton
		{
			get;
		}

		Maui.Core.WinControls.Button HelpButton
		{
			get;
		}

		Maui.Core.WinControls.Button RefreshButton
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAttachToProcessDialogVerify
	{
		bool Process(string processName);
		bool Process(string processName, string processID, string title, string type, string session);
	}
	#endregion

	#region enum types
	public enum PortType
	{
		Default,
		Pipe,
		TcpIp,
		DeviceRPC
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: AttachToProcessDialog
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you choose process(es) to attach, detach, break and
	/// terminate.  
	/// </summary>
	/// <history>
	///		[yiqingdu] 10/31/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class AttachToProcessDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IAttachToProcessDialogControls, IAttachToProcessDialogVerify
	{
		#region Exceptions
		public new class Exceptions : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog.Exceptions
		{
			[Serializable]
				public class AttachButtonNotEnabled : MauiException
			{	
				public AttachButtonNotEnabled(string message) : base(message) {}
		
				protected AttachButtonNotEnabled(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class ProcessNotFound : MauiException
			{	
				public ProcessNotFound(string message) : base(message) {}

				protected ProcessNotFound(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region member variables
		//strings
		private const string DialogTitle = ";Attach to Process;Win32DialogString;VSDebugUI.dll;4110";
		private const string TransportTypeDefault = ";Default;Win32String;msdbgui.dll;5014";
		private const string TransportTypePipe = "NatDbgDE.dll:6:251:0";
		private const string TransportTypeTcp = "NatDbgDE.dll:6:251:1";
		private const string TransportTypeDeviceRPC = ";VSD - Embedded Port Supplier;Win32String;eps.dll;5017";

		//controls
		private const int TransportComboBoxID = 0x461;
		private const int NameEditComboBoxID = 0x3e9;
		private const int NameEditButtonID = 0x1005;
		private const int AttachWithCheckBoxID = 0x49d;
		private const int AttachWithTextBoxID = 0x3ed;
		private const int DebuggingEngineSelectButtonID = 0x1007;
		private const int AvailableProcessesListViewID = 0x1006;
		private const int ShowSystemProcessesCheckBoxID = 0x13ad;
		private const int ShowProcessesInAllSessionsCheckBoxID = 0x455;
		private const int AttachButtonID = 0x42f;
		private const int CancelButtonID = 0x2;
		private const int HelpButtonID = 0x9;
		private const int RefreshButtonID = 0x100b;

		//other private variables
		private int m_defaultTimeOut = 10000; // milliseconds. 

		//constants to denote Available Processes list items
		private struct ProcessListItem
		{
			public const int Name = 0;
			public const int ID = 1;
			public const int Title = 2;
			public const int Type = 3;
			public const int Sessions = 4;
		}

		//hashtable to relate transport type and its name in the TransportComboBox 
		private Hashtable  m_transportTypeTable = new Hashtable();
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in Active app.
		/// </summary>
		/// <history>
		///		[yiqingdu] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachToProcessDialog() : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(DialogTitle),Constants.Commands.ToolsDebugProcesses,false)
		{
			DataInit();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in the specified app.  Opens it if not found
		/// </summary>
		/// <param name="application">Running instance of VS</param>
		/// <history>
		///		[yiqingdu] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachToProcessDialog(IDEApp application) : base(application,application.GetIntlStr(DialogTitle),Constants.Commands.ToolsDebugProcesses,false)
		{	
			DataInit();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in the specified app.  indicate whehter the dlg is already open or not. 
		/// </summary>
		/// <param name="application">Running instance of VS</param>
		/// <param name="isAlreadyOpen">Indicate whether the dialog is already up or not</param>
		/// <history>
		///		[yiqingdu] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachToProcessDialog(IDEApp application, bool isAlreadyOpen) : base(application,application.GetIntlStr(DialogTitle),Constants.Commands.ToolsDebugProcesses,isAlreadyOpen)
		{
			DataInit();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Initiate hashtable m_transportTypeTable
		/// </summary>
		/// <history>
		///		[yiqingdu] 	10/31/2002	Created
		///	</history>
		///-----------------------------------------------------------------------------
		private void DataInit()
		{
			m_transportTypeTable.Clear();
			m_transportTypeTable.Add(PortType.Default, this.App.GetIntlStr(TransportTypeDefault));
			m_transportTypeTable.Add(PortType.Pipe, this.App.GetIntlStr(TransportTypePipe));
			m_transportTypeTable.Add(PortType.TcpIp, this.App.GetIntlStr(TransportTypeTcp));
			m_transportTypeTable.Add(PortType.DeviceRPC, this.App.GetIntlStr(TransportTypeDeviceRPC));
		}
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IAttachToProcessDialogControls interface. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IAttachToProcessDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify return IAttachToProcessDialogVerify interface. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IAttachToProcessDialogVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get and Set transport type (string). 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string TransportType
		{
			get
			{
				return Controls.TransportComboBox.Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get and Set machine name (string). 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string MachineName
		{
			get
			{
				return Controls.NameEditComboBox.Text;
			}

			set
			{
				Controls.NameEditComboBox.Text = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get and Set default time out. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}
		#endregion

		#region IAttachToProcessDialogControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return TransportComboBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ComboBox IAttachToProcessDialogControls.TransportComboBox
		{
			get
			{
				return new Maui.Core.WinControls.ComboBox(this, TransportComboBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return NameEditComboBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.EditComboBox IAttachToProcessDialogControls.NameEditComboBox
		{
			get
			{
				return new Maui.Core.WinControls.EditComboBox(this,NameEditComboBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachWithCheckBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.CheckBox IAttachToProcessDialogControls.AttachWithCheckBox
		{
			get
			{
				return new Maui.Core.WinControls.CheckBox(this,AttachWithCheckBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachWithTextBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.TextBox IAttachToProcessDialogControls.AttachWithTextBox
		{
			get
			{
				return new Maui.Core.WinControls.TextBox(this,AttachWithTextBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return DebuggingEngineSelectButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IAttachToProcessDialogControls.DebuggingEngineSelectButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,DebuggingEngineSelectButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AvailableProcessesListView object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ListView IAttachToProcessDialogControls.AvailableProcessesListView
		{
			get
			{
				return new Maui.Core.WinControls.ListView(this, AvailableProcessesListViewID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ShowSystemProcessesCheckBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.CheckBox IAttachToProcessDialogControls.ShowSystemProcessesCheckBox
		{
			get
			{
				return new Maui.Core.WinControls.CheckBox(this, ShowSystemProcessesCheckBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ShowProcessesInAllSessionsCheckBox object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.CheckBox IAttachToProcessDialogControls.ShowProcessesInAllSessionsCheckBox
		{
			get
			{
				return new Maui.Core.WinControls.CheckBox(this, ShowProcessesInAllSessionsCheckBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IAttachToProcessDialogControls.AttachButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, AttachButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return CancelButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IAttachToProcessDialogControls.CancelButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, CancelButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return HelpButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IAttachToProcessDialogControls.HelpButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, HelpButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return RefreshButton object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IAttachToProcessDialogControls.RefreshButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this, RefreshButtonID);
			}
		}
		#endregion

		#region IAttachToProcessDialogVerify implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check to see if Attached Processes list contains the specified process in the list
		/// </summary>
		/// <param name="processName">Process Name</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IAttachToProcessDialogVerify.Process(string processName)
		{
			try
			{
				if (this.Controls.AvailableProcessesListView.FindAllByText(processName, false)!= null)
					return true;

				return false;
			}
			catch(System.Exception e)
			{
				throw new GlobalExceptions.MauiException(e.Message + ": error while calling Verify.Process()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify the items in the available processes list
		/// </summary>
		/// <param name="processName"> Process name</param>
		/// <param name="processID"> Process ID</param>
		/// <param name="title"> Process title</param>
		/// <param name="type"> Process type</param>
		/// <param name="session"> The session that the process is in</param>
		/// <returns> Returns bool: if match, return true; otherwise, return false.</returns>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IAttachToProcessDialogVerify.Process(string processName, string processID, string title, string type, string session)
		{
			try
			{
				foreach (Maui.Core.WinControls.ListViewItem item in this.Controls.AvailableProcessesListView.Items)
					if (IsProcessMatch(item, processName, processID, title, type, session))
						return true;				
		
				return false;
			}
			catch(System.Exception e)
			{
				throw new GlobalExceptions.MauiException(e.Message + ": error while calling ItemOfDebuggeeList()"); 
			}
		}

		#endregion

		#region member functions	
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Attach to a process automatically in default transport type
		/// </summary>
		/// <param name="machineName"> Machine name. If null, then use default.</param>
		/// <param name="processName"> Process name</param>
		/// <returns>If the process can't be found, return false; otherwise, return true.</returns>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// 	[mkpark] 3/12/2003	changed to use other overloaded method.
		/// </history>
		///-----------------------------------------------------------------------------
		public void AttachToProcess(string machineName, string processName)
		{
				this.AttachToProcess(machineName,processName,DeType.Auto);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Attach to a process in default type: PortType.Default, TeType.Native
		/// </summary>
		/// <param name="machineName"> Machine name. If null, then use default.</param>
		/// <param name="processName"> Process name</param>
		/// <param name="deType"> Debugger Engine type. Use | to combine selections.</param>
		/// <returns>If the process can't be found, return false; otherwise, return true.</returns>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// 	[mkpark] 3/12/2003 changed to use other overloaded method.
		/// </history>
		///-----------------------------------------------------------------------------
		public void AttachToProcess(string machineName, string processName, DeType deType)
		{
			AttachToProcess(machineName,processName,PortType.Default,null,deType,false,false);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Attach to a process
		/// </summary>
		/// <param name="machineName"> Machine name. Can be null to select the default machine name.</param>
		/// <param name="processName"> Process name</param>
		/// <param name="enPortName"> Transport type</param>
		/// <param name="programType"> Program type: Win32, .NET, Script ... Can be null so it won't be checked.</param>
		/// <param name="deType"> DE type. Can use | to combine flags.</param>
		/// <param name="checkSystemProcess"> Check the "System Process" checkbox</param>
		/// <param name="checkAllSessions"> Check the "All Sessions" checkbox</param>
		/// <returns>If the process can't be found, return false; otherwise, return true.</returns>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// 	[mkpark] 2/3/2003	
		/// 						- try/catch block is removed for better error logging with specific type of Exception than general one
		/// 						- let user be able to choode "auto" mode for Debugger engin. just select "Auto" DeType.
		/// 						- some small clean up. 
		/// </history>
		///-----------------------------------------------------------------------------
		public void AttachToProcess(string machineName, string processName, PortType enPortName, string programType, DeType deType, bool checkSystemProcess, bool checkAllSessions)
		{
			//set Transport type
			this.Controls.TransportComboBox.SelectByText((string)m_transportTypeTable[enPortName], false);

			//set the machine name
			if(machineName != null)
				this.Controls.NameEditComboBox.Text = machineName;
			//refresh
			this.Controls.RefreshButton.Click();
			//show system and/or all sessions processes
			if(checkSystemProcess != this.Controls.ShowSystemProcessesCheckBox.Checked)
				this.Controls.ShowSystemProcessesCheckBox.Click();
			// Devices don't support the concept of Sessions so this check box is disabled
			// when the Device transport is selected
			if(checkAllSessions != this.Controls.ShowProcessesInAllSessionsCheckBox.Checked &&
				this.Controls.TransportComboBox.Text != (string)m_transportTypeTable[PortType.DeviceRPC])
				this.Controls.ShowProcessesInAllSessionsCheckBox.Click();
			//refresh
			this.Controls.RefreshButton.Click();
			this.App.WaitForStatusReady();

			if (SelectProcess(this.Controls.AvailableProcessesListView,processName,programType))
			{
				//enable select engine types
				if(deType != DeType.Auto)
				{
					//select debugging engine type(s)
					this.Controls.AttachWithCheckBox.Checked = true;
					this.Controls.DebuggingEngineSelectButton.Click();
					DebuggingEngineSelectDialog deSelectDlg = new DebuggingEngineSelectDialog(this.App, true);
					deSelectDlg.SelectDE(deType);
					this.App.WaitForStatusReady();
				}
				else
				{
					this.Controls.AttachWithCheckBox.Checked = false;
				}
				
				//attach to it
				ClickAttachButton();
			}
			else
			{
				throw new Exceptions.ProcessNotFound("Process not found.");
			}
			
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify if a selected process matches input criteria
		/// </summary>
		///<param name="item"> Process ListView item</param>
		/// <param name="processName"> Process name</param>
		/// <param name="processID"> Process ID </param>
		/// <param name="title"> Process title</param>
		/// <param name="type"> Process type: Win32, .NET, Script ...</param>
		/// <param name="session"> The session that the process is in</param>
		/// <returns>If matched debugee is found, return true; otherwise, return false.</returns>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		private bool IsProcessMatch(Maui.Core.WinControls.ListViewItem item, string processName, string processID, string title, string type, string session)
		{
			try
			{
				if((processName != null) && (item[ProcessListItem.Name].Text.ToLower() != processName.ToLower()))
					return false;
				if((processID != null) && (item[ProcessListItem.ID].Text.ToLower() != processID.ToLower()))
					return false;
				if((title != null) && (item[ProcessListItem.Title].Text.ToLower() != title.ToLower()))
					return false;
				if((type != null) && (item[ProcessListItem.Type].Text.ToLower() != type.ToLower()))
					return false;
				if((session != null) && (item[ProcessListItem.Sessions].Text.ToLower() != session.ToLower()))
					return false;

				return true;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling IsProcessMatch()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Select a process from a processes list view.
		/// </summary>
		/// <param name="listView"> Processes list view</param>
		/// <param name="processName"> Process name</param>
		/// <returns>If the process is found, return true; otherwise, return false.</returns>
		/// <remarks></remarks>
		/// <history>
		/// 	[yiqingdu] 	10/31/2002	Created
		/// 	[mkpark]    3/12/2003		Change to use "programType".
		/// </history>
		///-----------------------------------------------------------------------------
		private bool SelectProcess(Maui.Core.WinControls.ListView listView, string processName,string programType)
		{
			bool processFound = false;

			//find the process
			foreach (Maui.Core.WinControls.ListViewItem type in this.Controls.AvailableProcessesListView.Items)
			{
				if (type.Text.ToLower().StartsWith(processName.ToLower()))
					if ((programType == null) || (type[ProcessListItem.Type].Text.ToLower().IndexOf(programType.ToLower(), 0, programType.Length) != -1))
					{
						type.Select();
						this.Controls.AvailableProcessesListView.WaitForResponse();
						processFound = true;
						break;
					}
			}

			return processFound;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Wrapper function to click the Attach button. If the button
		/// is not active, throw an exception
		/// </summary>
		/// <history>
		/// 	[yiqingdu] 	02/14/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void ClickAttachButton()
		{
			if(this.Controls.AttachButton.Extended.IsEnabled)
			{
				this.Controls.AttachButton.Click();
				this.App.WaitForStatusReady();
			}
			else
				throw new Exceptions.AttachButtonNotEnabled("Attach button is not enabled.");
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\BreakPointPropertiesDialog.cs ===
using System;
using Maui.Core;
using Maui.Core.WinControls;
using System.ComponentModel;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	#region Interface for Controls
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IBreakpointPropertiesDialogControls
	{
		TabControl BreakpointTypesTabControl {get;}
		Button ConditionButton {get;}
		Button HitCountButton {get;}
		Button OKButton {get;}
		Button CancelButton {get;}
		Button HelpButton {get;}
		StaticControl ConditionStaticControl {get;}
		StaticControl HitCountStaticControl {get;}
		EditComboBox LanguageEditComboBox{get;}

		//controls on the Function tab
		TextBox FunctionTextBox{get;}
		TextBox FunctionLineTextBox{get;}
		TextBox FunctionCharacterTextBox{get;}

		//controls on the File tab
		TextBox FileTextBox{get;}
		TextBox FileLineTextBox{get;}
		TextBox FileCharacterTextBox{get;}

		//controls on the Address tab
		TextBox AddressTextBox{get;}

		//controls on the Data tab
		TextBox DataVariableTextBox{get;}
		TextBox DataItemsTextBox{get;}
		TextBox DataContextTextBox{get;}
	}
	#endregion
	///-----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: BreakPointPropertiesDialog
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class implements the functionality of the New Breakpoint and BreakpointProperties dialog
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/5/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------

	public class BreakPointPropertiesDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IBreakpointPropertiesDialogControls
	{
#region "Interface, Constants, Strings, and Control IDs"

		public class Strings
		{
			public const string BreakpointPropertiesDialogTitle = "VSDebugUI.dll:5:4908:0"; //"Breakpoint Properties";
			public const string NewBreakpointDialogTitle = "VSDebugUI.dll:6:1:10"; //"New Breakpoint";

			public const string FunctionTabText = "VSDebugUI.dll:6:12:13";
			public const string FileTabText = "VSDebugUI.dll:6:12:14";
			public const string AddressTabText = "VSDebugUI.dll:6:12:15";
			public const string DataTabText = "VSDebugUI.dll:6:13:0";

			public const string LanguageBasic = "VSDebugUI.dll:6:7:13";
			public const string LanguageCSharp = "cslangsvcui.dll:6:8:11";
			public const string LanguageCPP = "VSDebugUI.dll:6:7:12";
			public const string LanguageJScript = "msenvui.dll:6:900:11";
			public const string LanguageScript = "VSDebugUI.dll:6:7:10";
			public const string LanguageSQL = "VSDebugUI.dll:6:7:11";
			public const string LanguageUnknown = "VSDebugUI.dll:6:7:14";
			public const string LanguageVJSharp = "VJ#";
		}

		public class ControlIDs
		{
			public const int breakpointTypesTabControlID = 1050;
			public const int conditionButtonID = 1062;
			public const int hitCountButtonID = 1063;
			public const int OKButtonID = 1;
			public const int cancelButtonID = 2;
			public const int helpButtonID = 4921;
			public const int languageEditComboBoxID = 1067;
			public const int conditionStaticControlID = 4912;
			public const int hitCountStaticControlID = 1036;


			//IDs for the controls on the Function tab
			public const int functionTextBoxID = 1056;
			public const int functionLineTextBoxID = 1057;
			public const int functionCharacterTextBoxID = 1061;
			//IDs for the controls on the File tab
			public const int fileTextBoxID = 1052;
			public const int fileLineTextBoxID = 1053;          
			public const int fileCharacterTextBoxID = 1054;
			//IDs for the controls on the Address tab           
			public const int addressTextBoxID = 1060;
			//IDs for the controls on the Data tab
			public const int dataVariableTextBoxID = 1058;                     
			public const int dataItemsTextBoxID = 1059;                        
			public const int dataContextTextBoxID = 1128;

		}
#endregion

#region "Variables for Cached Controls"
		TabControl m_cachedBreakpointTypesTabControl;
		Button m_cachedConditionButton;
		Button m_cachedHitCountButton;
		Button m_cachedOKButton;
		Button m_cachedCancelButton;
		Button m_cachedHelpButton;
		StaticControl m_cachedConditionStaticControl;
		StaticControl m_cachedHitCountStaticControl;
		EditComboBox m_cachedLanguageEditComboBox;

		//controls on the Function tab
		TextBox m_cachedFunctionTextBox;
		TextBox m_cachedFunctionLineTextBox;
		TextBox m_cachedFunctionCharacterTextBox;
		//EditComboBox m_cachedFunctionLanguageEditComboBox;

		//controls on the File tab
		TextBox m_cachedFileTextBox;
		TextBox m_cachedFileLineTextBox;
		TextBox m_cachedFileCharacterTextBox;

		//controls on the Address tab
		TextBox m_cachedAddressTextBox;
		//EditComboBox m_cachedAddressLanguageEditComboBox;

		//controls on the Data tab
		TextBox m_cachedDataVariableTextBox;
		TextBox m_cachedDataItemsTextBox;
		TextBox m_cachedDataContextTextBox;
		//EditComboBox m_cachedDataLanguageEditComboBox;
#endregion


#region "Other private variables"
		private Maui.VisualStudio.Everett.IDEApp m_app;
#endregion

#region "Constructors"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the Breakpoint Properties dialog is open for the default application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[[mkoller]] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPointPropertiesDialog(): base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.BreakpointPropertiesDialogTitle), true)
		{
			Init(CoreManager.ActiveApp);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the Breakpoint Properties dialog is open for the given application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[[mkoller]] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPointPropertiesDialog(IDEApp app): base(app, app.GetIntlStr(Strings.BreakpointPropertiesDialogTitle), true)
		{
			Init(app);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the Breakpoint Properties dialog is open with the default application
		/// </summary>
		/// <param name="IsNewBreakpoint">true for New Breakpoint, false for Breakpoint Properties</param>
		/// <remarks></remarks>
		/// <history>[[mkoller]] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPointPropertiesDialog(bool IsNewBreakpoint) : base(CoreManager.ActiveApp, IsNewBreakpoint ? CoreManager.ActiveApp.GetIntlStr(Strings.NewBreakpointDialogTitle) : CoreManager.ActiveApp.GetIntlStr(Strings.BreakpointPropertiesDialogTitle), true)

		{
			Init(CoreManager.ActiveApp);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the Breakpoint Properties dialog is open with the given application
		/// </summary>
		/// <param name="IsNewBreakpoint">true for New Breakpoint, false for Breakpoint Properties</param>
		/// <remarks></remarks>
		/// <history>[[mkoller]] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakPointPropertiesDialog(IDEApp app, bool IsNewBreakpoint) : base(CoreManager.ActiveApp, IsNewBreakpoint ? CoreManager.ActiveApp.GetIntlStr(Strings.NewBreakpointDialogTitle) : CoreManager.ActiveApp.GetIntlStr(Strings.BreakpointPropertiesDialogTitle), true)
		{
			Init(app);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// This function will attempt to find a showing instance of the dialog.
		/// </summary>
		/// <remarks></remarks>)
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(IDEApp app)
		{
			// set app
			m_app = app;
		
			// set focus on window. 
			this.Extended.SetFocus();
		}

#endregion

#region "Public Properties"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the raw controls for this dialog
		/// </summary>
		/// <value>An interface that groups all of the dialog's control properties together</value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IBreakpointPropertiesDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Condition
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickCondition()
		{
			Controls.ConditionButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button HitCount
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHitCount()
		{
			Controls.HitCountButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button OK
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickOK()
		{
			Controls.OKButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Cancel
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickCancel()
		{
			Controls.CancelButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Help
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHelp()
		{
			Controls.HelpButton.Click();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control BreakpointTypesTabControlTab
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointInfo.BreakpointType BreakpointTypesTabControlTabValue
		{
			get
			{
				if(Controls.BreakpointTypesTabControl.SelectedTab.Text == App.GetIntlStr(Strings.FunctionTabText))
					return BreakpointInfo.BreakpointType.Function;
				if(Controls.BreakpointTypesTabControl.SelectedTab.Text == App.GetIntlStr(Strings.FileTabText))
					return BreakpointInfo.BreakpointType.File;
				if(Controls.BreakpointTypesTabControl.SelectedTab.Text == App.GetIntlStr(Strings.AddressTabText))
					return BreakpointInfo.BreakpointType.Address;
				if(Controls.BreakpointTypesTabControl.SelectedTab.Text == App.GetIntlStr(Strings.DataTabText))
					return BreakpointInfo.BreakpointType.Data;
				return BreakpointInfo.BreakpointType.File;  //we shouldn't get here
			}
			set
			{
				if(value == BreakpointInfo.BreakpointType.Function)
					Controls.BreakpointTypesTabControl[App.GetIntlStr(Strings.FunctionTabText)].Select();
				else if(value == BreakpointInfo.BreakpointType.File)
					Controls.BreakpointTypesTabControl[App.GetIntlStr(Strings.FileTabText)].Select();
				else if(value == BreakpointInfo.BreakpointType.Address)
					Controls.BreakpointTypesTabControl[App.GetIntlStr(Strings.AddressTabText)].Select();
				else if(value == BreakpointInfo.BreakpointType.Data)
					Controls.BreakpointTypesTabControl[App.GetIntlStr(Strings.DataTabText)].Select();
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to get the text in control ConditionStaticControl
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string ConditionStaticControlText
		{
			get
			{
				return Controls.ConditionStaticControl.Text;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to get the text in control HitCountStaticControl
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string HitCountStaticControlText
		{
			get
			{
				return Controls.HitCountStaticControl.Text;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control LanguageEditComboBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------		
		public BreakpointInfo.Language LanguageEditComboBoxValue
		{
			get
			{
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageBasic))
					return BreakpointInfo.Language.Basic;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageCPP))
					return BreakpointInfo.Language.CPP;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageCSharp))
					return BreakpointInfo.Language.CS;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageJScript))
					return BreakpointInfo.Language.JScript;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageScript))
					return BreakpointInfo.Language.Script;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageSQL))
					return BreakpointInfo.Language.SQL;
				if(Controls.LanguageEditComboBox.Text == App.GetIntlStr(Strings.LanguageUnknown))
					return BreakpointInfo.Language.Unknown;
				if(Controls.LanguageEditComboBox.Text == CoreManager.ActiveApp.GetIntlStr(Strings.LanguageVJSharp))
					return BreakpointInfo.Language.VJS;
				return BreakpointInfo.Language.Unknown;  //we shouldn't get here
			}
			set
			{
				if(value == BreakpointInfo.Language.Basic)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageBasic),true);
				if(value == BreakpointInfo.Language.CPP)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageCPP),true);
				if(value == BreakpointInfo.Language.CS)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageCSharp),true);
				if(value == BreakpointInfo.Language.JScript)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageJScript),true);
				if(value == BreakpointInfo.Language.Script)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageScript),true);
				if(value == BreakpointInfo.Language.SQL)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageSQL),true);
				if(value == BreakpointInfo.Language.Unknown)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageUnknown),true);
				if(value == BreakpointInfo.Language.VJS)
					Controls.LanguageEditComboBox.SelectByText(App.GetIntlStr(Strings.LanguageVJSharp),true);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FunctionTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FunctionTextBoxText
		{
			get
			{
				return Controls.FunctionTextBox.Text;
			}
			set
			{
				Controls.FunctionTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FunctionLineTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FunctionLineTextBoxText
		{
			get
			{
				return Controls.FunctionLineTextBox.Text;
			}
			set
			{
				Controls.FunctionLineTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FunctionCharacterText
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FunctionCharacterTextBoxText
		{
			get
			{
				return Controls.FunctionCharacterTextBox.Text;
			}
			set
			{
				Controls.FunctionCharacterTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FileTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FileTextBoxText
		{
			get
			{
				return Controls.FileTextBox.Text;
			}
			set
			{
				Controls.FileTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FileLineTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FileLineTextBoxText
		{
			get
			{
				return Controls.FileLineTextBox.Text;
			}
			set
			{
				Controls.FileLineTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control FileCharacterTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FileCharacterTextBoxText
		{
			get
			{
				return Controls.FileCharacterTextBox.Text;
			}
			set
			{
				Controls.FileCharacterTextBox.Text = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control AddressTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string AddressTextBoxText
		{
			get
			{
				return Controls.AddressTextBox.Text;
			}
			set
			{
				Controls.AddressTextBox.Text = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control DataVariableTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string DataVariableTextBoxText
		{
			get
			{
				return Controls.DataVariableTextBox.Text;
			}
			set
			{
				Controls.DataVariableTextBox.Text = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control DataItemsTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DataItemsTextBoxText
		{
			get
			{
				return System.Convert.ToInt32(Controls.DataItemsTextBox.Text);
			}
			set
			{
				Controls.DataItemsTextBox.Text = value.ToString();
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control DataContextTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string DataContextTextBoxText
		{
			get
			{
				return Controls.DataContextTextBox.Text;
			}
			set
			{
				Controls.DataContextTextBox.Text = value;
			}
		}

#endregion

#region "Control Implementations"

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the BreakpointTypesTabControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TabControl IBreakpointPropertiesDialogControls.BreakpointTypesTabControl
		{
			get
			{
				if (m_cachedBreakpointTypesTabControl == null)
					m_cachedBreakpointTypesTabControl = new TabControl(this, ControlIDs.breakpointTypesTabControlID);

				return m_cachedBreakpointTypesTabControl;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the ConditionButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IBreakpointPropertiesDialogControls.ConditionButton
		{
			get
			{
				if (this.m_cachedConditionButton == null)
					m_cachedConditionButton = new Button(this, ControlIDs.conditionButtonID);

				return m_cachedConditionButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HitCountButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IBreakpointPropertiesDialogControls.HitCountButton
		{
			get
			{
				if (this.m_cachedHitCountButton == null)
					m_cachedHitCountButton = new Button(this, ControlIDs.hitCountButtonID);

				return m_cachedHitCountButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the OKButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IBreakpointPropertiesDialogControls.OKButton
		{
			get
			{
				if (this.m_cachedOKButton == null)
					m_cachedOKButton = new Button(this, ControlIDs.OKButtonID);

				return m_cachedOKButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the CancelButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IBreakpointPropertiesDialogControls.CancelButton
		{
			get
			{
				if (this.m_cachedCancelButton == null)
					m_cachedCancelButton = new Button(this, ControlIDs.cancelButtonID);

				return m_cachedCancelButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HelpButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IBreakpointPropertiesDialogControls.HelpButton
		{
			get
			{
				if (this.m_cachedHelpButton == null)
					m_cachedHelpButton = new Button(this, ControlIDs.helpButtonID);

				return m_cachedHelpButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the ConditionStaticControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		StaticControl IBreakpointPropertiesDialogControls.ConditionStaticControl
		{
			get
			{
				if (this.m_cachedConditionStaticControl == null)
					m_cachedConditionStaticControl = new StaticControl(this, ControlIDs.conditionStaticControlID);

				return m_cachedConditionStaticControl;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HitCountStaticControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		StaticControl IBreakpointPropertiesDialogControls.HitCountStaticControl
		{
			get
			{
				if (this.m_cachedHitCountStaticControl == null)
					m_cachedHitCountStaticControl = new StaticControl(this, ControlIDs.hitCountStaticControlID);

				return m_cachedHitCountStaticControl;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the LanguageEditComboBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		EditComboBox IBreakpointPropertiesDialogControls.LanguageEditComboBox
		{
			get
			{
				if (this.m_cachedLanguageEditComboBox == null)
					m_cachedLanguageEditComboBox = new EditComboBox(this, ControlIDs.languageEditComboBoxID);

				return m_cachedLanguageEditComboBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FunctionTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FunctionTextBox
		{
			get
			{
				if (this.m_cachedFunctionTextBox == null)
					m_cachedFunctionTextBox = new TextBox(this, ControlIDs.functionTextBoxID);

				return m_cachedFunctionTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FunctionLineTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FunctionLineTextBox
		{
			get
			{
				if (this.m_cachedFunctionLineTextBox == null)
					m_cachedFunctionLineTextBox = new TextBox(this, ControlIDs.functionLineTextBoxID);

				return m_cachedFunctionLineTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FunctionCharacterTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FunctionCharacterTextBox
		{
			get
			{
				if (this.m_cachedFunctionCharacterTextBox == null)
					m_cachedFunctionCharacterTextBox = new TextBox(this, ControlIDs.functionCharacterTextBoxID);

				return m_cachedFunctionCharacterTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FileTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FileTextBox
		{
			get
			{
				if (this.m_cachedFileTextBox == null)
					m_cachedFileTextBox = new TextBox(this, ControlIDs.fileTextBoxID);

				return m_cachedFileTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FileLineTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FileLineTextBox
		{
			get
			{
				if (this.m_cachedFileLineTextBox == null)
					m_cachedFileLineTextBox = new TextBox(this, ControlIDs.fileLineTextBoxID);

				return m_cachedFileLineTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the FileCharacterTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.FileCharacterTextBox
		{
			get
			{
				if (this.m_cachedFileCharacterTextBox == null)
					m_cachedFileCharacterTextBox = new TextBox(this, ControlIDs.fileCharacterTextBoxID);

				return m_cachedFileCharacterTextBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the AddressTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.AddressTextBox
		{
			get
			{
				if (this.m_cachedAddressTextBox == null)
					m_cachedAddressTextBox = new TextBox(this, ControlIDs.addressTextBoxID);

				return m_cachedAddressTextBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the DataVariableTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.DataVariableTextBox
		{
			get
			{
				if (this.m_cachedDataVariableTextBox == null)
					m_cachedDataVariableTextBox = new TextBox(this, ControlIDs.dataVariableTextBoxID);

				return m_cachedDataVariableTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the DataItemsTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.DataItemsTextBox
		{
			get
			{
				if (this.m_cachedDataItemsTextBox == null)
					m_cachedDataItemsTextBox = new TextBox(this, ControlIDs.dataItemsTextBoxID);

				return m_cachedDataItemsTextBox;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the DataContextTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IBreakpointPropertiesDialogControls.DataContextTextBox
		{
			get
			{
				if (this.m_cachedDataContextTextBox == null)
					m_cachedDataContextTextBox = new TextBox(this, ControlIDs.dataContextTextBoxID);

				return m_cachedDataContextTextBox;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\ConditionDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IConditionDialogControls
	{
		CheckBox ConditionCheckBox {get;}
		TextBox ConditionTextBox {get;}
		RadioButton IsTrueRadioButton {get;}
		RadioButton HasChangedRadioButton {get;}
		Button OKButton {get;}
		Button CancelButton {get;}
		Button HelpButton {get;}
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: Alert
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This Class implements the Breakpoint Condition Dialog
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/5/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------

	public class ConditionDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IConditionDialogControls
	{
#region "Interface, Constants, Strings, and Control IDs"

		public class Strings
		{
			public const string Caption = "VSDebugUI.dll:5:4902:0";
		}

		public class ControlIDs
		{
			public const int conditionCheckBox = 1035;
			public const int conditionTextBox = 4912;
			public const int isTrueRadioButton = 1022;
			public const int hasChangedRadioButton = 1023;
			public const int OKButton = 1;
			public const int cancelButton = 2;
			public const int helpButton = 4921;
		}
#endregion

#region "Variables for Cached Controls"
		protected CheckBox m_cachedConditionCheckBox;
		protected TextBox m_cachedConditionTextBox;
		protected RadioButton m_cachedIsTrueRadioButton;
		protected RadioButton m_cachedHasChangedRadioButton;
		protected Button m_cachedOKButton;
		protected Button m_cachedCancelButton;
		protected Button m_cachedHelpButton;
		private const int m_defaultTimeOut = 10000;

#endregion
		#region "Other private variables"
		private Maui.VisualStudio.Everett.IDEApp m_app;
#endregion

#region "Constructors"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using the default application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ConditionDialog() : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.Caption),  true)
		{
			Init(CoreManager.ActiveApp);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using a given application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ConditionDialog(IDEApp app) : base(app, app.GetIntlStr(Strings.Caption),  true)
		{
			Init(app);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// This function will attempt to find a showing instance of the dialog.
		/// </summary>
		/// <returns>The dialog's hWnd</returns>
		/// <remarks></remarks>)
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(IDEApp app)
		{
			//			// First look to see if the dialog is already showing
			//			int handle = FindWindow(Utilities.GetIntlStr(Strings.Caption), 
			//				"#32770  /*strClass*/", 
			//				0, /*ControlID*/
			//				true, /*bVisibleOnly*/
			//				0, /*hwndStartWindow*/
			//				app.Process.Id,
			//				false /*CaptionCaseSensitive*/,m_defaultTimeOut );
			//			if (handle != 0)
			//				return handle;
			//			else
			//			{
			//				// Dialog wasn't found, so throw an exception since it is supposed to be up
			//				throw new Maui.Exceptions.VisualStudio.Everett.BreakpointsExceptions.DialogNotFoundException("Breakpoint Condition dialog is not visible.");
			//
			//			}
			// set app
			m_app = app;
		
			// set focus on window. 
			//this.Extended.SetFocus();

		}

#endregion

#region "Public Properties"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the raw controls for this dialog
		/// </summary>
		/// <value>An interface that groups all of the dialog's control properties together</value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IConditionDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Condition
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickCondition()
		{
			Controls.ConditionCheckBox.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button istrue
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickIsTrue()
		{
			Controls.IsTrueRadioButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button haschanged
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHasChanged()
		{
			Controls.HasChangedRadioButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button OK
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickOK()
		{
			Controls.OKButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Cancel
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickCancel()
		{
			Controls.CancelButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Help
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHelp()
		{
			Controls.HelpButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control TextBox3
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string ConditionTextBoxText
		{
			get
			{
				return Controls.ConditionTextBox.Text;
			}

			set
			{
				Controls.ConditionTextBox.Text = value;
			}
		}

		public BreakpointInfo.ConditionType BreakpointConditionType
		{
			get
			{
				if(Controls.IsTrueRadioButton.ButtonState == ButtonState.Checked)
					return BreakpointInfo.ConditionType.IsTrue;
				return BreakpointInfo.ConditionType.HasChanged;
			}
		}


#endregion

#region "Control Implementations"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the ConditionCheckBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		CheckBox IConditionDialogControls.ConditionCheckBox
		{
			get
			{
				if (m_cachedConditionCheckBox == null)
					m_cachedConditionCheckBox = new CheckBox(this, ControlIDs.conditionCheckBox);

				return m_cachedConditionCheckBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the ConditionTextBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IConditionDialogControls.ConditionTextBox
		{
			get
			{
				if (m_cachedConditionTextBox == null)
					m_cachedConditionTextBox = new TextBox(this, ControlIDs.conditionTextBox);

				return m_cachedConditionTextBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the istrueRadioButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		RadioButton IConditionDialogControls.IsTrueRadioButton
		{
			get
			{
				if (m_cachedIsTrueRadioButton == null)
					m_cachedIsTrueRadioButton = new RadioButton(this, ControlIDs.isTrueRadioButton);

				return m_cachedIsTrueRadioButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the haschangedRadioButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		RadioButton IConditionDialogControls.HasChangedRadioButton
		{
			get
			{
				if (m_cachedHasChangedRadioButton == null)
					m_cachedHasChangedRadioButton = new RadioButton(this, ControlIDs.hasChangedRadioButton);

				return m_cachedHasChangedRadioButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the OKButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IConditionDialogControls.OKButton
		{
			get
			{
				if (m_cachedOKButton == null)
					m_cachedOKButton = new Button(this, ControlIDs.OKButton);

				return m_cachedOKButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the CancelButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IConditionDialogControls.CancelButton
		{
			get
			{
				if (m_cachedCancelButton == null)
					m_cachedCancelButton = new Button(this, ControlIDs.cancelButton);

				return m_cachedCancelButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HelpButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IConditionDialogControls.HelpButton
		{
			get
			{
				if (m_cachedHelpButton == null)
					m_cachedHelpButton = new Button(this, ControlIDs.helpButton);

				return m_cachedHelpButton;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\EditAndContinueDialog.cs ===
using System;
using Maui.Core;
using Maui.Core.WinControls;
using System.ComponentModel;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	/// <summary>
	/// Summary description for EditAndContinueDialog.
	/// </summary>

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IEditAndContinueDialogControls
	{
		StaticControl EncMessageStaticControl {get;}
		Button EditCodeButton {get;}
		Button IgnoreButton {get;}
		Button HelpButton {get;}
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: Alert
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This Class implements the Edit and Continue Dialog
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/5/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------

	public class EditAndContinueDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IEditAndContinueDialogControls
	{
#region "Interface, Constants, Strings, and Control IDs"

		public class Strings
		{
			public const string Caption = ":Edit and Continue:Win32DialogString:VSDebugUI.dll:120";

		}

		public class ControlIDs
		{
			public const int encMessageStaticControl = 1115;
			public const int editCodeButton = 1171;
			public const int ignoreButton = 1173;
			public const int helpButton = 9;
		}


#endregion

#region "Variables for Cached Controls"
		protected StaticControl m_cachedEncMessageStaticControl;
		protected Button m_cachedEditCodeButton;
		protected Button m_cachedIgnoreButton;
		protected Button m_cachedHelpButton;
#endregion

#region "Other private variables"
		private Maui.VisualStudio.Everett.IDEApp m_app;
#endregion
#region "Constructors"

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using the default application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public EditAndContinueDialog() : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.Caption),  true)
		{
			Init(CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using a given application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[Dialog Maker Tool] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public EditAndContinueDialog(IDEApp app) : base(app, app.GetIntlStr(Strings.Caption), true)
		{
			Init(app);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using a given application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[Dialog Maker Tool] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public EditAndContinueDialog(int Timeout) : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.Caption), true, Timeout)
		{
			Init(CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// This function will attempt to find a showing instance of the dialog.
		/// </summary>
		/// <returns>The dialog's hWnd</returns>
		/// <remarks></remarks>)
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(IDEApp app)
		{
			m_app = app;
		}

#endregion

#region "Public Properties"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the raw controls for this dialog
		/// </summary>
		/// <value>An interface that groups all of the dialog's control properties together</value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IEditAndContinueDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button EditCode
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickEditCodeButton()
		{
			Controls.EditCodeButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Ignore
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickIgnoreButton()
		{
			Controls.IgnoreButton.Click();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Help
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHelpButton()
		{
			Controls.HelpButton.Click();
		}
	#endregion
	#region "Control Implementations"
	
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the EncMessageStaticControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		StaticControl IEditAndContinueDialogControls.EncMessageStaticControl
		{
			get
			{
				if (m_cachedEncMessageStaticControl == null)
					m_cachedEncMessageStaticControl = new StaticControl(this, ControlIDs.encMessageStaticControl);

				return m_cachedEncMessageStaticControl;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the EditCodeButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IEditAndContinueDialogControls.EditCodeButton
		{
			get
			{
				if (m_cachedEditCodeButton == null)
					m_cachedEditCodeButton = new Button(this, ControlIDs.editCodeButton);

				return m_cachedEditCodeButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the IgnoreButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IEditAndContinueDialogControls.IgnoreButton
		{
			get
			{
				if (m_cachedIgnoreButton == null)
					m_cachedIgnoreButton = new Button(this, ControlIDs.ignoreButton);

				return m_cachedIgnoreButton;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HelpButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IEditAndContinueDialogControls.HelpButton
		{
			get
			{
				if (m_cachedHelpButton == null)
					m_cachedHelpButton = new Button(this, ControlIDs.helpButton);

				return m_cachedHelpButton;
			}
		}
	#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\ExceptionPass.cs ===
//*********************************************************
// Owner : bboris
// Class name : ExceptionPass
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	using System;
	using System.ComponentModel;
	using Maui.Core.WinControls;
	using Maui.Core;
    
    
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IExceptionPassControls
	{
        
		Button YesButton
		{
			get;
		}
        
		Button NoButton
		{
			get;
		}
        
	}
    
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  After an exception has been handled by the debugger if the user click continue they get
	///  a dialog asking them if they want to pass exception to the program being debugged.  This 
	///  class handles that dialog
	///  </summary>
	///  <remarks></remarks>
	///  <history>[bboris] 11/19/2002 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	/// 
	public class ExceptionPass : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IExceptionPassControls
	{
        #region "Interface, Constants, Strings, and Control IDs"
		public class ControlIDs
		{
            
			public const int YesButton = 6;
            
			public const int NoButton = 7;
            
		}

		#endregion 

		#region member variables
		protected Button m_CachedYesButton;
        
		protected Button m_CachedNoButton;
        
		private const string m_DialogTitle = "msenvmui.dll:6:188:8"; 

		private int m_defaultTimeOut = 10000; // milliseconds. 
        
		#endregion 


		#region Constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for ExcpetionPass Class
		/// </summary>
		/// <param name="app">IDEApp to be passed on to base class</param>
		/// <remarks></remarks>
		/// <history>[bboris] 1/9/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionPass(IDEApp app): base(app,app.GetIntlStr(m_DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default Constructor for ExcpetionPass Class
		/// </summary>
		/// <remarks></remarks>
		/// <history>[bboris] 1/9/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ExceptionPass(): base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(m_DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IExceptionPassControls Controls
		{
			get
			{
				return this;
			}
		}
		#endregion
        
		#region IExceptionPassControls implementation
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the YesButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionPassControls.YesButton
		{
			get
			{
				if ((m_CachedYesButton == null))
				{
					m_CachedYesButton = new Button(this, ControlIDs.YesButton);
				}
				return m_CachedYesButton;
			}
		}
        
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the NoButton control
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionPassControls.NoButton
		{
			get
			{
				if ((m_CachedNoButton == null))
				{
					m_CachedNoButton = new Button(this, ControlIDs.NoButton);
				}
				return m_CachedNoButton;
			}
		}
        
        
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Yes
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickYes()
		{
			Controls.YesButton.Click();
		}
        
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button No
		///  </summary>
		///  <remarks></remarks>
		///  <history>[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickNo()
		{
			Controls.NoButton.Click();
		}
        
		#endregion

		
	
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\ExceptionsDialog.cs ===
using System;
using System.ComponentModel;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for Exceptions Dialog.
		
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IExceptionsDialogControls
	{
		TreeView ExceptionsTreeView
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
    
		Button FindButton
		{
			get;
		}
    
		Button FindNextButton
		{
			get;
		}
    
		Button ClearAllButton
		{
			get;
		}
    
		Button AddButton
		{
			get;
		}
    
		Button DeleteButton
		{
			get;
		}
	}


	#endregion

	#region Helper Classes

	///-----------------------------------------------------------------------------
	/// <summary>
	/// EXCEPTION_RUNTIME_TYPE enum that relates to the 4 types of exceptions found in the exceptions dialog.
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum ExceptionRuntimeType
	{
		CPlusPlusExceptions,
		CommonLanguageRuntimeExceptions,
		NativeRunTimeChecks,
		Win32Exceptions,
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// EXCEPT_SETTING_TYPE enum that relates to the 2 states that can be set on an exception.
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum ExceptSettingType
	{
		None,
		FirstChance,
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls both the ui of the debugger excetions dialog as well as providing functionality to drive the ui.
	/// </summary>
	///  <history>
	///			[bboris] 1/30/2003 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class ExceptionsDialog : VsDialog, IExceptionsDialogControls
	{

		#region Exceptions
		public new class Exceptions : VsDialog.Exceptions
		{	
			[Serializable]
				public class NameNotFoundException : MauiException
			{
				public NameNotFoundException(string message) : base(message) {}

				protected NameNotFoundException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}

			[Serializable]
				public class InvalidIndexException : MauiException
			{
				public InvalidIndexException(string message) : base(message) {}

				protected InvalidIndexException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int ExceptionsTreeView = 4870;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 4875;
        
			public const int FindButton = 4876;
        
			public const int FindNextButton = 4877;
        
			public const int ClearAllButton = 4878;
        
			public const int AddButton = 4879;
        
			public const int DeleteButton = 4880;
		}


		private const string DialogTitle = "VSDebugUI.dll:5:4130:0"; 
		private const string AnExceptionContainingTheSpecifiedStringWasNotFound = ":An exception containing the specified string was not found.:Win32String:vsdebugui.dll:503";
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion

		#region Constructors

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exceptions Dialog constructor that launches the debuggers exception dialog
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public ExceptionsDialog() : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(DialogTitle),Constants.Commands.ViewDebugWindowsExceptions,false)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exceptions Dialog constructor that launches the debuggers exception dialog
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public ExceptionsDialog(IDEApp app) :  base(app,app.GetIntlStr(DialogTitle),Constants.Commands.ViewDebugWindowsExceptions,false)
		{
			this.WaitForResponse(DefaultTimeOut); 
		}
    
		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IExceptionsDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		#endregion

		#region IExceptionsDialogControls implementation
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.ExceptionsTreeView control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TreeView IExceptionsDialogControls.ExceptionsTreeView
		{
			get
			{
				return new TreeView(this, ControlIDs.ExceptionsTreeView);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.FindButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.FindButton
		{
			get
			{
				return new Button(this, ControlIDs.FindButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.FindNextButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.FindNextButton
		{
			get
			{
				return new Button(this, ControlIDs.FindNextButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.ClearAllButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.ClearAllButton
		{
			get
			{
				return new Button(this, ControlIDs.ClearAllButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.AddButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.AddButton
		{
			get
			{
				return new Button(this, ControlIDs.AddButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the IExceptionsDialogControls.DeleteButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IExceptionsDialogControls.DeleteButton
		{
			get
			{
				return new Button(this, ControlIDs.DeleteButton);
			}
		}
    
		#endregion

		#region IExceptionsDialogControls Helper Funcitons

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Find
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickFind()
		{
			Controls.FindButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button FindNext
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickFindNext()
		{
			Controls.FindNextButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button ClearAll
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickClearAll()
		{
			Controls.ClearAllButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Add
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickAdd()
		{
			Controls.AddButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Delete
		///  </summary>
		///  <history>
		///			[bboris] 1/30/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickDelete()
		{
			Controls.DeleteButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion

		#region Member Funcitons

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ChangeSettings will take an excpetion name, find it in the exceptions dialog and set it to the user EXCEPT_SETTING_TYPE
		/// 
		/// usgae:
		/// 
		/// my_exceptionsDialog.ChangeSettings("Divide by Zero",EXCEPT_SETTING_TYPE.FirstChance);
		///
		/// </summary>
		/// <param name="exceptionName">the name of the exception</param>
		/// <param name="setting">setting to apply to the exception with the name of exceptionName</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ChangeSettings(string exceptionName, ExceptSettingType setting)
		{
			Find(exceptionName);
			switch(setting)
			{
				case ExceptSettingType.None:
					this.Controls.ExceptionsTreeView.SelectedItem.Checked = false;
					break;
				case ExceptSettingType.FirstChance:
					this.Controls.ExceptionsTreeView.SelectedItem.Checked = true;
					break;
				default : throw new  Exceptions.InvalidIndexException("Invalid EXCEPT_SETTING_TYPE index.");
			}
		}

		public void AddNew(ExceptionRuntimeType runtimeType, string name, string number)
		{

			switch(runtimeType)
			{
					case ExceptionRuntimeType.CPlusPlusExceptions:
					this.Controls.ExceptionsTreeView.SelectByIndex(0);
					this.ClickAdd();
					NewCExceptionsDialog tempNewCExceptionsDialog = new NewCExceptionsDialog(this.Controls.ExceptionsTreeView.SelectedItem.Text);
					tempNewCExceptionsDialog.Controls.FindTextBox.Text = name;
					tempNewCExceptionsDialog.ClickOK();
					break;
				case ExceptionRuntimeType.CommonLanguageRuntimeExceptions:
					this.Controls.ExceptionsTreeView.SelectByIndex(1);
					this.ClickAdd();
					NewCommonLanguageRuntimeExceptionsDialog tempNewCommonLanguageRuntimeExceptionsDialog = new NewCommonLanguageRuntimeExceptionsDialog(this.Controls.ExceptionsTreeView.SelectedItem.Text);
					tempNewCommonLanguageRuntimeExceptionsDialog.Controls.FindTextBox.Text = name;
					tempNewCommonLanguageRuntimeExceptionsDialog.ClickOK();
					break;				
				case ExceptionRuntimeType.NativeRunTimeChecks:
					this.Controls.ExceptionsTreeView.SelectByIndex(2);
					this.ClickAdd();
					NewNativeRunTimeChecksDialog tempNewNativeRunTimeChecksDialog = new NewNativeRunTimeChecksDialog(this.Controls.ExceptionsTreeView.SelectedItem.Text);
					tempNewNativeRunTimeChecksDialog.Controls.FindTextBox.Text = name;
					tempNewNativeRunTimeChecksDialog.Controls.NumberTextBox.Text = number;
					tempNewNativeRunTimeChecksDialog.ClickOK();
					break;
				case ExceptionRuntimeType.Win32Exceptions:
					this.Controls.ExceptionsTreeView.SelectByIndex(3);
					this.ClickAdd();
					NewWin32ExceptionsDialog tempNewWin32ExceptionsDialog = new NewWin32ExceptionsDialog(this.Controls.ExceptionsTreeView.SelectedItem.Text);
					tempNewWin32ExceptionsDialog.Controls.FindTextBox.Text = name;
					tempNewWin32ExceptionsDialog.Controls.NumberTextBox.Text = number;
					tempNewWin32ExceptionsDialog.ClickOK();
					break;
				default : throw new  Exceptions.InvalidIndexException("Invalid EXCEPTION_RUNTIME_TYPE index.");

			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Delete is a simple method that will click the find dialog, enter in the name that is provided, then press the delete button
		/// 
		/// usgae:
		/// 
		/// my_exceptionsDialog.Delete("myexpt");
		///
		/// </summary>
		/// <param name="exception">name of new exception to delete</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Delete(string exception)
		{
			Find(exception);
			ClickDelete();
		}
    
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Find is a simple method that will find and exception based on the name provided.
		/// 
		/// usgae:
		/// 
		/// my_exceptionsDialog.Find("myexpt");
		///
		/// </summary>
		/// <param name="exception">name of new exception to find</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Find(string exception)
		{
			
			bool result = false;

			this.ClickFind();
			
			FindExceptionDialog findDialog  = new FindExceptionDialog(App);
			findDialog.Controls.FindTextBox.Text = exception;
			findDialog.ClickOK();
			
			 // if found do no action, if not found we have to dismiss a dialog
			try
			{
				Alert.HandleAlert(App.GetIntlStr(AnExceptionContainingTheSpecifiedStringWasNotFound), AlertAction.ClickYes,App.MainWindow, m_defaultTimeOut, true);
				result = true;
			}
			catch
			{
				
			}

			if(result)
			{
				throw new  Exceptions.NameNotFoundException("Exception not found");
			}
		}

		#endregion
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\NewNativeRunTimeChecksDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for NewNativeRunTimeChecks Dialog.
		
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface INewNativeRunTimeChecksDialogControls
	{  
		TextBox FindTextBox
		{
			get;
		}
    
		TextBox NumberTextBox
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls the ui of the excetions dialog sub Add new Native RunTime Checks dialog
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class NewNativeRunTimeChecksDialog : VsDialog, INewNativeRunTimeChecksDialogControls
	{
		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int FindTextBox = 1006;
        
			public const int NumberTextBox = 1007;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 1097;
		}

		private const string DialogTitle = ":New %1:Win32String:vsdebugui.dll:58";
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion

		#region Constructors

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New Native RunTime Checks Exception Dialog.
		///  </summary>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewNativeRunTimeChecksDialog(string exception) : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,GenerateCaption(Maui.VisualStudio.Everett.CoreManager.ActiveApp,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		/// Constructor for the Add New Native RunTime Checks Exception Dialog.
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewNativeRunTimeChecksDialog(IDEApp app, string exception) : base(app,GenerateCaption(app,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual INewNativeRunTimeChecksDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		#endregion
    
		#region Helper functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified expceptions add windows
		/// </summary>
		/// <param name="Exception">expceptions add window to get caption for</param>
		/// <param name="app">target application </param>
		/// <returns>expceptions add window caption</returns>
		/// <history>
		///			[bboris] 1/22/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, string ExceptionType) 
		{
			
			return app.GetIntlStr(DialogTitle).Replace("%1", ExceptionType);
		}

		#endregion
    
		#region Implementation of INewNativeRunTimeChecksDialogControls
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FindTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewNativeRunTimeChecksDialogControls.FindTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.FindTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the NumberTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewNativeRunTimeChecksDialogControls.NumberTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.NumberTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewNativeRunTimeChecksDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewNativeRunTimeChecksDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewNativeRunTimeChecksDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);
			}
		}
    
		#endregion
    
		#region Helper Functions for INewNativeRunTimeChecksDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Find
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string FindText
		{
			get
			{
				return Controls.FindTextBox.Text;
			}
			set
			{
				Controls.FindTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Number
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string NumberText
		{
			get
			{
				return Controls.NumberTextBox.Text;
			}
			set
			{
				Controls.NumberTextBox.Text = value;
			}
		}
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\NewCommonLanguageRuntimeExceptionsDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for NewCommonLanguageRuntimeExceptions Dialog.
		
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface INewCommonLanguageRuntimeExceptionsDialogControls
	{
		TextBox FindTextBox
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls the ui of the excetions dialog sub Add new Common Language Runtime Exceptions dialog
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class NewCommonLanguageRuntimeExceptionsDialog : VsDialog, INewCommonLanguageRuntimeExceptionsDialogControls
	{
    
		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int FindTextBox = 1006;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 1097;
		}

		private const string DialogTitle = ":New %1:Win32String:vsdebugui.dll:58";
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion

		#region Constructors

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New Common Language Runtime Exception Dialog.
		///  </summary>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewCommonLanguageRuntimeExceptionsDialog(string exception) : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,GenerateCaption(Maui.VisualStudio.Everett.CoreManager.ActiveApp,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New Common Language Runtime Exception Dialog.
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewCommonLanguageRuntimeExceptionsDialog(IDEApp app, string exception) : base(app,GenerateCaption(app,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual INewCommonLanguageRuntimeExceptionsDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		#endregion
	
		#region Helper functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified expceptions add windows
		/// </summary>
		/// <param name="Exception">expceptions add window to get caption for</param>
		/// <param name="app">target application </param>
		/// <returns>expceptions add window caption</returns>
		/// <history>
		///			[bboris] 1/22/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, string ExceptionType) 
		{
			
			return app.GetIntlStr(DialogTitle).Replace("%1", ExceptionType);
		}

		#endregion
    
		#region Implementation of INewCommonLanguageRuntimeExceptionsDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FindTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewCommonLanguageRuntimeExceptionsDialogControls.FindTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.FindTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCommonLanguageRuntimeExceptionsDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCommonLanguageRuntimeExceptionsDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCommonLanguageRuntimeExceptionsDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);
			}
		}
	
		#endregion
    
		#region Helper Functions for INewCommonLanguageRuntimeExceptionsDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Find
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string FindText
		{
			get
			{
				return Controls.FindTextBox.Text;
			}
			set
			{
				Controls.FindTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\HitCountDialog.cs ===
using System;
using Maui.Core;
using Maui.Core.WinControls;
using System.ComponentModel;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	/// <summary>
	/// Summary description for HitCountDialog.
	/// </summary>

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IHitCountDialogControls
	{
		EditComboBox WhenTheBreakpointIsHitEditComboBox {get;}
		TextBox HitCountIsTextBox {get;}
		StaticControl CurrentHitCountStaticControl {get;}
		Button ResetHitCountButton {get;}
		Button OKButton {get;}
		Button CancelButton {get;}
		Button HelpButton {get;}
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: Alert
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This Class implements the Breakpoint HitCount Dialog
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 11/5/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------

	public class HitCountDialog : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IHitCountDialogControls
	{
#region "Interface, Constants, Strings, and Control IDs"

		public class Strings
		{
			public const string Caption = "VSDebugUI.dll:5:4903:0";//"Breakpoint Hit Count";

		}

		public class ControlIDs
		{
			public const int whenTheBreakpointIsHitEditComboBox = 1077;
			public const int currentHitCountStaticControl = 4914;
			public const int hitCountIsTextBox = 4918;
			public const int resetHitCountButton = 1024;
			public const int OKButton = 1;
			public const int cancelButton = 2;
			public const int helpButton = 4921;
		}


#endregion

#region "Variables for Cached Controls"
		protected EditComboBox m_cachedWhenTheBreakpointIsHitEditComboBox;
		protected StaticControl m_cachedCurrentHitCountStaticControl;
		protected TextBox m_cachedHitCountIsTextBox;
		protected Button m_cachedResetHitCountButton;
		protected Button m_cachedOKButton;
		protected Button m_cachedCancelButton;
		protected Button m_cachedHelpButton;
		private const int m_defaultTimeOut = 10000;
#endregion

#region "Other private variables"
		private Maui.VisualStudio.Everett.IDEApp m_app;
#endregion
#region "Constructors"

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using the default application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public HitCountDialog() : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.Caption),  true)
		{
			Init(CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Makes sure the dialog is open using a given application
		/// </summary>
		/// <remarks></remarks>
		/// <history>[Dialog Maker Tool] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		public HitCountDialog(IDEApp app) : base(app, app.GetIntlStr(Strings.Caption), true)
		{
			Init(app);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// This function will attempt to find a showing instance of the dialog.
		/// </summary>
		/// <returns>The dialog's hWnd</returns>
		/// <remarks></remarks>)
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(IDEApp app)
		{
			//	// First look to see if the dialog is already showing
			//		int handle = FindWindow(Strings.Caption, 
			//			"#32770  /*strClass*/", 
			//			0, /*ControlID*/
			//			true, /*bVisibleOnly*/
			//			0, /*hwndStartWindow*/
			//			app.Process.Id,
			//
			//			false /*CaptionCaseSensitive*/, m_defaultTimeOut);
			//		if (handle != 0)
			//			return handle;
			//		else
			//		{
			//			// Dialog wasn't found, so throw an exception since it is supposed to be up
			//			throw new Maui.Exceptions.VisualStudio.Everett.BreakpointsExceptions.DialogNotFoundException("Breakpoint Hit Count dialog is not visible.");
			//
			//		}
			// set app
			m_app = app;

		}

#endregion

#region "Public Properties"
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the raw controls for this dialog
		/// </summary>
		/// <value>An interface that groups all of the dialog's control properties together</value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IHitCountDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button ResetHitCount
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickResetHitCount()
		{
			Controls.ResetHitCountButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button OK
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickOK()
		{
			Controls.OKButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Cancel
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickCancel()
		{
			Controls.CancelButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to click on button Help
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClickHelp()
		{
			Controls.HelpButton.Click();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control WhenTheBreakpointIsHitEditComboBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType WhenTheBreakpointIsHitEditComboBoxValue
		{
			get
			{
				switch(Controls.WhenTheBreakpointIsHitEditComboBox.SelectedIndex)
				{
					case 0:
						return Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType.Always;
					case 1:
						return Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType.Equal;
					case 2:
						return Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType.MultipleOf;
					case 3:
						return Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType.GreaterThanEqual;
					default:
						return Maui.VisualStudio.Everett.Debugger.BreakpointInfo.HitCountType.Always;
				}
			}

			set
			{
				Controls.WhenTheBreakpointIsHitEditComboBox.SelectByIndex(System.Convert.ToInt32(value));
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control HitCountIsTextBox
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string HitCountIsTextBoxText
		{
			get
			{
				return Controls.HitCountIsTextBox.Text;
			}

			set
			{
				Controls.HitCountIsTextBox.Text = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to get the text in control CurrentHitCountStaticControl
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string CurrentHitCountStaticControlText
		{
			get
			{
				return Controls.CurrentHitCountStaticControl.Text;
			}
		}

#endregion

#region "Control Implementations"

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the WhenTheBreakpointIsHitEditComboBox control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		EditComboBox IHitCountDialogControls.WhenTheBreakpointIsHitEditComboBox
		{
			get
			{
				if (m_cachedWhenTheBreakpointIsHitEditComboBox == null)
					m_cachedWhenTheBreakpointIsHitEditComboBox = new EditComboBox(this, ControlIDs.whenTheBreakpointIsHitEditComboBox);
				return m_cachedWhenTheBreakpointIsHitEditComboBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the CurrenthitcountStaticControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		StaticControl IHitCountDialogControls.CurrentHitCountStaticControl
		{
			get
			{
				if (m_cachedCurrentHitCountStaticControl == null)
					m_cachedCurrentHitCountStaticControl = new StaticControl(this, ControlIDs.currentHitCountStaticControl);

				return m_cachedCurrentHitCountStaticControl;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the 0StaticControl control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		TextBox IHitCountDialogControls.HitCountIsTextBox
		{
			get
			{
				if (m_cachedHitCountIsTextBox == null)
					m_cachedHitCountIsTextBox = new TextBox(this, ControlIDs.hitCountIsTextBox);

				return m_cachedHitCountIsTextBox;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the ResetHitCountButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IHitCountDialogControls.ResetHitCountButton
		{
			get
			{
				if (m_cachedResetHitCountButton == null)
					m_cachedResetHitCountButton = new Button(this, ControlIDs.resetHitCountButton);

				return m_cachedResetHitCountButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the OKButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IHitCountDialogControls.OKButton
		{
			get
			{
				if (m_cachedOKButton == null)
					m_cachedOKButton = new Button(this, ControlIDs.OKButton);

				return m_cachedOKButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the CancelButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IHitCountDialogControls.CancelButton
		{
			get
			{
				if (m_cachedCancelButton == null)
					m_cachedCancelButton = new Button(this, ControlIDs.cancelButton);

				return m_cachedCancelButton;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Exposes access to the HelpButton control
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/5/2002 - Created
		/// </history>
		///-----------------------------------------------------------------------------
		Button IHitCountDialogControls.HelpButton
		{
			get
			{
				if (m_cachedHelpButton == null)
					m_cachedHelpButton = new Button(this, ControlIDs.helpButton);

				return m_cachedHelpButton;
			}
		}


#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\FindExceptionDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for Find Exception Dialog.

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IFindExceptionDialogControls
	{
    
		TextBox FindTextBox
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls the ui of the excetions dialog sub Find dialog
	/// </summary>
	///  <history>
	///			[bboris] 1/30/2003 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class FindExceptionDialog : VsDialog, IFindExceptionDialogControls
	{
    
		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int FindTextBox = 4879;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 1099;
		}
		
		private const string DialogTitle = "VSDebugUI.dll:5:4131:0";
		
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion
	
		#region Constructors

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Find Exception Dialog.
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		///			[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public FindExceptionDialog() :  base(CoreManager.ActiveApp,CoreManager.ActiveApp.GetIntlStr(DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut); 
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Find Exception Dialog.
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <history>
		///			[bboris] 11/19/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public FindExceptionDialog(IDEApp app) :  base(app,app.GetIntlStr(DialogTitle),true)
		{
			this.WaitForResponse(DefaultTimeOut); 
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IFindExceptionDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		#endregion	

		#region Implementation of IFindExceptionDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FindTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox IFindExceptionDialogControls.FindTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.FindTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IFindExceptionDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IFindExceptionDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IFindExceptionDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);;
			}
		}
    
		
		#endregion

		#region Helper function for IFindExceptionDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Find
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string FindText
		{
			get
			{
				return Controls.FindTextBox.Text;
			}
			set
			{
				Controls.FindTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\NewCExceptionsDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for NewCExceptions Dialog.

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface INewCExceptionsDialogControls
	{
		TextBox FindTextBox
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls the ui of the excetions dialog sub Add new C++ Exceptions dialog
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class NewCExceptionsDialog : VsDialog, INewCExceptionsDialogControls
	 {
    
		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int FindTextBox = 1006;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 1097;
		}

		private const string DialogTitle = ":New %1:Win32String:vsdebugui.dll:58";
		
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion

		#region Constructors

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New C++ Exception Dialog.
		///  </summary>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewCExceptionsDialog(string exception) : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,GenerateCaption(Maui.VisualStudio.Everett.CoreManager.ActiveApp,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New C++ Exception Dialog.
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewCExceptionsDialog(IDEApp app, string exception) : base(app,GenerateCaption(app,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual INewCExceptionsDialogControls Controls
		{
			get
			{
				return this;
			}
		}
    
		#endregion
   
		#region Helper functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified expceptions add windows
		/// </summary>
		/// <param name="Exception">expceptions add window to get caption for</param>
		/// <param name="app">target application </param>
		/// <returns>expceptions add window caption</returns>
		/// <history>
		///			[bboris] 1/22/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, string ExceptionType) 
		{
			
			return app.GetIntlStr(DialogTitle).Replace("%1", ExceptionType);
		}
    
		#endregion

		#region Implementation of INewCExceptionsDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FindTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewCExceptionsDialogControls.FindTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.FindTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCExceptionsDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCExceptionsDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewCExceptionsDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);
			}
		}
		
		#endregion
    
		#region Helper Functions for INewCExceptionsDialogControls

		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Find
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string FindText
		{
			get
			{
				return Controls.FindTextBox.Text;
			}
			set
			{
				Controls.FindTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\NewWin32ExceptionsDialog.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Dialogs;
using Maui.Core.WinControls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{

	#region Interfaces for NewWin32Exceptions Dialog.
		
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface INewWin32ExceptionsDialogControls
	{
		TextBox FindTextBox
		{
			get;
		}
    
		TextBox NumberTextBox
		{
			get;
		}
    
		Button OKButton
		{
			get;
		}
    
		Button CancelButton
		{
			get;
		}
    
		Button HelpButton
		{
			get;
		}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls the ui of the excetions dialog sub Add new Win32 Exceptions dialog
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class NewWin32ExceptionsDialog : VsDialog, INewWin32ExceptionsDialogControls
	{
		#region Constant(control ID/command), private members

		public class ControlIDs
		{
			public const int FindTextBox = 1006;
        
			public const int NumberTextBox = 1007;
        
			public const int OKButton = 1;
        
			public const int CancelButton = 2;
        
			public const int HelpButton = 1097;
		}

		private const string DialogTitle = ":New %1:Win32String:vsdebugui.dll:58";
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion

		#region Constructors
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New Win32 Exception Dialog.
		///  </summary>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewWin32ExceptionsDialog(string exception) : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,GenerateCaption(Maui.VisualStudio.Everett.CoreManager.ActiveApp,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Add New Win32 Exception Dialog.
		///  </summary>
		///  <param name="app">Application to open window for</param>
		///  <param name="exception">expceptions add window to get caption for</param>
		///  <history>
		///			[bboris] 1/22/2002 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public NewWin32ExceptionsDialog(IDEApp app, string exception) : base(app,GenerateCaption(app,exception),true)
		{
			this.WaitForResponse(DefaultTimeOut);
		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <history>
		///			[bboris] 11/19/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this dialog
		///  </summary>
		///  <value>An interface that groups all of the dialog's control properties together</value>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual INewWin32ExceptionsDialogControls Controls
		{
			get
			{
				return this;
			}
		}
    
		#endregion
		
		#region Helper functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified expceptions add windows
		/// </summary>
		/// <param name="Exception">expceptions add window to get caption for</param>
		/// <param name="app">target application </param>
		/// <returns>expceptions add window caption</returns>
		/// <history>
		///			[bboris] 1/22/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, string ExceptionType) 
		{
			
			return app.GetIntlStr(DialogTitle).Replace("%1", ExceptionType);
		}

		#endregion

		#region Implementation of INewWin32ExceptionsDialogControls
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the FindTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewWin32ExceptionsDialogControls.FindTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.FindTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the NumberTextBox control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		TextBox INewWin32ExceptionsDialogControls.NumberTextBox
		{
			get
			{
				return new TextBox(this, ControlIDs.NumberTextBox);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the OKButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewWin32ExceptionsDialogControls.OKButton
		{
			get
			{
				return new Button(this, ControlIDs.OKButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the CancelButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewWin32ExceptionsDialogControls.CancelButton
		{
			get
			{
				return new Button(this, ControlIDs.CancelButton);
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the HelpButton control
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button INewWin32ExceptionsDialogControls.HelpButton
		{
			get
			{
				return new Button(this, ControlIDs.HelpButton);
			}
		}
    
		#endregion

		#region Helper Functions for INewWin32ExceptionsDialogControls	
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Find
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string FindText
		{
			get
			{
				return Controls.FindTextBox.Text;
			}
			set
			{
				Controls.FindTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to set/get the text in control Number
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual string NumberText
		{
			get
			{
				return Controls.NumberTextBox.Text;
			}
			set
			{
				Controls.NumberTextBox.Text = value;
			}
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button OK
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickOK()
		{
			Controls.OKButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Cancel
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickCancel()
		{
			Controls.CancelButton.Click();
			this.WaitForInvalid(DefaultTimeOut);
		}
    
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Help
		///  </summary>
		///  <history>
		///			[bboris] 1/17/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickHelp()
		{
			Controls.HelpButton.Click();
			this.WaitForResponse(DefaultTimeOut);
		}
    
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\Quickwatch.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger.Controls;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	#region Interfaces for QuickWatch 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IQuickWatchControls
	{
		Maui.Core.WinControls.Button RecalculateButton
		{
			get;
		}

		Maui.Core.WinControls.Button AddWatchButton
		{
			get;
		}
		Maui.Core.WinControls.Button CloseButton
		{
			get;
		}
		Maui.Core.WinControls.Button HelpButton
		{
			get;
		}
		Maui.Core.WinControls.EditComboBox ExpressionComboBox
		{
			get;
		}
		Controls.VariableTreeGrid CurrentValueTreeGrid 
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IQuickWatchVerify
	{
		bool FirstRow(string expression, string variableValue, string type, RowExpandState state);
		bool AllRows(string expression, string[,] values);
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Quickwatch
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you use the dialog you get when you execute the
	///   "Debug.QuickWatch" command.
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 9/30/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class QuickWatch : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog, IQuickWatchControls, IQuickWatchVerify
	{
		#region member variables
		private const string DialogTitle = "VSDebugUI.dll:5:105:0"; 

		private const int RecalculateButtonID = 0x1358;
		private const int AddWatchButtonID = 0x1356;
		private const int CloseButtonID = 0x2;
		private const int HelpButtonID = 0x9;
		private const int ExpressionComboBoxID = 0x1357;
		private const int CurrentValueTreeGridID = 0x0;

		private const string GridColumnName = "VSDebugUI.dll:6:5:5";
		private const string GridColumnValue = "VSDebugUI.dll:6:5:6";
		private const string GridColumnType = "VSDebugUI.dll:6:5:7";

		private int m_defaultTimeOut = 10000; // milliseconds. 
		#endregion

		#region Constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in Active app.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatch() : base(Maui.VisualStudio.Everett.CoreManager.ActiveApp,Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(DialogTitle),Constants.Commands.ViewDebugWindowsQuickWatch,false)
		{
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in the specified app.  Opens it if not found
		/// </summary>
		/// <param name="application">Running instance of VS</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatch(IDEApp application) : base(application,application.GetIntlStr(DialogTitle),Constants.Commands.ViewDebugWindowsQuickWatch,false)
		{
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in the specified app.  indicate whehter the dlg is already open or not. 
		/// </summary>
		/// <param name="application">Running instance of VS</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatch(IDEApp application, bool isAlreadyOpen) : base(application,application.GetIntlStr(DialogTitle),Constants.Commands.ViewDebugWindowsQuickWatch,isAlreadyOpen)
		{
		}
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// IQuickWatchVerify interface  
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	11/11/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IQuickWatchVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return IQuickWatchControls. 
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	11/8/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IQuickWatchControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default time out value set. 
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	11/8/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return QuickWatchVariable object
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	11/8/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatchRows Rows
		{
			get
			{
				return new QuickWatchRows(this.Controls.CurrentValueTreeGrid);
			}
		}
		#endregion

		#region IQuickWatchControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return RecaluateButton object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IQuickWatchControls.RecalculateButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,RecalculateButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AddWatchButton object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IQuickWatchControls.AddWatchButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,AddWatchButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return CloseButton object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IQuickWatchControls.CloseButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,CloseButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return HelpButton object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IQuickWatchControls.HelpButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,HelpButtonID);				
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ExpressionComboBox object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.EditComboBox IQuickWatchControls.ExpressionComboBox
		{
			get
			{
				return new Maui.Core.WinControls.EditComboBox(this,ExpressionComboBoxID);				
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return CurrentValueTreeGrid object.
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		Controls.VariableTreeGrid IQuickWatchControls.CurrentValueTreeGrid 
		{
			get
			{
				return new Maui.VisualStudio.Everett.Debugger.Controls.VariableTreeGrid(this);			
			}
		}
		#endregion

		#region IQuickWatchVerify implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Evaluate the expression and verify the result with the first row.  
		/// </summary>
		/// <param name="expression">Expression to evaluate</param>
		/// <param name="variableValue">Expected value</param>
		/// <param name="type">Expected type</param>
		/// <param name="state">Expected state : Expanded/Collapsed/NonExpandable</param>
		/// <returns>it returns boolean value: if everything is matched, "true", otherwise, "false"</returns>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IQuickWatchVerify.FirstRow(string expression, string variableValue, string type, RowExpandState state)
		{
			bool returnValue = false;
			try
			{
				// Set expression value and calculate it.
				CalculateVariable(expression);
				
				// ToDo: compare the value. 
				returnValue = this.Rows[0].Verify(expression,variableValue,type,state);
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling VerifyQuickWatchInfo()"); 
			}
			finally
			{
				// Close dialog
				this.Controls.CloseButton.Click();
				// wait for the idle of main window after closing this dialog. 
				this.App.MainWindow.WaitForResponse(this.DefaultTimeOut);
			}

			return returnValue;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Evaluate the expression and verify the reuslt with the all rows.  
		/// </summary>
		/// <param name="expression">Expression to evaluate</param>
		/// <param name="expected">Expected values in all rows</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IQuickWatchVerify.AllRows(string expression, string[,] expected)
		{
			bool bReturn = false;
			RowExpandState expandState;

			try
			{
				// Set expression value and calculate it.
				CalculateVariable(expression);

				for( int i=0; i < this.Controls.CurrentValueTreeGrid.RowCount; i++ )
				{
					expandState = this.Controls.CurrentValueTreeGrid[i].GetExpandStateFromText(expected[i, 0]);

					bReturn = this.Rows[i].Verify(expected[i,1], expected[i,2], expected[i,3],expandState);
					if(!bReturn)
					{
						break; // there is mismatched thing. 
					}
				}
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling VerifyQuickWatchInfo()"); 
			}
			finally
			{
				// Close dialog
				this.Controls.CloseButton.Click();
				// wait for the idle of main window after closing this dialog. 
				this.App.MainWindow.WaitForResponse(this.DefaultTimeOut);
			}

			return bReturn;
		}
		#endregion

		#region member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Evaluate the expression. 
		/// </summary>
		/// <param name="expression">Expression to evaluate</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void CalculateVariable(string expression)
		{
			try
			{
				// set the value into expression combo box. 
				this.Controls.ExpressionComboBox.Text = expression;
				// recalculate it
				this.Controls.RecalculateButton.Click();
				// wait for calculation is done(wait for target idle)
				this.WaitForResponse(this.DefaultTimeOut); 
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling CalculateValue()"); 
			}
		}
		#endregion

	}

	
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: QuickWatchRows
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// this is the collection of QuickWatchRow objects. 
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 11/8/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class QuickWatchRows : Maui.Core.RemotingObject
	{
		#region private member
		private Controls.VariableTreeGrid m_treeGrid;
		#endregion

		#region Constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for QuickWatchRows collection  
		/// </summary>
		/// <param name="treeGrid">treeGrid : DebuggerTreegrid object</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatchRows(Controls.VariableTreeGrid treeGrid)
		{
			m_treeGrid = treeGrid;
		}
		#endregion

		#region indexer
		///-----------------------------------------------------------------------------
		/// <summary>
		/// indexer to get QuickWatchRow object based on index  
		/// </summary>
		/// <param name="index">index in integer(1 based)</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatchRow this[int index]
		{
			get
			{
				string[] columns;
				RowExpandState state;
				columns = m_treeGrid.GetRow(index);
				state = m_treeGrid.GetExpandState(index);

				return new QuickWatchRow(index,columns,state);
			}
		}
		#endregion
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: QuickWatchRow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// this is object to handle values. it is presenting the row in Quickwatch tree grid. 
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 11/8/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class QuickWatchRow : Maui.Core.RemotingObject
	{
		#region private member variables
		private int m_index;
		private RowExpandState m_state;
		private string m_name;
		private string m_value;
		private string m_type;
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for QuickWatchRow  
		/// </summary>
		/// <param name="index">index</param>
		/// <param name="columns">columns in string[]</param>
		/// <param name="state">state of value</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public QuickWatchRow(int index,string[] columns, RowExpandState state)
		{
			m_index = index;
			m_name = columns[1]; // Name
			m_value = columns[2]; // value
			m_type = columns[3];  // type
			m_state = state;
		}
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property of Name
		/// return m_name
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Name
		{
			get
			{
				return m_name;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property of Value
		/// return m_value
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Value
		{
			get
			{
				return m_value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property of Type
		/// return m_type
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Type
		{
			get
			{
				return m_type;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property of RowExpandState
		/// return m_state
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RowExpandState State
		{
			get
			{
				return m_state;
			}
		}
		#endregion

		#region Member functions
		/// <summary>
		/// Verify current row
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 11/8/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Verify(string name, string variableValue, string type, RowExpandState state)
		{
			bool returnValue = false;

			if(name == Name && variableValue == Value && type == Type && state == State)
			{
				returnValue = true;
			}
			else
			{
				Maui.TestLog.LogManager.WriteEntry(Maui.TestLog.EntryType.Verbose, Name.ToString() + Value.ToString() + Type.ToString() + State.ToString());
			}

			return returnValue;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\SQLDebugAttachDialog.cs ===
//*********************************************************
// Owner : JohnBain
// Class name : SQLDebugAttachDialog
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	/// <summary>
	/// Summary description for SQLDebugAttachDialog.
	/// </summary>
	public class SQLDebugAttachDialog
	{
		public SQLDebugAttachDialog(IDEApp application)
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\BreakpointNode.cs ===
using System;
using Maui;
using Maui.VisualStudio.Everett.Ide.Editors;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: BreakpointNode
	///
	/// Copyright (C) 2003, Microsoft Corporation
	///-----------------------------------------------------------------------------
	public class BreakpointNode : Core.WinControls.TreeNode
	{
		private BreakpointWindow m_parent;

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new Breakpoint node
		/// </summary>
		/// <param name="parent">BreakpointWindow object that the node belongs to</param>
		/// <param name="index">Index of the node in the treeview</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointNode(BreakpointWindow parent, int index) : base(parent.Controls.BreakpointTreeView, index)
		{ 
			m_parent = parent;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the BreakpointWindow that this node belongs too
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointWindow Parent
		{
			get
			{
				return m_parent;
			}
		}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the editor containing the code the BP is set at.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BaseEditor GotoSourceCode()
		{
			this.Select();
			this.Parent.App.RaiseCmd(Constants.Commands.BreakpointWindowGoToSourceCode);
			this.Parent.WaitForResponse();

			return new BaseEditor(m_parent.App);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the Disassembly window at the location of the BP
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Disassembly GotoDisassembly()
		{
			this.Select();
			this.Parent.App.RaiseCmd(Constants.Commands.BreakpointWindowGoToDisassembly);
			this.Parent.WaitForResponse();

			return new Disassembly(m_parent.App);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes the breakpoint
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Delete()
		{
			int nodeCount = m_parent.Controls.BreakpointTreeView.get_Count(false);

			this.Select();
			this.Parent.App.RaiseCmd(Constants.Commands.BreakpointWindowDelete);
			this.Parent.WaitForResponse();

			if( m_parent.Controls.BreakpointTreeView.get_Count(false) == nodeCount )
				throw new BreakPoints.Exceptions.BreakpointWindowException("Delete breakpoint failed.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the breakpoint
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Disable()
		{
			if( !this.Checked )
				throw new BreakPoints.Exceptions.BreakpointWindowException("Tried to disable already disabled breakpoint");
			else
			{
				this.Checked = false;
				this.Parent.WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Enables the breakpoint
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Enable()
		{
			if( this.Checked )
				throw new BreakPoints.Exceptions.BreakpointWindowException("Tried to enable already enabled breakpoint");
			else
			{
				this.Checked = true;
				this.Parent.WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the BP properties for the breakpoint and returns instance of the 
		/// BP Properties Window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Dialogs.BreakPointPropertiesDialog OpenBreakpointPropertiesDialog()
		{
			this.Select();
			this.Parent.App.RaiseCmd(Constants.Commands.BreakpointWindowProperties);
			this.Parent.WaitForResponse();

			return new Dialogs.BreakPointPropertiesDialog(this.Parent.App);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Name column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Name 
		{
			get
			{
				return this.Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Condition column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Condition 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the HitCount column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string HitCount 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[0].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Language column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Language 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[1].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the FunctionName column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FunctionName 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[2].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the File column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string File 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[3].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Address column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Address 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[4].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Data column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Data 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[5].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Program column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Program 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[6].Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the text of the Constraints column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Constraints 
		{
			get
			{
				return this.Parent.Controls.BreakpointListView.Items[this.Index].SubItems[7].Text;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\Dialogs\RemoteDebugging.cs ===
//*********************************************************
// Owner : Yigingdu
// Class name : RemoteDebugging
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.Dialogs
{
	/// <summary>
	/// Summary description for RemoteDebugging.
	/// </summary>
	public class RemoteDebugging : Maui.VisualStudio.Everett.Ide.Dialogs.VsDialog
	{
		#region member variables
		private const string DialogTitle = "Remote Debugging"; 
		private const string Command = "Debug.Remote";

		#endregion

		#region constructors
		public RemoteDebugging(IDEApp application) : base(application,application.GetIntlStr(DialogTitle),Command,false)
		{
			
		}

		public RemoteDebugging(IDEApp application, bool IsAlreadyOpen) : base(application,application.GetIntlStr(DialogTitle),Command,IsAlreadyOpen)
		{
			
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\AttachedProcessesWindow.cs ===
//*********************************************************
// Owner : Yigingdu
// Class name : AttachedProcessesWindow
// Description: 
//*********************************************************
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	#region Interfaces for AttachedProcessesWindow 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAttachedProcessesWindowControls
	{
		Maui.Core.WinControls.ListView AttachedProcessesWindowListView
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAttachedProcessesWindowVerify
	{
		bool Process(string processName);
		bool Process(string procesName, string processID, string path, string title, string machine, string state, string transport, string transportQualifier);
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: AttachedProcessesWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you manipulate the processes that are being debugged:
	/// break, detach, terminate, set breakpoint, etc.
	/// </summary>
	/// <history>
	///		[yiqingdu] 10/31/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class AttachedProcessesWindow : Everett.Ide.ToolWindows.ToolWindow, IAttachedProcessesWindowControls, IAttachedProcessesWindowVerify
	{
		
		#region member variables
		//strings
		private const string Title = ";Attached Processes;Win32String;VSDebugUI.dll;651"; 

		//controls
		private const int AttachedProcessesWindowListViewID = 0x1;

		//other private variables
		private int m_defaultTimeOut = 10000; // milliseconds. 

		//constants to denote Debuggered Processes list items
		private struct AttachedProcessesListItem
		{
			public const int Name = 0;
			public const int ID = 1;
			public const int Path = 2;
			public const int Title = 3;
			public const int Machine = 4;
			public const int State = 5;
			public const int Transport = 6;
			public const int TransportQualifier = 7;
		}

		//context menu items
		private const string SelectAllMenu = ";Select &All;CTMenuString;cmddefui.dll;1000d1684892995d{5EFC7975-14BC-11CF-9B2B-00AA00573819}:2:m;31";
		private const string ProcessesMenu = ";&Processes...;CTMenuString;VSDebugUI.dll;1000d1684892995d{5EFC7975-14BC-11CF-9B2B-00AA00573819}:5:m;213";
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IAttachedProcessesWindowControls interface. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IAttachedProcessesWindowControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return Conext Menu. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.Core.WinControls.Menu ContextMenu
		{
			get
			{
				return new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify return IAttachedProcessesWindowControls interface. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IAttachedProcessesWindowVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return default timeout. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ProcessesList object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ProcessesList ProcessesList
		{
			get
			{
				return new ProcessesList(this, this.Controls.AttachedProcessesWindowListView);
			}
		}
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open AttachedProcessesWindow window with default application. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachedProcessesWindow() : base(CoreManager.ActiveApp, Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(Title), Constants.Commands.ViewDebugWindowsProcesses)
		{
			RealConstrutor(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open AttachedProcessesWindow window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.VisualStudio.Everett.IDEApp</param>
		/// <history>
		///		[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AttachedProcessesWindow(Maui.VisualStudio.Everett.IDEApp application) : base(application, Maui.VisualStudio.Everett.CoreManager.ActiveApp.GetIntlStr(Title), Constants.Commands.ViewDebugWindowsProcesses)
		{
			RealConstrutor(application);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <history>
		///		[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void RealConstrutor(Maui.VisualStudio.Everett.IDEApp application)
		{
			Maui.Core.Window window = null;

			// get the window object with caption. 
			window = new Maui.Core.Window(application.GetIntlStr(Title), StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch, application,DefaultTimeOut);
			if(window == null)
			{
				throw new Maui.GlobalExceptions.MauiException("Running Doc window doesn't come up");
			}
			else
			{
				// set focus on window. 
				window.Extended.SetFocus();
			}
		}
		#endregion

		#region IAttachedProcessesWindowControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return AttachedProcessesWindowListView object. 
		/// </summary>
		/// <history>
		///		[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ListView IAttachedProcessesWindowControls.AttachedProcessesWindowListView
		{
			get
			{
				return new Maui.Core.WinControls.ListView(this, AttachedProcessesWindowListViewID);
			}
		}
		#endregion

		#region IAttachedProcessesWindowVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check to see if Attached Processes list contains the specified process in the list
		/// </summary>
		/// <param name="processName">Process Name</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IAttachedProcessesWindowVerify.Process(string processName)
		{
			try
			{
				if (this.Controls.AttachedProcessesWindowListView.FindAllByText(processName, false)!= null)
					return true;

				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling Verify.Process()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check to see if Attached Processes list contains the specified process in the list
		/// </summary>
		///<param name="procesName">Process Name</param>
		///<param name="processID">Process ID</param>
		///<param name="path">Path to the process</param>
		///<param name="title">Title of the process</param>
		///<param name="machine">Machine name</param>
		///<param name="state">Process state</param>
		///<param name="transport">Transport type</param>
		///<param name="transportQualifier">Transport qualifier</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IAttachedProcessesWindowVerify.Process(string processName, string processID, string path, string title, string machine, string state, string transport, string transportQualifier)
		{
			try
			{
				foreach (Maui.Core.WinControls.ListViewItem item in this.Controls.AttachedProcessesWindowListView.Items)
					if (IsProcessMatch(item, processName, processID, title, machine, state, transport, transportQualifier))
						return true;				
		
				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling Verify.Process()"); 
			}

		}
		#endregion

		#region member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Select All".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SelectAll()
		{
			this.ContextMenu[this.App.GetIntlStr(SelectAllMenu)].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Processes...".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Processes()
		{
			this.ContextMenu[this.App.GetIntlStr(ProcessesMenu)].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify if a selected process matches input criteria
		/// </summary>
		/// <param name="processID"> Process ID </param>
		/// <param name="machine"> Machine name</param>
		/// <param name="portType"> Transport type</param>
		/// <param name="processName"> Process name</param>
		/// <param name="title"> Process title</param>
		/// <param name="type"> Process type: Win32, .NET, Script ...</param>
		/// <returns>If matched debugee is found, return true; otherwise, return false.</returns>
		/// <history>
		/// 	[yiqingdu] 	02/17/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		private bool IsProcessMatch(Maui.Core.WinControls.ListViewItem item, string processName, string processID, string title, string machine, string state, string transport, string transportQualifier)
		{
			try
			{
				if((processName != null) && (item[AttachedProcessesListItem.Name].Text.ToLower() != processName.ToLower()))
					return false;
				if((processID != null) && (item[AttachedProcessesListItem.ID].Text.ToLower() != processID.ToLower()))
					return false;
				if((title != null) && (item[AttachedProcessesListItem.Title].Text.ToLower() != title.ToLower()))
					return false;
				if((machine != null) && (item[AttachedProcessesListItem.Machine].Text.ToLower() != machine.ToLower()))
					return false;
				if((state != null) && (item[AttachedProcessesListItem.State].Text.ToLower() != state.ToLower()))
					return false;
				if((transport != null) && (item[AttachedProcessesListItem.Transport].Text.ToLower() != transport.ToLower()))
					return false;
				if((transportQualifier != null) && (item[AttachedProcessesListItem.TransportQualifier].Text.ToLower() != transportQualifier.ToLower()))
					return false;

				return true;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling AttachedProcessesWindow.IsProcessMatch()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Select a process from a processes list view.
		/// </summary>
		/// <param name="listView"> Processes list view</param>
		/// <param name="processName"> Process name</param>
		/// <returns>If the process is found, return true; otherwise, return false.</returns>
		/// <history>
		/// 	[yiqingdu] 	02/17/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		private bool SelectProcess(Maui.Core.WinControls.ListView listView, string processName)
		{
			try
			{
				foreach (Maui.Core.WinControls.ListViewItem item in listView.Items)
				{
					if (item.Text.ToLower().StartsWith(processName.ToLower()))
					{
						item.Select();
						this.Controls.AttachedProcessesWindowListView.WaitForResponse();
						return true;
					}
				}
				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling AttachedProcessesWindow.SelectProcess()"); 
			}
		}

		#endregion
	}

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: ProcessesList
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// this is the collection of Process objects. 
	/// </summary>
	/// <history>
	///		[yiqingdu] 02/17/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class ProcessesList : Maui.Core.RemotingObject
	{
		#region member variables
		private Maui.Core.WinControls.ListView m_listView;
		private AttachedProcessesWindow m_attachedProcessesWindowParent;
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for ProcessesList collection  
		/// </summary>
		/// <param name="listView">Processes ListView</param>
		/// <param name="attachedProcessesWindowParent">Parent AttachedProcessWindow</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ProcessesList(AttachedProcessesWindow attachedProcessesWindowParent, Maui.Core.WinControls.ListView listView)
		{
			m_listView = listView;
			m_attachedProcessesWindowParent = attachedProcessesWindowParent;
		}
		#endregion

		#region indexer
		///-----------------------------------------------------------------------------
		/// <summary>
		/// indexer to get Process object based on index  
		/// </summary>
		/// <param name="index">index in integer(1 based)</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Process this[int index]
		{
			get
			{
				return new Process(m_attachedProcessesWindowParent, index, m_listView[index]);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// indexer to get Process object based on index  
		/// </summary>
		/// <param name="processName">Process name</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Process this[string processName]
		{
			get
			{
				return new Process(m_attachedProcessesWindowParent, m_listView[processName].Index, m_listView[processName, false]);
			}
		}
		#endregion
	}


	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Process
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This object represents the processes list in AttachedProcessListView. 
	/// </summary>
	/// <history>
	///		[yiqingdu] 02/17/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Process : Maui.Core.RemotingObject
	{
		#region Exceptions
		public class Exceptions
		{
			[Serializable]
				public class ContextMenuItemNotEnabled : MauiException
			{
				public ContextMenuItemNotEnabled(string message) : base(message) {}

				protected ContextMenuItemNotEnabled(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region member variables
		private int m_index;
		private string m_name;
		private string m_id;
		private string m_path;
		private string m_title;
		private string m_machine;
		private string m_state;
		private string m_transport;
		private string m_transportQualifier;
		private AttachedProcessesWindow m_attachedProcessesWindowParent;

		//context menu items
		private const string CopyMenu = ";&Copy;CTMenuString;cmddefui.dll;1000;1684892995;{5EFC7975-14BC-11CF-9B2B-00AA00573819}:2:m;15";
		private const string StartProcessMenu = ";&Start Process;CTMenuString;VSDebugUI.dll;1000;1684892995;{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2:m;40961";
		private const string BreakProcessMenu = ";&Break Process;CTMenuString;VSDebugUI.dll;1000;1684892995;{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2:m;40962";
		private const string DetachProcessMenu = ";&Detach Process;CTMenuString;VSDebugUI.dll;1000;1684892995;{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2:m;40963";
		private const string TerminateProcessMenu = ";&Terminate Process;CTMenuString;VSDebugUI.dll;1000;1684892995;{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2:m;40964";
		private const string InsertBreakpointMenu = ";Insert B&reakpoint;CTMenuString;VSDebugUI.dll;1000;1684892995;{5EFC7975-14BC-11CF-9B2B-00AA00573819}:5:m;375";
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for Process collection  
		/// </summary>
		/// <param name="attachedProcessesWindowParent">Parent AttachedProcessWindow</param>
		/// <param name="listView">Processes ListView</param>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Process(AttachedProcessesWindow attachedProcessesWindowParent, int index, Maui.Core.WinControls.ListViewItem item)
		{
			m_index = index;
			m_name = item.Text;
			m_id = item[0].Text;
			m_path = item[1].Text;
			m_title = item[2].Text;
			m_machine = item[3].Text;
			m_state = item[4].Text;
			m_transport = item[5].Text;
			m_transportQualifier = item[6].Text;
			m_attachedProcessesWindowParent = attachedProcessesWindowParent;
		}
		#endregion

		#region methods
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Copy".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Copy()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(CopyMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Copy menu is not enabled.");
		}
 
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Start Process".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void StartProcess()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(StartProcessMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Start Process menu is not enabled.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Break Process".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void BreakProcess()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(BreakProcessMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Break Process menu is not enabled.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Detach Process".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DetachProcess()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(DetachProcessMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Break Process menu is not enabled.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Terminate Process".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void TerminateProcess()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(TerminateProcessMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Terminate Process menu is not enabled.");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu "Insert Breakpoint".
		/// </summary>
		/// <history>
		///		[yiqingdu] 02/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void InsertBreakpoint()
		{
			Maui.Core.WinControls.MenuItem item = m_attachedProcessesWindowParent.ContextMenu[m_attachedProcessesWindowParent.App.GetIntlStr(InsertBreakpointMenu)];
			if(item.Enabled)
			{
				item.Execute();
				m_attachedProcessesWindowParent.WaitForResponse();
			}
			else
				throw new Exceptions.ContextMenuItemNotEnabled("Insert Breakpoint menu is not enabled.");
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\AutosWindow.cs ===
using System;
using Maui.VisualStudio.Everett;
using Maui.Core;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: AutosWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Automation class for the Debugger Autos toolwindow.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class AutosWindow : VariableWindow
	{
#region Constants

		protected class Strings
		{
			public const string WindowCaption = "VSDebugUI.dll:6:6:2";
		}

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show the Autos window for the passed-in app
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AutosWindow() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsAutos, CoreManager.ActiveApp.GetIntlStr(Strings.WindowCaption))
		{
			this.WaitForResponse(); 
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show the Autos window for the passed-in app
		/// </summary>
		/// <param name="app">Application to show the window for</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public AutosWindow(IDEApp app) : base(app, Constants.Commands.ViewDebugWindowsAutos, app.GetIntlStr(Strings.WindowCaption))
		{ 
			this.WaitForResponse(); 
		}

#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\DebuggerToolWindow.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger.Controls;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: DebuggerToolWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------

	#region Controls and Verification Interfaces
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDebuggerToolWindowControls
	{
		DebuggerToolTreeGrid DebuggerToolWindowTreeGrid { get; }
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDebuggerToolWindowVerification
	{
		bool VerifyAll(string[] expected); // just verifies the values of the first column (i.e Name or ID column)
		bool VerifyAll(string[][] expected);
		bool VerifyAll(string[][] expected, bool caseSensitive, bool matchWholeString);
	}

#endregion

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Base class for specific Debugger Windows - CallStack, Threads, Modules.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[mkoller]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public abstract class DebuggerToolWindow : Everett.Ide.ToolWindows.ToolWindow, IDebuggerToolWindowControls, IDebuggerToolWindowVerification
	{

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new DebuggerToolWindow
		/// </summary>
		/// <param name="cmd">DTE Command to raise to open the window</param>
		/// <param name="caption">Expected Caption of opened window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolWindow(string cmd, string caption) : base(CoreManager.ActiveApp, caption, cmd)
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new DebuggerToolWindow
		/// </summary>
		/// <param name="app">App to create instance in</param>
		/// <param name="cmd">DTE Command to raise to open the window</param>
		/// <param name="caption">Expected Caption of opened window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolWindow(IDEApp app, string cmd, string caption) : base(app, caption, cmd)
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Container for controls inside the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDebuggerToolWindowControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verification methods
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDebuggerToolWindowVerification Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the TreeGrid control in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		DebuggerToolTreeGrid IDebuggerToolWindowControls.DebuggerToolWindowTreeGrid
		{
			get
			{
				return new DebuggerToolTreeGrid(this);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the Row specified by the index
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow this[int index]
		{
			get
			{
				return this.Controls.DebuggerToolWindowTreeGrid[index];
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the VariableRow specified by the text
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public DebuggerToolRow this[string name]
		{
			get
			{
				return this.Controls.DebuggerToolWindowTreeGrid[name];
			}
		}

		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the count of rows in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int RowCount
		{
			get
			{
				return this.Controls.DebuggerToolWindowTreeGrid.RowCount;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies all rows in the window against the given array of values
		/// </summary>
		/// <param name="expected">1D array of expected values for the first column</param>
		/// <returns>true if all info matches expected</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolWindowVerification.VerifyAll(string[] expectedName)
		{
			string[][] expected = new string[1][];
			expected[0] = expectedName;
			return this.Verify.VerifyAll(expected, true, true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies all rows in the window against the given array of values
		/// </summary>
		/// <param name="expected">2D array of expected rows values</param>
		/// <returns>true if all info matches expected</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolWindowVerification.VerifyAll(string[][] expected)
		{
			return this.Verify.VerifyAll(expected, true, true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies all rows in the window against the given array of values
		/// </summary>
		/// <param name="expected">2D array of expected rows values</param>
		/// <param name="caseSensitive">performs a case-sensitive compare</param>
		/// <param name="matchWholeString">only passes if entire string mathces</param>
		/// <returns>true if all info matches expected</returns>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IDebuggerToolWindowVerification.VerifyAll(string[][] expected, bool caseSensitive, bool matchWholeString)
		{
			bool verified = true;

			for( int i=0; i<this.Controls.DebuggerToolWindowTreeGrid.RowCount; i++ )
			{
				if( !this.Controls.DebuggerToolWindowTreeGrid[i].Verify.Verify(expected[i], caseSensitive, matchWholeString) )
					verified = false;
			}

			return verified;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\BreakpointWindow.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger.Controls;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: BreakpointWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------

#region Control Interfaces
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IBreakpointWindowControls
	{
		Core.WinControls.TreeView BreakpointTreeView { get; }
		Core.WinControls.ListView BreakpointListView { get; }
	}

#endregion

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Automation class for the Breakpoints toolwindow
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	1/16/2003	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class BreakpointWindow : Everett.Ide.ToolWindows.ToolWindow, IBreakpointWindowControls
	{
#region Constants

		protected class Strings
		{
			public const string WindowCaption = "VSDebugUI.dll:6:6:4";
			public const string ClearAllAlertText = ";Do you want to clear all breakpoints?;Win32String;VSDebugUI.dll;225";

			// Text in the language column 
			// TODO: can't find a few
			public const string BPLanguageBasic = "VSDebugUI.dll:6:7:13";
			public const string BPLanguageC = "";
			public const string BPLanguageCSharp = "";
			public const string BPLanguageCxx = "VSDebugUI.dll:6:7:12";
			public const string BPLanguageFoxPro = "";
			public const string BPLanguageJScript = "";
			public const string BPLanguageScript = "VSDebugUI.dll:6:7:10";
			public const string BPLanguageSQL = "VSDebugUI.dll:6:7:11";
			public const string BPLanguageUnknown = "VSDebugUI.dll:6:7:14";
		}

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the Breakpoint toolwindow
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointWindow() : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.WindowCaption), Constants.Commands.ViewDebugWindowsBreakpoints) 
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the Breakpoint toolwindow for the passed in app
		/// </summary>
		/// <param name="app">Application to open window in</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointWindow(IDEApp app) : base(app, app.GetIntlStr(Strings.WindowCaption), Constants.Commands.ViewDebugWindowsBreakpoints)
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Container for controls inside the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IBreakpointWindowControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the TreeView control in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Core.WinControls.TreeView IBreakpointWindowControls.BreakpointTreeView
		{
			get
			{
				return new Core.WinControls.TreeView(this, "", StringMatchSyntax.ExactMatch, Core.WindowClassNames.TreeView, StringMatchSyntax.ExactMatch);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the ListView control in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Core.WinControls.ListView IBreakpointWindowControls.BreakpointListView
		{
			get
			{
				return new Core.WinControls.ListView(this, "", StringMatchSyntax.ExactMatch, Core.WindowClassNames.ListView, StringMatchSyntax.ExactMatch);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the BreakpointNode specified by the index
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointNode this[int index]
		{
			get
			{
				return new BreakpointNode(this, index);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the BreakpointNode specified by the text
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public BreakpointNode this[string name]
		{
			get
			{
				Core.WinControls.TreeNode tn = this.Controls.BreakpointTreeView.Find(name);
				return new BreakpointNode(this, tn.Index);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get the language string displayed
		/// </summary>
		/// <param name="bpLang">Enum of the language text to look up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string LanguageText(BreakpointLanguages bpLang)
		{
			switch( bpLang )
			{
				case BreakpointLanguages.Basic:
					return this.App.GetIntlStr(Strings.BPLanguageBasic);
				case BreakpointLanguages.C:
					return this.App.GetIntlStr(Strings.BPLanguageC);
				case BreakpointLanguages.CSharp:
					return this.App.GetIntlStr(Strings.BPLanguageCSharp);
				case BreakpointLanguages.Cxx:
					return this.App.GetIntlStr(Strings.BPLanguageCxx);
				case BreakpointLanguages.FoxPro:
					return this.App.GetIntlStr(Strings.BPLanguageFoxPro);
				case BreakpointLanguages.JScript:
					return this.App.GetIntlStr(Strings.BPLanguageJScript);
				case BreakpointLanguages.Script:
					return this.App.GetIntlStr(Strings.BPLanguageScript);
				case BreakpointLanguages.SQL:
					return this.App.GetIntlStr(Strings.BPLanguageSQL);
				case BreakpointLanguages.Unknown:
					return this.App.GetIntlStr(Strings.BPLanguageUnknown);
				default:
					return "";
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get the language string displayed
		/// </summary>
		/// <param name="bpLang">Enum of the language text to look up</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ClearAllBreakpoints(bool performClear)
		{
			this.App.RaiseCmd(Constants.Commands.DebugClearAllBreakpoints);
			this.WaitForResponse();

			if( performClear )
				Alert.HandleAlert(this.App.GetIntlStr(Strings.ClearAllAlertText), AlertAction.ClickYes, this.App.MainWindow, 2000, true);
			else
				Alert.HandleAlert(this.App.GetIntlStr(Strings.ClearAllAlertText), AlertAction.ClickNo, this.App.MainWindow, 2000, true);
		}

		// TODO: New BP, Toolbar and setting columns visible is NYI
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\LocalsWindow.cs ===
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: LocalsWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Automation class for the Debugger Locals window.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class LocalsWindow : VariableWindow
	{
#region Constants

		protected class Strings
		{
			public const string WindowCaption = "VSDebugUI.dll:6:6:1";
		}

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show the Locals window for the ActiveApp
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public LocalsWindow() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsLocals, CoreManager.ActiveApp.GetIntlStr(Strings.WindowCaption))
		{
			this.WaitForResponse(); 
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show the Locals window for the passed-in app
		/// </summary>
		/// <param name="app">Application to show the window for</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public LocalsWindow(IDEApp app) : base(app, Constants.Commands.ViewDebugWindowsLocals, app.GetIntlStr(Strings.WindowCaption))
		{ 
			this.WaitForResponse(); 
		}

#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\ImmediateWindow.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett.Ide.VSControls;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: ImmediateWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IImmediateWindowControls
	{
		VsTextEditPane TextEditPane { get; }
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Automation class for the Debugger Immediate toolwindow.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	1/16/2003	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class ImmediateWindow : Everett.Ide.ToolWindows.ToolWindow, IImmediateWindowControls
	{

#region Constants

		protected class Strings
		{
			public const string WindowCaption = "msenvui.dll:6:866:5";
		}

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new ImmediateWindow
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ImmediateWindow() : base(CoreManager.ActiveApp, CoreManager.ActiveApp.GetIntlStr(Strings.WindowCaption), Constants.Commands.ViewDebugWindowsImmediate)
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new ImmediateWindow
		/// </summary>
		/// <param name="app">App to create instance in</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ImmediateWindow(IDEApp app) : base(app, app.GetIntlStr(Strings.WindowCaption), Constants.Commands.ViewDebugWindowsImmediate)
		{}

#endregion

#region Controls

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Access the ImmediateWindow's Controls
		/// </summary>
		/// <history>[Davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IImmediateWindowControls Controls 
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return the VsTextEditPane
		/// </summary>
		/// <history>[Davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		VsTextEditPane IImmediateWindowControls.TextEditPane
		{
			get
			{
				return new VsTextEditPane(this.App, this);
			}
		}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Clears all text from the IPane
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Clear()		
		{
			this.SetFocus();
			this.App.RaiseCmd(Constants.Commands.CommandWindowClearAll);
			this.App.MainWindow.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the entire text of the IPane
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Text
		{
			get
			{
				this.SetFocus();
				this.App.RaiseCmd(Constants.Commands.EditSelectAll);
				this.App.RaiseCmd(Constants.Commands.EditCopy);
				this.App.MainWindow.WaitForResponse();

				this.App.RaiseCmd(Constants.Commands.EditDocumentEnd);
				this.App.MainWindow.WaitForResponse();

				return Clipboard.Text;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the last line of text in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		///			 [mkpark] 1/31/2003 fixed to use "RaiseCmd"
		/// </history>
		///-----------------------------------------------------------------------------
		public string LastResultText()
		{
			// TODO: Waiting on IPane changes to make this prettier
			Keyboard.SendKeys("^{END}");
			Keyboard.SendKeys("{HOME}");
			Keyboard.SendKeys("{LEFT}");
			Keyboard.SendKeys("+{HOME}");
			this.App.RaiseCmd(Constants.Commands.EditCopy);
			this.App.MainWindow.WaitForResponse();

			return Clipboard.Text;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Types a new command at the bottom of the IPane and executes it
		/// </summary>
		/// <param name="command">Text to send</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SendCommand(string command)
		{
			this.SendCommand(command, true, false);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Types a new command at the bottom of the IPane and optionally executes it
		/// </summary>
		/// <param name="command">Text to send</param>
		/// <param name="execute">specifies whether to execute the command</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SendCommand(string command, bool execute)
		{
			this.SendCommand(command, execute, false);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Types a new command at the bottom of the IPane and optionally executes it
		/// </summary>
		/// <param name="command">Text to send</param>
		/// <param name="execute">specifies whether to execute the command</param>
		/// <param name="moveToEnd">specifies to move to the bottom of the window</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		///		[BrianMcM]	2/27/2003	Removed the prepareString param
		/// </history>
		///-----------------------------------------------------------------------------
		public void SendCommand(string command, bool execute, bool moveToEnd)
		{
			this.SetFocus();
			if( moveToEnd )
			{
				this.App.RaiseCmd(Constants.Commands.EditDocumentEnd);
				this.App.MainWindow.WaitForResponse();
			}

			this.SendKeys(command);

			if( execute )
			{
				SendKeys("{ENTER}");
				this.App.MainWindow.WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to do the work for DosKeyUp and DosKeyDown
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void DosKey()
		{
			throw new NotImplementedException("NYI");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes an up arrow in IPane and optional executes the command the appears
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DosKeyUp()
		{
			throw new NotImplementedException("NYI");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Executes an dn arrow in IPane and optional executes the command the appears
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 1/16/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DosKeyDown()
		{
			throw new NotImplementedException("NYI");
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\Modules.cs ===
//*********************************************************
// Owner : Yigingdu
// Class name : Modules
// Description: 
//*********************************************************
using System;
using System.Collections;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	#region Interfaces for Modules 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IModulesControls
	{
		Maui.Core.WinControls.ListView ModulesListView
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IModulesContextMenuItems
	{
		void Copy();
		void SelectAll();
		void SymbolsLoadInfo();
		void SymbolSettings();
		void ReloadSymbols();
	}
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IModulesVerify
	{
		bool ModuleInfo(string moduleName, string modulePath, string symbolStatus, string symbolFile, string order, string version, string timestamp, string address, string program);
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Modules
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you access the functionalities of the Modules
	/// window.
	/// </summary>
	/// <remarks></remarks>
	/// <history>[yiqingdu] 10/31/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Modules : Everett.Ide.ToolWindows.ToolWindow, IModulesControls, IModulesContextMenuItems, IModulesVerify
	{
		#region Exceptions
		public new class Exceptions : Everett.Ide.ToolWindows.ToolWindow.Exceptions
		{
			[Serializable]
				public class ModuleNotFound : MauiException
			{	
				public ModuleNotFound(string message) : base(message) {}

				protected ModuleNotFound(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion
		
		#region member variables
		//strings
		private const string DialogTitle = "VSDebugUI.dll:6:311:1"; 
		
		//controls
		private const int ModulesListViewID  = 0x1;

		//context menu items
		private const string CopyMenu = "Cop&y";
		private const string SelectAllMenu = "Select &All";
		private const string SymbolLoadInfoMenu = "VSDebugUI.dll;1000d1684892995d{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2;296"; //&Symbol Load Info...
		private const string SymbolSettingsMenu = "VSDebugUI.dll;1000d1684892995d{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2;294"; //&Symbol Settings...
		private const string ReloadSymbolsMenu = "VSDebugUI.dll;1000d1684892995d{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:2;28673"; //&Reload Symbols...

		#region ModuleObject class
		public class ModuleObject
		{
			string m_moduleName;
			string m_path;
			string m_symbolStatus;
			string m_symbolFile;
			string m_order;
			string m_version;
			string m_timestamp;
			string m_address;
			string m_program;	

			public ModuleObject()
			{	
				m_moduleName = "";
				m_path = "";
				m_symbolStatus = "";
				m_symbolFile = "";
				m_order = "";
				m_version = "";
				m_timestamp = "";
				m_address = "";
				m_program = "";		
			}

			public ModuleObject(string moduleName, string modulePath, string symbolStatus, string symbolFile, string order, string version, string timestamp, string address, string program)
			{
				m_moduleName = moduleName;
				m_path = modulePath;
				m_symbolStatus = symbolStatus;
				m_symbolFile = symbolFile;
				m_order = order;
				m_version = version;
				m_timestamp = timestamp;
				m_address = address;
				m_program = program;
			}

			public string Order
			{
				get
				{
					return m_order;
				}
			}

			public string ModuleName
			{
				get
				{
					return m_moduleName;
				}
			}

			public string Address
			{
				get
				{
					return m_address;
				}
			}

			public string Path
			{
				get
				{
					return m_path;
				}
			}

			public string Version
			{
				get
				{
					return m_version;
				}
			}

			public string Program
			{
				get
				{
					return m_program;
				}
			}

			public string Timestamp
			{
				get
				{
					return m_timestamp;
				}
			}

			public string SymbolFile
			{
				get
				{
					return m_symbolFile;
				}
			}
			public string SymbolStatus
			{
				get
				{
					return m_symbolStatus;
				}
			}
		}
		#endregion

		//collections, arrays
		private ArrayList m_moduleList = new ArrayList();
		private ModuleObject[] m_moduleArray; //this can avoid coverting m_moduleList to an Array everytime user calls through index.
		
		//other private variables
		private int m_defaultTimeOut = 10000; // milliseconds. 
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IModulesControls interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IModulesControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify return IModulesVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IModulesVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ContextMenuItems return IModulesContextMenuItems interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IModulesContextMenuItems ContextMenuItems
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ContextMenu return ContextMenu of Modules window. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.Core.WinControls.Menu ContextMenu
		{
			get
			{
				return new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return a list of modules listed in Modules window. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ModuleObject[] Items
		{
			get
			{
				//return (ModuleObject[]) m_moduleList.ToArray(typeof(ModuleObject));
				return m_moduleArray;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Set and Get DefaultTimeOut. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open modules window with default application. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Modules() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsModules, CoreManager.ActiveApp.GetIntlStr(DialogTitle))
		{
			RealConstrutor(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open modules window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.VisualStudio.Everett.IDEApp</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Modules(Maui.VisualStudio.Everett.IDEApp application) : base(application, Constants.Commands.ViewDebugWindowsModules, application.GetIntlStr(DialogTitle))
		{
			RealConstrutor(application);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void RealConstrutor(Maui.VisualStudio.Everett.IDEApp application)
		{
			Maui.Core.Window window = null;
			
			// get the window object with caption. 
			window = new Maui.Core.Window(application.GetIntlStr(DialogTitle), StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch, application,DefaultTimeOut);
			if(window == null)
			{
				throw new Maui.GlobalExceptions.MauiException("Running Doc window doesn't come up");
			}
			else
			{
				// set focus on window. 
				window.Extended.SetFocus();
				UpdateModuleList();
			}
		}
		#endregion

		#region IModulesControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return ModulesListView object. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ListView IModulesControls.ModulesListView
		{
			get
			{
				return new Maui.Core.WinControls.ListView(this, ModulesListViewID);
			}
		}
		#endregion

		#region IModulesVerify implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify if the specified module is listed in the Modules window  
		/// </summary>
		///<param name="moduleName">Name</param>
		/// <param name="modulePath">Path</param>
		/// <param name="symbolStatus">Symbol Status</param>
		/// <param name="symbolFile">Symbol File</param>
		/// <param name="nOrder">Order</param>
		/// <param name="version">Version</param>
		/// <param name="timestamp">Time Stamp</param>
		/// <param name="address">Address</param>	
		/// <param name="program">Program</param>
		/// <returns>it returns boolean value: if everything is matched, "true", otherwise, "false"</returns>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/30/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IModulesVerify.ModuleInfo(string moduleName, string modulePath, string symbolStatus, string symbolFile, string order, string version, string timestamp, string address, string program)
		{
			try
			{
				foreach (ModuleObject modObj in m_moduleList)
					if (IsModuleMatch(modObj, moduleName, modulePath, symbolStatus, symbolFile, order, version, timestamp, address, program))
						return true;
					
				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling ModuleInfo()"); 
			}

		}
		#endregion

		#region IModulesContextMenuItems implementations
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu Copy.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IModulesContextMenuItems.Copy()
		{
			this.ContextMenu[CopyMenu].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu Select All. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IModulesContextMenuItems.SelectAll()
		{
			this.ContextMenu[SelectAllMenu].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu Symbols Load Info. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IModulesContextMenuItems.SymbolsLoadInfo()
		{
			this.ContextMenu[SymbolLoadInfoMenu].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu Symbols Settings.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IModulesContextMenuItems.SymbolSettings()
		{
			this.ContextMenu[SymbolSettingsMenu].Execute();
			this.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Context menu Reload Symbols.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void IModulesContextMenuItems.ReloadSymbols()
		{
			this.ContextMenu[ReloadSymbolsMenu].Execute();
			this.WaitForResponse();
		}
		#endregion

		#region member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Fill in m_moduleArray
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void UpdateModuleList()
		{
			try
			{
				m_moduleList.Clear();
				foreach (Maui.Core.WinControls.ListViewItem type in this.Controls.ModulesListView.Items)
					m_moduleList.Add(new ModuleObject(type[0].Text.ToLower(), type[1].Text.ToLower(), type[2].Text.ToLower(), type[3].Text.ToLower(), type[4].Text.ToLower(), type[5].Text.ToLower(), type[6].Text.ToLower(), type[7].Text.ToLower(), type[8].Text.ToLower()));
				
				m_moduleArray = new ModuleObject[m_moduleList.Count];
				for (int i=0; i<m_moduleList.Count; i++)
					m_moduleArray[i] = (ModuleObject)m_moduleList[i];
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling UpdateModuleList()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify if the specified module object matches the attributes of the info module infos 
		/// </summary>
		/// <param name="modObj"> The specified module object</param>
		/// <param name="moduleName"> Name in Modules window</param>
		/// <param name="modulePath"> Path in Modules window</param>
		/// <param name="symbolStatus"> Symbol Status in Modules window</param>
		/// <param name="symbolFile"> Symbol File in Modules window</param>
		/// <param name="nOrder"> Order in Modules window</param>
		/// <param name="version"> Version in Modules window</param>
		/// <param name="timestamp"> Time Stamp in Modules window</param>
		/// <param name="address"> Address in Modules window</param>
		/// <param name="program"> Program in Modules window</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private bool IsModuleMatch(ModuleObject modObj, string moduleName, string modulePath, string symbolStatus, string symbolFile, string order, string version, string timestamp, string address, string program)
		{
			try
			{
				if((order != null) && (modObj.Order != order.ToLower()))
					return false;
				if((moduleName != null) && (modObj.ModuleName != moduleName.ToLower()))
					return false;
				if((address != null) && (modObj.Address != address.ToLower()))
					return false;
				if((modulePath != null) && (modObj.Path != modulePath.ToLower()))
					return false;
				if((version != null) && (modObj.Version != version.ToLower()))
					return false;
				if((program != null) && (modObj.Program != program.ToLower()))
					return false;
				if((timestamp != null) && (modObj.Timestamp != timestamp.ToLower()))
					return false;
				if((symbolFile != null) && (modObj.SymbolFile != symbolFile.ToLower()))
					return false;
				if((symbolStatus != null) && (modObj.SymbolStatus != symbolStatus.ToLower()))
					return false;

				return true;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling Modules::ModuleInfo()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Click on a tab in the Modules window to sort that column.
		/// </summary>
		/// <param name="byName"> Choose any of the column name in the Modules window</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SortBy(string byName)
		{
			try
			{
				this.Controls.ModulesListView.Columns[byName].Click();
				this.Controls.ModulesListView.WaitForResponse();
				this.WaitForResponse();
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling Modules::SortBy()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Click on a tab in the Modules window to sort that column.
		/// </summary>
		/// <param name="col"> Column number</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SortBy(int col)
		{
			try
			{
				this.Controls.ModulesListView.Columns[col].Click();
				this.Controls.ModulesListView.WaitForResponse();
				this.WaitForResponse();
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling Modules::SortBy()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// indexer to get ModuleObject object based on index  
		/// </summary>
		/// <param name="index">index in integer(1 based)</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ModuleObject this[string moduleName]
		{
			get
			{
//				for (int i = 0; i < m_moduleList.Count; i++)
//				{
//					if (((ModuleObject) m_moduleList[i]).ModuleName == moduleName.ToLower())
//						return (ModuleObject) m_moduleList[i];
//				}

				for (int i = 0; i < m_moduleArray.Length; i++)
					if (m_moduleArray[i].ModuleName == moduleName.ToLower())
						return m_moduleArray[i];

				throw new Exceptions.ModuleNotFound("No matching module is found");
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\CallStack.cs ===
using System;
using System.Collections;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;
using Maui.VisualStudio.Everett.Debugger.Dialogs;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	#region Interfaces
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface ICallStackVerify
	{
		bool VerifyCurrentFrame(string name, string language);
		bool VerifyAllFrames(string[][] stackFrames);
	}
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IFrameVerify
	{
		bool VerifyNameIs(string functionName);
		bool VerifyNameIsLike(string functionName);
		bool VerifyFrame(string functionName, string language);
	}
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface ICallStackAttributes
	{
		bool ShowByteOffsets
		{
			get;
			set;
		}
		bool ShowLineNumbers
		{
			get;
			set;
		}
		bool ShowParameterValues
		{
			get;
			set;
		}
		bool ShowParameterNames
		{
			get;
			set;
		}
		bool ShowParameterTypes
		{
			get;
			set;
		}
		bool ShowModuleNames
		{
			get;
			set;
		}
		bool ShowNonUserCode
		{
			get;
			set;
		}
		bool IncludeCallsFromOtherThreads
		{
			get;
			set;
		}
		bool HexadecimalDisplay
		{
			get;
			set;
		}	
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.Everett.Debugger
	/// Class		: CallStack
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you use the CallStack window's functionality
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class CallStack : DebuggerToolWindow, ICallStackAttributes, ICallStackVerify
	{
		#region Constant(control ID/command), private members
		private const string CallStackCaption = "VSDebugUI.dll:6:5:3";

		// const strings for context menus....
		private const string ShowByteOffsetsMenu = ":Show Byte &Offsets:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32775";
		private const string ShowLineNumbersMenu = ":Show Lin&e Numbers:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32774";
		private const string ShowParameterValuesMenu = ":Show Parameter &Values:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32770";
		private const string ShowParameterNamesMenu = ":Show &Parameter Names:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32772";		
		private const string ShowParameterTypesMenu = ":Show Parameter &Types:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32771";
		private const string ShowModuleNamesMenu = ":Show &Module Names:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32773";
		private const string ReloadSymbolsMenu = ":&Reload Symbols...:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:28673";
		private const string SymbolSettingsMenu = ":&Symbol Settings...:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:294";
		private const string SymbolLoadInfoMenu = ":&Symbol Load Info...:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:296";
		private const string ShowNonUserCodeMenu = ":Show E&xternal Code:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32777";
		private const string IncludeCallsFromOtherThreadsMenu = ":Include &Calls To/From Other Threads:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32776";
		private const string HexadecimalDisplayMenu = ":&Hexadecimal Display:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:314";
		private const string SelectAllMenu = ":Select &All:CTMenuString:cmddefui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:31";

		private const int m_defaultTimeOut = 10000;
		private Maui.VisualStudio.Everett.IDEApp m_app;
		private FramesCollection m_stackFrames; 
		private ArrayList m_columnsList;
		#endregion

		#region constructors and help functions for constructors. 
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open callstack window with default application. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public CallStack() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsCallStack, CoreManager.ActiveApp.GetIntlStr(CallStackCaption))
		{
			Init(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open callstack window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.Everett.IDEApp</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public CallStack(Maui.VisualStudio.Everett.IDEApp application) : base(application, Constants.Commands.ViewDebugWindowsCallStack, application.GetIntlStr(CallStackCaption))
		{
			Init(application);
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(Maui.VisualStudio.Everett.IDEApp application)
		{

			// set app
			m_app = application;
		
			// set focus on window. 
			this.Extended.SetFocus();
			m_stackFrames = new FramesCollection(this);	
			string[] columns = Controls.DebuggerToolWindowTreeGrid.GetColumns();
			m_columnsList = new ArrayList();
			foreach(string col in columns)
				m_columnsList.Add(col); 
		}


		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns ICallStackVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public new ICallStackVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns ICallStackAttributes interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/26/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ICallStackAttributes Attributes
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the Frames collection
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public FramesCollection Frames
		{
			get
			{
				m_stackFrames.ReloadFrames();
				return m_stackFrames;
			
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the list of column headers
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ArrayList ColumnsList
		{
			get
			{
				return m_columnsList;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the number of frames
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int FrameCount
		{
			get 
			{
				return this.Controls.DebuggerToolWindowTreeGrid.RowCount;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the index of the Active thread (0-based)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int CurrentFrameIndex
		{
			get 
			{
				for (int i= 0; i< this.FrameCount; i++)
					if(this.Frames[i].IsActive)
						return i;
				LogManager.LogFailure("Couldn't find the active thread in the Threads window");
				return -1;		
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// return Context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/25/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.Core.WinControls.Menu ContextMenu
		{
			get
			{
				return new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);;
			}
		}
		#endregion

		#region implementation of  ICallStackAttributes
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowByteOffsets context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowByteOffsets
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowByteOffsetsMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowByteOffsetsMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowByteOffsetsMenu)].Checked = value;
				WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowLineNumbers context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowLineNumbers
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowLineNumbersMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowLineNumbersMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowLineNumbersMenu)].Checked = value;
				WaitForResponse();
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowParameterValues context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoler] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowParameterValues
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterValuesMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterValuesMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowParameterValuesMenu)].Checked = value;
				WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowParameterTypes context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowParameterTypes
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterTypesMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterTypesMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowParameterTypesMenu)].Checked = value;
				WaitForResponse();
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowParameterNames context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowParameterNames
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterNamesMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowParameterNamesMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowParameterNamesMenu)].Checked = value;
				WaitForResponse();
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowModuleNames context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowModuleNames
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowModuleNamesMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowModuleNamesMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowModuleNamesMenu)].Checked = value;
				WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ShowNonUserCode context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.ShowNonUserCode
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(ShowNonUserCodeMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(ShowNonUserCodeMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(ShowNonUserCodeMenu)].Checked = value;
				WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// IncludeCallsFromOtherThreads context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.IncludeCallsFromOtherThreads
		{
			get
			{
				bool b = ContextMenu[App.GetIntlStr(IncludeCallsFromOtherThreadsMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b = ContextMenu[App.GetIntlStr(IncludeCallsFromOtherThreadsMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(IncludeCallsFromOtherThreadsMenu)].Checked = value;
				WaitForResponse();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// HexadecimalDisplay context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackAttributes.HexadecimalDisplay
		{
			get
			{
				bool b=ContextMenu[App.GetIntlStr(HexadecimalDisplayMenu)].Checked;
				this.SendKeys("{ESC}");
				return b;
			}

			set
			{
				bool b=ContextMenu[App.GetIntlStr(HexadecimalDisplayMenu)].Checked;
				this.SendKeys("{ESC}");
				if(b != value)
					ContextMenu[App.GetIntlStr(HexadecimalDisplayMenu)].Checked = value;
				WaitForResponse();
			}
		}
		#endregion

		#region implementation of ICallStackVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify Current frame 
		/// </summary>
		/// <param name="name">Current frame's Name </param>
		/// <param name="language">Current frame's Language</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/11/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackVerify.VerifyCurrentFrame(string name, string language)
		{
			int currentFrameIndex = CurrentFrameIndex;
			if(currentFrameIndex >= 0)
				return Frames[currentFrameIndex].Verify.VerifyFrame(name, language);
			else
			{
				LogManager.LogFailure("Couldn't find the active frame in the CallStack");
				return false;
			}

		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify all the frames in the callstack  
		/// </summary>
		/// <param name="stackFrames">2D array containing the exact names and languages expected</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool ICallStackVerify.VerifyAllFrames(string[][] stackFrames)
		{
			return base.Verify.VerifyAll(stackFrames);

		}
		#endregion

		#region Member functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// SelectAll 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SelectAll()
		{
			ContextMenu[App.GetIntlStr(SelectAllMenu)].Execute();
			WaitForResponse();
		}


		#endregion
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class represents a frame object in the CallStack window and it exposes the functionality that can be performed on a frame
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Frame : Maui.VisualStudio.Everett.Debugger.Controls.DebuggerToolRow, IFrameVerify
	{
		#region Constants for context menu actions
		private const string InsertBreakpointMenu = ":Insert B&reakpoint:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:375";
		private const string DisableBreakpointMenu = ":&Disable Breakpoint:Win32String:vsdebugui.dll:132";
		private const string EnableBreakpointMenu = ":Enab&le Breakpoint:CTMenuString:vsdebugui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:376";
		private const string RemoveBreakpointMenu = ":Remo&ve Breakpoint:Win32String:VSDebugUI.dll:131";
		private const string BreakpointPropertiesMenu = ":&Breakpoint Properties...:CTMenuString:vsdebugui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:260";
		private const string RunToCursorMenu = ":Ru&n To Cursor:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:251";
		private const string GoToDisassemblyMenu = ":Go To &Disassembly:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:263";
		private const string GoToSourceCodeMenu = ":&Go To Source Code:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:8193";
		private const string SwitchToFrameMenu = ":&Switch To Frame:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:32769";
		private const string CopyMenu = ":&Copy:CTMenuString:cmddefui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:15";
		#endregion

		#region Private variables
		private string m_functionName;
		private string m_language;
		private bool m_isActive;
		private int m_index; 
		private CallStack m_callStackWindowParent;
		#endregion

		#region Constants for Column names
		private const string NameColumnName = "VSDebugUI.dll:6:5:5";
		private const string LanguageColumnName = "VSDebugUI.dll:6:5:8";

		#endregion

		#region Constructor

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for the Frame object
		/// </summary>
		/// <param name="callStackWindowParent">the parent CallStack window</param>
		/// <param name="index">the 0-based index of the Frame in the CallStack window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Frame(CallStack callStackWindowParent, int index) : base( callStackWindowParent.Controls.DebuggerToolWindowTreeGrid, index)
		{
			m_callStackWindowParent = callStackWindowParent;
			m_index = index;

		}
		#endregion
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the index of a frame (0-based)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		#region Public Properties
		public int Index
		{			
			get
			{
				return m_index;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns IFrameVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public new IFrameVerify Verify
		{
			get
			{
				return this;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Function column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string FunctionName
		{
			get
			{
				m_functionName = Value[m_callStackWindowParent.ColumnsList.IndexOf(m_callStackWindowParent.App.GetIntlStr(NameColumnName))];
				return m_functionName;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Language column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Language
		{
			get
			{
				m_language = Value[m_callStackWindowParent.ColumnsList.IndexOf(m_callStackWindowParent.App.GetIntlStr(LanguageColumnName))];
				return m_language;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns true if the frame has the focus
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool IsActive
		{
			get
			{
				m_isActive = (bool)(Value[0] == ">");
				return m_isActive;
			}
		}
		#endregion
		#region implementation of IFrameVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify the Function is the exact string specified by functionName  
		/// </summary>
		/// <param name="functionName">the exact name expected</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IFrameVerify.VerifyNameIs(string functionName)
		{
			bool isTheSame = true;

			if(functionName != FunctionName)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Name column: " + FunctionName + " does not match expected value: " + functionName);
				isTheSame = false;
			}

			return isTheSame;
			
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify the functionName is part of the actual value of the Function column (non-case sensitive comparison)  
		/// </summary>
		/// <param name="functionName">part of the actual function name (non-case sensitive, non-whole string comparison)</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IFrameVerify.VerifyNameIsLike(string functionName)
		{
			bool isTheSame = true;

			if((FunctionName.ToLower()).IndexOf(functionName.ToLower()) == -1)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Name column: " + FunctionName + " does not match expected value: " + functionName);
				isTheSame = false;
			}
			return isTheSame;

		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify the Function and Language are the exact strings specified 
		/// </summary>
		/// <param name="functionName">the exact name expected</param>
		/// <remarks></remarks>
		/// <param name="language">the exact language expected</param>	
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IFrameVerify.VerifyFrame(string functionName, string language)
		{
			bool isTheSame = true;

			if(functionName != FunctionName)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Name column: " + FunctionName + " does not match expected value: " + functionName);
				isTheSame = false;
			}
			if(language != Language)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Name column: " + Language + " does not match expected value: " + language);
				isTheSame = false;
			}
			return isTheSame;
		}
		#endregion
#region Public member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Switches to this frame 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SwitchToFrame()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(SwitchToFrameMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();

		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Inserts a breakpoint at this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void InsertBreakpoint()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(InsertBreakpointMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();

		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Removes the breakpoint on this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RemoveBreakpoint()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(RemoveBreakpointMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the breakpoint on this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DisableBreakpoint()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(DisableBreakpointMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Disables the breakpoint on this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void EnableBreakpoint()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(EnableBreakpointMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Brings up the BreakpointProperties dialog for the breakpoint on this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public  Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog BreakpointProperties()
		{
			// I'm not sure whether this should create BP Properties dialog here and return the instance. 
			Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog BPPropertiesDlg = null;
			this.Select();		
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(BreakpointPropertiesMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
			BPPropertiesDlg = new Maui.VisualStudio.Everett.Debugger.Dialogs.BreakPointPropertiesDialog(m_callStackWindowParent.App);
			return BPPropertiesDlg;
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Go To Source code for this frame 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GoToSource()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(GoToSourceCodeMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Go To Disassembly for this frame
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void GoToDisassembly()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(GoToDisassemblyMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Runs To Cursor for this frame 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void RunToCursor()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(RunToCursorMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Copy this frame to clipboard
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Copy()
		{
			this.Select();
			m_callStackWindowParent.ContextMenu[m_callStackWindowParent.App.GetIntlStr(CopyMenu)].Execute();
			m_callStackWindowParent.WaitForResponse();
		}
		#endregion
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class represents the collection of frame objects in the CallStack window 
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class FramesCollection : Maui.Core.RemotingObject
	{
	#region Constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for the Frames collection
		/// </summary>
		///<param name="threadsWindowParent">an instance of the parent Frames Window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public FramesCollection(CallStack callStackWindowParent)
		{
			m_callStackWindowParent = callStackWindowParent;
				
		}
	#endregion

	#region Private member variables and functions
		private CallStack m_callStackWindowParent;
		private Frame[] m_frames;

	#endregion

	#region public properties and functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// ReloadFrames - loads the array of Frame objects from the TreeGrid control
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ReloadFrames()
		{
			if(m_frames != null)
				m_frames = null;
			m_frames = new Frame[this.Count];
			for(int i=0; i< this.Count; i++)
				m_frames[i] = new Frame(m_callStackWindowParent,i);
		
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------		
		public Frame this[int index]
		{
			get
			{
				return m_frames[index];
			}
			set
			{
				m_frames[index] = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the number of frame objects in the CallStack window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int Count
		{
			get
			{
				return m_callStackWindowParent.Controls.DebuggerToolWindowTreeGrid.RowCount;
			}
		}
		#endregion

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\Registers.cs ===
using System;
using System.Collections;
using System.Text.RegularExpressions;
using System.ComponentModel;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.Editors;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: RegisterWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------

	#region Interface
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IRegisterAttributes
	{
		bool Flags 
		{	
			get;
			set; 
		}	
	
		bool CPUEffectiveAddress		
		{	
			get;
			set; 
		}

		bool FloatingPoint 		
		{	
			get;
			set; 
		}

		bool MMX 		
		{	
			get;
			set; 
		}

		bool SSE 		
		{	
			get;
			set; 
		}

		bool SSE2		
		{	
			get;
			set; 
		}

		bool RegisterStack		
		{	
			get;
			set; 
		}

		bool AMD3DNow		
		{	
			get;
			set; 
		}

		bool Application		
		{	
			get;
			set; 
		}

		bool Branch		
		{	
			get;
			set; 
		}
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// <summary>
	///	This class lets you access the functionalities of the Register
	/// window.
	/// </summary>							   
	/// <history>
	///		[daigoh] 01/17/2003 Created
	///	</history>
	///-----------------------------------------------------------------------------
	public class Registers : Everett.Ide.ToolWindows.ToolWindow, IRegisterAttributes
	{
		private BaseEditor m_baseEditor = null;	
	
		#region ResouceID
		///-----------------------------------------------------------------------------
		/// <summary>
		/// static class for Resouce IDs
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected class ResouceString
		{
			public readonly static string WindowCaption		= "VSDebugUI.dll:6:7:7";
			// Context Menu Items
			public readonly static string MenuItemCPU		= ":CPU:Win32String:msdbgui.dll:1040";
			public readonly static string MenuItemCPUSeg	= ":CPU Segments:Win32String:msdbgui.dll:1043";
			public readonly static string MenuItemCPUEffAdd	= ":CPUEffective Address:Win32String:vsdebugui.dll:5017";
			public readonly static string MenuItemFlags		= ":Flags:Win32String:msdbgui.dll:1041";
			public readonly static string MenuItemFloatPt	= ":Floating Point:Win32String:msdbgui.dll:1042";
			public readonly static string MenuItemMMX		= ":MMX:in32String:NatDbgDEUI.dll:4";
			public readonly static string MenuItemSSE		= ":SSE:Win32String:NatDbgDEUI.dll:5";
			public readonly static string MenuItemSSE2		= ":SSE2:Win32String:NatDbgDEUI.dll:6";
			public readonly static string MenuItemRegStack	= ":Register Stack:Win32String:NatDbgDEUI.dll:8";
			public readonly static string MenuItem3DNow		= ":3DNow!:Win32String:NatDbgDEUI.dll:7";
			public readonly static string MenuItemApp		= ":Application:Win32String:NatDbgDEUI.dll:9";
			public readonly static string MenuItemBranch	= ":Branch:Win32String:NatDbgDEUI.dll:10";
		}
		#endregion ResouceID

		#region Ctors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Default Ctor.
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Registers() : 
			base(CoreManager.ActiveApp, 
				 CoreManager.ActiveApp.GetIntlStr(ResouceString.WindowCaption),
				 Constants.Commands.ViewDebugWindowsRegisters)
		{
			Init();	
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Ctor with IDEApp arg
		/// </summary>
		/// <param name="application">Maui.VisualStudio.Everett.IDEApp</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Registers(IDEApp application) : 
			base(application,
				 application.GetIntlStr(ResouceString.WindowCaption),
				 Constants.Commands.ViewDebugWindowsRegisters)
		{
			Init();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Common method to initialize this object
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void Init()
		{
			this.m_baseEditor = new BaseEditor(this.App,this);
		}

		#endregion Ctors

		#region Indexer/Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer to set/get value to the given register
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		public string this[string register]
		{
			get
			{
				return ParseRegisterWndText(register);
			}
			set
			{
				SetRegisterValue(register,value);
			}		
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get the entire text in the register window
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string RawText
		{
			get
			{
				m_baseEditor.SetFocus();
				m_baseEditor.Cursor.SelectAll();
				return m_baseEditor.Cursor.SelectedText();
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Get/Set All the value with a hashtable format
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IDictionary All
		{
			get
			{
				return GetParsedTable();
			}
			set
			{
				SetRegisterValues((IDictionary)value);				
			}
		}

		#endregion Indexer/Properties

		#region For legacy support
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Auto7 style SetRegister method
		/// </summary>
		/// <param name="register">Register Name</param>
		/// <param name="val">Register Value</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void SetRegister(string register, string val)
		{	
			this[register]=val;
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Auto7 style GetRegister method
		/// </summary>
		/// <param name="register">Register Name</param>
		/// <param name="val">Register Value</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		void GetRegister(string register, ref string val)
		{
			val = this[register];
		}
		#endregion For legacy support

		#region ContextMenu Property

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Property return the interface.....
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IRegisterAttributes Attributes
		{
			get{ return this;}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// CPU Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool CPU
		{
			get{ return GetContextMenuItemStatus(ResouceString.MenuItemCPU); }
			set{ SetContextMenuItemStatus(ResouceString.MenuItemCPU,value);}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// CPU Segments Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool CPUSegments
		{
			get{ return GetContextMenuItemStatus(ResouceString.MenuItemCPUSeg); }
			set{ SetContextMenuItemStatus(ResouceString.MenuItemCPUSeg,value);}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Flags Segments Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Flags
		{
			get
			{ 
				return GetContextMenuItemStatus(ResouceString.MenuItemFlags); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemFlags,value);
			}
		}		

		///-----------------------------------------------------------------------------
		/// <summary>
		/// CPU Effective Address Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool CPUEffectiveAddress
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemCPUEffAdd); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemCPUEffAdd,value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Floating Point Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool FloatingPoint
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemFloatPt); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemFloatPt,value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// MMX Segments Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool MMX
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemMMX); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemMMX,value);
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// SSE Context Menu Property
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool SSE
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemSSE); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemSSE,value);
			}
		}

		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// SSE2 Context Menu Property
		/// </summary>
		/// <history>[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool SSE2
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemSSE2); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemSSE2,value);
			}
		}
	
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Register Stack Context Menu Property
		/// </summary>
		/// <history>[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool RegisterStack
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemRegStack); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemRegStack,value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 3DNow! Context Menu Property
		/// </summary>
		/// <history>[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool AMD3DNow
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItem3DNow); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItem3DNow,value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Application Menu Property
		/// </summary>
		/// <history>[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Application
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemApp); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemApp,value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Branch Context Menu Property
		/// </summary>
		/// <history>[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Branch
		{
			get
			{
				return GetContextMenuItemStatus(ResouceString.MenuItemBranch); 
			}
			set
			{
				SetContextMenuItemStatus(ResouceString.MenuItemBranch,value);
			}
		}
		#endregion ContextMenu Property

		#region Helper Functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to Parse the text in the register window
		/// </summary>
		/// <param name="regName">Register Name</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected string ParseRegisterWndText(string regName)
		{
			return (string)GetParsedTable()[regName];
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// get register values with hashtable
		/// </summary>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------		
		protected IDictionary GetParsedTable()
		{
			return GetParsedTable(this.RawText);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// get register values with hashtable
		/// </summary>
		/// <param name="regValues">Row string of register window</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected IDictionary GetParsedTable(string regVales)
		{
			Hashtable table = new Hashtable();
			Regex regex = new Regex(@"(?<key>\S+)\s=\s(?<value>\S+)\s?",(RegexOptions) 0);
			MatchCollection mc = regex.Matches(regVales);

			foreach(Match m in mc)
			{
				table.Add(m.Groups["key"].Value,m.Groups["value"].Value);
			}
			
			return table;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to set multiple register values
		/// </summary>
		/// <param name="regTable">
		///		Hashtable which contains Register name as key and 
		///		Register value as a Value
		/// </param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void SetRegisterValues(IDictionary regTable)
		{
			foreach(IDictionaryEnumerator entry in regTable)
			{
				SetRegisterValue((string)entry.Key,(string)entry.Value);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to set register value
		/// </summary>
		/// <param name="register">Register Name</param>
		/// <param name="val">Register Value</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void SetRegisterValue(string register, string val)
		{
			// TODO: Not done yet..
			throw new NotImplementedException("Setting Register Value hasn't done yet...");
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to set Context Menu Item status
		/// </summary>
		/// <param name="item">Context Menu Item Name</param>
		/// <param name="check">Item status (check/uncheck)</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected void SetContextMenuItemStatus(string item, bool check)
		{
			try
			{
				Core.WinControls.Menu c = new Core.WinControls.Menu(ContextMenuAccessMethod.ShiftF10);
				c[App.GetIntlStr(item)].Checked = check;
			}
			finally
			{
				this.m_baseEditor.SendKeys("{ESC}");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get Context Menu Item status
		/// </summary>
		/// <param name="item">Context Menu Item Name</param>
		/// <history>
		///		[daigoh] 01/17/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		protected bool GetContextMenuItemStatus(string item)
		{
			try
			{
				Core.WinControls.Menu c = new Core.WinControls.Menu(ContextMenuAccessMethod.ShiftF10);
				return c[item].Checked;
			}
			catch(MenuItem.Exceptions.MenuItemNotFoundException)
			{
				return false;
			}
			finally
			{
				this.m_baseEditor.SendKeys("{ESC}");
			}
		}
		#endregion Helper Functions
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\RunningDoc.cs ===
//*********************************************************
// Owner : Yigingdu
// Class name : RunningDoc
// Description: 
//*********************************************************
using System;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	#region Interfaces for RunningDoc 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IRunningDocControls
	{
		Maui.Core.WinControls.TreeView RunningDocTreeView
		{
			get;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IRunningDocVerify
	{
		bool Node(string nodeName);
		bool VerifyRelationship(string parentNode, string childNode);
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: RunningDoc
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you access the functionalities of the Running Documents
	/// window.
	/// </summary>
	/// <remarks></remarks>
	/// <history>[yiqingdu] 10/31/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class RunningDoc : Everett.Ide.ToolWindows.ToolWindow, IRunningDocControls, IRunningDocVerify
	{
		#region member variables
		//strings
		private const string DialogTitle = "VSDebugUI.dll:6:4:15"; 

		//controls
		private const int RunningDocTreeViewID = 0x23e;

		//other private variables
		private int m_defaultTimeOut = 10000; // milliseconds. 

		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IRunningDocControls interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IRunningDocControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify return IRunningDocControls interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IRunningDocVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return default timeout. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int DefaultTimeOut
		{
			get
			{
				return m_defaultTimeOut;
			}

			set
			{
				m_defaultTimeOut = value;
			}
		}
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open RunningDoc window with default application. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RunningDoc() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsRunningDocs, CoreManager.ActiveApp.GetIntlStr(DialogTitle))
		{
			RealConstrutor(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open RunningDoc window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.VisualStudio.Everett.IDEApp</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public RunningDoc(Maui.VisualStudio.Everett.IDEApp application) : base(application, Constants.Commands.ViewDebugWindowsRunningDocs, application.GetIntlStr(DialogTitle))
		{
			RealConstrutor(application);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void RealConstrutor(Maui.VisualStudio.Everett.IDEApp application)
		{
			Maui.Core.Window window = null;

			// get the window object with caption. 
			window = new Maui.Core.Window(application.GetIntlStr(DialogTitle), StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch, application,DefaultTimeOut);
			if(window == null)
			{
				throw new Maui.GlobalExceptions.MauiException("Running Doc window doesn't come up");
			}
			else
			{
				// set focus on window. 
				window.Extended.SetFocus();
			}
		}
		#endregion

		#region IRunningDocControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return RunningDocTreeView object. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.TreeView IRunningDocControls.RunningDocTreeView
		{
			get
			{
				return new Maui.Core.WinControls.TreeView(this, RunningDocTreeViewID);
			}
		}
		#endregion

		#region IRunningDocVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check to see if Running Doc window contains the specified node in the list
		/// </summary>
		/// <param name="nodeName"> The node name</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IRunningDocVerify.Node(string nodeName)
		{
			try
			{
				if (this.Controls.RunningDocTreeView.Find (nodeName) != null)
					return true;

				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling IRunningDocVerify.Node()"); 
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check to see if one node is the child of another parent node.
		/// </summary>
		/// <param name="parentNode"> Parent node name</param>
		/// <param name="childNode"> Child node name</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IRunningDocVerify.VerifyRelationship(string parentNode, string childNode)
		{
			try
			{
				Maui.Core.WinControls.TreeNode ParentNode;
				if ((ParentNode = this.Controls.RunningDocTreeView.Find(parentNode))!= null)
					if (ParentNode.Find(childNode) != null)
						return true;

				return false;
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling IRunningDocVerify.VerifyRelationship()"); 
			}
		}
		#endregion

		#region member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open a file from Running Doc window. 
		/// </summary>
		/// <param name="nodeName"> File name</param>
		/// <remarks></remarks>
		/// <history>[yiqingdu] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Open (string nodeName)
		{
			try
			{
				Maui.Core.WinControls.TreeNode node;
				if ((node = this.Controls.RunningDocTreeView.Find(nodeName))!= null)
				{
					node.Select();
					this.WaitForResponse(DefaultTimeOut);
					this.SendKeys("{ENTER}");
				}
				else
				{
					throw new Maui.GlobalExceptions.MauiException("Error while calling RunningDoc.Open(): can't find matching node in Running Doc window."); 
				}
			}
			catch(System.Exception e)
			{
				throw new Maui.GlobalExceptions.MauiException(e.Message + ": error while calling RunningDoc.Open()"); 
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\Memory.cs ===
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.Core.WinControls;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Ide.VSControls;
using Maui.VisualStudio.Everett.Ide.Editors;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{

	#region Interfaces for Memory window.

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IMemoryDialogControls
	{
		EditComboBox AddressComboBox
		{
			get;
		}
        
		EditComboBox ColumnsComboBox
		{
			get;
		}

		BaseEditor MemoryBaseEditor
		{
			get;
		}

		VSContextMenu ContextMenu
		{
			get;
		}
	}
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IMemoryAttributes
	{
		bool NoData
		{
			get;
			set;
		}

		bool Integer1byte
		{
			get;
			set;
		}
		bool Integer2byte
		{
			get;
			set;
		}
		bool Integer4byte
		{
			get;
			set;
		}
		bool Integer8byte
		{
			get;
			set;
		}


		bool FloatingPoint32bit
		{
			get;
			set;
		}

		bool FloatingPoint64bit
		{
			get;
			set;
		}

		bool HexidecimalDisplay
		{
			get;
			set;
		}
		bool SignedDisplay
		{
			get;
			set;
		}

		bool UnSignedDisplay
		{
			get;
			set;
		}

		bool NoText
		{
			get;
			set;
		}

		bool AnsiText
		{
			get;
			set;
		}

		bool UnicodeText
		{
			get;
			set;
		}

		MenuItem EditValue
		{
			get;
		}

		bool ReevaluateAutomatically
		{
			get;
			set;
		}

		bool ShowToolBar
		{
			get;
			set;
		}
	}
	
	#endregion
	
	#region Helper Classes

	///-----------------------------------------------------------------------------
	/// <summary>
	/// MemoryFormat is a helper class that holds all the data need to set the various memory window settings.
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class MemoryFormat
	{
		public DataFormat dataFormat = DataFormat.NoChange;
		public TextFormat textFormat = TextFormat.NoChange;
		public DataDisplay dataDisplay = DataDisplay.NoChange;
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// DataFormat enum that relates to the memory windows data format view
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum DataFormat
	{
		NoData,
		Int1,
		Int2,
		Int4,
		Int8,
		Float32,
		Float64,
		NoChange,
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// TextFormat enum that relates to the memory windows text display
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum TextFormat
	{
		NoText,
		Ansi,
		Unicode,
		NoChange,
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// DataDisplay enum relates directly to the memory windows display of text
	/// </summary>
	///-----------------------------------------------------------------------------
	public enum DataDisplay
	{
		Hex,
		Signed,
		Unsigned,
		NoChange,
	}

		#endregion

	/// -----------------------------------------------------------------------------
	/// <summary>
	/// This class controls both the ui of the debugger memory window as well as providing functionality to drive the ui.
	/// </summary>
	/// <history>
	///			[bboris] 1/30/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class Memory : Maui.VisualStudio.Everett.Ide.ToolWindows.ToolWindow, IMemoryDialogControls,IMemoryAttributes
	{
		#region Exceptions
		public new class Exceptions : Maui.VisualStudio.Everett.Ide.ToolWindows.ToolWindow.Exceptions
		{
			[Serializable]
				public class InvalidIndexException : MauiException
			{
				public InvalidIndexException(string message) : base(message) {}

				protected InvalidIndexException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion
		
		#region Constant(control ID/command), private members
		
		protected class ControlIDs
		{									   
			public const int AddressComboBox = 0x019fe4e8;
			public const int ColumnsComboBox = 16752844;
			public const int AddressComboBoxEdit = 16789505;
		}
		
		protected class StringIDs
		{									   
			public readonly static string DialogTitle = ";Memory %1;Win32String;vsdebugui.dll;112";
			public readonly static string NoDataMenu = ":No &Data:CTMenuString:vsdebugui.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12305";
			public readonly static string Integer1byteMenu = ":&1-byte Integer:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12306";
			public readonly static string Integer2byteMenu = ":&2-byte Integer:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12307";
			public readonly static string Integer4byteMenu = ":&4-byte Integer:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12308";
			public readonly static string Integer8byteMenu = ":&8-byte Integer:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12309";
			public readonly static string FloatingPoint32bitMenu = ":&32-bit Floating Point:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12320";
			public readonly static string FloatingPoint64bitMenu = ":&64-bit Floating Point:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12321";
			public readonly static string HexidecimalDisplayMenu = ":&Hexadecimal Display:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12336";
			public readonly static string SignedDisplayMenu = ":&Signed Display:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12337";
			public readonly static string UnSignedDisplayMenu = ":&Unsigned Display:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12338";
			public readonly static string NoTextMenu = ":&No Text:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12352";
			public readonly static string AnsiTextMenu = ":&ANSI Text:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12353";
			public readonly static string UnicodeTextMenu = ":Un&icode Text:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12354";
			public readonly static string EditValueMenu = ":&Edit Value:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12368";
			public readonly static string ReevaluateAutomaticallyMenu = ":&Reevaluate Automatically:CTMenuString;vsdebugui.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12290";
			public readonly static string ShowToolBarMenu = ":Show &Toolbar:CTMenuString:VSDebugUI.dll:1000:1684892995:{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}:12386";
			public readonly static string AddressComboBoxID = "{C9DD4A59-47FB-11D2-83E7-00C04F9902C1}";
		}
		
		private int m_defaultTimeOut = 10000; // milliseconds. 
    
		#endregion 

		#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens memory window 1 for the active app
		/// </summary>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory():  base(CoreManager.ActiveApp,GenerateCaption(CoreManager.ActiveApp,1),PickCommand(1))
		{
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens Memory window 1 for the passed in app
		/// </summary>
		/// <param name="app">Application to open window for</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory(IDEApp app):  base(app,GenerateCaption(app,1),PickCommand(1))
		{
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens Memory window [1-4] for the passed in app
		/// </summary>
		/// <param name="index">Index for which memory window to open</param>
		/// <param name="app">Application to open window for</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory(IDEApp app, int index):	base(app,GenerateCaption(app,index),PickCommand(index))
		{
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens Memory window [1-4] for the active app
		/// </summary>
		/// <param name="index">Index for which memory window to open</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Memory(int index):  base(CoreManager.ActiveApp,GenerateCaption(CoreManager.ActiveApp,index),PickCommand(index))
		{
		}
		
		#endregion

		#region Properties
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>
		///  An interface that groups all of the window's control properties together
		///  </value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IMemoryDialogControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Controls return IMemoryAttributes interface. 
		/// </summary>
		/// <value>
		/// An interface that groups all the context menu attributes together
		/// </value>
		/// <history>
		///			[bboris] 	10/30/2002	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IMemoryAttributes Attributes
		{
			get
			{
				return this;
			}
		}

		#endregion 

		#region Implementation of IMemoryDialogControls

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Controls.ContextMenu control
		///  </summary>
		///  <value>
		///  Context menu
		///  </value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		VSContextMenu IMemoryDialogControls.ContextMenu
		{
			get
			{
				// bboris: by default there is no cursor in the memory window,so i have to click there first
				Controls.MemoryBaseEditor.SetFocus();
				//Mouse.Click(MouseClickType.SingleClick,MouseFlags.LeftButton,Controls.MemoryBaseEditor.Cursor.XPos(),Controls.MemoryBaseEditor.Cursor.YPos());
				return new VSContextMenu(App,Controls.MemoryBaseEditor.Cursor.XPos(),Controls.MemoryBaseEditor.Cursor.YPos());
				//return new Maui.Core.WinControls.Menu(ContextMenuAccessMethod.ShiftF10);
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the MemoryBaseEditor control
		///  </summary>
		///  <value>
		///  Text editor for the memory window
		///  </value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		BaseEditor IMemoryDialogControls.MemoryBaseEditor
		{
			get
			{
				return new BaseEditor(App,this);
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the AddressComboBox control
		///  </summary>
		///  <value>
		///  The address combo box
		///  </value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		EditComboBox IMemoryDialogControls.AddressComboBox
		{
			get
			{
				return new EditComboBox(this,"", StringMatchSyntax.ExactMatch,Core.WindowClassNames.RichEdit, StringMatchSyntax.WildCard);
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ColumnsComboBox control
		///  </summary>
		///  <value>
		///  The columns combo box
		///  </value>
		///  <history>
		///			[bboris] 1/30/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		EditComboBox IMemoryDialogControls.ColumnsComboBox
		{
			get
			{
				return new EditComboBox(this, ControlIDs.ColumnsComboBox);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control AddressComboBox 
		/// </summary>
		/// <value>
		/// the text from the address combo box
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public virtual string AddressComboBoxText
		{
			get
			{ 
				return Controls.AddressComboBox.Text;
			}

			set
			{
				object o = "";
				object o2 = value;
				App.RaiseCmd(StringIDs.AddressComboBoxID, ControlIDs.AddressComboBoxEdit, ref o2,ref o);			
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Routine to set/get the text in control ColumnsComboBox 
		/// </summary>
		/// <value>
		/// the text from the columns combo box
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public virtual string ColumnsComboBoxText
		{
			get
			{
				
				return Controls.ColumnsComboBox.Text;
			}

			set
			{
				 Controls.ColumnsComboBox.Text = value; 					
			}
		}

		#endregion

		#region Implementation of IMemoryAttributes

		///-----------------------------------------------------------------------------
		/// <summary>
		/// No Data context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.NoData
		{
			get
			{
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.NoDataMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.NoDataMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 1 byte Integer context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.Integer1byte
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer1byteMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer1byteMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 2 byte Integer context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.Integer2byte
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer2byteMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer2byteMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 4 byte Integer context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.Integer4byte
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer4byteMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer4byteMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 8 byte Integer context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.Integer8byte
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer8byteMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.Integer8byteMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 32 bit Floating Point context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.FloatingPoint32bit
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.FloatingPoint32bitMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.FloatingPoint32bitMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// 64 bit Floating Point context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.FloatingPoint64bit
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.FloatingPoint64bitMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.FloatingPoint64bitMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// HexidecimalDisplay context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.HexidecimalDisplay
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.HexidecimalDisplayMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.HexidecimalDisplayMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Signed Display context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///				[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.SignedDisplay
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.SignedDisplayMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.SignedDisplayMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// UnSigned Display context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.UnSignedDisplay
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.UnSignedDisplayMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.UnSignedDisplayMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// No Text context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.NoText
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.NoTextMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.NoTextMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// AnsiText context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.AnsiText
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.AnsiTextMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.AnsiTextMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// UnicodeText context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.UnicodeText
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.UnicodeTextMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.UnicodeTextMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// EditValue context menu  
		/// </summary>
		/// <value>
		/// the edit value menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		MenuItem IMemoryAttributes.EditValue
		{
			get
			{	
				return Controls.ContextMenu[App.GetIntlStr(StringIDs.EditValueMenu)];;
			}

		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Reevaluate Automatically context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.ReevaluateAutomatically
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.ReevaluateAutomaticallyMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.ReevaluateAutomaticallyMenu)].Checked = value;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Show ToolBar context menu  
		/// </summary>
		/// <value>
		/// the boolean value of the menu item
		/// </value>
		/// <history>
		///			[bboris] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IMemoryAttributes.ShowToolBar
		{
			get
			{	
				bool temp = Controls.ContextMenu[App.GetIntlStr(StringIDs.ShowToolBarMenu)].Checked;
				SendKeys("{ESC}");
				return temp;
			}

			set
			{
				Controls.ContextMenu[App.GetIntlStr(StringIDs.ShowToolBarMenu)].Checked = value;
			}
		}

		#endregion

		#region Helper Function
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to return DTE command of specified memory window
		/// </summary>
		/// <param name="index">Memory window to get command for</param>
		/// <value>
		/// DTE RaiseCmd command string
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string PickCommand(int index) 
		{
			switch( index )
			{
				case 1 : return Constants.Commands.ViewDebugWindowsMemory1;
				case 2 : return Constants.Commands.ViewDebugWindowsMemory2;
				case 3 : return Constants.Commands.ViewDebugWindowsMemory3;
				case 4 : return Constants.Commands.ViewDebugWindowsMemory4;
				default : throw new Exceptions.InvalidIndexException("Invalid memory window index.");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified memory window
		/// </summary>
		/// <param name="index">Memory window to get caption for</param>
		/// <value>
		/// Memory window caption
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, int index) 
		{
			return app.GetIntlStr(StringIDs.DialogTitle).Replace("%1", index.ToString());
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function that will setup the memory windows various fields
		/// </summary>
		/// <param name="address">address to be placed in the memory windows address box</param>
		/// <param name="memformat">a MemoryFormat variable that holds many variables found on the context menu of the memory window</param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void SetMemoryInfo(string address, MemoryFormat memformat)
		{
			SetFocus();
			AddressComboBoxText = address;
			
			switch(memformat.dataFormat)
			{
				case DataFormat.NoData:
					Attributes.NoData = true;
					break;
				case DataFormat.Int1:
					Attributes.Integer1byte = true;
					break;
				case DataFormat.Int2:
					Attributes.Integer2byte = true;
					break;
				case DataFormat.Int4:
					Attributes.Integer4byte = true;
					break;
				case DataFormat.Int8:
					Attributes.Integer8byte = true;
					break;
				case DataFormat.Float32:
					Attributes.FloatingPoint32bit = true;
					break;
				case DataFormat.Float64:
					Attributes.FloatingPoint64bit = true;
					break;
				case DataFormat.NoChange:
					break;
				default : throw new Exceptions.InvalidIndexException("Invalid DataFormat index.");

			}

			switch(memformat.dataDisplay)
			{	
				case DataDisplay.Hex:
					Attributes.HexidecimalDisplay = true;
					break;
				case DataDisplay.Signed:
					Attributes.SignedDisplay = true;
					break;
				case DataDisplay.Unsigned:
					Attributes.UnSignedDisplay = true;
					break;
				case DataDisplay.NoChange:
					break;
				default : throw new Exceptions.InvalidIndexException("Invalid DataDisplay index.");
			}

			switch(memformat.textFormat)
			{

				case TextFormat.Ansi:
					Attributes.AnsiText = true;
					break;
				case TextFormat.NoText:
					Attributes.NoText = true;
					break;
				case TextFormat.Unicode:
					Attributes.UnicodeText = true;
					break;
				case TextFormat.NoChange:
					break;
				default : throw new Exceptions.InvalidIndexException("Invalid TextFormat index.");
			}
		}

		#endregion

		#region Member Funcitons
	
		///-----------------------------------------------------------------------------
		/// <summary>
		/// GetMemoryRow returns the current memory row, i.e. address + data + text, to the user
		/// 
		/// usgae:
		/// 
		/// string s = my_memory.GetMemoryRow("ConsoleApplication4.Class1.Main(string[]) + 0x00000000",new MemoryFormat());
		///
		/// </summary>
		/// <param name="address">the memory address to set in the memory window</param>
		/// <param name="memformat">the MemoryFormat object that tells what setting to apply in the memory window</param>
		/// <value>
		/// a string that represents the entire memory row
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string GetMemoryRow(string address, MemoryFormat memformat)
		{
			SetMemoryInfo(address,memformat);
			
			Controls.MemoryBaseEditor.SetFocus();
			
			Mouse.Click(Controls.MemoryBaseEditor.Cursor.XPos(),Controls.MemoryBaseEditor.Cursor.YPos());
			WaitForResponse(m_defaultTimeOut);
			Controls.MemoryBaseEditor.Cursor.SelectCurrentLine();

			return Controls.MemoryBaseEditor.Cursor.SelectedText(true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// GetMemoryData returns one memory unit to the user
		/// 
		/// usgae:
		/// 
		/// string s = my_memory.GetMemoryData("ConsoleApplication4.Class1.Main(string[]) + 0x00000000",new MemoryFormat(),1);
		///
		/// </summary>
		/// <param name="address">the memory address to set in the memory window</param>
		/// <param name="memformat">the MemoryFormat object that tells what setting to apply in the memory window</param>
		/// <param name="start">this number relates to memory units, not to characters,if the memory window is set to 4 columns then there will be 4 memory units in a row</param>
		/// <value>
		/// a string that represents the entire memory row
		/// </value>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string GetMemoryData(string address, MemoryFormat memformat, int start)
		{
			SetMemoryInfo(address,memformat);
			
			Controls.MemoryBaseEditor.SetFocus();
			Mouse.Click(Controls.MemoryBaseEditor.Cursor.XPos(),Controls.MemoryBaseEditor.Cursor.YPos());
			WaitForResponse(m_defaultTimeOut);
			
			// tab to start	
			for(int i=0;i < start;i++)
			{
				Keyboard.SendKeys("{TAB}");
			}
			
			Attributes.EditValue.Execute();
			string temp = Controls.MemoryBaseEditor.Cursor.SelectedText(true);
			Keyboard.SendKeys("{ESC}");

			return temp;
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// SetMemoryData sets the value of a memory unit based on the MemoryFormat size.
		/// 
		/// usgae:
		/// 
		/// my_memory.SetMemoryData("ConsoleApplication4.Class1.Main(string[]) + 0x00000000",new MemoryFormat(),1,"5");
		///
		/// </summary>
		/// <param name="address">the memory address to set in the memory window</param>
		/// <param name="memformat">the MemoryFormat object that tells what setting to apply in the memory window</param>
		/// <param name="start">the memory unit offset, this number relates to memory units, not to characters,if the memory window is set to 4 columns then there will be 4 memory units in a row</param>
		/// <param name="data">the data to type into the memory unit </param>
		/// <history>
		///			[bboris] 1/30/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SetMemoryData(string address, MemoryFormat memformat, int start, string data)
		{
			SetMemoryInfo(address,memformat);

			Controls.MemoryBaseEditor.SetFocus();
			Mouse.Click(MouseClickType.SingleClick,MouseFlags.LeftButton,Controls.MemoryBaseEditor.Cursor.XPos(),Controls.MemoryBaseEditor.Cursor.YPos());
			
			// tab to start	
			for(int i=0;i < start;i++)
			{
				Keyboard.SendKeys("{TAB}");
			}

			Attributes.EditValue.Execute();
			Keyboard.SendKeys(data + "{ENTER}");
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\VariableWindow.cs ===
using System;
using System.ComponentModel;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using Maui.VisualStudio.Everett.Debugger.Controls;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: AutosWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------

	#region Controls and Verification Interfaces
	
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IVariableWindowControls
	{
		VariableTreeGrid VariableWindowTreeGrid { get; }
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IVariableWindowVerification
	{
		bool VerifyAll(string[,] expected);
		bool VerifyAll(string[,] expected, bool caseSensitive, bool matchWholeString);
	}

#endregion

	///-----------------------------------------------------------------------------
	/// <summary>
	/// Base class for specific Variable Windows - Autos, Locals, Watch.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public abstract class VariableWindow : Everett.Ide.ToolWindows.ToolWindow, IVariableWindowControls, IVariableWindowVerification
	{

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new VariableWindow
		/// </summary>
		/// <param name="cmd">DTE Command to raise to open the window</param>
		/// <param name="caption">Expected Caption of opened window</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableWindow(string cmd, string caption) : base(CoreManager.ActiveApp, caption, cmd)
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Creates a new VariableWindow
		/// </summary>
		/// <param name="app">App to create instance in</param>
		/// <param name="cmd">DTE Command to raise to open the window</param>
		/// <param name="caption">Expected Caption of opened window</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableWindow(IDEApp app, string cmd, string caption) : base(app, caption, cmd)
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Container for controls inside the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IVariableWindowControls Controls
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verification methods
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IVariableWindowVerification Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Gets the TreeGrid control in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		VariableTreeGrid IVariableWindowControls.VariableWindowTreeGrid
		{
			get
			{
				return new VariableTreeGrid(this);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the VariableRow specified by the index
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[int index]
		{
			get
			{
				return this.Controls.VariableWindowTreeGrid[index];
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the VariableRow specified by the text
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[string name]
		{
			get
			{
				return this.Controls.VariableWindowTreeGrid[name];
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer that gets the VariableRow specified by the text
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VariableRow this[string name, int instance]
		{
			get
			{
				return this.Controls.VariableWindowTreeGrid[name, instance];
			}
		}

		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the count of rows in the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int RowCount
		{
			get
			{
				return this.Controls.VariableWindowTreeGrid.RowCount;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies all rows in the window against the given array of values
		/// </summary>
		/// <param name="expected">2D array of expected rows values</param>
		/// <returns>true if all info matches expected</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableWindowVerification.VerifyAll(string[,] expected)
		{
			return this.Verify.VerifyAll(expected, true, true);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies all rows in the window against the given array of values
		/// </summary>
		/// <param name="expected">2D array of expected rows values</param>
		/// <param name="caseSensitive">performs a case-sensitive compare</param>
		/// <param name="matchWholeString">only passes if entire string mathces</param>
		/// <returns>true if all info matches expected</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IVariableWindowVerification.VerifyAll(string[,] expected, bool caseSensitive, bool matchWholeString)
		{
			bool verified = true;
			RowExpandState expandState;

			for( int i=0; i<=expected.GetUpperBound(0); i++ )
			{
				expandState = this.Controls.VariableWindowTreeGrid[i].GetExpandStateFromText(expected[i, 0]);

				if( !this.Controls.VariableWindowTreeGrid[i].Verify.Verify(expandState, expected[i, 1], expected[i, 2], expected[i, 3], caseSensitive, matchWholeString) )
					verified = false;
			}

			return verified;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\WatchWindow.cs ===
using System;
using System.Runtime.Serialization;
using Maui.GlobalExceptions;
using Maui.Core;
using Maui.VisualStudio.Everett;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: WatchWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Automation class for the Debugger Locals window.
	/// </summary>
	/// <remarks></remarks>
	/// <history>
	/// 	[davebarn]	11/12/2002	Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class WatchWindow : VariableWindow
	{

		#region Exceptions
		public new class Exceptions : Maui.VisualStudio.Everett.Ide.ToolWindows.ToolWindow.Exceptions
		{
			[Serializable]
				public class InvalidIndexException : MauiException
			{
				public InvalidIndexException(string message) : base(message) {}

				protected InvalidIndexException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

#region Constants

		protected class Strings
		{
			public const string WindowCaption = "VSDebugUI.dll:6:6:3";
		}

#endregion

#region Constructors

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens Watch 1 for the ActiveApp
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsWatch1, GenerateCaption(CoreManager.ActiveApp, 1))
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens Watch 1 for the passed in app
		/// </summary>
		/// <param name="app">Application to open window for</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow(IDEApp app) : base(app, Constants.Commands.ViewDebugWindowsWatch1, GenerateCaption(app, 1))
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the selected watch window (1-4) for the active app
		/// </summary>
		/// <param name="index">Watch window to open</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow(int index) : base(CoreManager.ActiveApp, PickCommand(index), GenerateCaption(CoreManager.ActiveApp, index))
		{}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Opens the selected watch window (1-4) for the passed-in app
		/// </summary>
		/// <param name="app">Application to open window for</param>
		/// <param name="index">Watch window to open</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public WatchWindow(IDEApp app, int index) : base(app, PickCommand(index), GenerateCaption(app, index))
		{}

#endregion

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to return DTE command of specified watch window
		/// </summary>
		/// <param name="index">Watch window to get command for</param>
		/// <returns>DTE RaiseCmd command string</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string PickCommand(int index) 
		{
			switch( index )
			{
				case 1 : return Constants.Commands.ViewDebugWindowsWatch1;
				case 2 : return Constants.Commands.ViewDebugWindowsWatch2;
				case 3 : return Constants.Commands.ViewDebugWindowsWatch3;
				case 4 : return Constants.Commands.ViewDebugWindowsWatch4;
				default : throw new Exceptions.InvalidIndexException("Invalid watch window index.");
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper function to get caption for specified watch window
		/// </summary>
		/// <param name="app">The application.</param>
		/// <param name="index">Watch window to get caption for</param>
		/// <returns>Watch window caption</returns>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private static string GenerateCaption(IDEApp app, int index) 
		{
			return app.GetIntlStr(Strings.WindowCaption).Replace("%1", index.ToString());
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Adds one or more watches to bottom of watch window
		/// </summary>
		/// <param name="expression">List of watches to add</param>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Add(params string[] expression)
		{
			// TODO: figure out away not to do this:
			// Paste is failing sometimes.  Try clicking in window in ensure focus
			Mouse.Click(this.Extended.Right - 20, this.Extended.Top + 45);

			// Goto end of the watch window
			this.App.SendKeys("{END}");

			// Create expression list and paste into watch window
			string vars = string.Join("\r\n", expression);

			// Paste the expressions in to the window
			Clipboard.Text = vars;
			this.App.SendKeys("^(v)");
			this.WaitForResponse();
			this.App.MainWindow.WaitForResponse();
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Deletes all watches from the window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[davebarn] 11/12/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void DeleteAll()
		{
			this.App.SendKeys("{HOME}+{END}");
			this.App.SendKeys("{DELETE}");
			this.WaitForResponse();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\vsjitdebugger\JitDebuggeeApp.cs ===
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.VsJitDebugger
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger.VsJitDebugger
	/// Class		: VsJitDebuggerApp
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Start Jit debuggee which cause exception and JIT debugging sequence.
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 2/13/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class JitDebuggeeApp : Maui.Core.App
	{
		#region constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// This will launch debuggee app
		/// </summary>
		/// <param name="debuggeePath">Path of Jit debuggee exe</param>
		/// <param name="hasWindow">indicate whether it has window or not.</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/13/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public JitDebuggeeApp(string debuggeePath,bool hasWindow) : base(debuggeePath,hasWindow) 
		{
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\vsjitdebugger\vsjitdebuggerapp.cs ===
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.VsJitDebugger
{
	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger.VsJitDebugger
	/// Class		: VsJitDebuggerApp
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// this is UI class for JIT debugging dialog from vsjitdebugger.exe
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 2/13/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class VsJitDebuggerApp : Maui.Core.App
	{

		#region private members
		const string VsJitDebuggerPath = "vsjitdebugger.exe";
		#endregion

		#region constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// VsJitDebugger process is created before creating this object because JIT
		/// debugging is started by external process which is launched before creation of
		/// this object. 
		/// </summary>
		/// <param name="PID"> PID of vsjitdebugger process</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VsJitDebuggerApp(int pId) : base(pId,true)
		{
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\ToolWindows\Thread.cs ===
using System;
using System.Collections;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;
using Maui.VisualStudio.Everett.Debugger.Dialogs;

namespace Maui.VisualStudio.Everett.Debugger.ToolWindows
{
	#region Interfaces
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IThreadsVerify
	{
		bool ActiveThread(int threadID, string name, string location, System.Threading.ThreadPriority priority, int suspend);
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IThreadVerify
	{
		bool VerifyThread(int threadID, string name, string location, System.Threading.ThreadPriority priority, int suspend);
	}
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger
	/// Class		: Threads
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class lets you use the Threads window's functionality
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Threads : DebuggerToolWindow, IThreadsVerify
	{
		#region Constant(control ID/command), private members
		private const string ThreadsCaption = "VSDebugUI.dll:6:6:0";

		// const strings for context menus....
		private const string SelectAllMenu = ":Select &All:CTMenuString:cmddefui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:31";
		private const string CopyMenu = ":&Copy:CTMenuString:cmddefui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:15";
		private const int m_defaultTimeOut = 10000;
		private Maui.VisualStudio.Everett.IDEApp m_app;
		private ThreadsCollection m_threads; 
		private ArrayList m_columnsList;
		#endregion

		#region constructors and help functions for constructors. 
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open threads window with default application. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Threads() : base(CoreManager.ActiveApp, Constants.Commands.ViewDebugWindowsThreads, CoreManager.ActiveApp.GetIntlStr(ThreadsCaption))
		{

			Init(Maui.VisualStudio.Everett.CoreManager.ActiveApp);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Open threads window with indicated application. 
		/// </summary>
		/// <param name="application">Maui.Everett.IDEApp</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Threads(Maui.VisualStudio.Everett.IDEApp application) : base(application, Constants.Commands.ViewDebugWindowsThreads, application.GetIntlStr(ThreadsCaption))
		{
			Init(application);
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Real constructor function.  
		/// </summary>
		/// <param name="application">application object</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void Init(Maui.VisualStudio.Everett.IDEApp application)
		{
			// set app
			m_app = application;
		
			// set focus on window. 
			this.Extended.SetFocus();
	
			m_threads = new ThreadsCollection(this);

			string[] columns = Controls.DebuggerToolWindowTreeGrid.GetColumns();
			m_columnsList = new ArrayList();
			foreach(string col in columns)
				m_columnsList.Add(col); 

		}

		#endregion

		#region Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns IThreadsVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public new IThreadsVerify Verify
		{
			get
			{
				return this;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the threads collection
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ThreadsCollection ThreadObjects
		{
			get
			{
				m_threads.ReloadThreads();
				return m_threads;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the list of column headers
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ArrayList ColumnsList
		{
			get
			{
				return m_columnsList;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the number of threads
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ThreadCount
		{
			get 
			{
				return this.Controls.DebuggerToolWindowTreeGrid.RowCount;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the index of the Active thread (0-based) and -1 if the active thread couldn't be found
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ActiveThreadIndex
		{
			get 
			{
				for (int i= 0; i< this.ThreadCount; i++)
					if(this.ThreadObjects[i].IsActive)
						return i;
				return -1;		
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// return Context menu  
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/25/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Maui.Core.WinControls.Menu ContextMenu
		{
			get
			{
				return new Maui.Core.WinControls.Menu(Maui.Core.WinControls.ContextMenuAccessMethod.ShiftF10);
			}
		}
		#endregion


		#region implementation of IThreadsVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verifies the properties of the thread that is currently active
		/// </summary>
		/// <param name="threadID">Current thread's ID </param>
		/// <param name="name">Current frame's name</param>
		/// <param name="location">Current thread's location</param>
		/// <param name="priority">Current thread's priority</param>
		/// <param name="suspend">Current thread's suspend status</param>		
		/// <remarks></remarks>
		/// <history>[mkoller] 11/11/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IThreadsVerify.ActiveThread(int threadID, string name, string location, System.Threading.ThreadPriority priority, int suspend)
		{
			int activeThreadIndex = ActiveThreadIndex;
			if(activeThreadIndex >= 0)
				return ThreadObjects[activeThreadIndex].Verify.VerifyThread(threadID, name, location, priority, suspend);
			else
			{
				return false;
			}

		}


		#endregion

		#region Member functions

		///-----------------------------------------------------------------------------
		/// <summary>
		/// SelectAll 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SelectAll()
		{
			ContextMenu[App.GetIntlStr(SelectAllMenu)].Execute();
			this.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Copies all the selected threads 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------

		public void Copy()
		{
			ContextMenu[App.GetIntlStr(CopyMenu)].Execute();
			this.WaitForResponse();
		}
		#endregion
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class represents a thread object in the Threads window and it exposes the functionality that can be performed on a thread
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class Thread : Maui.VisualStudio.Everett.Debugger.Controls.DebuggerToolRow, IThreadVerify
	{
		#region Constants for priorities
		private const string Highest = "cpde.dll:6:65:10"; //"Highest";
		private const string Normal = "cpde.dll:6:65:9"; //"Normal";
		private const string Lowest = "cpde.dll:6:65:7"; //"Lowest";
		private const string AboveNormal = "cpde.dll:6:65:11"; //"Above Normal";
		private const string BelowNormal = "cpde.dll:6:65:8"; //"Below Normal";


		#endregion

		#region Constants for Column names
		private const string IDColumnName = "VSDebugUI.dll:6:2:3";
		private const string NameColumnName = "VSDebugUI.dll:6:5:5";
		private const string LocationColumnName = "VSDebugUI.dll:6:5:9";
		private const string PriorityColumnName = "VSDebugUI.dll:6:5:14";
		private const string SuspendColumnName = "VSDebugUI.dll:6:5:11";
		private const string CopyMenu = ":&Copy:CTMenuString:cmddefui.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:15";
		private const string SwitchToThreadMenu = ":&Switch To Thread:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:313";
		private const string FreezeMenu = ":&Freeze:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:311";
		private const string ThawMenu = ":&Thaw:CTMenuString:VSDebugUI.dll:1000:1684892995:{5EFC7975-14BC-11CF-9B2B-00AA00573819}:312";
		#endregion

		#region Private variables
		private string m_name;
		private int m_threadID;
		private string m_location;
		private System.Threading.ThreadPriority m_priority;
		private int m_suspend;
		private int m_index; 
		private Threads m_threadsWindowParent;
		#endregion

		#region Constructor

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for the Thread object
		/// </summary>
		/// <param name="threadsWindowParent">the parent Threads window</param>
		/// <param name="index">the 0-based index of the Thread in the Threads window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Thread(Threads threadsWindowParent, int index) : base( threadsWindowParent.Controls.DebuggerToolWindowTreeGrid, index)
		{
			m_threadsWindowParent = threadsWindowParent;
			m_index = index;

		}
		#endregion

		#region Public Properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns IThreadVerify interface. 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public new IThreadVerify Verify
		{
			get
			{
				return this;
			}
		}		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the index of a thread (0-based)
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int Index
		{			
			get
			{
				return m_index;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Name column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Name
		{
			get
			{
				m_name = Value[m_threadsWindowParent.ColumnsList.IndexOf(m_threadsWindowParent.App.GetIntlStr(NameColumnName))];
				return m_name;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Location column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public string Location
		{
			get
			{
				m_location = Value[m_threadsWindowParent.ColumnsList.IndexOf(m_threadsWindowParent.App.GetIntlStr(LocationColumnName))];
				return m_location;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the ID column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int ID
		{
			get
			{
				m_threadID = Convert.ToInt32(Value[m_threadsWindowParent.ColumnsList.IndexOf(m_threadsWindowParent.App.GetIntlStr(IDColumnName))]);
				return m_threadID;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Prority column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public System.Threading.ThreadPriority Priority
		{
			get
			{
				string priorityColValue = Value[m_threadsWindowParent.ColumnsList.IndexOf(m_threadsWindowParent.App.GetIntlStr(PriorityColumnName))];
				if(priorityColValue == m_threadsWindowParent.App.GetIntlStr(Highest))
					m_priority = System.Threading.ThreadPriority.Highest;
				else if(priorityColValue == m_threadsWindowParent.App.GetIntlStr(Normal))
					m_priority = System.Threading.ThreadPriority.Normal;
				else if(priorityColValue == m_threadsWindowParent.App.GetIntlStr(Lowest))
					m_priority = System.Threading.ThreadPriority.Lowest;
				else if(priorityColValue == m_threadsWindowParent.App.GetIntlStr(AboveNormal))
					m_priority = System.Threading.ThreadPriority.AboveNormal;
				else if(priorityColValue == m_threadsWindowParent.App.GetIntlStr(BelowNormal))
					m_priority = System.Threading.ThreadPriority.BelowNormal;
				return m_priority;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the value of the Suspend column
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int Suspend
		{
			get
			{
				m_suspend = Convert.ToInt32(Value[m_threadsWindowParent.ColumnsList.IndexOf(m_threadsWindowParent.App.GetIntlStr(SuspendColumnName))]);
				return m_suspend;
			}
		}
		
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns true if the thread is the active one
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool IsActive
		{
			get
			{
				return (bool)(Value[0] == ">");
			}
		}
		#endregion


		#region Implementation of IThreadVerify
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Verify the Function and Language are the exact strings specified 
		/// </summary>
		/// <param name="functionName">the exact name expected</param>
		/// <remarks></remarks>
		/// <param name="language">the exact language expected</param>	
		/// <history>[mkoller] 11/21/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		bool IThreadVerify.VerifyThread(int threadID, string name, string location, System.Threading.ThreadPriority priority, int suspend)
		{
			bool isTheSame = true;
			if(threadID != ID)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure, "Actual value of ID column: " + ID.ToString() +  " does not match expected value: " + threadID.ToString());
				isTheSame = false;
			}
			if(name != Name)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Name column: " + Name + " does not match expected value: " + name);
				isTheSame = false;
			}
			if(location != Location)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Location column: " + Location +  " does not match expected value: " + location);
				isTheSame = false;
			}
			if(priority != Priority)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Priority column: " + Priority.ToString() +  " does not match expected value: " + priority.ToString());
				isTheSame = false;
			}
			if(suspend != Suspend)
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Actual value of Suspend column: " + Suspend.ToString() +  " does not match expected value: " + suspend.ToString());
				isTheSame = false;
			}

			return isTheSame;
		}
		#endregion

		#region Public member functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Switches to this thread 
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void SwitchToThread()
		{
			this.Select();
			m_threadsWindowParent.ContextMenu[m_threadsWindowParent.App.GetIntlStr(SwitchToThreadMenu)].Execute();
			m_threadsWindowParent.WaitForResponse();
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Freezes this thread; returns false if the thread is already frozen
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Freeze()
		{
			this.Select();
			if(this.Suspend == 0)
			{
				m_threadsWindowParent.ContextMenu[m_threadsWindowParent.App.GetIntlStr(FreezeMenu)].Execute();
				m_threadsWindowParent.WaitForResponse();
				return true;
			}
			else
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Thread with index " + this.Index + " is already frozen");
				return false;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Thaws this thread; returns false if the thread is already active
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public bool Thaw()
		{
			this.Select();
			if(this.Suspend != 0)
			{
				m_threadsWindowParent.ContextMenu[m_threadsWindowParent.App.GetIntlStr(ThawMenu)].Execute();
				m_threadsWindowParent.WaitForResponse();
				return true;
			}
			else
			{
				LogManager.WriteEntry(Maui.TestLog.EntryType.Failure,"Thread with index " + this.Index + " is already thawed");
				return false;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Copy this frame to clipboard
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 10/31/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void Copy()
		{
			this.Select();
			m_threadsWindowParent.ContextMenu[m_threadsWindowParent.App.GetIntlStr(CopyMenu)].Execute();
			m_threadsWindowParent.WaitForResponse();
		}
		#endregion
	}

	///-----------------------------------------------------------------------------
	/// <summary>
	/// This class represents a colection of thread objects
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkoller] 10/31/2002 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class ThreadsCollection : Maui.Core.RemotingObject
	{

		#region Constructor
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor for the Threads collection
		/// </summary>
		///<param name="threadsWindowParent">an instance of the parent Threads Window</param>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public ThreadsCollection(Threads threadsWindowParent)
		{
			m_threadsWindowParent = threadsWindowParent;
				
		}
		#endregion

		#region Private member variables and functions
		private Threads m_threadsWindowParent;
		private Thread[] m_threads;



		#endregion

		#region public properties and functions
		///-----------------------------------------------------------------------------
		/// <summary>
		/// LoadThreads - loads the array of Thread objects from the TreeGrid control
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public void ReloadThreads()
		{
			if(m_threads != null)
				m_threads = null;
			m_threads = new Thread[this.Count];
			for(int i=0; i< this.Count; i++)
				m_threads[i] = new Thread(m_threadsWindowParent,i);
		
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Indexer
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public Thread this[int index]
		{
			get
			{
				return m_threads[index];
			}
			set
			{
				m_threads[index] = value;
			}
		}
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Returns the number of thread objects in the Threads window
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkoller] 11/18/2002 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public int Count
		{
			get
			{
				return m_threadsWindowParent.Controls.DebuggerToolWindowTreeGrid.RowCount;
			}
		}
		#endregion
	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\animctrl.cpp ===
// animctrl.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "animctrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrlPage property page

CAnimateCtrlPage::CAnimateCtrlPage()
	: CPropertyPage(CAnimateCtrlPage::IDD),
	m_dwStyle(WS_CHILD|WS_VISIBLE|ACS_CENTER)
{
	//{{AFX_DATA_INIT(CAnimateCtrlPage)
	m_cstrFileName = _T("");
	m_bCentered = TRUE;
	m_bTransparent = FALSE;
	m_bAutoplay = FALSE;
	//}}AFX_DATA_INIT
	//m_psp.dwFlags &= ~PSP_HASHELP;  // Lose the Help button
}

void CAnimateCtrlPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAnimateCtrlPage)
	DDX_Check(pDX, IDC_CENTER, m_bCentered);
	DDX_Check(pDX, IDC_TRANSPARENT, m_bTransparent);
	DDX_Check(pDX, IDC_AUTOPLAY, m_bAutoplay);
	DDX_Text(pDX, IDC_EDIT1, m_cstrFileName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAnimateCtrlPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAnimateCtrlPage)
	ON_EN_KILLFOCUS(IDC_EDIT1, OnFileChange)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	ON_BN_CLICKED(IDC_CENTER, OnCenter)
	ON_BN_CLICKED(IDC_TRANSPARENT, OnTransparent)
	ON_BN_CLICKED(IDC_AUTOPLAY, OnAutoplay)
	ON_BN_CLICKED(IDC_PLAY, OnPlay)
	ON_BN_CLICKED(IDC_STOP, OnStop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrlPage message handlers
BOOL CAnimateCtrlPage::OnInitDialog()
{
	if(!CPropertyPage::OnInitDialog())
		return FALSE;

	// Create animation control inside static frame.
	// This is necessary to avoid having the animation control
	// "overflow" the rectangle assigned to it when the
	// ACS_CENTER style is removed.

	CWnd* pFrame = GetDlgItem(IDC_ANIMFRAME);
	pFrame->GetClientRect(&m_rectAnimateCtrl);
	m_AnimateCtrl.Create(m_dwStyle, m_rectAnimateCtrl, pFrame, IDC_ANIMATE);

	return TRUE;
}

void CAnimateCtrlPage::OnFileChange()
{
	UpdateData();
	CFileStatus filestatus;
	if(CFile::GetStatus(m_cstrFileName, filestatus))
		ApplyChanges();
}

void CAnimateCtrlPage::OnBrowse()
{
	CFileDialog dlg( TRUE,_T("AVI"),_T("*.AVI"),
					 OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT,
					 _T("Animation (*.AVI)|*.AVI|"));

	if( dlg.DoModal()==IDOK )
	{
		m_cstrFileName = dlg.GetPathName();
		UpdateData(FALSE);
		ApplyChanges();
	}
}

void CAnimateCtrlPage::OnCenter()
{
	UpdateData();
	if( m_bCentered )
		m_dwStyle |= ACS_CENTER;
	else
		m_dwStyle &= ~ACS_CENTER;
	ApplyChanges();
}

void CAnimateCtrlPage::OnTransparent()
{
	UpdateData();
	if( m_bTransparent )
		m_dwStyle |= ACS_TRANSPARENT;
	else
		m_dwStyle &= ~ACS_TRANSPARENT;
	ApplyChanges();
}

void CAnimateCtrlPage::OnAutoplay()
{
	UpdateData();
	if( m_bAutoplay )
		m_dwStyle |= ACS_AUTOPLAY;
	else
		m_dwStyle &= ~ACS_AUTOPLAY;
	ApplyChanges();
}

void CAnimateCtrlPage::OnPlay()
{
	// From frame: 1, To frame: end (0xFFFF, or -1),
	// Play once (1)
	m_AnimateCtrl.Play(0,0xFFFF,1);
}

void CAnimateCtrlPage::OnStop()
{
	m_AnimateCtrl.Stop();
}

void CAnimateCtrlPage::ApplyChanges()
{
	// Stop any current animation and close the animation file
	m_AnimateCtrl.Stop();
	m_AnimateCtrl.Close();

	// Set the new style
	::SetWindowLong(m_AnimateCtrl.GetSafeHwnd(), GWL_STYLE, m_dwStyle);
	// A call to SetWindowPos forces the window to re-read its style
	m_AnimateCtrl.SetWindowPos(NULL, 0, 0, m_rectAnimateCtrl.Width(), m_rectAnimateCtrl.Height(),
							   SWP_NOZORDER|SWP_NOMOVE|SWP_NOACTIVATE|SWP_SHOWWINDOW);

	m_AnimateCtrl.Open(m_cstrFileName);
	// force repaint of the portion of the property page occupied by the control
	InvalidateRect(&m_rectAnimateCtrl);
	UpdateWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\animctrl.h ===
// animctrl.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _ANIMCTRL_H
#define _ANIMCTRL_H

/////////////////////////////////////////////////////////////////////////////
// CAnimateCtrlPage dialog

class CAnimateCtrlPage : public CPropertyPage
{
// Construction
public:
	CAnimateCtrlPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAnimateCtrlPage)
	enum { IDD = IDD_ANIMCTRL };
	CString m_cstrFileName;
	BOOL m_bCentered;
	BOOL m_bTransparent;
	BOOL m_bAutoplay;
	//}}AFX_DATA
	CAnimateCtrl m_AnimateCtrl;
	CRect m_rectAnimateCtrl;
	DWORD m_dwStyle;   // control styles
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAnimateCtrlPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	void ApplyChanges();

	// Generated message map functions
	//{{AFX_MSG(CAnimateCtrlPage)
	afx_msg void OnFileChange();
	afx_msg void OnBrowse();
	afx_msg void OnCenter();
	afx_msg void OnTransparent();
	afx_msg void OnAutoplay();
	afx_msg void OnPlay();
	afx_msg void OnStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\CmnCtrl1.cpp ===
// CmnCtrl1.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
#include "stdafx.h"
#include "CmnCtrl1.h"
#include "propsht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCmnCtrl1App

BEGIN_MESSAGE_MAP(CCmnCtrl1App, CWinApp)
	//{{AFX_MSG_MAP(CCmnCtrl1App)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCmnCtrl1App construction

CCmnCtrl1App::CCmnCtrl1App()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCmnCtrl1App object

CCmnCtrl1App theApp;

/////////////////////////////////////////////////////////////////////////////
// CCmnCtrl1App initialization

BOOL CCmnCtrl1App::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization

	CAllControlsSheet   allcontrolssheet(_T("Common Controls Sample"));
	m_pMainWnd = &allcontrolssheet;
	allcontrolssheet.DoModal();
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\CmnCtrl1.h ===
// CmnCtrl1.h : main header file for the CMNCTRL1 application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#if !defined(AFX_CMNCTRL1_H__A14ECE83_E24D_11D0_8286_00C04FD73634__INCLUDED_)
#define AFX_CMNCTRL1_H__A14ECE83_E24D_11D0_8286_00C04FD73634__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCmnCtrl1App:
// See CmnCtrl1.cpp for the implementation of this class
//
#define CELEMS(rgFoo) (sizeof(rgFoo) / sizeof(rgFoo[0]))

class CCmnCtrl1App : public CWinApp
{
public:
	CCmnCtrl1App();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCmnCtrl1App)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCmnCtrl1App)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CMNCTRL1_H__A14ECE83_E24D_11D0_8286_00C04FD73634__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\DateTime.cpp ===
// DateTime.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "RESOURCE.H"
#include "DateTime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDateTimePage property page

IMPLEMENT_DYNCREATE(CDateTimePage, CPropertyPage)

CDateTimePage::CDateTimePage() : CPropertyPage(CDateTimePage::IDD)
{
	//{{AFX_DATA_INIT(CDateTimePage)
	m_bAppCanParse = FALSE;
	m_bShowNone = FALSE;
	m_bUpDown = FALSE;
	//}}AFX_DATA_INIT
	//m_psp.dwFlags &= ~PSP_HASHELP;  // Lose the Help button
}

CDateTimePage::~CDateTimePage()
{
}

void CDateTimePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDateTimePage)
	DDX_Check(pDX, IDC_CKAPPCANPARSE, m_bAppCanParse);
	DDX_Check(pDX, IDC_CKSHOWNONE, m_bShowNone);
	DDX_Check(pDX, IDC_CKUPDOWN, m_bUpDown);
	//}}AFX_DATA_MAP
	DDX_Control(pDX,IDC_LBNOTIFY,m_lbNotifyList);
}


BEGIN_MESSAGE_MAP(CDateTimePage, CPropertyPage)
	//{{AFX_MSG_MAP(CDateTimePage)
	ON_BN_CLICKED(IDC_CKUPDOWN, OnCkupdown)
	ON_BN_CLICKED(IDC_CKTIMEFORMAT, OnCktimeformat)
	ON_BN_CLICKED(IDC_CKSHORTDATEFORMAT, OnCkshortdateformat)
	ON_BN_CLICKED(IDC_CKSHOWNONE, OnCkshownone)
	ON_BN_CLICKED(IDC_CKLONGDATEFORMAT, OnCklongdateformat)
	ON_BN_CLICKED(IDC_CKAPPCANPARSE, OnCkappcanparse)
	//}}AFX_MSG_MAP
	ON_NOTIFY(DTN_CLOSEUP,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_DATETIMECHANGE,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_DROPDOWN ,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_FORMAT,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_FORMATQUERY,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_USERSTRING,IDC_DATETIME, OnDTNotify)
	ON_NOTIFY(DTN_WMKEYDOWN ,IDC_DATETIME, OnDTNotify)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDateTimePage message handlers

BOOL CDateTimePage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	CWnd *pWnd = GetDlgItem(IDC_DTFRAME);
	CRect rc;
	if(!pWnd) return TRUE;
	pWnd->GetWindowRect(rc);
	pWnd->DestroyWindow(); //pWnd was just a placeholder;
	ScreenToClient(rc);
	m_DateTime.Create(WS_CHILD|WS_VISIBLE|DTS_SHORTDATEFORMAT,rc,this,IDC_DATETIME);
	m_nPrevStyle=DTS_SHORTDATEFORMAT;
	SetCheck(IDC_CKSHORTDATEFORMAT);


	return TRUE;
}

void CDateTimePage::OnCkupdown()
{
	UpdateData(TRUE);

	if(m_bUpDown)
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle |= DTS_UPDOWN;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);
	}
	else
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle &= ~DTS_UPDOWN;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);
	}

}





void CDateTimePage::OnCkshownone()
{
	UpdateData(TRUE);
	if(m_bShowNone)
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle |= DTS_SHOWNONE;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);

	}
	else
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle &= ~DTS_SHOWNONE;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);
	}

}



void CDateTimePage::OnCkappcanparse()
{
	UpdateData(TRUE);
	if(m_bAppCanParse)
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle |= DTS_APPCANPARSE;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);
	}
	else
	{
		CRect rc;
		m_DateTime.GetWindowRect(rc);
		long lStyle = ::GetWindowLong(m_DateTime.m_hWnd,GWL_STYLE);
		lStyle &= ~DTS_APPCANPARSE;
		m_DateTime.DestroyWindow();
		ScreenToClient(rc);
		m_DateTime.Create(lStyle,rc,this,IDC_DATETIME);
	}

}

void CDateTimePage::OnCkshortdateformat()
{
	SetCheck(IDC_CKSHORTDATEFORMAT);
	//remove previous format style
	m_DateTime.ModifyStyle(m_nPrevStyle,0);
	//set this style
	m_DateTime.ModifyStyle(0,DTS_SHORTDATEFORMAT,SWP_NOSIZE);
	m_nPrevStyle=DTS_SHORTDATEFORMAT;
}
void CDateTimePage::OnCklongdateformat()
{
	SetCheck(IDC_CKLONGDATEFORMAT);

	//remove previous format style
	m_DateTime.ModifyStyle(m_nPrevStyle,0);
	//set this style
	m_DateTime.ModifyStyle(0,DTS_LONGDATEFORMAT,SWP_NOSIZE);
	m_nPrevStyle=DTS_LONGDATEFORMAT;
}
void CDateTimePage::OnCktimeformat()
{
	SetCheck(IDC_CKTIMEFORMAT);

	//remove previous format style
	m_DateTime.ModifyStyle(m_nPrevStyle,0);
	//set this style
	m_DateTime.ModifyStyle(0,DTS_TIMEFORMAT,SWP_NOSIZE);
	m_nPrevStyle=DTS_TIMEFORMAT;
}
void CDateTimePage::SetCheck(UINT idBtn)
{
	static UINT buttons []={IDC_CKTIMEFORMAT,IDC_CKLONGDATEFORMAT,IDC_CKSHORTDATEFORMAT};
	CButton *pBtn=NULL;
	for(int i=0;i<3;i++)
	{
		pBtn = (CButton*)GetDlgItem(buttons[i]);
		if(!pBtn) continue;

		if(buttons[i]==idBtn)
			pBtn->SetCheck(1);
		else
			pBtn->SetCheck(0);
	}

}

void CDateTimePage::OnDTNotify(NMHDR *pHdr, LRESULT * /*pRes*/)
{
	switch( pHdr->code)
	{
	case DTN_CLOSEUP:
		m_lbNotifyList.AddString(_T("DTN_CLOSEUP"));
		break;
	case DTN_DATETIMECHANGE:
		m_lbNotifyList.AddString(_T("DTN_DATETIMECHANGE"));
		break;
	case DTN_DROPDOWN:
		m_lbNotifyList.AddString(_T("DTN_DROPDOWN"));
		break;
	case DTN_FORMAT:
		m_lbNotifyList.AddString(_T("DTN_FORMAT"));
		break;
	case DTN_FORMATQUERY:
		m_lbNotifyList.AddString(_T("DTN_FORMATQUERY"));
		break;
	case DTN_USERSTRING:
		m_lbNotifyList.AddString(_T("DTN_USERSTRING"));
		break;
	case DTN_WMKEYDOWN:
		m_lbNotifyList.AddString(_T("DTN_WMKEYDOWN"));
		break;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Visual Studio\Everett\Maui.VisualStudio.Everett.Debugger\vsjitdebugger\vsjitdebuggerwindow.cs ===
using System;
using Maui.Core;
using Maui.GlobalExceptions;
using Maui.TestLog;
using Maui.VisualStudio.Everett;
using System.ComponentModel;

namespace Maui.VisualStudio.Everett.Debugger.VsJitDebugger
{
	#region Interfaces for QuickWatch 
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IVsJitDebuggerWindowControls
	{
		Maui.Core.WinControls.Button YesButton
		{
			get;
		}

		Maui.Core.WinControls.Button NoButton
		{
			get;
		}

		Maui.Core.WinControls.Control ExceptionLabel
		{
			get;
		}

		Maui.Core.WinControls.ListBox PossibleDebuggerListBox
		{
			get;
		}

		Maui.Core.WinControls.CheckBox SetCurrentAsDefaultCheckButton
		{
			get;
		}

		Maui.Core.WinControls.CheckBox ManualChooseDECheckButton
		{
			get;
		}
	}	
	#endregion

	///-----------------------------------------------------------------------------
	/// Project		: Maui.VisualStudio.Everett.Debugger.VsJitDebugger
	/// Class		: VsJitDebuggerWindow
	///
	/// Copyright (C) 2002, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// this is UI class for JIT debugging dialog from vsjitdebugger.exe
	/// </summary>
	/// <remarks></remarks>
	/// <history>[mkpark] 2/13/2003 Created
	/// </history>
	///-----------------------------------------------------------------------------
	public class VsJitDebuggerWindow : Maui.Core.Dialog, IVsJitDebuggerWindowControls
	{
		#region constant members
		public const string VSDebugger = "";
		public const string DBGCLR = "";
		public const string Rascal = "";
		#endregion

		#region private members for resources
		new const string Caption = ":Visual Studio Just-In-Time Debugger:Win32String:vsjitdebuggerui.dll:201";
		const string NewInstanceOf = ":New instance of :Win32String:vsjitdebuggerui.dll:210";

		const int PossibleDebuggerListBoxID = 0x190;
		const int ExceptionLabelID = 0x195;
		const int SetCurrentAsDefaultCheckButtonID = 0x192;
		const int ManualChooseDECheckButtonID = 0x197;
		const int YesButtonID = 0x6;
		const int NoButtonID = 0x7;
		#endregion

		#region constructors
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Looks for the dialog in Active app.
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		public VsJitDebuggerWindow(VsJitDebuggerApp app) : base(app,app.GetIntlStr(Caption),true)
		{
			this.SetFocus();
		}
		#endregion

		#region properties
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return IVsJitDebuggerWindowControls. 
		/// </summary>
		/// <value></value>
		/// <remarks></remarks>
		/// <history>
		/// 	[mkpark] 	2/12/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public IVsJitDebuggerWindowControls Controls
		{
			get
			{
				return this;
			}
		}
		#endregion

		#region IControls implementation
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Yes button object
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IVsJitDebuggerWindowControls.YesButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,YesButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return No button object
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Button IVsJitDebuggerWindowControls.NoButton
		{
			get
			{
				return new Maui.Core.WinControls.Button(this,NoButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return Exception information label control object
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.Control IVsJitDebuggerWindowControls.ExceptionLabel
		{
			get
			{
				return new Maui.Core.WinControls.Control(this,ExceptionLabelID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Return possible debugger list box object
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.ListBox IVsJitDebuggerWindowControls.PossibleDebuggerListBox
		{
			get
			{
				return new Maui.Core.WinControls.ListBox(this,PossibleDebuggerListBoxID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check box : "Set the currently selected debugger as the default
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.CheckBox IVsJitDebuggerWindowControls.SetCurrentAsDefaultCheckButton
		{
			get
			{
				return new Maui.Core.WinControls.CheckBox(this,SetCurrentAsDefaultCheckButtonID);
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Check box : "Manually coose the debugging engines
		/// </summary>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		Maui.Core.WinControls.CheckBox IVsJitDebuggerWindowControls.ManualChooseDECheckButton
		{
			get
			{
				return new Maui.Core.WinControls.CheckBox(this,ManualChooseDECheckButtonID);
			}
		}
		#endregion

		#region public methods
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Start JIt debugging with current debugger
		/// </summary>
		/// <param name="startWithNewInstance">indicate whether JIT debugging starts with new instance of debugger or not</param>
		/// <param name="debuggerName">debugger title should be passed, if it is null, the first non new instance will be selected</param>
		/// <param name="manualDESelect">if you want to select DE(Debug Engine) when JIT debugging session is started by this method. set it as "True"</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		///				  [mkpark] 2/24/2003 updated for new UI. 
		/// </history>
		///-----------------------------------------------------------------------------
		public void StartJITDebuggingWith(bool startWithNewInstance, string debuggerName,bool manualDESelect)
		{
			Controls.ManualChooseDECheckButton.Checked = manualDESelect;

			if(startWithNewInstance == true)
			{
				StartJITDebugging(App.GetIntlStr(NewInstanceOf) + debuggerName,true);
			}
			else
			{
				if(debuggerName == null)
				{
					StartJITDebugging(App.GetIntlStr(NewInstanceOf),false);
				}
				else
				{
					StartJITDebugging(debuggerName,true);
				}
			}
		}
		#endregion

		#region private methods
		///-----------------------------------------------------------------------------
		/// <summary>
		/// Start JIt debugging with the indicated debugger 
		/// </summary>
		/// <param name="debuggerName">title of debugger app</param>
		/// <param name="isMatched">select the matched one</param>
		/// <remarks></remarks>
		/// <history>[mkpark] 2/12/2003 Created
		/// </history>
		///-----------------------------------------------------------------------------
		private void StartJITDebugging(string debuggerName, bool isMatched)
		{
			if(isMatched ==true)
			{
				this.Controls.PossibleDebuggerListBox.SelectItem(debuggerName,false);
			}
			else
			{
				for(int i = 0 ; i < Controls.PossibleDebuggerListBox.Count; i++)
				{
					if(Controls.PossibleDebuggerListBox[i].Text.IndexOf(App.GetIntlStr(NewInstanceOf)) == -1)
					{
						Controls.PossibleDebuggerListBox.SelectItem(i);
					}
					else
					{
						continue;
					}
				}

			}

			Controls.YesButton.Click();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\DateTime.h ===
// DateTime.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.
#if !defined(AFX_DATETIME_H__39010224_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_)
#define AFX_DATETIME_H__39010224_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDateTimePage dialog

class CDateTimePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CDateTimePage)

// Construction
public:
	void OnDTNotify(NMHDR *pHdr, LRESULT *pRes);
	CListBox m_lbNotifyList;
	UINT m_nPrevStyle;
	void SetCheck(UINT idBtn);
	CDateTimeCtrl m_DateTime;
	CDateTimePage();
	~CDateTimePage();

// Dialog Data
	//{{AFX_DATA(CDateTimePage)
	enum { IDD = IDD_DATETIME };
	BOOL    m_bAppCanParse;
	BOOL    m_bShowNone;
	BOOL    m_bUpDown;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDateTimePage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDateTimePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCkupdown();
	afx_msg void OnCktimeformat();
	afx_msg void OnCkshortdateformat();
	afx_msg void OnCkshownone();
	afx_msg void OnCklongdateformat();
	afx_msg void OnCkappcanparse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DATETIME_H__39010224_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\MonthCal.cpp ===
// MonthCalPage.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "resource.h"

#include "MonthCal.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMonthCalPage property page

IMPLEMENT_DYNCREATE(CMonthCalPage, CPropertyPage)

CMonthCalPage::CMonthCalPage() : CPropertyPage(CMonthCalPage::IDD)
{
	//{{AFX_DATA_INIT(CMonthCalPage)
	m_nMaxSelCount = 0;
	m_pszRange = _T("");
	m_pszSelection = _T("");
	m_bDayState = FALSE;
	m_bNoToday = FALSE;
	m_bNoTodayCircle = FALSE;
	m_bWeekNumbers = FALSE;
	m_bMultiSelect = FALSE;
	//}}AFX_DATA_INIT
	//m_psp.dwFlags &= ~PSP_HASHELP;  // Lose the Help button
}

CMonthCalPage::~CMonthCalPage()
{
}

void CMonthCalPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMonthCalPage)
	DDX_Control(pDX, IDC_EDSELRANGE, m_edMaxSel);
	DDX_Control(pDX, IDC_NOTIFYLIST, m_NotifyList);
	DDX_Text(pDX, IDC_EDSELRANGE, m_nMaxSelCount);
	DDX_Text(pDX, IDC_STRRANGE, m_pszRange);
	DDX_Text(pDX, IDC_STRSELECTION, m_pszSelection);
	DDX_Check(pDX, IDC_CKDAYSTATE, m_bDayState);
	DDX_Check(pDX, IDC_CKNOTODAY, m_bNoToday);
	DDX_Check(pDX, IDC_CKNOTODAYCIRCLE, m_bNoTodayCircle);
	DDX_Check(pDX, IDC_CKWEEKNUMBERS, m_bWeekNumbers);
	DDX_Check(pDX, IDC_CMULTISELECT, m_bMultiSelect);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMonthCalPage, CPropertyPage)
	//{{AFX_MSG_MAP(CMonthCalPage)
	ON_BN_CLICKED(IDC_CKNOTODAY, OnCknotoday)
	ON_BN_CLICKED(IDC_CKNOTODAYCIRCLE, OnCknotodaycircle)
	ON_BN_CLICKED(IDC_CKWEEKNUMBERS, OnCkweeknumbers)
	ON_BN_CLICKED(IDC_CMULTISELECT, OnCmultiselect)
	ON_EN_CHANGE(IDC_EDSELRANGE, OnChangeEdselrange)
	ON_BN_CLICKED(IDC_CKDAYSTATE, OnCkdaystate)
	//}}AFX_MSG_MAP
	ON_NOTIFY(MCN_SELCHANGE,IDC_MONTHCAL,HandleSelChange)
	ON_NOTIFY(MCN_SELECT,IDC_MONTHCAL,HandleSelect)
	ON_NOTIFY(MCN_GETDAYSTATE,IDC_MONTHCAL,GetDayState)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMonthCalPage message handlers

BOOL CMonthCalPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	CWnd *pFrame = GetDlgItem(IDC_MCFRAME);
	CRect rcWnd;
	pFrame->GetClientRect(rcWnd);
	pFrame->DestroyWindow(); //pFrame was just a placeholder anyway.
	m_MonthCal.Create(WS_CHILD|WS_VISIBLE,CPoint(rcWnd.left,rcWnd.top),this,IDC_MONTHCAL);
	m_nMaxSelCount = m_MonthCal.GetMaxSelCount();
	UpdateData(FALSE);

	return TRUE;
}

void CMonthCalPage::OnCknotoday()
{
	UpdateData(TRUE);

	if(m_bNoToday)
	{
		//add style
		m_MonthCal.ModifyStyle(0,MCS_NOTODAY,SWP_NOSIZE);
	}
	else
	{
		//remove style
		m_MonthCal.ModifyStyle(MCS_NOTODAY,0,SWP_NOSIZE);
	}
	m_MonthCal.SizeMinReq();
}
void CMonthCalPage::OnCknotodaycircle()
{
	UpdateData(TRUE);
	if(m_bNoTodayCircle)
	{
		//add style
		m_MonthCal.ModifyStyle(0,MCS_NOTODAYCIRCLE,SWP_NOSIZE);
	}
	else
	{
		//remove style
		m_MonthCal.ModifyStyle(MCS_NOTODAYCIRCLE,SWP_NOSIZE);
	}

}
void CMonthCalPage::OnCkweeknumbers()
{
	UpdateData(TRUE);
	if(m_bWeekNumbers)
	{
		//add style
		m_MonthCal.ModifyStyle(0,MCS_WEEKNUMBERS,SWP_NOSIZE);
	}
	else
	{
		//remove style
		m_MonthCal.ModifyStyle(MCS_WEEKNUMBERS,SWP_NOSIZE);
	}
	m_MonthCal.SizeMinReq();

}

void CMonthCalPage::OnCmultiselect()
{
	UpdateData(TRUE);
	if(m_bMultiSelect)
	{
		long lStyle; CRect rc;
		lStyle = ::GetWindowLong(m_MonthCal.m_hWnd,GWL_STYLE);
		lStyle |= MCS_MULTISELECT;
		m_MonthCal.GetClientRect(rc);
		m_MonthCal.DestroyWindow();
		m_MonthCal.Create(lStyle,CPoint(rc.left,rc.top),this,IDC_MONTHCAL);
		m_nMaxSelCount = m_MonthCal.GetMaxSelCount();
		UpdateData(FALSE);
		m_edMaxSel.EnableWindow(TRUE);

	}
	else
	{
		//remove style
		long lStyle; CRect rc;
		lStyle = ::GetWindowLong(m_MonthCal.m_hWnd,GWL_STYLE);
		lStyle &= ~MCS_MULTISELECT;
		m_MonthCal.GetClientRect(rc);
		m_MonthCal.DestroyWindow();
		m_MonthCal.Create(lStyle,CPoint(rc.left,rc.top),this,IDC_MONTHCAL);
		m_nMaxSelCount = m_MonthCal.GetMaxSelCount();
		UpdateData(FALSE);
		m_edMaxSel.EnableWindow(FALSE);
	}

}

void CMonthCalPage::OnCkdaystate()
{
	UpdateData(TRUE);
	if(m_bDayState)
	{
		long lStyle; CRect rc;
		lStyle = ::GetWindowLong(m_MonthCal.m_hWnd,GWL_STYLE);
		lStyle |= MCS_DAYSTATE;
		m_MonthCal.GetClientRect(rc);
		m_MonthCal.DestroyWindow();
		m_MonthCal.Create(lStyle,CPoint(rc.left,rc.top),this,IDC_MONTHCAL);
		UpdateData(FALSE);

	}
	else
	{
		//remove style
		long lStyle; CRect rc;
		lStyle = ::GetWindowLong(m_MonthCal.m_hWnd,GWL_STYLE);
		lStyle &= ~MCS_DAYSTATE;
		m_MonthCal.GetClientRect(rc);
		m_MonthCal.DestroyWindow();
		m_MonthCal.Create(lStyle,CPoint(rc.left,rc.top),this,IDC_MONTHCAL);
		m_nMaxSelCount = m_MonthCal.GetMaxSelCount();
		UpdateData(FALSE);
	}
}

//Notification handlers for notifications from the MonthCal control
void CMonthCalPage::GetDayState(NMHDR *pHdr, LRESULT* /*pRes*/)
{
	NMDAYSTATE *pds = (NMDAYSTATE*)pHdr;
	m_NotifyList.AddString(_T("MCN_GETDAYSTATE"));
	//this function just bolds the first four days of every visible
	//month.
	for(int i=0;i<pds->cDayState;i++)
		pds->prgDayState[i]=0xf;

}

void CMonthCalPage::HandleSelect(NMHDR* /*pHdr*/, LRESULT* /*pRes*/)
{
	m_NotifyList.AddString(_T("MCN_SELECT"));
	if((m_MonthCal.GetStyle() & MCS_MULTISELECT))
		return;
	CTime ct;
	m_MonthCal.GetCurSel(ct);
	m_pszSelection.Format(_T("%02d/%02d/%2d"),ct.GetMonth(),ct.GetDay(),ct.GetYear());
	UpdateData(FALSE);

}

void CMonthCalPage::HandleSelChange(NMHDR* /*pHdr*/, LRESULT* /*pRes*/)
{

	m_NotifyList.AddString(_T("MCN_SELCHANGE"));
	if(! (m_MonthCal.GetStyle() & MCS_MULTISELECT))
		return;
	CTime ctmin,ctmax;
	m_MonthCal.GetSelRange(ctmin,ctmax);
	m_pszRange.Format(_T("%02d/%02d/%2d to %02d/%02d/%2d"), ctmin.GetMonth(),ctmin.GetDay(),ctmin.GetYear(),
								ctmax.GetMonth(),ctmax.GetDay(),ctmax.GetYear());
	UpdateData(FALSE);
}

//Handler for selection range edit control
void CMonthCalPage::OnChangeEdselrange()
{
	UpdateData(TRUE);
	m_MonthCal.SetMaxSelCount(m_nMaxSelCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\MonthCal.h ===
// MonthCalPage.h : header file for the CMNCTRL1 application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.



#if !defined(AFX_MONTHCALPAGE_H__39010223_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_)
#define AFX_MONTHCALPAGE_H__39010223_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CMonthCalPage dialog

class CMonthCalPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMonthCalPage)

// Construction
public:
	void HandleSelChange(NMHDR *pHdr, LRESULT *pRes);
	void HandleSelect(NMHDR *pHdr, LRESULT *pRes);
	void GetDayState(NMHDR *pHdr, LRESULT *pRes);
	CMonthCalPage();
	~CMonthCalPage();
	CMonthCalCtrl m_MonthCal;
// Dialog Data
	//{{AFX_DATA(CMonthCalPage)
	enum { IDD = IDD_MONTHCAL };
	CEdit   m_edMaxSel;
	CListBox    m_NotifyList;
	UINT    m_nMaxSelCount;
	CString m_pszRange;
	CString m_pszSelection;
	BOOL    m_bDayState;
	BOOL    m_bNoToday;
	BOOL    m_bNoTodayCircle;
	BOOL    m_bWeekNumbers;
	BOOL    m_bMultiSelect;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMonthCalPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMonthCalPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCknotoday();
	afx_msg void OnCknotodaycircle();
	afx_msg void OnCkweeknumbers();
	afx_msg void OnCmultiselect();
	afx_msg void OnChangeEdselrange();
	afx_msg void OnCkdaystate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MONTHCALPAGE_H__39010223_ECB6_11D0_8FEA_00A0C9034892__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\mtreectl.cpp ===
// MyTreeCtrl.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "mtreectl.h"
#include "treecpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyTreeCtrl

CMyTreeCtrl::CMyTreeCtrl()
{
	m_bDragging = FALSE;
	m_pimagelist = NULL;
}

CMyTreeCtrl::~CMyTreeCtrl()
{
}


BEGIN_MESSAGE_MAP(CMyTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CMyTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, OnEndLabelEdit)
	ON_NOTIFY_REFLECT(TVN_BEGINDRAG, OnBeginDrag)
	ON_NOTIFY_REFLECT(TVN_BEGINRDRAG, OnBeginDrag)
	ON_WM_MOUSEMOVE()
	ON_WM_DESTROY()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyTreeCtrl message handlers
void CMyTreeCtrl::OnDestroy()
{
	CImageList  *pimagelist;

	pimagelist = GetImageList(TVSIL_NORMAL);
	pimagelist->DeleteImageList();
	delete pimagelist;
}

void CMyTreeCtrl::SetNewStyle(long lStyleMask, BOOL bSetBits)
{
	long        lStyleOld;

	lStyleOld = GetWindowLong(m_hWnd, GWL_STYLE);
	lStyleOld &= ~lStyleMask;
	if (bSetBits)
		lStyleOld |= lStyleMask;

	SetWindowLong(m_hWnd, GWL_STYLE, lStyleOld);
	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
}

void CMyTreeCtrl::OnEndLabelEdit(LPNMHDR pnmhdr, LRESULT *pLResult)
{
	TV_DISPINFO     *ptvinfo;

	((CTreeCtrlPage *)GetParent())->ShowNotification(pnmhdr, pLResult);
	ptvinfo = (TV_DISPINFO *)pnmhdr;
	if (ptvinfo->item.pszText != NULL)
	{
		ptvinfo->item.mask = TVIF_TEXT;
		SetItem(&ptvinfo->item);
	}
	*pLResult = TRUE;
}

void CMyTreeCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	HTREEITEM           hitem;
	UINT                flags;

	if (m_bDragging)
	{
		ASSERT(m_pimagelist != NULL);
		m_pimagelist->DragMove(point);
		if ((hitem = HitTest(point, &flags)) != NULL)
		{
			m_pimagelist->DragLeave(this);
			SelectDropTarget(hitem);
			m_hitemDrop = hitem;
			m_pimagelist->DragEnter(this, point);
		}
	}

	CTreeCtrl::OnMouseMove(nFlags, point);
}

BOOL CMyTreeCtrl::IsChildNodeOf(HTREEITEM hitemChild, HTREEITEM hitemSuspectedParent)
{
	do
	{
		if (hitemChild == hitemSuspectedParent)
			break;
	}
	while ((hitemChild = GetParentItem(hitemChild)) != NULL);

	return (hitemChild != NULL);
}


BOOL CMyTreeCtrl::TransferItem(HTREEITEM hitemDrag, HTREEITEM hitemDrop)
{
	TV_INSERTSTRUCT     tvstruct;
	TCHAR               sztBuffer[50];
	HTREEITEM           hNewItem, hFirstChild;

		// avoid an infinite recursion situation
	tvstruct.item.hItem = hitemDrag;
	tvstruct.item.cchTextMax = 49;
	tvstruct.item.pszText = sztBuffer;
	tvstruct.item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
	GetItem(&tvstruct.item);  // get information of the dragged element
	tvstruct.hParent = hitemDrop;
	tvstruct.hInsertAfter = TVI_SORT;
	tvstruct.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
	hNewItem = InsertItem(&tvstruct);

	while ((hFirstChild = GetChildItem(hitemDrag)) != NULL)
	{
		TransferItem(hFirstChild, hNewItem);  // recursively transfer all the items
		DeleteItem(hFirstChild);        // delete the first child and all its children
	}
	return TRUE;
}

void CMyTreeCtrl::OnButtonUp()
{
	if (m_bDragging)
	{
		ASSERT(m_pimagelist != NULL);
		m_pimagelist->DragLeave(this);
		m_pimagelist->EndDrag();
		delete m_pimagelist;
		m_pimagelist = NULL;

		if (m_hitemDrag != m_hitemDrop && !IsChildNodeOf(m_hitemDrop, m_hitemDrag) &&
															GetParentItem(m_hitemDrag) != m_hitemDrop)
		{
			TransferItem(m_hitemDrag, m_hitemDrop);
			DeleteItem(m_hitemDrag);
		}
		else
			MessageBeep(0);

		ReleaseCapture();
		m_bDragging = FALSE;
		SelectDropTarget(NULL);
	}
}

void CMyTreeCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	OnButtonUp();
	CTreeCtrl::OnLButtonUp(nFlags, point);
}

void CMyTreeCtrl::OnRButtonUp(UINT nFlags, CPoint point)
{
	OnButtonUp();
	CTreeCtrl::OnRButtonUp(nFlags, point);
}

void CMyTreeCtrl::OnBeginDrag(LPNMHDR pnmhdr, LRESULT *pLResult)
{
	CPoint      ptAction;
	UINT        nFlags;

	GetCursorPos(&ptAction);
	ScreenToClient(&ptAction);
	((CTreeCtrlPage *)GetParent())->ShowNotification(pnmhdr, pLResult);
	ASSERT(!m_bDragging);
	m_bDragging = TRUE;
	m_hitemDrag = HitTest(ptAction, &nFlags);
	m_hitemDrop = NULL;

	ASSERT(m_pimagelist == NULL);
	m_pimagelist = CreateDragImage(m_hitemDrag);  // get the image list for dragging
	m_pimagelist->DragShowNolock(TRUE);
	m_pimagelist->SetDragCursorImage(0, CPoint(0, 0));
	m_pimagelist->BeginDrag(0, CPoint(0,0));
	m_pimagelist->DragMove(ptAction);
	m_pimagelist->DragEnter(this, ptAction);
	SetCapture();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\mtreectl.h ===
// MyTreeCtrl.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef INC_MYTREECTRL_H
#define INC_MYTREECTRL_H
/////////////////////////////////////////////////////////////////////////////
// CMyTreeCtrl window

class CMyTreeCtrl : public CTreeCtrl
{
// Construction
public:
	CMyTreeCtrl();

// Attributes
public:
	BOOL        m_bDragging;
	HTREEITEM   m_hitemDrag;
	HTREEITEM   m_hitemDrop;
	CImageList  *m_pimagelist;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyTreeCtrl();
	void    SetNewStyle(long lStyleMask, BOOL bSetBits);
	BOOL    TransferItem(HTREEITEM hitem, HTREEITEM hNewParent);
	void    OnButtonUp(void);
	BOOL    IsChildNodeOf(HTREEITEM hitemChild, HTREEITEM hitemSuspectedParent);

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyTreeCtrl)
	afx_msg void OnEndLabelEdit(LPNMHDR pnmhdr, LRESULT *pLResult);
	afx_msg void OnBeginDrag(LPNMHDR pnmhdr, LRESULT *pLResult);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	//}}AFX_MSG

	void OnButtonUp(CPoint point);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\notifwdw.cpp ===
// NotifySowCase.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "notifwdw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNotifyShowCase

CNotifyShowCase::CNotifyShowCase()
{
	m_totalLines = 200;  // use this default
}

CNotifyShowCase::~CNotifyShowCase()
{
}

BEGIN_MESSAGE_MAP(CNotifyShowCase, CEdit)
	//{{AFX_MSG_MAP(CNotifyShowCase)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

notifDescrip CNotifyShowCase::m_rgNotifDescrip[NOTIFCOUNT] =
{
		// list control notifications
	{LVN_ITEMCHANGING, _T("LVN_ITEMCHANGING")},
	{LVN_ITEMCHANGED, _T("LVN_ITEMCHANGED")},
	{LVN_INSERTITEM, _T("LVN_INSERTITEM")},
	{LVN_DELETEITEM, _T("LVN_DELETEITEM")},
	{LVN_DELETEALLITEMS, _T("LVN_DELETEALLITEMS")},
	{LVN_BEGINLABELEDIT, _T("LVN_BEGINLABELEDIT")},
	{LVN_ENDLABELEDIT, _T("LVN_ENDLABELEDIT")},
	{LVN_BEGINDRAG, _T("LVN_BEGINDRAG")},
	{LVN_BEGINRDRAG, _T("LVN_BEGINRDRAG")},
	{LVN_COLUMNCLICK, _T("LVN_COLUMNCLICK")},
	{LVN_GETDISPINFO, _T("LVN_GETDISPINFO")},
	{LVN_SETDISPINFO, _T("LVN_SETDISPINFO")},
		// tree control notifications
	{TVN_ITEMEXPANDING, _T("TVN_ITEMEXPANDING")},
	{TVN_BEGINLABELEDIT, _T("TVN_BEGINLABELEDIT")},
	{TVN_ENDLABELEDIT, _T("TVN_ENDLABELEDIT")},
	{TVN_SELCHANGING, _T("TVN_SELCHANGING")},
	{TVN_SELCHANGED, _T("TVN_SELCHANGED")},
	{TVN_GETDISPINFO, _T("TVN_GETDISPINFO")},
	{TVN_SETDISPINFO, _T("TVN_SETDISPINFO")},
	{TVN_BEGINDRAG, _T("TVN_BEGINDRAG")},
	{TVN_KEYDOWN, _T("TVN_KEYDOWN")},
	{TVN_DELETEITEM, _T("TVN_DELETEITEM")},
	{TVN_ITEMEXPANDED, _T("TVN_ITEMEXPANDED")},
};


/////////////////////////////////////////////////////////////////////////////
// CNotifyShowCase message handlers
void CNotifyShowCase::AddLine(LPCTSTR lpsz)
{
	TCHAR   szt[50];
	int     nLastChar;
	int     cLines;

	if (GetLineCount() >= m_totalLines)
	{
		SetSel(0, LineLength(0), TRUE/*bNoScroll*/);  // select the first line
		Clear();  // and remove it
	}

	nLastChar = LineIndex((cLines = GetLineCount() - 1)) + LineLength(cLines);
	_stprintf(szt, _T("%s\x0D\x0A"), lpsz);
	SetSel(nLastChar, nLastChar, TRUE/*bNoScroll*/);
	ReplaceSel(szt);
}

void CNotifyShowCase::ShowNotification(UINT nCode)
{
	int i;

	for (i = 0; i < NOTIFCOUNT; i++)    // linear search for few items is OK
		if (m_rgNotifDescrip[i].nCode == nCode)
			break;

	if (i == NOTIFCOUNT)
	{
		TCHAR szt[30];

		_stprintf(szt, _T("UNKNOWN CODE (%d)"), nCode);
		AddLine(szt);
	}
	else
		AddLine(m_rgNotifDescrip[i]. sztCodeName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\propsht.cpp ===
// AllControlsSheet.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "propsht.h"
#include "mtreectl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAllControlsSheet

IMPLEMENT_DYNAMIC(CAllControlsSheet, CPropertySheet)

CAllControlsSheet::CAllControlsSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	AddControlPages();

	// TODO :: Add the pages for the rest of the controls here.
}

CAllControlsSheet::CAllControlsSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	AddControlPages();
}

CAllControlsSheet::~CAllControlsSheet()
{
}

void CAllControlsSheet::AddControlPages()
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_psh.dwFlags |= PSP_USEHICON;
	m_psh.hIcon = m_hIcon;
	m_psh.dwFlags |= PSH_NOAPPLYNOW;    // Lose the Apply Now button
	//m_psh.dwFlags &= ~PSH_HASHELP;  // Lose the Help button

	AddPage(&m_treectrlpage);
	AddPage(&m_animctrlpage);
	AddPage(&m_toolbarpage);
	AddPage(&m_datetimepage);
	AddPage(&m_monthcalpage);
}

BEGIN_MESSAGE_MAP(CAllControlsSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CAllControlsSheet)
	ON_WM_QUERYDRAGICON()
	ON_WM_SYSCOMMAND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAllControlsSheet message handlers

BOOL CAllControlsSheet::OnInitDialog()
{
	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	SetIcon(m_hIcon, TRUE);
	SetIcon(m_hIcon, FALSE);
	return CPropertySheet::OnInitDialog();
}
HCURSOR CAllControlsSheet::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CAllControlsSheet::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CPropertySheet::OnSysCommand(nID, lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

//  CmnCtrl1.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#if !defined(AFX_STDAFX_H__A14ECE87_E24D_11D0_8286_00C04FD73634__INCLUDED_)
#define AFX_STDAFX_H__A14ECE87_E24D_11D0_8286_00C04FD73634__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxdtctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A14ECE87_E24D_11D0_8286_00C04FD73634__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CmnCtrl1.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDC_DATETIME                    101
#define IDD_CMNCTRL1_DIALOG             102
#define IDC_MONTHCAL                    102
#define IDC_EDIT1                       104
#define IDC_ANIMATE                     105
#define IDD_DATETIME                    106
#define IDD_MONTHCAL                    107
#define IDR_MAINFRAME                   128
#define IDR_STANDARDBAR                 129
#define IDD_TOOLBARCTRL                 131
#define IDD_TREECTRL                    134
#define IDD_ANIMCTRL                    137
#define IDB_BMTREEFIRST                 138
#define IDB_BMTREEDOG                   139
#define IDB_BMTREEDOGSELECTED           140
#define IDB_BMTREEBIRD                  141
#define IDB_BMTREEBIRDSELECTED          142
#define IDB_BMTREEFISH                  143
#define IDB_BMTREEFISHSELECTED          144
#define IDB_BMTREELAST                  145
#define IDR_PALETTEBAR                  148
#define IDC_CKUPDOWN                    1000
#define IDC_CKSHOWNONE                  1001
#define IDC_CKAPPCANPARSE               1002
#define IDC_CKTIMEFORMAT                1003
#define IDC_CKSHORTDATEFORMAT           1004
#define IDC_CKLONGDATEFORMAT            1005
#define IDC_LBNOTIFY                    1006
#define IDC_DTFRAME                     1007
#define IDC_MCFRAME                     1008
#define IDC_CKDAYSTATE                  1009
#define IDC_CMULTISELECT                1010
#define IDC_CKNOTODAY                   1011
#define IDC_CKNOTODAYCIRCLE             1012
#define IDC_CKWEEKNUMBERS               1013
#define IDC_NOTIFYLIST                  1014
#define IDC_TREEVIEW1                   1015
#define IDC_EDSELRANGE                  1015
#define IDC_TVEDITLABELS                1016
#define IDC_STRSELECTION                1016
#define IDC_TVHASBUTTONS                1017
#define IDC_ALTDRAG                     1017
#define IDC_STRRANGE                    1017
#define IDC_TVHASLINES                  1018
#define IDC_TVLINESATROOT               1019
#define IDC_TVDISABLEDDRAGDROP          1020
#define IDC_TVSHOWSELALWAYS             1021
#define IDC_TREESTATUS                  1022
#define IDC_TVSSINGELEXPAND             1023
#define IDC_BROWSE                      1025
#define IDC_CENTER                      1026
#define IDC_TRANSPARENT                 1027
#define IDC_AUTOPLAY                    1028
#define IDC_PLAY                        1029
#define IDC_STOP                        1030
#define IDC_ANIMFRAME                   1031
#define IDC_ANIMSTATUS                  1033
#define ID_NEW                          2000
#define ID_OPEN                         2001
#define ID_SAVE                         2002
#define ID_CUT                          2003
#define ID_COPY                         2004
#define ID_PASTE                        2005
#define ID_PRINT                        2006
#define ID_ABOUT                        2007
#define ID_CONTEXTHELP                  2008
#define ID_ERASE                        2009
#define ID_PENCIL                       2010
#define ID_SELECT                       2011
#define ID_BRUSH                        2012
#define ID_AIRBRUSH                     2013
#define ID_FILL                         2014
#define ID_LINE                         2015
#define ID_SELECTCOLOR                  2016
#define ID_MAGNIFY                      2017
#define ID_RECTANGLE                    2018
#define ID_ROUNDRECTANGLE               2019
#define ID_ELLIPSE                      2020
#define ID_TOOLBARSTYLE                 3000
#define ID_CCSTOP                       3001
#define ID_CCSBOTTOM                    3002
#define ID_CCSADJUSTABLE                3003
#define ID_TBSTYLETOOLTIPS              3004
#define ID_TBSTYLEWRAPABLE              3005
#define ID_BUTTONSTYLE                  3006
#define ID_TBSTYLEBUTTON                3007
#define ID_TBSTYLECHECKGROUP            3008
#define ID_BUTTONSTYLE2                 3009
#define ID_TOOLBARSTYLE2                3010
#define ID_TBSTYLETOOLTIPS2             3011

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\notifwdw.h ===
// NotifySowCase.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CNotifySowCase window

#ifndef INC_NOTIFYSHOWCASE_H
#define INC_NOTIFYSHOWCASE_H

typedef struct notif_tag
{
	UINT    nCode;
	TCHAR   sztCodeName[30];
} notifDescrip;


#define NOTIFCOUNT  23

class CNotifyShowCase : public CEdit
{
// Construction
public:
	CNotifyShowCase();
	static notifDescrip m_rgNotifDescrip[NOTIFCOUNT];

// Attributes
public:
	int     m_totalLines;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNotifySowCase)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNotifyShowCase();
	void    SetBufferSize(int nLines) { m_totalLines = nLines;};
	void    AddLine(LPCTSTR lpsz);
	void    ShowNotification(UINT nCode);

	// Generated message map functions
protected:
	//{{AFX_MSG(CNotifySowCase)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\propsht.h ===
// AllControlsSheet.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CAllControlsSheet

#include "treecpg.h"
#include "animctrl.h"
#include "toolpage.h"
#include "datetime.h"
#include "monthcal.h"

class CAllControlsSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CAllControlsSheet)

// Construction
public:
	CAllControlsSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CAllControlsSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

protected:
	void AddControlPages(void);

// Attributes
public:

	CTreeCtrlPage       m_treectrlpage;
	CAnimateCtrlPage    m_animctrlpage;
	CToolBarCtrlPage    m_toolbarpage;
	CDateTimePage       m_datetimepage;
	CMonthCalPage       m_monthcalpage;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllControlsSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAllControlsSheet();
	virtual BOOL OnInitDialog();

	// Generated message map functions
protected:

	HICON m_hIcon;

	//{{AFX_MSG(CAllControlsSheet)
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolbar1.h ===
// Toolbar1.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CStandardBar window
#ifndef INC_TOOLBAR1_H
#define INC_TOOLBAR1_H

class CStandardBar : public CToolBarCtrl
{
private:
	int         m_nButtonCount;
	TBBUTTON    *m_pTBButtons;
	using CToolBarCtrl::Create;

// Construction
public:
	CStandardBar();

// Attributes
public:

// Operations
public:


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStandardBar)
	public:
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	virtual BOOL Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	//}}AFX_VIRTUAL


// Implementation
public:
	virtual ~CStandardBar();

protected:
	BOOL BeginAdjust(WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	BOOL BeginDrag(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL CustomizeHelp(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL EndAdjust(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL EndDrag(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL GetButtonInfo(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL QueryDelete(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL QueryInsert(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL Reset(WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	BOOL ToolBarChange(WPARAM wParam, LPARAM lParam,LRESULT* pLResult);
	CString NeedText(UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult);

	// Generated message map functions
protected:
	//{{AFX_MSG(CStandardBar)
	afx_msg void OnNeedTextW( UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult );
	afx_msg void OnNeedTextA( UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult );
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolbar2.h ===
// Toolbar2.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CPaletteBar window
#ifndef INC_TOOLBAR2_H
#define INC_TOOLBAR2_H

class CPaletteBar : public CToolBarCtrl
{
private:
	int         m_nButtonCount;
	TBBUTTON    *m_pTBButtons;
	using CToolBarCtrl::Create;

// Construction
public:
	CPaletteBar();

// Attributes
public:

// Operations
public:


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPaletteBar)
	public:
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	virtual BOOL Create( DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	//}}AFX_VIRTUAL


// Implementation
public:
	virtual ~CPaletteBar();

protected:
	BOOL BeginAdjust(WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	BOOL BeginDrag(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL CustomizeHelp(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL EndAdjust(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL EndDrag(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL GetButtonInfo(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL QueryDelete(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL QueryInsert(WPARAM wParam, LPARAM  lParam, LRESULT* pLResult);
	BOOL Reset(WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	BOOL ToolBarChange(WPARAM wParam, LPARAM lParam,LRESULT* pLResult);
	CString NeedText(UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult);

	// Generated message map functions
protected:
	//{{AFX_MSG(CPaletteBar)
	afx_msg void OnNeedTextW( UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult );
	afx_msg void OnNeedTextA( UINT nID, NMHDR * pNotifyStruct, LRESULT * lResult );
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolbar1.cpp ===
// ToolBar1.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxpriv.h"
#include "CmnCtrl1.h"
#include "Toolbar1.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStandardBar

CStandardBar::CStandardBar() : m_pTBButtons(NULL)
{

}

CStandardBar::~CStandardBar()
{
	delete []m_pTBButtons;
}


BEGIN_MESSAGE_MAP(CStandardBar, CToolBarCtrl)
	//{{AFX_MSG_MAP(CStandardBar)
	ON_NOTIFY_RANGE( TTN_NEEDTEXTA, 0, 0xFFFF, OnNeedTextA)
	ON_NOTIFY_RANGE( TTN_NEEDTEXTW, 0, 0xFFFF, OnNeedTextW)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CStandardBar::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID )
{
	BOOL bRet = CToolBarCtrl::Create(dwStyle, rect, pParentWnd, nID);

	m_nButtonCount = ID_CONTEXTHELP - ID_NEW + 1;

	VERIFY(AddBitmap(m_nButtonCount,IDR_STANDARDBAR) != -1);

	m_pTBButtons = new TBBUTTON[m_nButtonCount];

	for (int nIndex = 0; nIndex < m_nButtonCount; nIndex++)
	{
		CString string;
		string.LoadString(nIndex + ID_NEW);

		// Add second '\0'
		int nStringLength = string.GetLength() + 1;
		TCHAR * pString = string.GetBufferSetLength(nStringLength);
		pString[nStringLength] = 0;

		VERIFY((m_pTBButtons[nIndex].iString = AddStrings(pString)) != -1);

		string.ReleaseBuffer();


		m_pTBButtons[nIndex].fsState = TBSTATE_ENABLED;
		m_pTBButtons[nIndex].fsStyle = TBSTYLE_BUTTON;
		m_pTBButtons[nIndex].dwData = 0;
		m_pTBButtons[nIndex].iBitmap = nIndex;
		m_pTBButtons[nIndex].idCommand = nIndex + ID_NEW;

	}

	TBBUTTON sepButton;
	sepButton.idCommand = 0;
	sepButton.fsStyle = TBSTYLE_SEP;
	sepButton.fsState = TBSTATE_ENABLED;
	sepButton.iString = 0;
	sepButton.iBitmap = 0;
	sepButton.dwData = 0;

	for (nIndex = 0; nIndex < m_nButtonCount; nIndex++)
	{
		VERIFY(AddButtons(1,&m_pTBButtons[nIndex]));
		if (!((nIndex +1) % 3))
		{
			VERIFY(AddButtons(1,&sepButton));
		}
	}


	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CStandardBar message handlers

// MFC routes the notifications sent to the parent of the control to
// the control before the parent can process the notification.
// The control object can handle the notification or ignore it.
// If the notification is handled then return TRUE. Otherwise MFC
// will route it to the parent of the control.

BOOL CStandardBar::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult)
{
	if (message == WM_NOTIFY)
	{
		NMHDR *pNMHDR = (NMHDR *) lParam;
		switch (pNMHDR->code)
		{
		case TBN_BEGINADJUST :
			return BeginAdjust(wParam,  lParam,  pLResult);

		case TBN_BEGINDRAG:
			return BeginDrag(wParam,  lParam,  pLResult);

		case TBN_CUSTHELP:
			return CustomizeHelp(wParam,  lParam,  pLResult);

		case TBN_ENDADJUST:
			return EndAdjust(wParam,  lParam,  pLResult);

		case TBN_ENDDRAG:
			return EndDrag(wParam,  lParam,  pLResult);

		case TBN_GETBUTTONINFO:
			return GetButtonInfo(wParam,  lParam,  pLResult);

		case TBN_QUERYDELETE:
			return QueryDelete(wParam,  lParam,  pLResult);

		case TBN_QUERYINSERT:
			return QueryInsert(wParam,  lParam,  pLResult);

		case TBN_RESET:
			return Reset(wParam, lParam,  pLResult);

		case TBN_TOOLBARCHANGE:
			return ToolBarChange(wParam, lParam, pLResult);
		}
	}

	return CToolBarCtrl::OnChildNotify(message, wParam, lParam, pLResult);
}

BOOL CStandardBar::BeginAdjust(WPARAM /*wParam*/, LPARAM /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_BEGINADJUST\n"));

	// the customize dialog box is about to be displayed

	// save toolbar state before customization using the dialog
	// Use this information to restore the state if reset button is pressed
	SaveState(HKEY_CURRENT_USER,_T("Software\\Microsoft\\VC70\\Samples\\CtrlDemo"),_T("Standard Tool Bar"));

	return TRUE;
}

BOOL CStandardBar::BeginDrag(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_BEGINDRAG\n"));

	// we are not implementing custon drag and drop
	* pLResult = FALSE;
	return FALSE;
}

BOOL CStandardBar::CustomizeHelp(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_CUSTHELP\n"));

	// Sample displays a message box but a valid help topic
	// can be displayed for the customize dialog for this toolbar
	AfxMessageBox(_T("Help not implemented!"));

	return TRUE;
}

BOOL CStandardBar::EndAdjust(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_ENDADJUST\n"));

	// the customize dialog box has been closed

	return TRUE;
}

BOOL CStandardBar::EndDrag(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_ENDDRAG\n"));

	// Code to handle custom drag and drop. This message indicates that
	// the item is being dropped
	* pLResult = FALSE;
	return TRUE;
}

BOOL CStandardBar::GetButtonInfo(WPARAM /*wParam*/, LPARAM  lParam, LRESULT* pLResult)
{
	// This notification message has to be handled correctly if
	// all operations in the custom dialogbox has to function correctly
	// We have to supply information for the button specified by pTBN->tbButton
	//
	// This notification is sent in the following cases
	//
	// After TBN_BEGINADJUST the control sends these notifications until
	// * pLResult is TRUE. We have to supply valid values when this value is
	// set to TRUE. Here the control is collecting information for all
	// the buttons that have to be displayed in the dialog box
	//
	// The control sends this notification to get information about
	// a button if the user is trying to add it to the toolbar or
	// rearranging the buttons on the toolbar from within the dialog

	TRACE(_T("TBN_GETBUTTONINFO\n"));

	TBNOTIFY *pTBN = (TBNOTIFY *) lParam;

	if (pTBN->iItem >= m_nButtonCount)
	{
		* pLResult = FALSE;
	}
	else
	{
		CString buffer;
		buffer.LoadString(pTBN->iItem + ID_NEW);

		// set the string for the button
		// truncate the string if its length is greater than the buffer
		// supplied by the toolbar
		_tcsncpy(pTBN->pszText, buffer, pTBN->cchText - 1);
		pTBN->pszText[pTBN->cchText - 1] = '\0';

		// set the button info
		pTBN->tbButton = m_pTBButtons[pTBN->iItem];

		// valid values are structure
		*pLResult = TRUE;
	}

	return TRUE;
}

BOOL CStandardBar::QueryDelete(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_QUERYDELETE\n"));

	// in this sample any button can be deleted
	// if a particular button cannot be deleted set *pResult to FALSE for that item
	*pLResult = TRUE;
	return TRUE;
}

BOOL CStandardBar::QueryInsert(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_QUERYINSERT\n"));

	// in this sample buttons can be inserted at any location on the
	// toolbar
	*pLResult = TRUE;
	return TRUE;
}

BOOL CStandardBar::Reset(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_RESET\n"));

	// User has pressed the reset button
	// restore the state of the toolbar to the state it was before customization
	RestoreState(HKEY_CURRENT_USER,_T("Software\\Microsoft\\VC70\\Samples\\CtrlDemo"),_T("Standard Tool Bar"));

	*pLResult = TRUE;
	return TRUE;
}

BOOL CStandardBar::ToolBarChange(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_TOOLBARCHANGE\n"));

	// the toolbar has changed
	return TRUE;
}


// Helper function for tooltips

CString CStandardBar::NeedText(UINT nID, NMHDR * pNotifyStruct, LRESULT* /*lResult*/)
{
	LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT)pNotifyStruct ;
	ASSERT(nID == lpTTT->hdr.idFrom);

	CString toolTipText;
	toolTipText.LoadString(nID);

	// szText length is 80
	int nLength = (toolTipText.GetLength() > 79) ? 79 : toolTipText.GetLength();

	toolTipText = toolTipText.Left(nLength);

	return toolTipText;
}


void CStandardBar::OnNeedTextW( UINT /*nID*/, NMHDR * pNotifyStruct, LRESULT* lResult )
{
	if (pNotifyStruct->idFrom >= ID_NEW && pNotifyStruct->idFrom <= ID_CONTEXTHELP)
	{
		CString toolTipText = NeedText((UINT)pNotifyStruct->idFrom, pNotifyStruct, lResult);
		LPTOOLTIPTEXTW lpTTT = (LPTOOLTIPTEXTW)pNotifyStruct;
#ifndef _UNICODE
		mbstowcs(lpTTT->szText,(LPCSTR)toolTipText, toolTipText.GetLength() + 1);
#else
		_tcsncpy(lpTTT->szText, toolTipText, toolTipText.GetLength() + 1);
#endif
	}		
}

void CStandardBar::OnNeedTextA( UINT /*nID*/, NMHDR * pNotifyStruct, LRESULT * lResult )
{
	if (pNotifyStruct->idFrom >= ID_NEW && pNotifyStruct->idFrom <= ID_CONTEXTHELP)
	{
		CString toolTipText = NeedText((UINT)pNotifyStruct->idFrom, pNotifyStruct, lResult);
		LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT)pNotifyStruct;
		_tcscpy(lpTTT->szText,(LPCTSTR)toolTipText);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolpage.cpp ===
// ToolPage.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "toolbar1.h"
#include "toolbar2.h"
#include "ToolPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlPage property page

IMPLEMENT_DYNCREATE(CToolBarCtrlPage, CPropertyPage)

CToolBarCtrlPage::CToolBarCtrlPage() : CPropertyPage(CToolBarCtrlPage::IDD)
{
	//{{AFX_DATA_INIT(CToolBarCtrlPage)
	m_bAltDrag = FALSE;
	//}}AFX_DATA_INIT
	//m_psp.dwFlags &= ~PSP_HASHELP;  // Lose the Help button
}

CToolBarCtrlPage::~CToolBarCtrlPage()
{
}

void CToolBarCtrlPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolBarCtrlPage)
	DDX_Check(pDX, IDC_ALTDRAG, m_bAltDrag);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CToolBarCtrlPage, CPropertyPage)
	//{{AFX_MSG_MAP(CToolBarCtrlPage)
	ON_BN_CLICKED(IDC_ALTDRAG, OnAltdrag)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
#pragma warning(disable : 4706)
BOOL CToolBarCtrlPage::OnInitDialog()
{

	CPropertyPage::OnInitDialog();


	m_StandardBar.Create(WS_BORDER | WS_VISIBLE | WS_CHILD
			| CCS_TOP | CCS_ADJUSTABLE | TBSTYLE_TOOLTIPS,
		CRect(0,0,0,0),this, IDR_STANDARDBAR);

	m_PaletteBar.Create(WS_BORDER | WS_VISIBLE | WS_CHILD
			| CCS_BOTTOM | TBSTYLE_WRAPABLE | TBSTYLE_TOOLTIPS,
		CRect(0,0,0,0),this, IDR_PALETTEBAR);

	m_StandardBar.AutoSize();
	m_PaletteBar.AutoSize();

	m_ToolTip.Create(this);

	CString cstrToolTip;
	CWnd *pWnd = 0;
	CRect rect;

	// Setup the tooltip control for tooltips with the static controls
	for (int nIndex = ID_TOOLBARSTYLE; nIndex <= ID_TBSTYLETOOLTIPS2; nIndex++)
	{
		cstrToolTip.LoadString(nIndex);

		VERIFY(pWnd = GetDlgItem(nIndex));

		pWnd->GetWindowRect(&rect);
		ScreenToClient(&rect);

		m_ToolTip.AddTool(this, (LPCTSTR)cstrToolTip, &rect, nIndex);
	}

	m_ToolTip.Activate(TRUE);

	return TRUE;  // return TRUE unless you set the focus to a control
				  // EXCEPTION: OCX Property Pages should return FALSE
}
#pragma warning(default : 4706)

void CToolBarCtrlPage::ChangeCtrlStyle(long lStyle, BOOL bSetStyle)
{
	long    lStyleOld;
	CRect   rect;

	m_StandardBar.GetWindowRect(&rect);
	lStyleOld = GetWindowLong( m_StandardBar.GetSafeHwnd(), GWL_STYLE );
	if ( bSetStyle )
		lStyleOld |= lStyle;
	else
		lStyleOld &= ~lStyle;

	SetWindowLong( m_StandardBar.GetSafeHwnd(), GWL_STYLE, lStyleOld );
	m_StandardBar.InvalidateRect(&rect);
}

void CToolBarCtrlPage::OnAltdrag()
{
	UpdateData();
	ChangeCtrlStyle(TBSTYLE_ALTDRAG, m_bAltDrag);
}


LRESULT CToolBarCtrlPage::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// We need to pass these messages to the tooltip for it to determine
	// the position of the mouse

	switch (message)
	{
	case WM_LBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_MBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MOUSEMOVE:
		{
			MSG msg;
			msg.hwnd = m_hWnd;
			msg.message = message;
			msg.wParam = wParam;
			msg.lParam = lParam;

			m_ToolTip.RelayEvent(&msg);
		}
	}

	return CPropertyPage::WindowProc(message,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\Remoting\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolbar2.cpp ===
// ToolBar2.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afxpriv.h"
#include "CmnCtrl1.h"
#include "Toolbar2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPaletteBar

CPaletteBar::CPaletteBar() : m_pTBButtons(NULL)
{

}

CPaletteBar::~CPaletteBar()
{
	delete []m_pTBButtons;
}

BEGIN_MESSAGE_MAP(CPaletteBar, CToolBarCtrl)
	//{{AFX_MSG_MAP(CPaletteBar)
	ON_NOTIFY_RANGE( TTN_NEEDTEXTA, 0, 0xFFFF, OnNeedTextA)
	ON_NOTIFY_RANGE( TTN_NEEDTEXTW, 0, 0xFFFF, OnNeedTextW)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CPaletteBar::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID )
{
	BOOL bRet = CToolBarCtrl::Create(dwStyle, rect, pParentWnd, nID);

	m_nButtonCount = ID_ELLIPSE - ID_ERASE + 1;

	VERIFY(AddBitmap(m_nButtonCount,IDR_PALETTEBAR) != -1);

	m_pTBButtons = new TBBUTTON[m_nButtonCount];

	for (int nIndex = 0; nIndex < m_nButtonCount; nIndex++)
	{
		CString string;
		string.LoadString(nIndex + ID_ERASE);

		// Add second '\0'
		int nStringLength = string.GetLength() + 1;
		TCHAR* pString = string.GetBufferSetLength(nStringLength);
		pString[nStringLength] = 0;

		VERIFY((m_pTBButtons[nIndex].iString = AddStrings(pString)) != -1);

		string.ReleaseBuffer();


		m_pTBButtons[nIndex].fsState = TBSTATE_ENABLED;
		m_pTBButtons[nIndex].fsStyle = TBSTYLE_CHECKGROUP;
		m_pTBButtons[nIndex].dwData = 0;
		m_pTBButtons[nIndex].iBitmap = nIndex;
		m_pTBButtons[nIndex].idCommand = nIndex + ID_ERASE;

	}


	for (nIndex = 0; nIndex < m_nButtonCount; nIndex++)
	{
		VERIFY(AddButtons(1,&m_pTBButtons[nIndex]));
	}


	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CPaletteBar message handlers

// MFC routes the notifications sent to the parent of the control to
// the control before the parent can process the notification.
// The control object can handle the notification or ignore it.
// If the notification is handled then return TRUE. Otherwise MFC
// will route it to the parent of the control.

BOOL CPaletteBar::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult)
{
	if (message == WM_NOTIFY)
	{
		NMHDR *pNMHDR = (NMHDR *) lParam;
		switch (pNMHDR->code)
		{
		case TBN_BEGINADJUST :
			return BeginAdjust(wParam,  lParam,  pLResult);

		case TBN_BEGINDRAG:
			return BeginDrag(wParam,  lParam,  pLResult);

		case TBN_CUSTHELP:
			return CustomizeHelp(wParam,  lParam,  pLResult);

		case TBN_ENDADJUST:
			return EndAdjust(wParam,  lParam,  pLResult);

		case TBN_ENDDRAG:
			return EndDrag(wParam,  lParam,  pLResult);

		case TBN_GETBUTTONINFO:
			return GetButtonInfo(wParam,  lParam,  pLResult);

		case TBN_QUERYDELETE:
			return QueryDelete(wParam,  lParam,  pLResult);

		case TBN_QUERYINSERT:
			return QueryInsert(wParam,  lParam,  pLResult);

		case TBN_RESET:
			return Reset(wParam, lParam,  pLResult);

		case TBN_TOOLBARCHANGE:
			return ToolBarChange(wParam, lParam, pLResult);
		}
	}

	return CToolBarCtrl::OnChildNotify(message, wParam, lParam, pLResult);
}

BOOL CPaletteBar::BeginAdjust(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_BEGINADJUST\n"));

	// the customize dialog box is about to be displayed

	// save toolbar state before customization using the dialog
	// Use this information to restore the state if reset button is pressed
	SaveState(HKEY_CURRENT_USER,_T("Software\\Microsoft\\VC70\\Samples\\CtrlDemo"),_T("Palette Tool Bar"));

	return TRUE;
}

BOOL CPaletteBar::BeginDrag(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_BEGINDRAG\n"));

	// we are not implementing custon drag and drop
	* pLResult = FALSE;
	return FALSE;
}

BOOL CPaletteBar::CustomizeHelp(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_CUSTHELP\n"));

	// Sample displays a message box but a valid help topic
	// can be displayed for the customize dialog for this toolbar
	AfxMessageBox(_T("Help not implemented!"));

	return TRUE;
}

BOOL CPaletteBar::EndAdjust(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_ENDADJUST\n"));

	// the customize dialog box has been closed

	return TRUE;
}

BOOL CPaletteBar::EndDrag(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_ENDDRAG\n"));

	// Code to handle custom drag and drop. This message indicates that
	// the item is being dropped
	* pLResult = FALSE;
	return TRUE;
}

BOOL CPaletteBar::GetButtonInfo(WPARAM /*wParam*/, LPARAM  lParam, LRESULT* pLResult)
{
	// This notification message has to be handled correctly if
	// all operations in the custom dialogbox has to function correctly
	// We have to supply information for the button specified by pTBN->tbButton
	//
	// This notification is sent in the following cases
	//
	// After TBN_BEGINADJUST the control sends these notifications until
	// * pLResult is TRUE. We have to supply valid values when this value is
	// set to TRUE. Here the control is collecting information for all
	// the buttons that have to be displayed in the dialog box
	//
	// The control sends this notification to get information about
	// a button if the user is trying to add it to the toolbar or
	// rearranging the buttons on the toolbar from within the dialog

	TRACE(_T("TBN_GETBUTTONINFO\n"));

	TBNOTIFY *pTBN = (TBNOTIFY *) lParam;

	if (pTBN->iItem >= m_nButtonCount)
	{
		* pLResult = FALSE;
	}
	else
	{
		CString buffer;
		buffer.LoadString(pTBN->iItem + ID_ERASE);

		// set the string for the button
		// truncate the string if its length is greater than the buffer
		// supplied by the toolbar
		_tcsncpy(pTBN->pszText, buffer, pTBN->cchText - 1);
		pTBN->pszText[pTBN->cchText - 1] = '\0';

		// set the button info
		pTBN->tbButton = m_pTBButtons[pTBN->iItem];

		// valid values are structure
		*pLResult = TRUE;
	}

	return TRUE;
}

BOOL CPaletteBar::QueryDelete(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_QUERYDELETE\n"));

	// in this sample any button can be deleted
	// if a particular button cannot be deleted set *pResult to FALSE for that item
	*pLResult = TRUE;
	return TRUE;
}

BOOL CPaletteBar::QueryInsert(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_QUERYINSERT\n"));

	// in this sample buttons can be inserted at any location on the
	// toolbar
	*pLResult = TRUE;
	return TRUE;
}

BOOL CPaletteBar::Reset(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* pLResult)
{
	TRACE(_T("TBN_RESET\n"));

	// User has pressed the reset button
	// restore the state of the toolbar to the state it was before customization
	RestoreState(HKEY_CURRENT_USER,_T("Software\\Microsoft\\VC70\\Samples\\CtrlDemo"),_T("Palette Tool Bar"));

	*pLResult = TRUE;
	return TRUE;
}

BOOL CPaletteBar::ToolBarChange(WPARAM /*wParam*/, LPARAM  /*lParam*/, LRESULT* /*pLResult*/)
{
	TRACE(_T("TBN_TOOLBARCHANGE\n"));

	// the toolbar has changed
	return TRUE;
}


// Helper function for tooltips

CString CPaletteBar::NeedText(UINT nID, NMHDR* pNotifyStruct, LRESULT* /*lResult*/ )
{
	LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT)pNotifyStruct ;
	ASSERT(nID == lpTTT->hdr.idFrom);

	CString toolTipText;
	toolTipText.LoadString(nID);

	// szText length is 80
	int nLength = (toolTipText.GetLength() > 79) ? 79 : toolTipText.GetLength();

	toolTipText = toolTipText.Left(nLength);

	return toolTipText;
}


void CPaletteBar::OnNeedTextW(UINT /*nID*/, NMHDR* pNotifyStruct, LRESULT * lResult )
{
	if (pNotifyStruct->idFrom >= ID_ERASE && pNotifyStruct->idFrom <= ID_ELLIPSE)
	{
		CString toolTipText = NeedText((UINT)pNotifyStruct->idFrom, pNotifyStruct, lResult);
		LPTOOLTIPTEXTW lpTTT = (LPTOOLTIPTEXTW)pNotifyStruct;
#ifdef _UNICODE
		_tcsncpy(lpTTT->szText,(LPCTSTR)toolTipText, toolTipText.GetLength() + 1);
#else
		mbstowcs(lpTTT->szText,(LPCTSTR)toolTipText, toolTipText.GetLength() + 1);
#endif
	}
}

void CPaletteBar::OnNeedTextA(UINT /*nID*/, NMHDR* pNotifyStruct, LRESULT * lResult )
{
	if (pNotifyStruct->idFrom >= ID_ERASE && pNotifyStruct->idFrom <= ID_ELLIPSE)
	{
		CString toolTipText = NeedText((UINT)pNotifyStruct->idFrom, pNotifyStruct, lResult);
		LPTOOLTIPTEXT lpTTT = (LPTOOLTIPTEXT)pNotifyStruct;
		_tcscpy(lpTTT->szText,(LPCTSTR)toolTipText);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\treecpg.h ===
// TreeCtrlPage.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrlPage dialog
#ifndef INC_TRCPAGE_H
#define INC_TRCPAGE_H

#include "mtreectl.h"
#include "notifwdw.h"

class CTreeCtrlPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CTreeCtrlPage)

// Construction
public:
	CTreeCtrlPage();
	~CTreeCtrlPage();

// Dialog Data
	//{{AFX_DATA(CTreeCtrlPage)
	enum { IDD = IDD_TREECTRL };
	CNotifyShowCase m_notifshowcase;
	CMyTreeCtrl m_mytreectrl;
	BOOL    m_bDisableDragDrop;
	BOOL    m_bHasButtons;
	BOOL    m_bHasLines;
	BOOL    m_bLinesAtRoot;
	BOOL    m_bEditLabels;
	BOOL    m_bShowSelAlways;
	CString m_cstrStatus;
	BOOL    m_bSingleExpand;
	//}}AFX_DATA


	HTREEITEM   m_rghItem[12];
	HTREEITEM   m_hitemDrag;
	HTREEITEM   m_hitemDrop;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTreeCtrlPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	// Generated message map functions
	//{{AFX_MSG(CTreeCtrlPage)
	afx_msg void OnEditLabels();
	afx_msg void OnHasButtons();
	afx_msg void OnHasLines();
	afx_msg void OnLinesAtRoot();
	afx_msg void OnDisabledDragDrop();
	afx_msg void OnShowSelAlways();
	afx_msg void ShowNotification(LPNMHDR pnmhdr, LRESULT *pLResult);
	afx_msg void OnSingleExpand();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\treecpg.cpp ===
// TreeCtrlPage.cpp : implementation file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "CmnCtrl1.h"
#include "treecpg.h"
#include "mtreectl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrlPage property page

IMPLEMENT_DYNCREATE(CTreeCtrlPage, CPropertyPage)

CTreeCtrlPage::CTreeCtrlPage() : CPropertyPage(CTreeCtrlPage::IDD)
{
	//{{AFX_DATA_INIT(CTreeCtrlPage)
	m_bDisableDragDrop = FALSE;
	m_bHasButtons = FALSE;
	m_bHasLines = FALSE;
	m_bLinesAtRoot = FALSE;
	m_bEditLabels = FALSE;
	m_bShowSelAlways = FALSE;
	m_cstrStatus = _T("");
	m_bSingleExpand = FALSE;
	//}}AFX_DATA_INIT
	//m_psp.dwFlags &= ~PSP_HASHELP;  // Lose the Help button
}

CTreeCtrlPage::~CTreeCtrlPage()
{
}

void CTreeCtrlPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTreeCtrlPage)
	DDX_Control(pDX, IDC_TREESTATUS, m_notifshowcase);
	DDX_Control(pDX, IDC_TREEVIEW1, m_mytreectrl);
	DDX_Check(pDX, IDC_TVDISABLEDDRAGDROP, m_bDisableDragDrop);
	DDX_Check(pDX, IDC_TVHASBUTTONS, m_bHasButtons);
	DDX_Check(pDX, IDC_TVHASLINES, m_bHasLines);
	DDX_Check(pDX, IDC_TVLINESATROOT, m_bLinesAtRoot);
	DDX_Check(pDX, IDC_TVEDITLABELS, m_bEditLabels);
	DDX_Check(pDX, IDC_TVSHOWSELALWAYS, m_bShowSelAlways);
	DDX_Text(pDX, IDC_TREESTATUS, m_cstrStatus);
	DDX_Check(pDX, IDC_TVSSINGELEXPAND, m_bSingleExpand);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTreeCtrlPage, CPropertyPage)
	//{{AFX_MSG_MAP(CTreeCtrlPage)
	ON_BN_CLICKED(IDC_TVEDITLABELS, OnEditLabels)
	ON_BN_CLICKED(IDC_TVHASBUTTONS, OnHasButtons)
	ON_BN_CLICKED(IDC_TVHASLINES, OnHasLines)
	ON_BN_CLICKED(IDC_TVLINESATROOT, OnLinesAtRoot)
	ON_BN_CLICKED(IDC_TVDISABLEDDRAGDROP, OnDisabledDragDrop)
	ON_BN_CLICKED(IDC_TVSHOWSELALWAYS, OnShowSelAlways)
	ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_SELCHANGING, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_GETDISPINFO, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_SETDISPINFO, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_BEGINDRAG, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_KEYDOWN, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_SELCHANGING, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_ITEMEXPANDED, IDC_TREEVIEW1, ShowNotification)
	ON_NOTIFY(TVN_DELETEITEM, IDC_TREEVIEW1, ShowNotification)
	ON_BN_CLICKED(IDC_TVSSINGELEXPAND, OnSingleExpand)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrlPage message handlers
BOOL CTreeCtrlPage::OnInitDialog()
{
	CImageList          *pImageList;
	CBitmap             bitmap;
	CString             strItems[11];
	CCmnCtrl1App        *pApp;
	int                 iItem;
	UINT                nID;
	TV_INSERTSTRUCT     curTreeItem;

	strItems[0]= _T("Dogs");
	strItems[1]= _T("German Shepherd");
	strItems[2]= _T("Dalmatian");
	strItems[3]= _T("Great Dane");
	strItems[4]= _T("Birds");
	strItems[5]= _T("Hummingbird");
	strItems[6]= _T("Pigeon");
	strItems[7]= _T("Eagle");
	strItems[8]= _T("Fish");
	strItems[9]= _T("Snapper");
	strItems[10]= _T("Sole");
//	strItems[11]= _T("Salmon");

	pApp = (CCmnCtrl1App *)AfxGetApp();
	CPropertyPage::OnInitDialog();  // let the base class do the default work
	pImageList = new CImageList();
	pImageList->Create(32, 16, ILC_MASK, 6, 4);

	for (nID = IDB_BMTREEFIRST; nID <= IDB_BMTREELAST; nID++)  // load bitmaps for dog, bird and fish
	{
		bitmap.LoadBitmap(nID);
		pImageList->Add(&bitmap, (COLORREF)0xFFFFFF);
		bitmap.DeleteObject();
	}

	m_mytreectrl.SetImageList(pImageList, TVSIL_NORMAL);
	for (iItem = 0; iItem < CELEMS(strItems); iItem ++)
	{
		curTreeItem.hParent = (iItem % 4 == 0)? NULL : m_rghItem[iItem / 4 * 4];
		curTreeItem.hInsertAfter = TVI_SORT;
		curTreeItem.item.iImage = iItem / 4 * 2;
		curTreeItem.item.iSelectedImage = curTreeItem.item.iImage + 1;
		curTreeItem.item.pszText = strItems[iItem].GetBuffer(strItems[iItem].GetLength());
		curTreeItem.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT;
		m_rghItem[iItem] = m_mytreectrl.InsertItem(&curTreeItem);
	}

	return FALSE;
}

void CTreeCtrlPage::OnEditLabels()
{
	UpdateData(TRUE/*bSaveAndValidate*/);  // get information from the dialog
	m_mytreectrl.SetNewStyle(TVS_EDITLABELS, m_bEditLabels);
}

void CTreeCtrlPage::OnHasButtons()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_HASBUTTONS, m_bHasButtons);
}

void CTreeCtrlPage::OnHasLines()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_HASLINES, m_bHasLines);
}

void CTreeCtrlPage::OnLinesAtRoot()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_LINESATROOT, m_bLinesAtRoot);
}

void CTreeCtrlPage::OnDisabledDragDrop()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_DISABLEDRAGDROP, m_bDisableDragDrop);
}

void CTreeCtrlPage::OnShowSelAlways()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_SHOWSELALWAYS, m_bShowSelAlways);
}

void CTreeCtrlPage::ShowNotification(LPNMHDR pnmhdr, LRESULT* /*pResult*/)
{
	((CNotifyShowCase *)GetDlgItem(IDC_TREESTATUS))->ShowNotification(pnmhdr->code);
}

void CTreeCtrlPage::OnSingleExpand()
{
	UpdateData(TRUE);
	m_mytreectrl.SetNewStyle(TVS_SINGLEEXPAND, m_bSingleExpand);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\MfcApp\cmnctrl1\toolpage.h ===
// ToolPage.h : header file
//

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CToolBarCtrlPage dialog
#ifndef INC_TOOLPAGE_H
#define INC_TOOLPAGE_H

#include "toolbar1.h"
#include "toolbar2.h"

class CToolBarCtrlPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CToolBarCtrlPage)

// Construction
public:
	CToolBarCtrlPage();
	~CToolBarCtrlPage();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyToolBarCtrlPage)
	//}}AFX_VIRTUAL

// Attributes
protected:
	CStandardBar    m_StandardBar;
	CPaletteBar     m_PaletteBar;
	CToolTipCtrl    m_ToolTip;
// Dialog Data
	//{{AFX_DATA(CToolBarCtrlPage)
	enum { IDD = IDD_TOOLBARCTRL };
	BOOL    m_bAltDrag;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CToolBarCtrlPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	void ChangeCtrlStyle(long lStyle, BOOL bSetStyle);

	// Generated message map functions
	//{{AFX_MSG(CToolBarCtrlPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnAltdrag();
	//}}AFX_MSG
#ifdef FWC
	afx_msg void OnToolbarCommand(UINT nID);
#endif
	DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Core\Remoting\RemotingSuite.cs ===
using System;
using System.IO;
using Maui.TestLog;
using Maui.Core.Remoting;
using Maui.GlobalExceptions;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.Projects;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Ide.Editors;
using Maui.VisualStudio.Whidbey.ProjectItems.VB;
using Maui.VisualStudio.Whidbey.Projects.VB;
using Maui.VisualStudio.Whidbey.Ide.Dialogs;
using Maui.Suites;
using App = Maui.Core.App;

namespace Maui.Suites.RemotingSuite
{
	///-----------------------------------------------------------------------------
	/// <summary>
	/// This suite checks the following:
	///		- Basic functionality works: can create objects remotely (WhibeyApp), Project Editor, Dialogs, SendKeys.
	///		- RemoteWrapper works (.Exists for a dialog)
	///		- Exceptions are routed correctly thorough remoting
	/// This suite does the following:
	///		- Creates an instance of WhidbeyApp remotely
	///		- Creates a VB project
	///		- Creates a VB module, inserts some text into it
	///		- Opens New File Dialog and calls .Exists() mehotd via RemoteWrapper
	///		- Saves All
	///		- Close the App.
	///	Run time: less than 25 seconds
	/// This suite requires MauiServer to be built.
	/// </summary>
	/// <history>
	///		[mkolt] 02/21/2003
	/// </history>
	///-----------------------------------------------------------------------------
	public class RemotingSuite: Suite
	{
		private const string ServerName = "localhost";
		private const string RunningSuffix = ".running";
		
		// Time (millisecs) to sleep in between checking MauiServer running.
		private const int SleepTimeInterval = 300;
		
		// Time to sleep in between checking MauiServer running.
		private static readonly TimeSpan TimeoutWaitingMauiServer = TimeSpan.FromSeconds(30);

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <history>
		///		[mkolt] 02/21/2003
		/// </history>
		///-----------------------------------------------------------------------------
		public RemotingSuite()
		{
		}

                ///-----------------------------------------------------------------------------
                /// <summary>
                ///    Whether the suite is to be used when (e.g. if you want to disable it, use this property).
                /// </summary>
                /// <history>
                ///    [victoru]	05/29/2003	Created
                /// </history>
                ///-----------------------------------------------------------------------------
                public override bool IsEnabled
                {
                    get
                    {
                        return true;
                    }
                }

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		/// <history>
		///    [victoru]	06/15/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "VictorU";
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Run the suite.
		/// </summary>
		/// <history>
		///		[mkolt]		02/21/2003	Created
		///		[victoru]	08/25/2004	Fixed project creation
		/// </history>
		///-----------------------------------------------------------------------------
		public override void Run()
		{
			System.Diagnostics.Process mauiServerProcess = null;

			try
			{
				// First start MauiServer.exe.
				mauiServerProcess = StartMauiServer(PathToMauiServerExe);

				using (RemotingClient client = new RemotingClient(ServerName))
				{
					//********************************************************************
					LogManager.InitScenario("Launch WhidbeyApp");
					WhidbeyApp app = (WhidbeyApp) client.CreateInstance(typeof(WhidbeyApp));
					
					//********************************************************************
					LogManager.InitScenario("Create a VB project");
					ProjectParameters pars = new ProjectParameters(
						ProjectTypes.VisualBasicProjects, ProjectTemplates.VB_WindowsApplication);
                    Project.RemoteWrapper projectWrapper = Project.RemoteWrapper.GetInstance(client);
					Project project = projectWrapper.NewProject(ref pars);

					//********************************************************************
					LogManager.InitScenario("Create a VBModule in the VB project");
					VBModule projItem = (VBModule) client.CreateInstance(typeof(VBModule), project);

					//********************************************************************
					LogManager.InitScenario("Edit the Module");
					TextEditor editor = projItem.Editor;
					editor.Cursor.Move(1, 1);
					editor.SendKeys("' Hello Remoting!{ENTER}");

					//********************************************************************
					LogManager.InitScenario("Save All");
					app.RaiseCmd(Constants.Commands.FileSaveAll);

					//********************************************************************
					LogManager.InitScenario("Open New File Dialog and verify Exists()");
					NewFileDialog dlg = (NewFileDialog) client.CreateInstance(typeof(NewFileDialog), app);
					if (!NewFileDialog.RemoteWrapper.GetInstance(client).Exists())
					{
						LogManager.LogFailure("NewFileDialog.Exists() returned false!");
					}

					//********************************************************************
					LogManager.InitScenario("Verify exceptions are routed correctly through remoting");
					try
					{
						project.SelectInSolutionExplorer();
						LogManager.LogFailure("Expected TreeNode.Exceptions.NodeNotFoundException but did not get it!");
					}
					catch (Core.WinControls.TreeNode.Exceptions.NodeNotFoundException)
					{
						// This is what we expect.
					}
					catch (Exception e)
					{
						LogManager.LogFailure(e, "Waiting for TreeNode.Exceptions.NodeNotFoundException, got another exception: ");
					}

					dlg.ClickCancel();
					
					//********************************************************************
					LogManager.InitScenario("Quit");
					app.Quit();
				}
			}
			finally
			{
				if (mauiServerProcess != null)
				{
					try
					{
						mauiServerProcess.Kill();
					}
					catch	// Ignore.
					{
					}
				}
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		/// Helper method to start MauiServer.
		/// </summary>
		/// <param name="path">Path to MauiServer.exe</param>
		/// <history>
		///		[mkolt] 02/21/2003
		/// </history>
		///-----------------------------------------------------------------------------
		private System.Diagnostics.Process StartMauiServer(string path)
		{
			// First check if MauiServer.exe was built and exists.
			if (!File.Exists(path))
			{
				throw new RemotingException("Cannot find MauiServer.exe at " + path);
			}

			// Remove MauiServer.running file.
			string serverRunningFile = path + RunningSuffix;
			if (File.Exists(serverRunningFile))
			{
				try
				{
					File.Delete(serverRunningFile);
				}
				catch	// Do nothing if can't delete - the file can be used by another process, that's Ok.
				{
				}
			}

			// Start Maui Server.
			System.Diagnostics.Process mauiServerProcess = System.Diagnostics.Process.Start(PathToMauiServerExe);

			// Wait until MauiServer loads.
			// TODO: use Maui.Core.Sleeper after we integrate Maui.Core.CC changes into QALab22Dev.
			DateTime startTime = DateTime.Now;
			while (!File.Exists(serverRunningFile) && DateTime.Now - startTime < TimeoutWaitingMauiServer)
			{
				System.Threading.Thread.Sleep(SleepTimeInterval);
			}
			if (!File.Exists(serverRunningFile))
			{
				throw new RemotingException("Timed out waiting MauiServer to start!");
			}

			return mauiServerProcess;
		}

		/// <summary>
		/// The property calculates path to MauiServer.exe.
		/// It is neceaarsy because the working folder for the suite
		/// is not guaranteed to be the same as the folder where the
		/// executable is located.
		/// </summary>
		/// <history>
		///		[victoru]	05/01/2003	Created
		/// </history>
		private string PathToMauiServerExe
		{
			get
			{
				string filePath;
				
				filePath = System.IO.Path.GetDirectoryName(System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);
				filePath += @"\..\..\..\Maui\Core\Remoting\MauiServer\bin\MauiServer.exe";
				return filePath;
			}
		}


		///-----------------------------------------------------------------------------
		/// <summary>
		/// Entry point of .exe.
		/// </summary>
		/// <history>
		///		[mkolt] 02/21/2003
		/// </history>
		///-----------------------------------------------------------------------------
		public new static int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\ProgressStatus\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\SettingsAndContraintsSuite\SettingsAndConstraintsSuite.cs ===
#region Imports
using System;
using System.Reflection;
using Maui.TestLog;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.ApplicationDesign;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.LogicalInfrastructureDesign;
#endregion

namespace Maui.Suites.WhitehorseSuite
{
	/// <summary>
	///		Whitehorse SCE Suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 55 seconds (on P4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly on CHK builds.
	/// </requirements>
	/// <remarks>
	/// </remarks>
	/// <history>
	///		[crickman]	01/21/2004	Created
	/// </history>
	public class SettingsAndConstraintsSuite : WhidbeySuite
	{
		private bool _AutoHidePropertyBrowser;
		private bool _AutoHideToolbox;
		private Toolbox _Toolbox;
        private LogicalInfrastructureDesigner _Designer;
        private SettingsConstraintsEditor _Editor;

		/// <summary>
		///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
		/// </summary>
		public override bool IsEnabled
		{
			get
			{
				return false;
			}
		}

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "erbily";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		public override void Initialize()
		{
			base.Initialize();
			
			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			_AutoHidePropertyBrowser = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			_Toolbox = new Toolbox(App);
			_AutoHideToolbox = _Toolbox.AutoHide;
			_Toolbox.AutoHide = false;
		}

        /// <summary>
        /// Creates a blank solution
        /// </summary>
        private void CreateSolution()
        {
            LogManager.InitScenario("Create a blank solution.");
            SolutionParameters sp = new SolutionParameters(App);
            sp.CreationMode = SolutionCreationMode.CreateNew;
            App.Solution = new Solution(sp);
        }

        /// <summary>
        /// Creates a blank LSAD
        /// </summary>
        private void CreateDesigner()
        {             
            LogManager.InitScenario("Create LSAD.");
            ProjectItemParameters pp = new ProjectItemParameters();
            pp.App = App;
            pp.CreationMode = ProjectItemCreationMode.AddNew;
            pp.UseCodemarkers = false;
            LogicalInfrastructureModelFile modelFile = new LogicalInfrastructureModelFile(pp);
            App.PropertyBrowser.Show();
            App.MainWindow.Extended.State = Core.WindowState.Maximize;
            _Designer = modelFile.Designer;
        }

        /// <summary>
        /// Populates LSAD with zone and hosts
        /// </summary>
        private void CreateDiagram()
        {
            LogManager.InitScenario("Add a new zone to the diagram." );
            Zone zone = new Zone( _Designer.Diagram, ToolboxCreateMethod.DragDrop, _Designer.Diagram.X + 32, _Designer.Diagram.Y + 32 );
            
            LogManager.InitScenario("Add a new host inside the zone." );
            Iis60Host innerHost = new Iis60Host( zone, ToolboxCreateMethod.DragDrop, zone.X + zone.Width / 2, zone.Y + zone.Height / 2 );
        }

        /// <summary>
        /// Ensure SCE window is displayed
        /// </summary>
        private void ShowEditor()
        {
            LogManager.InitScenario("Ensure SCE is displayed" );            
            _Editor = new SettingsConstraintsEditor();
			_Editor.Resize(VSWindow.WindowSide.wsTop, -300); 
        }

        /// <summary>
        /// Close solution w/o saving
        /// </summary>
        private void CloseSolution()
        {
            LogManager.InitScenario("Close solution without saving it (otherwise HUGE perf impact).");
            App.Solution.Close(SaveSolution.No);
        }

		/// <summary>
		/// Runs the suite.
		/// </summary>
		public override void Run()
		{
            CreateSolution();
            CreateDesigner();
            CreateDiagram();
            ShowEditor();

            LogManager.InitScenario("Select Host." );
            _Designer.Diagram.Zones[ 0 ].Hosts[ 0 ].Select();

            LogManager.InitScenario("Navigate tree in SCE." );
            NavigationTree nav = new NavigationTree( _Editor );
            nav.ConstraintsCategoryNode.Expand();
            if ( nav.ConstraintsCategoryNode.Nodes.Count == 0 )
                LogManager.LogFailure( "Constraints node does not have children" );
			nav.SettingsCategoryNode.EnsureVisible(); 
			nav.SettingsCategoryNode.Expand();
            if ( nav.SettingsCategoryNode.Nodes.Count == 0 )
                LogManager.LogFailure( "Settings node does not have children" );

            CloseSolution();
		}

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				_Toolbox.AutoHide = _AutoHideToolbox;
				App.PropertyBrowser.AutoHide = _AutoHidePropertyBrowser;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		[STAThread()]
		public static new int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\SolutionDesignerSuite\SolutionDesignerSuite.cs ===
#region Imports
using System;
using System.Reflection;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.CodeServices;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.ApplicationDesign;
#endregion

namespace Maui.Suites.WhitehorseSuite
{
	/// <summary>
	///		Whitehorse Solution Designer and Member Details Window joined check-in suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 1 min 40 seconds (on 4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly in powered user mode or on checked builds.
	/// </requirements>
	/// <remarks>
	///		This check-in suite will create blank solution with Distributed Application Diagram
	///		in it. Then it will add some components to the diagram and perform UI operations
	///		on them. Finally, a web-port will be added to Web component and port operations
	///		will be edited in Member Details window at the bottom.
	///		
	///		Most common possible failures:
	///			- ExecutionEngineException and debug dialog during the TC - VSWhidbey 65259
	///			- NullReferenceException during operations in MDW - VSWhidbey
	///			- Shape not created or not moved - Maui.VisualStudio.Whidbey.Whitehorse.dll problems
	///			- Other failures - please see dmitriv or cedricda.
	/// </remarks>
	/// <history>
	///		[dmitriv]	3/14/2003	Created
	///     [dmitriv & yuxiao] 4/29/2003 Updated to work again
	///		[liangz]	8/9/2004	Updated to the new version 
	/// </history>
	public class SolutionDesignerSuite : WhidbeySuite
	{
		private bool propertyBrowserAutoHide;
		private bool toolboxAutoHide;
		private Toolbox toolbox;

        /// <summary>
        ///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
        /// </summary>
        /// <history>
        ///    [victoru]	05/29/2003	Created
        /// </history>
        public override bool IsEnabled
        {
            get
            {
                return true;
            }
        }

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		/// <history>
		///    [victoru]	06/15/2003	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "LiangZ";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		public override void Initialize()
		{
			base.Initialize();

			Maui.Core.Resources.ManagedStringHandler.EnableWhidbeyResourceBridge = true;
			LogManager.LogHacksPerMethod = 1;

			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			propertyBrowserAutoHide = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			toolbox = new Toolbox(App);
			toolboxAutoHide = toolbox.AutoHide;
			toolbox.AutoHide = false;
		}

		/// <summary>
		/// Runs the suite.
		/// </summary>
		public override void Run()
		{
			LogManager.InitScenario("Create a blank solution.");
			SolutionParameters sp = new SolutionParameters(App);
			sp.CreationMode = SolutionCreationMode.CreateNew;
			App.Solution = new Solution(sp);

			LogManager.InitScenario("Create Distributed Application Diagram.");
			ProjectItemParameters pp = new ProjectItemParameters();
			pp.App = App;
			pp.CreationMode = ProjectItemCreationMode.AddNew;
			pp.UseCodemarkers = false;
			ApplicationModelFile modelFile = new ApplicationModelFile(pp);
			App.PropertyBrowser.Show();
			App.MainWindow.Extended.State = Core.WindowState.Maximize;

			SolutionDesigner designer = modelFile.Designer;
			SolutionDiagram diagram = designer.Diagram;			

			LogManager.InitScenario("Add a Web Service Component to the diagram.");
			WebServiceComponent wsc = new WebServiceComponent(diagram);
			string wscName = wsc.DisplayName;

			LogManager.InitScenario("Move the Web Service Component.");
			wsc.ClickDrag(wsc.X + 250, wsc.Y, false, 200);
			designer.WaitForUIReady();

			LogManager.InitScenario("Create an External Web Service component on the diagram.");
			ExternalWebServiceComponent exWeb = new ExternalWebServiceComponent(diagram);

			LogManager.LogHack("Create Connection", "Determine why this fails");
			//LogManager.InitScenario("Create a connection between the External Web Service component and the Web Service component.");
			//ApplicationConnection conn = new ApplicationConnection(exWeb.ProviderPorts[0], wsc);

			//LogManager.InitScenario("Redraw the connection.");
			//conn.Redraw();

			LogManager.InitScenario("Add a Windows Client component to the diagram.");
			WindowsClientComponent winClient = new WindowsClientComponent(diagram);

			LogManager.InitScenario("Add a Database component to the diagram.");
			DeployedDatabaseComponent db = new DeployedDatabaseComponent(diagram);
			
			LogManager.InitScenario("Delete deafult port on Web Service Component.");
			wsc.Ports[0].Delete(CommandMethod.ContextMenu);

			LogManager.LogHack("Create web service port", "Determine why this fails");
/*
			LogManager.InitScenario("Create Web Service port on Web Application Component.");
			WebProviderPort rp = new WebProviderPort(diagram.Components[wscName]);

			LogManager.InitScenario("Connect Web Service component to the Windows component.");
			ApplicationConnection conn3 = new ApplicationConnection(rp, winClient, WireCreateMethod.DragSourcePort);

			LogManager.InitScenario("Resize the Windows Client component.");
			winClient.Resize(Direction.BottomRight, 20);

			LogManager.InitScenario("Rename both components.");
			wsc.Name = "ServiceProvider";
			winClient.Name = "ServiceConsumer";

			LogManager.InitScenario("Remove the Database component from the diagram.");
			db.Delete(CommandMethod.Keyboard);
			designer.WaitForUIReady();

			LogManager.InitScenario("Show member details window on port.");
			rp.Click(Core.MouseClickType.DoubleClick);
			PortDetailsWindow pdw = new PortDetailsWindow(App);

			LogManager.InitScenario("Add an operation to the port.");
			PortNode portNode = (PortNode)pdw.RootNode;
			OperationNode opNode = portNode.AddOperation("GetServiceName", "string");

			LogManager.InitScenario("Change operation name and type.");
			opNode.Name = "GetListPrice";
			opNode.Type = "int";

			LogManager.InitScenario("Add parameters to operation.");
			OperationParameterNode param1 = opNode.AddParameter("skuName", "string");
			OperationParameterNode param2 = portNode.Operations[0].AddParameter("number", "int");
			
			LogManager.InitScenario("Change parameters modifiers.");
			param1.DetailsWindow.CodeLanguage = CodeLanguage.VisualBasic;
			param1.Modifier = Maui.VisualStudio.Whidbey.CodeServices.ParameterModifier.Ref;
			param2.Modifier = Maui.VisualStudio.Whidbey.CodeServices.ParameterModifier.Value;

			LogManager.InitScenario("Expand/collapse nodes in MDW.");
			opNode.Collapse();
			opNode.Expand();
			portNode.Collapse();
			portNode.Expand();

			LogManager.InitScenario("Delete parameter node.");
			opNode.Parameters[0].Select();
			param1.Delete(CommandMethod.Keyboard);

			LogManager.InitScenario("Delete operation node.");
			opNode.Delete(CommandMethod.ContextMenu);
*/
			LogManager.InitScenario("Close solution without saving it (otherwise HUGE perf impact).");
			App.Solution.Close(SaveSolution.Yes);
		}

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				toolbox.AutoHide = toolboxAutoHide;
				App.PropertyBrowser.AutoHide = propertyBrowserAutoHide;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		[STAThread()]
		public static new int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\SystemDesignerSuite\SystemDesigner.cs ===
#region Imports
using System;
using System.Reflection;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.CodeServices;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.ApplicationDesign;
#endregion

namespace Maui.Suites.WhitehorseSuite
{
	/// <summary>
	///		Whitehorse System Designer check-in suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 1 min 40 seconds (on 4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly in powered user mode or on checked builds.
	/// </requirements>
	/// <remarks>
	///		This check-in suite will create blank solution with Distributed Application Diagram
	///		in it. Then it will add some components to the diagram and create System Designer from
	///		ACD diagram or from the solution explorer, then perform some UI operations
	///		on them. 
	///		
	///		Most common possible failures:
	///			- Shape not created or not moved - Maui.VisualStudio.Whidbey.Whitehorse.dll problems
	///			- Other failures - please see liangz.
	/// </remarks>
	/// <history>
	///		[liangz]	8/9/2004	Created
	/// </history>
	public class SolutionDesignerSuite : WhidbeySuite
	{
		private bool propertyBrowserAutoHide;
		private bool toolboxAutoHide;
		private Toolbox toolbox;

        /// <summary>
        ///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
        /// </summary>
        /// <history>
        ///    [liangz]		8/9/2004	Created
        /// </history>
        public override bool IsEnabled
        {
            get
            {
                return false;
            }
        }

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		/// <history>
		///    [liangz]	08/09/2004	Created
		/// </history>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "LiangZ";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		public override void Initialize()
		{
			base.Initialize();

			Maui.Core.Resources.ManagedStringHandler.EnableWhidbeyResourceBridge = true;
			LogManager.LogHacksPerMethod = 1;

			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			propertyBrowserAutoHide = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			toolbox = new Toolbox(App);
			toolboxAutoHide = toolbox.AutoHide;
			toolbox.AutoHide = false;
		}

		/// <summary>
		/// Runs the suite.
		/// </summary>
		public override void Run()
		{
			LogManager.InitScenario("Create a blank solution.");
			SolutionParameters sp = new SolutionParameters(App);
			sp.CreationMode = SolutionCreationMode.CreateNew;
			App.Solution = new Solution(sp);

			LogManager.InitScenario("Create Distributed Application Diagram.");
			ProjectItemParameters pp = new ProjectItemParameters();
			pp.App = App;
			pp.CreationMode = ProjectItemCreationMode.AddNew;
			pp.UseCodemarkers = false;
			ApplicationModelFile modelFile = new ApplicationModelFile(pp);
			App.PropertyBrowser.Show();
			App.MainWindow.Extended.State = Core.WindowState.Maxmize;

			SolutionDesigner designer = modelFile.Designer;
			SolutionDiagram diagram = designer.Diagram;			

			LogManager.InitScenario("Add a Web Service Component to the diagram.");
			WebServiceComponent wsc = new WebServiceComponent(diagram);
			string wscName = wsc.Name;
			string portName = wsc.ProviderPorts[0].DisplayName;

			LogManager.InitScenario("Create an External Web Service component on the diagram.");
			ExternalWebServiceComponent exWeb = new ExternalWebServiceComponent(diagram);
			string exWebName = exWeb.Name;

			//LogManager.InitScenario("Create a connection between the External Web Service component and the Web Service component.");
			//ApplicationConnection conn = new ApplicationConnection(exWeb.ProviderPorts[0], wsc);

			LogManager.InitScenario("Create a System Designer via ACD context menu.");
			SubSystemDiagram sd = diagram.CreateSubSystemDiagram();
			sd.Designer.WaitForUIReady();
			sd.CompoundComponent.Click();
			sd.Designer.WaitForUIReady();
			string sdName1 = sd.Name;

			//LogManager.InitScenario("Create a delegation of the Web Service endpoint.");
			//ComponentPort cPort = sd.Components[wscName].ProviderComponentPorts[portName];
			//string cPortName = cPort.Name;
			//cPort.Delegate();
			//sd.Designer.WaitForUIReady();
			//if (sd.ProxyPorts.Count != 1)
			//    LogManager.LogFailure("The proxy port is not created on the diagram.");
			//if (sd.Delegations.Count != 1)
			//    LogManager.LogFailure("The delegation is not created on the diagram.");
			//if (sd.Delegations[0].SourcePort.Name != cPortName)
			//    LogManager.LogFailure("The delegation's source port name is not the web service port.");

			LogManager.InitScenario("Create second SD via solution explorer.");
			ProjectItemParameters para = new ProjectItemParameters();
			para.App = App;
			para.CreationMode = ProjectItemCreationMode.AddNew;
			para.UseCodemarkers = false;
			SubSystemModelFile sdFile = new SubSystemModelFile(para);
			SubSystemDiagram sd2 = sdFile.Designer.Diagram;

			LogManager.InitScenario("Click the second SD diagram.");
			sd2.Designer.WaitForUIReady();
			sd2.CompoundComponent.Click();

			LogManager.InitScenario("Create a component use of the Web Service component to the diagram.");
			WebServiceComponentUse webUse = new WebServiceComponentUse(sd2, wscName);

			LogManager.InitScenario("Create a component use of the External Web Service component.");
			ExternalWebServiceComponentUse exWebUse = new ExternalWebServiceComponentUse(sd2, exWebName);

			LogManager.InitScenario("Add a nested system of Sd1 on this SD.");
			NestedSystem ns = new NestedSystem(sd2, sdName1);

			// Comment following step out, since there is a product bug, when creating a connection
			// between two component port, just got red cross on the designer.
			//LogManager.InitScenario("Create a connection between the Web Component use and the External Web Component use.");
			//ApplicationWire wire = new ApplicationWire(exWebUse.ProviderComponentPorts[0], webUse.ConsumerComponentPorts[0]);

			LogManager.InitScenario("Close solution without saving it (otherwise HUGE perf impact).");
			App.Solution.Close(SaveSolution.No);
		}

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				toolbox.AutoHide = toolboxAutoHide;
				App.PropertyBrowser.AutoHide = propertyBrowserAutoHide;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		[STAThread()]
		public static new int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\SubsystemMapperSuite\SubsystemMapper.cs ===
using System;
using System.IO;
using System.Reflection;
using Maui.Core;
using Maui.Core.Utilities;
using Maui.TestLog;
using Maui.VisualStudio.Whidbey;
using Maui.VisualStudio.Whidbey.CodeServices;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.Dialogs;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.ApplicationDesign;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.LogicalInfrastructureDesign;
using Maui.VisualStudio.Whidbey.Whitehorse.Designers.SdmDesigners.SubsystemMapper;

namespace Maui.Suites.WhitehorseSuite
{
	/// <summary>
	///		Whitehorse System Deployment Designer test stuie
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 5 minutes
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly in powered user mode or on checked builds.
	/// </requirements>
	/// <remarks>
	/// </remarks>
	/// <history>
	///		[crickman]	9/12/2003	Created
	/// </history>
	public class SubsystemMapperSuite : WhidbeySuite
	{
		private bool _AutoHidePropertyBrowser;
		private bool _AutoHide_Toolbox;
		private Toolbox _Toolbox;
		private SubsystemMapper _Mapper;
        private SolutionDesigner _Dsd;
        private LogicalInfrastructureDesigner _Lsad;
        private string asp1Name = "";
        private string asp1PortName = "";
        private string asp2Name = "";
        private string hostPortName = "";

        /// <summary>
        ///     Whether the suite is to be used when ( e.g. if you want to disable it, use this property ).
        /// </summary>
        public override bool IsEnabled
        {
            get
            {
				return false;
            }
        }

		///-----------------------------------------------------------------------------
		/// <summary>
		///    The suite owner.
		/// </summary>
		///-----------------------------------------------------------------------------
		public override string Owner
		{
			get
			{
				return "jliperi";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		///-----------------------------------------------------------------------------
		public override void Initialize()
		{
			base.Initialize();
			Maui.Core.Resources.ManagedStringHandler.EnableWhidbeyResourceBridge = true;

			LogManager.LogHacksPerMethod = 1;
			
			LogManager.InitScenario( "Make sure tool windows are docked as we want" );
			_AutoHidePropertyBrowser = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			App.PropertyBrowser.Show();
			App.MainWindow.Extended.State = Core.WindowState.Maximize;
			_Toolbox = new Toolbox( App );
			_AutoHide_Toolbox = _Toolbox.AutoHide;
			_Toolbox.AutoHide = false;

		}

        /// <summary>
        /// Creates a blank solution
        /// </summary>
        private void CreateSolution()
        {
            LogManager.InitScenario("Create a blank solution.");
            SolutionParameters sp = new SolutionParameters(App);
            sp.CreationMode = SolutionCreationMode.CreateNew;
            App.Solution = new Solution(sp);
        }

        /// <summary>
        /// Creates a DSD
        /// </summary>
        private void CreateDSD()
        {
            LogManager.InitScenario("Create DSD.");
            ProjectItemParameters dsdParams = new ProjectItemParameters();
            dsdParams.App = App;
            dsdParams.CreationMode = ProjectItemCreationMode.AddNew;
            dsdParams.UseCodemarkers = false;
            ApplicationModelFile modelFile = new ApplicationModelFile( dsdParams );

            _Dsd = modelFile.Designer;
            WebServiceComponent asp1 = new WebServiceComponent( _Dsd.Diagram, ToolboxCreateMethod.DragDrop );
            WebServiceComponent asp2 = new WebServiceComponent( _Dsd.Diagram, ToolboxCreateMethod.DragDrop );

            asp1Name = asp1.Name;
            asp1PortName = asp1.Ports[0].Name;
            asp2Name = asp2.Name;
        }

        /// <summary>
        /// Creates a LSAD
        /// </summary>
        private void CreateLSAD()
        {
            LogManager.InitScenario("Create LSAD.");
            ProjectItemParameters lsadParams = new ProjectItemParameters();
            lsadParams.App = App;
            lsadParams.CreationMode = ProjectItemCreationMode.AddNew;
            lsadParams.UseCodemarkers = false;
            LogicalInfrastructureModelFile lsadFile = new LogicalInfrastructureModelFile( lsadParams );

            _Lsad = lsadFile.Designer;
            //_Lsad.Diagram.Zoom( ZoomFactor.Zoom75, ZoomMethod.Toolbar );
            LogManager.InitScenario("Add a new host." );
            Iis60Host host = new Iis60Host(_Lsad.Diagram, ToolboxCreateMethod.DragDrop);
            hostPortName = host.GetDefaultPort(typeof(WebSitePort)).Name;
        }

        /// <summary>
        /// Creates a blank mapper
        /// </summary>
        private void CreateMapper()
        {
            string name = _Lsad.Diagram.Name;
            _Dsd.EnsureVisible();           
			_Mapper = new SubsystemMapper( _Dsd, name, true );
            _Mapper.WaitForDteReady();
            _Mapper.SetFocus();
		}

        /// <summary>
        /// Creates all required designers
        /// </summary>
        private void CreateDesigner()
        {
            CreateDSD();
            CreateLSAD();
            CreateMapper();
        }

        /// <summary>
        /// Close solution w/o saving
        /// </summary>
        private void CloseSolution()
        {
            LogManager.InitScenario("Close solution without saving it (otherwise HUGE perf impact).");
            App.Solution.Close(SaveSolution.No);
        }

		/// <history>
		///		[crickman]	9/12/2003	Created
		/// </history>
		public override void Run()
		{           
			LogManager.InitScenario("Initialize solution");
            CreateSolution();
            CreateDesigner();

            LogManager.InitScenario("Test Mapper State");
            _Mapper.WaitForDteReady();
            Sleeper.Delay(2000);
            Assert( _Mapper.IsActiveDocument, "Is DD active?" );
			Assert( _Mapper.HasFocus, "Does DD have focus?" );

            LogManager.InitScenario("Test Mapper Diagram");
            SubsystemMapperDiagram diagram = _Mapper.Diagram;
            Assert( null != diagram, "Diagram is not accessible" );
            if ( null != diagram )
            {
                LogManager.InitScenario("Confirm existence of host");
                if (diagram.Hosts.Count != 1)
                {
                    LogManager.LogFailure("Unexpected number of hosts", "1", diagram.Hosts.Count.ToString());
                    CloseSolution();
                    return;
                }
                
                LogManager.InitScenario("Confirm host has no bindings");
                Host host = diagram.Hosts[0];
                if (host.Map.List.Count != 0)
                {
                    LogManager.LogFailure("Unexpected number of map entries", "0", host.Map.List.Count.ToString());
                    CloseSolution();
                    return;
                }

                LogManager.InitScenario("Confirm binding action via drag-drop");
                this.BindComponentToHost(diagram, host, 0);

                if (host.Map.List.Count != 1)
                    LogManager.LogFailure("Unexpected number of map entries", "1", diagram.Zones[0].Hosts[0].Map.List.Count.ToString());

                LogManager.InitScenario("Confirm binding action via bind dialog");
		// TODO: JLiperi, fix so that things aren't indexed by number
                MapComponentDialog bindDialog = this.SurfaceDialog(0);
                bindDialog.ClickOK();

                if (host.Map.List.Count != 2)
                    LogManager.LogFailure("Unexpected number of map entries", "2", host.Map.List.Count.ToString());

                LogManager.LogHack("Run", "Bug is blocking Endpoint Binding Details dialog automation", false, "437661");
                //LogManager.InitScenario("Verify Endpoint Binding Details dialog functionality");
                //MapEntry entry = host.Map.List[0];
                //MappingDetailsDialog bindDetailsDialog = entry.ShowDetails();
                //bindDetailsDialog.MapPort(asp1PortName, hostPortName);
                //string noneString = this.App.GetIntlStr(Maui.VisualStudio.Whidbey.Whitehorse.Strings.SubsystemMapper.Dialogs.ApplicationPoolNone);
                //bindDetailsDialog.Controls.ApplicationPoolComboBox.SelectByText(noneString);
                //bindDetailsDialog.ClickOK();
            }
                                   
            CloseSolution();
		}

        private string BindComponentToHost(SubsystemMapperDiagram diagram, Host host, int componentIndex)
        {
            MapControl map = host.Map;
            diagram.ScrollInView(map.X + map.Width / 2, map.Y + map.Height / 2);
            return BindComponentToPoint(componentIndex, map.X + map.Width / 2, map.Y + map.Height / 2);
        }

        private string BindComponentToPoint(int componentIndex, int x, int y)
        {
            string componentName = null;
            MapDesignerNode node = GetComponentNode(componentIndex);
            if (null != node)
            {
                componentName = node.Name;
                node.ClickDragToDesigner(x, y);
            }
            return componentName;
        }

        private MapDesignerNode GetComponentNode(int componentIndex)
        {
            ComponentView cv = new ComponentView( this.App );
            cv.Show();
            MapDesignerNode node = (MapDesignerNode)cv.GetNode(componentIndex);
            this.Assert(null != node, "Unable to access component node");
            return node;
        }

        protected MapComponentDialog SurfaceDialog(int index)
        {
            MapComponentDialog dlg = null;
            try
            {
                ComponentView cv = new ComponentView(this.App);
                cv.Show();
                MapDesignerNode node = (MapDesignerNode)cv.GetNode(index);
                dlg = node.MapComponent(CommandMethod.ContextMenu);
            }
            catch (Exception ex)
            {
                LogManager.LogFailure(ex, "Expected dialog not found!");
            }
            return dlg;
        }

        /// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario( "Restore docking of windows" );
			try
			{
				App.PropertyBrowser.AutoHide = _AutoHidePropertyBrowser;
				_Toolbox.AutoHide = _AutoHide_Toolbox;
			}
			catch(  Exception ex  )
			{
				LogManager.LogFailure(  ex  );
			}
			base.Cleanup();
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="cond"></param>
		/// <param name="msg"></param>
		private void Assert( bool cond, string msg )
		{
			if ( !cond )
				LogManager.LogFailure( String.Format( "{0} {1}", msg, cond ));
			else
				LogManager.WriteEntry( EntryType.Standard, String.Format( "PASS: {0} {1}", msg, cond ));

		}

		[STAThread()]
		public static new int Main()
		{
			return Suite.Main();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\ClassDesignerSuite\ClassDesignerSuite.cs ===
#region Using statements

using System;
using System.Reflection;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Whidbey.CodeServices;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Projects;
using System.IO;
using Maui.Core.Utilities;

#endregion

namespace Maui.VisualStudio.Whidbey.Whitehorse.Designers.ClassDesign
{
	/// <summary>
	///		Whitehorse Class Designer check-in suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 1 min 40 seconds (on 4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly in powered user mode or on checked builds.
	/// </requirements>
	/// <remarks>
	///		This check-in suite tests the basic functionality performed in the Class Diagram.
	///		It creates a new diagram, drags shapes from the toolbox and class-view and modifies 
	///		how the information that is displayed.
	///		It also creates relationships such as interface implementation, inheritance and association,
	///		and adds/modifies some members via the Class Details Window.
	///		
	///		Most common possible failures:
	///			- NullReferenceException during operations in CDW - VSWhidbey
	///			- Shape not created or not moved - Maui.VisualStudio.Whidbey.Whitehorse.dll problems
	///			- Other failures - please see ECutts, DmitriV and CedricDa
	/// </remarks>
	/// <history>
	///		[ecutts]	12/12/2003	Created
	///		[ecutts]	03/12/2004	Updated to work on new QALab23 Gauntlet
	///		[yuxiao]	08/05/2004	Remove Class Details Window test (will have a seperate suite) 
	/// </history>
	public class ClassDesignerSuite  : Maui.Suites.WhidbeySuite
	{
		#region Initialization/properties

		private bool propertyBrowserAutoHide;
		private bool toolboxAutoHide;
		private Toolbox toolbox;

        /// <summary>
        ///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
        /// </summary>
        /// <history>
        ///    [victoru]	05/29/2003	Created
        /// </history>
        public override bool IsEnabled
        {
            get
            {
				return false;
            }
        }

		/// <summary>
		///    The suite owner.
		/// </summary>
		/// <history>
		///    [victoru]	06/15/2003	Created
		/// </history>
		public override string Owner
		{
			get
			{
				return "ECutts, DmitriV";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		public override void Initialize()
		{
			base.Initialize();

			LogManager.LogHacksPerMethod = 1;

			LogManager.InitScenario("Maxmize IDE window.");
			//App.MainWindow.Extended.State = WindowState.Maxmize;

			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			propertyBrowserAutoHide = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			toolbox = new Toolbox(App);
			toolboxAutoHide = toolbox.AutoHide;
			toolbox.AutoHide = false;
		}


		protected override App StartApp()
		{
			// Not sure why base suite doesn't do this, but we don't want Auto Recovery
			// dialog to appear on VS startup.
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\General\AutoRecover",
				"AutoRecover Enabled", 0);
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\General\Disaster Recovery",
				"Disaster Recovery Enabled", 0);

			// A very reliable way to show project references in Class View.
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\Class View",
				"Settings", 0x7e40100);

			return base.StartApp();
		}

		#endregion

		/// <summary>
		/// Runs the suite.
		/// </summary>
		public override void Run()
		{
			LogManager.InitScenario("Create a C# project.");
			Project project = new CSClientProject(ProjectTemplates.CS_ClassLibrary);

			LogManager.InitScenario("Add Class Diagram to the project.");
			ProjectItemParameters cdparams = new ProjectItemParameters(ProjectItemCategories.CSharpProjectItems, Strings.ProjectItems.ClassDiagram);
			cdparams.Parent = project;
			cdparams.CreationMode = ProjectItemCreationMode.AddNew;

			ClassDesigner designer = new ClassDiagramFile(cdparams).Designer;
			ClassDiagram diagram = designer.Diagram;

			LogManager.InitScenario("Create all kinds of shapes and members.");
			ClassShape s1 = new ClassShape(diagram);
			s1.AddMethod();
			s1.AddProperty();
			s1.AddEvent();
			s1.AddField();
			s1.AddConstructor();
			s1.AddDestructor();
			s1.AddConstant();

			InterfaceShape s2 = new InterfaceShape(diagram);
			s2.AddProperty();
			s2.AddMethod();
			s2.AddEvent();

			DelegateShape s3 = new DelegateShape(diagram);
			s3.AddParameter();

			StructShape s4 = new StructShape(diagram);
			s4.AddMethod();
			s4.AddProperty();
			s4.AddEvent();
			s4.AddField();
			s4.AddConstructor();
			s4.AddConstant();

			AbstractClassShape s5 = new AbstractClassShape(diagram);

			EnumShape s6 = new EnumShape(diagram);
			s6.AddMember();
			s6.AddMember();
			s6.AddMember();
			s6.MembersCompartment.Verify.MemberCount(3);

			LogManager.InitScenario("Clear the diagram.");
			diagram.Clear();

			LogManager.LogHack("ClassDesignerSuite", "Disable some functionality due to VSWhidbey toobox bug: 444875");
			//LogManager.InitScenario("Create comment shape and remove it from diagram");
			//Comment comment = new Comment(diagram);
			//comment.Cut();


			//LogManager.InitScenario("Create inheritance line");
			//ClassShape c1 = new ClassShape(diagram);
			//ClassShape c2 = new ClassShape(diagram);
			//InheritanceLine line1 = new InheritanceLine(c1, c2);
			//line1.Delete(CommandMethod.Keyboard);

			//LogManager.InitScenario("Show association line");
			//AssociationLine line2 = new AssociationLine(c1, c2);

			//LogManager.InitScenario("Clean the diagram.");
			//diagram.Clear();

			//LogManager.InitScenario("Set some properties on a new class.");
			//ClassShape c3 = new ClassShape(diagram);
			//c3.AccessModifier = AccessModifier.Internal;
			//c3.Summary = "some summary comment";
			//c3.Remarks = "some remarks comment";
			//c3.InheritanceModifier = InheritanceModifier.Abstract;

			//LogManager.InitScenario("Drag & drop some ref types on the diagram.");
			//ClassShape rt1 = new ClassShape(diagram, "mscorlib", "System.IO.FileStream");
			//InterfaceShape rt3 = new InterfaceShape(diagram, "mscorlib", "System.Collections.ICollection");

			//LogManager.InitScenario("Remove local class from diagram and readd it from Class View.");
			//string c3Name = c3.Name;
			//c3.RemoveFromDiagram();
			//c3 = new ClassShape(diagram, c3.Name);
		}

		#region Cleanup/main

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				toolbox.AutoHide = toolboxAutoHide;
				App.PropertyBrowser.AutoHide = propertyBrowserAutoHide;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		[STAThread()]
		public static new int Main()
		{
			return Maui.Suites.Suite.Main();
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\Products\Visual Studio\Whidbey\Maui.VisualStudio.Whidbey.Whitehorse\ClassDetailsWindowSuite\ClassDetailsWindowSuite.cs ===
#region Using statements

using System;
using System.Reflection;
using Maui.TestLog;
using Maui.Core;
using Maui.VisualStudio.Whidbey.CodeServices;
using Maui.VisualStudio.Whidbey.Ide;
using Maui.VisualStudio.Whidbey.Ide.ToolWindows;
using Maui.VisualStudio.Whidbey.ProjectItems;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows;
using Maui.VisualStudio.Whidbey.Whitehorse.Dialogs;
using Maui.VisualStudio.Whidbey.Whitehorse.ToolWindows.MemberNodes;
using Maui.VisualStudio.Whidbey.Projects;

#endregion

namespace Maui.VisualStudio.Whidbey.Whitehorse.Designers.ClassDesign
{
	/// <summary>
	///		Whitehorse Class Details Window check-in suite.
	/// </summary>
	/// <timeout>
	///		This suite usually completes within 1 min 40 seconds (on 4 CPU 1.6 GHz, 1.00 GB RAM).
	/// </timeout>
	/// <requirements>
	///		To run this suite you need Visual Studio .NET Enterprise Architect installed.
	///		Sometimes might not run correctly in powered user mode or on checked builds.
	/// </requirements>
	/// <remarks>
	///		This check-in suite tests the basic functionality performed in the Class Details Window.
	///		It will run for Class Shape, Enum Shape and Delegate shape. All other type shapes
	///		
	///		Most common possible failures:
	///			- Shape not created or not moved - Maui.VisualStudio.Whidbey.Whitehorse.dll problems
	///			- Other failures - please see YuXiao
	/// </remarks>
	/// <history>
	///		[yuxiao]	08/05/2004	Created
	/// </history>
	class ClassDetailsWindowSuite : Maui.Suites.WhidbeySuite
	{
		#region Initialization/properties

		private bool propertyBrowserAutoHide;
		private bool toolboxAutoHide;
		private Toolbox toolbox;

		/// <summary>
		///     Whether the suite is to be used when (e.g. if you want to disable it, use this property).
		/// </summary>
		/// <history>
		///    [yuxiao]  08/05/2004	Created
		/// </history>
		public override bool IsEnabled
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		///    The suite owner.
		/// </summary>
		/// <history>
		///    [yuxiao]  08/05/2004	Created
		/// </history>
		public override string Owner
		{
			get
			{
				return "YuXiao";
			}
		}

		/// <summary>
		/// Initializes the suite.
		/// </summary>
		/// <history>
		///    [yuxiao]  08/05/2004	Created
		/// </history>
		public override void Initialize()
		{
			base.Initialize();

			Maui.Core.Resources.ManagedStringHandler.EnableWhidbeyResourceBridge = true;
			LogManager.LogHacksPerMethod = 1;

			LogManager.InitScenario("Maxmize IDE window.");
			App.MainWindow.Extended.State = WindowState.Maxmize;

			LogManager.InitScenario("Make sure tool windows are docked as we want.");
			propertyBrowserAutoHide = App.PropertyBrowser.AutoHide;
			App.PropertyBrowser.AutoHide = false;
			toolbox = new Toolbox(App);
			toolboxAutoHide = toolbox.AutoHide;
			toolbox.AutoHide = false;
		}

		/// <summary>
		/// Start Applicaiton
		/// </summary>
		/// <history>
		///    [yuxiao]  08/05/2004	Created
		/// </history>
		protected override App StartApp()
		{
			// Not sure why base suite doesn't do this, but we don't want Auto Recovery
			// dialog to appear on VS startup.
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\General\AutoRecover",
				"AutoRecover Enabled", 0);
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\General\Disaster Recovery",
				"Disaster Recovery Enabled", 0);

			// A very reliable way to show project references in Class View.
			Maui.Core.Utilities.Registry.SetValue(
				Maui.Core.Utilities.RegistryHive.Win32CurrentUser,
				@"Software\Microsoft\VisualStudio\8.0\Class View",
				"Settings", 0x7e40100);

			return base.StartApp();
		}

		#endregion

		/// <summary>
		/// Runs the suite.
		/// </summary>
		/// <history>
		///		[yuxiao]	08/05/2004	Created
		/// </history>
		public override void Run()
		{
			LogManager.InitScenario("Create a C# project.");
			CSClientProject project = new CSClientProject(ProjectTemplates.CS_ClassLibrary);

			LogManager.InitScenario("Add Class Diagram to the project.");
			ProjectItemParameters cdparams = new ProjectItemParameters(ProjectItemCategories.CSharpProjectItems, Strings.ProjectItems.ClassDiagram);
			cdparams.Parent = project;
			cdparams.CreationMode = ProjectItemCreationMode.AddNew;
			ClassDesigner designer = new ClassDiagramFile(cdparams).Designer;
			ClassDiagram diagram = designer.Diagram;

			LogManager.InitScenario("Create test shapes - class, enum and delegate.");
			EnumShape sEnum = new EnumShape(diagram);
			DelegateShape sDelegate = new DelegateShape(diagram);
			ClassShape sClass = new ClassShape(diagram);
			ClassDetailsWindow cdw;
			
			#region Enum shape test
			cdw = sEnum.Details;

			LogManager.InitScenario("Enum - create field in the details window");
			EnumNode en1 = cdw.AddEnum ("testNode0", "1");
			EnumNode en2 = cdw.AddEnum ("testNode1", "2");

			LogManager.InitScenario("Enum - update field (name, value, summary) in the details window");
			en1.Name = "newName";
			en1.Value = "10";
			en1.SummaryField = "test summary";

			LogManager.InitScenario("Enum - hide field from the details window");
			en2.Hide = true;

			//bug 16140
			//LogManager.InitScenario("Enum - remove field in the details window");
			//sEnum.Details.Enums[0].Delete(CommandMethod.Keyboard);

			#endregion

			#region Delegate shape test
			cdw = sDelegate.Details;

			LogManager.InitScenario("Delegate - create parameters in the details window");
			MethodParameterNode dp1 = cdw.Delegate.AddParameter ("testNode0");
			MethodParameterNode dp2 = cdw.Delegate.AddParameter ("testNode1");

			LogManager.InitScenario("Delegate - update parameter (name, type, summary) in the details window");
			//bug 322847
			//dp1.Name = "newName";
			dp1.Type = "int";
			dp1.SummaryField = "test summary";

			//bug 16140
			//LogManager.InitScenario("Delegate - remove parameter in the details window");
			//sEnum.Details.Delegate.Parameters[1].Delete();

			#endregion

			#region Class shape test
			sClass.Select();
			cdw = new ClassDetailsWindow();

			LogManager.InitScenario("Class - create all member nodes (method, parameter, property, event, field) in the details window");
			MethodNode m1 = cdw.AddMethod ("testMethod");
			MethodParameterNode p1 = m1.AddParameter ("testParameter");
			FieldNode f1 = cdw.AddField ("testField");
			PropertyNode pro1 = cdw.AddProperty ("testProperty");
			//EventNode e1 = cdw.AddEvent ("testEvent");

			LogManager.InitScenario("Class - update method (name, type, modifier, summary) in the details window");
			m1 = cdw.Methods[0];
			m1.Name = "newName0";
			m1.Type = "int";
			m1.Modifier = CodeServices.AccessModifier.Protected;
			m1.SummaryField = "test summary";

			LogManager.InitScenario("Class - update parameter (name, type, modifier, summary) in the details window");
			p1 = cdw.Methods[0].Parameters[0];
			p1.Name = "newName1";
			p1.Type = "int";
			p1.SummaryField = "test summary";

			LogManager.InitScenario("Class - update proeprty (name, type, modifier, summary) in the details window");
			pro1 = cdw.Properties[0];
			pro1.Name = "newName1";
			pro1.Type = "int";
			pro1.Modifier = CodeServices.AccessModifier.Protected;
			pro1.SummaryField = "test summary";

			LogManager.InitScenario("Class - update field (name, type, modifier, summary) in the details window");
			f1 = cdw.Fields[0];
			f1.Name = "newName2";
			f1.Type = "int";
			f1.Modifier = CodeServices.AccessModifier.Protected;
			f1.SummaryField = "test summary";

			LogManager.InitScenario("Class - update event (name, type, modifier, summary) in the details window");
			/*e1 = cdw.Events[0];
			e1.Name = "newName3";
			e1.Modifier = CodeServices.AccessModifier.Protected;*/
			
			LogManager.InitScenario("Class - update field's comment using description dialog");		
			f1 = cdw.Fields[0];
			DocumentationDialog dlg = f1.DocumentationDialog;
			dlg.SummaryText = "testSummary";
			dlg.ClickOK();
			
			LogManager.InitScenario("Class - Hide method in the details window");
			sClass.Details.Methods[0].Hide = true;

			LogManager.InitScenario("Class - Remove property in the details window");
			sClass.Details.Properties[0].Cut(CommandMethod.Keyboard);

			#endregion
		}

		#region Cleanup/main

		/// <summary>
		/// Cleans VS IDE after the suite.
		/// </summary>
		/// <history>
		///		[yuxiao]	08/05/2004	Created
		/// </history>
		public override void Cleanup()
		{
			LogManager.InitScenario("Restore docking of windows.");
			try
			{
				toolbox.AutoHide = toolboxAutoHide;
				App.PropertyBrowser.AutoHide = propertyBrowserAutoHide;
			}
			catch (Exception e)
			{
				LogManager.LogFailure(e);
			}

			base.Cleanup();
		}

		/// <summary>
		/// Entry point of the suite.
		/// </summary>
		/// <history>
		///		[yuxiao]	08/05/2004	Created
		/// </history>
		[STAThread()]
		public static new int Main()
		{
			return Maui.Suites.Suite.Main();
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\StringManipulator.cs ===
using System;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for StringManipulator.
	/// </summary>
	public class StringManipulator
	{
		public StringManipulator()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public static string AddSlash(string path)
		{
			path.Replace("\\", "\\\\");
			return path;
		}

		public static string GetFileLocation(string path)
		{
			if(path==null)
				return null;

			int i = path.LastIndexOf("\\");
			return path.Substring(0, i);
		}

		public static string GetNameFromPath(string path)
		{
			if(path==null)
				return null;

			string[] splitPath = path.Split(new char[] {'\\'});
			return splitPath[splitPath.Length - 1];
		}

		public static string RemoveExtension(string name)
		{
			if(name==null)
				return null;

			int i = name.LastIndexOf(".");
			return name.Substring(0, i);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\ProgressStatus\Progress.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Data;
using System.Windows.Forms;
using System.Diagnostics;

namespace ProgressStatus
{
	/// <summary>
	/// Summary description for Progress.
	/// </summary>
	public class Progress : System.Windows.Forms.UserControl
	{
		private System.Windows.Forms.Timer timer1;
		private System.ComponentModel.IContainer components;
		private string text;
		private PointF textLocation = new PointF(20, 20);
		private Rectangle scannerRect;
		private Size scannerSize;
		private Point scannerLocation = new Point(0,0);
		private int increment = 10;
		const int scannerWidth = 140;
		private Color scannerColor = Color.Gainsboro;
		private Rectangle textRect;
		private Brush foreColorBrush;

		public Progress()
		{
			// This call is required by the Windows.Forms Form Designer.
			InitializeComponent();
			text = "Status...";
			this.SetStyle(ControlStyles.DoubleBuffer, true);
			this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);
			this.SetStyle(ControlStyles.UserPaint, true);			
		}

		public override string Text
		{
			get
			{
				return text;
			}
			set
			{
				text = value;
				Initialize();
			}
		}

		public int Increment
		{
			get
			{
				return increment;
			}
			set
			{
				increment = value;
			}
		}

		[Category("Appearance")]
		public Color ScannerColor 
		{
			get 
			{
				return scannerColor;
			}
			set 
			{
				scannerColor = value;
			}
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}

				if ( foreColorBrush == null )
					foreColorBrush.Dispose();
			}
			base.Dispose( disposing );
		}

		#region Component Designer generated code
		/// <summary> 
		/// Required method for Designer support - do not modify 
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			// 
			// timer1
			// 
			this.timer1.Enabled = true;
			this.timer1.Interval = 50;
			this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
			// 
			// Progress
			// 
			this.BackColor = System.Drawing.Color.Black;
			this.Font = new System.Drawing.Font("Microsoft Sans Serif", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.ForeColor = System.Drawing.SystemColors.HighlightText;
			this.Name = "Progress";
			this.Size = new System.Drawing.Size(488, 24);
			this.Resize += new System.EventHandler(this.Progress_Resize);
			this.Load += new System.EventHandler(this.Progress_Load);

		}
		#endregion

		protected override void OnPaint(PaintEventArgs e)
		{
			base.OnPaint(e);

			if ( scannerRect == Rectangle.Empty )
				return;

			Graphics graphics = e.Graphics;

			// draw the scanner...
			Rectangle leftRect = scannerRect;
			Rectangle rightRect = scannerRect;
			leftRect.Width /= 2;
			rightRect.Width /= 2;
			rightRect.Location = new Point(leftRect.Right, rightRect.Location.Y);

			Brush leftBrush = new LinearGradientBrush(leftRect, this.BackColor, scannerColor, LinearGradientMode.Horizontal);
			Brush rightBrush = new LinearGradientBrush(rightRect, scannerColor, this.BackColor, LinearGradientMode.Horizontal);

			graphics.FillRectangle(leftBrush, leftRect);
			graphics.FillRectangle(rightBrush, rightRect);

			if ( foreColorBrush == null )
				foreColorBrush = new SolidBrush(this.ForeColor);

			graphics.DrawString(this.Text, this.Font, foreColorBrush, textLocation);
			ControlPaint.DrawBorder3D(graphics, this.ClientRectangle, Border3DStyle.Flat);

			leftBrush.Dispose();
			rightBrush.Dispose();
		}

		protected override void OnForeColorChanged(EventArgs e)
		{
			base.OnForeColorChanged (e);

			if ( foreColorBrush != null )
				foreColorBrush.Dispose();
			
			foreColorBrush = new SolidBrush(this.ForeColor);
		}


		private void Progress_Load(object sender, System.EventArgs e)
		{
			Initialize();
		}

		private void timer1_Tick(object sender, System.EventArgs e)
		{
			this.scannerRect = new Rectangle(scannerLocation, scannerSize);
			this.Refresh(); // force a repaint
			// update the location of the scanner
			if((scannerLocation.X + scannerSize.Width / 2) > this.Width)
			{
				// restart at the beginning
				increment = Math.Abs(increment) * -1;
				scannerLocation.X += increment;
			}
			else if(scannerLocation.X + scannerRect.Width / 2 < 0)
			{
				increment = Math.Abs(increment);
				scannerLocation.X += increment;
			}
			else
			{
				// move the scanner over by the specified increment
				scannerLocation.X += increment;
			}
		}

		private void Progress_Resize(object sender, System.EventArgs e)
		{
			Initialize();
		}

		private void Initialize()
		{
			Graphics graphics = this.CreateGraphics();
			// get the size of the text
			SizeF stringSize = graphics.MeasureString(this.Text, this.Font);
			// find the the point that would make it so that the text is 
			// centered vertically and horizontally on the usercontrol
			float centerX = (this.Width - stringSize.Width) / 2;
			float centerY = (this.Height - stringSize.Height) / 2;
			this.textLocation = new PointF(centerX, centerY);

			this.textRect = new Rectangle((int)this.textLocation.X, (int)this.Location.Y, (int)stringSize.Width, (int)stringSize.Height);
			// update the size of the scanner since we've been resized
			this.scannerSize = new Size(scannerWidth, this.Height);
			//graphics.Dispose();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\Constants.cs ===
using System;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for Constants.
	/// </summary>
	public class Strings
	{
		public const string Maui = "Maui";
		public const string Suites = "Suites";
		public const string SuitesTxt = "Suites.txt";
		public const string BaseSuite = "BaseSuite";
		public const string WhidbeySuite = "WhidbeySuite";
		public const string SuitesDriverBat = "SuitesDriver.bat";
		public const string BuildAndRunBat = "BuildAndRun.bat";
		public const string Build = "Build";
		public const string Run = "Run";
		public const string ResultSuitesTempXml = "ResultSuitesTemp.xml";
		public const string SummarySuitesTempXml = "SummarySuitesTemp.xml";
		public const string ExeDon = "EXE.DON";
		public const string ResultSuitesXml = "ResultSuites.xml";
		public const string Results = "Results";
		public const string Debug = "Debug";
		public const string bin = "bin";
		public const string WinformAppSuite = "WinformAppSuite";
		public const string WinControlsSuite = "WinControlsSuite";
		public const string ResultsPathsTxt = "ResultsPaths.txt";
		public const string ResultsLog = "Results.log";
		public const string Summary = "Summary";
		public const string Total = "Total";
		public const string Pass = "Pass";
		public const string Fail = "Fail";
		public const string UserSettings = "UserSettings";
		public const string MauiPath = "MauiPath";
		public const string UserSettingsXml = "UserSettings.xml";
		public const string Path = "Path";
		public const string AvoidFoldersXml = "AvoidFolders.xml";
		public const string AvoidFolders = "AvoidFolders";
		public const string Folder = "Folder";
		public const string Name = "Name";
		public const string SuitesDriver = "SuitesDriver";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\ResultManager.cs ===
using System;
using System.IO;
using System.Xml;
using System.Windows.Forms;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for ResultManager.
	/// </summary>
	public class ResultManager
	{
		public ResultManager()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		/// <summary>
		/// Returns true if all suites passed, false otherwise. it also fills up the
		/// array resultsCount with: Total, Pass and fail count values for all suites
		/// </summary>
		/// <param name="finalResultPath">Path of the results file</param>
		/// <param name="resultsCount">Result count array passed by reference</param>
		/// <returns>Boolean</returns>
		private bool GetOverviewResult(string finalResultPath, ref int[] resultsCount)
		{
			XmlDocument result = new XmlDocument();
			try
			{
				result.Load(finalResultPath);
				XmlNodeList summaryList = result.GetElementsByTagName("Summary");
				XmlNode summary = summaryList[0];
				XmlNode allSuites = summary.FirstChild;
				resultsCount[0] = Convert.ToInt32(allSuites.Attributes["Total"].Value);
				resultsCount[1] = Convert.ToInt32(allSuites.Attributes["Pass"].Value);
				resultsCount[2] = Convert.ToInt32(allSuites.Attributes["Fail"].Value);
				if(resultsCount[2]==0)
					return true;
				else
					return false;
			}
			catch(Exception ex)
			{
				ex.ToString();
				return true;
			}
		}

		/// <summary>
		/// Combines the results and the summary files and consolidates
		/// them to produce one results file.
		/// </summary>
		public void ProcessResults()
		{
			AccumulateResults();

			StreamReader resultReader = null;
			StreamReader summaryReader = null;
			StreamWriter writer = null;
			try
			{
				string resultPath = Strings.ResultSuitesTempXml;
				string summaryPath = Strings.SummarySuitesTempXml;
				string finalResultPath = Strings.ResultSuitesXml;

				resultReader = new StreamReader(resultPath);
				summaryReader = new StreamReader(summaryPath);
				writer = new StreamWriter(finalResultPath);

				string line;

				// Write the Header and Root tag
				for(int i=0;i<2;i++)
				{
					line = resultReader.ReadLine();
					writer.WriteLine(line);
				}
				
				// Write the Summary
				line = summaryReader.ReadLine();
				while(line!=null)
				{
					line = summaryReader.ReadLine();
					writer.WriteLine(line);
				}

				// Write the Body
				line = resultReader.ReadLine();
				while(line!=null)
				{
					if(!(line.StartsWith("</" + Strings.Results + "><?") || line.StartsWith("<" + Strings.Results + ">")))
						writer.WriteLine(line);
					line = resultReader.ReadLine();
				}

			}
			catch(Exception ex)
			{
				MessageBox.Show("Error in creating the Xml Results File: \n" + ex.ToString()); 
			}
			finally
			{
				if(resultReader!=null)
					resultReader.Close();
				if(summaryReader!=null)
					summaryReader.Close();
				if(writer!=null)
					writer.Close();
			}
		}

		private void AccumulateResults()
		{
			File.Delete(Strings.ResultSuitesTempXml);
			File.Delete(Strings.SummarySuitesTempXml);
			File.Delete(Strings.ResultSuitesXml);
			File.Delete(Strings.ResultsLog);

			StreamReader pathsReader = null;
			try
			{
				pathsReader = new StreamReader(Strings.ResultsPathsTxt);

				int[] counts = new int[3];
				string path;
				path = pathsReader.ReadLine();
				while(path!=null)
				{
					GetResultsXml(path + "\\" + Strings.ResultSuitesTempXml);
					GetResultsLog(path + "\\" + Strings.ResultsLog);
					counts = GetSummaryCounts(path + "\\" + Strings.SummarySuitesTempXml, counts);
					path = pathsReader.ReadLine();
				}
				this.WriteSummary(counts);
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(pathsReader!=null)
					pathsReader.Close();
			}
		}

		private void GetResultsXml(string path)
		{
			StreamReader resultReader = null;
			StreamWriter writer = null;
			try
			{
				resultReader = new StreamReader(path);
				writer = new StreamWriter(Strings.ResultSuitesTempXml, true);

				string line;
				line = resultReader.ReadLine();
				while(line!=null)
				{
					if(line=="</" + Strings.Results + ">")
						writer.Write(line);
					else
						writer.WriteLine(line);
					line = resultReader.ReadLine();
				}
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(resultReader!=null)
					resultReader.Close();
				if(writer!=null)
				{
					writer.Flush();
					writer.Close();
				}
			}
		}

		private void GetResultsLog(string path)
		{
			StreamReader resultReader = null;
			StreamWriter writer = null;
			try
			{
				resultReader = new StreamReader(path);
				writer = new StreamWriter(Strings.ResultsLog, true);

				string line;
				line = resultReader.ReadLine();
				while(line!=null)
				{
					writer.WriteLine(line);
					line = resultReader.ReadLine();
				}
				writer.WriteLine();
				writer.WriteLine("#####################################################################################");
				writer.WriteLine("#####################################################################################");
				writer.WriteLine();
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(resultReader!=null)
					resultReader.Close();
				if(writer!=null)
				{
					writer.Flush();
					writer.Close();
				}
			}
		}

		private int[] GetSummaryCounts(string path, int[] counts)
		{
			XmlDocument xmlReader = new XmlDocument();
			xmlReader.Load(path);
			XmlNode summaryNode = xmlReader.GetElementsByTagName(Strings.Summary)[0];
			XmlNode totalNode = summaryNode.ChildNodes[0];
			int total = Convert.ToInt32(totalNode.Attributes[Strings.Total].Value);
			int pass = Convert.ToInt32(totalNode.Attributes[Strings.Pass].Value);
			int fail = Convert.ToInt32(totalNode.Attributes[Strings.Fail].Value);
			return new int[] {counts[0] + total, 
								 counts[1] + pass, 
								 counts[2] + fail};
		}

		private void WriteSummary(int[] counts)
		{
			XmlTextWriter xmlWriter = null;
			try
			{
				xmlWriter = new XmlTextWriter(Strings.SummarySuitesTempXml, null);
				xmlWriter.Formatting = Formatting.Indented;
				xmlWriter.Indentation = 6;
				xmlWriter.Namespaces = false;
				xmlWriter.WriteStartDocument();
				xmlWriter.WriteStartElement(Strings.Summary);
				xmlWriter.WriteStartElement(Strings.Suites);
				xmlWriter.WriteAttributeString(Strings.Total, counts[0].ToString());
				xmlWriter.WriteAttributeString(Strings.Pass, counts[1].ToString());
				xmlWriter.WriteAttributeString(Strings.Fail, counts[2].ToString());
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndDocument();
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(xmlWriter!=null)
				{
					xmlWriter.Flush();
					xmlWriter.Close();
				}
			}
		}

		/// <summary>
		/// Deletes all the temporary files and the previous result file.
		/// </summary>
		public void DeleteFiles()
		{
			DeleteTempFiles();
			DeleteResultFile();
		}

		/// <summary>
		/// Deletes all the temporary files
		/// </summary>
		public void DeleteTempFiles()
		{
			try
			{
				string resultPath = Strings.ResultSuitesTempXml;
				string summaryPath = Strings.SummarySuitesTempXml;
				string exeDonPath = Strings.ExeDon;
				string suitesDriverBatPath = Strings.SuitesDriverBat;
				string tempResultPath = Strings.ResultsPathsTxt;

				File.Delete(resultPath);
				File.Delete(summaryPath);
				File.Delete(exeDonPath);
				File.Delete(suitesDriverBatPath);
				File.Delete(tempResultPath);
			}
			catch
			{
			}
		}

		/// <summary>
		/// Deletes the Results.xml file
		/// </summary>
		private void DeleteResultFile()
		{
			try
			{
				string finalResultPath = Strings.ResultSuitesXml;
				File.Delete(finalResultPath);
			}
			catch
			{
			}
		}

		/// <summary>
		/// Shows the Xml result file if the user wishes to see the file.
		/// </summary>
		public void ShowResults()
		{
			
			string finalResultPath = StringManipulator.GetFileLocation(System.Reflection.Assembly.GetExecutingAssembly().Location) + "\\" + Strings.ResultSuitesXml;
			string finalResultLog = StringManipulator.GetFileLocation(System.Reflection.Assembly.GetExecutingAssembly().Location) + "\\" + Strings.ResultsLog;
			int [] resultsCount = new int[3];
			try
			{
				bool pass = GetOverviewResult(finalResultPath, ref resultsCount);
				DialogResult dr; 
				if(pass)
					dr = MessageBox.Show("All " + resultsCount[0].ToString() + " suites passed." + 
						"\nDo you want to see the results?", "Success in Suites Run", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
				else
					dr = MessageBox.Show("Total Suites: " + resultsCount[0].ToString() + " Pass: " + resultsCount[1].ToString() + " Fail: " + resultsCount[2].ToString() + 
						"\nDo you want to see the results?", "Failure in Suites Run", MessageBoxButtons.YesNo, MessageBoxIcon.Error);

				if(dr == DialogResult.Yes)
				{
					try
					{
						System.Diagnostics.Process.Start("IExplore.exe", finalResultPath);
					}
					catch(Exception ex)
					{
						ex.ToString();
						System.Diagnostics.Process.Start("notepad.exe", finalResultPath);
					}

					try
					{
						System.Diagnostics.Process.Start("notepad.exe", finalResultLog);
					}
					catch
					{
					}
				}
			}
			catch(Exception ex)
			{
				ex.ToString();
			}
		}

	} // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\SuitesFileManager.cs ===
using System;
using System.IO;
using System.Windows.Forms;
using System.Diagnostics;

namespace SuitesDriver
{

	enum BuildRun
	{
		Build,
		Run
	}

	/// <summary>
	/// Summary description for SuitesFileManager.
	/// </summary>
	internal class SuitesFileManager
	{
		private SuitesDriver m_suitesDriver;
		private string m_errorMessage = null;
		private bool m_bodyCreated = false;

		public SuitesFileManager(SuitesDriver suitesDriver)
		{
			m_suitesDriver = suitesDriver;
		}

		private SuitesDriver SuitesDriver
		{
			get
			{
				return m_suitesDriver;
			}
		}

		public string ErrorMessage
		{
			get
			{
				return m_errorMessage;
			}
			set
			{
				m_errorMessage = value;
			}
		}

		internal bool CreateSuitesFile()
		{
			ErrorMessage = null;
			StreamWriter writer = null;
			try
			{
				File.Delete(Strings.ResultsPathsTxt);
				File.SetAttributes(this.PrependMauiSuitesPath(Strings.SuitesTxt), FileAttributes.Normal);
				writer = new StreamWriter(this.PrependMauiSuitesPath(Strings.SuitesTxt));
				WriteSuitesFileHeader(writer);
				m_bodyCreated = false;
				WriteSuitesFileBody(writer, SuitesDriver.TreeView.Nodes[0]);
				File.SetAttributes(this.PrependMauiSuitesPath(Strings.SuitesTxt), FileAttributes.ReadOnly);
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(writer!=null)
				{
					writer.Flush();
					writer.Close();
				}
			}
			return m_bodyCreated;
		}

		internal void BuildSuites()
		{
			BuildRunSuites(BuildRun.Build);
		}

		internal void RunSuites()
		{
			BuildRunSuites(BuildRun.Run);
		}

		private void BuildRunSuites(BuildRun buildRun)
		{
			StreamWriter writer=null;
			try
			{
				writer = new StreamWriter(Strings.SuitesDriverBat);
				writer.WriteLine("cd " + GetMauiSuitesPath());
				switch(buildRun)
				{
					case BuildRun.Build:
						writer.WriteLine("call " + Strings.BuildAndRunBat + " /build");
						break;
					case BuildRun.Run:
						writer.WriteLine("call " + Strings.BuildAndRunBat);
						break;
				}
				writer.Flush();
				writer.Close();

				Process batchExecute = new Process();
				batchExecute.StartInfo.FileName = Strings.SuitesDriverBat;
				batchExecute.Start();
				batchExecute.WaitForExit();
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(writer!=null)
				{
					try
					{
						writer.Flush();
						writer.Close();
					}
					catch
					{
					}
				}
			}
		}

		internal string GetSuitesDriverPath()
		{
			string path = System.Reflection.Assembly.GetExecutingAssembly().Location;
			path = StringManipulator.GetFileLocation(path);
			path = path.Replace("\\" + Strings.Debug, null);
			path = path.Replace("\\" + Strings.bin, null);
			return path;
		}

		internal string GetMauiSuitesPath()
		{
			return SuitesDriver.MauiPath + "\\" + Strings.Suites;
		}


		private void WriteSuitesFileHeader(StreamWriter writer)
		{
			writer.WriteLine("# This file defines for BuildAndRun.bat which suites to build & run");
			writer.WriteLine("# The format is: ProjectFile:BinaryFile OR -:BinaryFile OR ProjectFile:-");
			writer.WriteLine("#");
			writer.WriteLine("BaseSuite\\BaseSuite.vbproj:-");
			writer.WriteLine("Products\\Visual Studio\\Whidbey\\WhidbeySuite\\WhidbeySuite.vbproj:-");
			writer.WriteLine("#");
		}

		private void WriteSuitesFileBody(StreamWriter writer, TreeNode workNode)
		{
			for(int i=0; i<workNode.Nodes.Count; i++)
			{
				if(workNode.Nodes[i].FullPath.EndsWith(Strings.BaseSuite) || workNode.Nodes[i].FullPath.EndsWith(Strings.WhidbeySuite))
					continue;

				if((workNode.Nodes[i].Nodes.Count==0) && (workNode.Nodes[i].Checked))
					AddEntry(writer, workNode.Nodes[i]);
				else
					WriteSuitesFileBody(writer, workNode.Nodes[i]);
			}
		}

		private void AddEntry(StreamWriter writer, TreeNode workNode)
		{
			string[] files = Directory.GetFiles(PrependMauiPath(workNode.FullPath));
			bool found = false;
			string rhs = null;
			for(int i=0;i<files.Length && !found;i++)
			{
				if(files[i].EndsWith("proj"))
				{
					found = true;
					writer.Write(GetRelativePath(files[i]) + ":");
					if(files[i].EndsWith("vbproj"))
					{
						if(files[i].EndsWith(Strings.WinformAppSuite + ".vbproj"))
						{
							rhs = GetRelativePath(StringManipulator.GetFileLocation(files[i])) + "\\bin\\" + Strings.WinControlsSuite + ".exe";
							writer.WriteLine(rhs);
						}
						else
						{
							rhs = GetRelativePath(StringManipulator.GetFileLocation(files[i])) + "\\bin\\" + StringManipulator.RemoveExtension(StringManipulator.GetNameFromPath(files[i])) + ".exe";
							writer.WriteLine(rhs);
						}
					}
					else
					{
						rhs = GetRelativePath(StringManipulator.GetFileLocation(files[i])) + "\\bin\\Debug\\" + StringManipulator.RemoveExtension(StringManipulator.GetNameFromPath(files[i])) + ".exe";
						writer.WriteLine(rhs);
					}
					AppendResultPath(PrependMauiSuitesPath(StringManipulator.GetFileLocation(rhs)));
					m_bodyCreated = true;
				}
			}
			if(!found)
				ErrorMessage += workNode.Text + "\n";
		}

		private void AppendResultPath(string path)
		{
			StreamWriter writer = null;
			try
			{
				writer = new StreamWriter(Strings.ResultsPathsTxt, true);
				writer.WriteLine(path);
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(writer!=null)
				{
					writer.Flush();
					writer.Close();
				}
			}
		}

		private string GetDrive(string path)
		{
			if(path==null)
				return null;

			int i = path.IndexOf("\\");
			return path.Substring(0, i);
		}

		private string GetRelativePath(string path)
		{
			if(path==null)
				return null;

			string startPath = SuitesDriver.MauiPath + "\\" + Strings.Suites + "\\";
			return path.Remove(0, startPath.Length);
		}

		private string PrependMauiSuitesPath(string path)
		{
			return SuitesDriver.MauiPath + "\\" + Strings.Suites + "\\" + path;
		}

		internal string PrependMauiPath(string path)
		{
			return SuitesDriver.MauiPath + "\\" + path;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\TreeViewManager.cs ===
using System;
using System.IO;
using System.Xml;
using System.Windows.Forms;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for TreeViewManager.
	/// </summary>
	internal class TreeViewManager
	{
		private SuitesDriver m_suitesDriver;
		private string[] avoidFolders;
		
		public TreeViewManager(SuitesDriver suitesDriver)
		{
			m_suitesDriver = suitesDriver;
			PopulateAvoidFolders();
		}

		private void PopulateAvoidFolders()
		{
			try
			{
				XmlDocument xmlReader = new XmlDocument();
				xmlReader.Load(GetSuitesDriverPath() + "\\" + Strings.AvoidFoldersXml);
				XmlNode avoidFoldersNode = xmlReader.GetElementsByTagName(Strings.AvoidFolders)[0];
				int count = avoidFoldersNode.ChildNodes.Count;
				avoidFolders = new string[count];
				for(int i=0;i<count;i++)
				{
					XmlNode folder = avoidFoldersNode.ChildNodes[i];
					avoidFolders[i] = Convert.ToString(folder.Attributes[Strings.Name].Value);
				}
			}
			catch
			{
			}
		}

		private string GetSuitesDriverPath()
		{
			string path = System.Reflection.Assembly.GetExecutingAssembly().Location;
			path = StringManipulator.GetFileLocation(path);
			path = path.Replace("\\" + Strings.Debug, null);
			path = path.Replace("\\" + Strings.bin, null);
			return path;
		}

		private SuitesDriver SuitesDriver
		{
			get
			{
				return m_suitesDriver;
			}
		}

		internal void PopulateTreeNode(TreeNode workNode)
		{
			workNode.Nodes.Clear();
			//fill the children information with the directory names
			string folder = AddSlash(SuitesDriver.MauiPath) + "\\" + workNode.FullPath;
			//folder = folder.Substring(folder.IndexOf("\\") + 1) + @"\";
			string[] subFolders = null;
			try
			{
				subFolders = Directory.GetDirectories(folder);
			}
			catch
			{
			}

			if (subFolders != null)
			{
				foreach (string child in subFolders)
				{
					FileAttributes atts = File.GetAttributes(child);
					if ((atts & FileAttributes.Hidden) != 0)
						continue;

					string dirName = child.Substring(child.LastIndexOf("\\") + 1);
					TreeNode childNode = new TreeNode(dirName, 5, 5);
					string[] grandChildren = Directory.GetDirectories(child);
					if (grandChildren.GetLength(0) > 0)
						childNode.Nodes.Add(new TreeNode(@"\\", 0, 0));  // marker node

					if(CanAddNode(childNode.Text))
					{
						childNode.Checked = SuitesDriver.CurrentCheckedState;
						workNode.Nodes.Add(childNode);
						PopulateTreeNode(childNode);
					}
				}
			}
		}

		private string AddSlash(string path)
		{
			path.Replace("\\", "\\\\");
			return path;
		}

		private bool CanAddNode(string folderName)
		{
			bool add = true;
			if(avoidFolders==null)
				return true;

			for(int i=0;i<avoidFolders.Length;i++)
			{
				if(folderName.ToLower()==avoidFolders[i].ToLower())
					add=false;
			}
			return add;
		}

	} // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\FolderPicker.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.IO;
using System.Reflection;

namespace SuitesDriver
{
#if !HASFOLDERBROWSER
	/// <summary>
	/// Summary description for FolderPicker.
	/// </summary>
	public class FolderPicker : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TreeView folderTreeview;
		private System.Windows.Forms.Button createNewFolderButton;
		private System.Windows.Forms.Button okButton;
		private System.Windows.Forms.Button cancelButton;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		string	initialFolder;

		public FolderPicker(string folder)
		{
			initialFolder = folder;
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region "Member Variables"
		string selectedFolderName;
		#endregion

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.folderTreeview = new System.Windows.Forms.TreeView();
			this.createNewFolderButton = new System.Windows.Forms.Button();
			this.okButton = new System.Windows.Forms.Button();
			this.cancelButton = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// folderTreeview
			// 
			this.folderTreeview.AccessibleDescription = "Treeview showing the folders in MyComputer";
			this.folderTreeview.AccessibleName = "foldersTreeview";
			this.folderTreeview.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.folderTreeview.ImageIndex = -1;
			this.folderTreeview.LabelEdit = true;
			this.folderTreeview.Location = new System.Drawing.Point(16, 16);
			this.folderTreeview.Name = "folderTreeview";
			this.folderTreeview.SelectedImageIndex = -1;
			this.folderTreeview.Size = new System.Drawing.Size(384, 304);
			this.folderTreeview.TabIndex = 0;
			this.folderTreeview.KeyUp += new System.Windows.Forms.KeyEventHandler(this.folderTreeview_KeyUp);
			this.folderTreeview.AfterLabelEdit += new System.Windows.Forms.NodeLabelEditEventHandler(this.folderTreeview_AfterLabelEdit);
			this.folderTreeview.BeforeCollapse += new System.Windows.Forms.TreeViewCancelEventHandler(this.folderTreeview_BeforeCollapse);
			this.folderTreeview.BeforeExpand += new System.Windows.Forms.TreeViewCancelEventHandler(this.folderTreeview_BeforeExpand);
			// 
			// createNewFolderButton
			// 
			this.createNewFolderButton.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.createNewFolderButton.Location = new System.Drawing.Point(16, 336);
			this.createNewFolderButton.Name = "createNewFolderButton";
			this.createNewFolderButton.Size = new System.Drawing.Size(152, 24);
			this.createNewFolderButton.TabIndex = 1;
			this.createNewFolderButton.Text = "C&reate New Folder...";
			this.createNewFolderButton.Click += new System.EventHandler(this.createNewFolderButton_Click);
			// 
			// okButton
			// 
			this.okButton.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.okButton.DialogResult = System.Windows.Forms.DialogResult.OK;
			this.okButton.Location = new System.Drawing.Point(200, 336);
			this.okButton.Name = "okButton";
			this.okButton.Size = new System.Drawing.Size(72, 24);
			this.okButton.TabIndex = 2;
			this.okButton.Text = "OK";
			this.okButton.Click += new System.EventHandler(this.okButton_Click);
			// 
			// cancelButton
			// 
			this.cancelButton.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
			this.cancelButton.Location = new System.Drawing.Point(288, 336);
			this.cancelButton.Name = "cancelButton";
			this.cancelButton.Size = new System.Drawing.Size(72, 24);
			this.cancelButton.TabIndex = 3;
			this.cancelButton.Text = "Cancel";
			// 
			// FolderPicker
			// 
			this.AccessibleDescription = "Folder Picker Dialog";
			this.AccessibleName = "folderPicker";
			this.AutoScaleBaseSize = new System.Drawing.Size(6, 15);
			this.ClientSize = new System.Drawing.Size(416, 384);
			this.ControlBox = false;
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.cancelButton,
																		  this.okButton,
																		  this.createNewFolderButton,
																		  this.folderTreeview});
			this.Name = "FolderPicker";
			this.Text = "FolderPicker";
			this.Load += new System.EventHandler(this.FolderPicker_Load);
			this.ResumeLayout(false);

		}
		#endregion

		public string SelectedFolder
		{
			get
			{
				return selectedFolderName;
			}
			set
			{
				selectedFolderName = value;
			}
		}

		private void FolderPicker_Load(object sender, System.EventArgs e)
		{
			string[] iconList = new string[]
				{"machine", "CDDrive", "HardDisk", 
					"Floppy", "OpenFolder", "ClosedFolder"};

			Assembly assembly = Assembly.GetExecutingAssembly();
			folderTreeview.ImageList = new ImageList();
			foreach(string resource in iconList)
			{
				string resourceName = resource + ".ico";
				folderTreeview.ImageList.Images.Add(new Icon("..\\..\\Resources\\" + resourceName));
			}

			string[] drives = Environment.GetLogicalDrives();
			Cursor = Cursors.WaitCursor;
			folderTreeview.BeginUpdate();
			TreeNode rootNode = new TreeNode(
				String.Format("My Computer ({0})", Environment.MachineName),
				0, 0);

			foreach (string drive in drives)
			{
				string driveName = drive.TrimEnd(new char[1] {'\\'});
				TreeNode driveNode = new TreeNode(driveName, 2, 2);
				driveNode.Nodes.Add(new TreeNode(@"\\", 0, 0));
				rootNode.Nodes.Add(driveNode);
			}

			rootNode.Expand();
			folderTreeview.Nodes.Add(rootNode);

			SelectTreeNode(initialFolder);
			folderTreeview.EndUpdate();
			Cursor = Cursors.Default;
		}

		private void SelectTreeNode(string nodeText)
		{
			try
			{
				// find the node for the initial folder and select it.
				if (nodeText == null || nodeText.Length == 0)
					return;

				nodeText = nodeText.TrimEnd(new Char[1]{'\\'});
				string workPath = nodeText;
				string token = "";
				int i = workPath.IndexOf(':');
				if (i >= 0)
				{
					token = workPath.Substring(0, i + 1).ToLower();
					workPath = workPath.Substring(i + 2);
				}

				TreeNode workNode = folderTreeview.Nodes[0];
				TreeNode newWorkNode = null;
				while (token.Length > 0)
				{
					// check if the node needs to be populated
					if (workNode.Nodes.Count == 1 && workNode.Nodes[0].Text == @"\\")
						PopulateTreeNode(workNode);

					foreach (TreeNode node in workNode.Nodes)
					{
						if (node.Text.ToLower() == token)
						{
							newWorkNode = node;
							break;
						}
					}

					if (newWorkNode == null)
						break;

					workNode = newWorkNode;
					newWorkNode = null;
					if (workPath.Length == 0)
						break;

					i = workPath.IndexOf(@"\");
					if (i > 0)
					{
						token = workPath.Substring(0, i).ToLower();
						workPath = workPath.Substring(i + 1);
					}
					else
					{
						token = workPath.ToLower();
						workPath = "";
					}
				}

				if (workNode != null)
					folderTreeview.SelectedNode = workNode;
			}
			catch
			{
			}
		}

		private void ChangeImageIndex(TreeNode node, int oldIndex, int newIndex)
		{
			if (node.ImageIndex != oldIndex)
				return;

			node.ImageIndex = newIndex;
			node.SelectedImageIndex = newIndex;
		}

		private void folderTreeview_BeforeCollapse(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
		{
			ChangeImageIndex(e.Node, 4, 5);
		}

		private void PopulateTreeNode(TreeNode workNode)
		{
			workNode.Nodes.Clear();
			//fill the children information with the directory names
			string folder = workNode.FullPath;
			folder = folder.Substring(folder.IndexOf("\\") + 1) + @"\";
			string[] subFolders = null;
			try
			{
				subFolders = Directory.GetDirectories(folder);
			}
			catch
			{
			}

			if (subFolders != null)
			{
				foreach (string child in subFolders)
				{
					FileAttributes atts = File.GetAttributes(child);
					if ((atts & FileAttributes.Hidden) != 0)
						continue;

					string dirName = child.Substring(child.LastIndexOf("\\") + 1);
					TreeNode childNode = new TreeNode(dirName, 5, 5);
					string[] grandChildren = Directory.GetDirectories(child);
					if (grandChildren.GetLength(0) > 0)
						childNode.Nodes.Add(new TreeNode(@"\\", 0, 0));  // marker node

					workNode.Nodes.Add(childNode);
				}
			}
		}

		private void folderTreeview_BeforeExpand(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
		{
			TreeNode workNode = e.Node;
			if (workNode.Nodes[0] != null && workNode.Nodes[0].Text == @"\\")  // check if the children need to be filled
			{
				PopulateTreeNode(workNode);
			}

			if (e.Node.Nodes.Count > 0)
				ChangeImageIndex(e.Node, 5, 4);
		}

		private void okButton_Click(object sender, System.EventArgs e)
		{
			TreeNode selection = folderTreeview.SelectedNode;
			if (selection != null)
			{
				string folder = folderTreeview.SelectedNode.FullPath;
				selectedFolderName = folder.Substring(folder.IndexOf(@"\") + 1);
			}
		}

		private void createNewFolderButton_Click(object sender, System.EventArgs e)
		{
			TreeNode selection = folderTreeview.SelectedNode;
			if (selection != null)
			{
				string folder = folderTreeview.SelectedNode.FullPath;
				folder = folder.Substring(folder.IndexOf(@"\") + 1);
				folder += @"\New Folder";
				string workFolder = folder;
				int count = 1;
				while (Directory.Exists(workFolder))
					workFolder = String.Format("{0}{1}", folder, count++);

				try
				{
					Directory.CreateDirectory(workFolder);
				}
				catch (Exception e2)
				{
					MessageBox.Show(this, 
						String.Format("Error creating folder : {0}", e2.Message),
						"Error", MessageBoxButtons.OK, MessageBoxIcon.Error);

					return;
				}

				TreeNode newNode = new TreeNode(
					workFolder.Substring(workFolder.LastIndexOf(@"\") + 1),
					5, 5);

				TreeNode parentNode = folderTreeview.SelectedNode;
				parentNode.Nodes.Add(newNode);
				parentNode.Expand();
				folderTreeview.SelectedNode = newNode;
				folderTreeview.Focus();
			}
		}

		private void folderTreeview_AfterLabelEdit(object sender, System.Windows.Forms.NodeLabelEditEventArgs e)
		{
			if (e.Label == null)
				return;

			string oldNodeName = e.Node.FullPath;
			oldNodeName = oldNodeName.Substring(oldNodeName.IndexOf(@"\") + 1);
			string root = oldNodeName.Substring(0, oldNodeName.LastIndexOf(@"\") + 1);
			string newNodeName = root + e.Label;
			if (newNodeName != oldNodeName)
			{
				try
				{
					Directory.Move(oldNodeName, newNodeName);
				}
				catch (Exception e3)
				{
					MessageBox.Show(this, "Error Renaming Folder : " + e3.Message, 
						"Error", MessageBoxButtons.OK, MessageBoxIcon.Error);

					e.CancelEdit = true;
				}
			}
		}

		private void folderTreeview_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
		{
			if (e.KeyCode == Keys.F5)
			{
				folderTreeview.Nodes.Clear();
				FolderPicker_Load(sender, e);
			}

			if (e.KeyCode != Keys.Delete || folderTreeview.SelectedNode == null)
				return;
			
			string folder = folderTreeview.SelectedNode.FullPath;
			folder = folder.Substring(folder.IndexOf(@"\") + 1);
			try
			{
				Directory.Delete(folder, true);
			}
			catch (Exception e2)
			{
				MessageBox.Show(this, "Error deleting folder : " + e2.Message);
				return;
			}

			folderTreeview.SelectedNode.Remove();
		}
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\TimeTracker.cs ===
using System;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for TimeTracker.
	/// </summary>
	public class TimeTracker
	{
		private static int m_time = 0;
		private static int m_hours = 0;
		private static int m_minutes = 0;
		private static int m_seconds = 0;

		public TimeTracker()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public static void UpdateTime()
		{
			m_time += 100;
			if(m_time == 1000)
			{
				m_time = 0;

				m_seconds++;
				if(m_seconds==60)
				{
					m_seconds = 0;
					m_minutes++;
					if(m_minutes==60)
					{
						m_minutes = 0;
						m_hours++;
					}
				}
			}
		}

		public static string GetTime()
		{
			return m_hours.ToString() + " hours " + 
				m_minutes.ToString() + " minutes " + 
				m_seconds.ToString() + " seconds";
		}

		/// <summary>
		/// Clears the time that is cached by the driver
		/// </summary>
		public static void ClearCachedTime()
		{
			m_time = 0;
			m_hours = 0;
			m_minutes = 0;
			m_seconds = 0;
		}


	} // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\VSInfo.cs ===
using System;
using Microsoft.Win32;
using System.Runtime.InteropServices;

namespace SuitesDriver
{
	public enum VSVersion
	{
		RTM,
		Everett,
		Whidbey
	}


	/// <summary>
	/// Summary description for VSInfo.
	/// </summary>
	public class VSInfo
	{
		public VSInfo()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		[DllImport("kernel32")]
		public static extern int SetEnvironmentVariable(string var, string val);

		public static string GetVSPath(VSVersion v)
		{
			try
			{
				string version = null;
				string VSPath = null;
				switch(v)
				{
					case VSVersion.RTM :
						version = "7.0";
						break;
					case VSVersion.Everett :
						version = "7.1";
						break;
					case VSVersion.Whidbey :
						version = "8.0";
						break;
				}

				RegistryKey regKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\VisualStudio\\" + version);
				VSPath = regKey.GetValue("InstallDir").ToString();
				regKey.Close();
				return VSPath;
			}
			catch
			{
				return null;
			}
		}

		public static bool IsVSInstalled(VSVersion v)
		{
			if(GetVSPath(v)==null)
				return false;
			else
				return true;
		}

		public static void AddVSToPath(VSVersion v)
		{
			string prevPath = System.Environment.GetEnvironmentVariable(Strings.Path);
			string path = GetVSPath(v);
			
			if(path==null)
				return;

			int i = path.Length;
			if(path.EndsWith("\\"))
				path = path.Remove(i-1, 1);
			
			bool present = false;
			string[] splitPaths = prevPath.Split(';');
			for(int j=0;j<splitPaths.Length && !present;j++)
				if(splitPaths[j]==path)
					present = true;

			if(!present)
				SetEnvironmentVariable(Strings.Path, prevPath + ";" + path);
		}

	} // class
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\SuitesDriver.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.IO;
using System.Threading;
using System.Xml;
using Microsoft.Win32;

namespace SuitesDriver
{

	/// <summary>
	/// Summary description for SuitesDriver.
	/// </summary>
	public class SuitesDriver : System.Windows.Forms.Form
	{
		private ProgressStatus.Progress progress1;
		private System.Windows.Forms.Panel panel2;
		private System.Windows.Forms.GroupBox groupBox2;
		private System.Windows.Forms.Button btnBrowse1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.TreeView treeView1;
		private bool m_currentCheckedState = false;
		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem menuItem2;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.MenuItem menuItem6;
		private System.Windows.Forms.MenuItem menuItem7;
		private System.Windows.Forms.Button btnGo;
		private System.Windows.Forms.Timer timer1;
		private System.ComponentModel.IContainer components;
		private System.Windows.Forms.RadioButton rdbBuildAndRun;
		private System.Windows.Forms.RadioButton rdbBuild;

		private Thread t;
		private BuildRun buildRun = BuildRun.Build;

		private TreeViewManager m_treeViewManager;
		private SuitesFileManager m_suitesFileManager;
		private System.Windows.Forms.Label label2;
		private ResultManager m_resultManager;
		private System.Windows.Forms.TextBox txtMauiPath;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.LinkLabel linkLabel1;
		private UserSettingsManager m_userSettingsManager;

		public SuitesDriver()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();
			CustomInitialize();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		private void CustomInitialize()
		{
			m_treeViewManager = new TreeViewManager(this);
			m_suitesFileManager = new SuitesFileManager(this);
			m_resultManager = new ResultManager();
			m_userSettingsManager = new UserSettingsManager(this);
			
			if(VSInfo.IsVSInstalled(VSVersion.RTM))
			{
				VSInfo.AddVSToPath(VSVersion.RTM);
			}
			else if(VSInfo.IsVSInstalled(VSVersion.Everett))
			{
				MessageBox.Show("VisualStudio 7.0 is not installed. 7.1 compiler will be used.", "Visual Studio 7.0 Not Found", MessageBoxButtons.OK, MessageBoxIcon.Information);
				VSInfo.AddVSToPath(VSVersion.Everett);
			}
			else if(VSInfo.IsVSInstalled(VSVersion.Whidbey))
			{
				MessageBox.Show("VisualStudio 7.0 or 7.1 are not installed. 8.0 compiler will be used.", "Visual Studio 7.0 or 7.1 Not Found", MessageBoxButtons.OK, MessageBoxIcon.Information);
				VSInfo.AddVSToPath(VSVersion.Whidbey);
			}
			else
			{
				MessageBox.Show("VisualStudio has to be installed on the machine", "Visual Studio Not Found", MessageBoxButtons.OK, MessageBoxIcon.Error);
			}
			
			string mauiPath = UserSettingsManager.GetUserSettings();
			if(IsMauiPath(mauiPath))
				this.txtMauiPath.Text = mauiPath;
			else
			{
				mauiPath = GetSpeculativeMauiRoot();
				if(IsMauiPath(mauiPath))
					this.txtMauiPath.Text = mauiPath;
			}

			this.StatusBarText = "Ready...";
		}

		private string GetSpeculativeMauiRoot()
		{
			string path = System.Reflection.Assembly.GetExecutingAssembly().Location;
			path = StringManipulator.GetFileLocation(path);
			path = path.Replace("\\" + Strings.Suites + "\\" + Strings.SuitesDriver + "\\" + Strings.SuitesDriver + "\\" + Strings.bin + "\\" + Strings.Debug, null);
			return path;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			this.progress1 = new ProgressStatus.Progress();
			this.panel2 = new System.Windows.Forms.Panel();
			this.groupBox2 = new System.Windows.Forms.GroupBox();
			this.txtMauiPath = new System.Windows.Forms.TextBox();
			this.btnBrowse1 = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.linkLabel1 = new System.Windows.Forms.LinkLabel();
			this.label3 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.btnGo = new System.Windows.Forms.Button();
			this.rdbBuildAndRun = new System.Windows.Forms.RadioButton();
			this.rdbBuild = new System.Windows.Forms.RadioButton();
			this.treeView1 = new System.Windows.Forms.TreeView();
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.menuItem6 = new System.Windows.Forms.MenuItem();
			this.menuItem7 = new System.Windows.Forms.MenuItem();
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			this.panel2.SuspendLayout();
			this.groupBox2.SuspendLayout();
			this.groupBox1.SuspendLayout();
			this.SuspendLayout();
			// 
			// progress1
			// 
			this.progress1.BackColor = System.Drawing.SystemColors.Highlight;
			this.progress1.Dock = System.Windows.Forms.DockStyle.Bottom;
			this.progress1.Font = new System.Drawing.Font("Microsoft Sans Serif", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.progress1.ForeColor = System.Drawing.SystemColors.HighlightText;
			this.progress1.Increment = 10;
			this.progress1.Location = new System.Drawing.Point(0, 377);
			this.progress1.Name = "progress1";
			this.progress1.ScannerColor = System.Drawing.Color.Gainsboro;
			this.progress1.Size = new System.Drawing.Size(496, 24);
			this.progress1.TabIndex = 15;
			// 
			// panel2
			// 
			this.panel2.BackColor = System.Drawing.Color.Silver;
			this.panel2.Controls.AddRange(new System.Windows.Forms.Control[] {
																				 this.groupBox2,
																				 this.groupBox1});
			this.panel2.Dock = System.Windows.Forms.DockStyle.Fill;
			this.panel2.Name = "panel2";
			this.panel2.Size = new System.Drawing.Size(496, 377);
			this.panel2.TabIndex = 18;
			// 
			// groupBox2
			// 
			this.groupBox2.Anchor = ((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.groupBox2.BackColor = System.Drawing.Color.Silver;
			this.groupBox2.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.txtMauiPath,
																					this.btnBrowse1,
																					this.label1});
			this.groupBox2.Location = new System.Drawing.Point(8, 308);
			this.groupBox2.Name = "groupBox2";
			this.groupBox2.Size = new System.Drawing.Size(480, 56);
			this.groupBox2.TabIndex = 1;
			this.groupBox2.TabStop = false;
			this.groupBox2.Text = "Settings";
			// 
			// txtMauiPath
			// 
			this.txtMauiPath.Location = new System.Drawing.Point(144, 23);
			this.txtMauiPath.Name = "txtMauiPath";
			this.txtMauiPath.Size = new System.Drawing.Size(296, 20);
			this.txtMauiPath.TabIndex = 44;
			this.txtMauiPath.Text = "";
			this.txtMauiPath.TextChanged += new System.EventHandler(this.txtMauiPath_TextChanged);
			// 
			// btnBrowse1
			// 
			this.btnBrowse1.BackColor = System.Drawing.Color.LightGray;
			this.btnBrowse1.Location = new System.Drawing.Point(448, 24);
			this.btnBrowse1.Name = "btnBrowse1";
			this.btnBrowse1.Size = new System.Drawing.Size(22, 17);
			this.btnBrowse1.TabIndex = 42;
			this.btnBrowse1.Text = "...";
			this.btnBrowse1.Click += new System.EventHandler(this.btnBrowse1_Click);
			// 
			// label1
			// 
			this.label1.BackColor = System.Drawing.Color.LightGray;
			this.label1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.ForeColor = System.Drawing.Color.Black;
			this.label1.Location = new System.Drawing.Point(16, 25);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(124, 16);
			this.label1.TabIndex = 43;
			this.label1.Text = "Maui Folder Path";
			// 
			// groupBox1
			// 
			this.groupBox1.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.groupBox1.BackColor = System.Drawing.Color.Silver;
			this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.linkLabel1,
																					this.label3,
																					this.label2,
																					this.btnGo,
																					this.rdbBuildAndRun,
																					this.rdbBuild,
																					this.treeView1});
			this.groupBox1.Location = new System.Drawing.Point(8, 8);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(480, 292);
			this.groupBox1.TabIndex = 0;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Suites";
			// 
			// linkLabel1
			// 
			this.linkLabel1.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.linkLabel1.Location = new System.Drawing.Point(220, 264);
			this.linkLabel1.Name = "linkLabel1";
			this.linkLabel1.Size = new System.Drawing.Size(48, 16);
			this.linkLabel1.TabIndex = 7;
			this.linkLabel1.TabStop = true;
			this.linkLabel1.Text = "MauiSuit";
			this.linkLabel1.Click += new System.EventHandler(this.linkLabel1_Click);
			// 
			// label3
			// 
			this.label3.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.label3.Font = new System.Drawing.Font("Verdana", 8F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(15, 265);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(216, 23);
			this.label3.TabIndex = 6;
			this.label3.Text = "For any suite issues please contact:";
			// 
			// label2
			// 
			this.label2.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.label2.Font = new System.Drawing.Font("Verdana", 8F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label2.Location = new System.Drawing.Point(15, 245);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(264, 23);
			this.label2.TabIndex = 5;
			this.label2.Text = "To open a project double-click on the node";
			// 
			// btnGo
			// 
			this.btnGo.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.btnGo.Location = new System.Drawing.Point(430, 249);
			this.btnGo.Name = "btnGo";
			this.btnGo.Size = new System.Drawing.Size(33, 23);
			this.btnGo.TabIndex = 4;
			this.btnGo.Text = "Go";
			this.btnGo.Click += new System.EventHandler(this.btnGo_Click);
			// 
			// rdbBuildAndRun
			// 
			this.rdbBuildAndRun.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.rdbBuildAndRun.Checked = true;
			this.rdbBuildAndRun.Location = new System.Drawing.Point(341, 249);
			this.rdbBuildAndRun.Name = "rdbBuildAndRun";
			this.rdbBuildAndRun.Size = new System.Drawing.Size(88, 24);
			this.rdbBuildAndRun.TabIndex = 3;
			this.rdbBuildAndRun.TabStop = true;
			this.rdbBuildAndRun.Text = "BuildAndRun";
			// 
			// rdbBuild
			// 
			this.rdbBuild.Anchor = (System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left);
			this.rdbBuild.Location = new System.Drawing.Point(287, 249);
			this.rdbBuild.Name = "rdbBuild";
			this.rdbBuild.Size = new System.Drawing.Size(48, 24);
			this.rdbBuild.TabIndex = 2;
			this.rdbBuild.Text = "Build";
			// 
			// treeView1
			// 
			this.treeView1.Anchor = (((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right);
			this.treeView1.CheckBoxes = true;
			this.treeView1.ImageIndex = -1;
			this.treeView1.Location = new System.Drawing.Point(8, 16);
			this.treeView1.Name = "treeView1";
			this.treeView1.Nodes.AddRange(new System.Windows.Forms.TreeNode[] {
																				  new System.Windows.Forms.TreeNode("Suites")});
			this.treeView1.SelectedImageIndex = -1;
			this.treeView1.Size = new System.Drawing.Size(464, 216);
			this.treeView1.TabIndex = 1;
			this.treeView1.MouseDown += new System.Windows.Forms.MouseEventHandler(this.treeView1_MouseDown);
			this.treeView1.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.treeView1_AfterCheck);
			this.treeView1.BeforeExpand += new System.Windows.Forms.TreeViewCancelEventHandler(this.treeView1_BeforeExpand);
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem1,
																					  this.menuItem4,
																					  this.menuItem6});
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 0;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem2,
																					  this.menuItem3});
			this.menuItem1.Text = "&Mode";
			// 
			// menuItem2
			// 
			this.menuItem2.Index = 0;
			this.menuItem2.Shortcut = System.Windows.Forms.Shortcut.F5;
			this.menuItem2.Text = "&Run";
			this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 1;
			this.menuItem3.Text = "&Exit";
			this.menuItem3.Click += new System.EventHandler(this.menuItem3_Click);
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 1;
			this.menuItem4.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem5});
			this.menuItem4.Text = "&View";
			// 
			// menuItem5
			// 
			this.menuItem5.Checked = true;
			this.menuItem5.Index = 0;
			this.menuItem5.Text = "&Scanner";
			this.menuItem5.Click += new System.EventHandler(this.menuItem5_Click);
			// 
			// menuItem6
			// 
			this.menuItem6.Index = 2;
			this.menuItem6.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.menuItem7});
			this.menuItem6.Text = "&Help";
			// 
			// menuItem7
			// 
			this.menuItem7.Index = 0;
			this.menuItem7.Text = "&About";
			this.menuItem7.Click += new System.EventHandler(this.menuItem7_Click);
			// 
			// timer1
			// 
			this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
			// 
			// SuitesDriver
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.BackColor = System.Drawing.Color.Silver;
			this.ClientSize = new System.Drawing.Size(496, 401);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.panel2,
																		  this.progress1});
			this.Menu = this.mainMenu1;
			this.Name = "SuitesDriver";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "Suites Driver";
			this.panel2.ResumeLayout(false);
			this.groupBox2.ResumeLayout(false);
			this.groupBox1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new SuitesDriver());
		}

		private void txtMauiPath_TextChanged(object sender, System.EventArgs e)
		{
			CurrentCheckedState = this.treeView1.Nodes[0].Checked;
			TreeViewManager.PopulateTreeNode(this.treeView1.Nodes[0]);
			UserSettingsManager.SaveUserSettings();
		}

		private void treeView1_BeforeExpand(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
		{
			TreeNode workNode = e.Node;
			if (workNode.Nodes[0] != null && workNode.Nodes[0].Text == @"\\")  // check if the children need to be filled
			{
				TreeViewManager.PopulateTreeNode(workNode);
			}
		}

		private void btnBrowse1_Click(object sender, System.EventArgs e)
		{
			FolderPicker fp = new FolderPicker(StringManipulator.AddSlash(this.txtMauiPath.Text));
			if (fp.ShowDialog() == DialogResult.OK)
			{
				if(!IsMauiPath(fp.SelectedFolder))
					MessageBox.Show("Please check the path specified. Either the path specified is not Maui root or it does not have a Suites folder", "Path error", MessageBoxButtons.OK, MessageBoxIcon.Error);
				else
					this.txtMauiPath.Text = fp.SelectedFolder;
			}
		}

		private bool IsMauiPath(string path)
		{
			bool success = false;
			if(path==null)
				return false;

			if(StringManipulator.GetNameFromPath(path).ToLower()!=Strings.Maui.ToLower())
				return false;
			
			string[] folders = Directory.GetDirectories(path);
			for(int i=0;i<folders.Length && !success;i++)
			{
				if(StringManipulator.GetNameFromPath(folders[i]).ToLower()==Strings.Suites.ToLower())
					success = true;
			}
			return success;
		}

		private void ToggleCheckNodeRecursive(TreeNode workNode)
		{
			this.treeView1.AfterCheck -= new System.Windows.Forms.TreeViewEventHandler(this.treeView1_AfterCheck);

			if(workNode==null)
				return;

			workNode.Checked = CurrentCheckedState;
			for(int i=0;i<workNode.Nodes.Count;i++)
			{
				if(workNode.Nodes[i]!=null)
					ToggleCheckNodeRecursive(workNode.Nodes[i]);
			}
		}

		private void treeView1_AfterCheck(object sender, System.Windows.Forms.TreeViewEventArgs e)
		{
			TreeNode workNode = e.Node;
			CurrentCheckedState = e.Node.Checked;
			ToggleCheckNodeRecursive(workNode);
			this.treeView1.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.treeView1_AfterCheck);	
		}

		private void btnGo_Click(object sender, System.EventArgs e)
		{
			if(MauiPath=="")
			{
				MessageBox.Show("Please enter path for Maui Root Directory", "Maui Path", MessageBoxButtons.OK, MessageBoxIcon.Information);
				return;
			}
			if(this.rdbBuild.Checked)
				buildRun = BuildRun.Build;
			else
				buildRun = BuildRun.Run;
			BuildRunSuites();
		}

		private void BuildRunSuites()
		{
			try
			{
				switch(buildRun)
				{
					case BuildRun.Build:
						this.StatusBarText = "Building Suites...";
						break;
					case BuildRun.Run:
						this.StatusBarText = "Running Suites...";
						break;
				}
				this.timer1.Start();
				TimeTracker.ClearCachedTime();
				ChangePositionOfDriver();
				ResultManager.DeleteFiles();
				t = new Thread(new ThreadStart(WaitForFinish));
				t.Start();	
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
		}

		private void WaitForFinish()
		{
			bool bodyCreated = SuitesFileManager.CreateSuitesFile();
			DialogResult dialogResult=DialogResult.Yes;

			if(!bodyCreated)
			{
				dialogResult = MessageBox.Show("None of the selected folders have any project files. Do you still want to continue building the base classes?", "Project Files Missing", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
			}
			else
			{
				if(SuitesFileManager.ErrorMessage!=null)
					dialogResult = MessageBox.Show("Following selected folders do not have any project files: \n" + SuitesFileManager.ErrorMessage + "\nDo you still want to continue with other projects?", 
						"Project files missing", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
			}

			if(dialogResult==DialogResult.Yes)
			{
				switch(buildRun)
				{
					case BuildRun.Build:
						SuitesFileManager.BuildSuites();
						ResultManager.DeleteTempFiles();
						this.StatusBarText = "Suites Build Completed...";
						StopTimer();
						MessageBox.Show("Suites build completed", "Build Completed", MessageBoxButtons.OK, MessageBoxIcon.Information); 
						break;
					case BuildRun.Run:
						if(bodyCreated)
						{
							SuitesFileManager.RunSuites();
							ResultManager.ProcessResults();
							ResultManager.DeleteTempFiles();
							this.StatusBarText = "Suites Run Completed...";
							StopTimer();
							ResultManager.ShowResults();
						}
						else
						{
							SuitesFileManager.BuildSuites();
							ResultManager.DeleteTempFiles();
							this.StatusBarText = "Suites Build Completed...";
							StopTimer();
							MessageBox.Show("Suites build completed", "Build Completed", MessageBoxButtons.OK, MessageBoxIcon.Information); 
						}
						break;
				}
			}
			t.Abort();
			File.Delete(Strings.ResultsPathsTxt);
		}

		private void StopTimer()
		{
			this.timer1.Stop();
			DisplayTime();
			TimeTracker.ClearCachedTime();
		}

		internal string MauiPath
		{
			get
			{
				return this.txtMauiPath.Text;
			}
		}

		internal bool CurrentCheckedState
		{
			get
			{
				return m_currentCheckedState;
			}
			set
			{
				m_currentCheckedState = value;
			}
		}

		private TreeViewManager TreeViewManager
		{
			get
			{
				return m_treeViewManager;
			}
		}

		private SuitesFileManager SuitesFileManager
		{
			get
			{
				return m_suitesFileManager;
			}
		}

		private ResultManager ResultManager
		{
			get
			{
				return m_resultManager;
			}
		}

		private UserSettingsManager UserSettingsManager
		{
			get
			{
				return m_userSettingsManager;
			}
		}

		public TreeView TreeView
		{
			get
			{
				return this.treeView1;
			}
		}

		private string StatusBarText
		{
			get
			{
				return this.progress1.Text;
			}
			set
			{
				this.progress1.Text = value;
			}
		}

		/// <summary>
		/// Moves the driver to the bottom right of the screen.
		/// </summary>
		private void ChangePositionOfDriver()
		{
			int x = SystemInformation.PrimaryMonitorSize.Width - this.Width - 3;
			int y = SystemInformation.PrimaryMonitorSize.Height - this.Height - this.progress1.Height - 3;
			this.DesktopLocation = new Point (x, y);
		}

		/// <summary>
		/// Keeps track of the time displayed in the status bar
		/// </summary>
		/// <param name="sender">Timer</param>
		/// <param name="e">EventArgs</param>
		private void timer1_Tick(object sender, System.EventArgs e)
		{
			TimeTracker.UpdateTime();
			switch(buildRun)
			{
				case BuildRun.Build:
					this.StatusBarText = "Building Suites..."; 
					break;
				case BuildRun.Run:
					this.StatusBarText = "Running Suites..."; 
					break;
			}
			DisplayTime();
		}

		/// <summary>
		/// Displays the time in the status bar
		/// </summary>
		private void DisplayTime()
		{
			this.StatusBarText += " " + TimeTracker.GetTime();
		}

		private void menuItem5_Click(object sender, System.EventArgs e)
		{
			if(this.progress1.ScannerColor == Color.Gainsboro)
				this.progress1.ScannerColor = SystemColors.Highlight;
			else
				this.progress1.ScannerColor = Color.Gainsboro;

			this.menuItem5.Checked = !this.menuItem5.Checked;
		}

		private void menuItem7_Click(object sender, System.EventArgs e)
		{
			MessageBox.Show("Suites Driver Version 1.0", "About", MessageBoxButtons.OK, MessageBoxIcon.Information);
		}

		private void treeView1_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			if(e.Clicks==2)
			{
				if(MauiPath=="")
				{
					MessageBox.Show("Please enter path to Maui root folder", "Maui Path", MessageBoxButtons.OK, MessageBoxIcon.Information);
					return;
				}

				try
				{
					TreeNode workNode = this.treeView1.GetNodeAt(e.X, e.Y);
					string[] files = Directory.GetFiles(SuitesFileManager.PrependMauiPath(workNode.FullPath));
					bool found = false;
					for(int i=0;i<files.Length && !found;i++)
					{
						if(files[i].EndsWith("proj"))
						{
							found = true;

							if(VSInfo.IsVSInstalled(VSVersion.RTM))
							{
								System.Diagnostics.Process.Start(VSInfo.GetVSPath(VSVersion.RTM) + "devenv", "\"" + files[i] + "\"");
							}
							else if(VSInfo.IsVSInstalled(VSVersion.Everett))
							{
								if(MessageBox.Show("VisualStudio 7.0 is not installed. Do you want to open the project in 7.1 instead?", "Visual Studio 7.0 not installed", MessageBoxButtons.YesNo, MessageBoxIcon.Question)==DialogResult.No)
									return;
								else
									System.Diagnostics.Process.Start(VSInfo.GetVSPath(VSVersion.Everett) + "devenv", "\"" + files[i] + "\"");
							}
							else if(VSInfo.IsVSInstalled(VSVersion.Whidbey))
							{
								if(MessageBox.Show("VisualStudio 7.0 or 7.1 are not installed. Do you want to open the project in 8.0 instead?", "Visual Studio 7.0 or 7.1 not installed", MessageBoxButtons.YesNo, MessageBoxIcon.Question)==DialogResult.No)
									return;
								else
									System.Diagnostics.Process.Start(VSInfo.GetVSPath(VSVersion.Whidbey) + "devenv", "\"" + files[i] + "\"");
							}
							else
							{
								MessageBox.Show("Unable to open the project. Visual Studio is not installed.", "Visual Studio not installed", MessageBoxButtons.OK, MessageBoxIcon.Error);
							}
						}
					}
					if(!found)
						MessageBox.Show("No project found in folder " + workNode.Text, "Open Project Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
					workNode.Expand();
				}
				catch
				{
					MessageBox.Show("Error in opening the project", "Open Project Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
				}
			}
		}

		private void menuItem3_Click(object sender, System.EventArgs e)
		{
			this.Dispose();
		}

		private void linkLabel1_Click(object sender, System.EventArgs e)
		{
			try
			{
				System.Diagnostics.Process.Start("mailto:MauiSuit?subject=SUITES FAILURE: ");
			}
			catch
			{
			}
		}

		private void menuItem2_Click(object sender, System.EventArgs e)
		{
			this.btnGo_Click(null, null);
		}

		private string SuitesPath
		{
			get
			{
				return this.MauiPath + "\\" + Strings.Suites;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\SuitesDriver\SuitesDriver\UserSettingsManager.cs ===
using System;
using System.Xml;
using System.Windows.Forms;

namespace SuitesDriver
{
	/// <summary>
	/// Summary description for UserSettingsManager.
	/// </summary>
	public class UserSettingsManager
	{
		private SuitesDriver m_suitesDriver;

		public UserSettingsManager(SuitesDriver suitesDriver)
		{
			m_suitesDriver = suitesDriver;
		}

		private SuitesDriver SuitesDriver
		{
			get
			{
				return m_suitesDriver;
			}
		}

		public void SaveUserSettings()
		{

			XmlTextWriter xmlWriter = null;
			try
			{
				xmlWriter = new XmlTextWriter(Strings.UserSettingsXml, null);
				xmlWriter.Formatting = Formatting.Indented;
				xmlWriter.Indentation = 6;
				xmlWriter.Namespaces = false;
				xmlWriter.WriteStartDocument();
				xmlWriter.WriteStartElement(Strings.UserSettings);
				xmlWriter.WriteStartElement(Strings.MauiPath);
				xmlWriter.WriteAttributeString(Strings.Path, SuitesDriver.MauiPath);
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndElement();
				xmlWriter.WriteEndDocument();
			}
			catch(Exception ex)
			{
				MessageBox.Show(ex.ToString());
			}
			finally
			{
				if(xmlWriter!=null)
				{
					xmlWriter.Flush();
					xmlWriter.Close();
				}
			}
		}

		public string GetUserSettings()
		{
			string mauiPath = null;
			try
			{
				XmlDocument xmlReader = new XmlDocument();
				xmlReader.Load(Strings.UserSettingsXml);
				XmlNode userSettingsNode = xmlReader.GetElementsByTagName(Strings.UserSettings)[0];
				XmlNode mauiPathNode = userSettingsNode.ChildNodes[0];
				mauiPath = Convert.ToString(mauiPathNode.Attributes[Strings.Path].Value);
			}
			catch
			{
			}
			return mauiPath;
		}

	} // class
}// namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\dictionary.inc ===
' File name: dictionary.inc
' Project:  dssnap

'$IFNDEF _dictionary
'$DEFINE _dictionary


' ************** ENGLISH **********************************

'global(account) groups in Users container
const DOMAIN_ADMINS_ENG					= "Domain Admins"
const DOMAIN_USERS_ENG					= "Domain Users"
const DOMAIN_GUESTS_ENG					= "Domain Guests"
const ENTERPRISE_ADMINS_ENG				= "Enterprise Admins"
const SCHEMA_ADMINS_ENG					= "Schema Admins"
const ADMINISTRATOR_ENG					= "Administrator"
const DOMAIN_CONTROLLERS_ENG			= "Domain Controllers"
const GUEST_ACCT_ENG					= "Guest"
const CERT_PUBL_ENG						= "Cert Publishers"
'local (resource) groups in BuiltIn container
const GRP_ADMINS_ENG					= "Administrators"
const GRP_USERS_ENG						= "Users"
const GRP_GUESTS_ENG					= "Guests"
const GRP_REPLIC_ENG					= "Replicator"
const GRP_BAKOP_ENG						= "Backup Operators"
const GRP_PRINTOP_ENG					= "Print Operators"
const GRP_SRVOP_ENG						= "Server Operators"
const GRP_ACCOP_ENG						= "Account Operators"
const GRP_RAS_IAS_SRV_ENG				= "RAS and IAS Servers"
const GRP_PRE_WINDOWS2000_ENG			= "Pre-Windows 2000 Compatible Access"


' ************** GERMAN **********************************

'global(account) groups in Users container
const DOMAIN_ADMINS_GER					= "Domnen-Admins"
const DOMAIN_USERS_GER					= "Domnen-Benutzer"
const DOMAIN_GUESTS_GER					= "Domnen-Gste"
const ENTERPRISE_ADMINS_GER				= "Organisations-Admins"
const SCHEMA_ADMINS_GER					= "Schema-Admins"
const ADMINISTRATOR_GER					= "Administrator"
const DOMAIN_CONTROLLERS_GER			= "Domnencontroller"
const GUEST_ACCT_GER					= "Gast"
const CERT_PUBL_GER						= "Zertifikatherausgeber"

'local (resource) groups in BuiltIn container
const GRP_ADMINS_GER					= "Administratoren"
const GRP_USERS_GER						= "Benutzer"
const GRP_GUESTS_GER					= "Gste"
const GRP_REPLIC_GER					= "Replikations-Operator"
const GRP_BAKOP_GER						= "Sicherung-Operatoren"
const GRP_PRINTOP_GER					= "Druck-Operatoren"
const GRP_SRVOP_GER						= "Server-Operatoren"
const GRP_ACCOP_GER						= "Konten-Operatoren"
const GRP_RAS_IAS_SRV_GER				= "RAS- und IAS-Server"
const GRP_PRE_WINDOWS2000_GER			= "Pre-Windows 2000 Compatible Access" 'need to translate




'$ENDIF _dictionary
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\language.inc ===
'	04.10.2002 : mehmetd  File Created
'	
' Below settings are seperated from sv2_sitescommon.inc file to implement CompileSites.vbs script
' Compile.vbs will create this file on-fly an make files ready to compile for any language

''$DEFINE UI_GER
'$DEFINE UI_ENG


''$DEFINE SCHEMA_GER
'$DEFINE SCHEMA_ENG

''$DEFINE INPUT_GER
'$DEFINE INPUT_ENG
''$DEFINE INPUT_JPN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\Ex-include.inc ===
const DELIMITER = "\"

function exExpandTreeItem(TreeOrdinal as string , TreeItemAddress as String) as long
	
	Dim pos as integer
	Dim posNew as integer
	Dim TreeItem as String

	
	pos = 0
	posNew = 0

	Do  
		' Locate first delimiter
	
		posNew = InStr(1,TreeItemAddress,DELIMITER)

		' First the first Item to be expanded

		if (posNew <= 0) then exit do

		TreeItem = Mid$( TreeItemAddress , 1 , posNew - 1 )

		' Save the rest as new address

		TreeItemAddress = Right$(TreeItemAddress, Len ( TreeItemAddress) - PosNew )

		if WTreeItemExists(TreeOrdinal, TreeItem) then
			
			if not WTreeItemExpanded(TreeOrdinal,TreeItem) then
			
				WTreeItemExpand(TreeOrdinal, TreeItem)

			end if

		else
			
			exit do

		end if


		Sleep(MIN_WAIT / 4)

		
	Loop Until posNew = 0  

	WTreeItemClk(TreeOrdinal , TreeItem)


end function  'function exExpandTreeItem(TreeOrdinal as integer , TreeItem as String) as long

'--------------------------------------------------------------------------------
'
'
'
'
'--------------------------------------------------------------------------------

function exbWTreeExpandAll(TreeOrdinal as String)

Dim CurrentItem as long
'Check the existence of the tree control and return -1 on failure
	if not WTreeExists(TreeOrdinal) then
		
		LogIt(LVL_STATUSINFO,"Tree Control can not be located : " + TreeOrdinal)
		exbWTreeExpandAll = -1
		exit function

	end if


' Reset current item
	CurrentItem = 1

	While WTreeItemExists(TreeOrdinal,_ord(CurrentItem),1)
		if not WTreeItemExpanded(TreeOrdinal,_ord(CurrentItem)) then

			WTreeItemExpand(TreeOrdinal,_ord(CurrentItem))
			sleep(MIN_WAIT/4)

		end if
	
		
		CurrentItem = CurrentItem + 1
	WEnd

end function

'--------------------------------------------------------------------------------
'
'
'
'
'--------------------------------------------------------------------------------
function exbWMenuSelect(strMenuItemCaption as string)

	EnterSub("function exbWMenuSelect( " + strMenuItemCaption + "as string)" )

	'Check the existence of the menu item
	if not WMenuExists(strMenuItemCaption) then

		LogIt(LVL_STATUSINFO, "Menu Item can not be located : " + strMenuItemCaption)
		exbWMenuSelect = false
		exit function

	end if

	'select the menu item
	WMenuSelect(strMenuItemCaption)

	ExitSub("function exbWMenuSelect( " + strMenuItemCaption + "as string)" )

end function 'function exbWMenuSelect(strMenuItemCaption as string)
'--------------------------------------------------------------------------------
'
'
'
'
'--------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\stringsSchema_eng.inc ===
const DEFAULT_FIRST_SITE_NODE		= "Default-First-Site-Name"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\Ex-SitesInclude.inc ===
function b_EXMakeServerNOTGC(sSiteName as String,sServerName as String) as long
	
EnterSub("SV2_SitescCommon.inc::bMakeServerNOTGC > Site : " + sSiteName + " Server : " + sServerName)

 

	WTreeItemExpand(ORD_1,sSiteName)
	Sleep (MIN_WAIT)
	WTreeItemClk(ORD_1,sSiteName)
	Sleep (MIN_WAIT)
	WViewItemDblClk(ORD_1,SERVERS_NODE)
	Sleep (MIN_WAIT)
	WViewItemDblClk(ORD_1,sServerName)
	Sleep (MIN_WAIT)
	WViewItemClk(ORD_1,NTDSSETTINGS_NODE,VK_RBUTTON)
	Sleep (MIN_WAIT)
	WMenuSelect(SM_STR_PROPERTIES)
	Sleep (MIN_WAIT)
	WCheckState("Global Catalog",UNCHECKED)
	Sleep (MIN_WAIT)
	WButtonClick("OK")
	Sleep(MIN_WAIT)	

ExitSub("SV2_SitescCommon.inc::bMakeServerNOTGC > Site : " + sSiteName + " Server : " + sServerName)
	
end function  'function bMakeServerGC(sSiteName as String,sServerName as String) as long

'--------------------------------------------------------------------------------
'
'
'
'
'--------------------------------------------------------------------------------


function exbCreateSite(sSiteName as string,strSiteLink$  = DEFAULT_FIRST_SITE_LINK)
	
	EnterSub("function exbCreateSite(" + sSiteName + " as string)" )

'Expand all the nodes down to Sites Node
	exExpandTreeItem(ORD_1,TREE_ROOT + "\" + AD_SITES_AND_SERVICES )

'Right Click on the Sites node to see the menu

	exbWMenuSelect(

'Select New Site menu item from the context menu

'Verify that New Site dialog is created

'Enter SiteName

'Select Sitelink

'Click OK



	ExitSub("function exbCreateSite(" + sSiteName + " as string)" )

end function 'function exbCreateSite(sSiteName as string)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\stringsInput_eng.inc ===
'----------------------  NOT IN STRINGS PROPER!!!!! --------------------------------------

'Test object strings
const TEXT_TESTSITEALPHA =			"TestSiteAlpha"
const TEXT_TESTSERVERALPHA =		"TestServerAlpha"
const TEXT_TESTSUBNETALPHA =		"200.200.200.18/32"
const TEXT_TESTSITEEINSTEIN =		"Istanbul-AZaz09"
const TEXT_TESTSITENEWTON =			"Newton-Site-DSSITE"
const TEXT_TESTSITEBRAHE =			"Brahe-Site-DSSITE"
const TEXT_TESTSITEKEPPLER =		"Keppler-Site-DSSITE"
const TEXT_TESTSERVEREULER =		"Euler-Server-DSSITE"
const TEXT_TESTSERVERtycho =		"Tycho-Server-DSSITE"
const TEXT_TESTSITELINK_mercury =	"Mercury-SiteLink-DSSITE"
const TEXT_TESTSITELINK_venus =		"Venus-SiteLink-DSSITE"
const TEXT_TEST_SLBRIDGE_Phobos =	"Phobos-SLBridge-DSSITE"
const TEXT_TEST_SLBRIDGE_Deimos =	"Deimos-SLBridge-DSSITE"
const TEXT_TEST_CONNECTION_Alaska =	"Alaska-Connection-DSSITE"
const TEXT_TEST_CONNECTION_Maine =	"Maine-Connection-DSSITE"
const TEXT_TEST_SUBNET_001 =		"100.100.100.100/32"
const TEXT_TEST_SUBNET_001_Close =	"100.100.100.100/31"
const TEXT_TEST_SUBNET_002 =		"200.200.200.200/32"
const TEXT_TEST_SUBNET_INVALID =		"200.200.200.12/24"


const TEXT_PRESET_COST =			"100"
const TEXT_PRESET_TIME =			"180"

const TEXT_63_CHARS =				"ZBCDEFGHIJKLMONPQRSTUVWXYabcdefghijklmonpqrstuvwxy1234567890123"
const TEXT_64_CHARS =				"ZBCDEFGHIJKLMONPQRSTUVWXYabcdefghijklmonpqrstuvwxy12345678901234"
const TEXT_65_CHARS =				"ZBCDEFGHIJKLMONPQRSTUVWXYabcdefghijklmonpqrstuvwxy123456789012345"
const TEXT_TESTSTRING =				"Test String 123"


'---------- DSALAB Setup Strings -----------
Const FOREST_A =					"A"
Const FOREST_B =					"B"
Const FOREST_C =					"C"
Const FOREST_D =					"D"
Const FOREST_E =					"E"
Const FOREST_F =					"F"
Const FOREST_G =					"G"
Const FOREST_H =					"H"
Const FOREST_I =					"I"
Const FOREST_J =					"J"
Const FOREST_K =					"K"
Const SITE_ALPHA  =					"ALPHA"
Const SITE_BETA  =					"BETA"
Const SITE_GAMMA  =					"GAMMA"
Const SITE_DELTA  =					"DELTA"
Const SITE_OMEGA  =					"OMEGA"
Const SITE_SUFFIX =					"-Site"
Const SITELINK_SUFFIX =				"-SiteLink"
Const OMEGA_MAXLENGTH =				"-MAXNAME-abcdefghijklmnopqrstuvwxy----1234567890123"
Const MAX_COST =					2147483647  
Const MIN_COST =					1
Const MIN_REPLICATION =				15
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\SV2_SitesSetup.inc ===
'************************************************************************************************************
'
'	SV2_SITESSETUP.inc
'
'	Using a given text configuration file, will configure the current MMC.
'
'	FUNCTION LIST
'	function bSetupSitesFromConfigFile(sConfigFile as String) as long
'	function bTakedownSitesFromConfigFile(sConfigFile as String) as long
'
'	HISTORY
'	Date		User		Activity
'	10-06-2000	tyuhas		Created file
'	10-11-2000	tyuhas		Added category 'FAILURE' to allow for boundary testing, (if you try to create
'							two objects with the same name, you can check for the error here).
'							NOTE: when FAILURE is set, only the very next object
'							will be checked for failure.  ie: You must declare FAILURE before each individual
'							failure test.
'	10-12-2000	tyuhas		Added ***COMMENT*** category so that notes can be left in the setup routine.
'
'************************************************************************************************************

'Load the symbol for this file
'$DEFINE SV2_SITESSETUP

'Check for a initilization file in the current directory.  If one exists, set variables
Const SITES_INITIALIZATION_FILE = "sitesTests.ini"

'Each of the possible values should have entries here of the form

'CONST ENTRY_DESCRIPTION = {{String to use in identification in the ini file}}
'Global declaration of the variable
'intialization of the variable

Const ENTRY_VERBOSE_MODE = "VERBOSE_MODE"
Global bVerboseMode as Long
bVerboseMode = FALSE

Const ENTRY_CONFIG_PATH = "PATH_CONFIG_FILES"
Global sPathConfigFiles as String
sPathConfigFiles = ""

'Seed the variables if they exist
if exists(SITES_INITIALIZATION_FILE) then
	Dim vFileTemp as Variant
	Dim lDelim as Long
	Dim sOneLine as String

	vFileTemp = FREEFILE
	Open SITES_INITIALIZATION_FILE for Input as vFileTemp

	do while not eof(vFileTemp)

		Line Input #vFileTemp, sOneLine
		lDelim = instr(sOneLine, "=")

'If an equal sign exists on the line, process
		if lDelim <> 0 then

			Select Case left(sOneLine, lDelim - 1)
				Case ENTRY_VERBOSE_MODE
					bVerboseMode = Val(Trim(Right(sOneLine, len(sOneLine) - lDelim)))
				Case ENTRY_CONFIG_PATH
					sPathConfigFiles = Trim(Right(sOneLine, len(sOneLine) - lDelim))
			end select

		end if
	loop

	close vFileTemp

end if


'Finish loading include files
'$IFNDEF SV2_TOOLS
	'$include 'SV2_tools.inc'
'$ENDIF

'$IFNDEF SV2_STRINGS
	'$include 'SV2_strings.inc'
'$ENDIF

'$IFNDEF SV2_SITESCOMMON
	'$include 'SV2_sitesCommon.inc'
'$ENDIF




'============================================================================================================
' DECLARATIONS
'============================================================================================================

'For use with the vtSplit function to parse up the config file information painlessly
const DELIM = ";"

'Expected number of parameters for each type of object
'NOTE - parameters can be left NULL, but a delimiter must be included
'for each in the config file
const NUM_SITE_PARAM = 1
const NUM_SERVER_PARAM = 2
const NUM_SITELINK_PARAM = 4
const NUM_SITELINKBRIDGE_PARAM = 4
const NUM_MOVESERVER_PARAM = 3

const NUM_SITE_REM_PARAM = 1
const NUM_SERVER_REM_PARAM = 2
const NUM_SITELINK_REM_PARAM = 2
const NUM_SITELINKBRIDGE_REM_PARAM = 2

'For holding each two line record in the config file
Type SITESCONFIGRECORD 'prefix = scr
	sType as String
	sDetail as String
End Type

'============================================================================================================
' FUNCTIONS
'============================================================================================================

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bSetupSitesFromConfigFile
'
'	Reads the config file into an array, (that way if any part causes failure the config file
'	is not left open), then calls each setup routine as specified by the file.
'	NOTE: This does not verify that the config file is correct.  If you try to set up a server
'	in a site that doesn't exist, this will simply fail.
'
'	PARAMETERS
'		sConfigFile - full path of config file to run from
'
'	RETURN VALUE
'		TRUE if all of the calls in the config file came back true
'		FALSE if any call came back false, or if the config file did not exist
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bSetupSitesFromConfigFile(sConfigFile as String) as long

	EnterProc("bSetupSitesFromConfigFile")

'For use splitting up parameters of each object
	Dim sConfigArray as Array of String
	Dim lTop as Long
	Dim bFailureFlag as Long

'Default to true.  That way we only have to set it false once to get
'the TRUE/FALSE behavior described
	bSetupSitesFromConfigFile = TRUE
	Dim bResult as Long

	LOG
	LOG_VP("BEGINNING SETUP OF SITES USING CONFIG FILE: [" + sConfigFile + "]")
	LOG

'Check that the config file is a real file
	if Exists(sConfigFile) = FALSE then
	
		bSetupSitesFromConfigFile = False
		LOG_VP(FAIL_PREFIX + "" + sConfigFile + " not found.")
		exit function
		
	end if		

'Load information from the file into Check array
	Dim scrSetups as Array of SITESCONFIGRECORD
	Dim lNumOfControls as Long
	Dim x as long 'Generic looping variable

	Dim vFile as Variant
	vFile = FREEFILE

	Open sConfigFile for Input as vFile

	Do While Not EOF(vFile)
		
		Redim Preserve scrSetups(lNumOfControls) as SITESCONFIGRECORD
		Line Input #vFile, scrSetups(lNumOfControls).SType

'Don't assume there is a second line of config information.
		if EOF(vFile) then
			lNumOfcontrols = lNumOfControls - 1
			Redim Preserve scrSetups(lNumOfControls) as SITESCONFIGRECORD
			Exit Do
		end if

		Line Input #vFile, scrSetups(lNumOfControls).sDetail
		lNumOfcontrols = lNumOfControls + 1

	loop

	Close vFile

'There will be one more control num than there really is as it is incremented
'before the check for the next item, (the alternative is to begin arrays at 1
'or get convoluted by starting the num of count at -1)....
	lNumOfcontrols = lNumOfControls - 1

'Check each control
	For x = 0 to lNumOfControls

		lTop = vtSplit(scrSetups(x).sDetail, DELIM, sConfigArray)
		lTop = lTop + 1  '(VT Split returns top of array starting at zero)

		Select Case scrSetups(x).sType

			case "SITE"				'[Site Name]

				If lTop <> NUM_SITE_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [Site] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bCreateSite(sConfigArray(0))
				end if

			case "SERVER"			'[Server Name];[Site Name]
				If lTop <> NUM_SERVER_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [Server] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bCreateServer(sConfigArray(1), sConfigArray(0))
				end if

			case "SITELINK"			'[Link Name];[Site One];[Site Two];[Transport]

				If lTop <> NUM_SITELINK_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [SiteLink] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bCreateSiteLink(sConfigArray(0), sConfigArray(1), sConfigArray(2), sConfigArray(3))
				end if

			case "SITELINKBRIDGE"	'[Bridge Name];[Link One];[Link Two];[Transport]

				If lTop <> NUM_SITELINKBRIDGE_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [SiteLinkBridge] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bCreateSiteLinkBridge(sConfigArray(0), sConfigArray(1), sConfigArray(2), sConfigArray(3))
				end if

			case "MOVESERVER"		'[Server Name];[From Site];[To Site]

				If lTop <> NUM_MOVESERVER_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [MoveServer] has invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bMoveServer(sConfigArray(0), sConfigArray(1), sConfigArray(2))
				end if

			case "FAILURE"
				bFailureFlag = TRUE
				LOG_VP("Expect FAILURE Set...")
				goto sKIP_tO_nEXT_oBJECT

			case "***COMMENT***"   'Remarks....to be printed out
				LOG_VP ("***COMMENT***" + sConfigArray(0))
				goto sKIP_tO_nEXT_oBJECT

			case ""

			case else
				Log_VP (FAIL_PREFIX + "WARNING:Unrecognized type in config file: " + scrSetups(x).sType)

		end select

'Compare temporary result to the failure flag switch for true pos or false neg
'The Failure Flag should be opposite of the temporary result to indicate
'a real positive
		if bResult = bFailureFlag then
			bResult = FALSE
		else
			bResult = TRUE
		end if

'If bResult is false even once then the entire function fails
		if bResult = FALSE then
			LOG
			LOG "TRUE FAILURE OCCURED JUST BEFORE THIS"
			LOG
			bSetupSitesFromConfigFile = FALSE
		end if
		bFailureFlag = FALSE

sKIP_tO_nEXT_oBJECT:

	Next x

	LOG
	LOG_VP("FINISHED SETUP OF SITES USING CONFIG FILE: [" + sConfigFile + "]")
	LOG

	ExitProc("bSetupSitesFromConfigFile")

end function 'bSetupSitesFromConfigFile

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bTakedownSitesFromConfigFile
'
'	Reads the config file into an array, (that way if any part causes failure the config file
'	is not left open), then calls each delete routine as specified by the file.
'	NOTE: This does not verify that the config file is correct.  eg: If you try to delete a server
'	in a site that doesn't exist, this will simply fail.
'
'	PARAMETERS
'		sConfigFile - full path of config file to run from
'
'	RETURN VALUE
'		TRUE if all of the calls in the config file came back true
'		FALSE if any call came back false, or if the config file did not exist
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bTakedownSitesFromConfigFile(sConfigFile as String) as long

	EnterProc("bTakedownSitesFromConfigFile")

'For use splitting up parameters of each object
	Dim sConfigArray as Array of String
	Dim lTop as Long

'Default to true.  That way we only have to set it false once to get
'the TRUE/FALSE behavior described
	bTakedownSitesFromConfigFile = TRUE
	Dim bResult as Long

	LOG_VP("BEGINNING TAKEDOWN OF SITES USING CONFIG FILE: [" + sConfigFile + "]")


'Check that the config file is a real file
	if Exists(sConfigFile) = FALSE then
	
		bTakedownSitesFromConfigFile = False
		LOG_VP(FAIL_PREFIX + "" + sConfigFile + " not found.")
		exit function
		
	end if		

'Load information from the file into Check array
	Dim scrRemovals as Array of SITESCONFIGRECORD
	Dim lNumOfControls as Long
	Dim x as long 'Generic looping variable

	Dim vFile as Variant
	vFile = FREEFILE

	Open sConfigFile for Input as vFile

	Do While Not EOF(vFile)
		
		Redim Preserve scrRemovals(lNumOfControls) as SITESCONFIGRECORD
		Line Input #vFile, scrRemovals(lNumOfControls).SType

'Don't assume there is a second line of config information.
		if EOF(vFile) then
			lNumOfcontrols = lNumOfControls - 1
			Redim Preserve scrRemovals(lNumOfControls) as SITESCONFIGRECORD
			Exit Do
		end if

		Line Input #vFile, scrRemovals(lNumOfControls).sDetail
		lNumOfcontrols = lNumOfControls + 1

	loop

	Close vFile

'There will be one more control num than there really is as it is incremented
'before the check for the next item, (the alternative is to begin arrays at 1
'or get convoluted by starting the num of count at -1)....
	lNumOfcontrols = lNumOfControls - 1

'Check each control
	For x = 0 to lNumOfControls

		lTop = vtSplit(scrRemovals(x).sDetail, DELIM, sConfigArray)
		lTop = lTop + 1  '(VT Split returns top of array starting at zero)

		Select Case scrRemovals(x).sType

			case "SITE"				'[Site Name]

				If lTop <> NUM_SITE_REM_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [Site] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bDeleteSite(sConfigArray(0))
				end if

		'	case "SERVER"			'[Server Name];[Site Name]
				'If lTop <> NUM_SERVER_REM_PARAM then
			'		Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [Server] has an invalid number of parameters in config file.")
		'			bResult = False
	'			else
			'		bResult = bCreateServer(sConfigArray(0), sConfigArray(1))
	'			end if

			case "SITELINK"			'[Link Name];[Transport]

				If lTop <> NUM_SITELINK_REM_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [SiteLink] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bDeleteSiteLink(sConfigArray(0), sConfigArray(1))
				end if

			case "SITELINKBRIDGE"	'[Bridge Name];[Transport]

				If lTop <> NUM_SITELINKBRIDGE_REM_PARAM then
					Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [SiteLinkBridge] has an invalid number of parameters in config file.")
					bResult = False
				else
					bResult = bDeleteSiteLinkBridge(sConfigArray(0), sConfigArray(1))
				end if

			'case "MOVESERVER"		'[Server Name];[From Site];[To Site]

				'If lTop <> NUM_MOVESERVER_REM_PARAM then
			'		Log_VP (FAIL_PREFIX + "Object #" + str(x) + " [MoveServer] has invalid number of parameters in config file.")
			'		bResult = False
			'	else
			'		bResult = bMoveServer(sConfigArray(0), sConfigArray(1), sConfigArray(2))
			'	end if

			case ""

			case else
				Log_VP (FAIL_PREFIX + "WARNING:Unrecognized type in config file: " + scrRemovals(x).sType)
				
		end select

'One false will fail whole function
		if bResult = False then
			bTakedownSitesFromConfigFile = False
		end if

	Next x

	LOG_VP("FINISHED TAKEDOWN OF SITES USING CONFIG FILE: [" + sConfigFile + "]")

	ExitProc("bTakedownSitesFromConfigFile")

end function 'bTakedownSitesFromConfigFile
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\SV2_checkdialog.inc ===
'************************************************************************************************************
'
'	CHECKDIALOG.inc
'
'	Using a given text configuration file, will check each of the controls on a dialog	
'
'	PROCEDURE LIST
'	Sub LogDialogCheck(sText as String)
'	Function bCheckCaption(sInfo as String) as Long
'	Function bCheckEdit(sInfo as String) as Long
'	Function bCheckStatic(sInfo as String) as Long
'	Function bCheckTab(sTabName as String) as Long
'	Function bCheckView(sInfo as String) as Long
'	Function bCheckViewItem(sInfo as String) as Long
'	Function bCheckButton(sInfo as String) as Long
'	Function bCheckCheckBox(sInfo as String) as Long
'
'	HISTORY
'	Date		User		Activity
'	09-26-2000	tyuhas		Created file	
'	09-27-2000	tyuhas		Add function to verify caption
'	10-09-2000	tyuhas		Added category 'FAILURE' to allow for boundary testing, (if you know there
'							should only be two items in a list box, then you can look for 'FAILURE'
'							when looking for '@3'. NOTE: when FAILURE is set, only the very next control
'							will be checked for failure.  You must declare FAILURE before each individual
'							failure test.
'
'************************************************************************************************************

'Load the symbol for this file
'$DEFINE SV2_CHECKDIALOG

'$IFNDEF SV2_TOOLS
	'$include 'SV2_tools.inc'
'$ENDIF

'$IFNDEF SV2_STRINGS
	'$include 'SV2_strings.inc'
'$ENDIF

'============================================================================================================
' DECLARATIONS
'============================================================================================================

'For turning documentation of Pass scenarios off and on
global bDialogCheckVerbose as integer


'For use with the vtSplit function to parse up the config file information painlessly
Global sArray as Array of String
global lTopOfArray as Long
const DELIM = ";"

'Expected number of parameters for each type of control
'NOTE - parameters can be left NULL, but a delimiter must be included
'for each in the config file
const NUM_PARAM_CAPTION = 1
const NUM_PARAM_TAB = 1
const NUM_PARAM_EDIT = 3
const NUM_PARAM_BUTTON = 3
const NUM_PARAM_STATIC = 2
const NUM_PARAM_VIEW = 2
const NUM_PARAM_VIEWITEM = 2
const NUM_PARAM_LISTBOX = 2
const NUM_PARAM_LISTBOXITEM = 2
const NUM_PARAM_CHECKBOX = 4

'For holding each two line record in the config file
Type DIALOGCONFIGRECORD 'prefix = dcr
	sType as String
	sDetail as String
End Type

'============================================================================================================
' FUNCTIONS
'============================================================================================================

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKDIALOG
'
'	Reads the config file into an array, (that way if any part causes failure the config file
'	is not left open), then calls each verification routine as specified by the file		
'
'	PARAMETERS
'		sDialogFile - full path of config file to run from
'
'	RETURN VALUE
'		TRUE if all of the calls in the config file came back true
'		FALSE if any call came back false, or if the config file did not exist
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckDialog(sDialogFile as String, bLogging as Long) as long

'Set log parameters
	bDialogCheckVerbose = bLogging

'Default to true.  That way we only have to set it false once to get
'the TRUE/FALSE behavior described
	bCheckDialog = TRUE
	Dim bResult as Long
	Dim bFailureFlag as Long

	Log
	Log "BEGINNING REVIEW OF ACTIVE DIALOG USING CONFIG FILE: [" + sDialogfile + "]"
	Log


'Check that the config file is a real file
	if Exists(sDialogFile) = FALSE then
	
		bCheckDialog = False
		LogDialogCheck (FAIL_PREFIX + "" + sDialogFile + " not found.")
		goto eXIT_fUNCTION
		
	end if		

'Load information from the file into Check array
	Dim dcrChecks as Array of DIALOGCONFIGRECORD
	Dim lNumOfControls as Long
	Dim x as long 'Generic looping variable

	Dim vFile as Variant
	vFile = FREEFILE

	Open sDialogFile for Input as vFile

	Do While Not EOF(vFile)
		
		Redim Preserve dcrChecks(lNumOfControls) as DIALOGCONFIGRECORD
		Line Input #vFile, dcrChecks(lNumOfControls).SType
		if EOF(vFile) then
			lNumOfcontrols = lNumOfControls - 1
			Redim Preserve dcrChecks(lNumOfControls) as DIALOGCONFIGRECORD
			Exit Do
		end if

		Line Input #vFile, dcrChecks(lNumOfControls).sDetail
		lNumOfcontrols = lNumOfControls + 1

	loop

	Close vFile

'There will be one more control num than there really is as it is incremented
'before the check for the next item, (the alternative is to begin arrays at 1
'or get convoluted by starting the num of count at -1)....
	lNumOfcontrols = lNumOfControls - 1

'Check each control
	bFailureFlag = FALSE

	For x = 0 to lNumOfControls
		Select Case dcrChecks(x).sType
			case "CAPTION"
				bResult = bCheckCaption(dcrChecks(x).sDetail)

			case "BUTTON"
				bResult = bCheckButton(dcrChecks(x).sDetail)

			case "TAB"
				bResult = bCheckTab(dcrChecks(x).sDetail)

			case "STATIC"
				bResult = bCheckStatic(dcrChecks(x).sDetail)

			case "EDIT"
				bResult = bCheckEdit(dcrChecks(x).sDetail)

			case "VIEW"
				bResult = bCheckView(dcrChecks(x).sDetail)

			case "VIEWITEM"
				bResult = bCheckViewItem(dcrChecks(x).sDetail)

			case "CHECKBOX"
				bResult = bCheckCheckBox(dcrChecks(x).sDetail)

			case "LISTBOX"
				bResult = bCheckListBox(dcrChecks(x).sDetail)

			case "LISTBOXITEM"
				bResult = bCheckListBoxItem(dcrChecks(x).sDetail)

			case "FAILURE"
				bFailureFlag = TRUE
				LOG_VP("Expect FAILURE Set...")
				goto sKIP_tO_nEXT_cONTROL

			case "" 'ignore blank lines

			case else
				LogDialogCheck (FAIL_PREFIX + "Unrecognized type in config file: " + dcrChecks(x).sType)
				bCheckDialog = False
		end select

'Compare temporary result to the failure flag switch for true pos or false neg
'The Failure Flag should be opposite of the temporary result to indicate
'a real positive
		if bResult = bFailureFlag then
			bResult = FALSE
		else
			bResult = TRUE
		end if

'If bResult is false even once then the entire dialog fails
		if bResult = FALSE then
			bCheckDialog = FALSE
		end if
		bFailureFlag = FALSE

sKIP_tO_nEXT_cONTROL:

	Next x


eXIT_fUNCTION:
	Log
	Log "FINISHED REVIEW OF ACTIVE DIALOG USING CONFIG FILE: [" + sDialogfile + "]"
	Log

end function 'bCheckDialog

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	LogDialogCheck
'
'	Write log information relating to the dialog check.  Use global boolean value bDialogCheckVerbose
'	to decide whether to log non-failures.  If sText begins with "***FAIL", this will log that
'	comment regardless.
'
'	PARAMETERS
'		sText - Text to Log
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Sub LogDialogCheck(sText as String)

	If Left(sText,len(FAIL_PREFIX)) = FAIL_PREFIX then
		Log "*****" + sText
	Elseif bDialogCheckVerbose = TRUE then
		Log "....." + sText
	end if

End Sub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKCAPTION
'
'	Verify that the information given is represented in the current dialog caption
'
'	PARAMETERS
'		sInfo - [Caption Text]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckCaption(sInfo as String) as Long

	Dim sText as String

	lTopOfArray = vtSplit(sInfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_CAPTION then
		LogDialogCheck (FAIL_PREFIX + "Edit control should have " + str(NUM_PARAM_EDIT) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckCaption = FALSE
		Exit Function
	end if
		
	sText = sArray(0)

	if GetText(wGetActWnd) = sText then
		LogDialogCheck ("Dialog Caption [" + sText + "] found."	)
		bCheckCaption = TRUE
	else
		LogDialogCheck (FAIL_PREFIX + "Dialog Caption [" + GetText(wGetActWnd) + _
				"] found, but config file is looking for [" + sText + "].")
		bCheckCaption = TRUE
	end if

end function 'bCheckCaption

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKEDIT
'
'	Verify that the information given is represented in a currently valid edit control
'
'	PARAMETERS
'		sInfo - [Ordinal of Edit Control];[Current Text];[Associated Text]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckEdit(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sText as String
	Dim sAscLabel as String

	lTopOfArray = vtSplit(sInfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_EDIT then
		LogDialogCheck (FAIL_PREFIX + "Edit control should have " + str(NUM_PARAM_EDIT) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckEdit = FALSE
		Exit Function
	end if
		
	sOrdinal = sArray(0)
	sText = sArray(1)
	sAscLabel = sArray(2)
	
	If WEditExists(sOrdinal) then
		if GetText(WEditFind(sOrdinal)) = sText then
			LogDialogCheck ("Edit control [" + sText + "] located and verified.")
			bCheckEdit = TRUE
			exit function

		else

			LogDialogCheck (FAIL_PREFIX + "Edit Box [" + GetText(WEditFind(sOrdinal)) + _
					"] on dialog should equal [" + sText + "] in CFG file.")

		end if

	else

		LogDialogCheck (FAIL_PREFIX + "[" + sOrdinal + "] edit box can not be found.")

	end if
	
	bCheckEdit = FALSE
end function 'bCheckEdit

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKSTATIC
'
'	Verify that the information given is represented in a currently valid static control
'
'	PARAMETERS
'		sInfo - [Ordinal of Static Control];[Current Text]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckStatic(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sText as String

	lTopOfArray = vtSplit(sInfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_STATIC then
		LogDialogCheck (FAIL_PREFIX + "Static control should have " + str(NUM_PARAM_STATIC) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckStatic = FALSE
		Exit Function
	end if

	sOrdinal = sArray(0)
	sText = sArray(1)
	
	If WStaticExists(sOrdinal) then
		if GetText(WStaticFind(sOrdinal)) = sText then
			LogDialogCheck ("Static control [" + sText + "] located and verified.")
			bCheckStatic = True
			exit function

		else

			LogDialogCheck (FAIL_PREFIX + "Static Text [" + GetText(WStaticFind(sOrdinal)) + _
					"] on dialog should equal [" + sText + "] in CFG file.")

		end if

	else

		LogDialogCheck (FAIL_PREFIX + "[" + sOrdinal + "] static control can not be found.")

	end if
	
	bCheckStatic = FALSE

end function 'bCheckStatic

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKTAB
'
'	Verify that the information given is represented in a currently valid tab control.
'	Will click on the tab to make it active.
'
'
'	PARAMETERS
'		sInfo - [Text of Tab Control]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckTab(sTabName as String) as Long

	if WTabExists(DEFAULT_ORDINAL) = FALSE then
		LogDialogCheck (FAIL_PREFIX + "No Tab controls exist.")
		bCheckTab = FALSE
	end if

	if wTabItemExists(DEFAULT_ORDINAL, sTabName) then
		wTabItemClk(DEFAULT_ORDINAL, sTabName)
		LogDialogCheck ("Found Tab [" + sTabName + "] as expected. Selecting...")
		bCheckTab = TRUE
		sleep 1

	else

		LogDialogCheck (FAIL_PREFIX + "Could not locate Tab [" + sTabName + "].")
		bCheckTab = FALSE

	end if

end function 'CheckTab

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKVIEW
'
'	Verify that the information given is represented in a currently valid VIEW LIST control
'
'	PARAMETERS
'		sInfo - [Ordinal of View List Control];[Associated Text]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckView(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sName as String



	lTopOfArray = vtSplit(sInfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_VIEW then
		LogDialogCheck (FAIL_PREFIX + "View list control should have " + str(NUM_PARAM_VIEW) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckView = FALSE
		Exit Function
	end if

	sOrdinal = sArray(0)
	sName = sArray(1)

	if wViewExists("@1") = FALSE then
		LogDialogCheck (FAIL_PREFIX + "No View controls exist.")
		bCheckView = FALSE
	end if

	if wViewExists(sOrdinal) then
		if GetText(wViewFind(sOrdinal)) = sName then
		
			LogDialogCheck ("Found View List [" + sName + "] as expected.")
			bCheckView = TRUE
			sleep .5

		else

			LogDialogCheck (FAIL_PREFIX + "Looking for [" + Name + _
					"] View List control but found [" + GetText(wViewFind(sOrdinal)) + "].")
			bCheckView = FALSE
		end if

	else

		LogDialogCheck (FAIL_PREFIX + "Could not locate View List with ordinal [" + sOrdinal + "]")
		bCheckView = FALSE

	end if

end function 'bCheckView

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKVIEWITEM
'
'	Verify that the information given is represented in a currently valid VIEW ITEM control
'
'	PARAMETERS
'		sInfo - [Ordinal of View List Control];[Text of Item]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckViewItem(sInfo as String) as Long
	Dim sViewOrdinal as String
	Dim sItemText as String

	lTopOfArray = vtSplit(sinfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_VIEWITEM then
		LogDialogCheck (FAIL_PREFIX + "View Item should have " + str(NUM_PARAM_VIEWITEM) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckViewItem = FALSE
		Exit Function
	end if

	sViewOrdinal = sArray(0)
	sItemText = sArray(1)

'If not even one view box exists then bail immediately
	if wViewExists("@1") = FALSE then
		LogDialogCheck (FAIL_PREFIX + "No View controls exist.")
		bCheckViewItem = FALSE
		exit Function
	end if

'Check for the View box specified
	if wViewExists(sViewOrdinal) then

'Locate the view item itself
		if wViewItemExists(sViewOrdinal, sItemText) = TRUE then

			LogDialogCheck ("Found View item [" + sItemText + "] as expected.  Selecting...")
			wViewItemClk(sViewOrdinal, sItemText)
			bCheckViewItem = TRUE
			sleep MIN_WAIT

		else

'The View item does not exist, fail
			LogDialogCheck (FAIL_PREFIX + "Looking for item [" + sItemText + _
					"], did not find in view box [" + sViewOrdinal + "].")
			bCheckViewItem = FALSE
		end if

	else

'No view list exists, fail
		LogDialogCheck (FAIL_PREFIX + "Could not locate View List with ordinal [" + sViewOrdinal + "]")
		bCheckViewItem = FALSE

	end if


end function 'CheckViewItem

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKBUTTON
'
'	Verify that the information given is represented in a currently valid button control
'
'	PARAMETERS
'		sInfo - [Ordinal of Button];[Text of Button];[1 or 0 for Enabled]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckButton(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sText as String
	Dim iEnabled as integer

	lTopOfArray = vtSplit(sinfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_BUTTON then
		LogDialogCheck (FAIL_PREFIX + "Button control should have " + str(NUM_PARAM_BUTTON) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckButton = FALSE
		Exit Function
	end if

	sOrdinal = sArray(0)
	sText = sArray(1)
	iEnabled = val(sArray(2))

	If WButtonExists(sOrdinal) then
		if GetText(WButtonFind(sOrdinal)) = sText then
			LogDialogCheck ("Button control [" + sText + "] located and verified.")
			bCheckButton = TRUE
			exit function

		else

			LogDialogCheck (FAIL_PREFIX + "Button [" + GetText(WButtonFind(sOrdinal)) + _
					"] on dialog should equal [" + sText + "] in CFG file.")

		end if

	else

		LogDialogCheck (FAIL_PREFIX + "Button [" + sOrdinal + "] can not be found.")

	end if

	bCheckButton = FALSE	

End Function 'bCheckButton

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKCHECKBOX
'
'	Verify that the information given is represented in a currently valid check box control
'
'	PARAMETERS
'		sInfo - [Ordinal of CheckBox];[Text of Box];[1/0 Checked];[1/0 Enabled]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckCheckBox(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sText as String
	Dim bChecked as integer
	Dim bEnabled as integer

	lTopOfArray = vtSplit(sinfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_CHECKBOX then
		LogDialogCheck (FAIL_PREFIX + "CheckBox control should have " + str(NUM_PARAM_CHECKBOX) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckCheckBox = FALSE
		Exit Function
	end if

	sOrdinal = sArray(0)
	sText = sArray(1)
	bChecked = val(sArray(2))
	bEnabled = val(sArray(3))


'Verify existence of check box
	If wCheckExists(sOrdinal) then
		if GetText(WCheckFind(sOrdinal)) <> sText then

			LogDialogCheck (FAIL_PREFIX + "CheckBox [" + GetText(WCheckFind(sOrdinal)) + _
					"] on dialog should equal [" + sText + "] in CFG file.")
			bCheckCheckBox = FALSE
			exit function
		end if
	else
		LogDialogCheck (FAIL_PREFIX + "[" + sOrdinal + "] Check Box can not be found.")
		bCheckCheckBox = FALSE
		exit function
	end if

'Verify Check Box State
	if wCheckState(sOrdinal) = CHECKED and bChecked = 0 then

		LogDialogCheck (FAIL_PREFIX + "CheckBox [" + sText + "] is checked, config file indicates not checked.")
		bCheckCheckBox = FALSE
		exit function
		
	elseif wCheckState(sOrdinal) = UNCHECKED and bChecked <> 0 then
		LogDialogCheck (FAIL_PREFIX + "CheckBox [" + sText + "] is not checked, config file indicates checked.")
		bCheckCheckBox = FALSE
		exit function

	end if

'Verify Check Box Enable Property
	if wCheckEnabled(sOrdinal) = TRUE and bEnabled = 0 then

		LogDialogCheck (FAIL_PREFIX + "CheckBox [" + sText + "] is enabled, config file indicates not enabled.")
		bCheckCheckBox = FALSE
		exit function
		
	elseif wCheckEnabled(sOrdinal) = FALSE and bEnabled <> 0 then
		LogDialogCheck (FAIL_PREFIX + "CheckBox [" + sText + "] is not enabled, config file indicates enabled.")
		bCheckCheckBox = FALSE
		exit function

	end if
	
	LogDialogCheck ("CheckBox control [" + sText + "] located and verified.")
	bCheckCheckBox = TRUE

End Function 'bCheckCheckBox

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKLISTBOX
'
'	Verify that the information given is represented in a currently valid LIST BOX control
'
'	PARAMETERS
'		sInfo - [Ordinal of ListBox Control];[Associated Text]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckListBox(sInfo as String) as Long

	Dim sOrdinal as String
	Dim sName as String


	lTopOfArray = vtSplit(sInfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_VIEW then
		LogDialogCheck (FAIL_PREFIX + "ListBox control should have " + str(NUM_PARAM_VIEW) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckListBox = FALSE
		Exit Function
	end if

	sOrdinal = sArray(0)
	sName = sArray(1)

	if wListExists("@1") = FALSE then
		LogDialogCheck (FAIL_PREFIX + "No ListBox controls exist.")
		bCheckListBox = FALSE
	end if

	if wListExists(sOrdinal) then
		if GetText(wListFind(sOrdinal)) = sName then
		
			LogDialogCheck ("Found ListBox [" + sName + "] as expected.")
			bCheckListBox = TRUE
			sleep MIN_WAIT

		else

			LogDialogCheck (FAIL_PREFIX + "Looking for [" + Name + _
					"] ListBox control but found [" + GetText(wListFind(sOrdinal)) + "].")
			bCheckListBox = FALSE
		end if

	else

		LogDialogCheck (FAIL_PREFIX + "Could not locate ListBox with ordinal [" + sOrdinal + "]")
		bCheckListBox = FALSE

	end if

end function 'bCheckListBox

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCHECKLISTBOXITEM
'
'	Verify that the information given is represented in a currently valid LISTBOX ITEM control
'
'	PARAMETERS
'		sInfo - [Ordinal of ListBox Control];[Text of Item]
'
'	RETURN VALUE
'		TRUE if all of the parameters check out
'		FALSE if any part of the parameters fail
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCheckListBoxItem(sInfo as String) as Long
	Dim sListBoxOrdinal as String
	Dim sItemText as String

	lTopOfArray = vtSplit(sinfo, ";", sArray)

'Holder is the top of the array that starts at 0.  Need to add one to get the
'actual number of items.
	If (lTopOfArray + 1) <> NUM_PARAM_VIEWITEM then
		LogDialogCheck (FAIL_PREFIX + "ListBox Item should have " + str(NUM_PARAM_VIEWITEM) + _
				" parameters but config file has " + str((lTopOfArray + 1)) + ". [" + sInfo + "]")
		bCheckListBoxItem = FALSE
		Exit Function
	end if

	sListBoxOrdinal = sArray(0)
	sItemText = sArray(1)

'If not even one view box exists then bail immediately
	if wListExists("@1") = FALSE then
		LogDialogCheck (FAIL_PREFIX + "No List controls exist.")
		bCheckListBoxItem = FALSE
		exit Function
	end if

'Check for the View box specified
	if wListExists(sListBoxOrdinal) then

'Locate the view item itself
		if wListItemExists(sListBoxOrdinal, sItemText) = TRUE then

			LogDialogCheck ("Found ListBox item [" + sItemText + "] as expected.  Selecting...")
			wListItemClk(sListBoxOrdinal, sItemText)
			bCheckListBoxItem = TRUE
			sleep MIN_WAIT

		else

'The View item does not exist, fail
			LogDialogCheck (FAIL_PREFIX + "Looking for item [" + sItemText + _
					"], did not find in ListBox [" + sListBoxOrdinal + "].")
			bCheckListBoxItem = FALSE
		end if

	else

'No view list exists, fail
		LogDialogCheck (FAIL_PREFIX + "Could not locate ListBox with ordinal [" + sListBoxOrdinal + "]")
		bCheckListBoxItem = FALSE

	end if


end function 'bCheckListBoxItem
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\util.inc ===
' File name: util.inc
' Project:  uitests
' ------------------------------------------------------------
'  Copyright 1994-1996 Software Testing Laboratories, Inc.
'  All rights reserved. You may use this source code freely
'  as long as it is not included as part of a selling product.
' ------------------------------------------------------------

 
'  Purpose: Common functions and subroutines that are useful
'           to other test case files are placed into this
'           file for MMC project.  
' 
'  Revision History:
' 
'  [ 0]  da-mon-year    email   action
'  [ 1]  28-FEB-1996    TomAr   Created NOTEUTIL.INC to hold
'                               common functions & subroutines.
'  [ 2]  29-FEB-1996    TVT     Moved in some common funcs.
'  [ 3]  06-MAR-1996    TomAr   Fixed TVT's bugs, added more
'                               support routines.
'  [ 4]  12-oct-1996    OanaN   Added support for warnings
'  [ 5]  27-feb-1997    OanaN   Added support for logging in 
'                                in ASCII and ODBC
' ------------------------------------------------------------

'$IFNDEF UTIL_INCLUDED
'$DEFINE UTIL_INCLUDED
'$include 'winapi.inc'

' ---------------------- INCLUDES ------------------------------

Declare function TestBegin_More()
Declare function TestEnd_More()

'********** Logging structure for Test Enterprise flat file logging
	Global gLIS_TE AS LOGINITSTRUCT

'********** Logging level: variables and constants
global gLoggingLevel%   
global MIN_WAIT as integer

const LVL_SUMMARY%      = 5   'Summary info after each test case
const LVL_STATUSINFO    = 20  'General status info
const LVL_VERBOSE%      = 100 'more than status, less tahn debugging
const LVL_DEBUGGING%    = 200 'Have all calls to LOG enabled

'********** Logging indentation constants
const EOL		= chr$(13)+chr$(10)
const TAB		= chr$(9)
const ENTER		= chr$(13)
const ONESPACE	= chr$(32)
const MAX_GAP   = 10    '# spaces gap used in logging out info
const INDENT    = "  "

'*********** pre-pend '+' to a string to allow VT to search for partial strings *********
const VT_WILDCARD			= "+"

'********** Tracing: enter and exit subroutines
'used to format sub EnterSub ( )
global gCountSpaces%
gCountSpaces = 0


'$ifdef RAS
   const MIN_WAIT%			= 5
   const MAX_WAIT%         = 10
   const HUGE_WAIT         = 100
   const MAX_TRY				= 60
   const MIN_TRY				= 5
'$else
	
	if ENVIRON("MIN_WAIT")<>"" then
		MIN_WAIT=Val(ENVIRON("MIN_WAIT"))
	else
		MIN_WAIT = 2
	end if

   'const MIN_WAIT%			= 2      
   const MAX_WAIT%         = 10     
   const HUGE_WAIT         = 100
   const MAX_TRY				= 60
   const MIN_TRY				= 5
'$endif

'********** global logging variables about scenarios and failures
global gstrScriptName$  'name of component tested by each script file
                        'Must be initialized before TestBegin()

global gstrLastScenario$'last scenario name
global gstrLastFailure$ 'last encountered failure

global gstrSummary$     'PASS/FAIL summary logged at the end of viewport/text file log

global giTestCount%     'Incr. by strTestNum()
global giFailCount%     'Incr. by strFailNum()
global giReported%      'Reset on scenario begin, set by ReportIt()
global giReportCount%   'total number of reports. Incr. by ReportIt

'*********** text file logging 
global giLogFile%			'Log file ID number
global giLogFileDetailed%   'Detailed log file ID number
global gnLogToFile%			'if TRUE , ASCII logging is ON
							'if FALSE, ASCII logging is OFF
gnLogToFile             = TRUE


global gstrTempPath$    'Temporary file path to create the log

'*********** Script pause and stop globals
global User_Terminated	as integer	 ' Flag  set when the user terminates
global User_Paused		as integer	 ' Flag  set when the user pauses

User_Paused			= FALSE
User_Terminated	    = FALSE

'*********** ODBC database for logging MMC UI results

const    SQL_MMC_UI_TABLE  = "DSSNAPIN"
const    TEST_NAME         = "MMC"
const    MAX_DETAIL		   = 8000


'***************************************************************
'* Subroutine:  TestBegin
'* Purpose:     All initialization code that needs to be run
'*              before the scenarios of a test case are
'*              executed should be placed in this subroutine.
'*              This subroutine needs to be called first by
'*              each test case.
'*
'* Parameters:  NONE
'*
'***************************************************************

sub TestBegin()

   viewport clear      'Clean the contents of the Viewport tab
                       'in the Output window.
   Randomize Timer
   
   gstrTempPath      = ENVIRON$("TEMP")+"\"

   'adaptations to handle new shell controls:
   wTabSetClass ( "SysTabControl32\UxTab" )		'for Properties opened from dsFind


   'this controls the logging level. 
   'see levels of logging defined in constants.inc
   '
   select case ucase(ENVIRON$("LOG_LEVEL"))
      case "SUMMARY"
         gLoggingLevel  = LVL_SUMMARY
      case "STATUSINFO"
         gLoggingLevel  = LVL_STATUSINFO
      case "VERBOSE"  
         gLoggingLevel  = LVL_VERBOSE
      case "DEBUGGING"
         gLoggingLevel  = LVL_DEBUGGING
      case else
         gLoggingLevel  = LVL_VERBOSE
   end select

	'two minutes (uses milliseconds)
	SetDeadlockTimeout ( 120000 )
	
   '//Begin Test Enterprise flat file logging
	'$IFDEF TE_LOGGING_FLAT
		  InitializeTELogging()
	'$ENDIF

   'Logging stuff---------------------------------------
   InitializeLogging()

'   SetupSQLLogging()
   'Logging stuff--------------------------------------- 
   
   'At this point insert calls to other initialization routines you may
   'need for setting up your Visual test scripts, like
   'reading environment variables, starting application etc.
   'You must implement the TestBegin_More function in a separate
   'include file, specific to your project
   TestBegin_More()

end sub 'TestBegin()


'***************************************************************
'* Subroutine:  TestEnd
'* Purpose:     Clean-up code that needs to be executed after
'*              all scenarios for a given test case file have
'*              been executed.
'*
'* Parameters:  NONE
'*
'***************************************************************
sub TestEnd ( )
   'At this point insert calls to other routines you may
   'need for clean-up up your Visual test scripts, like
   'resetting environment variables, closing application etc.

   'You must implement the TestEnd_More function in a separate
   'include file, specific to your project
   TestEnd_More()




   'Logging stuff---------------------------------------
   EndLogging()

   '//End Test Enterprise flat file logging
	'$IFDEF TE_LOGGING_FLAT
		EndTELogging()
	'$ENDIF

'   CleanupSQLLogging()
   'Logging stuff--------------------------------------- 

end sub 'TestEnd()

' --------------------------------------------------------------
' Function  : InitializeTELogging
' Author    : edfrench
' Purpose   : Initializes the log file used with flat file
'				logging for Test Enterprise
' --------------------------------------------------------------
sub InitializeTELogging()
  	'//Set Logging structure
	dim sFileName	as string
	dim sDrive		as string
	dim sDir		as string
	dim sExt		as string

	dim sSuiteName	as string
	dim sCaseName	as string


	'//Initialize the logging structure
	setLogStruct()

	'//Get the name of the .mst or .pc6 file that is running
	SPLITPATH Name(), sDrive, sDir, sFileName, sExt
	'//Set the Suite name and Case name
	'//environmental variable TE_SUITENAME should be set to the
	'//component being tested, otherwise the Suitename will be 
	'//set to the executing .mst or .pc6 filename
	if environ$ ("TE_SUITENAME")="" then
		sSuiteName=sFileName
		sCaseName=sFileName
	else
		sSuiteName=environ$ ("TE_SUITENAME")
		sCaseName=environ$ ("TE_SUITENAME") + ": " + sFileName
	end if
	'//Begin logging	
	LogBeginSuite (sSuiteName, gLIS_TE )
	LogBeginCase (sCaseName)

end sub


' --------------------------------------------------------------
' Function  : SetLogStruct
' Author    : edfrench
' Purpose   : Populates the log structure used with flat file
'				logging for Test Enterprise
' --------------------------------------------------------------
function SetLogStruct() as long

	gLIS_TE.LogOutputType = LogTypeFile
	gLIS_TE.MinDetailLevel = 5
	gLIS_TE.ProductVersion =GetBuildNum()
	'//Machine name is set to machine the tests are executing on
	gLIS_TE.MachineName = "\\" + environ$ ("COMPUTERNAME")
	'//Environmental variable TE_LOGFILE should be set before
	'//executing tests, otherwise default log location is in the
	'//temp directory
	if environ$ ( "TE_LOGFILE" )="" then
			gLIS_TE.LogLocation = environ$ ("TEMP") + "\TE.log"
		else
			gLIS_TE.LogLocation = environ$ ("TE_LOGFILE")
	end if
	gLIS_TE.Language = "US English"
	'//Log file must not contain results from previous tests so
	'//log file will be deleted
	on local error goto KillError
	kill gLIS_TE.LogLocation

    Exit Function
KillError:
	'//The logfile doesn't exist so the kill statement generates and error
	'//Resume at the next line which is the Exit function statement
	resume next
end function

' --------------------------------------------------------------
' Function  : GetBuildNum
' Author    : edfrench
' Purpose   : returns build number as string
' --------------------------------------------------------------
function GetBuildNum() as string
	DIM  build&,  osv AS OSVERSIONINFO,  win32Desc$

	osv.dwOSVersionInfoSize = LEN( osv )
	GetVersionEx( osv )
	build = &H0000FFFF& AND osv.dwBuildNumber
	'//5.0.xxxx
	'GetBuildNum =	TRIM$( STR$( osv.dwMajorVersion ) ) + "." + _
	'			TRIM$( STR$( osv.dwMinorVersion ) ) + "." + _
	GetBuildNum = 	TRIM$( STR$( build ) )
end function

' --------------------------------------------------------------
' Function  : EndTELogging
' Author    : edfrench
' Purpose   : Ends the flat file logging for Test Enterprise 
' --------------------------------------------------------------
sub EndTELogging()
'//Close logging
	LogEndCase
	LogEndSuite
end sub 'EndTELogging

' --------------------------------------------------------------
' Function  : EnterSub
' Author    : JerryA
' Purpose   : Traces entering subroutines and functions  
'             using it consistently will allow the logging output
'             in the viewport to contain useful information for 
'             debugging script, in an indented format
'
'				  Setting iLogLevel to something other than the default
'				  will enable suppressing for applications that use 
'				  common subroutines, but that do not want to see
'				  this level of debug detail, which can become quite verbose.
'
'				  Calling this function increments the global counter gCountSpaces
'				  which is shared with other functions such as ExitSub
' --------------------------------------------------------------
sub EnterSub ( strName$, iLogLevel%=LVL_STATUSINFO )
	
	dim loopCount%
	dim strSpaces$
	
	'initialize space count for indention to zero
	strSpaces = ""
	
	'build total number of spaces to be in the indention, where INDENT = two spaces
	for loopCount = 0 to gCountSpaces - 1
		strSpaces = strSpaces + INDENT
	next loopCount

	'call LogIt with total indention
	LogIt ( iLogLevel, strSpaces + "ENTER: " + strName )

	'increment gCountSpaces (a global value)
	gCountSpaces = gCountSpaces + 1

end sub 'EnterSub

' --------------------------------------------------------------
' Function  : ExitSub
' Author    : JerryA
' Purpose   : Traces exiting subroutines and functions   
'
'				  This essentially the opposite of EnterSub.
'				  Loglevel can be set and the global gCountSpaces 
'				  is decremented.  See also EnterSub
' --------------------------------------------------------------
sub ExitSub ( strName$, iLogLevel%=LVL_STATUSINFO )

	dim loopCount%
	dim strSpaces$

	'initialize space count for indention to zero
	strSpaces = ""

	'decrement gCountSpaces (a global value)
	gCountSpaces = gCountSpaces - 1

	'build total number of spaces to be in the indention, where INDENT = two spaces
	for loopCount = 0 to gCountSpaces - 1	
		strSpaces = strSpaces + INDENT
	next loopCount

	'call LogIt with total indention
	LogIt ( iLogLevel, strSpaces + "EXIT: " + strName )

end sub 'ExitSub

' --------------------------------------------------------------
'  Function:    iFailCount
'  Purpose:     Returns current number of failures for current
'               test case file.  This only works if the test
'               scenarios are using strFailNum() in conjunction
'               with calls to the FAIL statement.  Done this
'               way to avoid Test programmers directly accessing
'               the giFailCount global variable.
'  Returns:     INTEGER Current value of giFailCount which is
'                       a global value incremented every time
'                       strFailNum is called.
' 
' --------------------------------------------------------------

function iFailCount() as integer
    iFailCount = giFailCount
end function 'iFailCount


' --------------------------------------------------------------
'  Function:    iTestCount
'  Purpose:     Returns current number of test scenarios executed
'               for current test case file.  This only works if
'               the test scenarios are using strTestNum() in
'               conjunction with calls to the SCENARIO statement.
'               Done this way to avoid Test programmers directly
'               accessing the giTestCount global variable.
' 
'  Returns:     INTEGER Current value of giTestCount which is
'                       a global value incremented every time
'                       strTestNum is called.
' 
' --------------------------------------------------------------

function iTestCount() as integer
    iTestCount = giTestCount
end function 'iTestCount

' --------------------------------------------------------------
'  Function:    strFailNum
'  Purpose:     Keeps a counter of the total number of failures
'               that have occurred using the FAIL command for
'               the current test case file.  For this to work,
'               it must be called for each FAILure and is
'               therefore designed to work with the FAIL
'               statement.
'
'  Returns:     STRING  The string that is returned is formatted
'                       to fit in front of the text being
'                       included in the FAIL statement.
' 
'  Format
'  returned:    "Fail #<num>: "
' 
'  Use:         FAIL strFailNum()+"<descrip-of-failure>"
' 
' --------------------------------------------------------------

function strFailNum() as string
    dim strTemp$

    giFailCount = giFailCount + 1
    strFailNum  = "Fail    #"+trim$(str$(giFailCount))+": "

end function 'strFailNum()

                  
' --------------------------------------------------------------
'  Function:    strTestNum
'  Purpose:     Keeps a counter of the total number of tests
'               that have been executed for the current test
'               case file.  For this to work, it must be
'               called for each test.  It is designed to work
'               with the SCENARIO statement.  This is why it
'               returns a string.
' 
'  Returns:     STRING  The string that is returned is formatted
'                       to fit in front of the text being
'                       included in the SCENARIO statement.
' 
'  Format
'  returned:    Root MST Name + ".<num> "
' 
'  Use:         SCENARIO strTestNum()+"<descrip-of-test>"
' 
' --------------------------------------------------------------

function strTestNum() as string
    dim strTemp$, numTemp$
	dim fileEnd&, fileStart&, i&

    giTestCount = giTestCount + 1
	 giReported  = 0

    'extract the test file name (but not extension) from the full path
    for i = len(NAME$) to 1 step -1
	  if mid(NAME$, i, 1) = "." then
	    fileEnd = i
      end if
	  if mid(NAME$, i, 1) = "\" then
	    fileStart = i + 1
		exit for
	  end if
	next i

    numTemp = trim$(str$(giTestCount))
	if len(numTemp)<2 then
	  numTemp = "0" + numTemp
	end if

    strTemp     = mid$(NAME$, fileStart, fileEnd-FileStart)+"."+numTemp+" "
      
    strTestNum  = strTemp
   
end function 'strTestNum()


'--------------------------------------------------
' LogIt
'	Logs to screen, debugger, files, etc.
'	It is assumed that the file #1 is already open 
'	and is intended for logging.
'--------------------------------------------------
Sub LogIt (level%, Message$, bDetailedLogToFile = FALSE)
	dim msg$
   dim strCrtScenario$, strSeparator$
	dim loopCount%
	dim strSpaces$
   dim strIndent$

	'this section is used to add indentation to logs
	strSpaces = ""

	for loopCount = 0 to gCountSpaces
		strSpaces = strSpaces + INDENT
	next loopCount

   ' don't display any logging info with levels higher than
   ' general debugging level
   if level > gLoggingLevel then
      exit sub
   endif

   select case level   
      case LVL_SUMMARY     
         strIndent = ""
      case LVL_STATUSINFO   
         strIndent = INDENT
      case LVL_VERBOSE  
         strIndent = INDENT + INDENT
      case LVL_DEBUGGING   
         strIndent = INDENT + INDENT + INDENT
      case else
         strIndent = ""
   end select

	msg = strIndent + strSpaces + Message
	log level, msg
	print #giLogFileDetailed, ""
    print #giLogFileDetailed, msg
   
   'log level, msg

   if bDetailedLogToFile = TRUE then
      'if new scenario, print its name  
      strCrtScenario = SCENARIO()
   
      if gstrLastScenario <> strCrtScenario then
         gstrLastScenario = strCrtScenario

         if len(gstrLastScenario) < 70 then
            strSeparator = STRING$(70-len(gstrLastScenario),"-")
         else
            strSeparator = "-"
         endif

         print #giLogFile, ""
         print #giLogFile, gstrLastScenario + " " +strSeparator
      endif
   
      print #giLogFile, msg
   endif

End Sub

'--------------------------------------------------
' ReportIt
'	Logs to screen, debugger, files, etc.
' and set the giReported, without fail the scenario
'--------------------------------------------------
Sub ReportIt (level%, Message$)
   LogIt(level, strReportNum() + Message, TRUE)

   giReported = 1
   ConcatenateFailure("Warning: " + Message)

End Sub

' --------------------------------------------------------------
'  Function:    strReportNum
'  Purpose:     Keeps a counter of the total number of reports
'               that have occurred using the FAIL command for
' --------------------------------------------------------------

function strReportNum() as string
    giReportCount = giReportCount + 1
    strReportNum  = "Warning #"+trim$(str$(giReportCount))+": "
end function 'strReportNum()


' --------------------------------------------------------------
'  Function:    iReportCount
'  Purpose:     Returns current number of reported warnings
' 
'  Parameters:  NONE
' 
'  Returns:     INTEGER Current value of giReportCount which is
'                       a global value incremented every time
'                       ReportIt is called.
' 
' --------------------------------------------------------------
function iReportCount() as integer
    iReportCount = giReportCount
end function 'iReportCount


function iReported() as integer
    iReported = giReported
end function 'iReported

'--------------------------------------------------
' FailIt
'	Logs to screen, debugger, files, etc.
'  and fail the scenario
'--------------------------------------------------
Sub FailIt (level%, Message$)
	LogIt(level, strFailNum() + Message, TRUE)

	ConcatenateFailure("Failure: "+ Message)

    '// Added by edfrench 10/24/01

    '// Save an image of the screen to the Temp directory

    '// See the function saveScreenShot for settings

     if environ("SCREENCAP_FILENAME") <> "" then 

         saveScreenShot

      end if


	' Following lines modified by erinco on 28 AUG 2000 to prevent "error code 50's" in Garth's VT script.  8^b



	if failed = false and scenario$ <> "" then 
		fail
	else
		print "Warning: FailIt was called at an inappropriate time."
	end if
End Sub

'--------------------------------------------------
' Failure
'  return TRUE if the test was failed or there were	
'  reported warnings
'--------------------------------------------------
Function Failure() as integer
	
	if( failed or giReported = 1 ) then
		Failure = TRUE
	else
		Failure = FALSE
	endif

End Function

'--------------------------------------------------
' ReportScenarioStatus
'  To be called in Scenario Cleanup section.
'  Builds the PASS/FAIL reports
'--------------------------------------------------
sub ReportScenarioStatus()
   dim strTemp$, strSpace$

   strTemp  = space$(4)+SCENARIO()+":"

   if( len(strTemp) <= 64  ) then
	strSpace = space$(64-len(strTemp))
  endif
  if failed then
      gstrSummary = gstrSummary + strTemp +_
                    strSpace+" - FAIL"+EOL
   else
      gstrSummary = gstrSummary + strTemp +_
                    strSpace+" - PASS"+EOL
   endif
   
   if failed then
 '      LogDataToSQL(SQL_VARIATION_FAILED, gstrLastFailure)
   else
     if iReported()>0 then
'	   LogDataToSQL(SQL_VARIATION_PASSED_WITH_WARNINGS, gstrLastFailure)
	 else
'	   LogDataToSQL(SQL_VARIATION_PASSED, gstrLastFailure) 'gstrLastFailure is empty unless ConcatenateFailure was called
	 end if
   end if 
   gstrLastFailure = ""


   'Because it has to be called on each scenario, it is a good place
   ' to look for User terminated or User Paused
   if User_Terminated = TRUE then
      TestEnd()
      END
   endif

   if User_Paused then	 'If the user pasued the test
		   Print "To resume the tests:"   'Instructions for the user.
		   Print "     Make sure MMC has the focus,"
		   Print "     Then Press {CTRL} {ALT} p"
		   User_Paused = FALSE  'wait until the user presses CTRL-ALT-p
		   do
			   sleep 1
		   loop until User_Paused
   endif

End Sub

'--------------------------------------------------
' InitializeLogging
'  To be called inside TestBegin
'  Connect to the database and open the ASCII log file
'	Added support to save the detail log by mehmetd   07 / 03 /2002
'
'--------------------------------------------------
sub InitializeLogging()
   dim nLen%
   dim strlogFile$, strlogFileDetailed$, strDate$, strNewDate$, HowToNameFile$

   gstrSummary       = EOL
   gstrLastScenario  = ""
   gstrLastFailure   = ""
   
   if gnLogToFile = TRUE then      
      'Log file is created in the Temporary directory
      ' name in format COMPUTERNAME(DATE).mmc
      strDate     = DATE$
      strNewDate  = ""

      for nLen = 1 to len(strDate)
         if ASC(strDate) >= ASC("0") and ASC(strDate) <= ASC("9") then
            strNewDate = strNewDate + CHR(ASC(strDate))
         else
            strNewDate = strNewDate + "_"
         endif

         strDate = right(strDate, len(strDate)-1)
      next nLen


		HowToNameFile = ENVIRON$ ( "DSFILENAME" ) 
		

		if HowToNameFile = "" then
			strlogFile = ENVIRON$("COMPUTERNAME")+"("+strNewDate+").mmc" 
			strlogFileDetailed = "Detailed_" + ENVIRON$("COMPUTERNAME")+"("+strNewDate+").mmc" 
		else
			strlogFile = HowToNameFile
			strlogFileDetailed = "Detailed_ " + strlogFile
		end if


      giLogFile   = FREEFILE
      open gstrTempPath + strlogFile for output as #giLogFile

	  giLogFileDetailed   = FREEFILE
	  open gstrTempPath + strlogFileDetailed for output as #giLogFileDetailed

   
      if (giLogFile < 1) or (giLogFile > 20) then

         gnLogToFile  = FALSE
         LogIt(LVL_VERBOSE, "File logging is OFF.")

      else

         LogIt(LVL_STATUSINFO, "File logging is ON.")

      endif
   endif

end sub 'InitializeLogging

'--------------------------------------------------
' EndLogging
'  Log statistics and PASS/FAIL status
'  Disconnect the database and close the ASCII log file
'--------------------------------------------------
Sub EndLogging()
   dim iPPass%         'Percent passed
   dim strMetrix$      'Misc metrics
	dim strWarnings$    'reported bugs: not so serious to fail the test

   'Set up info to be logged out
   if (iTestCount <> 0) then
     iPPass = ((iTestCount - iFailCount) / iTestCount) * 100
   endif
   strMetrix = space$(4)+"Scenarios: "+trim$(str$(iTestCount)) + _
             SPACE$(MAX_GAP) + "Errors: "+trim$(str$(iFailCount)) + _
             SPACE$(MAX_GAP) + "Passed: " + _
             trim$(str$(iPPass))+"%"

	strWarnings= space$(4)+"Warnings: "+trim$(str$(iReportCount))

   'Log out final information for the test case file
   'When doing the LEFT$() stuff a bunch of spaces are added
   'for padding and then are cropped off so that the max size
   'of the line being written out is 70 characters.  By cropping
   'like this the info can adjust its size and still have the
   'right-hand border of the box remain in line.
    LogIt( LVL_SUMMARY,STRING$(70,"*"), TRUE)
    LogIt( LVL_SUMMARY,"Test Case Results:", TRUE)
    LogIt( LVL_SUMMARY,gstrSummary, TRUE)
    LogIt( LVL_SUMMARY,strMetrix, TRUE)
    LogIt( LVL_SUMMARY,strWarnings, TRUE)
    LogIt( LVL_SUMMARY,EOL, TRUE)
    LogIt( LVL_SUMMARY,"Test case completed testing at "+left$(datetime$+space$(70),36), TRUE)
    LogIt( LVL_SUMMARY,"Test Case: "+(left$(NAME$(0)+space$(70),56)), TRUE)
    LogIt( LVL_SUMMARY,STRING$(70,"*"), TRUE)
    LogIt( LVL_SUMMARY,EOL, TRUE)
    LogIt( LVL_SUMMARY,EOL, TRUE)

   if gnLogToFile  = TRUE then
      close #giLogFile
	  close #giLogFileDetailed
   endif

End Sub 'EndLogging

sub ConcatenateFailure(Message$)
	dim strAdd$, crtLen%, msgLen%
	
	msgLen = len(Message)
	crtLen = len(gstrLastFailure)
	
	if (crtLen + msgLen) < MAX_DETAIL-3 then
		strAdd = Message + EOL
	else
		strAdd = left(Message, MAX_DETAIL - crtLen-1)
	endif

	gstrLastFailure = gstrLastFailure + strAdd	   
end sub

'**********************************
' ON ??? handling procedures
'**********************************
Sub End_Test (data_ as variant)
	'Status ("Ending test: Please wait for current repetition to finish.")
	print "Terminating: Please wait for current repetition to finish."
	User_Terminated = TRUE
	'Find_Main (Main_Window_Title)
end Sub

Sub Pause_Test (data_ as variant)
	' When the user wants to pause the test, we don't want to just pause 
	' since the viewport would not have the currently logged information.
	' We end the scenario so that all loggin will be printed out.
	' Then we pause, and after that restart the main test scenario."
	print "Pausing test: Please wait for current repetition to finish."
	User_Terminated = TRUE	
	User_Paused		= TRUE
	'Find_Main (Main_Window_Title)
end Sub

Sub Stop_Now (error_data as variant)
'	Status ("Unhandled exception detected.  Killing test script.")
	Print "Unhandled exception detected.  Killing test script."
	Print error_data
'	Find_Main (Main_Window_Title)
	end
end Sub

'**********************
' ON ??? statements
'**********************
ON Keypress ("x", FALT or FCONTROL) call End_Test
ON Keypress ("p", FALT or FCONTROL) call Pause_Test
ON UnhandledException CALL Stop_Now

'$ENDIF UTIL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\SV2_tools.inc ===
'************************************************************************************************************
'
'	SV2_TOOLS.inc
'
'	General purpose procedures not related to any form of testing but to add functionality
'	to VT data proccessing.
'
'	OTHER
'	Enables CTRL+q as a hotkey to kill the VT run.
'	Enables CTRL+q as a hotkey to kill the VT run.
'	Enables CTRL+q as a hotkey to kill the VT run.
'		(Three times for emphasis, so as not be missed by a casual scan)
'
'	FUNCTION LIST
'	Function vtSplit(sToSplit as String, cDelim as String, vArray as Array of String) as Long

'	Function b_wButtonClick_Ex(sButton as String) as long

'	Function b_wMenuSelect_Ex(	sMenu as String, _
'								bTryHotkeyVars=TRUE as Long) as long

'	Function b_wViewItemClk_Ex(sViewList as string, sViewItem as string, vButton=VK_LBUTTON as Variant) as long

'	Function b_wTreeItemClk_Ex(sTreeList as string, sTreeItem as string, vButton=VK_LBUTTON as Variant) as long

'	Function b_wTreeItemDblClk_Ex(sTreeList as string, sTreeItem as string, vButton=VK_LBUTTON as Variant) as long

'	Function b_wTreeItemExpand_Ex(sTreeList as string, sTreeItem as string) as long

'	Function b_wTreeItemCollapse_Ex(sTreeList as string, sTreeItem as string)

'	Sub LogIt(LVL_STATUSINFO, sText as String)

'	Sub LOG_FILE(sText as String)

'	Sub EnterSub(sName as String)

'	Sub ExitSub(sName as String)

'	Function bCloseDialogs(sBaseCaption as String, lIter=5 as Long) as long

'	Function lFindToolbarButtonOrdinal(sButton as String) as Long as long

'	Function lExpandEntireNode(sTreeList as string, sNodeOrdinal as String) as long

'	Function b_wListItemClk_Ex(sListBox as string, sListItem as string, vButton=VK_LBUTTON as Variant)

'	Sub CaptionSleep(sCaption as string)

'	Function iViewItemInstances(sViewList as String, sViewItem as String) as Integer

'	Function bOpenProperties(sViewList as String, sViewItem as String) as Long

'	Function bCheckDescription(sViewList as String, sViewItem as String) as Long

'	Function bRefreshContextPane() as Long

'	Function vBinToDec(sBinNumber as String) as Long

'	Function b_wTabItemClk_Ex(	sTabControl as string, _
'								sTabItem as string, _
'								vButton=VK_LBUTTON as Variant) as Integer

'	Function b_wCheckBoxCheck_Ex(	sControl as String, _
'									iChecked=CHECKED as Integer) as Integer

'	Function bRenameObject(		sViewList as String, _
'								sViewItem as String, _
'								sNewName as String) as Long

'	Function bRefreshObject(sObjectName as String) as Long

'	Function b_Play_Ex(sText as String) as Long


'
'	HISTORY
'	Date		User		Activity
'	09-26-2000	tyuhas		Created file
'	10-04-2000	tyuhas		Added support for listbox item clicks
'	10-11-2000	tyuhas		Merged with earlier version of site link tools.  Add verification
'							of list box uniqueness, and sleep until dialog appears function.
'	10-20-2000	tyuhas		Added a function to convert a binary string to decimal notation.
'							Needed it to indepently resolve subnet masks.
'	11-12-2000	tyuhas		Added Refresh/Rename functions
'	11-14-2000	tyuhas		Added function to record 'Play' events	
'	01-10-2001	tyuhas		Added auto-hotkey search to Select Meun function
'
'
'************************************************************************************************************

'Load the symbol for this file
'$DEFINE SV2_TOOLS

const DEFAULT_ORDINAL = "@1"
const ORD_1 = "@1"
const ORD_2 = "@2"
const ORD_3 = "@3"
const ORD_4 = "@4"
const ORD_5 = "@5"
const ORD_6 = "@6"
const ORD_7 = "@7"
const ORD_8 = "@8"
const ORD_9 = "@9"
const ORD_10 = "@10"
const ORD_11 = "@11"
const ORD_12 = "@12"
const ORD_13 = "@13"
const ORD_14 = "@14"
const ORD_15 = "@15"
const ORD_16 = "@16"
const ORD_17 = "@17"
const ORD_18 = "@18"
const ORD_19 = "@19"
const ORD_20 = "@20"

const FAIL_PREFIX = "***FAIL : "


Global iIndent as integer
const STANDARD_INDENT = 7

const ENTER_PROC_PREFIX = "ENT --> | "
const EXIT_PROC_PREFIX = "<-- EXT | "
const MSG_PREFIX = " | "

'For file logging.  need some definite functionality increase here.
const SITES_OUTPUT_FILE = "SitesOutput.log"



'Used if a previous test failed that would cause this test to fail automatically
'ALWAYS assume the test completed successfully, and testing can continue at the beginnning
Global bDependenceFailure as Integer
Global bPartialDepFailure as Integer
bDependenceFailure = FALSE
bPartialDepFailure = FALSE
Const DEP_FAIL_COMMENT = "DEPENDENCE FAILURE : Necessary previous scenario failed."

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	Enable pressing "ctrl+q" to stop VT
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

TYPE KeyPressParam
   Key AS INTEGER
   State AS INTEGER
END TYPE

SUB KeyHandler(v AS VARIANT)
	end
END SUB

ON KeyPress ("q", FCONTROL) CALL KeyHandler


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	VTSPLIT
'
'	Clone of the Visual Basic function 'Split'.  Hashes a singles string into an array of partitioned
'	strings based upon a set delimiter
'
'	PARAMETERS
'		sHold - String to hash, will be cloned and the copy worked on
'		cDelim - Single Character delimiter to divide sToSplit by
'		vArray - Dynamic array that the hashed strings are put into
'
'	RETURN VALUE
'		Boundary of the array, (starting at zero)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function vtSplit(sHold as String, cDelim as String, vArray as Array of String) as Long
	
	Dim sToSplit as String
	Dim lCount as Long
	Redim vArray(0) as String

'Prevent VT's predeliction to pass variables ByRef from causing havoc
	sToSplit = sHold

'If the calling function included a terminating deliminator, get rid of it
	If Right(sToSplit, 1) = cDelim then
		sToSplit = Left(sToSplit, len(sToSplit) - 1)
	end if

'Loop if a delimiter exists in the remaining string
	Do while instr(sToSplit, cDelim) <> 0
			
		Redim Preserve vArray(lCount) as String
		vArray(lCount) = left(sToSplit, instr(sToSplit, cDelim) - 1)

		sToSplit = right(sToSplit, len(sToSplit) - len(vArray(lCount)) - 1)
		lCount = lCount + 1
	Loop

'Get Last Item
	Redim Preserve vArray(lCount) as String
	vArray(lCount) = sToSplit

'Return the array boundary
	vtSplit = lCount

End Function 'vtSplit

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wButtonClick_Ex
'
'	Makes sure the specified button exists, then clicks it.
'
'	PARAMETERS
'		sButton - Text of button to click
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wButtonClick_Ex(sButton as String)

	EnterSub ("b_wButtonClick_Ex [" + sButton + "]")

	if wButtonExists(sButton, MAX_WAIT) then
		wButtonClick(sButton)
		b_wButtonClick_Ex = TRUE
	else
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Button [" + sButton + "] does not exist.")
		b_wButtonClick_Ex = FALSE
	end if

	ExitSub ("b_wButtonClick_Ex")
		
end Function 'b_wButtonClick_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wMenuSelect_Ex
'
'	Makes sure the specified menu exists, then clicks it.  If fails, will try variations of the 
'	menu item with/without hotkey.
'
'	PARAMETERS
'		sMenu - the string of the menu to verify and select, (eg: "File\Open")
'		bTryHotkeyVars - (DEFAULT=TRUE) is flag is set, and the specified menu is not found
'				the function will try to find a matching menu item by creating a list of
'				current menu items without hotkeys and remove the hotkey from the sent text.
'				If any of these match, that menu item is selected.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wMenuSelect_Ex(	sMenu as String, _
							bTryHotkeyVars=TRUE as Long) as Long

	EnterSub ("b_wMenuSelect_Ex [" + sMenu + "]")

	Dim bTempResult as Long


	'---------- Assume failure ---------
	bTempResult = FALSE

'	sleep 2
'	msgbox "here"

	if wMenuExists(sMenu, MIN_WAIT) = TRUE then

		wMenuSelect(sMenu)
		bTempResult = TRUE

	else


	'----------- the sent Menu item does not exist.  If try alternates flag is set
	'attempt to recover and find a suitable menu option ----------

		if bTryHotKeyVars = TRUE then

			
			'---------- convert sent menu item to "no hotkey" version --------
			Dim sMenuItems as Array of String
			Dim iNumMenus as Long
			Dim sTempMenu as String
			Dim iAmpLoc as Long



			'--------- create list of NO HOTKEY menu items ----------
			iNumMenus = 1
			Do While wMenuExists(_ord(iNumMenus)) = TRUE

				sTempMenu = MenuText(_ord(iNumMenus))
				iAmpLoc = instr(sTempMenu, "&")

				if iAmpLoc <> FALSE then
					sTempMenu = Left(sTempMenu, iAmpLoc - 1) + Right(sTempMenu, len(sTempMenu) - iAmpLoc)
				End if

			
				Redim Preserve sMenuItems(iNumMenus) as String
				sMenuItems(iNumMenus) = sTempMenu
				iNumMenus = iNumMenus + 1

			Loop


			'--------- Vars in VT are passed by reference. Mutilate a copy 
			'of the menu text to find. ----------
			sTempMenu = sMenu
			iAmpLoc = instr(sTempMenu, "&")

			if iAmpLoc <> FALSE then
				sTempMenu = Left(sTempMenu, iAmpLoc - 1) + Right(sTempMenu, len(sTempMenu) - iAmpLoc)
			End if



			For iNumMenus = 1 to uBound(sMenuItems)

				LogIt(LVL_DEBUGGING, "Looking For Menu:[" + sTempMenu + "] --- Found:[" + _
						sMenuItems(iNumMenus) + "]")

				if sTempMenu = sMenuItems(iNumMenus) then

					wMenuSelect(_ord(iNumMenus))
					bTempResult = TRUE
					Exit For

				end if


			Next iNumMenus


			'-------- if the menu was found, the result flag was set to true ---------
			if bTempResult = FALSE then

				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Menu Item[" + sMenu + "] does not exist.  Hotkey variations included.")

			End If



		else
		'---------- hotkey variation search not selected --------

			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Menu Item[" + sMenu + "] does not exist.  Did not try hotkey variations.")

		end if

	end if


	'---------- return temp value ----------
	b_wMenuSelect_Ex = bTempResult



	ExitSub ("b_wMenuSelect_Ex")
		
end Function 'b_wMenuSelect_Ex


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wViewItemClk_Ex
'
'	Makes sure the view item exists, then clks it
'
'	PARAMETERS
'		sViewList - Ordinal of View list to use
'		sViewItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wViewItemClk_Ex(sViewList as string, sViewItem as string, vButton=VK_LBUTTON as Variant)

	EnterSub ("b_wViewItemClk_Ex [" + sViewItem + "]")

'Make sure view list exists
	if wViewExists(sViewList, MAX_WAIT) then
		
'Make sure item exists
		if wViewItemExists(sViewList, sViewItem, MAX_WAIT) then

'Select the item
			wViewItemClk(sViewList, sViewItem, vButton)
			b_wViewItemClk_Ex = TRUE

		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "View Item [" + sViewItem + "] does not exist.")
			b_wViewItemClk_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "View List [" + sViewList + "] does not exist.")
		b_wViewItemClk_Ex = FALSE

	end if

	ExitSub ("b_wViewItemClk_Ex")
		
end Function 'b_wViewItemClk_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wTreeItemClk_Ex
'
'	Makes sure the Tree item exists, then clks it
'
'	PARAMETERS
'		sTreeList - Ordinal of Tree list to use
'		sTreeItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wTreeItemClk_Ex(sTreeList as string, sTreeItem as string, vButton=VK_LBUTTON as Variant)

	EnterSub ("b_wTreeItemClk_Ex [" + sTreeItem + "]")

'Make sure view list exists
	if wTreeExists(sTreeList, MAX_WAIT) then

'Select the first item in the Tree
		wTreeItemClk(sTreeList, "@1")
		
'Make sure item exists
		if wTreeItemExists(sTreeList, sTreeItem, MAX_WAIT) then

'Click the root of the tree once to make sure we don't accidentall 'double click'
'and invoke the 'change name' functionality of the tree
			wTreeItemClk(sTreeList, DEFAULT_ORDINAL)

		'	play "{ESC}"


	

'Select the item
			wTreeItemClk(sTreeList, sTreeItem, vButton)
			b_wTreeItemClk_Ex = TRUE

		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree Item [" + sTreeItem + "] not found; parent node may be closed.")
			b_wTreeItemClk_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree List [" + sTreeList + "] does not exist.")
		b_wTreeItemClk_Ex = FALSE

	end if

	sleep MIN_WAIT
		
	ExitSub ("b_wTreeItemClk_Ex")

end Function 'b_wTreeItemClk_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wTreeItemDblClk_Ex
'
'	Makes sure the Tree item exists, then DOUBLE - clicks it.
'
'	PARAMETERS
'		sTreeList - Ordinal of Tree list to use
'		sTreeItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wTreeItemDblClk_Ex(sTreeList as string, sTreeItem as string, vButton=VK_LBUTTON as Variant)

	EnterSub ("b_wTreeItemDblClk_Ex [" + sTreeItem + "]")

'Make sure view list exists
	if wTreeExists(sTreeList, MAX_WAIT) then
		
'Make sure item exists
		if wTreeItemExists(sTreeList, sTreeItem, MAX_WAIT) then

'Select the item
			wTreeItemDblClk(sTreeList, sTreeItem, vButton)
			b_wTreeItemDblClk_Ex = TRUE

		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree Item [" + sTreeItem + "] not found; parent node may be closed.")
			b_wTreeItemDblClk_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree List [" + sTreeList + "] does not exist.")
		b_wTreeItemDblClk_Ex = FALSE

	end if

	ExitSub ("b_wTreeItemDblClk_Ex")
		
end Function 'b_wTreeItemDblClk_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wTreeItemExpand_Ex
'
'	Makes sure the Tree item exists, then DOUBLE - clicks it.
'
'	PARAMETERS
'		sTreeList - Ordinal of Tree list to use
'		sTreeItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wTreeItemExpand_Ex(sTreeList as string, sTreeItem as string)

	EnterSub ("b_wTreeItemExpand_Ex [" + sTreeItem + "]")

'Make sure view list exists
	if wTreeExists(sTreeList, MAX_WAIT) then
		
'Make sure item exists
		if wTreeItemExists(sTreeList, sTreeItem, MAX_WAIT) then


'Expand the Node

'Click the first node to clear out previous clicks, (if applicaple)
				wTreeItemClk(sTreeList, DEFAULT_ORDINAL)

				wTreeItemClk(sTreeList, sTreeItem)

				sleep MIN_WAIT

				wTreeItemExpand(sTreeList, sTreeItem)

				sleep MIN_WAIT

				wTreeItemExpand(sTreeList, sTreeItem)

				b_wTreeItemExpand_Ex = TRUE


		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree Item [" + sTreeItem + "] not found; parent node may be closed.")
			b_wTreeItemExpand_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree List [" + sTreeList + "] does not exist.")
		b_wTreeItemExpand_Ex = FALSE

	end if

	ExitSub ("b_wTreeItemExpand_Ex")

end Function 'b_wTreeItemExpand_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wTreeItemCollapse_Ex
'
'	Makes sure the Tree item exists, then DOUBLE - clicks it.
'
'	PARAMETERS
'		sTreeList - Ordinal of Tree list to use
'		sTreeItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wTreeItemCollapse_Ex(sTreeList as string, sTreeItem as string)

	EnterSub ("b_wTreeItemCollapse_Ex [" + sTreeItem + "]")

'Make sure view list exists
	if wTreeExists(sTreeList, MAX_WAIT) then
		
'Make sure item exists
		if wTreeItemExists(sTreeList, sTreeItem, MAX_WAIT) then


'Expand the Node

'Click the first node to clear out previous clicks, (if applicable)
				wTreeItemClk(sTreeList, DEFAULT_ORDINAL)

				wTreeItemClk(sTreeList, sTreeItem)

				sleep MIN_WAIT

				wTreeItemCollapse(sTreeList, sTreeItem)


				b_wTreeItemCollapse_Ex = TRUE


		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree Item [" + sTreeItem + "] not found; parent node may be closed.")
			b_wTreeItemCollapse_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tree List [" + sTreeList + "] does not exist.")
		b_wTreeItemCollapse_Ex = FALSE

	end if

	ExitSub ("b_wTreeItemCollapse_Ex")

end Function 'b_wTreeItemCollapse_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	LogIt
'
'	Writes the output to the viewport, indented based upon global indent variable.
'
'	PARAMETERS
'		sText - String to Output
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Sub Log_VP(sText as String)

	Log String$(iIndent, " ") + sText
	if instr(sText, FAIL_PREFIX) then
		LOG_FILE(sTEXT)
	end if

end sub 'LogIt

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	LOG_FILE
'
'	Writes the output to the file, indented based upon global indent variable.
'
'	PARAMETERS
'		sText - String to Output
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Sub LOG_FILE(sText as String)

	dim vFile as Variant

	vFile = FREEFILE
	open SITES_OUTPUT_FILE for append as vFile
	print #vFile, DATETIME$ + " | " + sText
	close #vFile

end sub 'LogIt

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	EnterSub
'
'	Logs the given text and adds to indent
'
'	PARAMETERS
'		sName - Text to output, (generally the name of the calling function)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Sub EnterProc(sName as String)

	LogIt(LVL_STATUSINFO, ENTER_PROC_PREFIX + sName)
	iIndent = iIndent + STANDARD_INDENT

end sub 'EnterSub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	ExitSub
'
'	Logs the given text and subtracts from the indent
'
'	PARAMETERS
'		sName - Text to output, (generally the name of the calling function)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Sub ExitProc(sName as String)

	iIndent = iIndent - STANDARD_INDENT
	LogIt(LVL_STATUSINFO, EXIT_PROC_PREFIX + sName)

end sub 'ExitSub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCloseDialogs
'
'	Attempts to Close up to the number of specified dialogs using 'Close', 'Cancel' or {ESC}.
'	Will stop at the end of the given iterations, or when given base caption is active
'
'	PARAMETERS
'		sBaseCaption - Caption of Dialog to stop closing at
'		lIter - number of dialogs to go through, (Default = 5)
'
'	RETURN VALUE
'		TRUE is base caption found
'		FALSE (0) if not found
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCloseDialogs(sBaseCaption as String, lIter=5 as Long)

	EnterSub ("bCloseDialogs")

	Dim bCheck as Long
	Dim sCurCaption as String

	sCurCaption = GetText(wGetActWnd())

	Do while GetText(wGetActWnd()) <> sBaseCaption

'try cancel/close buttons first as {ESC} can have odd side effects depending on app
		If wButtonExists(BTN_CANCEL) then

			wButtonClick(BTN_CANCEL)

		elseIf wButtonExists(BTN_CLOSE) then

			wButtonClick(BTN_CLOSE)

		else

			'---------- try ESC.  if it works, the caption should change ----------
			play "{ESC}"
			Sleep MIN_WAIT

			if sCurCaption = GetText(wGetActWnd()) then


				'---------- Last resort is to press OK, (could cause changes to persist) -----------
				if wButtonExists(BTN_OK) then

					wButtonClick(BTN_OK)

				end if


			end if
		end if

'Let dialog close itself
		sleep MIN_WAIT

'If this goes on for more than the specified iterations, stop
		lIter = lIter - 1
		if lIter = 0 then exit do

	Loop

'Return value based on whether the base dialog was achieved
	If GetText(wGetActWnd()) = sBaseCaption then

		bClosedialogs = TRUE

	else


'All dialogs may be closed but base dialog may not have focus.   Try to refocus on it.

		bCheck = wFndWnd(sBaseCaption, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS)

		if bCheck = FALSE then

			bCloseDialogs = FALSE

		else

			bCloseDialogs = TRUE

		end if


	end if

	ExitSub ("bCloseDialogs")

end function 'bCloseDialogs

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	lFindToolbarButtonOrdinal
'
'	Searches through the active dialog for a toolbar that contains the specified button.
'
'	PARAMETERS
'		sButton - Name of button to find on Toolbar
'
'	RETURN VALUE
'		Ordinal Value of the toolbar which begins with the specified button
'		FALSE (0) if not found
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function lFindToolbarButtonOrdinal(sButton as String) as Long

		EnterSub ("lFindToolbarButtonOrdinal - [" + sButton + "]")

		Dim lTBCount as long
		
		lTBCount = 1
		lFindToolbarButtonOrdinal = FALSE

'Surf through each tool bar that exists...
		Do While wToolbarExists(_ord(lTBCount))
			if wToolbarButtonExists(_ord(lTBCount), sButton) then
				lFindToolbarButtonOrdinal = lTBCount
				Exit Do
			end if
			lTBCount = lTBCount + 1
		Loop

		

		ExitSub ("lFindToolbarButtonOrdinal")
End Function 'lFindConsoleToolbarOrdinal
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	lExpandEntireTree
'
'	Expands every node to its completion on the tree
'
'	RETURN VALUE
'		Number of children added to tree, (for recursion purposes mainly)
'
'	PARAMETERS
'		sTreeList - Ordinal of Tree list to use
'		sTreeNode - Tree Item to start with
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function lExpandEntireNode(sTreeList as string, sNodeOrdinal as String)

	EnterSub ("lExpandEntireNode [" + sNodeOrdinal + _
		":" + TreeItemText(sTreeList, sNodeOrdinal) + "]")

	Dim lNumOfChildren as Long
	Dim lCount as Long
	Dim lParentIndex as Long
	Dim lNewIndex as Long
	Dim sChildNode as Long

'Make sure view list exists
	if wTreeExists(sTreeList, MAX_WAIT) =FALSE then

		lExpandEntireNode = FALSE
		LogIt(LVL_STATUSINFO, "Tree [" + sTreeList + "] does not exist.")
		ExitSub ("lExpandEntireNode [" + sNodeOrdinal + _
				":" + TreeItemText(sTreeList, sNodeOrdinal) + "]")

		Exit Function
	end if
		
'Make sure the specified starting point exists
	if wTreeItemExists(sTreeList, sNodeOrdinal, MAX_WAIT) =FALSE then

		lExpandEntireNode = FALSE
		LogIt(LVL_STATUSINFO, "Tree Node [" + sNodeOrdinal + "] does not exist.")
		ExitSub ("lExpandEntireNode [" + sNodeOrdinal + _
				":" + TreeItemText(sTreeList, sNodeOrdinal) + "]")

		Exit Function
	end if

'Expand the node before checking for children
	LogIt(LVL_STATUSINFO, "Expanding item [" + sNodeOrdinal + _
		":" + TreeItemText(sTreeList, sNodeOrdinal) + "]")

	wTreeItemExpand(sTreeList, sNodeOrdinal)
	sleep MIN_WAIT

'Get Number of children, if none then we're done
	lNumOfChildren = wTreeItemCount(sTreeList, sNodeOrdinal)
	If lNumOfChildren = 0 then

		lExpandEntireNode = 1
		ExitSub ("lExpandEntireNode [" + sNodeOrdinal + _
				":" + TreeItemText(sTreeList, sNodeOrdinal) + "]")
		Exit Function

	end if

'Otherwise, expand every child
	lParentIndex = wTreeItemIndex(sTreeList, sNodeOrdinal)
	lNewIndex = lParentIndex

	For lCount = 1 to lNumOfChildren
		lNewIndex = lNewIndex + _
				lExpandEntireNode(sTreeList, _ord(lNewIndex + 1))

	Next lCount

	lExpandEntireNode = (lNewIndex - lParentIndex) + lNumOfchildren

	ExitSub ("lExpandEntireNode")

end Function 'lExpandEntireNode

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wListBoxItemClk_Ex
'
'	Makes sure the List Box item exists, then clks it
'
'	PARAMETERS
'		sListBox - Ordinal of List Box to use
'		sListItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wListItemClk_Ex(sListBox as string, sListItem as string, vButton=VK_LBUTTON as Variant)

	EnterSub ("b_wListItemClk_Ex [" + sListItem + "]")

'Make sure view list exists
	if wListExists(sListBox, MAX_WAIT) then
		
'Make sure item exists
		if wListItemExists(sListBox, sListItem, MAX_WAIT) then

'Select the item
			wListItemClk(sListBox, sListItem, vButton)
			b_wListItemClk_Ex = TRUE

		else

'View Item was not present in view list
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "List Box Item [" + sListItem + "] does not exist.")
			b_wListItemClk_Ex = FALSE

		end if

	else
'View list was not present on current dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "List Box [" + sListBox + "] does not exist.")
		b_wListItemClk_Ex = FALSE

	end if

	ExitSub ("b_wListItemClk_Ex")
		
end Function 'b_wListItemClk_Ex


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	CaptionSleep
'
'	Continues pausing until a dialog containing the specified caption appears.
'
'	PARAMETERS
'		sCaption - caption of expected window
'		lLostFocus - (FALSE by default), if set to true, waits for the specified caption to LOSE
'					focus rather than waiting for the caption acquire focus
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function CaptionSleep(sCaption as string, _
						lLostFocus=FALSE as Long) as Long
	Dim lCount as Long

	'----- assume success ------
	CaptionSleep = TRUE


	'----- see which version to do ------
	if lLostFocus = FALSE then
		Do While Instr(GetText(wGetactWnd()), sCaption) = FALSE
			sleep MIN_WAIT
			lCount = lCount + 1
			if lCount = 10 then
				LogIt(LVL_STATUSINFO, "CaptionSleep | Waited 10 times MIN_WAIT and expected dialog [" + _
						sCaption + "] did not appear.")
				CaptionSleep = FALSE
				exit do
			end if

		Loop

	Else 'lLostfocus = TRUE

		Do While Instr(GetText(wGetactWnd()), sCaption) = TRUE
			sleep MIN_WAIT
			lCount = lCount + 1
			if lCount = 10 then
				LogIt(LVL_STATUSINFO, "CaptionSleep | Waited 10 times MIN_WAIT and expected dialog [" + _
						sCaption + "] did not lose focus.")
				CaptionSleep = FALSE
				exit do
			end if

		Loop

	End If

	Sleep MIN_WAIT

End Function 'CaptionSleep


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	COUNT NUMBER OF VIEW ITEMS
'
'	Verifies that the given item is unique in the viewlist
'
'	PARAMETERS:
'		sViewList - identifier of the viewlist to check
'		sViewItem - text of the viewlist item to compare
'
'	RETURN VALUE:
'		Number of times the specified item appears in the specified
'		viewlist.  Returns Zero if the item does not exist.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function iViewItemInstances(sViewList as String, sViewItem as String) as Integer

	Dim lItemIndex as Long
	Dim lNumFound as Long

	EnterSub("iViewItemInstances [" + sViewItem +"]")

'Verify that the list exists
	if WViewExists(sViewList) = FALSE then
		
		iViewItemInstances = FALSE   'False = zero
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not locate view list [" + sViewList +"]")
		goto eXIT_fUNCTION

	end if

'Verify that the item exists in the list
	if WViewItemExists(sViewList, sViewItem) = FALSE then
		
		iViewItemInstances = FALSE   'False = zero
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not locate view item [" + sViewItem + "]")
		goto eXIT_fUNCTION

	end if

'Verify that the item is unique
	lNumFound = 0

'Go through each of the items in the view
	For lItemIndex = 1 to WViewCount(sViewList)
		
'Increment the found counter for each instance of the
		if ViewItemText(sViewList, "@" + Trim(Str(lItemIndex))) = sViewItem Then
			
			lNumFound = lNumFound + 1
		
		end if

'move onto the next item
	Next lItemIndex	

	iViewItemInstances = lNumFound

eXIT_fUNCTION:
	ExitSub("iViewItemInstances [Found " + str(lNumFound) + "] of [" + sViewItem +"]")
	
End Function 'iViewItemInstances

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenProperties
'
'	Uses the context menu to open the properties of an object in the 
'	context pane
'
'	ASSUMES
'		The object to be opened is a currently selectable item in the
'		content pane
'
'	PARAMETERS:
'		sViewList - identifier of the context pane
'		sViewItem - identifier of object to open the properties of
'
'	RETURN VALUE:
'		TRUE if properties page opens
'		FALSE if properties page does not open
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenProperties(sViewList as String, sViewItem as String) as Long

	EnterSub("bOpenProperties [" + sViewItem +"]")

'Click on object using the right mouse button...brings up context menu
	if b_wViewItemClk_Ex(sViewList, sViewItem, VK_RBUTTON) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not select object [" +  sViewItem + "] item in context pane.")
		bOpenProperties = FALSE

	endif

	Sleep (MIN_WAIT)

'Select properties from the menu
		if b_wMenuSelect_Ex(SM_STR_PROPERTIES) = FALSE then

			LogIt(LVL_STATUSINFO, "Could not select properties from menu.")
			bOpenProperties = FALSE

		endif

		Sleep (MIN_WAIT)

			CaptionSleep(CAP_PROPERTIES)

'Make sure the properties window is the active one
			if wFndWnd(sViewItem, FW_ALL OR FW_PART OR _
					FW_RESTORE OR FW_FOCUS, MAX_WAIT) = FALSE then

				LogIt(LVL_STATUSINFO, "Properties dialog failed to appear.")
				bOpenProperties = FALSE
				goto eXIT_fUNCTION

			end if


'Verify that a dialog appeared with 'Properties' in the caption
			if instr(GetText(wGetActWnd()), SM_STR_PROPERTIES) = FALSE then

				LogIt(LVL_STATUSINFO, "Properties dialog failed to appear.")
				bOpenProperties = FALSE

			else

				bOpenProperties = TRUE

			end if

	sleep MIN_WAIT


eXIT_fUNCTION:
	Sleep MIN_WAIT
	ExitSub("bOpenProperties")
	
End Function 'bOpenProperties


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCheckDescription
'
'	Alters the description field of the given object. Verifies new
'	description appears in context pane, then replaces prior text.
'
'	ASSUMES
'		The object to be opened is a currently selectable item in the
'		content pane, and that the properties dialog contains the
'		description field on the first tab item.
'
'	PARAMETERS:
'		sViewList - identifier of the context pane
'		sViewItem - identifier of object to open the properties of
'
'	RETURN VALUE:
'		TRUE if the description box works as expected
'		FALSE if otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCheckDescription(	sViewList as String, _
							sViewItem as String) as Long

	EnterSub("bCheckDescription [" + sViewItem +"]")

	Dim sOldDescription as String

'open properties page
	If bOpenProperties(sViewList, sViewItem) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Could not open properties page.")
		goto eXIT_fUNCTION

	end if

	Sleep(MIN_WAIT)

'Make sure the properties window is the active one
	wFndWnd(sViewItem, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS, MAX_WAIT)


'Verify tabs exist then goto the first tab
	if wTabExists(DEFAULT_ORDINAL) = FALSE then
		
		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "No tab control on current dialog.")
		goto eXIT_fUNCTION

	end if

	Sleep(MIN_WAIT)

'Goto the first tab
	if wTabItemExists(DEFAULT_ORDINAL, DEFAULT_ORDINAL) = FALSE then
		
		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "First tab item not an option in current dialog")
		goto eXIT_fUNCTION

	end if

	Sleep(MIN_WAIT)

	wTabItemClk(DEFAULT_ORDINAL, DEFAULT_ORDINAL)


'Make a note of the current description, then write new one
	sOldDescription = EditText( "+" + SM_STR_DESCRIPTION )

	Sleep(MIN_WAIT)

	if wEditEnabled( "+" + SM_STR_DESCRIPTION  ) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Description box not enabled.")
		goto eXIT_fUNCTION

	end if


	wEditSetText( "+" + SM_STR_DESCRIPTION , TEXT_TESTSTRING)

	Sleep(MIN_WAIT)

'return to MMC
	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "OK button not found on Properties dialog????")
		goto eXIT_fUNCTION
	
	end if

	CaptionSleep(CAP_CONSOLE1)


'Refresh the context pane so that the new description pops up
	if bRefreshContextPane() = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Refresh of context pane failed.  Can't verify change in description.")
		goto eXIT_fUNCTION

	end if


	Sleep(MIN_WAIT)

'Verify description in context list
	if ViewItemText(sViewList, sViewItem, "~" + SM_STR_DESCRIPTION) <> TEXT_TESTSTRING then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Description of item [" + ViewItemText(sViewList, sViewItem, "~" + SM_STR_DESCRIPTION) + _
				" does not match test string.")
		goto eXIT_fUNCTION

	end if
		
'Open properties page and replace old string
	If bOpenProperties(sViewList, sViewItem) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Could not open properties page to replace old description.")
		goto eXIT_fUNCTION

	end if


'Make sure the properties window is the active one
	wFndWnd(sViewItem, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS, MAX_WAIT)


'Verify tabs exist then goto the 'General' tab
	if wTabExists(DEFAULT_ORDINAL) = FALSE then
		
		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "No tab control on current dialog.")
		goto eXIT_fUNCTION

	end if

	Sleep(MIN_WAIT)

	'Goto the first tab
	if wTabItemExists(DEFAULT_ORDINAL, DEFAULT_ORDINAL) = FALSE then
		
		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "General Tab not an option in current dialog")
		goto eXIT_fUNCTION

	end if

	wTabItemClk(DEFAULT_ORDINAL, DEFAULT_ORDINAL)

'Replace the old text
	if wEditEnabled( "+" + SM_STR_DESCRIPTION ) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "Description box not enabled. Can't replace old text.")
		goto eXIT_fUNCTION

	end if

	wEditSetText( "+" + SM_STR_DESCRIPTION, sOldDescription)

	'return to MMC
	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		bCheckDescription = FALSE
		LogIt(LVL_STATUSINFO, "OK button not found on Properties dialog????")
		goto eXIT_fUNCTION
	
	end if

	CaptionSleep(CAP_CONSOLE1)
	bCheckDescription = TRUE



eXIT_fUNCTION:
	ExitSub("bCheckDescription")
	
End Function 'bCheckDescription


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bRefreshContextPane
'
'	Refreshes the context pane.
'
'	ASSUMES
'		Application is open and active
'
'	RETURN VALUE:
'		TRUE if refresh occured
'		FALSE if refresh sdid not occur
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bRefreshContextPane() as Long

	EnterSub("bRefreshContextPane")

'Click on object using the right mouse button...brings up context menu
	wTreeItemClk(DEFAULT_ORDINAL,NULL, VK_RBUTTON)

'Select properties from the menu
	if b_wMenuSelect_Ex(REFRESH_TIP) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not select refresh from menu.")
		bRefreshContextPane = FALSE

	else

		bRefreshContextPane = TRUE

	end if

	Sleep MIN_WAIT + MIN_WAIT


eXIT_fUNCTION:
	ExitSub("bRefreshContextPane")
	
End Function 'bRefreshContextPane

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	vBinToDec
'
'	Converts a string of binary 1's and zeroes to an integer
'
'	PARAMETERS
'		sBinNumber as String
'
'	RETURN VALUE:
'		Converted number
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function vBinToDec(sBinNumber as String) as Long

	Dim x, y as integer 'generic looping variable
	Dim vResult as Variant
	Dim vTempAdd as Variant
	Dim bCurrentPlace as Long

	vResult = 0

	For x = 0 to (len(sBinNumber) - 1)

		bCurrentPlace = val(mid(sBinNumber, len(sBinNumber) - x, 1))

		if bCurrentPlace  = 1 then

			vTempAdd = 1

'Visual test doesn't have an exponential function!?!?

			If x = 0 then
				vTempAdd = 1
			else
				for y = 1 to x

					vTempAdd = vTempAdd * (2)

				next y
			end if

			vResult = vResult + vTempAdd
		end if

	next x

	vBinToDec = vResult

eXIT_fUNCTION:
	
End Function 'vBinToDec

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wTabItemClk_Ex
'
'	Makes sure the Tab exists, then clicks on it
'
'	PARAMETERS
'		sTabControl - Ordinal of Tab list to use
'		sTabItem - text of Item to click
'		vButton - which button of mouse to use, (DEFAULT to left)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wTabItemClk_Ex(	sTabControl as string, _
							sTabItem as string, _
							vButton=VK_LBUTTON as Variant) as Integer

	EnterSub ("b_wTabItemClk_Ex [" + sTabItem + "]")

'Make sure tab control exists
	if wTabExists(sTabControl, MAX_WAIT) then

'Select the first item in the Tab
		wTabItemClk(sTabControl, "@1")
		
'Make sure item exists
		if wTabItemExists(sTabControl, sTabItem, MAX_WAIT) then
	

'Select the item
			wTabItemClk(sTabControl, sTabItem, vButton)
			b_wTabItemClk_Ex = TRUE

		else

'Specific tab was not present in tab control
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tab Item [" + sTabItem + "] not found.")
			b_wTabItemClk_Ex = FALSE

		end if

	else

'No tab control existed on the dialog
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Tab Control [" + sTabControl + "] does not exist.")
		b_wTabItemClk_Ex = FALSE

	end if
		
	ExitSub ("b_wTabItemClk_Ex")

end Function 'b_wTabItemClk_Ex

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_wCheckBoxCheck_Ex
'
'	Verifies that the check box exists then sets the state specified, (default = checked)
'
'	PARAMETERS
'		sControl - Ordinal or associated text of the check box
'		iChecked - VT value representing marked state
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_wCheckBoxCheck_Ex(	sControl as String, _
								iChecked=CHECKED as Integer) as Integer

	EnterSub ("b_wCheckBoxCheck_Ex [" + sControl + "]")

'Assume failure
	b_wCheckBoxCheck_Ex = FALSE


'Make sure check box exists
	if wCheckExists(sControl, MAX_WAIT) = FALSE then

		LogIt(LVL_STATUSINFO, "CheckBox[" + Str$(iChecked) + "] not found.")

'Set the specified marked state -----


	else
'Is the checkbox already marked correctly?	
		if wCheckState(sControl) = iChecked then

		elseif iChecked = CHECKED then

			wCheckCheck(sControl)

		else

			wCheckUNCheck(sControl)

		end if
		
		b_wCheckBoxcheck_Ex = TRUE

	end if
	
	
		
	ExitSub ("b_wCheckBoxCheck_Ex")

end Function 'b_wCheckBoxCheck_Ex


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bRenameObject
'
'	Uses the context menu to rename an object.
'
'	ASSUMES
'		The object to be renamed is a currently selectable item in the
'		content pane
'
'	PARAMETERS:
'		sViewList - identifier of the content pane
'		sViewItem - identifier of object to rename
'		sNewName - Name to change to
'
'	RETURN VALUE:
'		TRUE if rename goes through
'		FALSE if rename fails
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bRenameObject(	sViewList as String, _
						sViewItem as String, _
						sNewName as String) as Long

	EnterSub("bRenameObject - Object[" + sViewItem +"]:New Name[" + sNewName + "]")


	Dim sTempCap as String


'Assume some failure will happen.  Will reset if all hurdles are passed
	bRenameObject = FALSE


'Click on object using the right mouse button...brings up context menu
	if b_wViewItemClk_Ex(sViewList, sViewItem, VK_RBUTTON) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select object [" +  sViewItem + "] item in content pane.")

	else


		Sleep MIN_WAIT

'Select rename from the menu
		if b_wMenuSelect_Ex(MNU_RENAME_NO_HOTKEY) = FALSE then

			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select rename from context menu.")

		else

			sleep MIN_WAIT

'Old name should now be highlighted, type new name
			
			b_Play_Ex(sNewName)
			
			Sleep MIN_WAIT
			
			b_Play_Ex("{ENTER}")

			Sleep MIN_WAIT + MIN_WAIT

			b_wButtonClick_Ex(BTN_YES)

			Sleep(MIN_WAIT)

'Should return to MMC.  If an error occured a message box will appear.
			if instR(GetText(wGetActWnd()), CAP_MMC) = FALSE then


				'----- There is often a bug here where VT freezes,
				'hopefully this will fix the issue by ensurein focus on
				'error dialog -----
				wClkWnd(0, W_CENTER, 10, VK_RBUTTON)


				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "New name was invalid.")
				b_wButtonClick_Ex(BTN_OK)
				CaptionSleep(CAP_MMC)


'Verify that the change persisted.
			elseif b_wViewItemClk_Ex(sViewList, sNewName) = FALSE then

				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "New name did not persist after change.")

			else


'If here, then rename completed successfully
				bRenameObject = TRUE

			end if
			
		end if

	end if

	sleep MIN_WAIT


eXIT_fUNCTION:
	Sleep MIN_WAIT
	ExitSub("bRenameObject")
	
End Function 'bRenameObject

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bRefreshObject
'
'	Refreshes the specified object by selecting 'Refresh' from the context menu
'
'	ASSUMES
'		Object is visible in the scope pane
'
'	PARAMETERS
'		sObjectName - the Text describing the object, (ordinal should work as well)
'
'	RETURN VALUE:
'		TRUE if refresh occured
'		FALSE if refresh did not occur
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bRefreshObject(sObjectName as String) as Long

	EnterSub("bRefreshObject - [" + sObjectName + "]")



'Assume Failure will occur somewhere
	bRefreshObject = FALSE



'Click on object using the right mouse button...brings up context menu
	if b_wTreeItemClk_Ex(ORD_1, sObjectName, VK_RBUTTON) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not bring up the context menu.")

	end if


	Sleep MIN_WAIT


'select Refresh form the menu
	if b_wMenuSelect_Ex(MNU_REFRESH) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not select refresh from context menu.")


	else


'If here then all went as planned.  Refresh was selected from the context menu...
		bRefreshObject = TRUE

	end if

	sleep MIN_WAIT

	ExitSub("bRefreshObject")
	
End Function 'bRefreshObject


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_Play_Ex
'
'	Wrapper that records in the log whatever is being typed
'
'	ASSUMES
'		There is someplace with the focus to type to currently.
'
'	PARAMETERS
'		sText - text to type
'		bLog - if TRUE then the string being played is logged
'
'	RETURN VALUE:
'		TRUE if typed
'		FALSE if not typed, (though I don't currently know how to check this, really...)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_Play_Ex(sText as String, _
					bLog=TRUE as Long) as Long

	if bLog = TRUE then
		LogIt(LVL_DEBUGGING, "b_Play_Ex - [" + sText + "]")
	End If

	Play sText

	b_Play_Ex = TRUE

	
End Function 'b_Play_Ex


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	sStringGen
'
'	Creates random Strings to use
'
'	PARAMETERS
'		lLen - Legth of String to return

'		NOTE: All chars allowed by default
'		sDoNotInclude - List of Specific chars to not include no deliminator necessary
'		bAlpha - T/F specifying whether or not to use standard letters
'		bNumbers - T/F specifying whether or not to use numbers
'		bSpaces - T/F specifying whether or not to use numbers
'		bPunc - T/F specifying whether or not to use punctuation
'		bDblByte - T/F specifying whether or not to use double byte chars
'
'
'	RETURN VALUE:
'		Randomly generated string
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function sStringGen(lLen as Long, _
					sDoNotInclude="" as String, _
					bAlpha=TRUE as Long, _
					bNumbers=TRUE as Long, _
					bSpaces=TRUE as LONG, _
					bPunc=TRUE as Long, _
					bDblByte=TRUE as Long)


	Dim i as Long


		

	

	
End Function 'sStringGen
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\stringsUI_eng.inc ===
' File name:	strings.inc
' Project:		dssnap
'
' Purpose:     Contains Language dependent strings 
'              should be translated when test scripts are localized
'

'$IFNDEF _STRINGS_ENG_UI
'$DEFINE _STRINGS_ENG_UI

''$include	'dictionary.inc'

'***********************************************************************
'
'                    Microsoft Management Console strings
'
'***********************************************************************


const AD_SITES_AND_SERVICES = "AD Sites and Services"

    
'-----------------------------------------------------------------------
' MMC windows captions
'------------------------------------------------------------
const CAP_CONSOLE1				   = "Console1"
const CAP_MMC$						   = CAP_CONSOLE1
const CAP_MMC_FULL				   = "Microsoft Management Console" 
                                 
                            
const TREE_ROOT                  = "Console Root"
                            
const MSC_EXT						      = ".msc"
const CAP_FIRST_CHILD			    = "MMC1 - "+TREE_ROOT
const CAP_MMC_BRAND_NEW$		   = CAP_MMC + " - MMC1"
const CAP_MMC_BRAND_NEW_MAX	   = CAP_MMC + " - [" + CAP_FIRST_CHILD + "]"
const CAP_SAVECHANGES$			   = "Microsoft Management Console" 
const CHILD_FRAME_CAP$			   = "MMC"
const CAP_TIP_OF_THE_DAY		   = "Tip of the Day"
const CAP_OPEN_DLG$				   = "Open"
const CAP_SAVE_DLG$				   = "Save As"
const TXT_SAVE					   = "Save"

const ABOUT_BOX                  = "About Management Console"

const CAP_PROPERTIES				   = "Properties"


'-----------------------------------------------------------------------
'General push buttons titles
'-----------------------------------------------------------------------
const BTN_OPEN				= "&Open"      'Open console dialog
const BTN_SAVE				= "&Save"      ' Save As dialog
const BTN_OK				= "OK"
const BTN_CANCEL			= "Cancel"
const BTN_FINISH			= "Finish"
const BTN_CLOSE			= "Close"
const BTN_YES				= "&Yes"
const BTN_YES_TO_ALL		= "Yes to &All"
const BTN_NO				= "&No"

'-----------------------------------------------------------------------
'Accelerators
'-----------------------------------------------------------------------
const ACC_CONSOLE_NEW   = "^(n)"
const ACC_CONSOLE_OPEN  = "^(o)"
const ACC_CONSOLE_SAVE  = "^(s)"
const ACC_PRINT         = "^(p)"
const ACC_COPY          = "^(c)"
const ACC_PASTE         = "^(v)"



'-----------------------------------------------------------------------
'MMC command line switches
'-----------------------------------------------------------------------
const CMD_NO_SNAP_SAVE  = "/ns"
const CMD_HIDE_TOOLBAR  = "/t"
const CMD_HELP          = "/h"
const CMD_NO_SPLASH     = "/s"
const CMD_NO_TIPS       = "/tip"



'-----------------------------------------------------------------------
'Console Menu items
'-----------------------------------------------------------------------
'$ifndef NT51
	const MNU_TXT_FILE                     = "&Console"
'$else
	const MNU_TXT_FILE                     = "&File"
'$endif

const MNU_CONSOLE_CLOSE				      = "&Close"

'used for short form of the main menu
const MNU_TXT_FILE_NEW$       		   = "&New"+TAB+"Ctrl+N"
const MNU_TXT_FILE_OPEN$		         = "&Open..."+TAB+"Ctrl+O"
                                       
const MNU_TXT_FILE_SAVE				      = "Save"
const MNU_TXT_FILE_SAVE_CONSOLE_AS$    = "Save Console &As..."
const MNU_TXT_FILE_SNAP_IN_MANAGER$	   = "Add/Remove Snap-in..."
const MNU_TXT_FILE_NEW_NODE$		      = "Ne&w Node"
const MNU_TXT_FILE_PROPERTIES$         = "Propert&ies..."
const MNU_TXT_FILE_EXIT$			      = "Exit"

'View Menu items
'-----------------------------------------------------------------------
const MNU_TXT_VIEW					      = "&View"
const MNU_TXT_VIEW_SCOPE_PANE		      = "S&cope Pane"
const MNU_TXT_VIEW_STATUS_BAR		      = "&Status Bar"
const MNU_TXT_VIEW_TOOLBAR    	      = "&Toolbar"
const MNU_TXT_VIEW_DESCRIPT_BAR	      = "&Description Bar"
const MNU_TXT_VIEW_REFRESH 		      = "Re&fresh"
const MNU_TXT_VIEW_OPTIONS			      = "Toolbar &Options..."


'Window menu items
'-----------------------------------------------------------------------
const MNU_TXT_WINDOW					      = "&Window"
const MNU_TXT_WINDOW_NEW_WINDOW			= "&New Window"
const MNU_TXT_NEW_WINDOW_FROM_HERE		= "New Window from Here"
const MNU_TXT_WINDOW_CASCADE			   = "&Cascade"
const MNU_TXT_WINDOW_CASCADE_WO_RESIZE	= "Cascade &without resize"
const MNU_TXT_WINDOW_TILE_H				= "&Tile Horizontally"
const MNU_TXT_WINDOW_TILE_V				= "Tile &Vertically"
const MNU_TXT_WINDOW_ARRANGE_ICONS		= "Arrange &Icons"
const MNU_TXT_WINDOW_CLOSE_ALL			= "Close &All"
const MNU_TXT_FIRST_WND					   = "&1 "+ CAP_FIRST_CHILD

'Help menu items
'-----------------------------------------------------------------------
const MNU_TXT_HELP				         = "Help"
const MNU_TXT_HELP_TIP			         = "Ti&p of the Day..."
const MNU_TXT_HELP_TOPICS		         = "&Help Topics"
const MNU_TXT_HELP_WEB_TUTOR	         = "Web &Tutorial"
const MNU_TXT_HELP_MS_WEB		         = "Microsoft on the &Web"
const MNU_TXT_HELP_ABOUT               = "&About"
                                       
'About popup
'-----------------------------------------------------------------------
const MNU_TXT_HELP_ABOUT_MMC           = " Microsoft Management Console..."


'-----------------------------------------------------------------------
'MMC context menu items
'-----------------------------------------------------------------------
const MNU_DOCKING_VIEW$					= "&Docking view"
const MNU_SCOPE_PANE$					= "S&cope Pane"
const MNU_DESCR_BAR                 = "Description Bar"
const MNU_SNAP_IN_MANAGER				= "Add/Re&move Snap-in"
const MNU_PROPERTIES						= "P&roperties"
const MNU_SEND_TO							= "&Send To"
const MNU_CREATE_NEW						= "New"
const MNU_COPY							= "&Copy..."
const MNU_EXPLORE_FROM_HERE			= "&Explore from here"
const MNU_TASK								= "T&ask"
const MNU_SELECT_ALL						= "Select &All"
const MNU_PRINT							= "&Print"
const MNU_VIEW								= "&View"
const MNU_ARRANGE_ICONS					= "Arrange &Icons"
const MNU_LINEUP_ICONS					= "Lin&e up Icons"

const MNU_FOLDER							= "&Folder..."
const MNU_SHORTCUT						= "&Shortcut..."
const MNU_LINK_TO_WEB_ADDRESS			= "&Link to Web Address..."
const MNU_GENERAL_CONTROL				= "&General Control..."
const MNU_MONITORING_CONTROLS			= "&Monitoring Controls..."
const MNU_TASK_PAD_ITEM					= "&Task Pad item..."

const MNU_VIEW_LARGE						= "Lar&ge Icons"
const MNU_VIEW_SMALL						= "S&mall Icons"
const MNU_VIEW_LIST						= "&List"
const MNU_VIEW_DETAIL					= "&Detail"
const MNU_VIEW_WEB						= "&Web"

const MNU_ARRANE_ICONS					= "Arrange &Icons"
const MNU_ARRANGE_BY_NAME				= "&Name"
const MNU_ARRANGE_BY_TYPE				= "&Type"
const MNU_ARRANGE_BY_SIZE				= "&Size"
const MNU_ARRANGE_BY_DATE				= "&Date"

const MNU_AUTO_ARRANGE					= "&Auto Arrange"
const MNU_START							= "&Start"
const MNU_STOP								= "St&op"
const MNU_PAUSE							= "Pa&use"		
const MNU_RESUME							= "Resu&me"

'-----------------------------------------------------------------------
'Snap-in Manager dialog strings
'-----------------------------------------------------------------------

const SNAP_IN_MANAGER		         = "Add/Remove Snap-in"  'title
                                      
'tips                                 
const SM_STR_ADD					      = "Add"
const SM_STR_PROPERTIES			      = "Properties"
const SM_STR_DELETE				      = "Delete"
const SM_STR_TAB_STANDALONE	      = "Standalone"
const SM_STR_TAB_EXTENSIONS	      = "Extensions"
                                 
'static text                     
const SM_STR_STANDALONE_DESCR       = "Use this page to add or remove a standalone Snap-in from the console."
const SM_STR_EXTENSIONS_DESCR       = "Use this page to enable snap-in extensions. To add a particular extension select the checkbox next to it."
                                 
const SM_STR_STANDALONE_ADDEDTO     = "&Snap-ins added to:"
const SM_STR_DESCRIPTION		      = "Description"
const SM_STR_EXTENSIONS_BEEXTENDED  = "&Snap-ins that can be extended:"
const SM_STR_EXTENSIONS_AVAIL	      = "Available &Extensions:"

'buttons
const SM_STR_STANDALONE_ADD	      = "&Add..."
const SM_STR_STANDALONE_REMOVE      = "&Remove"
const SM_STR_STANDALONE_ABOUT	      = "A&bout..."
                                    
const SM_STR_EXTENSIONS_ABOUT       = "A&bout..."

'static text
const SM_STR_CURRENTLY_LOADED	      = "Currently Loaded Snap-ins:"


'-----------------------------------------------------------------------
'Add a Snap-in dialog strings
'-----------------------------------------------------------------------
const ADD_A_SNAP_IN						= "Add Standalone Snap-in"

const AS_STR_ADD_TO						= " to "

const AS_STR_CURRENTLY_AVAILABLE		= "Currently Available Snap-ins:"
const AS_STR_NAME							= "Name"

const AS_STR_PROPERTIES					= "Properties"
const AS_STR_ALL							= "Show All snap-ins"
const AS_STR_STAND_ALONE				= "Show Stand alone snap-ins"
const AS_STR_EXTENSION					= "Show Extension snap-ins"

const AS_STR_ADD_BENEATH				= "Add beneath "
const AS_STR_EXTEND						= "Extend all nodes of type ..."
const AS_STR_STANDALONE					= "Standalone"
const AS_STR_CURRENTLY_AVAILABLEK	= "Available Standalone Snap-ins:"
const AS_STR_SNAPIN_TYPE				= "Snap-in Type"

const AS_STR_DECRIPTION_CAP			= "Description"

'-----------------------------------------------------------------------
'Toolbar tips
'-----------------------------------------------------------------------
const NEW_TIP			= "Create a new console"
const OPEN_TIP			= "Open an existing console"
const SAVE_TIP			= "Save the current console"
const NEW_WND_TIP    = "New Window"
const HELP_TIP       = "About"

const FORWARD_TIP		= "Forward"
const BACK_TIP			= "Back"
const STOP_TIP			= "Stop"
const REFRESH_TIP		= "Refresh"
const RESELECT_TIP   = "BUGBUG: re-select node tip"

const ACTION_TIP     = "Action"	 

const CUT_TIP        = "Cut"
const COPY_TIP       = "Copy"
const PASTE_TIP      = "Paste"
const DELETE_TIP     = "Delete"
const PROP_TIP       = "Properties"
const VIEWS_TIP      = "View"

const SNAP_MGR_TIP   = "Add / Remove snap-ins"
const UP_LEVEL_TIP   = "Up one level"
const SCOPE_TIP      = "Show / Hide Scope"


'-----------------------------------------------------------------------
'result pane headers
'-----------------------------------------------------------------------

'MMC commonn result headers
const RP_STR_NAME                   = "Name"
const RP_STR_TYPE                   = "Type"
const RP_STR_DESCR                  = "Description"


'default name for new folder nodes in the scope pane tree
const TREE_STR_NEW_FOLDER_NODE      = "New Folder"


'***********************************************************************
'  country list names
'***********************************************************************

const COUNTRY_NAME_USA = "UNITED STATES"


const CAP_DELWIZ					= "Delegation of Control Wizard"
const CAP_DSA$						= "dsa" 

'Developer studio caption: in case that the debugger should be MSDEV
'-----------------------------------------------------------------------
const CAP_MSDEV					= "Microsoft Developer Studio"




'-----------------------------------------------------------------------
'General push buttons titles
'-----------------------------------------------------------------------
const BTN_NEXT				= "&Next >"
const BTN_BACK				= "< &Back" 
const BTN_APPLY				= "&Apply"
const BTN_BROWSE			= "&Browse..."  
const BTN_DELETE			= "&Delete"
const BTN_ADD				= "A&dd..."
const BTN_REMOVE			= "&Remove"
const BTN_FIND_NOW			= "F&ind now"  'Find in The Directory window
const BTN_EDIT				= "&Edit..."

const BTN_LOGON_TO			= "Log On &To..."   '*Paris
const BTN_LOGON_HOURS		= "&Logon Hours..."
							
const EDT_NO_TEXT			= ""
							
const BTN_CHANGE_MODE		= "&Change Mode"
							
const BTN_NEXT				= "&Next >"
const BTN_DELWIZ_FINISH		= "&Finish"
const BTN_DELWIZ_ADD		= "&Add..."




'***********************************************************************
'
'                    Directory service snapin strings
'
'***********************************************************************

'-----------------------------------------------------------------------
' DS snap-in node name as appear in the snap-in manager dialog 
const DS_SNAPIN						= "Active Directory Users and Computers"
const DSSITE_SNAPIN						= "Active Directory Sites and Services"
const DSTREE_SNAPIN					= "Active Directory Domains and Trusts"


' ...and in scope pane as default
'-----------------------------------------------------------------------
const DS_NODE_NAME		         = VT_WILDCARD + "Active Directory Users and Computers"
const DSSITE_NODE_NAME		         = VT_WILDCARD + "Active Directory Sites and Services"
const DSTREE_NODE_NAME				= VT_WILDCARD + "Active Directory Domains and Trusts"

'-----------------------------------------------------------------------
'DS snap-in result pane headers
'-----------------------------------------------------------------------
const RP_STR_NAME				= "Name"
const RP_STR_CLASS	            = "Type"
const RP_STR_DESCR		         = "Description"

const RP_STR_LOC					= "Location"
const RP_STR_FROMSERVER			= "From Server"
const RP_STR_FROMSITE			= "From Site"
const RP_STR_SITE				= "Site"
const RP_STR_DOMAIN				= "Domain"
const RP_STR_BRIDGEHEAD			= "Bridgehead"

'-----------------------------------------------------------------------
'DS standard objects names
'-----------------------------------------------------------------------

' builtin node names	  (these should NOT be localized, as they remain 
' English on all DC installations, regardless of the language of the 
' operating system installed on it

' users&computers specific nodes
const BUILTIN_NODE					= "Builtin"
const COMPUTERS_NODE				= "Computers"
const USERS_NODE					= "Users"
const SYSTEM_NODE					= "System"
const DOMAIN_CONTROLLERS_NODE		= "Domain Controllers"

' sites snapin specific nodes
const DEFAULT_FIRST_SITE_LINK		= "DEFAULTIPSITELINK"
const SUBNETS_NODE					= "Subnets"
const INTERSITE_TRANSPORTS_NODE		= "Inter-Site Transports"
const SITES_NODE					= "Sites"
const IP_NODE						= "IP"
const SMTP_NODE						= "SMTP"
const SERVERS_NODE					= "Servers"
const NTDSSETTINGS_NODE				= "NTDS Settings"

const SITE_SETTINGS					= "NTDS Site Settings"
const SITE_LICENSE					= "Licensing Site Settings"

const CONNECTION_AUTO				= "<automatically generated>"




'-----------------------------------------------------------------------
'DS object types displayed in result pane 
'-----------------------------------------------------------------------
const RES_TYPE_USER					= "User"
const RES_TYPE_GROUP				= "Group"
const RES_TYPE_OU					= "Organizational Unit"
const RES_TYPE_CONTAINER			= "container"
const RES_TYPE_BLT_DOMAIN			= "builtinDomain"
const RES_TYPE_PRINT_QUEUE			= "Printer"
const RES_TYPE_VOLUME   			= "Shared Folder"
const RES_TYPE_CONTACT  			= "Contact"

const RES_DESC_ADMIN				= "Built-in account for administering the computer/domain"
const RES_DESC_GUEST				= "Built-in account for guest access to the computer/domain"

const RES_TYPE_DOMAIN				= "Domain"

const RES_TYPE_SITES_CONTAINER		= "Sites Container"
const RES_TYPE_SITE					= "Site"
const RES_TYPE_INTERSITE_CONTAINER	= "Inter-Site Transports Container"	
const RES_TYPE_INTERSITE			= "Inter-Site Transport"
const RES_TYPE_SUBNETS_CONTAINER	= "Subnets Container"
const RES_TYPE_SUBNET				= "Subnet"
const RES_TYPE_SITELICENSE			= "Licensing Site Settings"
const RES_TYPE_SITESETTINGS			= "Site Settings"
const RES_TYPE_SERVER				= "Server"
const RES_TYPE_APPVER				= "applicationVersion"
const RES_TYPE_APPCFG				= "msDS-App-Configuration"
const RES_TYPE_SERVERLICENSE		= "Domain Controller Settings"
const RES_TYPE_CONNECTION			= "Connection"
const RES_TYPE_SITELINK				= "Site Link"
const RES_TYPE_SITELINKBRIDGE		= "Site Link Bridge"




'-----------------------------------------------------------------------
'DS snap-in context menu items 
'-----------------------------------------------------------------------

'DS objects menu items for common operations
'note: Move menu item change 2095, for older builds use MNU_MOVE_NO_HOTKEY
'const	MNU_MOVE				 = "M&ove..."
const MNU_MOVE					 = "Mo&ve..."
const MNU_MOVE_NO_HOTKEY	 = "Move..."
const MNU_REFRESH				 = "Re&fresh"
const MNU_RENAME				 = "Rena&me"
const MNU_RENAME_NO_HOTKEY		 = "Rename"
const MNU_FIND  				 = "F&ind..."
const MNU_DELETE				 = "&Delete"
const MNU_DELETE_NO_HOTKEY		 = "Delete"
const MNU_ADVANCED_FEATURES      = "Advanced Features"
const MNU_AS_CONTAINERS          = "Users, Groups, and Computers as containers"
const MNU_FILTER_OPTIONS         = "Filter Options..."

'New submenu:
const MNU_USER					= "User"
const MNU_USERS					= "Users"

const MNU_CONTACT 				= "Contact"

const MNU_GROUP					= "Group"
const MNU_GROUPS				= "Groups"

const MNU_OU					= "Organizational Unit"
const MNU_OUS					= "Organizational Units"

const MNU_VOLUME				= "Shared Folder"
const MNU_VOLUMES				= "Shared Folders"

const MNU_COMPUTER				= "Computer"
const MNU_COMPUTERS				= "Computers"

const MNU_PRINTQUEUE				= "Printer"
const MNU_PRINTERS				= "Printers"

const MNU_FOOBAR				= "fooBar"

const MNU_SITE					= "Site"
const MNU_SITE_LICENSE			= "Licensing Site Settings"
const MNU_SITE_SETTINGS				= "Site Settings"
const MNU_SITE_SERVERS				= "Servers Container"

const MNU_SERVER				= "Server"

const MNU_APPVER				= "applicationVersion"
const MNU_APPCFG				= "msDS-App-Configuration"

const MNU_CONNECTION				= "Connection"

const MNU_SITELINK				= "Site Link"
const MNU_SITELINKBRIDGE			= "Site Link Bridge"

const MNU_SUBNET				= "Subnet"


'user specific TASK
const MNU_RESET_PWD				= "Reset Password..."
const MNU_CHANGE_PWD			= "Change Password..."
const MNU_ENABLE_ACCOUNT        = "Enable Account"
const MNU_DISABLE_ACCOUNT       = "Disable Account"

'PARIS change should be effective circa 2048
const MNU_ADD_TO_GRP					= "Add members to a Group..."

'computer specific TASK
const MNU_RESET_ACCT					= "Reset Account"

const MNU_NAME_MAPPINGS					= "Name Mappings..."

'container specific action
const MNU_DELWIZ						="Delegate Control..."

'-----------------------------------------------------------------------
'Dialogs: captions 
'-----------------------------------------------------------------------

'captions for create new wizard
const CAP_CREATE_NEW				   = "New Object"

'captions for rename dialogs 

'(some objects open a dialog after the in-place renaming part)
const CAP_RENAME_USER				= "Rename User"
const CAP_RENAME_GROUP				= "Rename Group"
const CAP_RENAME_COMPUTER			= "Rename Computer"
const CAP_RENAME_CONTACT			= "Rename Contact"

const REN_ID_EDIT_PRE_W2K_NAME_PREFIX_HOTKEY	= "W"



'captions for error pop-ups
'NOTE: "dsadmin" should change to "Active Directory Service"
'		 after the IDS
'const CAP_ACTIVE_DIRECTORY_OLD   = "Active Directory"

const CAP_ACTIVE_DIRECTORY		   = "Active Directory"
const CAP_SECURITY					= "Security"

const CAP_ACTIVE_DIRECTORY_ERR   = CAP_ACTIVE_DIRECTORY
const CAP_DS_GROUP_MEMB_ERR	   = CAP_ACTIVE_DIRECTORY_ERR

const CAP_DS_PROP_ERR			   = CAP_ACTIVE_DIRECTORY_ERR

const MSG_CONFIRM_COV_TO_DIST_LIST = "You are converting a security group to a distribution group."
const MSG_CANT_CHANGE_LOC_TO_UNIV  = "A universal group cannot have a local group as a member"
const MSG_CANT_CHANGE_UNIV_TO_GLOB  = "A global group cannot have a universal group as a member"
const MSG_CANT_CHANGE_UNIV_TO_LOC  = "The requested operation can be performed only on a global catalog server"
const MSG_CANT_GET_ROOTDSE         = "Naming information could not be located" 'IDS_CANT_GET_ROOTDSE
const MSG_LOCAL_LOGIN_ERROR        = "If you want to manage users and groups on this workstation" 'IDS_LOCAL_LOGIN_ERROR

const MSG_SITE_CREATION_SUCCESSFUL = "has been created. To finish configuration of"
const MSG_SERVERS_CONTAINER_CREATION_SUCCESSFUL = "Object Servers has been successfully created."

const MSG_SITELINK_NOT_ENOUGH_SITES = "Active Directory Sites and Services cannot locate two sites to create a working site link object. You may create a new site link that links only one site, but it will have no effect until it links at least two sites."
const MSG_SITELINKBRIDGE_NOT_ENOUGH_LINKS = "Active Directory Sites and Services cannot locate two site link objects using the same transport as the site link bridge. You cannot create a site link bridge until there are at least two site links for this transport."

const CAP_CREATE_NEW_VOL         = "New Object - Shared Folder"
const CAP_CREATE_NEW_PRN         = "New Object - Printer"

const CAP_CREATE_NEW_USER       = "New Object - User"
const CAP_COPY_USER       = "Copy Object - User"

const CAP_CREATE_NEW_OBJECT		= "Create New Object"



'caption for error pop-up when the properties cannot be applied due to
'unavailable objects (when MSG_PROP_OBJ_NOT_FOUND)
const CAP_APPLY_PROP_ERROR       = "DS Property Display Error"

'Find/Browse dialogs captions
const CAP_FIND_IN_DIRECTORY		= "Find"

const CAP_BROWSE_FOLDER				= "Browse"

'Find: Custom Search (Filtering Options)
const CAP_FIND_CUSTOM				= "Find Custom Search"
const TAB_FILTER_ADVANCED			= "Advanced"

const FILTER_BTN_FIELD				= "Fie&ld"
const FILTER_EDT_VALUE				= "Val&ue:"

const USER_NAME_FIELD				= "User\Name"

'Find: DC Search (in dssite)
const CAP_FIND_DC					= "Find Domain Controllers"

'User Account page, Logon button captions
const CAP_LOGON_TO					= "Logon Workstations"
const CAP_LOGON_HOURS				= "Logon Hours for"

'Filter Options
const CAP_FILTER_OPTIONS			= "Filter Options"
const MSG_UNABLE_TO_DISPLAY		= "Unable to display all items"

'Change Forests
const CAP_CHANGE_FOREST				= "Choose Target Forest"

'Change Domains
const CAP_CHANGE_DOMAIN				= "Connect to Domain"

'Change DCs
const CAP_CHANGE_DC					= "Connect to Domain Controller"

'Change Schedule (for sites snapin)
const CAP_CHANGE_SCHEDULE			= "Schedule for"


const MAIN_TOOLBAR_HELP_HOTKEY		= "h"
const MNU_HELP_TOPICS_MENU_ITEM		= "Help Topics"
const AD_HELP_CHECKLISTS			= "Checklists"
const AD_HELP_NEW_WAYS				= "New ways to do familiar tasks"
const AD_HELP_BEST					= "Best practices"
const AD_HELP_HOW_TO				= "How To..."
const AD_HELP_CONCEPTS				= "Concepts"
const AD_HELP_TROUBLE				= "Troubleshooting"

'copy user

const ST_USER_COPY_FROM				= "Copy from:"

'-----------------------------------------------------------------------
'Dialogs: messages 
'-----------------------------------------------------------------------

'Confirm operation messages. I gave the different IDs so we can
'easily modify if the text is changed
const MSG_CONFIRM_DELETE_OBJ			= "Are you sure you want to delete this object?"
const MSG_CONFIRM_DELETE_USR			= MSG_CONFIRM_DELETE_OBJ
const MSG_CONFIRM_DELETE_GRP			= MSG_CONFIRM_DELETE_OBJ
const MSG_CONFIRM_DELETE_OU			= MSG_CONFIRM_DELETE_OBJ
const MSG_CONFIRM_DELETE_OBJ_MULTI	= "Are you sure you want to delete these"

const MSG_CONFIRM_DELETE_SINGLE_NON_EMPTY_OU = "is a container and contains other objects"
const MSG_CONFIRM_DELETE_MULTI_NON_EMPTY_OU  = "To cancel the operation, click Cancel"

const MSG_CHANGE_DC_FAILED				= "Failed"
const MSG_CHANGE_DOM						= "do you wish"

const MSG_ADD_TO_GROUP_COMPLETE		= "The Add to Group operation was successfully completed."
const MSG_ADD_TO_GROUP_FAILED		= "The Add to Group operation failed or was canceled by the user"
const MSG_ADD_TO_GROUP_EMPTY_OU     = "contains no user or contact objects"
'const MSG_ADD_TO_GROUP_EXISTS		= "The object already exists"  'that is, object is already a member of group
const MSG_ADD_TO_GROUP_SOME_NOT     = "The Add to Group operation was completed, but some items were not added"
const MSG_ADD_TO_GROUP_TWICE		= "already in the list"
const MSG_ADDTOGRP_MENU_ITEM_TWICE  = "cannot be added to group"
const MSG_ADD_TO_GROUP_TWICE_OU     = "cannot be added to"

const MSG_REMOVE_GRP_MEMBER			= "Do you want to remove"

const MSG_COMPUTER_TRUSTED_FOR_DELEGATION = "This option allows the computer to be trusted for delegation"
const MSG_USR_PROF_HOME_DIR_EXISTS	= "home directory was not created because it already exists"

'-----------------------------------------------------------------------
'Multi Valued Dialog 
'(invoked by pressing "Others..." button in several prop. pages)
'-----------------------------------------------------------------------
const CAP_MULTI_VALUED_TEL			= "Telephone Numbers"
const CAP_MULTI_VALUED_MAIL		= "E-Mail Addresses"
const CAP_MULTI_VALUED_WEB			= "Web Addresses (Home Page)"

const CAP_MULTI_VALUED_PAGER		= "Pager Numbers"
const CAP_MULTI_VALUED_MOBILE		= "Mobile/Cellular Numbers"
const CAP_MULTI_VALUED_FAX			= "Facsimile Machine Numbers"



'-----------------------------------------------------------------------
'* *
'* *                       PROPERTY PAGES
'* *
'-----------------------------------------------------------------------


'-----------------------------------------------------------------------
'*** Shared Property Page Strings
'                 shared by more than one class of objects
'-----------------------------------------------------------------------
'TAB tiles
const SP_GENERAL_TAB		= "General"
const SP_SECURITY_TAB		= "Security"
const SP_OBJECT_TAB			= "Object"

const SP_GENERAL_EDT_Description		= "&Description:"
const SP_OBJECT_EDT_FQDN				= "&Fully qualified domain name of object:"

'-----------------------------------------------------------------------
'Shared page - Address
'-----------------------------------------------------------------------

'Hot Keys
const UP_ID_EDT_POBox_HOTKEY    = "b"
const UP_ID_EDT_City_HOTKEY     = "c"
const UP_ID_EDT_State_HOTKEY    = "v"
const UP_ID_EDT_Zip_HOTKEY      = "z"
const UP_ID_CMB_Country_HOTKEY  = "o"
const UP_ID_EDT_Street_HOTKEY   = "s"


'-----------------------------------------------------------------------
'Shared page - Telephones
'-----------------------------------------------------------------------

const UP_ID_EDT_Home_HOTKEY	 = "m"
const UP_ID_EDT_Pager_HOTKEY	 = "p"
const UP_ID_EDT_Mobile_HOTKEY	 = "b"
const UP_ID_EDT_Fax_HOTKEY		 = "f"
const UP_ID_EDT_IP_HOTKEY		 = "i"
const UP_ID_EDT_Notes_HOTKEY	 = "n"


const UP_ID_EDT_Home_Other_HOTKEY	 = "o"
const UP_ID_EDT_Pager_Other_HOTKEY	 = "t"
const UP_ID_EDT_Mobile_Other_HOTKEY	 = "h"
const UP_ID_EDT_Fax_Other_HOTKEY	    = "e"
const UP_ID_EDT_IP_Other_HOTKEY		 = "r"

'-----------------------------------------------------------------------
'Shared page - Membership
'-----------------------------------------------------------------------
const SP_SET_PRIMARY			= "Set Primary Group"
const SP_ID_BTN_Add_HOTKEY		= "d"
const SP_ID_BTN_Remove_HOTKEY	= "r"

'-----------------------------------------------------------------------
'Shared page - Managed By
'-----------------------------------------------------------------------
const SMP_CHANGE_BTN			   = "C&hange..."
'const SMP_VIEW_BTN				= "&View"  change in whistler beta2 2401
const SMP_VIEW_BTN				= "&Properties"
const SMP_CLEAR_BTN				= "Cl&ear"				'*Paris


const SMP_EDT_Name				= "&Name:"
const SMP_EDT_Office			   = "&Office:"
const SMP_EDT_Street			   = "&Street:"
const SMP_EDT_City				= "&City:"
const SMP_EDT_State  			= "State/p&rovince:"	  '*Paris
const SMP_EDT_Country			= "Co&untry/region:"	  '*Paris
const SMP_EDT_Phone				= "&Telephone number:"	  '*Paris
const SMP_EDT_Fax    			= "&Fax number:"		  '*Paris

'hot keys on Managed By page
const SMP_ID_EDT_Office_HOTKEY	   = "o"
const SMP_ID_EDT_Street_HOTKEY	   = "s"
const SMP_ID_EDT_City_HOTKEY	      = "c"
const SMP_ID_EDT_State_HOTKEY	      = "r"
const SMP_ID_EDT_Country_HOTKEY	   = "u"
const SMP_ID_EDT_Phone_HOTKEY	      = "t"
const SMP_ID_EDT_Fax_HOTKEY		   = "f"
const SMP_ID_EDT_Name_HOTKEY	      = "n"
const SMP_CHANGE_BTN_HOTKEY	      = "h"
'const SMP_VIEW_BTN_HOTKEY		      = "v"  change in whistler beta2 2401
const SMP_VIEW_BTN_HOTKEY		      = "p"
const SMP_CLEAR_BTN_HOTKEY		      = "e"



'-----------------------------------------------------------------------
'**** USER Property Page Strings
'-----------------------------------------------------------------------

'-----------------------------------------------------------------------
'User class - General page
'-----------------------------------------------------------------------
const UGP_FIRST_NAME				= "&First name:"
const UGP_LAST_NAME					= "&Last name:"
const UGP_INITIALS					= "&Initials:"
const UGP_DISPLAY_NAME				= "Di&splay name:"
const UGP_DESCRIPTION				= "&Description:"
const UGP_OFFICE					= "Offi&ce:"
const UGP_FRIENDLY_NAME				= "Friendly &name:"
const UGP_TELEPHONE					= "&Telephone number:" '*Paris
const UGP_EMAIL						= "E-&mail:"
const UGP_WEBPAGE					= "&Web page:"

const UP_OTHER_TEL					= "Phone Number"

const CONT_OTHER_TEL				= "Phone Number"

const UP_OTHER_EMAIL				= "E-Mail Address"
const UP_OTHER_WEB					= "Web Page Address"

const UP_BTN_OTHER_TELEPHONE		= "&Other..."
const UP_BTN_OTHER_HOMEPAGE			= "Othe&r..."


const UP_ID_EDT_Firstname_HOTKEY	= "f"
const UP_ID_EDT_Initials_HOTKEY		= "i"
const UP_ID_EDT_Lastname_HOTKEY		= "l"
const UP_ID_EDT_DisplayName_HOTKEY	= "s"
const UP_ID_EDT_Description_HOTKEY	= "d"
const UP_ID_EDT_Office_HOTKEY		= "c"
const UP_ID_EDT_Telephone_HOTKEY	= "t"
const UP_ID_EDT_Email_HOTKEY		= "m"
const UP_ID_EDT_Webpage_HOTKEY		= "w"

const UP_ID_BTN_Other_Tel_HOTKEY	= "o"
const UP_ID_BTN_Other_Web_HOTKEY	= "r"


'-----------------------------------------------------------------------
'User Property Page Strings
'-----------------------------------------------------------------------

'TAB title
const UP_GENERAL_TAB				= SP_GENERAL_TAB

'other strings
const UP_ADDRESS_TAB				= "Address"
const UP_TEL_NOTES_TAB				= "Telephones"	'*Paris
const UP_ORGANIZATION_TAB			= "Organization"
const UP_ACCOUNT_TAB				= "Account"
const UP_PROFILE_TAB				= "Profile"
const UP_MEMBEROF_TAB				= "Member Of"
const UP_DIALIN_TAB					= "Dial-in"


'-----------------------------------------------------------------------
'User - Organization page
'-----------------------------------------------------------------------
const UOP_CHANGE_MGR_BTN			= "Change..."
const UOP_MGR_PROP_BTN				= "&Manager..."
'const UOP_VIEW_MGR_BTN				= "&View"		'*Paris
const UOP_VIEW_MGR_BTN				= "&Properties"	' changed in 2264.01 vbl03 from above...?
const UOP_CLEAR_MGR_BTN				= "C&lear"
const UOP_EDT_TITLE					= "&Title:"
const UOP_EDT_DEPT					= "&Department:"
const UOP_EDT_CO					= "&Company:"
const UOP_EDT_NAME					= "&Name:"
const UOP_EDT_DIRECT				= "Direct &reports:"

'hotkeys

const UP_ID_EDT_Department_HOTKEY	 = "d"
const UP_ID_EDT_Company_HOTKEY		 = "c"
const UP_ID_EDT_Manager_Name_HOTKEY	 = "n"
const UP_ID_EDT_Title_HOTKEY		 = "t"	
const UP_ID_EDT_DirReports_HOTKEY	 = "e"

const UOP_CHANGE_MGR_BTN_HOTKEY		 = "h"


'-----------------------------------------------------------------------
'User - Profile page
'-----------------------------------------------------------------------

'hotkeys

const UP_ID_EDT_LOGON_SCRIPT_HOTKEY	 = "s"
const UP_ID_EDT_TO_HOTKEY			 = "t"
const UP_ID_EDT_PROFILE_PATH_HOTKEY	 = "p"

const UP_ID_RBTN_LOCAL_PATH_HOTKEY	 = "l"
const UP_ID_RBTN_CONNECT_HOTKEY		 = "c"


'-----------------------------------------------------------------------
'User - Dialin page
'-----------------------------------------------------------------------
const UP_DIAL_PAGE_GRANT			= "Grant Dialin Permission"
const UP_DIAL_PAGE_NO_CALL			= "No Call Back"
const UP_DIAL_PAGE_SET_BY			= "Set by caller"
const UP_DIAL_PAGE_PRESET			= "Preset to:"


'-----------------------------------------------------------------------
'User - Account page
'-----------------------------------------------------------------------
const UP_ACCOUNT_PAGE_MUST			= "User &must change password at next logon"
const UP_ACCOUNT_PAGE_NEVER		= "Password &never expires"
const UP_ACCOUNT_PAGE_DISABLED	= "Account &disabled"
const UP_ACCOUNT_PAGE_LOCKOUT		= "Account locked &out"

'hotkeys:
const UP_ID_EDT_NT5_PREFIX_HOTKEY	= "u"
const UP_ID_EDT_NT4_PREFIX_HOTKEY	= "w"

const BTN_LOGON_TO_HOTKEY			   = "t"
const BTN_LOGON_HOURS_HOTKEY		   = "l"

const UP_ID_RBTN_NEVER_HOTKEY		   = "v"
const UP_ID_RBTN_END_OF_HOTKEY		= "E"

const UP_ACCOUNT_OPTIONS_HOTKEY		= "o"

'-----------------------------------------------------------------------
'User - Telephone/Notes page
'-----------------------------------------------------------------------
const UP_OTHER_HOME					= "Home Phone"
const UP_OTHER_PAGER				   = "Pager Number"
const UP_OTHER_MOBILE				= "Mobile Number"
const UP_OTHER_FAX					= "Fax Number"
const UP_OTHER_IP					   = "IP Phone Number"

const BTN_OTHER_HOME					= "&Other..."
const BTN_OTHER_PAGER				= "O&ther..."
const BTN_OTHER_MOBILE				= "Ot&her..."
const BTN_OTHER_FAX					= "Oth&er..."
const BTN_OTHER_IP					= "Othe&r..."

const MV_BTN_ADD					   = "&Add"
const MV_BTN_EDIT					   = "&Edit"
const MV_BTN_REMOVE					= "&Remove"
const MV_BTN_OK						= "OK"		'*Paris
const MV_BTN_CANCEL					= "Cancel"

'-----------------------------------------------------------------------
'**** CONTACT Property Page Strings
'-----------------------------------------------------------------------

'-----------------------------------------------------------------------
'Contact - General page
'-----------------------------------------------------------------------
const CONT_OTHER_TEL					= "Phone Number"
const CONT_OTHER_WEB					= "Web Page Address"

'-----------------------------------------------------------------------
'**** Group Property Page Strings
'-----------------------------------------------------------------------

'TAB titles
const GP_GENERAL_TAB				= SP_GENERAL_TAB
const GP_MEMBERS_TAB			   	= "Members"
const GP_MEMBEROF_TAB				= "Member Of"
const GP_MANAGEDBY_TAB				= "Managed By"


'hotkeys - Group: General page

const GPG_ID_EDT_Downlevel_HOTKEY	   = "w"
const GPG_ID_EDT_Email_HOTKEY		   = "m"
const GPG_ID_EDT_Notes_HOTKEY		   = "n"
const GPG_ID_EDT_Description_HOTKEY	   = "e"

const GPG_ID_BTN_SECURITY_HOTKEY	   = "s"
const GPG_ID_BTN_GLOBAL_HOTKEY		   = "g"

const MSG_UGSE_ADD_MEM_FROM_MIXED	   = "The following objects that you selected for universal group membership are from a mixed-mode domain"
const MSG_PRIMARY_GROUP_CANNOT_REMOVE  = "The primary group cannot be removed"

'hotkeys - Group: Members page
const GPM_ID_BTN_Add_HOTKEY		= "d"
const GPM_ID_BTN_Remove_HOTKEY		= "r"

'-----------------------------------------------------------------------
'Volume Property Page Strings
'-----------------------------------------------------------------------
const VP_KEYWORDS_STR				= "Keywords"

const VP_BTN_KEYWORDS				= "&Keywords..."
const VP_BTN_BROWSE					= "&Browse..."

'hotkeys on Volume: General page
const VP_ID_EDT_UNCName_HOTKEY		= "u"
const VP_ID_EDT_Description_HOTKEY	= "d"
const VP_BTN_KEYWORDS_HOTKEY		= "k"

'------------------------------------------------------------------------------
'**** Organizational Units Properties
'------------------------------------------------------------------------------
const TAB_OU_GENERAL             = SP_GENERAL_TAB



'------------------------------------------------------------------------------
'**** Computer Property strings
'------------------------------------------------------------------------------
const CP_GENERAL_TAB       = SP_GENERAL_TAB
const CP_OPERATING_SYS     = "Operating System"

const WORKSTATION_ROLE 		= "WORKSTATION_ROLE"
const DOM_CTRL_ROLE    		= "DOM_CTRL_ROLE"
const ROLE_WKS_EDT			= "Workstation or server" '*Paris UI scrub - capitalization change
const	ROLE_DC_EDT				= "Domain controller" '*Paris UI scrub - capitalization change

'part of message for totally invalid computer names (contains <space> for example)
const MSG_COMP_NAME_NOT_VALID	= "not a valid computer name"

'part of message for computer names which are not strictly DNS compliant, 
'but "MS DNS" compliant (contains extended char for example)
const MSG_COMP_NAME_NOT_STD		= "ability to interoperate with other computers"

'part of special case message for computer names which contain a dot (.)
const MSG_COMP_NAME_DOT			= "contains a period"

'hot keys on General page
const CP_ID_EDT_DNS_HOTKEY			= "n"	
const CP_ID_EDT_Downlevel_HOTKEY	= "w"
const CP_ID_EDT_Role_HOTKEY			= "r"
const CP_ID_EDT_Description_HOTKEY	= "d"
const CP_ID_CHK_TrustedForDelegation_HOTKEY	= "m"

'hot keys on Operating System page
const CP_ID_EDT_opsysVersion_HOTKEY = "e" 
const CP_ID_EDT_opsysSerPack_HOTKEY = "s" 
const CP_ID_EDT_opsysName_HOTKEY	= "m"

'------------------------------------------------------------------------------
'**** Domain Property strings
'------------------------------------------------------------------------------
' Domain properties: General Page
const DP_ID_EDT_Description_HOTKEY	= "d"
const DP_ID_BTN_ChangeMode_HOTKEY	= "c"
                              

'************** Filtering Options types *******************
const FILTER_USERS					= "Users" 
const FILTER_GROUPS					= "Groups" 
const FILTER_CONTACTS				= "Contacts" 
const FILTER_COMPUTERS				= "Computers" 
const FILTER_PRINTERS				= "Printers" 
const FILTER_VOLUMES				= "Shared Folders" 	  '*Paris
const FILTER_SERVICES				= "Services" 

'************ Domain and Active Directory context menu items *****
const MNU_CHANGE_FOREST				= "Connect to Forest..."
const MNU_CHANGE_DOMAIN				= "Connect to Domain..."
const MNU_CHANGE_DC					= "Connect to Domain Controller..."

'************ Domain Other *********************************
const DOM_GEN_PAGE_MIXED			= "Mixed mode (supports both Windows 2000 and pre-Windows 2000 domain controllers)" '*Paris
const DOM_GEN_PAGE_NATIVE			= "Native mode (no pre-Windows 2000 domain controllers)."						 '*Paris



'-----------------------------------------------------------------------
'* *
'* *                       CREATE NEW WIZARDS
'* *
'-----------------------------------------------------------------------


'-----------------------------------------------------------------------
'*** Create New: Group 
'-----------------------------------------------------------------------
const GP_TYPE_SECURITY				= "&Security"
const GP_TYPE_DISTRIBUTION			= "Distri&bution"
const GP_TYPE_COL_SEC				= "Security Group"
const GP_TYPE_COL_DIST				= "Distribution Group"

const GP_SCOPE_DOMAIN_LOCAL		    = "D&omain local"
const GP_SCOPE_GLOBAL				= "&Global"
const GP_SCOPE_UNIVERSAL			= "&Universal"
const GP_TYPE_COL_DOMAIN_LOCAL		= "Domain Local"
const GP_TYPE_COL_GLOBAL			= "Global"
const GP_TYPE_COL_UNIVERSAL			= "Universal"

const GP_TYPE_DISTRIBUTION_WHISTLER	= "&Distribution"

'-----------------------------------------------------------------------
'* *
'* *                          TASKS
'* *
'-----------------------------------------------------------------------

'-----------------------------------------------------------------------
'*** Tasks: Group 
'-----------------------------------------------------------------------

'group membership
const CAP_REMOVE_GROUP_MEMBER	   = "Remove Group Member"
const CAP_REMOVE_USER_GROUP	   = "Remove user from group"

const CAP_ADD_TWICE					= "already in the list"


'-----------------------------------------------------------------------
'*** Tasks: User
'-----------------------------------------------------------------------

'Manipulating Password Dialogs
const CAP_RESET_PWD					=	"Reset Password"
const CAP_CHANGE_PWD					=	"Change Password"

'Reset Password messages
const RP_MSG_MISSMATCH	         =	"The New and Confirm passwords must match."
const RP_MSG_MATCH		         =	"has been changed."

'Enable/Disable account messages
const MSG_ACCOUNT_ENABLED        =	"has been enabled."
const MSG_ACCOUNT_DISABLED       =	"has been disabled."

'check Email address error message
const MSG_EMAIL_ERROR			= "The e-mail address is not valid."

const CAP_SEC_ID_MAP				= "Security Identity Mapping"
const CAP_ADD_CERT					= "Add Certificate"
const CAP_CERT_PROP					= "Certificate Properties"
const CAP_EDIT_CERT_ATTR			= "Edit Certificate Attribute"
const CAP_ADD_KERB_PRIN_NAME		= "Add Kerberos Principal Name"
const CAP_EDIT_KERB_PRIN_NAME		= "Edit Kerberos Principal Name"


'-----------------------------------------------------------------------
'*** Tasks: Computer
'-----------------------------------------------------------------------

'Manipulating reset account Dialogs

const CAP_RESET_ACCT_ARE_YOU_SURE	= "Are you sure you want to reset this computer account?"
const CAP_RESET_ACCT_HEAD			= "Account "
const CAP_RESET_ACCT_TAIL			= " was successfully reset."


'-----------------------------------------------------------------------
'*** Tasks: General
'-----------------------------------------------------------------------

'General task: Move
const CAP_MOVE_TO					= "Move"     'partial caption only
                                 
'move objects error messages
const ERR_MSG_MOVE_FAILED			= "The object could not be moved."											   
const ERR_MSG_MOVE_PATH_NOT_FOUND	= "The selected destination object could not be found."

const CAP_FILTER_NOT_ERR			= "did not specify"

'-----------------------------------------------------------------------
'*** Tasks: Find and Pick
'-----------------------------------------------------------------------

'Find and Browse the directory constants
const DIRECTORY_ROOT					= "Entire Directory\"
const END_OF_ROOT						= "\"

'because this is an owner draw list, the selection takes place by ordinals
'correct the values if the order is changed
const USR_AND_GRP_ID					= "@1"
const COMPUTERS_ID					= "@2"
const PRINTERS_ID						= "@3"
const SHARED_FILE_FOLD_ID			= "@4"
const DIRECORY_FOLD_ID				= "@5"
const OBJECTS_ID						= "@6"
const CUSTOM_ID						= "@7"

'Object Selection Dialog (OBJECT PICKER)
const CAP_OBJECT_PICKER				= "Select" 'partial caption
const CAP_OPICK_SELECT_MATCH		= "Select Matching" 'partial caption
const CAP_OPICK_CREDENTIALS			= "Enter Network Password"
const OBJPKR_BTN_ADD				= "&Add"
const CAP_OPICK_NAME_NOT_FOUND		= "Name Not Found"
const BTN_LOOK_FOR					= "Look &For..."
const CAP_LOOK_FOR					= "Look For"

'************ default Description strings **************************************
const UserContainerDefaultDescription = "Default container for upgraded user accounts"
const SystemContainerDefaultDescription = "Builtin system settings"
const ComputersContainerDefaultDescription = "Default container for upgraded computer accounts"

'*******************************************************************************
'
'              ACLS editor strings
'
'*******************************************************************************

'------------------------------------------------------------------------
'Well known SIDs
'------------------------------------------------------------------------
const WKSP_SELF				= "SELF"
const WKSP_EVERYONE			= "Everyone"
const WKSP_CREA_OWNER		= "CREATOR OWNER"
const WKSP_CREA_GROUP		= "CREATOR GROUP"
const WKSP_DIALUP			= "DIALUP"
const WKSP_PRIN_SELF		= "Principal Self"
const WKSP_AUTH_USER		= "Authenticated Users"
const WKSP_REST_CODE		= "RESTRICTED"
const WKSP_SYSTEM			= "SYSTEM"
const WKSP_NETWORK			= "NETWORK"
const WKSP_PROXY			= "PROXY"
const WKSP_INTERACTIVE		= "INTERACTIVE"
const WKSP_BATCH			= "BATCH"
const WKSP_SERVICE			= "SERVICE"

const WKSP_ENT_DOM_CONTROL	= "ENTERPRISE DOMAIN CONTROLLERS"

'------------------------------------------------------------------------
' DelWiz pages strings
'------------------------------------------------------------------------
const DELWIZ_OBJ_SEL_PG_THIS_CONTAINER		= "Delegate control on &this container"
const DELWIZ_OBJ_SEL_PG_OBJ_TYPE			= "Delegate control on &following types of objects in this container"

'const DELWIZ_PERM_PG_ACC_LIST_TXT			= "&Access to Delegate:"
const DELWIZ_PERM_PG_ACC_LIST_TXT			= "P&ermissions:"
const DELWIZ_PERM_PG_GENERAL_RIGHTS			= "Show &general rights"
const DELWIZ_PERM_PG_PROP_RIGHTS			= "Show &property rights"
const DELWIZ_PERM_PG_SUBOBJ_RIGHTS			= "Show &creation/deletion of subobject rights"

const DELWIZ_FINISH_PG_ACES_LIST			= "The following users / groups / computers:"
const DELWIZ_FINISH_PG_PERM_LIST			= "The following users / groups / computers:"
const DELWIZ_FINISH_PG_OBJ_LIST				= "on the following object types:"

const DEL_FOLLOWING_TASKS					= "&Delegate the following common tasks:"
const CREATE_CUSTOM_TASK_TO_DEL				= "&Create a custom task to delegate"
const FULL_CONTROL							= "Full Control"
const SELECT_MATCH							= "Select Matching"
const STR_OBJECT							= "Object"
'********** Strings 

'Templates (should move these to strings.eng when done debugging)

const TMPLT1_MANAGE_USER			= "Create, delete, and manage user accounts"
const TMPLT2_RESET_PWD				= "Reset passwords on user accounts"
const TMPLT3_READ_USER				= "Read all user information"
const TMPLT4_GRP_MEM				= "Modify the membership of a group"
const TMPLT5_JOIN_COMP				= "Join a computer to the domain"
const TMPLT6_MANAGE_PRN				= "Manage printers"
const TMPLT7_CREATE_DEL_PRN			= "Create and delete printers"
const TMPLT8_MANAGE_GPO				= "Manage Group Policy links"
const TMPLT9_CREATE_DEL_GRP			= "Create, delete and manage groups"

'Object Types page
const ENTIRE_FOLDER					= "&This folder, existing objects in this folder, and creation of new objects in this folder"
const OBJECTS_IN_FOLDER				= "&Only the following objects in the folder:"

const SCHEMA_DEFAULT_PERM			= "schema default permissions will be added"

const DW_STAT_WELCOME_PAGE			= "Welcome to the Delegation of Control Wizard"
const DW_STAT_FOLDER_PAGE			= "Name of the folder for which you want to delegate control:"
const DW_STAT_SEL_OBJ_PAGE			= "&Selected users and groups:"
const DW_STAT_OBJ_TYPE_PAGE			= "Delegate control of"
const DW_STAT_PERMISSION_PAGE		= "Show these permissions:"
const DW_STAT_FINISH_PAGE_CUSTOM	= "Completing the Delegation of Control Wizard"
										
const DW_CHK_BOX_OBJ_TYPE			= "In&clude both default and specified permissions for the selected object types"
const DW_CHK_BOX_PERM_GEN			= "&General"
const DW_CHK_BOX_PERM_PROP			= "&Property-specific"
const DW_CHK_BOX_PERM_CREATE		= "&Creation/deletion of specific child objects"

'----------------------------------------------------------------------------------
'strings on Security TAB
'----------------------------------------------------------------------------------
const CHK_AUDITING_FROM_PARENT	 = "&Inherit from parent the auditing entries that apply to child objects. Include these with entries explicitly defined here"
const CHK_INHERIT_FROM_PARENT    = "&Inherit from parent the permission entries that apply to child objects. Include these with entries explicitly defined here"
const CAP_ADD_USR_AND_GRP        = "Add User" 'caption is partial only because
                                              'it appears slighty different
                                              'when opened from security and ACE page
const BTN_ADVANCED               = "Ad&vanced"
const BTN_DEFAULT				= "De&fault"
const BTN_SELECT				= "Select..."
'---------------------------------------------------------------------------------
'caption for error pop-up when apply changes
'---------------------------------------------------------------------------------
const CAP_ERROR                  = "Error"
const CAP_SECURITY_ERR           = "Security"

'---------------------------------------------------------------------------------
'confirmation messages
'-----------------------------------------------------------------------------------
const MSG_CONVERT_INH_ENTRIES_CONFIRM   = "You are preventing any inheritable permissions from propagating to this object.  What do you want to do?"
'partinal string
const DENY_ALL_CONFIRM              = "Caution! Deny entries " 'partial string
'-----------------------------------------------------------------------------------
'BTN's in the CONVERT_INH_ENTRIES_CONFIRM confirmation dialog box
'-----------------------------------------------------------------------------------
const BTN_COPY_INHR_ACE				="Copy"
const BTN_REMOVE_INHR_ACE			="Remove"
const BTN_CLEAR_ALL					= "C&lear All"
const CONVERT_INH_ENTRIES_CONFIRM	= "You are preventing any inheritable permissions from propagating to this object."

'----------------------------------------------------------------------------------
'strings on ACE dialog (2nd page; via Sec tab / Advanced)
'----------------------------------------------------------------------------------
const CAP_ACE_SETT_PAGE						=	"Access Control Settings"
const CAP_ACE_ADV_SEC_SETT					=	"Advanced Security Settings for "
'TABs in ACE page
const ACE_TAB_PERMISSIONS					=	"Permissions"
const ACE_TAB_AUDITING						=	"Auditing"
const ACE_TAB_OWNER							=	"Owner"
const ACE_TAB_EFFECTIVE						=	"Effective Permissions"
'--------------------------------------------------------------------------
const CHKBX_CREATE_OBJ_IN_THIS_FOLDER		=	"Create selected Objects in this folder"
const CHKBX_DELETE_OBJ_IN_THIS_FOLDER		=	"Delete selected objects in this folder"
' Objects------------------------------------------------------------------
'--------------------------------------------------------------------------
const THIS_OBJ_ONLY							=	"This object only"
const THIS_OBJ_AND_SUBOBJ					=	"This object and all child objects"
const SUBOBJ_ONLY							=	"Child objects only"
const COMPUTER_OBJ							=	"Computer objects"
const GROUP_OBJ								=	"Group objects"
const CONTACT_OBJ							=	"Contact objects"
const CSRESOURCE_LIMITS_OBJ					=	"aCSResourceLimits objects"
const CERTIFICATION_AUTHORITY_OBJ			=	"certificationAuthority objects"
const GROUP_POLICY_CONTAINER_OBJ			=	"groupPolicyContainer objects"
const SITE_OBJ								=	"Site objects"
const SUBNET_OBJ							=	"Subnet objects"
const USER_OBJECT							=	"User objects"

const MSMQ_CONFIGURATION_NT5				=	"MSMQ Configuration objects"
const TRUSTED_DOMAIN_NT5					=	"Trusted Domain objects"
const INTELLIMIRROR_GROUP_NT5				=	"IntelliMirror Group objects"
const SUBNETS_CONTAINER_NT5					=	"Subnets Container objects"
const SITE_LINK_NT5							=	"Site Link objects"
const SITE_LINK_BRIDGE_NT5					=	"Site Link Bridge objects"
const SITE_CONTAINER_NT5					=	"Sites Container objects"
const INTELLIMIRROR_SERVICE_NT5				=	"IntelliMirror Service objects"
const VOLUME_NT5							=	"Shared Folder objects"
const PRINTER_NT5							=	"Printer objects"
const OU_NT5								=	"Organizational Unit objects"
const SITE_SETTING_NT5						=	"Site Settings objects"
const CONNECTION_NT5						=	"Connection objects"

const MSMQ_CONFIGURATION_NT4				=	"mSMQConfiguration objects"
const INTELLIMIRROR_SERVICE_NT4				=	"intellimirrorSCP objects"
const SUBNETS_CONTAINER_NT4					=	"subnetContainer objects"
const INTELLIMIRROR_GROUP_NT4				=	"intellimirrorGroup objects"
const PRINTER_NT4							=	"printQueue objects"
const OU_NT4								=	"organizationalUnit objects"
const SITE_LINK_NT4							=	"siteLink objects"
const SITE_LINK_BRIDGE_NT4					=	"siteLinkBridge objects"
const SITE_CONTAINER_NT4					=	"sitesContainer objects"
const TRUSTED_DOMAIN_NT4					=	"trustedDomain objects"
const VOLUME_NT4							=	"volume objects"
const CONNECTION_NT4						=	"nTDSConnection objects"
const SITE_SETTING_NT4						=	"nTDSSiteSettings objects"

'--------------------------------------------------------------------------
 'Some special cases between logon nt5user and nt4user
const PERM_DELETE_INTELLIMIRROR_SERVICE_NT5		=	"Delete IntelliMirror Service Objects"
const PERM_CREATE_INTELLIMIRROR_GROUP_NT5		=	"Create IntelliMirror Group Objects"
const PERM_CREATE_ORGANIZATIONAL_UNIT_NT5		=	"Create Organizational Unit Objects"
const PERM_CREATE_INTELLIMIRROR_SERVICE_NT5		=	"Create IntelliMirror Service Objects"
const PERM_CREATE_SHARED_FOLDER_NT5				=	"Create Shared Folder Objects"
const PERM_DELETE_SHARED_FOLDER_NT5				=	"Delete Shared Folder Objects"
const PERM_CREATE_PRINT_NT5						=	"Create Printer Objects"
const PERM_DELETE_PRINT_NT5						=	"Delete Printer Objects"
const PERM_CREATE_SUBNETS_CONTAINER_NT5			=	"Create Subnets Container Objects"
const PERM_DEL_SITE_SETTING_NT5					=	"Delete Site Settings Objects"
const PERM_WRITE_PAGER_NT5						=	"Write Pager Number (Others)"
const CREATE_DELETE_PRINT_NT5					=	"Create/Delete Printer Objects"


const PERM_CREATE_INTELLIMIRROR_GROUP_NT4		=	"Create intelliMirrorGroup Objects"
const PERM_CREATE_ORGANIZATIONAL_UNIT_NT4		=	"Create organizationalUnit Objects"
const PERM_CREATE_INTELLIMIRROR_SERVICE_NT4		=	"Create IntelliMirrorSCP Objects"
const PERM_CREATE_SHARED_FOLDER_NT4				=	"Create volume Objects"
const PERM_DELETE_SHARED_FOLDER_NT4				=	"Delete volume Objects"
const PERM_CREATE_PRINT_NT4						=	"Create printQueue Objects"
const PERM_DELETE_PRINT_NT4						=	"Delete printQueue Objects"

const PERM_DELETE_INTELLIMIRROR_SERVICE_NT4		=	"Delete IntelliMirrorSCP Objects"
const PERM_CREATE_SUBNETS_CONTAINER_NT4			=	"Create subnetsContainer Objects"
const PERM_DEL_SITE_SETTING_NT4					=	"Delete nTDSSiteSettings Objects"
const PERM_WRITE_PAGER_NT4						=	"Write pager"
const CREATE_DELETE_PRINT_NT4					=	"Create/Delete printQueue Objects"
'Read and write permission in delwiz
'----------------------------------------------------------------------------------
const DELWIZ_RW_GENERAL_INFO				=	"Read and write General Information"
const DELWIZ_RW_ACC_RESTRICT				=	"Read and write Account Restrictions"
const DELWIZ_RW_LOGON_INFO					=	"Read and write Logon Information"
const DELWIZ_RW_GROUP_MEM					=	"Read and write Group Membership"
const DELWIZ_RW_PERSON_INFO					=	"Read and write Personal Information"
const DELWIZ_RW_PHONE_MAIL_OP				=	"Read and write Phone and Mail Options"
const DELWIZ_RW_WEB_INFO					=	"Read and write Web Information"
const DELWIZ_RW_PUBLIC_INFO					=	"Read and write Public Information"
const DELWIZ_RW_RAS_INFO					=	"Read and write Remote Access Information"
'----------------------------------------------------------------------------------
'Context help in acls
'----------------------------------------------------------------------------------
const CONTEXT_HELP_BUTTON					=	"Context help"
const SEC_SID_TIP							=	"Lists the users and groups"
const SEC_PERM_TIP							=	"Lists the standard permissions"
const ADD_BUTTON_TIP						=	"Click to select the users and groups"
const REMOVE_BUTTON_TIP						=	"Removes the selected user or group"
const ADVANCED_BUTTON_TIP					=	"Click to view and set special permissions"
const OK_BUTTON_TIP							=	"Closes the dialog box and saves any changes"
const CANCEL_BUTTON_TIP						=	"Closes the dialog box without saving"
const APPLY_BUTTON_TIP						=	"Saves all the changes you have made without closing"
const PERM_INHERITABLE_TIP					=	"Specifies whether permissions for this object"
const AUD_INHERITABLE_TIP					=	"Specifies whether auditing entries for this object"
const PERM_LIST_TOOLTIP						=	"Lists the current permission entries"
const AUD_LIST_TOOLTIP						=	"Lists the auditing entries currently assigned to this object"
const PERM_VIEWEDIT_TOOLTIP					=	"Click to display and edit permissions"
const AUD_VIEWEDIT_TOOLTIP					=	"Click to display and edit the access attempts"
const BTN_VIEW_EDIT							=	"&Edit..."
const PERM_ENTRY_NAME_TIP			= "Specifies the user or group to whom the permissions are"
const AUD_ENTRY_NAME_TIP			= "Specifies the user or group to whom the auditing entries are"
const PERM_ENTRY_APPLY_ONTO_TIP		= "Specifies where the permissions are applied"
const AUD_ENTRY_APPLY_ONTO_TIP		= "Specifies where objects are audited"
const PERM_ENTRY_PERM_LIST_TIP		= "Lists the special permissions you can allow or deny"
const AUD_ENTRY_PERM_LIST_TIP		= "Lists the types of access to audit."

const PERM_ENTRY_CHANGE_BTN_TIP		= "Click to choose a user or group account to add"
const PERM_ENTRY_CLEAR_BTN_TIP		= "Clears the check boxes that are selected."
const APPLY_W_PERM_CONTAINERS_TIP	= "Specifies whether you want to apply permissions to"
const APPLY_W_AUD_CONTAINERS_TIP	= "Specifies whether you want to apply auditing to the selection"
const BTN_APPLY_PERM_WI_CONTAINERS	="Apply &these permissions to objects and/or containers within this container only"
const BTN_APPLY_AUD_WI_CONTAINERS	="Apply &these auditing entries to objects and/or containers within this container only"

'----------------------------------------------------------------------------------
'	Permissions TAB strings
'----------------------------------------------------------------------------------

const TYPE_ALLOW							=	"Allow"   'Permissions TAB
const TYPE_DENY								=	"Deny"    'Permissions TAB
                                 
const ACE_PERM_TYPE_COL						=	"Type"
const ACE_PERM_NAME_COL						=	"Name"
const ACE_PERM_PERM_COL						=	"Permission"
const ACE_PERM_APPLY_COL					=	"Apply to"
                                 
const BTN_S_ADD								=	"A&dd..."
const BTN_S_REMOVE							=	"&Remove"
const BTN_S_VIEW_EDIT						=	"&Edit..."


const MSG_CONFIRM_DENY_ACE       = "Caution! Deny entries take priority over Allow entries, which can cause unintended effects due to group memberships."+EOL+EOL+_
                                   "Do you wish to continue?"  
'----------------------------------------------------------------------------------
'		Permission text strings (On sec tab, perm entry page / OBJECT tab )
'----------------------------------------------------------------------------------

'generic rights
const PERM_ADDITIONAL_PERM					=	"Additional Permissions"
const PERM_FULL_CONTROL						=	"Full Control"
const PERM_LIST_CONTENTS					=	"List Contents"
const PERM_LIST_OBJ							=	"List Object"
const PERM_READ_ALL_PROP					=	"Read All Properties"
const PERM_WRITE_ALL_PROP					=	"Write All Properties"
'const PERM_ADDREMOVE_SELF_AS_MBR			=	"Add/Remove Self as Member"
const PERM_ALL_VALIDATED_WRITE				=	"All Validated Writes"
const PERM_ALL_EXTENDED_RIGHTS				=	"All Extended Rights"
const PERM_STANDARD_DELETE					=	"Delete"
const PERM_DELETE_SUBTREE					=	"Delete Subtree"
const PERM_READ_PERMISIONS					=	"Read Permissions"
const PERM_MODIFY_PERMISIONS				=	"Modify Permissions"
const PERM_MODIFY_OWNER						=	"Modify Owner"

const PERM_CREATE_ALL_CHL_OBJ				=	"Create All Child Objects"
const PERM_DELETE_ALL_CHL_OBJ				=	"Delete All Child Objects"
const PERM_SET_POLICY						=	"Generate Resultant Set of Policy(Logging)"

const PERM_MODIFY_SELF						=	"Modify Self"
const PERM_SPECIAL							=	"Special"
const PERM_READ								=	"Read"
const PERM_WRITE							=	"Write"

'control access rights
const PERM_CHANGE_PWD						=	"Change Password"

const PERM_MODIFY_RAS_INFO					=	"Modify Remote Access Information"
const PERM_RECEIVE_AS						=	"Receive As"
const PERM_RESET_PWD						=	"Reset Password"
const PERM_SEND_AS							=	"Send As"
const PERM_SEND_TO							=	"Send To"

'read/write property sets
const PERM_READ_SITE_LIST					=	"Read siteList"
const PERM_READ_PHONE_MAIL_OPTIONS			=	"Read Phone and Mail Options"
const PERM_READ_GENERAL_INFO				=	"Read General Information"
const PERM_READ_GROUP_MBR					=	"Read Group Membership"
const PERM_READ_PERSONAL_INFO				=	"Read Personal Information"
const PERM_READ_PUBLIC_INFO					=	"Read Public Information"
const PERM_READ_ACC_RESTRICTIONS			=	"Read Account Restrictions"
const PERM_READ_LOGON_INFO					=	"Read Logon Information"
const PERM_READ_WEB_INFO					=	"Read Web Information"
const PERM_READ_RAS_INFO					=	"Read Remote Access Information"
const PERM_READ_COMPANY						=	"Read Company"		'on User objects
const PERM_READ_MACHINE_ROLE				=	"Read machineRole"	'on Computer objects
const PERM_READ_KEYWORDS					=	"Read Keywords"	'on shared folder objects
const PERM_READ_DESCRIPTION					=	"Read Description"
const PERM_READ_FLAGS						=	"Read flags"
const PERM_READ_GPLINK						=	"Read gPLink"
const PERM_READ_GPOPTIONS					=	"Read gPOptions"
const PERM_READ_MANAGEDBY					=	"Read managedBy"
const PERM_READ_MS_DS_MACHINEACCOUNTQUOTA	=	"Read ms-DS-MachineAccountQuota"
const PERM_READ_NETBIOSNAME					=	"Read nETBIOSName"
const PERM_READ_NTMIXIEDDOMAIN				=	"Read nTMixedDomain"
const PERM_READ_TREENAME					=	"Read treeName"
const PERM_READ_MODIFY_GROUP_MEMB			=	"Read Modify Group Membership"
const PERM_READ_ADMIN_DESCRIPTION			=	"Read adminDescription"
const PERM_READ_ADMIN_DISPLAYNAME			=	"Read adminDisplayName"
const PERM_READ_COUNTRYCODE					=	"Read countryCode"
const PERM_READ_POSTALADDRESS				=	"Read postalAddress"
const PERM_READ_POSTALCODE					=	"Read postalCode"
const PERM_READ_POSTOFFICEBOX				=	"Read postOfficeBox"
const PERM_READ_ST							=	"Read st"
const PERM_READ_TRUST_AUTH_OUTGOING			=	"Read trustAuthOutgoing"
const PERM_READ_PARENTCA					=	"Read currentParentCA"
const PERM_READ_NETBOOT_MAXCLIENTS			=	"Read netbootMaxClients"
const PERM_READ_OBJECT_SID					=	"Read objectSid"
const PERM_READ_GPCMACHINE_EX_NAME			=	"Read gPCMachineExtensionNames"
const PERM_READ_STREET_ADDR					=	"Read Street Address"
const PERM_READ_JOB_TITLE					=	"Read Job Title"
const PERM_READ_DEPARTMENT					=	"Read Department"
const PERM_READ_POST_BOX					=	"Read Post Office Box"
const PERM_READ_MEMBERS						=	"Read Members"
const PERM_READ_MANAGED_BY					=	"Read Managed By"
'-----------------------------------------------------------------------------------
const PERM_WRITE_MANAGED_BY					=	"Write Managed By"
const PERM_WRITE_MEMBERS					=	"Write Members"
const PERM_WRITE_PRINT_ATTRIB				=	"Write printAttributes"
const PERM_WRITE_MSQCOMP_TYPEEX				=	"Write mSMQComputerTypeEx"
const PERM_WRITE_GPCMACHINE_EXNAME			=	"Write gPCMachineExtensionNames"
const PERM_WRITE_SITE_LINK_LIST				=	"Write siteLinkList"
const PERM_WRITE_PHONE_MAIL_OPTIONS			=	"Write Phone and Mail Options"
const PERM_WRITE_GENERAL_INFO				=	"Write General Information"
const PERM_WRITE_GROUP_MBR					=	"Write Group Membership"
const PERM_WRITE_PERSONAL_INFO				=	"Write Personal Information"
const PERM_WRITE_PUBLIC_INFO				=	"Write Public Information"
const PERM_WRITE_ACC_RESTRICTIONS			=	"Write Account Restrictions"
const PERM_WRITE_LOGON_INFO					=	"Write Logon Information"
const PERM_WRITE_WEB_INFO					=	"Write Web Information"
const PERM_WRITE_RAS_INFO					=	"Write Remote Access Information"
const PERM_WRITE_COMPANY					=	"Write Company"		'on User objests
const PERM_WRITE_MACHINE_ROLE				=	"Write machineRole"	'on Computer objects
const PERM_WRITE_KEYWORDS					=	"Write Keywords"	'on shared folder objects
const PERM_WRITE_DESCRIPTION				=	"Write Description"
const PERM_WRITE_FLAGS						=	"Write flags"
const PERM_WRITE_GPLINK						=	"Write gPLink"
const PERM_WRITE_GPOPTIONS					=	"Write gPOptions"
const PERM_WRITE_MANAGEDBY					=	"Write managedBy"
const PERM_WRITE_MS_DS_MACHINEACCOUNTQUOTA	=	"Write ms-DS-MachineAccountQuota"
const PERM_WRITE_NETBIOSNAME				=	"Write nETBIOSName"
const PERM_WRITE_NTMIXDOMAIN				=	"Write nTMixedDomain"
const PERM_WRITE_TREENAME					=	"Write treeName"
const PERM_WRITE_MODIFY_GROUP_MEMB			=	"Write Group Membership"
const PERM_WRITE_ADMIN_DESCRIPTION			=	"Write adminDescription"
const PERM_WRITE_ADMIN_DISPLAYNAME			=	"Write adminDisplayName"
const PERM_WRITE_COUNTRYCODE				=	"Write countryCode"
const PERM_WRITE_POSTALADDRESS				=	"Write postalAddress"
const PERM_WRITE_POSTALCODE					=	"Write postalCode"
const PERM_WRITE_POSTOFFICEBOX				=	"Write postOfficeBox"
const PERM_WRITE_ST							=	"Write st"
const PERM_WRITE_UPNSUFFIXES				=	"Write uPNSuffixes"
const PERM_WRITE_INTERSITE_TOPOLOGY_GEN		=	"Write interSiteTopologyGenerator"
const PERM_WRITE_TRUST_AUTHINCOMING			=	"Write trustAuthIncoming"
const PERM_WRITE_STREET_ADDR				=	"Write Street Address"
const PERM_WRITE_JOB_TITLE					=	"Write Job Title"
const PERM_WRITE_DEPARTMENT					=	"Write Department"
const PERM_WRITE_POST_BOX					=	"Write Post Office Box"
'---------------------------------------------------------------------------------
'General Perm:

const PERM_REPLICATING_DIRECTORY_CHANGES	=	"Replicating Directory Changes"
const PERM_REPLICATION_SYNCHRONIZATION		=	"Replication Synchronization"
const PERM_MANAGE_REPLICATION_TOPOLOGY		=	"Manage Replication Topology"
const PERM_CHANGE_PDC						=	"Change PDC"
const PERM_ADD_GUID							=	"Add GUID"
const PERM_ADD_REMOVE_REPLICA_IN_DOMAIN		=	"Add/Remove Replica In Domain"
const PERM_OPEN_CONNECTOR_Q					=	"Open Connector Queue"

'Property-specific
'----------------

const PERM_READ_MACHINE_ROLE		= "Read machineRole"	'on Computer objects
const PERM_WRITE_MACHINE_ROLE		= "Write machineRole"	'on Computer objects

const PERM_READ_KEYWORDS			= "Read Keywords"	'on shared folder objects
const PERM_WRITE_KEYWORDS			= "Write Keywords"	'on shared folder objects

const PERM_READ_MACHINE_ROLE		= "Read machineRole"	'on Computer objects
const PERM_WRITE_MACHINE_ROLE		= "Write machineRole"	'on Computer objects

'on computer objects
const PERM_VALID_WRITE_DNS			= "Validated write to DNS host name" 
const PERM_VALID_WRITE_SERVICE 		= "Validated write to service principal name"

const PERM_READ_KEYWORDS			= "Read Keywords"	'on shared folder objects
const PERM_WRITE_KEYWORDS			= "Write Keywords"	'on shared folder objects

const PERM_ADD_REMOVE_SELF_MEM		= "Add/Remove self as member"

const PERM_CREATE_GROUPPOLICYCONTAINER_OBJ		=	"Create groupPolicyContainer objects"
const PERM_CREATE_GROUP_OBJ						=	"Create Group Objects"
const PERM_CREATE_CONTACT_OBJ					=	"Create Contact Objects"
const PERM_CREATE_COMPUTER_OBJ					=	"Create Computer Objects"
const PERM_CREATE_USER_OBJ						=	"Create User Objects"
const PERM_CREATE_DELETE_CHILD_OBJ				=	"Creation/deletion of specific child object"
const PERM_CREATE_ACSRESOURCELIMITS_OBJ			=	"Create aCSResourceLimits objects"
const PERM_CREATE_CERTIFICATIONAUTHORITY_OBJ	=	"Create certificationAuthority objects"
const PERM_CREATE_TRUSTED_DOMAIN_OBJ			=	"Create Trusted Domain objects"

const PERM_CREATE_SUBNET_OBJ					=	"Create Subnet objects"
'------------------------------------------------------------------------------------------
const PERM_DELETE_COMPUTER_OBJ					=	"Delete Computer objects"
const PERM_DELETE_CONTACT_OBJ					=	"Delete Contact objects"
const PERM_DELETE_GROUP_OBJ						=	"Delete Group objects"
const PERM_DELETE_GROUPPOLICYCONTAINER_OBJ		=	"Delete groupPolicyContainer objects"
const PERM_DELETE_INTELLIMIRROR_GROUP_OBJ		=	"Delete IntelliMirror Group Objects"
const PERM_DELETE_ORGANIZATIONAL_UNIT_OBJ		=	"Delete Organizational Unit Objects"

const PERM_DELETE_USER_OBJ						=	"Delete User objects"
const PERM_DELETE_ACSRESOURCELIMITS_OBJ			=	"Delete aCSResourceLimits objects"
const PERM_DELETE_CERTIFICATIONAUTHORITY_OBJ	=	"Delete certificationAuthority objects"
const PERM_DELETE_TRUSTED_DOMAIN_OBJ			=	"Delete Trusted Domain objects"
const PERM_DELETE_GP_CONTAINER_OBJ				=	"Delete groupPolicyContainer objects"


const CONST_STR_READ   = "Read"
const CONST_STR_WRITE  = "Write"
const CONST_STR_MODIFY = "Modify"
'---------------------------------------------------------------------------------
'Default permissions
'---------------------------------------------------------------------------------
const CREATE_DELETE_SUBOBJ					=	"Create/Delete All Child Objects"
const CREATE_DELETE_USER_OBJ				=	"Create/Delete User Objects"
const CREATE_DELETE_GROUP_OBJ				=	"Create/Delete Group Objects"
const CREATE_DELETE_COMP_OBJ				=	"Create/Delete Computer Objects"
const READ_WRITE_PERS_INFO					=	"Read/Write Personal Information"
const READ_WRITE_PROP						=	"Read/Write Property"
const READ_WRITE_PHONE_MAIL_OP				=	"Read/Write Phone and Mail Options"
const READ_WRITE_WEB_INFO					=	"Read/Write Web Information"
const READ_WRITE_GENERAL_INFO				=	"Read/Write General Information"

'--------------------------------------------------------------------------------------------
const PERM_WRITE_MSQ_COMP_TYPE_EX						=	"Write mSMQComputerTypeEx"
const PERM_READ_NET_BOOT_SCPBL							=	"Read netbootSCPBL"
const PERM_WRITE_NET_BOOT_SCPBL							=	"Write netbootSCPBL"
const PERM_WRITE_FROM_SERVER							=	"Write fromServer"
								                                  
'----------------------------------------------------------------------------------
'	Properties strings (On	Perm entry page / PROPERTY tab) 
'----------------------------------------------------------------------------------
const DYNAMIC_PERMISSIONS		= "&Permissions for "
const STATIC_PERMISSIONS		= "&Permissions:"
const STATIC_ACCESS				= "Acce&ss:"

' accelerators to access checkboxes lists
const CHK_LIST_ON_PERMISSION    = "%p"
const CHK_LIST_ON_ACCESS        = "%s"

const CONST_STR_READ_PROPERTY	= "Read Property"
const CONST_STR_WRITE_PROPERTY	= "Write Property"
'----------------------------------------------------------------------------------
'Properties strings (On Delegation of Control Wizar)
'----------------------------------------------------------------------------------
const CHK_LIST_ON_DELWIZ_PERMISSION    = "%e"
'----------------------------------------------------------------------------------
'	Colpicker strings
'----------------------------------------------------------------------------------
const COL_VIEW					= "&View"
const COL_CHOOSE				= "Add/Remove Columns..."
const COL_MODIFY				= "Add/Remove Columns"


'----------------------------------------------------------------------------------
'				Auditing TAB strings
'----------------------------------------------------------------------------------
const ACE_AUDIT_TYPE_COL         = "Type"
const ACE_AUDIT_NAME_COL         = "Name"
const ACE_AUDIT_ACCESS_COL       = "Access"
const ACE_AUDIT_APPLY_COL        = "Apply to"
const ACE_AUDIT_CHK_INHERIT      = "&Inherit from parent the auditing entries that apply to child objects. Include these with entries explicitly defined here"

'possible values for type in audit page
const AUDIT_ALL                  = "All"
const AUDIT_SUCCESS              = "Success"
const AUDIT_FAIL                 = "Fail"

const TYPE_SUCCESS		         = "Success" 'Auditing TAB
const TYPE_FAILURE		         = "Fail"    'Auditing TAB

const MSG_CONFIRM_CONVERT_ACE	= "You are preventing any inheritable auditing entries from propagating to this object.  What do you want to do?"

'----------------------------------------------------------------------------------
'				Owner tab strings
'----------------------------------------------------------------------------------
const TAKE_OWNER_RIGHT_STAT			= "You can take ownership of an object if you have the appropriate permissions."
const OWNER_ADMINISTRATOR			= "Domain Admins"
const CURRENT_OWNER_STAT			= "Current owner of this item:"
const CHANGEG_OWNER_TO_STAT			= "Change &owner to:"
const MSG_CHANGE_OWNER_FAIL			= "Unable to set new owner on"
const CHK_LIST_ON_OWNER_LIST		= "%o"

'----------------------------------------------------------------------------------
'				Permission/Audit entry page strings
'----------------------------------------------------------------------------------
const CAP_PERMISSIONS_ENTRY			= "Permission Entry"
const CAP_AUDIT_ENTRY				= "Auditing Entry"

'Confirmation dialog for Apply onto:particular class of objects
'partial string
const MSG_CONFIRM_OBJECT_SPECIFIC_ACE	= "You are attempting to define permissions that apply to"

'warning message when audit settings are applied if auditing policy is turned OFF
'partial string
const MSG_WARNING_AUD_POL_OFF		= "The current Audit Policy for this computer does not have auditing turned on."

'TABs in Permission/Audit Entry page
const PE_TAB_OBJECT					= "Object"
const PE_TAB_PROP					= "Properties"

const PE_CHK_ID_INHERIT				= "Apply &these permissions to objects and/or containers within this container only"

'+--------------------------------------------------------------------------
'                 Security Description Language strings
'+--------------------------------------------------------------------------
'for rights
const SDL_FULLCONTRL       = "RPWPCCDCLCRCWOWDSDSW"
const SDL_READ             = "RPLCRC"
const SDL_WP               = "WP"
const SDL_RP               = "RP"

'for SIDs
const SDL_SY		         = "SY"
const SDL_AU		         = "AU"
const SDL_CO		         = "CO"
const SDL_PS		         = "PS"
const SDL_DA		         = "DA"
const SDL_AO		         = "AO"
const SDL_PO		         = "PO"
const SDL_WD		         = "WD"
const SDL_Unknown          = "Unknown"

'for properties types
const SDL_OP_SEND_TO       = "SENDTO" 
const SDL_OP_SEND_AS       = "SENDAS" 
const SDL_OP_RECEIVE_AS    = "RECEIVEAS" 
const SDL_OP_SEND_CH_PWD   = "CHANGEPASSWORD" 



'********** Error Message Strings ***************
const NO_GLOBAL_CATALOG		= "The object cannot be found in the global catalog."


'********** DSA Extensions strings **************

const CONFIRM_OP_MOVE             = "MOVE"
const CONFIRM_OP_RENAME           = "RENAME"
const CONFIRM_OP_DELETE           = "DELETE"


'-----------------------------------------------------------------
'Multi Edit Prop Page, common strings all Tabs
'-----------------------------------------------------------------
const PropOnMulti					= "Properties On Multiple Objects"

const UPA_MULTI_STATIC_MAIN			= "To change a property for multiple objects, select the check box " +_
										"for the property, and then select new settings. Only selected " +_
										"items will be changed."




'-----------------------------------------------------------------
'  Multi Edit Prop Page, Users General Page
'-----------------------------------------------------------------

const UPG_MULTI_DESCRIPTION			= "&Description:"
const UPG_MULTI_OFFICE				= "Offi&ce:"
const UPG_MULTI_TELEPHONE			= "&Telephone number:"
const UPG_MULTI_FAX					= "&Fax:"
const UPG_MULTI_WEB					= "&Web page:"
const UPG_MULTI_EMAIL				= "E-&mail:"

const UPG_MULTI_BUTTON_TELEPHONE			= "&Other..."
const UPG_MULTI_BUTTON_FAX					= "Oth&er..."
const UPG_MULTI_BUTTON_WEB					= "Othe&r..."

const UPG_MULTI_DESCRIPTION_HOTKEY			= "d"
const UPG_MULTI_OFFICE_HOTKEY				= "c"
const UPG_MULTI_TELEPHONE_HOTKEY			= "t"
const UPG_MULTI_FAX_HOTKEY					= "f"
const UPG_MULTI_WEB_HOTKEY					= "w"
const UPG_MULTI_EMAIL_HOTKEY				= "m"

const UPG_MULTI_BUTTON_TELEPHONE_HOTKEY			= "o"
const UPG_MULTI_BUTTON_FAX_HOTKEY				= "e"
const UPG_MULTI_BUTTON_WEB_HOTKEY				= "r"


'-----------------------------------------------------------------
'  Multi Edit Prop Page, Users Account Page
'-----------------------------------------------------------------

const UPA_MULTI_UPN					= "&UPN suffix:"
const UPA_MULTI_LOGON				= "&Logon hours:"
const UPA_MULTI_COMPUTER			= "&Computer restrictions"
const UPA_MULTI_EXPIRES				= "Accou&nt expires"

const UPA_MULTI_BUTTON_LOGON		= "Logon &Hours..."
const UPA_MULTI_BUTTON_LOGONTO		= "Log On &To..."
const UPA_MULTI_LOGONHOURS			= "Logon Hours"
const UPA_MULTI_LOGONWKST			= "Logon Workstations"

const UPA_MULTI_STATIC_ACCOUNT		= "Account &options:"

const UPA_MULTI_UPN_HOTKEY					= "u"
const UPA_MULTI_LOGON_HOTKEY				= "l"
const UPA_MULTI_COMPUTER_HOTKEY				= "c"
const UPA_MULTI_EXPIRES_HOTKEY				= "n"

const UPA_MULTI_BUTTON_LOGON_HOTKEY			= "h"
const UPA_MULTI_BUTTON_LOGONTO_HOTKEY		= "t"
const UPA_MULTI_OPTIONS_HOTKEY				= "o"

const UPA_MULTI_RBTN_NEVER_HOTKEY			= "v"
const UPA_MULTI_RBTN_ENDOF_HOTKEY			= "e"


'---------------------------------------------------
'Multi Edit Prop Page, Users Address Page
'---------------------------------------------------

const UPAD_MULTI_STREET						= "&Street:"						
const UPAD_MULTI_POBOX						= "P.O. &Box:"
const UPAD_MULTI_CITY						= "&City:"
const UPAD_MULTI_STATE						= "State/Pro&vince:"
const UPAD_MULTI_ZIP						= "&Zip/Postal Code:"
const UPAD_MULTI_COUNTRY					= "C&ountry/Region:"

const UPAD_MULTI_STREET_HOTKEY				= "s"						
const UPAD_MULTI_POBOX_HOTKEY				= "b"
const UPAD_MULTI_CITY_HOTKEY				= "c"
const UPAD_MULTI_STATE_HOTKEY				= "v"
const UPAD_MULTI_ZIP_HOTKEY					= "z"
const UPAD_MULTI_COUNTRY_HOTKEY				= "o"					


'----------------------------------------------------
'Multi Edit Prop Page, Users Profile Page
'----------------------------------------------------

const UPPROF_MULTI_PROFILE						= "&Profile path:"
const UPPROF_MULTI_LOGON						= "Logon &script:"
const UPPROF_MULTI_HOME							= "&Home folder"

const UPPROF_MULTI_OPTION_LOCAL					= "&Local path:"
const UPPROF_MULTI_OPTION_CONNECT				= "&Connect:"

const UPPROF_MULTI_PROFILE_HOTKEY				= "p"
const UPPROF_MULTI_LOGON_HOTKEY					= "s" 
const UPPROF_MULTI_HOME_HOTKEY					= "h"
const UPPROF_MULTI_OPTION_LOCAL_HOTKEY			= "l"
const UPPROF_MULTI_OPTION_CONNECT_HOTKEY		= "c"
const UPPROF_MULTI_TO_HOTKEY					= "t" 


'--------------------------------------------------------
'Multi Edit Prop Page, Users Orginization Page
'--------------------------------------------------------

const UPORG_MULTI_TITLE						= "&Title:"
const UPORG_MULTI_DEPART					= "&Department:"
const UPORG_MULTI_COMPANY					= "&Company:"
const UPORG_MULTI_MANAGER					= "&Manager:"

const UPORG_MULTI_EDIT_NAME					= "&Name:"

const UPORG_MULTI_BUTTON_CHANGE				= "C&hange..."
const UPORG_MULTI_BUTTON_VIEW				= "&View"
const UPORG_MULTI_BUTTON_CLEAR				= "C&lear"

const UPORG_MULTI_TITLE_HOTKEY					= "t"
const UPORG_MULTI_DEPART_HOTKEY					= "d"
const UPORG_MULTI_COMPANY_HOTKEY				= "c"
const UPORG_MULTI_MANAGER_HOTKEY				= "m"

const UPORG_MULTI_EDIT_NAME_HOTKEY				= "n"

const UPORG_MULTI_BUTTON_CHANGE_HOTKEY			= "h"
const UPORG_MULTI_BUTTON_VIEW_HOTKEY			= "v"
const UPORG_MULTI_BUTTON_CLEAR_HOTKEY			= "l"


'-----------------------------------------------------------
'Multi Edit Error Dialog
'-----------------------------------------------------------

const UPERR_MULTI_STATIC_APPLIED			= "Any changes on the following tabs were successfully applied:"
const UPERR_MULTI_STATIC_VIEW				= "The following errors occurred on the Profile tab:"
const UPERR_MULTI_STATIC_NOTAPPLIED			= "Any changes on the following tabs have not yet been applied:"

const UPERR_MULTI_BUTTON_COPY				= "&Copy"
const UPERR_MULTI_BUTTON_PROP				= "&Properties"
const UPERR_MULTI_BUTTON_CLOSE				= "Cl&ose"

const NOTEPAD_APP_EXE						= "notepad.exe"
const NOTEPAD_TITLE							= "Notepad"

const UPERR_MULTI_BUTTON_COPY_HOTKEY				= "c"
const UPERR_MULTI_BUTTON_PROP_HOTKEY				= "p"
const UPERR_MULTI_BUTTON_CLOSE_HOTKEY				= "o"


'--------------------------------------------------------------
'Multi Edit Mixed Page
'--------------------------------------------------------------

const UP_MULTI_MIX_DESCRIPTION			= "&Change the description text for all selected objects"






'----------------------------------------------------
'Domain Trusts Page, Tabs
'----------------------------------------------------
const DTTRUST_TAB					= "Trusts"

'----------------------------------------------------
'Domain Trusts Page, General Page
'----------------------------------------------------
 ' see DP_ID_* consts above

'----------------------------------------------------
'Domain Trusts Page, Trusts Page
'----------------------------------------------------
const DTTRUST_TRUSTEDLIST			= "Do&mains trusted by this domain:"
const DTTRUST_ADDTRUSTED			= "A&dd..."
const DTTRUST_EDITTRUSTED			= "&Edit..."
const DTTRUST_REMOVETRUSTED			= "&Remove"

const DTTRUST_ID_TRUSTEDLIST		= "@1"
const DTTRUST_ID_ADDTRUSTED			= "@1"
const DTTRUST_ID_EDITTRUSTED		= "@2"
const DTTRUST_ID_REMOVETRUSTED		= "@3"

const DTTRUST_TRUSTINGLIST			= "D&omains that trust this domain:"
const DTTRUST_ADDTRUSTING			= "Add..."
const DTTRUST_EDITTRUSTING			= "Edi&t..."
const DTTRUST_REMOVETRUSTING		= "Remo&ve"

const DTTRUST_ID_TRUSTINGLIST		= "@2"
const DTTRUST_ID_ADDTRUSTING		= "@4"
const DTTRUST_ID_EDITTRUSTING		= "@5"
const DTTRUST_ID_REMOVETRUSTING		= "@6"
'----------------------------------------------------
'Domain Trusts Page, Trust Properties By Page
'----------------------------------------------------
const DTTRUSTP_VERIFY				= "&Verify"

'----------------------------------------------------
'Domain Trusts Page, Managed By Page
'----------------------------------------------------
 ' see SMP_* consts above

'----------------------------------------------------
'Domain & Trusts  - Add Trusted Domain
'----------------------------------------------------
const DTADDTRUSTED_TITLE			= "Add Trusted Domain"
const DTADDTRUSTED_DOMAIN			= "&Trusted domain:"
const DTADDTRUSTED_PASSWORD			= "&Password:"
const DTADDTRUSTED_PASSWORD2		= "&Confirm password:"

const DTADDTRUSTED_ID_DOMAIN		= "@1"
const DTADDTRUSTED_ID_PASSWORD		= "@2"
const DTADDTRUSTED_ID_PASSWORD2		= "@3"

'----------------------------------------------------
'Domain & Trusts  - Add Trusting Domain
'----------------------------------------------------
const DTADDTRUSTING_TITLE			= "Add Trusting Domain"
const DTADDTRUSTING_DOMAIN			= "&Trusting domain:"
const DTADDTRUSTING_PASSWORD		= "&Password:"
const DTADDTRUSTING_PASSWORD2		= "&Confirm password:"

const DTADDTRUSTING_ID_DOMAIN		= "@1"
const DTADDTRUSTING_ID_PASSWORD		= "@2"
const DTADDTRUSTING_ID_PASSWORD2	= "@3"


'----------------------------------------------------
'Domain & Trusts  - Trust modify process - dialog strings
'----------------------------------------------------
const DTADD_CREDSNEEDED_STATIC					= VT_WILDCARD + "To complete this operation, you must log on to domain"
const DTADD_CREDSNEEDED_USER					= "&User name:"
const DTADD_CREDSNEEDED_PASSWORD				= "&Password:"
const DTADD_ID_CREDSNEEDED_USER					= "@1"
const DTADD_ID_CREDSNEEDED_PASSWORD				= "@2"

const DTADD_DOMAINNOTFOUND_STATIC				= VT_WILDCARD + "domain cannot be contacted."

'''''''''''''''''''''
' due to bug # 200249, the text is incorrect.  uncomment the next line and comment the line following that once its has been fixed
'const DTADD_TRUSTEDCREATED_STATIC				= "The trusted domain has been added and the trust verified."
const DTADD_TRUSTEDCREATED_STATIC				= "The trusting domain has been added and the trust verified."
'''''''''''''''''''''
const DTADD_TRUSTEDCREATEDNOTVERIFIED_STATIC	= VT_WILDCARD + "Active Directory cannot verify the trust."

const DTADD_TRUSTINGQUERYVERIFY_STATIC			= VT_WILDCARD + "To verify the new trust, you must have permissions to administer trusts for the domain"
const DTADD_TRUSTINGCREATED_STATIC				= "The trusting domain has been added and the trust verified."
const DTADD_TRUSTINGCREATEDNOTVERIFIED_STATIC	= VT_WILDCARD + "Active Directory cannot verify the trust."

const DTREMOVE_AREYOUSURE_STATIC				= VT_WILDCARD + "Are you sure you want to remove this direction of trust with the"
const DTREMOVE_FORCEREMOVAL_STATIC				= VT_WILDCARD + "Do you wish to force" 'BUGBUG - this is WRONG!  Look up the right string
const DTREMOVE_CREDSNEEDED_STATIC				= VT_WILDCARD + "To complete this operation, you must log on to domain"
const DTREMOVE_CREDSNEEDED_USER					= "&User name:"
const DTREMOVE_CREDSNEEDED_PASSWORD				= "&Password:"
const DTREMOVE_ID_CREDSNEEDED_USER				= "@1"
const DTREMOVE_ID_CREDSNEEDED_PASSWORD			= "@2"

const DTVERIFY_CREDSNEEDED_STATIC				= VT_WILDCARD + "To complete this operation, you must log on to domain"
const DTVERIFY_CREDSNEEDED_USER					= "&User name:"
const DTVERIFY_CREDSNEEDED_PASSWORD				= "&Password:"
const DTVERIFY_ID_CREDSNEEDED_USER				= "@1"
const DTVERIFY_ID_CREDSNEEDED_PASSWORD			= "@2"
const DTVERIFY_WILLATTEMPTSCRESET_STATIC		= VT_WILDCARD + "An SC reset will now be attempted."
const DTVERIFY_FAILWITHERROR_STATIC				= VT_WILDCARD + "failed with error:"
const DTVERIFY_QUERYRESETTRUSTPASSWORDS_STATIC	= VT_WILDCARD + "Resetting the trust passwords might solve the problem."
const DTVERIFY_CANNOTREPAIR_STATIC				= VT_WILDCARD + "The trust cannot be repaired because:"
const DTVERIFY_TRUSTVERIFIED_STATIC				= "The trust has been verified. It is in place and active."

'----------------------------------------------------
'Domain & Trusts  - String Constants
'----------------------------------------------------
const DTTRUSTTYPE_EXTERNAL	= "External"
const DTTRUSTTYPE_SHORTCUT	= "Shortcut"
const DTTRUSTTYPE_MIT		= "Non-Windows Kerberos Realm"
const DTTRUSTTYPE_TREEROOT	= "Tree Root"
const DTTRUSTTYPE_PARENT	= "Parent"
const DTTRUSTTYPE_CHILD		= "Child"

const DTTRUST_DOMAINCOLUMN			= "Domain Name"
const DTTRUST_RELATIONSHIPCOLUMN	= "Relationship"
const DTTRUST_TRANSITIVECOLUMN		= "Transitive"

'----------------------------------------------------
'Saved Queries  - String Constants
'----------------------------------------------------
const QUERY_STATIC_NAME				= "&Name:"
const QUERY_STATIC_DESCRIPTION		= "&Description:"
const QUERY_STATIC_QUERY_ROOT		= "&Query root:"
const QUERY_STATIC_INCLUDE_SUBS		= "Include &subcontainers"
const QUERY_STATIC_QUERY_STRING		= "Query string:"

const BTN_DEFINE_QUERY				= "D&efine Query..."

const SAVED_QUERIES_NODE		= "Saved Queries"

const DEFAULT_QUERIES_FOLDER	= "Default Queries"

const NEW_FOLDER_DEFAULT_NAME			= "New Folder"
const NEW_QUERY_BASIC			= "New Query"

const CAP_NEW_QUERY				= "New Query"
const CAP_EDIT_QUERY			= "Edit Query"

const MNU_SAVED_QUERY_FOLDER	= "&Folder"
const MNU_SAVED_QUERY_QUERY		= "&Query"


'---------------------------------------------------------
' group customization (adsiedit)  - string constants
'---------------------------------------------------------

const CAP_ADSI							="ADSI Edit"
const AdsiEdit_NODE_NAME		        = VT_WILDCARD + "ADSI Edit"
const CAP_ADSI_CONNECT					= "&Connect to..."
const CAP_ADSI_CONNECTION				= "Connection"
const Adsi_Combo_Context				= "@2"
const Adsi_Config_Container				= "Configuration Container"
const Adsi_TreeConfig_Container				= "Configuration Container +"
const Adsi_DisplaySpecifier_Container		= "CN=DisplaySpecifiers"
const Adsi_409_Conatainer				= "CN=409"
const Adsi_View_Default					= "CN=DS-UI-Default-Settings"
const CAP_Adsi_Prop						= "CN=DS-UI-Default-Settings Properties"
const Adsi_Editor_Page					= "Multi-valued String Editor"
const ADSI_ATTRIBUTES_TAB				= "Attribute Editor"
const Adsi_Combo_Attrib					= "@2"
const Adsi_List_Attrib					= "@1"
const Adsi_NonSec_Class					= "msDS-Non-Security-Group-Extra-Classes"
const Adsi_SEC_Class					= "msDS-Security-Group-Extra-Classes"
const Adsi_Edit_Attrib					= "@1"
const Adsi_Text_Volume					= "Volume"
const Adsi_Button_Add					= "&Add"
const Adsi_Text_OU						= "organizationalUnit"
const Adsi_Button_Edit					= "&Edit"




'-----------------------------------------------------
'Sites & Services properties pages - string constants
'-----------------------------------------------------
const SITE_TAB_General				= "General"
const SITE_TAB_Site					= "Site"
const SITE_TAB_Subnet				= "Subnet"
const SITE_SITE_EDT_Description		= "&Description:"
const SITE_SITE_LST_Subnets			= "&Subnets:"

const SITE_TAB_Location				= "Location"
const SITE_LOCATION_EDT_Location	= "&Location:"
const SITE_LOCATION_BTN_Browse		= "&Browse..."

const SITELIC_TAB_LicensingSettings	= "Licensing Settings"
const SITELIC_LS_EDT_Description	= "&Description:"
const SITELIC_LS_EDT_Computer		= "&Computer:"
const SITELIC_LS_EDT_Domain			= "D&omain:"
const SITELIC_LS_BTN_Change			= "C&hange..."

const SITESET_TAB_SiteSettings		= "Site Settings"
const SITESET_SS_EDT_Description	= "&Description:"
const SITESET_SS_CHK_Override		= "&Override inherited schedule"
const SITESET_SS_BTN_ChangeSched	= "&Change Schedule..."
const SITESET_SS_EDT_Server			= "&Server:"
const SITESET_SS_EDT_Site			= "Sit&e:"


const SERVER_TAB_General				= "General"
const SERVER_TAB_Server					= "Server"
const SERVER_SERVER_EDT_Description		= "D&escription:"
const SERVER_SERVER_LST_Available		= "&Transports available for inter-site data transfer:"
const SERVER_SERVER_LST_Available_Divided		= "&Transports available for inter-site data transfer:"
const SERVER_SERVER_LST_PrefBridgehead	= "This server is a preferred &bridgehead server for the following transports:"
const SERVER_SERVER_BTN_Add				= "A&dd >>"
const SERVER_SERVER_BTN_Remove			= "<< &Remove"
const SERVER_SERVER_EDT_Computer		= "&Computer:"
const SERVER_SERVER_BTN_Change			= "C&hange..."
const SERVER_SERVER_EDT_Domain			= "D&omain:"

const NTDSSETTINGS_TAB_Connections	= "Connections"
const NTDSSETTINGS_GENERAL_EDT_Description	= "&Description:"
const NTDSSETTINGS_GENERAL_CMB_QueryPolicy	= "&Query Policy:"
const NTDSSETTINGS_GENERAL_BTN_GC			= "&Global Catalog"
const NTDSSETTINGS_GENERAL_EDT_DNSAlias		= "D&NS Alias:"
const NTDSSETTINGS_CONNECTIONS_LST_RepFrom	= "Replicate &From:"
const NTDSSETTINGS_CONNECTIONS_LST_RepTo	= "Replicate &To:"

const CONNECTION_TAB_General			= "General"
const CONNECTION_TAB_Connection			= "Active Directory Connection"
const CONNECTION_ADC_EDT_Description	= "&Description:"
const CONNECTION_ADC_CMB_Transport		= "&Transport:"
const CONNECTION_ADC_CHK_Override		= "&Override inherited schedule"
const CONNECTION_ADC_BTN_ViewSched		= "&View Schedule"
const CONNECTION_ADC_EDT_Server			= "&Server:"
const CONNECTION_ADC_BTN_Change			= "C&hange..."
const CONNECTION_ADC_EDT_Site			= "Sit&e:"
const CONNECTION_ADC_EDT_RepDomain		= "&Replicated Naming Context(s):"
const CONNECTION_ADC_EDT_PartialRep		= "&Partially Replicated Naming Context(s):"

const SUBNET_TAB_Subnet				= "Subnet"
const SUBNET_TAB_general				= "General"
const SUBNET_TAB_Location			= "Location"
const SUBNET_SUBNET_EDT_Description	= "&Description:"
const SUBNET_SUBNET_CMB_Site		= "&Site:"
const SUBNET_SUBNET_IP_Network		= "Network:"
const SUBNET_SUBNET_IP_Mask			= "Mask:"
const SUBNET_LOCATION_EDT_Location	= "&Location:"
const SUBNET_LOCATION_BTN_Browse	= "&Browse..."

const TRANSPORT_TAB_General				= "General"
const TRANSPORT_GENERAL_EDT_Description	= "&Description:"
const TRANSPORT_GENERAL_CHK_IgnoreSched	= "&Ignore schedules"
const TRANSPORT_GENERAL_CHK_BridgeAll	= "&Bridge all site links"


'------------------------------------------------
'  Dragdrop stuff from Art
'------------------------------------------------

const CAP_EXPORT_LIST$			= "Export List..."
const SYS_MNU_CLOSE			= "Close"

'------------------------------------------------------------------------
' Some correction these need sto be moved to a better section in the file
'--------------------------------------------------------------------------

const MNU_CREATE_NEW_SITE = "New Site"
const MNU_CREATE_NEW_SITELINK = "New Site Link"
const MNU_CREATE_NEW_SITELINKBRIDGE = "New Site Link Bridge"
const MNU_CREATE_NEW_SUBNET = "New Subnet"
const SiteLink_EDT_Description = "D&escription:"

'---------------------
'Button text
const BTN_NO_NO_HOTKEY =			"No"


'Menu items
const MNU_SITE_HOTKEY =				"&Site"
const MNU_DELETE_NO_HOTKEY =		"Delete"
const MNU_NEW_AD_CONNECTION =		"New Active Directory Connection"
const MNU_DELWIZ_HOTKEY =			"D&elegate Control..."
const MNU_ALL_TASKS =				"All Tasks"
const MNU_CHECK_REPLICATION	=		"Check Replication Topology"
const MNU_REPLICATE_NOW =			"Replicate &Now"


'Object Property pages strings
const PROP_GENERAL_SITELINK_NOTINTHISLINK = "Sites &not in this site link:"
const PROP_GENERAL_SITELINK_INTHISLINK = "&Sites in this site link:"
const PROP_GENERAL_SITELINK_NOTINTHISLINK_Bridge = "Site links &not in this site link bridge:"
const PROP_GENERAL_SITELINK_NOTINTHISLINK_Bridge_Divided = "Site links &not in this site link bridge:"
const PROP_GENERAL_SITELINK_INTHISLINK_Bridge = "&Site links in this site link bridge:"
const PROP_GENERAL_SITELINK_INTHISLINK_Bridge_Divided = "&Site links in this site link bridge:"
const PROP_GENERAL_SITELINK_COST = "C&ost:"
const PROP_GENERAL_SITELINK_REPLICATEEVERY = "Re&plicate every"
const PROP_GENERAL_SITELINK_MINUTES = "minutes"
const PROP_GENERAL_BUTTON_ADD = "A&dd >>"
const PROP_GENERAL_BUTTON_REMOVE = "<< &Remove"
const PROP_GENERAL_BUTTON_CHANGESCHEDULE = "&Change Schedule..."


const PROP_OBJECT_SITES_CONTAINER =	"~/Configuration/Sites"
const PROP_OBJECT_SUBNETS_CONTAINER = "~/Configuration/Sites/Subnets"
const PROP_OBJECT_EDIT_DEFAULTSITE = "~/Configuration/Sites/"
const PROP_OBJECT_EDIT_LICENSINGSITE = "~/Licensing Site Settings"
const PROP_OBJECT_EDIT_NTDSSITE = "~/NTDS Site Settings"
const PROP_OBJECT_EDIT_DEFAULTIPSITELINK = "~.microsoft.com/Configuration/Sites/Inter-Site Transports/IP/DEFAULTIPSITELINK"
const PROP_OBJECT_TEXT_SITE =		"Site"
const PROP_OBJECT_TEXT_LICENSINGSITE = "Licensing Site Settings"
const PROP_OBJECT_TEXT_SITESETTINGS = "Site Settings"
const PROP_OBJECT_EDIT_DEFAULTSITESERVERS = "~/Configuration/Sites/"
const PROP_OBJECT_EDIT_TESTSITESERVERPREFIX = "~/Configuration/Sites/"
const PROP_OBJECT_EDIT_TESTSITESERVERSUFFIX = "/Servers"
const PROP_OBJECT_CLASS_SERVERSCONTAINER = "Servers Container"
const PROP_OBJECT_CLASS_DOMAINCONTROLLERSETTINGS = "Domain Controller Settings"


const PROP_SECURITY_BTN_ADD =		"A&dd..."
const PROP_SECURITY_BTN_REMOVE =	"&Remove"
const PROP_SECURITY_BTN_ADVANCED =	"Ad&vanced"
const PROP_SECURITY_TEXT_GROUPORUSERNAMES = "&Group or user names:"
const PROP_SECURITY_TEXT_PERMISSIONS = "~&Permissions for"
const PROP_SECURITY_TEXT_ALLOW =	"Allow"
const PROP_SECURITY_TEXT_DENY =		"Deny"
const PROP_SECURITY_TEXT_FULLCONTROL = "Full Control"
const PROP_SECURITY_TEXT_READ =		"Read"
const PROP_SECURITY_TEXT_WRITE =	"Write"
const PROP_SECURITY_TEXT_CREATEALLCHILD = "Create All Child Objects"
const PROP_SECURITY_TEXT_DELETEALLCHILD = "Delete All Child Objects"
const PROP_SECURITY_TEXT_OPENCONNECTORQUEUE = "Open Connector Queue"
const PROP_SECURITY_TEXT_ABANDONREPLICATION = "Abandon Replication"
const PROP_SECURITY_TEXT_ALLOCATERIDS = "Allocate Rids"
const PROP_SECURITY_TEXT_CHECKSTALEPHANTOMS = "Check Stale Phantoms"
const PROP_SECURITY_TEXT_DOGARBAGECOLLECTION = "Do Garbage Collection"
const PROP_SECURITY_TEXT_RECALCHIERARCHY = "Recalculate Hierarchy"
const PROP_SECURITY_TEXT_RECALCSECURITYINHERITANCE = "Recalculate Security Inheritance"
const PROP_SECURITY_TEXT_REFRESHGROUPCACHE = "Refresh Group Cache for Logons"
const PROP_SECURITY_TEXT_SPECIALPERMISSIONS = "Special Permissions"
const PROP_SECURITY_TEXT_FORSPECIALPERMISIONS = "For special permissions or for advanced settings, click Advanced."
const PROP_SECURITY_VIEW_ADMINISTRATORS = "~Administrators"
const PROP_SECURITY_VIEW_AUTHENTICATEDUSERS = "Authenticated Users"
const PROP_SECURITY_VIEW_DOMAINADMINS = "~Domain Admins"
const PROP_SECURITY_VIEW_ENTERPRISEADMINS = "~Enterprise Admins"
const PROP_SECURITY_VIEW_ENTERPRISEDCS = "ENTERPRISE DOMAIN CONTROLLERS"
const PROP_SECURITY_VIEW_SYSTEM =	"SYSTEM"

const PROP_TAB_SITE =				"Site"
const PROP_SITE_TEXT_SUBNETS =		"&Subnets:"

const PROP_TAB_LOCATION =			"Location"
const PROP_LOCATION_TEXT_LOCATION =	"&Location:"

const PROP_TAB_GROUPPOLICY =		"Group Policy"
const PROP_GROUPOLICY_TEXT_CURRENT = "~Current Group Policy Object Links"

const PROP_TAB_LICENSINGSETTINGS =	"Licensing Settings"
const PROP_LICENSE_TEXT_COMPUTER =	"&Computer:"
const PROP_LICENSE_TEXT_DOMAIN =	"D&omain:"

const PROP_NTDSSITE_CHKBOX_OVERRIDE = "&Override inherited schedule"
const PROP_NTDSSITE_CHKBOX_GCLESS =	"Enable &GC-less logon"
const PROP_NTDSSITE_TEXT_SERVER =	"&Server:"
const PROP_NTDSSITE_TEXT_SITE =		"Sit&e:"
const PROP_NTDSSITE_TEXT_REFRESH =	"&Refresh cache from GC in site:"
const PROP_NTDSSITE_BTN_CHANGESCHEDULE = "&Change Schedule..."

const PROP_NTDSSETTINGS_DNSEDITTEXT = "~.microsoft.com"
const PROP_COMBO_NTDSSETTINGS_DEFAULTQUERY = "Default Query Policy"


'Dialog Caption Strings
const DLG_CAP_SELECTUSERS =			"Select Users, Computers, or Groups"
const DLG_CAP_ADVANCEDSECURITY =	"Advanced Security Settings for "
const DLG_CAP_BROWSELOCATION =		"Browse for Location"
const DLG_CAP_SELECTCOMPUTER =		"Select Computer"
const DLG_CAP_NTDSSITESCHEDULE =	"Schedule for NTDS Site Settings"
const DLG_CAP_CONNECTTOFOREST =		"Connect to Forest"
const DLG_CAP_CONNECTTODC =			"Connect to Domain Controller"
const DLG_CAP_DELETING_DC =			"Deleting Domain Controller"


'Text for DC deletion dialog
const DLG_DCDEL_TEXT_MAINDESC =			"~The NTDS Settings object you " + _
												"want to delete represents Active Directory domain controller"
const DLG_DCDEL_DEMOTE_DC =				"I want to &demote this domain controller " + _
												"from the domain and continue using it as a computer."
const DLG_DCDEL_RESTART_AD =			"I want to &restart Active Directory replication for this domain controller."
const DLG_DCDEL_OFFLINE_DC =			"This domain controller is permanently offline and can no longer " + _
												"be demoted using the Active Directory Installation Wizard (DCPROMO)."

'New Site Creation Dialog

const NEW_SITE_NAME_EDIT = "N&ame:"     ' Add this part to german UI strings part. LastFrontier
const NEW_SITE_SITELINK_LISTBOX = "~&Select a site link object"

const MMC_VIEW_FILTER_OPTIONS = "&Filter Options..."
const MMC_VIEW_CUSTOMIZE = "C&ustomize..."





'$endif  _STRINGS_ENG_UI
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\sv2_verify.inc ===
'=============================================================================
'   Include:    sv2_verify.inc
'
'	RAW code copied from existing verify.inc on 12-1-2000
'	I wanted to make function-based and add more conventions
'	and didn't want to put gigantic pocks in other people's tests
'
'=============================================================================
'   Purpose:	Routines for verify the contents and state of
'							various Windows controls.  If the the contents
'							and state match the parameters, then simply return.
'							If they don't match, log an error and "fail" the scenario.
'
'-----------------------------------------------------------------------------
' Dependencies:	  strings.inc
'
' Notes:        
'-----------------------------------------------------------------------------
' Subroutine/Function List:
'
' Sub bVerify_MenuText (item$, text$, enabled_state$ = Enabled, gray_state$ = NotGray, 
' 	marked_state$ = Unmarked)
' Sub bVerify_TipsText (control$, text$)
' Sub bVerify_ToolButton (control$, button$, text$, tip$, enabled_state$ = Enabled)

'Function bVerify_Button(	sControl as String, _
'							sText as String, _
'							bEnabledState = CTL_ENABLED as integer) as Integer

'Function bVerify_OptionButton(	sControl as String, _
'								sText as String, _
'								bEnabledState as Long, _
'								bMarkedState as Long) as Long

'Function bVerify_CheckBox (	sControl as String, _
'								sText as String, _
'								bEnabledState=ENABLED as integer, _
'								bMarkedState=CHECKED as integer) as Integer

' Sub bVerify_ViewHeaderText (control$, header$, text$)

'Function bVerify_ViewItemText(	sControl as String, _
'								sItem as String, _
'								sSubItem="1" as String, _
'								sExpectedText as String,
'								bClick=TRUE as integer,
'								iButton=VK_LBUTTON) as Integer

' Sub bVerify_TreeItemText (control$, item$ = NULL, text$ = DontCare, )
' Sub bVerify_StatusItemText (control$, item$, text$)

'Function bVerify_StaticText (	sControl as String, _
'								sExpectedText as String ) as Integer

'Function bVerify_EditText(	sControl as String, _
'							sExpectedText=NULL as String, _
'							sStaticControl=NULL as String, _
'							sStaticText=NULL as String, _
'							bEnabledState=TRUE as Integer ) as Integer

' Sub bVerify_LineOfMultiEdit( control$, lineNo%, text$, Static_Text$ )
' Sub bVerify_MultiEditText (control$, lines() as string, Static_Control$ = NULL,_
'										Static_Text$ = "", enabled_state$ = Enabled)
'
'Function bVerify_ComboItemText(	sControl as String, _
'									iText as Integer, _
'									sText as String,
'									bSelectItem=FALSE as Integer) as Integer

' Sub bVerify_SpinPosition (control$, position, Static_Control$ = NULL, Static_Text$ = "")

'Function bVerify_TabItem (	sControl as string, _
'							sItem as string, _
'							sText as string, _
'							bSelectTab=FALSE as Long) as Integer

' Sub bVerify_WindowTitle (text$)
' Sub bVerify_GroupBoxText (text$)

' VerifyDockingView
' VerifyScopePane
'
'Function bVerify_ListItemText(	sControl as String, _
'								sItem as String, _
'								sExpectedText as String, _
'								bClick=TRUE as Integer, _
'								iButton=VK_LBUTTON) as Integer
'
'-----------------------------------------------------------------------------
' Revision History:
'
'       [ 0 ]    da-mon-year         Name   : action
'		  [ 1 ]		03-Sep-1996			kirkl	  : Created by removing procedures from api.inc
'       [ 2 ]     03-Nov-1996       oanan   : added logging level
'-----------------------------------------------------------------------------
'$IFNDEF bVerify_INC
'$DEFINE bVerify_INC

'$include	'util.inc'

const CTL_ENABLED	= TRUE
const CTL_DISABLED	= FALSE

const DontCare       = "Don't care"


const Enabled        = "Enabled"
const Disabled       = "Disabled"
const ToBeRemoved    = "To be removed"
const ToBeImplem     = "To be implemented"

const Marked         = "Marked"
const Unmarked       = "Unmarked"
const Visible        = "Visible"
const Hidden         = "Hidden"
                     
const Gray           = "Gray"
const NotGray        = "Not Gray"

'==============================================
'  bVerify_MenuText 
'	Checks a menu item to make sure it has the right text.
'==============================================
	Sub bVerify_MenuText (item$, text$, enabled_state$ = Enabled, gray_state$ = NotGray,_ 
								marked_state$ = Unmarked)
	
	LogIt( LVL_VERBOSE, "Verifying that the menu item "+item$+" """+text$+""" exists, has state "+enabled_state$+" and is "+marked_state$+".")
	if not WMenuExists (item$) then
		LogIt( LVL_VERBOSE, "The menu item "+item$+" """+text$+""" does not exist.")
	else 
	if not MenuFullText (item$) = text$ then
		LogIt( LVL_VERBOSE, "The menu item """+item$+""" should say """+text$+""" not """+MenuFullText (item$)+"""")
	else
	if enabled_state = ToBeImplem then
      LogIt( LVL_VERBOSE, "The Menu item """+text$+""" should be implemented.")
   else
	if enabled_state = ToBeRemoved then
      LogIt( LVL_VERBOSE, "The Menu item """+text$+""" should be removed.")
   else
   if not (WMenuEnabled (item$) = (enabled_state$ = Enabled)) then
		LogIt( LVL_VERBOSE, "The Menu item """+text$+""" should be "+enabled_state$+".")
	else
	if not (WMenuGrayed (item$) = (gray_state$ = Gray)) then
		LogIt( LVL_VERBOSE, "The Menu item """+text$+""" should be "+gray_state$+".")
	else
	if not (WMenuChecked (item$) = (marked_state$ = Marked)) then
		LogIt( LVL_VERBOSE, "The Menu item """+text$+""" should be "+marked_state$+".")
	end if
	end if
	end if
	end if
	end if
   end if
   end if
End Sub

'==================================================
'  bVerify_TipsText 
'	Checks tool tips for correct text.  Note: the pointer most be 
'	over the tool bar button for this to work.
'==================================================
Sub bVerify_TipsText (control$, text$)
	
	LogIt( LVL_VERBOSE, "Verifying that the tool tip "+control$+" says """+text$+""".")

	if not WTipsExists (control$, 1) then
		FailIt( LVL_VERBOSE, "The tool tip "+control$+" """+text$+""" does not exist.")
	else 
	if not TipsText (control$) = text$ then
		FailIt( LVL_VERBOSE, "The tool tips text "+control$+" should say """+text$+""" not """+TipsText (control$)+"""")
	end if
	end if
End Sub

'===============================================
' bVerify_ToolbarButton 
'	Checks a toolbar button for existance and correct text.
'===============================================
Sub bVerify_ToolButton (control$, button$, text$, tip$, enabled_state$ = Enabled)
	
	LogIt( LVL_VERBOSE, "Verfiying that the tool bar button "+button$+" """+text$+""" exists,")
	LogIt( LVL_VERBOSE, TAB + "is "+enabled_state$+" and displays the tip """+tip$+""".")

	if not WToolbarExists (control$) then
		LogIt( LVL_VERBOSE, "The tool bar "+control$+" does not exist." )
	else 
	'BUGBUG it seems that this gets stuck here if one of the buttons is missing, but normally exists.
	if not WToolbarButtonExists (control$, button$) then
		LogIt( LVL_VERBOSE, "The tool bar button "+button$+" """+text$+""" does not exist.")
	else 
	if not ToolbarButtonText (control$, button$) = text$ then
		LogIt( LVL_VERBOSE, "The tool bar button "+button$+" should say """+text$+""" not """+ToolbarButtonText (control$, button$)+"""")
	else 
  	if enabled_state = ToBeImplem then
      LogIt( LVL_VERBOSE, "The tool bar button """+text$+""" should be implemented.")
   else
	if not (WToolbarButtonEnabled (control$, button$) = (enabled_state$ = Enabled)) then
		LogIt( LVL_VERBOSE, "The toolbar button "+button$+" """+text$+""" should be "+enabled_state$+".")
	else
	WToolbarButtonMoveTo (control$, button$)
	if not WTipsExists ("@1", MIN_WAIT) then
		LogIt( LVL_VERBOSE, "The tool bar button "+button$+" did not have a tool tip """+tip$+".""")
	else
	if not TipsText ("@1") = tip$ then
		LogIt( LVL_VERBOSE, "The tool tip for button "+button$+" should say "+tip$+" not "+TipsText ("@1")+".")
	end if
	end if
	end if
	end if
	end if
	end if
   end if
End Sub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_Button
'
'	Checks for existence of command button and then compares text and state
'
'	PARAMETERS
'		sControl - Name or ordinal of the button control
'		sText - Text expected on the button control
'		bEnabledState - State of the button
'
'	RETURN VALUE
'		TRUE if control exists and the options match
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_Button(	sControl as String, _
							sText as String, _
							bEnabledState=CTL_ENABLED as integer) as Integer
	
	EnterSub("bVerify_Button - Button[" + sControl + "]:Text[" + sText + "]:Enabled[" + str$(bEnabledState) + "]")


'Assume verification will fail
	bVerify_Button = FALSE



'Verify that a button with this identifier exists
	if WButtonExists(sControl) = FALSE then

		LogIt( LVL_VERBOSE, "The button [" + sControl + "] does not exist.")



'Verify that a button with this text exists
	elseif wButtonExists(sText) = FALSE then

		LogIt( LVL_VERBOSE, "The button [" + sText + "] does not exist.")



'Verify that they are the same button
	elseif wButtonFind(sControl) <> WButtonFind(sText) then
	
		LogIt( LVL_VERBOSE, "The button [" + sControl + "] should read [" + sText + _
				"] but instead reads [" + GetText(wButtonFind(sControl)) + "].")
	


'Verify the state of the button
	elseif bEnabledState <> wButtonEnabled(sControl) then

		LogIt( LVL_VERBOSE, "The state of button [" + sText + "] is [" + _
				str$(wButtonEnabled(sControl)) + "] but should be in state [" + _
				str$(benabledState) + "].")



'Button checks out.
	else

		bVerify_Button = TRUE

	end if

	ExitSub("bVerify_Button")

End Function 'bVerify_Button


'==================================
' bVerify_Button_Extended 

'  this is an extended version of verifying that a button 
'  exists and is enabled.  This function was originally 
'  developed to support extened versions of the VT 
'  button functions, such as wButtonClick or wButtonDblClk
'  this version is intended to be more robust and to help
'  supply more debugging info, if needed, than 
'  the function bVerify_Button.  Also, as compared to bVerify_Button
'  checking is done by button control (strButtonID) which may 
'  either be text, ordinal, or handle.  Hence no button text 
'  checking is done by this function.
'==================================

sub bVerify_Button_Extended ( strButtonID$ )

	dim loopCount%
	dim isReady%

	EnterSub ( "bVerify_Button_Extended", LVL_DEBUGGING )

	'1) ensure that button EXISTS

	'initialize loop control variables
	loopCount = 1
	isReady = FALSE

	'verify existance	
	if not ( wButtonExists ( strButtonID )) then

		 LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
									 strButtonID +_
									 "' button NOT found or NOT ready, " +_
									 "will wait and check again" )
	
		'wait a while and give the button a chance to "appear"
		'it may be that VT is running faster than the 
		'system under test
		while ( loopCount <= MIN_TRY ) and ( isReady = FALSE )
			
			'wait a brief period for button to be ready
			LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: " +_
										"waiting 1 second..." )
			sleep MIN_WAIT

			'check if button is now ready
			if not ( wButtonExists ( strButtonID )) then

				'advance loopCount
				loopCount = loopCount + 1
				
				'if button has not appeared after 1 second, then possible performance bug
				LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
												  strButtonID +_
												  "' button STILL NOT FOUND, " +_
												  "possible performance bug." )
			else 					

		 		LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
											  strButtonID +_
											  "' button is now ready" )

				isReady = TRUE

			end if

		wend

		'report button existence status
 		if ( isReady = FALSE ) then

			FailIt ( LVL_VERBOSE, "bVerify_Button_Extended: '" +_
										 strButtonID +_
										 "' button NOT FOUND after " +_
										 trim(str(MIN_TRY*MIN_WAIT)) +_
										 " seconds" )

		else

			LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
										strButtonID +_
										"' button FOUND after " +_
										trim(str(loopCount)) +_
										" seconds" )

		end if

	else

		LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
									 strButtonID +_
									 "' button exists" )
									 
	end if
	
		
	'2) ensure that button is ENABLED

	'initialize loop control variables
	loopCount = 1
	isReady = FALSE

	'verify ENABLED state	
	if not ( wButtonEnabled ( strButtonID )) then

		 LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
									   strButtonID +_
									   "' button NOT enabled or NOT ready, " +_
									   "will wait and check again" )
	
		'wait a while and give the button a chance to "appear"
		'it may be that VT is running faster than the 
		'system under test
		while ( loopCount <= MIN_TRY ) and ( isReady = FALSE )
			
			'wait a brief period for button to be ready
			LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: " +_
										  "waiting 1 second..." )
			sleep MIN_WAIT

			'check if button is now ready
			if not ( wButtonEnabled ( strButtonID )) then

				'advance loopCount
				loopCount = loopCount + 1
				
				'if button is not enabled after 1 second then possible performance bug
				LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
											     strButtonID +_
											     "' button STILL NOT ENABLED, " +_
												  "possible performance bug." )
			else 					

		 		LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
											  strButtonID +_
											  "' button is now enabled" )

				isReady = TRUE

			end if

		wend

		'report button enabled status
 		if ( isReady = FALSE ) then

			FailIt ( LVL_VERBOSE, "bVerify_Button_Extended: '" +_
										 strButtonID +_
										 "' button NOT ENABLED after " +_
										 trim(str(MIN_TRY*MIN_WAIT)) +_
										 " seconds" )

		else

			LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
										  strButtonID +_
										  "' button ENABLED after " +_
										  trim(str(loopCount)) +_
										  " seconds" )

		end if

	else

		LogIt ( LVL_DEBUGGING, "bVerify_Button_Extended: '" +_
									  strButtonID +_
									  "' button enabled " )
									 
	end if
			

	ExitSub ( "bVerify_Button_Extended", LVL_DEBUGGING )

end sub 'Verify_Button_Extended


'==================================
' bVerify_ViewItem_Extended 

'  this is an extended version of verifying that a ViewItem 
'  exists.  This function was originally 
'  developed to support extened versions of the VT 
'  ViewItem functions, such as wViewItemClk or wViewItemDblClk
'  this version is intended to be more robust and to help
'  supply more debugging info, if needed, than 
'  the function bVerify_ViewItemText.  Also, as compared to bVerify_ViewItemText
'  checking is done by ViewItem control (strViewItemID) which may 
'  either be text, ordinal, or handle.  Hence no ViewItem text 
'  checking is done by this function.
'==================================

sub bVerify_ViewItem_Extended ( strListView$, strViewItemID$, shouldExist%=TRUE )

	dim loopCount%
	dim isReady%

	EnterSub ( "bVerify_ViewItem_Extended" )

	' ensure that ViewItem EXISTS

	'initialize loop control variables
	loopCount = 1
	isReady = FALSE

	if ( shouldExist = TRUE ) then

		'verify existance	
		if not ( wViewItemExists ( strListView, strViewItemID )) then

			 LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
										 strViewItemID +_
										 "' ViewItem NOT found or NOT ready, " +_
										 "will wait and check again" )
	
			'wait a while and give the ViewItem a chance to "appear"
			'it may be that VT is running faster than the 
			'system under test
			while ( loopCount <= MIN_TRY ) and ( isReady = FALSE )
			
				'wait a brief period for ViewItem to be ready
				LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: " +_
											"waiting 1 second..." )
				sleep MIN_WAIT

				'check if ViewItem is now ready
				if not ( wViewItemExists ( strListView, strViewItemID )) then

					'advance loopCount
					loopCount = loopCount + 1
				
					LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
												strViewItemID +_
												"' ViewItem STILL NOT FOUND" )
				else 					

			 		LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
												strViewItemID +_
												"' ViewItem is now ready" )

					isReady = TRUE

				end if

			wend

			'report ViewItem existence status
	 		if ( isReady = FALSE ) then

				FailIt ( LVL_VERBOSE, "bVerify_ViewItem_Extended: '" +_
											 strViewItemID +_
											 "' ViewItem NOT FOUND after " +_
											 trim(str(MIN_TRY*MIN_WAIT)) +_
											 " seconds" )

			else

				LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
											strViewItemID +_
											"' ViewItem FOUND after " +_
											trim(str(loopCount)) +_
											" seconds" )

			end if

		else

			LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
										 strViewItemID +_
										 "' ViewItem exists" )
									 
		end if

	else

		'( shouldExist = FALSE )

		'verify NON-existance	
		if not ( wViewItemExists ( strListView, strViewItemID )) then

			 LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
											strViewItemID +_
											"' ViewItem NOT found or NOT ready, " +_
											"will wait and check again" )
	
			'wait a while and give the ViewItem a chance to "appear"
			'it may be that VT is running faster than the 
			'system under test
			while ( loopCount <= MIN_TRY ) and ( isReady = FALSE )
			
				'wait a brief period for ViewItem to be ready
				LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: " +_
											"waiting 1 second..." )
				sleep MIN_WAIT

				'check if ViewItem is now ready
				if not ( wViewItemExists ( strListView, strViewItemID )) then

					'advance loopCount
					loopCount = loopCount + 1
				
					LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
													strViewItemID +_
													"' ViewItem still not found" )
				else 					

			 		LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
												  strViewItemID +_
												  "' ViewItem is now ready" )

					isReady = TRUE

				end if

			wend

			'report ViewItem NON-existence status
	 		if ( isReady = TRUE ) then

				FailIt ( LVL_VERBOSE, "bVerify_ViewItem_Extended: '" +_
											 strViewItemID +_
											 "' ViewItem FOUND after " +_
											 trim(str(MIN_TRY*MIN_WAIT)) +_
											 " seconds" )

			else

				LogIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
												strViewItemID +_
												"' ViewItem not found after " +_
												trim(str(loopCount)) +_
												" seconds" )

			end if

		else

			FailIt ( LVL_DEBUGGING, "bVerify_ViewItem_Extended: '" +_
										   strViewItemID +_
										   "' ViewItem should NOT be in list" )
									 
		end if

	end if

	ExitSub ( "bVerify_ViewItem_Extended" )

end sub 'Verify_ViewItem_Extended



'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_OptionButton
'
'	Checks for existence of Option Button and then compares state as well expected and actual text.
'
'	PARAMETERS
'		sControl - Name or ordinal of the Option Button control
'		sText - Expected text associated with the Option Button
'		bEnabledState - Whether or not the Option Button is accessible
'		bMarkedState - Whether or not the Option Button is Selected
'
'	RETURN VALUE
'		TRUE if control exists and text/state matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_OptionButton(	sControl as String, _
								sText as String, _
								bEnabledState as Long, _
								bMarkedState as Long) as Long

	EnterSub("bVerify_OptionButton - Control[" + sControl + "]:Text[" + sText + "]:Enabled[" + _
			str$(bEnabledState) + "]:Marked[" + str$(bMarkedState) + "]")


'Assume verification will fail at some point
	bVerify_OptionButton = FALSE



'Verify that the specified Radio button exists
	if wOptionExists(sControl, MAX_WAIT) = FALSE then

		LogIt(LVL_STATUSINFO, "Option button [" + sControl + "] not found.")



'Verify that the text of the button matches expected
	elseif instr(GetText(wOptionFind(sControl)), sText) = FALSE then

		LogIt(LVL_STATUSINFO, "Option button [" + sControl + "] should have text [" + sText + _
				"], but was found to read [" + GetText(wOptionFind(sControl)) + "].")



'Verify that the button is enabled/disabled as expected
	elseif wOptionEnabled(sControl) <> bEnabledState then
		
		LogIt(LVL_STATUSINFO, "Option button [" + sControl + "] expected to be in Enabled State [" + _
				str$(bEnabledState) + "], but found set to [" + str$(wOptionEnabled(sControl)) + "].")



'Verify that the marked state of the option button is correct.  Unfortunately, marked on an option
'button = 1, not -1....

	elseif (wOptionState(sControl) <> bMarkedState) AND _
			(bMarkedState = FALSE OR wOptionState(sControl) = FALSE) then


		LogIt(LVL_STATUSINFO, "Option button [" + sControl + "] expected to be in Marked State [" + _
				str$(bMarkedState) + "], but found set to [" + str$(wOptionState(sControl)) + "].")


	else
'If here then all checks passed.....
		
		bVerify_OptionButton = TRUE

	end if


	ExitSub("bVerify_OptionButton")

End Function 'bVerify_OptionButton

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_CheckBox
'
'	Checks for existence of CheckBox and then compares expected and actual text.
'
'	PARAMETERS
'		sControl - Name or ordinal of the check box control
'		sText - Expected text associated with the check box
'		bEnabledState - Whether or not the check box is accessible
'		bMarkedState - Whether or not the check box is checked
'
'	RETURN VALUE
'		TRUE if control exists and text matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_CheckBox (	sControl as String, _
							sText as String, _
							bEnabledState=CTL_ENABLED as integer, _
							bMarkedState=-1 as integer) as Integer
	
	EnterSub("bVerify_CheckBox - Control[" + sControl + "]:Text[" + sText + "]:Enabled[" + _
			str$(bEnabledState) + "]:Marked[" + str$(bMarkedState) + "]")



	'----- Assume verification will fail at some point -----
	Dim bLocalResult as Long
	bLocalResult = FALSE



'Verify that the check box exists
	if wCheckExists(sControl) =FALSE then

		LogIt( LVL_VERBOSE, "The check box [" + sControl + "] does not exist.")



'Verify the text associated with the checkbox

	elseif GetText(wCheckFind(sControl)) <> sText then

		LogIt(LVL_VERBOSE, "CheckBox[" + sControl +"] should read [" + stext + _
				"] but instead reads [" + GetText(wCheckFind(sControl)) + "]")



'Verify the enabled state of the box
	elseif wCheckEnabled(sControl) <> bEnabledState then

		LogIt( LVL_VERBOSE, "The check box [" + sText + "] is in the wrong enabled state.")



	'----- if requested by calling function, check marked state -----
	elseif bMarkedState <> -1 then


		if wCheckState(sControl) <> bMarkedState then

			LogIt( LVL_VERBOSE, "The check box [" + sText + "] is wrongly marked.")

		else

			bLocalResult = TRUE

		end if


	else
	
'Check box passed
		bLocalResult = TRUE
		
	end if

	bVerify_Checkbox = bLocalResult
	

	ExitSub("bVerify_CheckBox - RESULT=[" + str$(bLocalResult) + "]")

End Function 'bVerify_CheckBox

'============================================
' bVerify_ViewHeaderText 
'	Checks a header to make sure it has the right text.
'============================================
Sub bVerify_ViewHeaderText (control$, header$, text$)
	
	LogIt( LVL_VERBOSE, "Verifying that the list view header "+header$+" """+text$+""" exists.")

	if not WViewExists (control$) then
		FailIt( LVL_VERBOSE, "The list view "+control$+" does not exist.")
	else 
	if not WViewHeaderExists (control$, header$) then
		FailIt( LVL_VERBOSE, "The list view header "+header$+" """+text$+""" does not exist.")
	else 
	if not ViewHeaderText (control$, header$) = text$ then
		FailIt( LVL_VERBOSE, "The list view header "+header$+" should say """+text$+""" not """+ViewHeaderText (control$, header$)+"""")
	end if
	end if
	end if
End Sub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_ViewItemText
'
'	Checks for existence of View Item and then compares expected and actual text.
'	Then clicks the item by default.
'
'	PARAMETERS
'		sControl - Name or ordinal of the View control
'		sItem - Name or ordinal of the view item
'		sSubItem - Column of the view list to review
'		sExpectedText - Text expected on the view item
'		bClick - whether or not to click the view item (TRUE by default)
'		iButton - Button to use to click (Left button by default)
'
'	RETURN VALUE
'		TRUE if control exists and text matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_ViewItemText(	sControl as String, _
								sItem as String, _
								sSubItem=NULL as String, _
								sExpectedText as String, _
								bClick=TRUE as Integer, _
								iButton=VK_LBUTTON) as Integer
	
	EnterSub("bVerify_ViewItemText - Control[" + sControl + "]:sItem[" + sItem + "]:Column[" + _
			sSubItem + "]:Text[" + sExpectedText + "]")


'Assume vericifactions will fail
	bVerify_ViewItemText = FALSE



'Verify that the View control exists
	if wViewExists(sControl) = FALSE then

		LogIt(LVL_STATUSINFO, "View control could not be found.")



'Verify that the individual item exists
	elseif wViewItemExists(sControl, sItem) = FALSE then
	
		LogIt(LVL_STATUSINFO,"View item [" + sItem + "] control could not be found.")



'If the sub item parameter is not null, check it
	elseif sSubItem <> NULL then

'Verify that the subItem, (header/column), exists
		if wViewHeaderExists(sControl, sSubItem) = FALSE then
	
			LogIt(LVL_STATUSINFO,"The header/column [" + sSubItem + "] not found on view control [" + sControl + "].")



'Verify the text itself - if the expected text begins with a tilde, (VT WILDCARD), then
'check for partial match, else check exact string
		elseif Left(sexpectedText, 1) = "~" then

			if instr(ViewItemText(sControl, sItem), _
					Right(sExpectedText, len(sExpectedText) - 1)) = FALSE then

				LogIt(LVL_STATUSINFO,"The view item [" + sItem + "] should contain text [" + _
						sExpectedText + "] but reads [" + ViewItemText(sControl, sItem, sSubItem) + "].")

			else

				bVerify_ViewItemText = TRUE

'Click on the item if requested by user
				if bClick = TRUE then

					wViewItemClk(sControl, sItem, iButton)
					bVerify_ViewItemText = TRUE
					Sleep MIN_WAIT

				end if

			end if



'If here, then checking for an exact string...
		elseif ViewItemText(sControl, sItem, sSubItem) <> sExpectedText then

			LogIt(LVL_STATUSINFO, "The view item [" + sItem + "] should have text [" + _
					sExpectedText + "] but reads [" + ViewItemText(sControl, sItem, sSubItem) + "].")

		else

			bVerify_ViewItemtext = TRUE

'Click on the item if requested by user
			if bClick = TRUE then

				wViewItemClk(sControl, sItem, iButton)
				bVerify_ViewItemText = TRUE
				Sleep MIN_WAIT

			end if

		end if
				
				
				
'No sub item sent.  Check default.  Check situation of partial string first.
	elseif Left(sExpectedText, 1) = "~" then

		if instr(ViewItemText(sControl, sItem), _
				Right(sExpectedText, len(sExpectedText) - 1)) = FALSE then

			LogIt(LVL_STATUSINFO,"The view item [" + sItem + "] should contain text [" + _
					sExpectedText + "] but reads [" + ViewItemText(sControl, sItem) + "].")

		else

			bVerify_ViewItemText = TRUE

'Click on the item if requested by user
			if bClick = TRUE then

				wViewItemClk(sControl, sItem, iButton)
				bVerify_ViewItemText = TRUE
				Sleep MIN_WAIT

			end if


		end if
			


'If here, then checking for an exact string...
	elseif ViewItemText(sControl, sItem) <> sExpectedText then

		LogIt(LVL_STATUSINFO, "The view item [" + sItem + "] should have text [" + _
				sExpectedText + "] but reads [" + ViewItemText(sControl, sItem) + "].")

'The view item checks out clean...
	else

		bVerify_ViewItemText = TRUE

'Click on the item if requested by user
		if bClick = TRUE then

			wViewItemClk(sControl, sItem, iButton)
			bVerify_ViewItemText = TRUE
			Sleep MIN_WAIT

		end if


	end if

	ExitSub("bVerify_ViewItemText")
	
End Function 'bVerify_ViewItemText

'==========================================
' bVerify_TreeItemText 
'	Checks an item to make sure it has the right text.
'==========================================
Sub bVerify_TreeItemText (control$, item$ = NULL, text$ = DontCare, )
	
	if( text$ = DontCare ) then
		LogIt( LVL_VERBOSE, "Verifying that the tree item "+control$+" """+item$+""" exists.")
	else
		LogIt( LVL_VERBOSE, "Verifying that the tree item "+control$+" """+item$+""" """+text$+""" exists.")
	end if

	
	if not WTreeExists (control$) then
		FailIt( LVL_VERBOSE, "The tree "+control$+" does not exist.")
	else 
	if not WTreeItemExists (control$, item$) then
		FailIt( LVL_VERBOSE, "The tree item "+item$+" """+text$+""" does not exist.")
	else 
	if not (TreeItemText (control$, item$) = text$) or (text$ = DontCare) then
		FailIt( LVL_VERBOSE, "The tree item "+item$+" should say """+text$+""" not """+TreeItemText (control$, item$)+"""")
	end if
	end if
	end if
End Sub

'-----------------------------------------------------------------------------
' bVerify_StatusItemText checks an item to make sure it has the right text.
'-----------------------------------------------------------------------------
Sub bVerify_StatusItemText (control$, item$, text$)
	
	LogIt( LVL_VERBOSE, "Verifying that the status bar item "+item$+" """+text$+""" exists.")

	if not WStatusExists (control$) then
		FailIt( LVL_VERBOSE, "The status bar "+control$+" does not exist.")
	else 
	if not WStatusItemExists (control$, item$) then
		FailIt( LVL_VERBOSE, "The status bar item "+item$+" """+text$+""" does not exist.")
	else 
	if not StatusItemText (control$, item$) = text$ then
		LogIt( LVL_VERBOSE, "The status bar item "+item$+" should say """+text$+""" not """+StatusItemText (control$, item$)+"""")	
	end if
	end if
	end if
End Sub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_StaticText
'
'	Checks for existence of Static Item and then compares expected and actual text
'
'	PARAMETERS
'		sControl - Name or ordinal of the static control
'		sExpectedText - Text expected on the static control
'
'	RETURN VALUE
'		TRUE if control exists and text matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_StaticText (	sControl as String, _
								sExpectedText as String ) as Integer
	
	dim strActualText as String

	EnterSub ( "bVerify_StaticText - Control:[" + sControl + "] Text:[" + sExpectedText + "]")


'Assume that the result will be failure
	bVerify_StaticText = FALSE
	

'Ensure that the static control exists
	if WStaticExists(sControl) = FALSE then
	
		LogIt(LVL_VERBOSE, "Specified static control does not exist.")


'If the function was called with no text to verify, then the
'assumption is that no validation is to occur.  Make note and
'drop out of function
	elseif sExpectedText = NULL then
		
		LogIt(LVL_VERBOSE, "No text comparison requested by calling function.")
		bVerify_StaticText = TRUE


'Do text verification...
	else
		

'if the initial character is the tilde, (VT wildcard), then look for the string
'inside of the other string, else look for a total match
		if left(sExpectedText, 1) = "~" then

			if instr(StaticText(sControl, MAX_WAIT), Right(sExpectedText, len(sExpectedText) - 1)) = FALSE then


				LogIt(LVL_VERBOSE, "Static control [" + sControl + "] should contain [" + _
						sExpectedText + "] but instead reads [" + StaticText(sControl, MAX_WAIT) + "]")

			else

				bVerify_StaticText = TRUE

			end if

		elseif sExpectedText <> StaticText(sControl, MAX_WAIT) then
			
			LogIt(LVL_VERBOSE, "Static control [" + sControl + "] should read [" + _
					sExpectedText + "] but instead reads [" + StaticText(sControl, MAX_WAIT) + "]")
		else

'If here, then all control is setup as expected
			bVerify_StaticText = TRUE

		end if
	
	end if

	ExitSub ( "bVerify_StaticText" )

End Function 'bVerify_StaticText

'==========================================
' bVerify_MultilineEditText 
'	Checks an item to make sure it has the right text.
'==========================================

Sub bVerify_MultiEditText (control$, lines() as string ,_
										Static_Control$ = NULL,_
										Static_Text$ = "",_
										enabled_state$ = Enabled)
	dim EditLinesCount%, ArraySize%, i%

	EnterSub ( "bVerify_MultiEditText" )
	
	LogIt( LVL_DEBUGGING, "Verifying that the multiline edit text item "+_
								control$ + " """+ Static_Text$ +_
                        """ exists, contains the correct lines " +_
                        "and is " + enabled_state)

	if not WEditExists (control$) then
		FailIt( LVL_VERBOSE, "The "+Static_Text$+" multiline edit box ("+control$+") does not exist.")
	end if

	EditLinesCount = WEditLines(control$)
	ArraySize = UBOUND( lines, 1 ) + 1 '0-base indexed array

	if( EditLinesCount <> ArraySize ) then
		FailIt( LVL_VERBOSE, "The "+Static_Text$+" multiline edit box ("+control$+_
									") contains " + str(EditLinesCount) + " lines instead of " +_
									str(ArraySize) + " !")
	endif

	for i = 1 to  EditLinesCount
'		Verify_LineOfMultiEdit( control, i, lines(i - 1), Static_Text$ )
	next i

	if not Static_Control$ = NULL then
		bVerify_StaticText (Static_Control$, Static_Text$)
	endif

	if not (WEditEnabled (control$) = (enabled_state$ = Enabled)) then
		FailIt( LVL_VERBOSE, "The "+Static_Text$+" edit box ("+control$+") should be "+enabled_state$+".")
	endif

	ExitSub ( "bVerify_MultiEditText" )

End Sub	'Verify_MultiEditText


Sub bVerify_LineOfMultiEdit( control$, lineNo%, text$, Static_Text$ )

	dim strEntireMultiText$
	dim hwndTemp&

	EnterSub ( "bVerify_LineOfMultiEdit" ) 
	
	LogIt( LVL_DEBUGGING,	"Verifying that text for the line " +_
								str(lineNo) + " in the " + Static_Text$ + _
								"multiline edit (" + control + ") is """ +_
								text$ + """ !")

	'get the window handle of the multi-line edit box
	hwndTemp = wEditFind ( control )

	'get the entire contents of the multi-line edit box
	strEntireMultiText = GetText ( hwndTemp )

	'pause "2)address line: " + strTemp

	'note: passing lineNo by value [by placing parentheses around the variable]
	if not (EditLineText (control, (lineNo)) = text$) then
		LogIt( LVL_DEBUGGING, "POSSIBLE ERROR: " +_
									 "The "+ Static_Text$ + " multiline edit box (" +_
									 + control$ + ") should say """ + text$ +_
									 """ not """ + EditLineText (control$, (lineNo))+_
									 """ on line " + str(lineNo) + " !")
		'bugbug: DBCS testing seems to fail this test, so adding an additional check
		LogIt( LVL_DEBUGGING, "...performing an additional check..." )
		'check compare the contents of the Entire Multi-line edit box with 
		'the string in question, to see if it is included there
		'"GetText" is a little more robust function than "EditLineText"
		if instr ( strEntireMultiText, text ) then
			'found the string we are looking for
			LogIt( LVL_DEBUGGING, "'" + text + "' found on second check" )
		else
			'still could not find the string we are looking for, report failure
			LogIt( LVL_VERBOSE, "'" + text + "' NOT found after 2 checks" )
		end if 
	else
		LogIt( LVL_DEBUGGING, "'" + text + "' found on first check" )	
	end if

	ExitSub ( "bVerify_LineOfMultiEdit" )

End Sub	'Verify_LineOfMultiEdit

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_EditText
'
'	Checks for existence of Edit Text and then verifies the contents
'
'	PARAMETERS
'		sControl - Name or ordinal of the tab control
'		sExpectedText - Text expected on the tab control
'		sStaticControl - ID of associated static control
'		sStaticText - Expected Text of associated static control
'		bEnabledState - Input state of this edit box
'
'	RETURN VALUE
'		TRUE if control exists and text matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_EditText(	sControl as String, _
							sExpectedText=NULL as String, _
							sStaticControl=NULL as String, _
							sStaticText=NULL as String, _
							bEnabledState=TRUE as Integer ) as Integer

	Dim bTemp as Long

	EnterSub ("bVerify_EditText - Control[" + sControl + "]:Text[" + sExpectedText + "]")


'Assume failure.  If all checks pass, will set to TRUE
	bVerify_EditText = FALSE



'First, ensure that the edit box exists
	if WEditExists(sControl) = FALSE then

		LogIt(LVL_VERBOSE, "EditBox Control was not found.")



'Verify text in the Edit Box.  If expected text begins with the tilde, (VT Wildcard),
'then check for partial match; else check for exact match.
	elseif left(sExpectedText, 1) = "~" then

		if instr(EditText(sControl, MAX_WAIT), Right(sExpectedText, len(sExpectedText) - 1) ) = FALSE then


			LogIt(LVL_VERBOSE, "Edit control [" + sControl + "] should contain [" + _
					sExpectedText + "] but instead reads [" + EditText(sControl, MAX_WAIT) + "]")

		else

			bVerify_EditText = TRUE


		end if

	elseif ((sExpectedText=NULL) OR (sExpectedText=EditText(sControl))) = FALSE then

		LogIt(LVL_VERBOSE, "Expected text [" + sExpectedtext + "] but edit box control read [" + _
				EditText(sControl) + "]")
	


'Verify the current state of the edit box
	elseif bEnabledState<>wEditEnabled(sControl) then

		if bEnabledState = FALSE then

			LogIt(LVL_VERBOSE, "Edit Box found ENABLED. Expected edit box to be disabled.")

		else

			LogIt(LVL_VERBOSE, "Edit box found DISABLED. Expected edit box to be enabled.")

		end if



'If Static Text is to be checked, do so now
	elseif sStaticControl<>NULL then

		if bVerify_StaticText(sStaticControl, sStaticText) = FALSE then

			LogIt(LVL_VERBOSE, "Static Box FAILED.  Failing Edit Box as parent process.")

		else

			bVerify_EditText = TRUE

		end if



'If here, then no check is being made against the associated static label for
'this edit box.  Therefore, everything checks out.
	else

		bVerify_EditText = TRUE
			
	end if

	ExitSub ("bVerify_EditText")

End Function 'Verify_EditText


'==========================================
' bVerify_ListBox 
'	Checks that a list box contains the proper state.
'==========================================

Sub bVerify_ListBox (control$, text$ = "", enabled_state$ = Enabled)
	
	if ( text$ = "" ) then

		LogIt ( LVL_VERBOSE, "Verifying that the list box " + control$ +_
                            " EXISTS and IS " + _
                              enabled_state + " and list IS empty.")
		   			  
		if not ( wListExists ( control$ ) ) then

			FailIt ( LVL_VERBOSE, "The list box " + control$ + " DOES NOT exist.")
 		endif

	
		if not ( wListCount ( control$ ) = 0 ) then

		FailIt ( LVL_VERBOSE, "The list box " + control$ + " IS NOT empty.")
		endif


		if not ( wListEnabled ( control$ ) = ( enabled_state$ = Enabled ) ) then

			FailIt ( LVL_VERBOSE, "The list box " + control$ + " IS NOT " + enabled_state$ + ".")
		endif

	else

		LogIt ( LVL_VERBOSE, "Verifying that the list box " + control$ + _
                          " EXISTS and CONTAINS " + text$ + _
                          " and IS " + enabled_state + "." )

		if not ( wListExists ( control$ ) ) then

			FailIt ( LVL_VERBOSE, "The list box " + control$ + " DOES NOT exist.")
 		endif

	
		if not ( wListItemExists ( control$, text$ ) ) then

			FailIt ( LVL_VERBOSE, "The list item " + text$ + " was NOT found.")
		endif

		if not ( wListEnabled ( control$ ) = ( enabled_state$ = Enabled ) ) then

			FailIt ( LVL_VERBOSE, "The list box " + control$ + " IS NOT " + enabled_state$ + "." )
		endif

	endif

End Sub


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_ComboItemText
'
'	Checks that the ComboBox control specified exists, then the combo item.  Will
'	Select it, (making it active), if the bSelectItem var is set to TRUE
'
'	PARAMETERS
'		sControl - Name or ordinal of the ComboBox control
'		iItem - The 1-based index of the item
'		sText - Text expected on the tab control
'		bSelectItem - (DEFAULT=FALSE) Click the item after checking
'
'	RETURN VALUE
'		TRUE if ComboBox, Item, and ItemText all match up
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_ComboItemText(	sControl as String, _
								lItem as Long, _
								sText as String, _
								bSelectItem=FALSE as Integer) as Integer
	
	EnterSub("bVerify_ComboItemText - ComboBox[" + sControl + "]:Item[" + str$(lItem) + "]:sText[" + sText + "]")


'Assume failure will occur
	bVerify_ComboItemText = FALSE



'Verify that the ComboBox exists
	if WComboExists (sControl) = FALSE then

		LogIt( LVL_VERBOSE, "ComboBox [" + sControl + "] not found.")



'Verify that the index sent to look for is not larger than the number
'of available items in the ComboBox
	elseif wComboCount(sControl) < lItem then

		LogIt( LVL_VERBOSE, "This ComboBox contains only [" + str$(wComboCount(sControl)) + "] items.")



'Verify that the sent text matches the text in the index
	elseif sText <> ComboItemText(sControl, lItem) then

		LogIt( LVL_VERBOSE, "Item[" + str$(lItem) + "] should read [" + sText +"] but was found to read [" + _
				ComboItemText(sControl, lItem) + "].")



'If the calling function requested it, click the item in the box
'(either way, this function should now return TRUE
	elseif bSelectItem = TRUE then

		wComboItemClk(sControl, sText)
		Sleep MIN_WAIT
		bVerify_ComboItemText = TRUE

	else

		bVerify_ComboItemText = TRUE

	end if

	ExitSub("bVerify_ComboItemText")

End Function 'bVerify_ComboItemText

'=================================================
' bVerify_SpinPosition 
'	Checks a spin control to make sure it has the right value.
'=================================================
Sub bVerify_SpinPosition (control$, position, Static_Control$ = NULL, Static_Text$ = "")
	
	LogIt( LVL_VERBOSE, "Verifying that the spin control "+control$+" """+Static_Text$+""" exists, and has value "+STR(position)+".")

	if not WSpinExists (control$) then
		FailIt( LVL_VERBOSE, "The "+Static_Text$+" combo box ("+control$+") does not exist.")
	else 
	if not WSpinPos (control$) = position then
		FailIt( LVL_VERBOSE, "The " + Static_Text$ + " combo box (" + control$ + ") should have the value "+ STR(position) + " not " + STR(WSpinPos (control$)))
	else
	if not Static_Control$ = NULL then
		bVerify_StaticText (Static_Control$, Static_Text$)
	end if
	end if
	end if
End Sub

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_TabItem
'
'	Checks that the tab control specified exists, then the tab itself.  Will
'	Select it, (making it active), if the bSelectTab var is set to TRUE
'
'	PARAMETERS
'		sControl - Name or ordinal of the tab control
'		sItem - Name or ordinal of tab itself
'		sText - Text expected on the tab control
'		bSelectTab - (DEFAULT=FALSE) Click the tab after checking
'
'	RETURN VALUE
'		TRUE is Tab control exists, contains expected tab, and the text is correct
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_TabItem (	sControl as string, _
							sItem as string, _
							sText as string, _
							bSelectTab=FALSE as Long) as Integer


	EnterSub("bVerify_TabItem - Tab Control[" + sControl + "]:Tab Item[" + sText + "]")

'Assume that the tab item does not exist.
	bVerify_TabItem = FALSE


'Verify existence of tab control
	if WTabExists (sControl) = FALSE then

		LogIt( LVL_VERBOSE, "The tab control " + sControl + " does not exist.")

	else

'Does the specific tab exist, (generally checking the ordinal here)
		if WTabItemExists (sControl, sItem) = FALSE then

			LogIt( LVL_VERBOSE, "The tab [" + sItem + _
					"] was not found on the current tab control.")

		else

'Compare the text of the specified tab
			if TabItemText (sControl, sItem) <> sText then

				LogIt( LVL_VERBOSE, "Tab [" + sItem + "] should read [" + sText + _
						"] but instead reads [" + TabItemText (sControl, sItem) + "]")

			else

'If here then tab passed all verification tests. If user specified the
'selection flag, then select the tab.  Otherwise return true and exit
				if bSelectTab = TRUE then

					LogIt( LVL_VERBOSE, "Attempting to click tab [" + sText + "].")

					wTabItemClk(sControl, sItem)
					Sleep (MIN_WAIT + MIN_WAIT)

				end if

				bVerify_TabItem = TRUE

			end if
		end if
	end if

	ExitSub("bVerify_TabItem")

End Function 'bVerify_TabItem

'=================================
' bVerify_WindowTitle 
'	Checks the title of the active window.
'=================================
Sub bVerify_WindowTitle (text$)
'dim wait as short
'	
'	wait = Default_Time_out
'	DO while (not GetText (WGetActWnd(0)) = text$) and (wait > 0)
'		sleep 1
'		wait = wait - 1
'	LOOP
	
	LogIt( LVL_VERBOSE, "Verifying that caption is """+text$+""".")
	
	if not GetText (WGetActWnd(0)) = text$ then
		FailIt( LVL_VERBOSE, "The Title of the active window should be """+text$+""" not """+GetText (WGetActWnd(0))+"""")
	end if
End Sub

'=================================
' bVerify_ButtonDefault 
' Checks the default push button
'=================================
Sub bVerify_ButtonDefault( button$ )
	LogIt( LVL_STATUSINFO, "Verifying that button "+button$+" is the default push button" )
	if( wButtonDefault( button$ ) = FALSE ) then
		FailIt( LVL_VERBOSE, "Button "+button$+" is not the default push button" )
	endif

End Sub

Sub bVerify_GroupBoxText (text$)
  	LogIt(LVL_VERBOSE, _
         "Verifying that group box """+text$+"""exist.")

   if WFndWndC( text, "BUTTON", FW_ALL) = NULL then
      LogIt(LVL_VERBOSE, "There is no window named """+text+""".")
   endif

End Sub




'=================================
'
' bVerify_ListViewExists 
' 
' a sub-routine to ensure that an expected SysListView32 exists
' if not found on initial inspection, then will wait a few seconds
' to give the proppage a chance to finish populating.
'
' listView - string that identifies the list view control, 
'				 most likely an ordinal value, such as "@1"
'=================================

sub bVerify_ListViewExists ( listView$ )

	dim loopCount%
	dim wasFound%

	EnterSub ( "bVerify_ListViewExists" )

	'iniitial inspection to verify ListView exists
	if not ( wViewExists ( listView )) then
		
		LogIt ( LVL_DEBUGGING, "bVerify_ListViewExists: '" +_
									listView + "' was not found " +_
								   "on initial inspection, " +_
									"will wait and check again" )
		
		'initialize conditional variables
		loopCount = 0
		wasFound = FALSE

		'search for ListView with "sleeps" in between
		while ( loopCount <= MIN_TRY ) and ( wasFound = FALSE )
			if not ( wViewExists ( listView )) then
				'sleep for MIN_WAIT before trying again
				sleep MIN_WAIT
				loopCount = loopCount + 1
			else
				'set variable to break out of loop
				wasFound = TRUE
			end if
		wend

		'report outcome of search for ListView 
		if ( wasFound = FALSE ) then
			FailIt ( LVL_VERBOSE, "bVerify_ListViewExists: '" +_
										 listView + "' could NOT be found, " +_
										 "even after waiting " + trim(str(MIN_TRY*MIN_WAIT)) + " seconds" )
		else
			LogIt ( LVL_DEBUGGING, "bVerify_ListViewExists: '" +_
										 listView + "' was found, " +_
										 "after a few seconds" )
		end if

	else 

		LogIt ( LVL_DEBUGGING, "bVerify_ListViewExists: '" +_
									listView + "' was found " +_
									"on initial inspection" )

	end if

	ExitSub ( "bVerify_ListViewExists" )

end sub 'Verify_ListViewExists


'=================================
'
' bVerify_TreeExists 
' 
' a sub-routine to ensure that an expected SysTreeView32 exists
' if not found on initial inspection, then will wait a few seconds
' to give the proppage a chance to finish populating.
'
' strTree - string that identifies the tree view control, 
'				 most likely an ordinal value, such as "@1"
'=================================

sub bVerify_TreeExists ( strTree$ )

	dim loopCount%
	dim wasFound%

	EnterSub ( "bVerify_TreeExists" )

	'iniitial inspection to verify TreeView exists
	if not ( wTreeExists ( strTree )) then
		
		LogIt ( LVL_DEBUGGING, "bVerify_TreeExists: '" +_
									  strTree + "' was not found " +_
								     "on initial inspection, " +_
									  "will wait and check again" )
		
		'initialize conditional variables
		loopCount = 0
		wasFound = FALSE

		'search for TreeView with "sleeps" in between
		while ( loopCount <= MIN_TRY ) and ( wasFound = FALSE )
			if not ( wTreeExists ( strTree )) then
				'sleep for MIN_WAIT before trying again
				sleep MIN_WAIT
				loopCount = loopCount + 1
			else
				'set variable to break out of loop
				wasFound = TRUE
			end if
		wend

		'report outcome of search for TreeView 
		if ( wasFound = FALSE ) then
			'pause "debug: Tree NOT found; is covered? error message? hit OK to continue"
			FailIt ( LVL_VERBOSE, "bVerify_TreeExists: '" +_
										 strTree + "' could NOT be found, " +_
										 "even after waiting " + trim(str(MIN_TRY*MIN_WAIT)) + " seconds" )
		else
			LogIt ( LVL_DEBUGGING, "bVerify_TreeExists: '" +_
										  strTree + "' was found, " +_
										  "after a few seconds" )
		end if

	else 

		LogIt ( LVL_DEBUGGING, "bVerify_TreeExists: '" +_
									  strTree + "' was found " +_
									  "on initial inspection" )

	end if

	ExitSub ( "bVerify_TreeExists" )

end sub 'Verify_TreeExists



'=================================
'
' bVerify_TreeItemExists 
' 
' a sub-routine to ensure that an expected SysTreeView32 item exists
' if not found on initial inspection, then will wait a few seconds
' to give the proppage a chance to finish populating.
'
' listView - string that identifies the list view control, 
'				 most likely an ordinal value, such as "@1"
'=================================

sub bVerify_TreeItemExists ( TreeView$, TreeItem$ )

	dim loopCount%
	dim wasFound%

	EnterSub ( "bVerify_TreeItemExists" )

	'ensure that the Tree exists (and/or give it a chance to come up)
'	Verify_TreeExists ( TreeView )

	'iniitial inspection to verify TreeItem exists
	if not ( wTreeItemExists ( TreeView, TreeItem)) then
		
		LogIt ( LVL_DEBUGGING, "bVerify_TreeItemExists: '" +_
										TreeItem + "' was not found " +_
									   "on initial inspection, " +_
										"will wait and check again" )
		
		'initialize conditional variables
		loopCount = 0
		wasFound = FALSE

		'search for TreeItem with "sleeps" in between
		while ( loopCount <= MIN_TRY ) and ( wasFound = FALSE )
			if not ( wTreeItemExists ( TreeView, TreeItem)) then
				'sleep for MIN_WAIT before trying again
				sleep MIN_WAIT
				loopCount = loopCount + 1
			else
				'set variable to break out of loop
				wasFound = TRUE
			end if
		wend

		'report outcome of search for TreeItem 
		if ( wasFound = FALSE ) then
			FailIt ( LVL_VERBOSE, "bVerify_TreeItemExists: '" +_
										 TreeItem + "' could NOT be found, " +_
										 "even after waiting " + trim(str(MIN_TRY*MIN_WAIT)) + " seconds" )
		else
			LogIt ( LVL_DEBUGGING, "bVerify_TreeItemExists: '" +_
										 TreeItem + "' was found, " +_
										 "even after a few seconds" )
		end if

	else 

		LogIt ( LVL_DEBUGGING, "bVerify_TreeItemExists: '" +_
									TreeItem + "' was found " +_
									"on initial inspection" )

	end if

	ExitSub ( "bVerify_TreeItemExists" )

end sub 'Verify_TreeItemExists


'=================================
'
' bVerify_ViewItemExists 
' 
' a sub-routine to ensure that an expected SysListView32 item exists
' if not found on initial inspection, then will wait a few seconds
' to give the proppage a chance to finish populating.
'
' ListView - string that identifies the list view control, 
'				 most likely an ordinal value, such as "@1"
' ViewItem - string that identifies the view Item, 
'				 such as "@1" or text for item name
'=================================

sub bVerify_ViewItemExists ( ListView$, ViewItem$ )

	dim loopCount%
	dim wasFound%

	EnterSub ( "bVerify_ViewItemExists" )

	'iniitial inspection to verify ViewItem exists
	if not ( wViewItemExists ( ListView, ViewItem)) then
		
		LogIt ( LVL_DEBUGGING, "bVerify_ViewItemExists: '" +_
										ViewItem + "' was not found " +_
									   "on initial inspection, " +_
										"will wait and check again" )
		
		'initialize conditional variables
		loopCount = 0
		wasFound = FALSE

		'search for ViewItem with "sleeps" in between
		while ( loopCount <= MIN_TRY ) and ( wasFound = FALSE )
			if not ( wViewItemExists ( ListView, ViewItem)) then
				'sleep for MIN_WAIT before trying again
				sleep MIN_WAIT
				loopCount = loopCount + 1
			else
				'set variable to break out of loop
				wasFound = TRUE
			end if
		wend

		'report outcome of search for ViewItem 
		if ( wasFound = FALSE ) then
			FailIt ( LVL_VERBOSE, "bVerify_ViewItemExists: '" +_
										 ViewItem + "' could NOT be found, " +_
										 "even after waiting " + trim(str(MIN_TRY*MIN_WAIT)) + " seconds" )
		else
			LogIt ( LVL_DEBUGGING, "bVerify_ViewItemExists: '" +_
										 ViewItem + "' was found, " +_
										 "even after a few seconds" )
		end if

	else 

		LogIt ( LVL_DEBUGGING, "bVerify_ViewItemExists: '" +_
									ViewItem + "' was found " +_
									"on initial inspection" )

	end if

	ExitSub ( "bVerify_ViewItemExists" )

end sub 'Verify_ViewItemExists

'---------------------------------------------------------------------------
' VerifyTreeItem verify that the ViewItem exists in the ListboxItem$
'---------------------------------------------------------------------------
Sub VerifyTreeItem(Dlg_TITLE$, TreeTitle$, TreeItem$)

   dim hWnd as long
	dim TempText$
	
	LogIt( LVL_VERBOSE, "Verifying that node """ +TreeItem$+ _
	                    """ is present in the """+TreeTitle+""" tree." )
	if( Dlg_Title$ <> Null ) then

		'Get the handle of the dialog window
		 hWnd = WFndWnd(Dlg_TITLE$, FW_PART or FW_ALL or FW_FOCUS, MAX_WAIT)

		 ' If unable to get handle of the dialog window, stop test.
		 if hWnd = 0 then
			 FailIt( LVL_VERBOSE, "VerifyTreeItem: Dialog " + Dlg_TITLE$ + " couldn't be found")
			 end
		 else
			WSetActWnd(hWnd)
		 end if
	end if

	'Select the Tree Item
	if( wTreeExists( TreeTitle$ ) = TRUE ) then
		if( WTreeItemExists(TreeTitle$, TreeItem$ ) = FALSE ) then
			FailIt( LVL_VERBOSE, "VerifyTreeItem: Item """ + TreeItem$ + """ couldn't be found in " + TreeTitle$ + """ tree.")
		endif
	else
		FailIt( LVL_VERBOSE, "VerifyTreeItem: Tree """ + TreeTitle$ + """ couldn't be found in " + Dlg_TITLE$ + " dialog.")
	endif
	    
End Sub	 ' End of the VerifyTreeItem function

'---------------------------------------------------------------------------
' VerifyResultItem verify that the ViewItem exists in the viewTitle view
'---------------------------------------------------------------------------
Sub VerifyResultItem(viewTitle$, viewItem$)
   if( wViewExists( viewTitle$ ) = TRUE ) then
		if( WViewItemExists(viewTitle$, viewItem$ ) = FALSE ) then
			FailIt( LVL_VERBOSE, "VerifyResultItem: Item """ + viewItem$ + " couldn't be found in " + viewTitle$ + """ view.")
		endif
	else
		FailIt( LVL_VERBOSE, "VerifyResultItem: View """ + viewTitle$ + """ couldn't be found.")
	endif
   
End Sub  'VerifyResultItem

sub VerifyAndSelectMenuItem ( strMenuItem$ )

	EnterSub ( "VerifyAndSelectMenuItem" )

	'ensure menu item exists and select it
	if not wMenuExists ( strMenuItem ) then
	  
	  'close menu, if still open
	  wMenuEnd

	  'report failure and terminate scenario
	  FailIt ( LVL_VERBOSE, "Menu item '" + strMenuItem + "' NOT found" )
	
	else
	
		'report that menu item exists and continue
		LogIt ( LVL_DEBUGGING, "Menu item '" + strMenuItem + "' found" )
	
		'ensure menu item is enabled
		if not wMenuEnabled ( strMenuItem ) then
			
			'close menu, if still open
			wMenuEnd

			'report failure and terminate scenario
			FailIt ( LVL_VERBOSE, "Menu item '" + strMenuItem + "' NOT enabled" )
		
		else

			'report that menu item is enabled and continue
			LogIt ( LVL_DEBUGGING, "Menu item '" + strMenuItem + "' enabled" )
			
			'select menu item
			wMenuSelect ( strMenuItem )

			'report that menu item was successfully selected
			LogIt ( LVL_DEBUGGING, "Menu item '" + strMenuItem + "' was successfully selected" )
			
			'menu is not closed here, since target menu item may be more than one level deep
			'ensuring that 'wMenuEnd' is called after menu item is selected is responsibility
			'of calling function (and should not really be necessary)

		end if 'not wMenuEnabled
	
	end if 'not wMenuExists

	ExitSub ( "VerifyAndSelectMenuItem" )

end sub 'VerifyAndSelectMenuItem

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bVerify_ListItemText
'
'	Checks for existence of List Item and then compares expected and actual text.
'	Then clicks the item by default.
'
'	PARAMETERS
'		sControl - Name or ordinal of the List control
'		sItem - Index of the List item
'		sExpectedText - Text expected on the List item
'		bClick - whether or not to click the List item (FALSE by default)
'		iButton - Button to use to click (Left button by default)
'
'	RETURN VALUE
'		TRUE if control exists and text matches
'		FALSE otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bVerify_ListItemText(	sControl as String, _
								lItem as Long, _
								sExpectedText as String, _
								bClick=FALSE as Integer, _
								iButton=VK_LBUTTON) as Integer
	
	EnterSub("bVerify_ListItemText - Control[" + sControl + "]:lItem[" + str$(lItem) + "]:Text[" + sExpectedText + "]")


'Assume vericifactions will fail
	bVerify_ListItemText = FALSE



'Verify that the List control exists
	

	if not wListExists(sControl,MIN_WAIT) then

		LogIt(LVL_STATUSINFO, "List control could not be found.")



'Verify that the individual item exists, by checking that the index of the item
'is not larger than the total items int he list
	elseif wListCount(sControl) < lItem then
	
		LogIt(LVL_STATUSINFO,"List item [" + str$(lItem) + "] control could not be found.")




'Verify the text itself - if the expected text begins with a tilde, (VT WILDCARD), then
'check for partial match, else check exact string
	elseif Left(sexpectedText, 1) = "~" then

		if instr(ListItemText(sControl, lItem), Right(sExpectedText, len(sExpectedText) - 1)) = FALSE then

			LogIt(LVL_STATUSINFO, "The List item [" + str$(lItem) + "] should contain text [" + _
					sExpectedText + "] but reads [" + ListItemText(sControl, lItem) + "].")

		else

			bVerify_ListItemText = TRUE

'Click on the item if requested by user
			if bClick = TRUE then

				wListItemClk(sControl, ListItemText(sControl, lItem), iButton)
				bVerify_ListItemText = TRUE
				Sleep MIN_WAIT

			end if

		end if



'If here, then checking for an exact string...
	elseif ListItemText(sControl, lItem) <> sExpectedText then

		LogIt(LVL_STATUSINFO, "The List item [" + str$(lItem) + "] should have text [" + _
				sExpectedText + "] but reads [" + ListItemText(sControl, lItem) + "].")

	else

		bVerify_ListItemtext = TRUE

'Click on the item if requested by user
		if bClick = TRUE then

			wListItemClk(sControl, ListItemText(sControl, lItem), iButton)
			bVerify_ListItemText = TRUE
			Sleep MIN_WAIT

		end if

	end if
				

	ExitSub("bVerify_ListItemText")
	
End Function 'bVerify_ListItemText


'$ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Suites\VTShim\VTSampleScripts\inc\SV2_sitesCommon.inc ===
'************************************************************************************************************
'
'	SV_SitesCommon.inc
'
'	All general Functions related specifically to the AD Sites and Services Snap In
'
'	PROCEDURE LIST
'	function bStartMMC() as long

'	function bAccessSnapInManager() as long

'	function bAddSitesAndServiceSnapIn() as long

'	function bOpenSitesContainer() as long

'	function bCollapseSitesContainer()

'	function bOpenTransportsContainer() as long

'	function bOpenSubnetsContainer() as long

'	function bOpenSpecificSiteContainer(sSiteName as string) as long

'	function bOpenSpecificServerContainer(sSiteName as string) as long

'	Function bCreateSite(	sSiteName as string, _
'							sSiteLink=DEFAULT_FIRST_SITE_LINK as String) as Long

'	function bDeleteSite(sSiteName as string) as long

'	function bCreateSiteLink(sLinkName as String, sSiteOne as String, _
'			sSiteTwo as string, sTransport="IP" as string) as long

'	function bCreateSiteLinkBridge(sBridgeName as String, sLinkOne as String, _
'			sLinkTwo as string, sTransport="IP" as string) as long

'	function bDeleteSiteLink(sLinkName as string, sTransport as string) as long

'	function bDeleteSiteLinkBridge(sBridgeName as string, sTransport as string) as long

'	Function bCreateServer(	sSiteName as String, _
'							sServerName as String, _
'							bSkipFindContainer=FALSE as Long) as Long

'	Function lFindServer(	sSiteName as String, _
'							sServerName as String, _
'							bSkipFindContainer=FALSE as Long) as Long

'	function bMoveServer(sServerName as string, sFromSite as String, sToSite as String) as long

'	function lOpenSpecificServer(sSiteName as String, sServerName as string) as long

'	function bSelectSpecificServerNTDSSettings(sSiteName as String, sServerName as string) as long

'	function bCheckLocation(sViewList as String, sViewItem as String) as Long

'	function bCreateLicensingSettings(sSiteName as String) as long

'	function bCreateSiteSettings(sSiteName as String) as long

'	function bDeleteSiteSettings(sSiteName as String) as long

'	function bDeleteLicensingSettings(sSiteName as String) as long

'	function bCreateSubnet(sSiteName as String, sFullAddress as String) as long

'	function bDeleteSubnet(sSubnetMask as string) as long

'	Function bCheckSecurity(	sViewList as String, _
'								sViewItem as String) as Long

'	Function bDeleteObject(	sViewList as String, _
'							sObjectName as string) as long

'	Function bRetargetForest(sForestDNS as String) as Long

'	Function bRetargetDC(sDCName as String) as Long

'	Function bCreateServersContainer(sSiteName as String) as Long

'	Function bChangeSiteLinkSettings(	sTransport=IP_NODE as String, _
'										sSiteLink as String, _
'										iCost=FALSE as Integer,
'										iMinutes=FALSE as Integer,) as Long

'	Function bCreateConnection(	sSiteName as String, _
'								sBaseServer as String, _
'								sFromServer as String, _
'								sConnectionName as String) as Long

'
'	HISTORY
'	Date		User		Activity
'	09-26-2000	tyuhas		Created file
'	10-03-2000	tyuhas		Added open for subnets and specific sites	
'	10-06-2000	tyuhas		Added open for Server containers
'							Added Create and Delete Site function
'	10-09-2000	tyuhas		Added Create SiteLink and SiteLinkBridge functions
'	10-10-2000	tyuhas		Added delete SiteLink and Bridge functions
'	10-13-2000	tyuhas		Added locate, open, and move server functions
'	11-17-2000	tyuhas		Added Subnet Functions
'	11-30-2000	tyuhas		Added Security and delete generic object functions
'	12-16-2000	tyuhas		Changed Find/Create Server to allow for speedier completion
'							if the calling function sets a skip flag.  See code for details.
'	12-17-2000	tyuhas		Added Change Site Link Settings and Connection Creation.
'	05.15.2001  mehmetd     Code correction for german input
'   06.23.2001  mehmetd	    Added German Correction
'	07.16.2001  mehmetd     Added ability to support Language Pack Testing
'	10.04.2001  mehmetd     Can support Schema, UI and input language variations
'   04.24.2002  mehmetd     Code changes to implement CompileSites script 
'
'************************************************************************************************************

'Load symbol for this file
'$DEFINE SV2_SITESCOMMON

'$include 'language.inc'



'The strings.inc file needs this so as to not use W2K text
'$DEFINE NT51

'$IFNDEF UTIL
	'$include 'util.inc'
'$ENDIF



' Following scetion indicated the language of the machine that UI is running. 

'$IFNDEF STRINGS_UI
  '$DEFINE STRINGS_UI
	
	'$IFDEF UI_ENG
		'$include 'stringsUI_eng.inc'
	
	'$ELSEIFDEF UI_GER
		'$include 'stringsUI_ger.inc'

	'$ENDIF

'$ENDIF





' Following section indicates the language to used in schema. 
' This depends on the local of the root DC in Enterprise

'$IFNDEF STRINGS_SCHEMA
  '$DEFINE STRINGS_SCHEMA

	'$IFDEF SCHEMA_GER
		'$include 'stringsSchema_ger.inc'

	'$ELSEIFDEF SCHEMA_ENG
		'$include 'stringsSchema_eng.inc'

	'$ENDIF

'$ENDIF




' Following sction indicates the language to be used when entering the test strings

'$IFNDEF STRINGS_INPUT
  '$DEFINE STRINGS_INPUT

	'$IFDEF INPUT_ENG
		'$include 'stringsInput_eng.inc'

	'$ELSEIFDEF INPUT_GER
		'$include 'stringsInput_ger.inc'

	'$ELSEIFDEF INPUT_JPN
		'$include 'stringsInput_jpn.inc'

	'$ENDIF

'$ENDIF
		



'$IFNDEF SV2_TOOLS
	'$include 'SV2_tools.inc'
'$ENDIF

'$IFNDEF SV2_VERIFY
	'$include 'SV2_verify.inc'
'$ENDIF






'****************** TYPE DECLATATIONS ******************

'----- the weekly matrix control is used on the Scheduling options for
'Connections, NTDS Site Settings, and SiteLink objects.  This type holds the
'state data for one such control.  In order to initialize, call the
'function InitializeWeeklyMatrix immediately after declaring the variable ----
Type WEEKLYMATRIX ' Prefix = wkmx

	Sun as Array of Long
	Mon as Array of Long
	Tue as Array of Long
	Wed as Array of Long
	Thu as Array of Long
	Fri as Array of Long
	Sat as Array of Long

End Type


'----- the weekly matrix control is a custom control.  This string is used to
'find it's handle for the wCustom* function calls
Const WEEKLYMATRIX_CLASSNAME = "AfxWnd42u"




'****************** SETUP VARIATIONS *******************
'See if the MMC path is environment specified.  If not, default to NTDS standard
global gsMMCPath as String
if ENVIRON$("SITES_MMC_PATH") <> "" then 

	gsMMCPath = ENVIRON$("SITES_MMC_PATH")

else

	gsMMCPath = "ntsd -gG mmc.exe"

end if



'Setup crednetials variables
global giUserCred as Integer
const CRED_UNKNOWN = 0
const CRED_ADMIN = 1
const CRED_NOT_ADMIN = 2
giUserCred = CRED_UNKNOWN



'Specific Ordinal Positions
const ORD_NEWSITELINK_NOTINLINK = "@1"
const ORD_NEWSITELINK_INLINK = "@2"
const ORD_NEWSITELINKBRIDGE_NOTINLINK = "@1"
const ORD_NEWSITELINKBRIDGE_INLINK = "@2"

'TE Variables
Global gsStartTime as String

Function TestBegin_More()

'Record Start Time
	gsStartTime = DATETIME$
	LogIt(LVL_STATUSINFO, "Test begin at " + gsStartTime)


End Function

Function TestEnd_More()

	LogIt(LVL_STATUSINFO, "TE START TIME = [" + gsStartTime + "]", TRUE)

End Function


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bStandardStartup
'
'	Runs through the nominal startup procedure:
'		Close all MMCs
'		Open a new MMC
'		Load Sites Snap-in
'		Retarget Forest (if requested)
'		Retarget DC (if requested)
'		Verify Sites loaded as expected
'
'	PARAMETERS
'		ghwndMain - the handle that the new MMC is given
'
'	RETURN VALUE
'		TRUE if all systems are go
'		FALSE if all systems are not go
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bStandardStartup(ghwndMain as Long) as Long

	EnterSub("bStandardStartup")

	Dim bTempResult as Long


	'----- assume failure ------
	bTempResult = FALSE



	'----- 
	ghwndMain = bStartMMC()
	if ghwndMain = FALSE then

		FailIt(LVL_STATUSINFO, "Could not load fresh copy of MMC.")

	endif

	if bAddSitesAndServiceSnapIn() = FALSE then

		FailIt(LVL_STATUSINFO, "Could not load Sites Snap-In to console.")

	End IF


	'----- If retargeting to a different forest, do that now -----
	if ENVIRON$("SITES_RETARGET_FOREST") <> "" then

		if bRetargetForest(ENVIRON$("SITES_RETARGET_FOREST"))  = FALSE then

			goto eXIT_fUNCTION

		end if

	end if



	'----- If retargeting to a different DC, do that now -----
	if ENVIRON$("SITES_RETARGET_DC") <> "" then

		if bRetargetDC(ENVIRON$("SITES_RETARGET_DC"))  = FALSE then

			goto eXIT_fUNCTION

		end if

	end if



	'----- Verify that the Sites node exists and can be expanded ------
	if bOpenSitesContainer() = FALSE then

		goto eXIT_fUNCTION

	end if


	'------ If credentials have not been checked, check if this is an administator -----
	if giUserCred = CRED_UNKNOWN then

	'----- If the current user has admin rights, then the New Site command will
	'be available from the context menu of the Sites Container ------
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, SITES_NODE, VK_RBUTTON) = TRUE then

			if wMenuExists(MNU_CREATE_NEW_SITE, MAX_WAIT) = TRUE or _
					wMenuExists(MNU_CREATE_NEW + " " + MNU_SITE_HOTKEY, MAX_WAIT) = TRUE then

				giUserCred = CRED_ADMIN

			else

				giUserCred = CRED_NOT_ADMIN

			end if

		end if

	end if


	'----- if here, then all is good -----
	bTempResult = TRUE


eXIT_fUNCTION:

	bStandardStartup = bTempResult
	ExitSub("bStandardStartup")

End Function 'bStandardStartup


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bSTARTMMC
'
'	Locates any current instance of MMC and shuts it down.  Then starts a fresh copy.
'
'
'	RETURN VALUE
'		TRUE if MMC started
'		FALSE if MMC not started
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bStartMMC() as Long

	EnterSub("bStartMMC")


	LogIt(LVL_DEBUGGING, "Closing all previous instances of MMC...")

	'----- attempt to shut down all existing copies of the MMC -----
	if bQuitMMC() = FALSE then

		bStartMMC = False
		LogIt(LVL_STATUSINFO, "Could not quit all MMCs, will not attempt to start another.")
		goto eXIT_fUNCTION

	end if



	LogIt(LVL_DEBUGGING, "Starting new instance of MMC.")


	'----- attempt to start a new copy of the MMC -----
	On Local Error Goto MMC_LOAD_FAILURE
		Run gsMMCPath, NOWAIT
	On Local Error Goto 0


	'----- Wait for the MMC dialog to appear before moving on -----
	Do
	
		Sleep MIN_WAIT

	Loop Until wFndWnd(CAP_MMC, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS)


	'----- return the window handle to the MMC -----
	bStartMMC = wFndWnd(CAP_MMC, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS)


eXIT_fUNCTION:
	ExitSub("bStartMMC")
	Exit Function


'ERROR TRAPPING
MMC_LOAD_FAILURE:
	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not start a new instance of MMC.")
	bStartMMC = FALSE
	ExitSub("bStartMMC")

End Function 'bStartMMC

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bQUITTMMC
'
'	Locates any current instance of MMC and shuts it down.
'	Note: This will shut down ALL instances of the MMC, not just one.
'
'	RETURN VALUE
'		TRUE if MMC started
'		FALSE if MMC not started
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bQuitMMC() as Long

	EnterSub("bQuitMMC")

	Dim lTBOrd as Long

	bQuitMMC = TRUE


	'----- Check for a current instance of the MMC -----
	Do While wFndWnd(CAP_MMC, FW_ALL OR FW_PART OR FW_RESTORE OR FW_FOCUS)



		'----- Close any active dialogs -----
		if bCloseDialogs(GetText(WFndWnd("~" + CAP_MMC))) = FALSE then
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all dialogs within the MMC.")
			goto eXIT_fUNCTION
		end if



		'----- depending on the arrangement of the toolbars in the MMC the
		'toolbar ordinal could be different each time ----
		lTBOrd = lFindToolbarButtonOrdinal(MNU_TXT_FILE)



		'----- Close the MMC if an appropriate toolbar ordinal can be found-----
		if lTBOrd <> FALSE then

			wToolbarButtonClk(_ord(lTBOrd), MNU_TXT_FILE)

			if b_wMenuSelect_Ex(MNU_TXT_FILE_EXIT) = FALSE then

'For some unknown reason, the 'Exit' selection under the file menu was not available...
				bQuitMMC = FALSE
				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all instances of the MMC.")
				goto eXIT_fUNCTION

			end if

'Breathe a bit
			sleep MIN_WAIT

'If the save box pops up, close it without saving
			if GetText(wGetActWnd()) = CAP_MMC_FULL then
				
'Check for 'No' button.  If does not exist, bail as we have arrived someplace unexpected
				if wButtonExists(BTN_NO) then

					wButtonClick(BTN_NO)

				else

					bQuitMMC = FALSE
					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all instances of the MMC.")
					goto eXIT_fUNCTION

				end if

			end if

		else

			bQuitMMC = FALSE
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all instances of the MMC.")
			goto eXIT_fUNCTION

		end if

	Loop

'Pause a bit to let the system catch up
	Sleep 1

eXIT_fUNCTION:
	ExitSub("bQuitMMC")

End Function 'bQuitMMC

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bAccessSnapInManager
'
'	Calls up the Add Remove Snap In Dialog
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Dialog started
'		FALSE if Dialog not started
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bAccessSnapInManager() as long

	EnterSub("bAccessSnapInManager")


	Dim lTBOrd as Long
	lTBOrd = lFindToolbarButtonOrdinal(MNU_TXT_FILE)
	
	LogIt(LVL_STATUSINFO, "Attempting to open Snap-in Manager dialog...")

	'----- Select Console Menu\AddRemove Snapin -----
	if LTBOrd <> FALSE then

		wToolbarButtonClk(_ord(lTBOrd), MNU_TXT_FILE)
		b_wMenuSelect_Ex(MNU_TXT_FILE_SNAP_IN_MANAGER)

	else

		bAccessSnapInManager = FALSE
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Console Toolbar not found.")
		ExitSub("bAccessSnapInManager")
		Exit Function

	end if

	'Breathe a bit
	Sleep 1


eXIT_fUNCTION:

'Verfiy the resulting dialog
	If GetText(WGetActWnd()) = SNAP_IN_MANAGER then

		bAccessSnapInManager = TRUE
		LogIt(LVL_DEBUGGING, "Snap-in manager loaded successfully.")

	else

		bAccessSnapInManager = FALSE
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Snap-in manager did not load.")

	end if

	ExitSub("bAccessSnapInManager")

End Function 'bAccessSnapInManager

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bAddSnapin
'
'	Verifies the specified snap-in exists and attempts to load it
'
'	ASSUMES
'		An instance of MMC is open, active, and has no child dialogs open
'
'	PARAMETERS
'		sSnapin - Text of the snap-in to load from the "Add Standalone Snap-in" dialog
'
'	RETURN VALUE
'		TRUE if Snap-in Added
'		FALSE if Snap-in Not Added
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bAddSnapIn( sSnapIn as String) as Long

	EnterSub("bAddSnapIn [" + sSnapIn + "]")

	Dim bResult as integer

	LogIt(LVL_DEBUGGING, "Attempting to add snap-in...")



	'----- Open the Snap-in Manager dialog -----
	bResult = False
	if bAccessSnapInManager() = TRUE then
		
		CaptionSleep(SNAP_IN_MANAGER)

		'----- click the Add button to bring up the standalone snap-in dialog -----
		if b_wButtonClick_Ex("~" + BTN_ADD) = TRUE then

			CaptionSleep(ADD_A_SNAP_IN)


			'----- Find and select the specified snap-in from the listbox -----
			if b_wViewItemClk_Ex(DEFAULT_ORDINAL, "~" + sSnapIn) = TRUE then



				'----- click the add button, then close the "Standalone" dialog to return
				'to the "Add/Remove Snap-in Manager" dialog -----
				if b_wButtonClick_Ex(MV_BTN_ADD) = TRUE then
					if b_wButtonClick_Ex(BTN_CLOSE) = TRUE then

						CaptionSleep(SNAP_IN_MANAGER)


						'----- click OK to finish loading the snap-in to the MMC -----
						if b_wButtonClick_ex(BTN_OK) = TRUE then

							CaptionSleep(CAP_MMC)

						end if
					end if
				end if
			end if
		end if
	end if



	'----- Breath a moment... -----
	Sleep MIN_WAIT

	
	LogIt(LVL_DEBUGGING, "Verify that snap-in loaded...")


	'---------- Verify that the snap-in loaded ---------'
	if wTreeItemExists(DEFAULT_ORDINAL, sSnapIn) = TRUE then

		bResult = TRUE

	End if




	'----- Process return value -----
	if bResult = FALSE then

		bAddSnapIn = FALSE
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Specified snap-in did not load.")

	Else

		bAddSnapIn = TRUE

	End If


	ExitSub("bAddSnapIn")

End Function 'bAddSnapIn


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bAddSitesAndServicesSnap-in
'
'	Adds the S&S Snap In via menu calls and use of the Snap-in Manager.
'
'	ASSUMES
'		An instance of MMC is open, active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Snap-in Added
'		FALSE if Snap-in Not Added
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bAddSitesAndServiceSnapIn()

	EnterSub("bAddSitesAndServiceSnapIn")

	Dim bResult as integer
	bResult = False


	LogIt(LVL_STATUSINFO, "Attempting to Add Sites and Services Snap In...")


	'----- Add the snap in -----
	if bAddSnapIn(DSSITE_SNAPIN) = fALSE then

		LogIt(LVL_STATUSINFO, "Could not load sites snap-in")
		Goto eXIT_fUNCTION

	End If


	'---------- Verify that the snap-in loaded ---------'
	if wTreeItemExists(ORD_1, DSSITE_SNAPIN) = TRUE then



		if ENVIRON$("SITES_RETARGET_FOREST") <> "" then

			'--------- an error message may appear if the targetting of the snap-in
			'is not correct, (launched with NT4 credentials for example) ---------'
			LogIt(LVL_STATUSINFO, "Clicking node to trip 'retarget error'")
			b_Play_Ex("{DOWN}")


			LogIt(LVL_STATUSINFO, "Waiting")
			CaptionSleep(CAP_ACTIVE_DIRECTORY)

			LogIt(LVL_STATUSINFO, "Moving on...")
			if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

				bCloseDialogs(CAP_MMC)

			Else

				bResult = FALSE

			End if

		end if

		bResult = TRUE

	End if


eXIT_fUNCTION:

'Process result
	if bResult = FALSE then

		bAddSitesAndServiceSnapIn = FALSE
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sites and Services Snap-in did not load.")
		ExitSub("bAddSitesAndServiceSnapIn")
		Exit Function

	Else

		bAddSitesAndServiceSnapIn = TRUE

	End If


	Sleep MIN_WAIT


	ExitSub("bAddSitesAndServiceSnapIn")

End Function 'bAddSitesAndServiceSnapIn

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenSitesContainer
'
'	Finds the Sites container and expands it
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Sites container expanded
'		FALSE if Sites container not expanded
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenSitesContainer()

	EnterSub("bOpenSitesContainer")

'Verify that the sites and services snap-in is loaded
	if wTreeItemExists(DEFAULT_ORDINAL, "~" + DSSITE_SNAPIN) = FALSE then
		if bAddSitesAndServiceSnapIn() = FALSE then
			
			bOpenSitesContainer = FALSE
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sites container not opened.")
			goto eXIT_fUNCTION

		end if
	end if

'If Sites node already open, jump out immeditaely

	if wTreeItemExists(DEFAULT_ORDINAL, "~" + SITES_NODE) then
		if wTreeItemExpanded(DEFAULT_ORDINAL, "~" + SITES_NODE) then


'Click Sites node in scope pane to enumerate childeren in context pane
			b_wTreeItemClk_Ex(DEFAULT_ORDINAL, "~" + SITES_NODE)

			bOpenSitesContainer = TRUE
			goto eXIT_fUNCTION

		end if
	end if

'Open the Snap In node
	do

	if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, "~" + DSSITE_SNAPIN) then

		sleep MIN_WAIT

		
'Open the Sites node
		if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, "~" + SITES_NODE) then

'Pause for a bit
			sleep MIN_WAIT

			bOpenSitesContainer = TRUE

'Click Sites node in scope pane to enumerate childeren in context pane
			b_wTreeItemClk_Ex(DEFAULT_ORDINAL, "~" + SITES_NODE)

			goto eXIT_fUNCTION
		
		end if

	

	end if

	loop while True

	bOpenSitesContainer = FALSE
	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sites container not opened.")

eXIT_fUNCTION:
	ExitSub("bOpenSitesContainer")
		
End Function 'bOpenSitesContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCollapseSitesContainer
'
'	Finds the Sites container and collapses it if it is expanded.  NOTE: This returns
'	TRUE if the Sites container is already collapsed prior to start.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Sites container collapsed
'		FALSE if Sites container not collapsed
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCollapseSitesContainer()

	EnterSub("bCollapseSitesContainer")

'Verify that the sites and services snap-in is loaded
	if wTreeItemExists(DEFAULT_ORDINAL, "~" + DSSITE_SNAPIN) = FALSE then
		if bAddSitesAndServiceSnapIn() = FALSE then
			
			bCollapseSitesContainer = FALSE
			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sites container could not be found to collapse.")
			goto eXIT_fUNCTION

		end if
	end if

'If Sites node already open, jump out immeditaely

	if wTreeItemExists(DEFAULT_ORDINAL, "~" + SITES_NODE) = TRUE then
		if wTreeItemExpanded(DEFAULT_ORDINAL, "~" + SITES_NODE) = FALSE then

			bCollapseSitesContainer = TRUE
			LogIt(LVL_STATUSINFO, "Sites container already collapsed.")
			goto eXIT_fUNCTION

		end if
	end if

'Open the Snap In node
	if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, "~" + DSSITE_SNAPIN) then

		sleep MIN_WAIT

'Open the Sites node
		if b_wTreeItemCollapse_Ex(DEFAULT_ORDINAL, "~" + SITES_NODE) then

'Pause for a bit
			sleep MIN_WAIT

			bCollapseSitesContainer = TRUE
			LogIt(LVL_STATUSINFO, "Sites container collapsed successfully.")
			goto eXIT_fUNCTION

		end if

	end if

	bCollapseSitesContainer = FALSE
	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sites container not collapsed for unknown reasons.")

eXIT_fUNCTION:
	ExitSub("bCollapseSitesContainer")
		
End Function 'bCollapseSitesContainer


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenTransportsContainer
'
'	Finds the Inter-Site Transports container and expands it
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Tansports container expanded
'		FALSE if Transports container not expanded
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenTransportsContainer()

	EnterSub("bOpenTransportsContainer")

'Open the Sites node
	if bOpenSitesContainer then

'Verify that the Transports container exists
	if wTreeItemExists(DEFAULT_ORDINAL, INTERSITE_TRANSPORTS_NODE) = FALSE then

		LogIt(LVL_STATUSINFO, "Inter-Site Transports not found.")
		bOpenTransportsContainer = fALSE
		goto eXIT_fUNCTION

	end if

'If Transports node already expanded, jump out immeditaely
	if wTreeItemExpanded(DEFAULT_ORDINAL, INTERSITE_TRANSPORTS_NODE) then

		LogIt(LVL_STATUSINFO, "Transports container already opened.")


'Select the transports container to enumerate its children in the context pane
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, INTERSITE_TRANSPORTS_NODE) = TRUE then

			bOpenTransportsContainer = TRUE
			goto eXIT_fUNCTION

		else

			LogIt(LVL_STATUSINFO, "Transports container could not be selected in scope pane.")
			bOpenTransportsContainer = FALSE
			goto eXIT_fUNCTION

		end if


	end if


'Open the Transports node
		if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, INTERSITE_TRANSPORTS_NODE) then

			sleep MIN_WAIT

'Select the transports container to enumerate its children in the context pane
			if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, INTERSITE_TRANSPORTS_NODE) = TRUE then

				bOpenTransportsContainer = TRUE
				goto eXIT_fUNCTION

			else

				LogIt(LVL_STATUSINFO, "Transports container could not be selected in scope pane.")
				bOpenTransportsContainer = FALSE
				goto eXIT_fUNCTION

			end if

		end if

	end if

	bOpenTransportsContainer = FALSE
	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Transports container not opened.")



eXIT_fUNCTION:
	ExitSub("bOpenTransportsContainer")
			
End Function 'bOpenTransportsContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenSubnetsContainer
'
'	Finds the Subnets container and expands it
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Subnets container expanded
'		FALSE if Subnets container not expanded
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenSubnetsContainer()

	EnterSub("bOpenSubnetsContainer")

'Open the Sites node
	if bOpenSitesContainer then

'If Subnets node already exists, jump out immediately
		if wTreeItemExpanded(DEFAULT_ORDINAL, SUBNETS_NODE) = TRUE then

			LogIt(LVL_STATUSINFO, "Subnets container already opened.")


'Select the subnets node to enumerate children in content pane
			if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, SUBNETS_NODE) = TRUE then

				bOpenSubnetsContainer = TRUE
				goto eXIT_fUNCTION

			else

				LOG_VP(FAIL_PREFIX + "Subnets container not found in scope pane??")
				bOpenSubnetsContainer = FALSE
				goto eXIT_fUNCTION

			end if

		end if


'Open the Subnets node
		if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, SUBNETS_NODE) = FALSE then

			bOpenSubnetsContainer = FALSE
			goto eXIT_fUNCTION
			
		end if

'Select the subnets node to enumerate children in context pane
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, SUBNETS_NODE) = TRUE then

			bOpenSubnetsContainer = TRUE
			goto eXIT_fUNCTION

		else

				LOG_VP(FAIL_PREFIX + "Subnets container not found in scope pane??")

		end if

	else 'Sites node couldn't be opened.  Doc'd by called function.
	end if


	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Subnets container not opened.")
	bOpenSubnetsContainer = FALSE

eXIT_fUNCTION:
	ExitSub("bOpenSubnetsContainer")
			
End Function 'bOpenSubnetsContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenSpecificSiteContainer
'
'	Finds the given Site container and expands it
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Site container expanded
'		FALSE if Site container not found or not expanded
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenSpecificSiteContainer(sSiteName as string)

	EnterSub("bOpenSpecificSiteContainer [" + sSiteName + "]")

'Open the Sites node
	if bOpenSitesContainer then

'Open the specified site node
		Sleep(MIN_WAIT)
	'	if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, sSiteName) then
	     wTreeItemExpand(DEFAULT_ORDINAL, sSiteName)
			sleep MIN_WAIT
			bOpenSpecificSiteContainer = TRUE
			LogIt(LVL_STATUSINFO, "Site [" + sSiteName + "] container opened.")
			ExitSub("bOpenSpecificSiteContainer [" + sSiteName + "]")
			Exit Function

		'end if

	end if

	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] container not opened.")
	bOpenSpecificSiteContainer = FALSE
			
	ExitSub("bOpenSpecificSiteContainer [" + sSiteName + "]")

End Function 'bOpenSpecificSiteContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bOpenSpecificServerContainer
'
'	Finds the Server container for the given Site and expands it
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	RETURN VALUE
'		TRUE if Server container expanded
'		FALSE if Server container not found or not expanded
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bOpenSpecificServerContainer(sSiteName as string)

	EnterSub("bOpenSpecificServerContainer [" + sSiteName + "]")

'Open the Sites node
	if bOpenSitesContainer then

'Open the specified site node
		if bOpenSpecificSiteContainer(sSiteName) then

		sleep(MIN_WAIT)

'Can't just search for 'Servers' folder because there may be more than
'one open at a given time.

'One of the children in the site should be the Servers container if
'a servers container exists

			Dim lNumOfChildren as Long
			Dim lParentIndex as Long
			Dim lCount as Long

			lParentIndex = wTreeItemIndex(DEFAULT_ORDINAL, sSiteName)
			lNumOfChildren = wTreeItemCount(DEFAULT_ORDINAL, sSiteName)


'Cycle through each Parent+Child Index for "Servers" Folder
			for lCount = 1 to lNumOfChildren
				
				if TreeItemText(DEFAULT_ORDINAL, _ord(lParentIndex + lCount)) = SERVERS_NODE then

'Select and Expand the container 	
					b_wTreeItemClk_Ex(DEFAULT_ORDINAL, _ord(lParentIndex + lCount))
					b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, _ord(lParentIndex + lCount))

					sleep MIN_WAIT
					bOpenSpecificServerContainer = TRUE
					goto eXIT_fUNCTION

				end if

			next lCount

		end if

	end if

	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "[Servers] container for site [" + sSiteName + "] not opened.  Most likely does not exist.")
	bOpenSpecificServerContainer = FALSE

eXIT_fUNCTION:

	Sleep MIN_WAIT			
	ExitSub("bOpenSpecificServerContainer [" + sSiteName + "]")

End Function 'bOpenSpecificServerContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateSite
'
'	Attempt to create a site with the specified name.  When finished will attempt to open newly created
'	site node for verification.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of new site to create.
'		sSiteLink - name of link to use in creation of site.  Use DEFAULTIPSITELINK if none provided.
'
'	RETURN VALUE
'		TRUE if new site created
'		FALSE if new site not created
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCreateSite(	sSiteName as string, _
						sSiteLink=DEFAULT_FIRST_SITE_LINK as String) as Long


	EnterSub("bCreateSite [" + sSiteName + "]")

	
'Open Sites folder
	if bOpenSitesContainer then

'Select New Site from popup menu
		If b_wTreeItemClk_Ex(DEFAULT_ORDINAL, SITES_NODE, VK_RBUTTON) then
			
			If b_wMenuSelect_Ex(MNU_CREATE_NEW_SITE) then
		
'Small breather
				Sleep MIN_WAIT

'Should be at creation dialog.  Type name.
				b_Play_Ex(sSiteName)

'Select specified site link
				If b_wViewItemClk_Ex(DEFAULT_ORDINAL, sSiteLink) then

'Everything should be good, select OK
					If b_wButtonClick_Ex(BTN_OK) then
						Sleep (MAX_WAIT)

'A dialog box will appear if this is the first site created in this session OR if it has an error.
'Check for dialog box with Active Directory caption and clear it
						if (not (WFndWnd(CAP_ACTIVE_DIRECTORY) = 0) ) then
							Sleep(MAX_WAIT)
							b_wButtonClick_Ex(BTN_YES)	
							Sleep (MAX_WAIT)
							b_wButtonClick_Ex(BTN_OK)

						end if

						Sleep MIN_WAIT

'If No Error occured during creation then returned to console
						if GetText(wGetActWnd()) = CAP_CONSOLE1 then
							
'Verify that the new site was created
							if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, sSiteName) then

								LogIt(LVL_STATUSINFO, "Site [" + sSiteName + "] created using sitelink [" + sSiteLink + "].")
								bCreateSite = TRUE
								ExitSub("bCreateSite [" + sSiteName + "]")
								exit function

							end if

'Site creation process went flawlessly, but site did not show up in tree??!?
							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] should have been created." + _
									"Error unexplainable.  Redo test manually.")
						else

'Site already existed or there was some other error that prevented the return to the main console
							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] most likely already exists." + _
									" New site not created.")

'Back out of creation dialog and check for existence of site.
							bCloseDialogs(CAP_MMC)

							if wTreeItemExists(DEFAULT_ORDINAL, sSiteName) then

								LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] confirmed as already existing.")

							else

								LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] did not already, " + _
										"nor does it currently, exist.")
							end if

						end if

					else 'OK Button not found.  Error documented by called function.
					end if


				else 'specified sitelink does not exist.  Error documented by called function.
				end if


			else 'New site menu not found in popup box.  Error documented by called function.
			end if


		else 'Sites container not found. Error documented by called function.
		end if


	else 'Sites container could not be found/added/opened.  Error documented by called function.
	end if

	bCreateSite = FALSE
	ExitSub("bCreateSite [" + sSiteName + "]")

end function 'bCreateSite

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteSite
'
'	Deletes a site with the specified name.  Returns no error if site not found; the goal is for the site
'	to not exist, not to perform the deletion.  If site exists, but fails to delete, then failure is
'	returned.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of site to delete.
'
'	RETURN VALUE
'		TRUE if site no longer exists
'		FALSE if site still exists.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteSite(sSiteName as string) as long

	EnterSub("bDeleteSite [" + sSiteName + "]")

	Dim bResult as long


	'----- assume failure -----
	bResult = FALSE


	'----- Make sure the sites container is open, and contents enumerated in the content pane -----
	if bOpenSitesContainer then


		if bDeleteObject(DEFAULT_ORDINAL, sSiteName) = TRUE then
			bResult = TRUE
		End If
			

	end if			

	if bResult = TRUE then

		LogIt(LVL_STATUSINFO, "Site [" + sSiteName + "] deleted succesfully.")
		bDeleteSite = TRUE

	else

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site [" + sSiteName + "] not deleted.")
		bDeleteSite = FALSE

	end if
		

	ExitSub("bDeleteSite [" + sSiteName + "]")

end function 'bDeleteSite

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateSiteLink
'
'	Creates a link between the two sites specified using the given transport, (IP or SMTP), and
'	will default to IP.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sLinkName - name of link to be created
'		sSiteOne - name of first site
'		sSiteTwo - name of second site
'		sTransport - IP or SMTP, (IP by default)
'
'	RETURN VALUE
'		TRUE if sitelink created
'		FALSE if sitelink not created, (sites did not exist will cause this failure)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCreateSiteLink(sLinkName as String, _
						sSiteOne as String, _
						sSiteTwo as string, _
						sTransport="IP" as string) as long

	EnterSub("bCreateSiteLink [" + sSiteOne + "] to [" + sSiteTwo + "]")

'Access the transports container
	if bOpenTransportsContainer then

'Select the correct transport container, (IP or SMTP) and create new link
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sTransport, VK_RBUTTON) then
			if b_wMenuSelect_Ex(MNU_CREATE_NEW_SITELINK) then
				
				Sleep MIN_WAIT

'If only one site exists, then an error message will pop-up.
				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then
					
					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Only one site exists.  Not possible to create a site link.")
					b_wButtonClick_Ex(BTN_OK)
					b_wButtonClick_Ex(BTN_CANCEL)
					bCreateSiteLink = False
					goto dONE_cREATING_lINK

				end if

'Type the new site link name
				b_Play_Ex(sLinkName)

'If only two sites exist, the sites will have been automatically selected and put into the 
''Sites in the site link' list box
				LogIt(LVL_STATUSINFO, "Checking for 'ONLY TWO SITES' scenario.  ***NOTE: FAILURE HERE DOES NOT MEAN SCENARIO FAILED ***")
				if b_wListItemClk_Ex(ORD_NEWSITELINK_INLINK, sSiteOne) AND _
						b_wListItemClk_Ex(ORD_NEWSITELINK_INLINK, sSiteTwo) Then
							
					if b_wButtonClick_Ex(BTN_OK) then

						sleep MIN_WAIT
							
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK button.")
						bCreateSiteLink = False
						goto dONE_cREATING_lINK

					end if

				else

'Select the two items from the 'NOT IN LINK' box and add>>

'SITE ONE ------------------------->>>
					if b_wListItemClk_Ex(ORD_NEWSITELINK_NOTINLINK, sSiteOne) then
						if b_wButtonClick_Ex("~" + SM_STR_ADD) = FALSE then

							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving Add>> button.")
							bCreateSiteLink = False
							goto dONE_cREATING_lINK

						end if
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "First Site [" + sSiteOne + "] not found.")
						bCreateSiteLink = False
						goto dONE_cREATING_lINK

					end if

'SITE TWO ------------------------->>>
					if b_wListItemClk_Ex(ORD_NEWSITELINK_NOTINLINK, sSiteTwo) then
						if b_wButtonClick_Ex("~" + SM_STR_ADD) = FALSE then

							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving Add>> button.")
							bCreateSiteLink = False
							goto dONE_cREATING_lINK

						end if
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Second Site [" + sSiteOne + "] not found.")
						bCreateSiteLink = False
						goto dONE_cREATING_lINK

					end if

'Both sites moved over, all good.  Click OK.
					if b_wButtonClick_Ex(BTN_OK) then

						sleep MIN_WAIT
							
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK button.")
						bCreateSiteLink = False
						goto dONE_cREATING_lINK

					end if

				end if 'conditional branch between 2 sites and 3+ sites situations



'If there was a problem creating the site, (duplicate name, for example), it will error here
				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then
					
					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site link not created.  Most likely an object with this name already exists.")
					b_wButtonClick_Ex(BTN_OK)
					b_wButtonClick_Ex(BTN_CANCEL)
					bCreateSiteLink = False
					goto dONE_cREATING_lINK

				end if

'Verify that new site link showed up in context window

'The transport container should still be selected from above.  Therefore the context pane
'should already contain the contents of this transport container
				if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sLinkName) = FALSE then

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error...site link not created but should have.")
						bCreateSiteLink = False
						goto dONE_cREATING_lINK

				else

					bCreateSiteLink = TRUE

				end if

			end if 'New Site Link menu selection failed
		end if 'Could not find specified transport container
	end if 'Could not open transports container
		
dONE_cREATING_lINK:
'Make sure the link creation dialogs are abandoned
	if bCloseDialogs(GetText(WFndWnd("~" + CAP_CONSOLE1))) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all dialogs within the MMC.")
	end if	

	ExitSub("bCreateSiteLink [" + sSiteOne + "] to [" + sSiteTwo + "]")

end function 'bCreateSiteLink

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateSiteLinkBridge
'
'	Creates a bridge between the two sitelinks specified within the given transport.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sBridgeName - name of link to be created
'		sLinkOne - name of first site
'		sLinkTwo - name of second site
'		sTransport - IP or SMTP, (IP by default)
'
'	RETURN VALUE
'		TRUE if sitelink bridge created
'		FALSE if sitelink bridge not created, (If site links do not exist, this will cause failure)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCreateSiteLinkBridge(sBridgeName as String, _
						sLinkOne as String, _
						sLinkTwo as string, _
						sTransport="IP" as string) as long

	EnterSub("bCreateSiteLinkBridge [" + sLinkOne + "] to [" + sLinkTwo + "]")


'Access the transports container
	if bOpenTransportsContainer then

	Sleep(MIN_WAIT)

'Select the correct transport contaioner, (IP or SMTP) and create new link
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sTransport, VK_RBUTTON) then

			Sleep(MIN_WAIT)

			if b_wMenuSelect_Ex(MNU_CREATE_NEW_SITELINKBRIDGE) then

				Sleep MIN_WAIT

'If only one site exists, then an error message will pop-up.
				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then
					
					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Only one sitelink exists.  Not possible to create a sitelink Bridge.")
					b_wButtonClick_Ex(BTN_OK)
					b_wButtonClick_Ex(BTN_CANCEL)
					bCreateSiteLinkBridge = False
					goto dONE_cREATING_bRIDGE

				end if

'Type the new site link name
				b_Play_Ex(sBridgeName)

'If only two sites exist, the sites will have been automatically selected and put into the 
''Sites in the site link' list box
				LogIt(LVL_STATUSINFO, "Checking for 'ONLY TWO SITE LINKS' scenario.  ***NOTE: FAILURE HERE DOES NOT MEAN SCENARIO FAILED ***")
				if b_wListItemClk_Ex(ORD_NEWSITELINKBRIDGE_INLINK, sLinkOne) AND _
						b_wListItemClk_Ex(ORD_NEWSITELINKBRIDGE_INLINK, sLinkTwo) Then
							
					if b_wButtonClick_Ex(BTN_OK) then

						sleep MIN_WAIT
							
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK button.")
						bCreateSiteLinkBridge = False
						goto dONE_cREATING_bRIDGE

					end if

				else

'Select the two items from the 'NOT IN LINK' box and add>>

'SITE ONE ------------------------->>>
					if b_wListItemClk_Ex(ORD_NEWSITELINKBRIDGE_NOTINLINK, sLinkOne) then
						if b_wButtonClick_Ex("~" + SM_STR_ADD) = FALSE then

							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving Add>> button.")
							bCreateSiteLinkBridge = False
							goto dONE_cREATING_bRIDGE

						end if
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "First Link [" + sLinkOne + "] not found.")
						bCreateSiteLinkBridge = False
						goto dONE_cREATING_bRIDGE

					end if

'SITE TWO ------------------------->>>
					if b_wListItemClk_Ex(ORD_NEWSITELINKBRIDGE_NOTINLINK, sLinkTwo) then
						if b_wButtonClick_Ex("~" + SM_STR_ADD) = FALSE then

							LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving Add>> button.")
							bCreateSiteLinkBridge = False
							goto dONE_cREATING_bRIDGE

						end if
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Second Link [" + sLinkOne + "] not found.")
						bCreateSiteLinkBridge = False
						goto dONE_cREATING_bRIDGE

					end if

'Both sites moved over, all good.  Click OK.
					if b_wButtonClick_Ex(BTN_OK) then

						sleep MIN_WAIT
							
					else

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK button.")
						bCreateSiteLinkBridge = False
						goto dONE_cREATING_bRIDGE

					end if

				end if 'conditional branch between 2 sites and 3+ sites situations

'If there was a problem creating the site, (duplicate name, for example), it will error here
				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then
					
					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Site link not created.  Most likely a link or bridge object with this name already exists.")
					b_wButtonClick_Ex(BTN_OK)
					b_wButtonClick_Ex(BTN_CANCEL)
					bCreateSiteLinkBridge = False
					goto dONE_cREATING_bRIDGE

				end if

'Verify that new site link showed up in context window

'The transport container should still be selected from above.  Therefore the context pane
'should already contain the contents of this transport container
				if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sBridgeName) = FALSE then

						LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error...site link not created but should have.")
						bCreateSiteLinkBridge = False
						goto dONE_cREATING_bRIDGE

				else

					bCreateSiteLinkBridge = TRUE

				end if

			end if 'New Site Link menu selection failed
		end if 'Could not find specified transport container
	end if 'Could not open transports container


dONE_cREATING_bRIDGE:
'Make sure the bridge creation dialogs are abandoned
	if bCloseDialogs(GetText(WFndWnd("~" + CAP_CONSOLE1))) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all dialogs within the MMC.")
	end if		

	ExitSub("bCreateSiteLinkBridge [" + sLinkOne + "] to [" + sLinkTwo + "]")

end function 'bCreateSiteLinkBridge

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteSiteLink
'
'	Deletes a sitelink with the specified name and trnasport.  Returns no error if site not found;
'	the goal is for the link to not exist, not to perform the deletion.
'	If link exists, but fails to delete, then failure is returned.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sLinkName - name of site to delete.
'		sTransport - the transport containing the link
'
'	RETURN VALUE
'		TRUE if link no longer exists
'		FALSE if link still exists.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteSiteLink(sLinkName as string, sTransport as string) as long

	Dim bResult as long

	EnterSub("bDeleteSiteLink [" + sLinkName + "]")

'Make sure the transports container is open
	if bOpenTransportsContainer then

'Select the transport, bringing up all of the links in the context pane
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sTransport, VK_LBUTTON) then

'Breathe a bit just in case transport folder is slow in opening
			Sleep MIN_WAIT

'Select the appropriate object in the context pane and clear dialogs
			if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sLinkName, VK_RBUTTON) then
				if b_wMenuSelect_Ex(MNU_DELETE) then
					if b_wButtonClick_Ex(BTN_YES) then

'Verify the site no longer exists
						bResult = wViewItemExists(DEFAULT_ORDINAL, sLinkName)

					end if
				end if
			end if
		end if
	end if			

	if bResult = FALSE then

		LogIt(LVL_STATUSINFO, "Sitelink [" + sLinkName + "] deleted succesfully.")
		bDeleteSiteLink = TRUE

	else

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sitelink [" + sLinkName + "] not deleted.")
		bDeleteSiteLink = FALSE

	end if
		

	ExitSub("bDeleteSiteLink [" + sLinkName + "]")

end function 'bDeleteLink

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteSiteLinkBridge
'
'	Deletes a sitelink bridge with the specified name and transport.  Returns no error if site not found;
'	the goal is for the bridge to not exist, not to perform the deletion.
'	If bridge exists, but fails to delete, then failure is returned.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sBridgeName - name of site to delete.
'		sTransport - the transport containing the link
'
'	RETURN VALUE
'		TRUE if bridge no longer exists
'		FALSE if bridge still exists.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteSiteLinkBridge(sBridgeName as string, sTransport as string) as long

	Dim bResult as long

	EnterSub("bDeleteSiteLink [" + sBridgeName + "]")

'Make sure the transports container is open
	if bOpenTransportsContainer then

'Select the transport, bringing up all of the links in the context pane
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sTransport, VK_LBUTTON) then

'Breathe a bit just in case transport folder is slow in opening
			Sleep MIN_WAIT

'Select the appropriate object in the context pane and clear dialogs
			if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sBridgeName, VK_RBUTTON) then
				if b_wMenuSelect_Ex(MNU_DELETE) then
					if b_wButtonClick_Ex(BTN_YES) then

'Verify the site no longer exists
						bResult = wViewItemExists(DEFAULT_ORDINAL, sBridgeName)

					end if
				end if
			end if
		end if
	end if			

	if bResult = FALSE then

		LogIt(LVL_STATUSINFO, "Sitelink [" + sBridgeName + "] deleted succesfully.")
		bDeleteSiteLinkBridge = TRUE

	else

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Sitelink [" + sBridgeName + "] not deleted.")
		bDeleteSiteLinkBridge = FALSE

	end if
		

	ExitSub("bDeleteSiteLinkBridge [" + sBridgeName + "]")

end function 'bDeleteSiteLinkBridge

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateServer
'
'	Creates a Servers inside the servers container for the specified site.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of site to use.
'		sServerName - name of new server
'		bSkipFindContainer - DEFAULT=FALSE - if set to true, then the function will not
'				attempt to locate the apropriate site/server container combination and assume
'				that the calling function has already verified that the only visible server container
'				in the scope pane is the one to be used
'
'
'	RETURN VALUE
'		TRUE if new server created
'		FALSE if new server not created
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCreateServer(	sSiteName as String, _
						sServerName as String, _
						bSkipFindContainer=FALSE as Long) as Long

	EnterSub("bCreateServer [" + sServerName + "] in Site [" + sSiteName + "]")



'Assume Failure will occur
	bCreateServer = FALSE



'Check to see if server object with this name already exists. 
'Note: lFindServer returns the index of the server, not true/false
	if lFindServer(sSiteName, sServerName, bSkipFindContainer) <> FALSE then
		
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Server [" + sServerName + "] already exists in site [" + sSiteName + "]")

	end if



'Open the context menu for the Servers Container
	wTreeItemClk(ORD_1, SERVERS_NODE, VK_RBUTTON) 

	Sleep(MIN_WAIT)

'Creating a 'new' Server from the context menu
	if b_wMenuSelect_Ex(MNU_CREATE_NEW) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select New Server from context menu.")

	endif

	Sleep(MIN_WAIT)

	if b_wMenuSelect_Ex(MNU_SERVER) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select New Server from context menu.")	

	end if



'The new Server dialog should appear
		CaptionSleep(CAP_CREATE_NEW)
		if instr(GetText(wGetActWnd()), CAP_CREATE_NEW) = FALSE then

			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Create new Server dialog did not appear.")



'Type the name of the server
		elseif b_Play_Ex(sServerName) = FALSE then

			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not type name of new server in creation dialog.")



'Click OK and return to MMC
		elseif b_wButtonClick_Ex(BTN_OK) = FALSE then

			LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK button!!?!?!")

		else


'If an active directory message box appears, then there was some error during creation
			Sleep MIN_WAIT
			if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not create server.  Likely invalid name.")

'Clear out the dialogs
				if bCloseDialogs(CAP_MMC) = FALSE then

					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not automatically return to MMC after Server creation failure.")

				end if

			else


'Should return to the MMC
				CaptionSleep(CAP_MMC)
			
				

'----- Server should be created.  Make sure it's part of the tree and in the correct container. -----

'Check to see if server exists.
				if lFindServer(sSiteName, sServerName, bSkipFindContainer) = FALSE then

					LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not find newly created server.")

				else



'If here then all went as planned.
					bCreateServer = TRUE

				end if
			end if
		end if

		
		
	ExitSub("bCreateServer")

end function 'bCreateServer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	lFindServer
'
'	Locates a Servers inside the servers container for the specified site.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of site to use.
'		sServerName - name of new server
'		bSkipFindContainer - DEFAULT=FALSE - if set to true, then the function will not
'				attempt to locate the apropriate site/server container combination and assume
'				that the calling function has already verified that the only visible server container
'				in the scope pane is the one to be used
'
'	RETURN VALUE
'		Ordinal number of the tree list item that is the server object.
'		Returns 0 (FALSE) if server not found
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function lFindServer(	sSiteName as String, _
						sServerName as String, _
						bSkipFindContainer=FALSE as Long) as Long

	EnterSub("lFindServer [" + sServerName + "] in Site [" + sSiteName + "]")



	Dim bTempResult as Long
	Dim lOutput as Long
	Dim lNumOfChildren as Long
	Dim lParentIndex as Long
	Dim lCount as Long
	


'Check to see if the skip container flag has been set
	if bSkipFindContainer = TRUE then


'Only one server container should be open.  Expand it, and the server to be found should be inside
	'	if b_wTreeItemExpand_Ex(ORD_1, SERVERS_NODE) = TRUE then
	
		wTreeItemExpand(ORD_1, SERVERS_NODE)

			Sleep MIN_WAIT

'The server should now be an item in the tree list.  Verify then return index value.
			if wTreeItemExists(ORD_1, sServerName) = TRUE then
				
				lOutput = wTreeItemIndex(ORD_1, sServerName)
				goto eXIT_fUNCTION

			end if

	'	end if

	end if



'----- if here, then either the skip flag was not set or the skip search failed to find
'the desired server.  Attempting the exhaustive search... -----'	



'Open desired server container 
	if bOpenSpecificServerContainer(sSiteName) = TRUE then

'Can't just search for 'Servers' folder because there may be more than
'one site open at a given time.

'One of the children in the site should be the Servers container if
'a servers container exists

		lParentIndex = wTreeItemIndex(DEFAULT_ORDINAL, sSiteName)
		lNumOfChildren = wTreeItemCount(DEFAULT_ORDINAL,sSiteName)

'Cycle through each Parent+Child Index for "Servers" Folder
		for lCount = 1 to lNumOfChildren
				
			if TreeItemText(DEFAULT_ORDINAL, _ord(lParentIndex + lCount)) = SERVERS_NODE then

				bTempResult = TRUE
				exit for

			end if

		next lCount

		If bTempResult = FALSE then
				
			LOG_VP(FAIL_PREFIX + "Could not locate [Servers] container for site [" + sSiteName + "]")
			goto eXIT_FUNCTION

		end if

'The server container was found.  Open the servers container.
		if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, TreeItemText(DEFAULT_ORDINAL, _
				_ord(lParentIndex + lCount))) then

			Sleep MIN_WAIT

'New Parent node will be the server continer nder the site
			lParentIndex = lParentIndex + lCount
			lNumOfChildren = wTreeItemCount(DEFAULT_ORDINAL, _ord(lParentIndex))

			'LOG_VP("***TESTOUT: ParentIndex:" + TreeItemText("@1", _ord(lParentIndex)))
			'LOG_VP("***TESTOUT: Children:" + str(lNumOfChildren))

'Cycle through each Parent+Child Index for "Servers" Folder
'			if WTreeItemExists(DEFAULT_ORDINAL,sServerName) then
'
'				lOutput= WTreeItemIndex(DEFAULT_ORDINAL,sServerName)
'				goto eXIT_FUNCTION
'
'			endif

DIM dummystring as string
			for lCount = 1 to lNumOfChildren

			'	LOG_VP("***TESTOUT: ParentIndex:" + TreeItemText(DEFAULT_ORDINAL, _ord(lParentIndex + lCount)))
			dummystring = TreeItemText(DEFAULT_ORDINAL, _ord(lParentIndex + lCount))
			Sleep(MIN_WAIT)
				if dummystring = sServerName then

				   
'All Good.  Return index value of server in tree
					lOutput = lParentIndex + lCount 
				
					goto eXIT_FUNCTION

				end if

			next lCount

		end if 'could not expand Servers container???

	else 'Sites container could not be found/added/opened.  Error documented by called function.
	end if

	lOutput = FALSE

eXIT_fUNCTION:

	lFindServer = lOutput
	ExitSub("lFindServer [" + sServerName + "] in Site [" + sSiteName + "] RES =" + str(lOutPut))

end function 'lFindServer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bMoveServer
'
'	Moves a server from one site to another
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sServerName - name of server to move
'		sFromSite - name of current server site
'		sToSite - name of site to send server to
'
'	RETURN VALUE
'		TRUE if server moved successfully
'		FALSE if server not moved successfully
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bMoveServer(sServerName as string, sFromSite as String, sToSite as String) as long

	EnterSub("bMoveServer [" + sServerName + "] (from->to : [" + sFromSite + "] -> [" + sToSite + "]")

	Dim lServerIndex as Long

	lServerIndex = lFindServer(sFromSite, sServerName)
	
'Check to see if server exists.
	if lServerIndex = FALSE then
		
		LOG_VP("Server [" + sServerName + "] not found in site [" + sFromSite + "].")
		bMoveServer = FALSE
		goto eXIT_fUNCTION

	end if

	bOpenSpecificServerContainer(sFromSite)

'Open context menu for the Server
	If b_wViewItemClk_Ex(DEFAULT_ORDINAL, _ord(lServerIndex), VK_RBUTTON) then

'Opt 'MOVE' the server from the menu
		If b_wMenuSelect_Ex(MNU_MOVE) then
		
'Wait for the display
			CaptionSleep(CAP_MOVE_TO + " " + RES_TYPE_SERVER)

'Find the site to move the server to in the view list
			if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sToSite) then

				if b_wButtonClick_Ex(BTN_OK) then

'If a message box appeared, then an error happened

					Sleep MIN_WAIT
					if GetText(wGetActWnd()) <> CAP_ACTIVE_DIRECTORY then

'Verify server left the old site

						if lFindServer(sFromSite, sServerName) = FALSE then

'Verify showed up in expected site
							if lFindServer(sToSite, sServerName) then

'All is good.  Move accomplished succesfully
								bMoveServer = TRUE
								goto eXIT_fUNCTION

							else

								LOG_VP(FAIL_PREFIX + "Server [" + sServerName + _
										"] not present in new site [" + sToSite + "]")

							end if

						else

							LOG_VP(FAIL_PREFIX + "Server [" + sServerName + _
									"] not not removed from old site [" + sToSite + "]")

						end if

					else
						
						LOG_VP(FAIL_PREFIX + "Unexpected error occured during move." + _
							"Not related to duplicate server in destination site as this " + _
							"was already ruled out.")

					end if
					
				else 'Error clicking OK button???!?!?
				end if
			else 'destination sit enot listed as a possiblitiy
			end if

		else 'Site container not found in tree??? Error documented by called function.
		end if

	else 'Sites container could not be found/added/opened.  Error documented by called function.
	end if

	bMoveServer = FALSE

eXIT_fUNCTION:
	ExitSub("bMoveServer [" + sServerName + "] (from->to : [" + sFromSite + "] -> [" + sToSite + "]")

end function 'bMoveServer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	lOpenSpecificServer
'
'	Opens a the specified server node to expose the NTDS settings object underneath, (if
'	the server is a DC, of course.  Otherwise, this will only select the server.)
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of server site
'		sServerName - name of server to open

'
'	RETURN VALUE
'		Index value of server in Scope Tree
'		FALSE if server not opened successfully
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function lOpenSpecificServer(sSiteName as String, sServerName as string) as long

	EnterSub("lOpenSpecificServer [" + sServerName + "] in site [" + sSitename + "]")

	Dim lServerTreeIndex as Long

'Locate server in scope tree
	lServerTreeIndex = lFindServer(sSiteName, sServerName)
	if lServerTreeIndex = FALSE then

		LOG_VP(FAIL_PREFIX + "Could not locate specified server.")
		lOpenSpecificServer = FALSE
		goto eXIT_fUNCTION

	end if


'Open tree
	if b_wTreeItemExpand_Ex(DEFAULT_ORDINAL, _ord(lServerTreeIndex)) = FALSE then

		LOG_VP(FAIL_PREFIX + "Could not locate specified server.")
		lOpenSpecificServer = FALSE
		goto eXIT_fUNCTION

	end if

'If here, then the server was found, opened and selected.
	lOpenSpecificServer = lServerTreeIndex

eXIT_fUNCTION:
	ExitSub("lOpenSpecificServer [" + sServerName + "] in site [" + sSitename + "]")

end function 'lOpenSpecificServer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bSelectSpecificServerNTDSSettings
'
'	Clicks on the NTDS settings of the specified server to enumerate the connections
'	in the content pane.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of server site
'		sServerName - name of server to move

'
'	RETURN VALUE
'		TRUE if server moved successfully
'		FALSE if server not moved successfully
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bSelectSpecificServerNTDSSettings(sSiteName as String, sServerName as string) as long

	EnterSub("bSelectSpecificServerNTDSSettings [" + sServerName + "] in site [" + sSitename + "]")

	Dim lServerTreeIndex as Long
	Dim lServerChildIndex as Long

'Locate server in scope tree
	lServerTreeIndex = lOpenSpecificServer(sSiteName, sServerName)
	if lServerTreeIndex = FALSE then

		LOG_VP(FAIL_PREFIX + "Could not locate specified server.")
		bSelectSpecificServerNTDSSettings = FALSE
		goto eXIT_fUNCTION

	end if


'Find the first NTDS settings object under the server
	for lServerChildIndex = 1 to wTreeItemCount(DEFAULT_ORDINAL, _ord(lServerTreeIndex))
		
		if TreeItemText(DEFAULT_ORDINAL, _ord(lServerTreeIndex + lServerChildIndex)) = NTDSSETTINGS_NODE then
			
			if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, _ord(lServerTreeIndex + lServerChildIndex)) = FALSE then
					
				LOG_VP(FAIL_PREFIX + "Could not click on NTDS Settings in Scope Pane")
				bSelectSpecificServerNTDSSettings = FALSE
				goto eXIT_fUNCTION

			end if

'The proper NTDS settings object should be selected now.

		end if

	next lServerIndex

	bSelectSpecificServerNTDSSettings = TRUE

eXIT_fUNCTION:
	Sleep MIN_WAIT
	ExitSub("bSelectSpecificServerNTDSSettings [" + sServerName + "] in site [" + sSitename + "]")

end function 'bSelectSpecificServerNTDSSettings


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bMakeServerGC
'
'	Set the GC-Flag on the NTDS Settings object corresponding to the specified server
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of server site
'		sServerName - name of server to make a GC

'
'	RETURN VALUE
'		TRUE if server became a GC
'		FALSE if server did not become a GC
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bMakeServerGC(	sSiteName as String, _
						sServerName as String) as long

	EnterSub("bMakeServerGC [" + sServerName + "] in site [" + sSitename + "]")

	Dim lServerTreeIndex as Long
	Dim lServerChildIndex as Long



	'----- Locate server in scope tree-----
	lServerTreeIndex = lOpenSpecificServer(sSiteName, sServerName)
	if lServerTreeIndex = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not locate specified server.")
		bMakeServerGC = FALSE
		goto eXIT_fUNCTION

	end if


	'----- open the properties page for the NTDS settings object -----
	if bOpenProperties(DEFAULT_ORDINAL, NTDSSETTINGS_NODE) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not open properties page.")
		bMakeServerGC = FALSE
		goto eXIT_fUNCTION

	end if


	'----- set the GC flag -----
	if b_wCheckBoxCheck_Ex(NTDSSETTINGS_GENERAL_BTN_GC, CHECKED) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not set GC Flag")
		bMakeServerGC = FALSE
		goto eXIT_fUNCTION

	End If


	'----- close the properties page -----
	if b_wButtonClick_Ex(BTN_OK) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK buton!?!?!?")
		bMakeServerGC = FALSE
		goto eXIT_fUNCTION

	End If


	'----- should return to the MMC -----
	CaptionSleep(CAP_MMC)


	bMakeServerGC = TRUE

eXIT_fUNCTION:
	Sleep MIN_WAIT
	ExitSub("bMakeServerGC [" + sServerName + "] in site [" + sSitename + "]")

end function 'bMakeServerGC

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bMakeServerNOTGC
'
'	Remove the GC-Flag on the NTDS Settings object corresponding to the specified server
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - name of server site
'		sServerName - name of server to make a GC

'
'	RETURN VALUE
'		TRUE if server GC flag is unset
'		FALSE if server GC flag did not get changed
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bMakeServerNOTGC(	sSiteName as String, _
						sServerName as String) as long

	EnterSub("bMakeServerNOTGC [" + sServerName + "] in site [" + sSitename + "]")

	Dim lServerTreeIndex as Long
	Dim lServerChildIndex as Long



	'----- Locate server in scope tree-----
	lServerTreeIndex = lOpenSpecificServer(sSiteName, sServerName)
	if lServerTreeIndex = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not locate specified server.")
		bMakeServerNOTGC = FALSE
		goto eXIT_fUNCTION

	end if


	'----- open the properties page for the NTDS settings object -----
	if bOpenProperties(DEFAULT_ORDINAL, NTDSSETTINGS_NODE) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not open properties page.")
		bMakeServerNOTGC = FALSE
		goto eXIT_fUNCTION

	end if


	'----- set the GC flag -----
	if b_wCheckBoxCheck_Ex(NTDSSETTINGS_GENERAL_BTN_GC, UNCHECKED) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not unset GC Flag")
		bMakeServerNOTGC = FALSE
		goto eXIT_fUNCTION

	End If


	'----- close the properties page -----
	if b_wButtonClick_Ex(BTN_OK) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Unexpected error involving OK buton!?!?!?")
		bMakeServerNOTGC = FALSE
		goto eXIT_fUNCTION

	End If


	'----- should return to the MMC -----
	CaptionSleep(CAP_MMC)


	bMakeServerNOTGC = TRUE

eXIT_fUNCTION:
	Sleep MIN_WAIT
	ExitSub("bMakeServerNOTGC [" + sServerName + "] in site [" + sSitename + "]")

end function 'bMakeServerNOTGC


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCheckLocation
'
'	Alters the location field of the given object. Verifies new
'	location appears in context pane, then replaces prior text.
'
'	ASSUMES
'		The object to be opened is a currently selectable item in the
'		context pane
'
'	PARAMETERS:
'		sViewList - identifier of the context pane
'		sViewItem - identifier of object to open the properties of
'
'	RETURN VALUE:
'		TRUE if the location box works as expected
'		FALSE if otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCheckLocation(sViewList as String, sViewItem as String) as Long

	EnterSub("bCheckLocation [" + sViewItem +"]")

	Dim sOldLocation as String

'open properties page
	If bOpenProperties(sViewList, sViewItem) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Could not open properties page.")
		goto eXIT_fUNCTION

	end if

'Verify tabs exist then goto the 'Location' tab
	if wTabExists(DEFAULT_ORDINAL) = FALSE then
		
		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "No tab control on current dialog.")
		goto eXIT_fUNCTION

	end if

	if wTabItemExists(DEFAULT_ORDINAL, PROP_TAB_LOCATION) = FALSE then
		
		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Location Tab not an option in current dialog")
		goto eXIT_fUNCTION

	end if

	wTabItemClk(DEFAULT_ORDINAL, PROP_TAB_LOCATION)

	Sleep(MIN_WAIT)

'Verify Browse button brings up the Browse for location dialog if the browse button is
'enabled.
	if wButtonEnabled(VP_BTN_BROWSE) = TRUE then

		if b_wButtonClick_Ex(VP_BTN_BROWSE) = FALSE then

			bCheckLocation = FALSE
			LogIt(LVL_STATUSINFO, "Browse button could not be clicked.")
			goto eXIT_fUNCTION

		end if

		Sleep MIN_WAIT


		if GetText(wGetActWnd()) = DLG_CAP_BROWSELOCATION then

			bCheckLocation = FALSE
			LogIt(LVL_STATUSINFO, "Browse dialog did not appear.")
			goto eXIT_fUNCTION

		end if

'Clear the browse dialog
		if b_wButtonClick_Ex(BTN_CANCEL) = FALSE then

			bCheckLocation = FALSE
			LogIt(LVL_STATUSINFO, "Browse button could not be clicked.")
			goto eXIT_fUNCTION

		end if

		Sleep MIN_WAIT
				
	end if


'Make a note of the current description, then write new one
	Sleep(MIN_WAIT)

	sOldLocation = EditText( PROP_LOCATION_TEXT_LOCATION )

	if wEditEnabled( PROP_LOCATION_TEXT_LOCATION ) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Location box not enabled.")
		goto eXIT_fUNCTION

	end if

	wEditSetText( PROP_LOCATION_TEXT_LOCATION, TEXT_TESTSTRING)
	
	sleep(MIN_WAIT)

'return to MMC
	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "OK button not found on Properties dialog????")
		goto eXIT_fUNCTION
	
	end if

	CaptionSleep(CAP_CONSOLE1)

'Refresh the context pane so that the new description pops up
	if bRefreshContextPane() = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Refresh of context pane failed.  Can't verify change in description.")
		goto eXIT_fUNCTION

	end if

'Verify description in content list, (if such a header exists...)
	if wViewHeaderExists(sViewList, "~" + PROP_TAB_LOCATION) = TRUE then

		
		if ViewItemText(sViewList, sViewItem, "~" + PROP_TAB_LOCATION) <> TEXT_TESTSTRING then

			bCheckLocation = FALSE
			LogIt(LVL_STATUSINFO, "Location of item [" + ViewItemText(sViewList, sViewItem, "~" + SM_STR_DESCRIPTION) + _
					" does not match test string.")
			goto eXIT_fUNCTION

		end if

	else
		
		LogIt(LVL_DEBUGGING, "Location header does not exist in content pane.  Skipping check.")

	end if
		
'Open properties page and replace old string
	If bOpenProperties(sViewList, sViewItem) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Could not open properties page to replace old location.")
		goto eXIT_fUNCTION

	end if

'Verify tabs exist then goto the 'General' tab
	if wTabExists(DEFAULT_ORDINAL) = FALSE then
		
		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "No tab control on current dialog.")
		goto eXIT_fUNCTION

	end if

	'Goto the 'General' tab
	if wTabItemExists(DEFAULT_ORDINAL, PROP_TAB_LOCATION) = FALSE then
		
		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "General Tab not an option in current dialog")
		goto eXIT_fUNCTION

	end if

	wTabItemClk(DEFAULT_ORDINAL, PROP_TAB_LOCATION)

'Replace the old text
	if wEditEnabled( SITE_LOCATION_EDT_Location ) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "Description box not enabled. Can't replace old text.")
		goto eXIT_fUNCTION

	end if

	wEditSetText( SITE_LOCATION_EDT_Location, sOldLocation)

	'return to MMC
	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		bCheckLocation = FALSE
		LogIt(LVL_STATUSINFO, "OK button not found on Properties dialog????")
		goto eXIT_fUNCTION
	
	end if

	CaptionSleep(CAP_CONSOLE1)
	bCheckLocation = TRUE



eXIT_fUNCTION:
	ExitSub("bCheckLocation")
	
End Function 'bCheckLocation

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateLicensingSettings
'
'	Creates a Site Licensing Settings Object for the specified site.
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site to add the settings object to
'
'	RETURN VALUE:
'		TRUE if setting created
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCreateLicensingSettings(sSiteName as String) as Long

	EnterSub("bCreateLicensingSettings")

'Locate and open site
	if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
		LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
		bCreateLicensingSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Check for existing Licensing Setting object
	if b_wViewItemClk_Ex(DEFAULT_ORDINAL, RES_TYPE_SITELICENSE) = TRUE then

		LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + "] already contains a licensing settings object.")
		bCreateLicensingSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Open context menu and create new Licensing Settings Object
	if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sSiteName, VK_RBUTTON) then
		if b_wMenuSelect_Ex(MNU_CREATE_NEW) then
			if b_wMenuSelect_Ex(MNU_SITE_LICENSE) then

'A message box will appear.  If it is an 'Active Directory' messagebox then an error occured
				sleep MIN_WAIT

				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

					b_wButtonClick_Ex(BTN_OK)	
					LOG_VP("Some unecpected error occured preventing creation. Manual review.")
					bCreateLicensingSettings = FALSE
					goto eXIT_fUNCTION

				end if
				
				b_wButtonClick_Ex(BTN_OK)

'Make sure new object appeared in proper place.
'Locate and open site
				if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
					LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
					bCreateLicensingSettings = FALSE
					goto eXIT_fUNCTION

				end if

'Check for existing Licensing Setting object
				if b_wViewItemClk_Ex(DEFAULT_ORDINAL, RES_TYPE_SITELICENSE) = FALSE then

					LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + _
							"] does not contain the new Licensing object.")
					bCreateLicensingSettings = FALSE
					goto eXIT_fUNCTION

				end if

			else 'No option for licensing settings on context menu. Doc'd by called function.
			end if
		else 'No 'New' option on context menu. Doc'd by called function.
		end if
	else 'Site name not found in tree. Should not be possible as we assured this previously.
	end if


	bCreateLicensingSettings = TRUE

eXIT_fUNCTION:
	ExitSub("bCreateLicensingSettings")

end function 'bCreateLicensingSettings


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateSiteSettings
'
'	Creates a Site Settings Object for the specified site.
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site to add the settings object to
'
'	RETURN VALUE:
'		TRUE if setting created
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCreateSiteSettings(sSiteName as String) as Long

	EnterSub("bCreateSiteSettings")

'Locate and open site
	if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
		LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
		bCreateSiteSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Check for existing Site Setting object
	if b_wViewItemClk_Ex(DEFAULT_ORDINAL, SITE_SETTINGS) = TRUE then

		LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + "] already contains a site settings object.")
		bCreateSiteSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Open context menu and create new Site Settings Object
	if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sSiteName, VK_RBUTTON) then
		if b_wMenuSelect_Ex(MNU_CREATE_NEW) then
			if b_wMenuSelect_Ex(MNU_SITE_SETTINGS) then

'A message box will appear.  If it is an 'Active Directory' messagebox then an error occured
				sleep MIN_WAIT

				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

					b_wButtonClick_Ex(BTN_OK)	
					LOG_VP("Some unecpected error occured preventing creation. Manual review.")
					bCreateSiteSettings = FALSE
					goto eXIT_fUNCTION

				end if
				
				b_wButtonClick_Ex(BTN_OK)

'Make sure new object appeared in proper place.
'Locate and open site
				if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
					LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
					bCreateSiteSettings = FALSE
					goto eXIT_fUNCTION

				end if

'Check for existing Licensing Setting object
				if b_wViewItemClk_Ex(DEFAULT_ORDINAL, SITE_SETTINGS) = FALSE then

					LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + _
							"] does not contain the new Site Settings object.")
					bCreateSiteSettings = FALSE
					goto eXIT_fUNCTION

				end if

			else 'No option for site settings on context menu. Doc'd by called function.
			end if
		else 'No 'New' option on context menu. Doc'd by called function.
		end if
	else 'Site name not found in tree. Should not be possible as we assured this previously.
	end if


	bCreateSiteSettings = TRUE

eXIT_fUNCTION:
	ExitSub("bCreateSiteSettings")

end function 'bCreateSiteSettings

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteSiteSettings
'
'	Deletes a Site Settings Object for the specified site.  Will return
'	true if an object doe snot already exist, (the point of this call is
'	to get rid of the object, if one's not there, then this passes).
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site to delet the settings object from
'
'	RETURN VALUE:
'		TRUE if child object Deleted
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteSiteSettings(sSiteName as String) as Long

	EnterSub("bDeleteSiteSettings")

'Locate and open site
	if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
		LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
		bDeleteSiteSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Check for existing Site Setting object while bringing up context menu
	if b_wViewItemClk_Ex(DEFAULT_ORDINAL, SITE_SETTINGS, VK_RBUTTON) = FALSE then

		LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + "] does not contain a site settings object.")
		bDeleteSiteSettings = TRUE
		goto eXIT_fUNCTION

	end if

'Delete Site Settings Object
	if b_wMenuSelect_Ex(MNU_DELETE) = TRUE then

'A message box will appear, (should be Active Directory msgbox).  Select 'yes' to confirm...
		sleep MIN_WAIT

		if GetText(wGetActWnd()) <> CAP_ACTIVE_DIRECTORY then

				b_wButtonClick_Ex(BTN_OK)	
				LOG_VP("Some unexpected error occured preventing creation. Manual review.")
				bDeleteSiteSettings = FALSE
				goto eXIT_fUNCTION

		end if
				
		b_wButtonClick_Ex(BTN_YES)

'Make sure deletion occured as expected

'Locate and open site
		if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
			LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "] to verify deletion.")
			bDeleteSiteSettings = FALSE
			goto eXIT_fUNCTION

		end if

'Check for existing Licensing Setting object
		if b_wViewItemClk_Ex(DEFAULT_ORDINAL, SITE_SETTINGS) = TRUE then

			LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + _
					"] still contains the deleted object..")
			bDeleteSiteSettings = FALSE
			goto eXIT_fUNCTION

		end if

	else 'Site name not found in tree. Should not be possible as we assured this previously.
	end if


	bDeleteSiteSettings = TRUE

eXIT_fUNCTION:
	ExitSub("bDeleteSiteSettings")

end function 'bDeleteSiteSettings

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteLicensingSettings
'
'	Deletes a Licensing Settings Object for the specified site.  Will return
'	true if an object does not already exist, (the point of this call is
'	to get rid of the object, if one's not there, then this passes).
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site to delet the settings object from
'
'	RETURN VALUE:
'		TRUE if child object Deleted
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteLicensingSettings(sSiteName as String) as Long

	EnterSub("bDeleteLicensingSettings")

'Locate and open site
	if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
		LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "].")
		bDeleteLicensingSettings = FALSE
		goto eXIT_fUNCTION

	end if

'Check for existing Site Setting object while bringing up context menu
	if b_wViewItemClk_Ex(DEFAULT_ORDINAL, RES_TYPE_SITELICENSE, VK_RBUTTON) = FALSE then

		LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + "] does not contain a site licensing object.")
		bDeleteLicensingSettings = TRUE
		goto eXIT_fUNCTION

	end if

'Delete Licesing Settings Object
	if b_wMenuSelect_Ex(MNU_DELETE) = TRUE then

'A message box will appear.  Select 'yes' to confirm...
		sleep MIN_WAIT

		if GetText(wGetActWnd()) <> CAP_ACTIVE_DIRECTORY then

				bCloseDialogs(CAP_CONSOLE1)
				LOG_VP("Some unexpected error occured preventing creation. Manual review.")
				bDeleteLicensingSettings = FALSE
				goto eXIT_fUNCTION

		end if
				
		b_wButtonClick_Ex(BTN_YES)


'Verify deletion
'Locate and open site
		if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
			LOG_VP(FAIL_PREFIX + "Could not find site [" + sSiteName + "] to verify deletion.")
			bDeleteLicensingSettings = FALSE
			goto eXIT_fUNCTION

		end if

'Check for existing Licensing Setting object
		if b_wViewItemClk_Ex(DEFAULT_ORDINAL, SITE_SETTINGS) = TRUE then

			LOG_VP(FAIL_PREFIX + "Site [" + sSiteName + _
					"] still contains the deleted object..")
			bDeleteLicensingSettings = FALSE
			goto eXIT_fUNCTION

		end if

	else 'Site name not found in tree. Should not be possible as we assured this previously.
	end if


	bDeleteLicensingSettings = TRUE

eXIT_fUNCTION:
	ExitSub("bDeleteLicensingSettings")

end function 'bDeleteLicensingSettings



'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateSubnet
'
'	Creates a subnet with the given mask and pointed to the site.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSiteName - Name of site to which this subnet must be pointed
'		sAddress - IP address of the subnet including mask bits, (eg: 127.122.235.78/32)
'
'	RETURN VALUE
'		TRUE if sitelink created
'		FALSE if sitelink not created, (sites did not exist will cause this failure)
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bCreateSubnet(sSiteName as String, _
						sFullAddress as String) as long

	EnterSub("bCreateSubnet [" + sFullAddress + "] mapped to site [" + sSiteName + "]")

'Verify address parameter is of the proper form
	Dim sIPAddress as String
	Dim iMask as Integer
	Dim sTempMask as String
	Dim lHolder as Long
	Dim sTempArray as Array of String
	Dim x as long 'generic looping variable


'Should have a forward slash separating the two parts of the address.
'Thus exactly two strings should be parsed.

	LOG_VP("Splitting IP\Mask for '" + sFullAddress + "'")


	lHolder = vtSplit(sFullAddress, "/", sTempArray)
	if lHolder = 1 then 'Note 1 is second spot of array starting at zero

		iMask = Val(sTempArray(1))
		sIPAddress = sTempArray(0)

'Verify that there are four sub streings in the address
			LOG_VP("Splitting IP Address for '" + sIPAddress + "'")

			lHolder = vtSplit(sIPAddress, ".", sTempArray)
			if lHolder = 3 then

'Each entry should be 3 chars long.  If not, prepend zeros until it is.
					for x = 0 to 3
						Do while len(sTempArray(x)) < 3
							sTempArray(x) = "0" + sTempArray(x)
						loop
					next x

'Create proper mask, (in binary string)
					for x = 1 to 32
						
						if x <= iMask then

							sTempMask = sTempMask + "1"

						else
							
							sTempMask = sTempMask + "0"

						end if

					next x


'This appears to be properly formatted.  Continue.
				goto gOOD_pARAMETERS_cONTINUE
			
			end if

	end if

'If here then some part of the passed information is bad.  Bail.
	LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Bad subnet mask information passed to function:")
	goto eXIT_fUNCTION

'Otherwise, create the subnet
gOOD_pARAMETERS_cONTINUE:


'Access the transports container
	if bOpenSubnetsContainer() = TRUE then

		Sleep(MIN_WAIT)
'Select new subnet from context menu
		If b_wTreeItemClk_Ex(DEFAULT_ORDINAL, "~" + SUBNETS_NODE, VK_RBUTTON) = TRUE then
			If b_wMenuSelect_Ex(MNU_CREATE_NEW_SUBNET) = TRUE then
		
'Small breather
				Sleep MIN_WAIT

'Enter each of the pieces of the IP address in turn
				for x = 0 to 3
					
					b_Play_Ex(sTempArray(x))

				next x

'Move on to mask field
				b_Play_Ex("{TAB}")
				Sleep(MIN_WAIT)


'The mask must be converted to an appropriate mask.  For each eight bits in the mask
'create a dec number and input.

				sTempArray(0) = trim(str(vBinToDec(mid(sTempMask, 1, 8))))
				sTempArray(1) = trim(str(vBinToDec(mid(sTempMask, 9, 8))))
				sTempArray(2) = trim(str(vBinToDec(mid(sTempMask, 17, 8))))
				sTempArray(3) = trim(str(vBinToDec(mid(sTempMask, 25, 8))))

'Each entry should be 3 chars long.  If not, prepend zeros until it is.
					for x = 0 to 3
						Do while len(sTempArray(x)) < 3
							sTempArray(x) = "0" + sTempArray(x)
						loop
					next x

					Sleep(MIN_WAIT)

'Enter each of the pieces of the mask in turn
				for x = 0 to 3
					
					b_Play_Ex(sTempArray(x))

				next x

				Sleep(MIN_WAIT)


'The IP address and mask are now entered.  Select site to map to.
				if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sSiteName) = FALSE then

					LogIt(LVL_STATUSINFO, "Could not find site [" + sSiteName + "] to map to.")

					bCreateSubnet = FALSE
					goto eXIT_fUNCTION

				end if


'Click OK.  If msgbox appears then error occured, (most likely this subnet is already mapped.)
				if b_wButtonClick_Ex(BTN_OK) = TRUE then
					
					sleep MIN_WAIT

					if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

						LogIt(LVL_STATUSINFO, "Could not create subnet.  Most likely one such mapping " + _
								"already exists.")

						b_wButtonClick_Ex(BTN_OK)

						bCreateSubnet = FALSE
						goto eXIT_fUNCTION

					end if

'If here then subnet should have been created.  Verify existence in scope pane.
				if bOpenSubnetsContainer() = TRUE then

'Refresh the context pane just in case
					bRefreshContextPane

					Sleep(MIN_WAIT)

'Find the subnet
					if b_wViewItemClk_Ex(DEFAULT_ORDINAL, sFullAddress) = FALSE then

						LogIt(LVL_STATUSINFO, "Subnet not in Context pane but should be.")
						bCreateSubnet = FALSE
						goto eXIT_fUNCTION

					end if
				
'All good.  Return true.
					bCreateSubnet = TRUE
					goto eXIT_fUNCTION

				else
				end if 'Could not find subnets container.  Doc'd by called function.

				else 'OK button not found?  Doc'd by called function.
				end if
			
			else 'Subnets container not in tree?  Doc'd by called function.
			end if  

		else 'New Subnet not available? Doc'd by called function.
		end if 

	else 'Could not open subnets container.  Doc'd by called function.
	end if 
		

eXIT_fUNCTION:

'Make sure the subnet creation dialogs are abandoned if open (error occured)
	if bCloseDialogs(GetText(WFndWnd("~" + CAP_CONSOLE1))) = FALSE then
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not close all dialogs within the MMC.")
	end if	

	ExitSub("bCreateSubnet [" + sFullAddress + "] mapped to site [" + sSiteName + "]")

end function 'bCreateSubnet

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteSubnet
'
'	Deletes a subnet with the specified mask.  Returns no error if subnet not found; the goal is for the
'	subnet to not exist, not to perform the deletion.  If subnet exists, but fails to delete, then failure is
'	returned.
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sSubnetMask - name of site to delete.
'
'	RETURN VALUE
'		TRUE if subnet no longer exists
'		FALSE if subnet still exists.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteSubnet(sSubnetMask as string) as long

	EnterSub("bDeleteSubnet [" + sSubnetMask + "]")

	Dim bResult as long
	Dim lTBOrd as long

	bResult = TRUE

'Make sure the sites container is open
	if bOpenSubnetsContainer then
	Sleep(MIN_WAIT)

	b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sSubnetMask)

	b_wTreeItemClk_Ex(DEFAULT_ORDINAL, DEFAULT_ORDINAL)

		

	Sleep(MIN_WAIT)

'Select the site, bringing up pop up menu.  Choose delete and agree to all of the dialog windows.
		if b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sSubnetMask, VK_RBUTTON) then
		Sleep(MIN_WAIT)
			if b_wMenuSelect_Ex(MNU_DELETE) then

			Sleep(MIN_WAIT)

				if not (b_wButtonClick_Ex(BTN_YES)) then

					saveScreenShot("SitesSubNetFail1.bmp")
					
					LogIt(LVL_STATUSINFO, "Will re-try operation. Can not locate button : " + BTN_YES)

					
					Sleep(MIN_WAIT)

					b_wButtonClick_Ex(BTN_YES)

					saveScreenShot("SitesSubNetFail2.bmp")

				endif

				
				'Verify the site no longer exists
				bResult = wTreeItemExists(DEFAULT_ORDINAL, sSubnetMask)

										
			end if
		end if
	end if			

	if bResult = FALSE then

		LogIt(LVL_STATUSINFO, "Subnet [" + sSubnetMask + "] deleted succesfully.")
		bDeleteSubnet = TRUE

	else

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Subnet [" + sSubnetMask + "] not deleted.")
		bDeleteSubnet = FALSE

	end if
		

	ExitSub("bDeleteSubnet [" + sSubnetMask + "]")

end function 'bDeleteSubnet

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCheckSecurity
'
'	Verifies that the proper dialogs are brought up when buttons
'	on the dialog are pressed and that the check boxes
'	in the security area can be altered
'
'	ASSUMES
'		The object to be opened is a currently selectable item in the
'		content pane, and that the properties dialog contains the
'		a typical Security tab.
'
'	PARAMETERS:
'		sViewList - identifier of the context pane
'		sViewItem - identifier of object to open the properties of
'
'	RETURN VALUE:
'		TRUE if the Security tab works as expected
'		FALSE if otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCheckSecurity(	sViewList as String, _
							sViewItem as String) as Long

	EnterSub("bCheckSecurity [" + sViewItem +"]")

	Dim bTempResult as integer

'Assume failure of some scenario
	bTempResult = FALSE


'open properties page
	If bOpenProperties(sViewList, sViewItem) = FALSE then
		LogIt(LVL_STATUSINFO, "Could not open properties page.")


'Verify tab control exists and go to it
	elseif bVerify_TabItem(DEFAULT_ORDINAL, SP_SECURITY_TAB, SP_SECURITY_TAB, TRUE) = FALSE then
		LogIt(LVL_STATUSINFO, "Could not locate security tab.")


'If a msgbox does not appear, then this user has admin crednetials
	elseif GetText(wGetActWnd())<>(CAP_SECURITY) then

		
		sleep (MIN_WAIT + MIN_WAIT)

'Verify that clicking the [Add...] button brings up the Select Users... dialog
		if b_wButtonClick_Ex(PROP_SECURITY_BTN_ADD) = TRUE then
			
			Sleep (MIN_WAIT + MIN_WAIT)
			if GetText(wGetActWnd()) = DLG_CAP_SELECTUSERS then

'Escape the select dialog
				if b_wButtonClick_Ex(BTN_CANCEL) = TRUE then
					

'Click on advanced security settings and verify
'that the dialog comes up
					Sleep MIN_WAIT
					if b_wButtonClick_Ex(PROP_SECURITY_BTN_ADVANCED) = TRUE then

						CaptionSleep(DLG_CAP_ADVANCEDSECURITY)
						if instr(GetText(wGetActWnd()), DLG_CAP_ADVANCEDSECURITY) <> FALSE then

							sleep MIN_WAIT
'Escape the advanced security dialog
							if b_wButtonClick_Ex(BTN_CANCEL) = TRUE then

'If here, then all passes up to this point:
								bTempResult = TRUE
							
							end if	
						end if
					end if
				end if
			end if
		end if

		sleep MIN_WAIT
'Return to snap-in proper
		b_wButtonClick_Ex(BTN_CANCEL)

'If a msgbox appears then this user is not an admin
	else

'Clear dialog
		if b_wButtonClick_Ex(BTN_OK) = TRUE then
		
'The only button that should be available is the Advanced permissions
			Sleep (MIN_WAIT + MIN_WAIT)
			if b_wButtonClick_Ex(PROP_SECURITY_BTN_ADVANCED) = FALSE then

				CaptionSleep(DLG_CAP_ADVANCEDSECURITY)
				if instr(GetText(wGetActWnd()), DLG_CAP_ADVANCEDSECURITY) <> FALSE then

					Sleep MIN_WAIT
'Escape the advanced security dialog
					if b_wButtonClick_Ex(BTN_CANCEL) = TRUE then

'If here, then all passes up to this point:
						bTempResult = TRUE
								
					end if
				end if
			end if
		end if

		Sleep MIN_WAIT
'Return to snap-in proper
		b_wButtonClick_Ex(BTN_CANCEL)

	end if

'Return final value
	bCheckSecurity = bTempResult

eXIT_fUNCTION:
	ExitSub("bCheckSecurity")
	
End Function 'bCheckSecurity

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bDeleteObject
'
'	Deletes an object with the specified name.  Returns no error if object not found; the goal is for the object
'	to not exist, not to perform the deletion.  If object exists, but fails to delete, then failure is
'	returned.
'
'	ASSUMES
'		An instance of MMC is open.  Object to be deleted is enumerated in the content pane.
'
'	PARAMETERS
'		sViewList - the ordinal or other identifier of the content pane
'		sObjectName - name of site to delete.
'
'	RETURN VALUE
'		TRUE if object no longer exists
'		FALSE if object still exists.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
function bDeleteObject(	sViewList as String, _
						sObjectName as string) as long

	EnterSub("bDeleteObject [" + sObjectName + "]")

	Dim bResult as long
	Dim sTempCap as String

'Assume that this will fail, (TRUE is a failure in the delete scenario)
	bResult = TRUE

'Select the object, bringing up pop up menu.  Choose delete and agree to all of the dialog windows.
	if b_wViewItemClk_Ex(sViewList, sObjectName, VK_RBUTTON) = TRUE then

		sTempCap = GetText(wGetActWnd)
		if b_wMenuSelect_Ex(MNU_DELETE) = TRUE then


			CaptionSleep(sTempCap, TRUE)
			sTempCap = GetText(wGetActWnd)

			if b_wButtonClick_Ex(BTN_YES) = TRUE then


				CaptionSleep(sTempCap, TRUE)
				sTempCap = GetText(wGetActWnd)


'If this is a container object, there will be a secondary dialog
'referring to the time necessary to delete the object
'and its children.
				if wButtonExists(BTN_YES, MAX_WAIT) = TRUE then


					b_wButtonClick_Ex(BTN_YES)
					CaptionSleep(sTempCap, TRUE)



'Should have returned to the MMC ---
'Verify the object no longer exists
					bResult = b_wViewItemClk_Ex(DEFAULT_ORDINAL, sObjectName)



'If this failed, (NTDS settings object exists for example), then an
'error appears.  Click OK and return failure
				endif

				if wButtonExists(BTN_OK, MAX_WAIT) = TRUE then
					
					b_wButtonClick_Ex(BTN_OK)
					bResult = TRUE

'Else no dialog appeared and deletion occured as expected
'Should have returned to the MMC ---

					CaptionSleep(CAP_MMC)


'Verify the object no longer exists
				endif 

					bResult = b_wViewItemClk_Ex(DEFAULT_ORDINAL, sObjectName)


			end if
		end if
	end if			

	if bResult = FALSE then

		LogIt(LVL_STATUSINFO, "Object [" + sObjectName + "] deleted succesfully.")
		bDeleteObject = TRUE

	else

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Object [" + sObjectName + "] not deleted.")
		bDeleteObject = FALSE

	end if
		

	Sleep MIN_WAIT

	ExitSub("bDeleteObject")

end function 'bDeleteObject

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bRetargetForest
'
'	Sets the forest to the specified target using the AD sites and Services node
'
'	ASSUMES
'		The AD Sites node is present in the current MMC, either via adding the snap-in
'		or running dssite.msc - if the AD Sites node is not found, this will fail
'
'	PARAMETERS
'		sForestDNS - Complete DNS of the forest to retarget to
'
'	RETURN VALUE
'		TRUE if retarget was successful
'		FALSE if retarget fails
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bRetargetForest(sForestDNS as String) as Long

	EnterSub("bRetargetForest - New Domain[" + sForestDNS +"]")


'Assume failure will occur somewhere
	bRetargetForest = FALSE

'
	b_wViewItemClk_Ex(ORD_1,ORD_1)
	

'Right click on the AD Sites root node to bring up the context menu
	if b_wTreeItemClk_Ex(ORD_1, DSSITE_NODE_NAME, VK_RBUTTON) = FALSE then

		LogIt(LVL_VERBOSE, "Could not find Sites Snap-in Root Node.")
		goto eXIT_fUNCTION

	end if

	Sleep MIN_WAIT



'Select 'Connect to Forest...' from the context menu
	if b_wMenuSelect_Ex(MNU_CHANGE_FOREST) = FALSE then

		LogIt(LVL_VERBOSE, "Retarget to different forest item not found on menu.")
		goto eXIT_fUNCTION

	end if

	Sleep MIN_WAIT



'The Connect to Forest dialog should come up
	CaptionSleep(DLG_CAP_CONNECTTOFOREST)

'Enter the new domain in the edit box, then click 'OK'
	b_Play_Ex(sForestDNS)


	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		LogIt(LVL_VERBOSE, "Unexpected error involving OK button??!?!?")
		goto eXIT_fUNCTION

	end if



'Should have returned to the MMC.
	CaptionSleep(CAP_MMC)



'If there is an 'Active Directory' dialog then some error occured
	if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

		LogIt(LVL_VERBOSE, "Could not retarget to specified forest.")
		goto eXIT_fUNCTION

	end if



'If here, then the new forest was found and targeted.
	bRetargetForest = TRUE
	Sleep MIN_WAIT	


eXIT_fUNCTION:
	ExitSub("bRetargetForest")

End Function 'bRetargetForest

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bRetargetDC
'
'	Sets the DC to the specified target using the AD sites and Services node
'
'	ASSUMES
'		The AD Sites node is present in the current MMC, either via adding the snap-in
'		or running dssite.msc - if the AD Sites node is not found, this will fail
'
'	PARAMETERS
'		sDCName - Full DNS name of the DC to retarget to (ex: foo.bar.nttest.microsoft.com)
'
'	RETURN VALUE
'		TRUE if retarget was successful
'		FALSE if retarget fails
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bRetargetDC(sDCName as String) as Long

	EnterSub("bRetargetDC - DC[" + sDCName +"]")


	Dim sTempCap as String


	'----- Assume failure will occur somewhere -----
	bRetargetDC = FALSE

	

	'----- Right click on the AD Sites root node to bring up the context menu -----
	if b_wTreeItemClk_Ex(ORD_1, DSSITE_NODE_NAME, VK_RBUTTON) = FALSE then

		LogIt(LVL_VERBOSE, "Could not find Sites Snap-in Root Node.")
		goto eXIT_fUNCTION

	end if

	Sleep MIN_WAIT



	'----- Select 'Connect to DC...' from the context menu -----
	if b_wMenuSelect_Ex(MNU_CHANGE_DC) = FALSE then

		LogIt(LVL_VERBOSE, "Retarget to different DC item not found on menu.")
		goto eXIT_fUNCTION

	end if

	Sleep MIN_WAIT


	'----- The Connect to DC dialog should come up -----
	CaptionSleep(DLG_CAP_CONNECTTODC)

	sTempCap = GetText(wGetActWnd())


	'----- if the domain is specified, then look that up first through recursive call -----
	if instr(sDCName, ".") <> FALSE then

		b_Play_Ex(mid(sDCName, instr(sDCName, ".") + 1, len(sDCName)))
		Sleep MIN_WAIT

		b_Play_Ex("{ENTER}")
		Sleep MIN_WAIT

		if bRetargetDC(Left(sDCName, instr(sDCName, ".") - 1)) = FALSE then

			LogIt(LVL_VERBOSE, "Recursive function failed.")
			goto eXIT_fUNCTION	

		end if

	else


		'----- Select the Dc from the list, then click 'OK' -----
		if b_wViewItemClk_Ex(DEFAULT_ORDINAL, "+" + sDCName, VK_LBUTTON) = FALSE then

			LogIt(LVL_VERBOSE, "Could not slect specified DC from list.")
			goto eXIT_fUNCTION

		elseif b_wButtonClick_Ex(BTN_OK) = FALSE then

			LogIt(LVL_VERBOSE, "Unexpected error involving OK button??!?!?")
			goto eXIT_fUNCTION

		end if





		'----- If an 'Active Directory' dialog appears then some error occured -----
		CaptionSleep(sTempCap, TRUE)
		if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

			LogIt(LVL_VERBOSE, "Could not retarget to specified DC.")
			goto eXIT_fUNCTION

		end if

	end if


'If here, then the new DC was found and targeted.
	bRetargetDC = TRUE
	Sleep MIN_WAIT	


eXIT_fUNCTION:
	ExitSub("bRetargetDC")

End Function 'bRetargetDC


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateServersContainer
'
'	Creates a new Servers container Object for the specified site.
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site to add the servers container to
'
'	RETURN VALUE:
'		TRUE if container created
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCreateServersContainer(sSiteName as String) as Long

	EnterSub("bCreateServersContainer - Site[" + sSiteName + "]")


'Assume failure will occur
	bCreateServersContainer = FALSE


'Locate and open site
	if bOpenSpecificSiteContainer(sSiteName) = FALSE then
		
		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not find site [" + sSiteName + "].")

	end if

	Sleep(MIN_WAIT)

'Open context menu and selec New/Servers Container
	wTreeItemClk(DEFAULT_ORDINAL, sSiteName, VK_RBUTTON)


	Sleep(MIN_WAIT)


	if b_wMenuSelect_Ex(MNU_CREATE_NEW) =FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select New/Servers Container from menu")

	elseif b_wMenuSelect_Ex(MNU_SITE_SERVERS) = FALSE then

		LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not select New/Servers Container from menu")



'A message box will appear.  If it is an 'Active Directory' messagebox then an error occured
	else
	
		if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

			b_wButtonClick_Ex(BTN_OK)
			LogIt(LVL_STATUSINFO, "Could not create new Servers container.  Likely one already exists.")

		else

		
			
'A message box appeared, but it was 'new object created'....	
			b_wButtonClick_Ex(BTN_OK)



'Make sure new object appeared in proper place.
'Locate and open site
			if bOpenSpecificSiteContainer(sSiteName) = FALSE then

				LogIt(LVL_STATUSINFO, FAIL_PREFIX + "Could not find site to verify creation of container.")

			end if

			wTreeItemClk(ORD_1,sSiteName)


'Make sure a Servers container exists
			wViewItemClk(DEFAULT_ORDINAL, SERVERS_NODE)

			Sleep(MIN_WAIT)

'If here, then servers object created as expected.
			bCreateServersContainer = TRUE


		end if
	end if


	ExitSub("bCreateServersContainer")

end function 'bCreateServersContainer

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bChangeSiteLinkSettings
'
'	Changes the Cost and time between replication for a SiteLink.  If no value, (zero), is sent for either cost
'	or minutes, it is left unchanged.  (Intention is to send FALSE if no change is desired)
'
'	ASSUMES
'		An instance of MMC is open,  active, and has no child dialogs open
'
'	PARAMETERS
'		sTransport - IP or SMTP, (defaults to IP)
'		sSiteLink - name of SiteLink to work with
'		iCost - (defaults to FALSE=>'no change') value to set cost to
'		iMinutes - (defaults to FALSE=>'no change')value to set for replication time
'
'
'	RETURN VALUE
'		TRUE if changes can be made
'		FALSE if changes can not be made
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bChangeSiteLinkSettings(	sTransport=IP_NODE as String, _
									sSiteLink as String, _
									iCost=FALSE as Long, _
									iMinutes=FALSE as Integer,) as Long

	EnterSub("bChangeSiteLinkSettings [" + sSiteLink + "]:Cost[" + str$(iCost) + _
			"]:Minutes[" + str$(iMinutes) + "]")



'Assume failure will occure somewhere
	bChangeSiteLinkSettings = FALSE


'Open the specified transports container
	if bOpenTransportsContainer() = FALSE then



'Select the specific transport node
	elseif b_wTreeItemClk_Ex(DEFAULT_ORDINAL, sTransport) = FALSE then



'Open the properties of the SiteLink
	elseif bOpenProperties(ORD_1, sSiteLink) = FALSE then



'Select the General tab
	elseif bVerify_TabItem(DEFAULT_ORDINAL, DEFAULT_ORDINAL, SP_GENERAL_TAB, TRUE) = FALSE then



	else

'All good, send positive result
		bChangeSiteLinkSettings = TRUE

'Input new values if requested
		if iCost > 0 then

			wEditSetText(ORD_2, trim(str$(iCost)), MAX_WAIT)

		end if

		if iMinutes > 0 then

			wEditSetText(ORD_3, trim(str$(iMinutes)), MAX_WAIT)

		end if

		
	end if	
	
	
'Close the properties dialog
	if b_wButtonClick_Ex(BTN_OK) = FALSE then
		
		LogIt(LVL_VERBOSE, "Unexpected error involving OK button???!?!?")
		
	end if
	
	
'Should return to the MMC
	 bChangeSiteLinkSettings = CaptionSleep(CAP_MMC)		

	ExitSub("bChangeSiteLinkSettings")

end function 'bChangeSiteLinkSettings


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bCreateConnection
'
'	Creates a connection object between the specified servers
'
'	ASSUMES
'		MMC open active, with no child dialogs open
'
'	PARAMETERS:
'		sSiteName - the site that contains the first server
'		sBaseServer - server to create the connection under
'		sFromServer - the other server involved in the connection
'		sConnectionName - the name to give to the new connection
'
'	RETURN VALUE:
'		TRUE if server created
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bCreateConnection(	sSiteName as String, _
							sBaseServer as String, _
							sFromServer as String, _
							sConnectionName as String) as Long

	EnterSub("bCreateConnection - From[" + sBaseServer + "]:To[" + sFromServer + "]")


	Dim x as Long


'Assume failure
	bCreateConnection = FALSE



'Open the NTDS Settings object in which to create the connection
	if bSelectSpecificServerNTDSSettings(sSiteName, sBaseServer) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not open NTDS Settings object.")
		


'Open context menu and select a New Active directory connection
	elseif b_wTreeItemClk_Ex(ORD_1, NTDSSETTINGS_NODE, VK_RBUTTON) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not open NTDS Settings context menu.")



	elseif b_wMenuSelect_Ex(MNU_NEW_AD_CONNECTION) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not select a new connection from the context menu.")



	else

	

'The Find DC dialog should appear
		CaptionSleep(CAP_FIND_DC)

'it can take a long time for the search fied to enumerate. try for a while
		For x = 1 to 15

			Sleep MIN_WAIT
			if wViewItemExists(ORD_1, ORD_1) = TRUE then
				
				Exit For

			end if

		Next x
		

'Select the specified from server, and press OK
		if sFromServer = "" then
			sFromServer = ORD_1 ' Select any server position
			
			if ViewItemText(ORD_1,ORD_1) = sBaseServer then
			   if WViewItemExists(ORD_1,ORD_2) then
					
					 sFromServer = ORD_2
			   else
					
					LogIt(LVL_STATUSINFO,FAIL_PREFIX + "No other server to create connection object")
					goto EXIT_FUNCTION_CREATECONNECTION
				endif

	
			  end if 

		endif

		

		if b_wViewItemClk_Ex(ORD_1, sFromServer) = FALSE then
				
			LogIt(LVL_STATUSINFO, "Could not find/select From Server in Find DC dialog.")

		elseif b_wButtonClick_Ex(BTN_OK) = FALSE then

			LogIt(LVL_STATUSINFO, "Unexpected error involving OK Button??!?!")

		else


'If a dialog appeared asking for confirmation, then these two are already connected
'Select 'Yes' and move on to make a second connection
			b_wButtonClick_ex(BTN_YES)



'The naming dialog for the connection should appear
			CaptionSleep(CAP_CREATE_NEW + " - " + RES_TYPE_CONNECTION)
			if GetText(wGetActWnd()) <> (CAP_CREATE_NEW + " - " + RES_TYPE_CONNECTION) then

				LogIt(LVL_STATUSINFO, "Connection naming dialog did not appear.")


'Type specified name, press OK
			elseif b_Play_Ex(sConnectionName) = FALSE then
				
				LogIt(LVL_STATUSINFO, "Unexpected problem involving typing name. (Possible tab order error)")

			elseif b_wButtonClick_Ex(BTN_OK) = FALSE then

				LogIt(LVL_STATUSINFO, "Unexpected error involving OK Button??!?!")

			else

'Check to see if an error occured, if so, exit dialogs....
				Sleep MIN_WAIT
				if GetText(wGetActWnd()) = CAP_ACTIVE_DIRECTORY then

					LogIt(LVL_STATUSINFO, "Error box appeared.  Likely naming conflict.")
					
					
					Sleep MIN_WAIT
					b_wButtonClick_Ex(BTN_OK)
					Sleep MIN_WAIT
					b_wButtonClick_Ex(BTN_CANCEL)

					
					CaptionSleep(CAP_MMC)
					
					goto eXIT_fUNCTION

				end if


'Should return to MMC and connection should be listed in content pane
				CaptionSleep(CAP_MMC)
				if GetText(wGetActWnd()) <> CAP_MMC then

					LogIt(LVL_STATUSINFO, "Did not return to MMC.  Likely error occured in creating Connection.")


				elseif b_wViewItemClk_Ex(ORD_1, sConnectionName) = FALSE then

					LogIt(LVL_STATUSINFO, "New connection did not populate content pane.")

				else

					bCreateConnection = TRUE

				end if
			end if
		end if
	end if

EXIT_FUNCTION_CREATECONNECTION:
eXIT_fUNCTION:
	ExitSub("bCreateConnection")

end function 'bCreateConnection


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bInitializeWeeklyMatrix
'
'	Removes any information in the weekly matrix structure and sizes
'	the arrays to twenty-four hours each, (0-23)
'
'	PARAMETERS:
'		wkmxToSetup - WEEKLYMATRIX structure to initialize
'
'	RETURN VALUE:
'		TRUE if setup completed successfully
'		FALSE if not
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bInitializeWeeklyMatrix(wkmxToSetup as WEEKLYMATRIX) as Long


	On Local Error Goto SETUP_ERROR

	Redim (wkmxToSetup.SUN)(23)
	Redim (wkmxToSetup.MON)(23)
	Redim (wkmxToSetup.TUE)(23)
	Redim (wkmxToSetup.WED)(23)
	Redim (wkmxToSetup.THU)(23)
	Redim (wkmxToSetup.FRI)(23)
	Redim (wkmxToSetup.SAT)(23)

	bInitializeWeeklyMatrix = TRUE
	Exit Function


SETUP_ERROR:
	bInitializeWeeklyMatrix = FALSE
	Err = 0
	Exit Function
	

End Function 'bInitializeWeeklyMatrix


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bGetWeeklyMatrixState
'
'	Fills in the passed weekly matrix structure with the values of the
'	currently active weekly matrix control
'
'	ASSUMES
'		The current dialog has only one weekly matrix control on it.
'		The value of the current cell can be read by looking at the
'		radio buttons on the dialog.
'
'	PARAMETERS:
'		wkmxToSetup - WEEKLYMATRIX structure to fillout
'
'	RETURN VALUE:
'		TRUE if research completed successfully
'		FALSE if not
'
'	NOTE:  The values filled in will be from 1 to x, where x is the
'	number of radio buttons.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bGetWeeklyMatrixState(wkmxCurrent as WEEKLYMATRIX) as Long

	EnterSub("bGetWeeklyMatrixState")

	Dim lCurrentDay as Long
	Dim lCurrentHour as Long
	Dim lNumOfOptionButtons as Long
	Dim lValue as Long 
	Dim i as Long


	'----- assume failure -----
	bGetWeeklyMatrixState = FALSE



	'----- verify that the weekly matrix structure is sized for input -----
	if bInitializeWeeklyMatrix(wkmxCurrent) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not intialize WEEKLYMATRIX structure")
		goto eXIT_fUNCTION

	end if


	'----- sometimes the caption bar control menu gets the focus, (no, I
	'don't know why.  I blame VT for being freaky at times...), this will
	'click in the center of the dialog and prevent the issue from causing havoc -----
	wClkWnd(0)

		

	'----- Set the input focus on the weekly matrix control -----
	wCustomSetClass(WEEKLYMATRIX_CLASSNAME)

	if wCustomExists(_ord(1)) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not find a Weekly Matrix control, (Class Name = [" + WEEKLYMATRIX_CLASSNAME + "])")
		goto eXIT_fUNCTION

	end if

	wCustomSetFocus(_ord(1))



	'----- figure out how many possible values there are by counting
	'the number of option buttons -----
	Do

		lNumofOptionButtons  = lNumofOptionButtons + 1

	Loop while wOptionExists(_ord(lNumofOptionButtons + 1)) = TRUE



	'----- Move to the upper-left corner cell, (Sunday, midnight - 1AM)
	if b_Play_Ex("{HOME}", FALSE) = FALSE then goto eXIT_fUNCTION


	
	'----- Cycle through each day -----
	For lCurrentDay = 1 to 7


		'----- reset the selection back to the first cell -----
		if b_Play_Ex("{HOME}", FALSE) = FALSE then goto eXIT_fUNCTION



		'----- move to the specified day of the week -----
		For i = 1 to lCurrentDay - 1

			if b_Play_Ex("{DOWN}", FALSE) = FALSE then goto eXIT_fUNCTION

		Next i



		'----- Cycle through each hour -----
		For lCurrentHour = 0 to 23


			'----- Check the current value by looking at the radio buttons
			'on the dialog -----
			For lValue = 1 to lNumofOptionButtons

				if wOptionState(_ord(lValue)) <> FALSE then

					Exit For

				End If

			Next lValue


			
			'----- Jump to whatever day we're looking at
			'and input the value there -----
			Select Case lCurrentDay

				Case is = 1
					wkmxCurrent.SUN(lCurrentHour) = lValue

				Case is = 2
					wkmxCurrent.MON(lCurrentHour) = lValue

				Case is = 3
					wkmxCurrent.TUE(lCurrentHour) = lValue

				Case is = 4
					wkmxCurrent.WED(lCurrentHour) = lValue

				Case is = 5
					wkmxCurrent.THU(lCurrentHour) = lValue

				Case is = 6
					wkmxCurrent.FRI(lCurrentHour) = lValue

				Case is = 7
					wkmxCurrent.SAT(lCurrentHour) = lValue

				Case Else

					LogIt(LVL_STATUSINFO, "?!?!?Unexpected Error in Select Statement re: 7 days of the week?!?!?")
					goto eXIT_fUNCTION
					

			End Select


			'----- move to the right one cell ----
			if b_Play_Ex("{RIGHT}", FALSE) = FALSE then goto eXIT_fUNCTION
			Sleep .05

		Next lCurrentHour

	
	Next lCurrentDay



	'----- if here then all went well and we should have a complete
	'weekly matrix structure filled out -----
	bGetWeeklyMatrixState = TRUE

	
eXIT_fUNCTION:

	ExitSub("bGetWeeklyMatrixState")

End Function 'bGetWeeklyMatrixState


'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	bSetWeeklyMatrixState
'
'	Fills in the weekly matrix control with the values of the
'	passed weekly matrix structure
'
'	ASSUMES
'		The current dialog has only one weekly matrix control on it.
'		The value of the current cell can be set by the
'		radio buttons on the dialog.
'
'	PARAMETERS:
'		wkmxToSetup - WEEKLYMATRIX structure to fillout
'
'	RETURN VALUE:
'		TRUE if fill completed successfully
'		FALSE if not
'
'	NOTE:  The values filled in will be from 1 to x, where x is the
'	number of radio buttons.
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function bSetWeeklyMatrixState(wkmxCurrent as WEEKLYMATRIX) as Long

	EnterSub("bSetWeeklyMatrixState")

	Dim lCurrentDay as Long
	Dim lCurrentHour as Long
	Dim lNumOfOptionButtons as Long
	Dim lValue as Long 
	Dim i as Long


	'----- assume failure -----
	bSetWeeklyMatrixState = FALSE



	'----- sometimes the caption bar control menu gets the focus, (no, I
	'don't know why.  I blame VT for being freaky at times...), this will
	'click in the center of the dialog and prevent the issue from causing havoc -----
	wClkWnd(0)

		

	'----- Set the input focus on the weekly matrix control -----
	wCustomSetClass(WEEKLYMATRIX_CLASSNAME)

	if wCustomExists(_ord(1)) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not find a Weekly Matrix control, (Class Name = [" + WEEKLYMATRIX_CLASSNAME + "])")
		goto eXIT_fUNCTION

	end if

	wCustomSetFocus(_ord(1))



	'----- figure out how many possible values there are by counting
	'the number of option buttons -----
	Do

		lNumofOptionButtons  = lNumofOptionButtons + 1

	Loop while wOptionExists(_ord(lNumofOptionButtons + 1)) = TRUE



	'----- Move to the upper-left corner cell, (Sunday, midnight - 1AM)
	if b_Play_Ex("{HOME}", FALSE) = FALSE then goto eXIT_fUNCTION


	
	'----- Cycle through each day -----
	For lCurrentDay = 1 to 7


		'----- reset the selection back to the first cell -----
		if b_Play_Ex("{HOME}", FALSE) = FALSE then goto eXIT_fUNCTION



		'----- move to the specified day of the week -----
		For i = 1 to lCurrentDay - 1

			if b_Play_Ex("{DOWN}", FALSE) = FALSE then goto eXIT_fUNCTION

		Next i



		'----- Cycle through each hour -----
		For lCurrentHour = 0 to 23

			'----- Jump to whatever day we're looking at
			'and input the value there -----
			Select Case lCurrentDay

				Case is = 1
					lValue = wkmxCurrent.SUN(lCurrentHour)

				Case is = 2
					lValue = wkmxCurrent.MON(lCurrentHour)

				Case is = 3
					lValue = wkmxCurrent.TUE(lCurrentHour)

				Case is = 4
					lValue = wkmxCurrent.WED(lCurrentHour)

				Case is = 5
					lValue = wkmxCurrent.THU(lCurrentHour)

				Case is = 6
					lValue = wkmxCurrent.FRI(lCurrentHour)

				Case is = 7
					lValue = wkmxCurrent.SAT(lCurrentHour)

				Case Else

					LogIt(LVL_STATUSINFO, "?!?!?Unexpected Error in Select Statement re: 7 days of the week?!?!?")
					goto eXIT_fUNCTION
					

			End Select


			'----- make sure you're only setting a possible option value -----
			if lValue > lNumOfOptionButtons then

				lValue = lNumOfOptionButtons

			End If



			'----- seleect specified option ----
			if wOptionExists(_ord(lValue)) = TRUE then

				wOptionSelect(_ord(lValue))

			Else

					LogIt(LVL_STATUSINFO, "?!?!?Unexpected Error: Option button did not exist?!?!?")
					goto eXIT_fUNCTION

			End If



			'----- set focus back on the weekly matrix control -----
			wCustomSetFocus(_ord(1))


			'----- move to the right one cell ----
			if b_Play_Ex("{RIGHT}", FALSE) = FALSE then goto eXIT_fUNCTION
			Sleep .05

		Next lCurrentHour

	
	Next lCurrentDay



	'----- if here then all went well and we should have a complete
	'weekly matrix structure filled out -----
	bSetWeeklyMatrixState = TRUE

	
eXIT_fUNCTION:

	ExitSub("bSetWeeklyMatrixState")

End Function 'bSetWeeklyMatrixState



'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	sOutputWeeklyMatrix
'
'	ASSUMES
'		The passed weekly matrix structur has been initialized correctly
'
'	PARAMETERS:
'		wkmxCurrent - WEEKLYMATRIX structure to read from
'
'	RETURN VALUE:
'		String in "grid" format showing all the values held in the structure
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function sOutputWeeklyMatrix(wkmxCurrent as WEEKLYMATRIX) as String

	EnterSub("sOutputWeeklyMatrix")

	Dim lCurrentDay as Long
	Dim lCurrentHour as Long
	Dim sOutput as String


	sOutput = ""

	
	'----- Cycle through each day -----
	For lCurrentDay = 1 to 7

		Select Case lCurrentDay

			Case is = 1
				sOutput = sOutput + "SUN "

			Case is = 2
				sOutput = sOutput + "MON "

			Case is = 3
				sOutput = sOutput + "TUE "

			Case is = 4
				sOutput = sOutput + "WED "

			Case is = 5
				sOutput = sOutput + "THU "

			Case is = 6
				sOutput = sOutput + "FRI "

			Case is = 7
				sOutput = sOutput + "SAT "

			Case Else

				LogIt(LVL_STATUSINFO, "?!?!?Unexpected Error in Select Statement re: 7 days of the week?!?!?")
				sOutput = sOutput + chr(10) + chr(10) + "***ERROR***"
				goto eXIT_fUNCTION
					
			End Select


		'----- Cycle through each hour -----
		For lCurrentHour = 0 to 23

			
			'----- Jump to whatever day we're looking at
			'and input the value there -----
			Select Case lCurrentDay

				Case is = 1
					sOutput = sOutput + str$(wkmxCurrent.SUN(lCurrentHour))

				Case is = 2
					sOutput = sOutput + str$(wkmxCurrent.MON(lCurrentHour))

				Case is = 3
					sOutput = sOutput + str$(wkmxCurrent.TUE(lCurrentHour))

				Case is = 4
					sOutput = sOutput + str$(wkmxCurrent.WED(lCurrentHour))

				Case is = 5
					sOutput = sOutput + str$(wkmxCurrent.THU(lCurrentHour))

				Case is = 6
					sOutput = sOutput + str$(wkmxCurrent.FRI(lCurrentHour))

				Case is = 7
					sOutput = sOutput + str$(wkmxCurrent.SAT(lCurrentHour))

				Case Else

					LogIt(LVL_STATUSINFO, "?!?!?Unexpected Error in Select Statement re: 7 days of the week?!?!?")
					sOutput = sOutput + chr(10) + chr(10) + "***ERROR***"
					goto eXIT_fUNCTION
					

			End Select


		Next lCurrentHour


		'----- add a CR to the end of the day row ------
		sOutput = sOutput + chr(10)

	
	Next lCurrentDay


	
eXIT_fUNCTION:

	sOutputWeeklyMatrix = sOutput

	ExitSub("sOutputWeeklyMatrix")

End Function 'sOutputWeeklyMatrix

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_ClkDayOnWeeklyMatrix
'
'	ASSUMES
'		The current dialog contains a wekly matrix dialog
'
'	PARAMETERS:
'		lDay - Number representing the day of the week
'				(0=All, 1=SUN, 2=MON... , 7=SAT)
'
'	RETURN VALUE:
'		TRUE - if the button was clicked, (or at least if this funciton thinks it was)
'		FALSE -otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_ClkDayOnWeeklyMatrix(lDay as Long) as Long


	EnterSub("b_ClkDayOnWeeklyMatrix - Day[" + Str$(lDay) + "]")


	Dim hwndWMatrix as Long
	Dim infoWMatrix as INFO
	Dim lWidth as Long
	Dim lHeight as Long


	'----- assume failure -----
	b_ClkDayOnWeeklyMatrix = FALSE



	'----- sometimes the caption bar control menu gets the focus, (no, I
	'don't know why.  I blame VT for being freaky at times...), this will
	'click in the center of the dialog and prevent the issue from causing havoc -----
	wClkWnd(0)

		

	'----- Verify weekly matrix control exists and intial custom class -----
	wCustomSetClass(WEEKLYMATRIX_CLASSNAME)

	if wCustomExists(_ord(1)) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not find a Weekly Matrix control, (Class Name = [" + WEEKLYMATRIX_CLASSNAME + "])")
		goto eXIT_fUNCTION

	end if


	'----- get size information about control -----
	hwndWMatrix = wCustomFind(_ord(1))
	wGetInfo(hwndWMatrix, infoWMatrix)
	lHeight = infoWMatrix.wHeight
	lWidth = infoWMatrix.wWidth



	'---- the window will be divided into nine equal sections heightwise,
	' each section representing one button, (ALL, SUNDAY, ..., SATURDAY)
	' PLUS the space above the buttons for the legend, (~1.5 buttons).

	' Height is now equal to the height of one button.  Divided by two
	' and we have the middle of the first button.  Add one whole button
	' height for each day to reach middle of that button -----
	lHeight = int((lHeight / 9.5 / 2) + (lHeight / 9.5 * (lDay + 1.5)))


	'----- the day buttons comprise one-fifth the widthe of the control.
	'  1/5 equals the width of the button, and half of this is the 
	' middle of the button. -----
	lWidth = int(lWidth / 5 / 2)



	'---- we now have an appropriate height and width relative to the top 
	' left corner of the weekly matrix control. -----
	wCustomClickAt(_ord(1), lWidth, lHeight, VK_LBUTTON)


	'----- that should be all it takes, clean up -----
	b_ClkDayOnWeeklyMatrix = TRUE


	
eXIT_fUNCTION:

	ExitSub("b_ClkDayOnWeeklyMatrix")

End Function 'b_ClkDayOnWeeklyMatrix

'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
'
'	b_ClkHourOnWeeklyMatrix
'
'	ASSUMES
'		The current dialog contains a wekly matrix dialog
'
'	PARAMETERS:
'		lHour - Number representing the hour of day
'
'	RETURN VALUE:
'		TRUE - if the button was clicked, (or at least if this funciton thinks it was)
'		FALSE -otherwise
'
'-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Function b_ClkHourOnWeeklyMatrix(lHour as Long) as Long


	EnterSub("b_ClkHourOnWeeklyMatrix - Hour[" + Str$(lHour) + "]")


	Dim hwndWMatrix as Long
	Dim infoWMatrix as INFO
	Dim lWidth as Long
	Dim lHeight as Long


	'----- assume failure -----
	b_ClkHourOnWeeklyMatrix = FALSE



	'----- sometimes the caption bar control menu gets the focus, (no, I
	'don't know why.  I blame VT for being freaky at times...), this will
	'click in the center of the dialog and prevent the issue from causing havoc -----
	wClkWnd(0)

		

	'----- Verify weekly matrix control exists and intial custom class -----
	wCustomSetClass(WEEKLYMATRIX_CLASSNAME)

	if wCustomExists(_ord(1)) = FALSE then

		LogIt(LVL_STATUSINFO, "Could not find a Weekly Matrix control, (Class Name = [" + WEEKLYMATRIX_CLASSNAME + "])")
		goto eXIT_fUNCTION

	end if


	'----- get size information about control -----
	hwndWMatrix = wCustomFind(_ord(1))
	wGetInfo(hwndWMatrix, infoWMatrix)
	lHeight = infoWMatrix.wHeight
	lWidth = infoWMatrix.wWidth



	'---- the window will be divided into thirty equal sections heightwise,
	' each section representing one button, (ALL, 0-23)

	lWidth = int((lWidth / 15 / 2) + (lWidth / 31 * (lHour + 6.4)))


	'----- the hour buttons comprise one-fifth the widthe of the control.
	'  1/5 equals the width of the button, and half of this is the 
	' middle of the button. -----
	lHeight = int((lHeight / 9.5 / 2) + (1.5 * lHeight / 9.5))



	'---- we now have an appropriate height and width relative to the top 
	' left corner of the weekly matrix control. -----
	wCustomClickAt(_ord(1), lWidth, lHeight, VK_LBUTTON)


	'----- that should be all it takes, clean up -----
	b_ClkHourOnWeeklyMatrix = TRUE


	
eXIT_fUNCTION:

	ExitSub("b_ClkHourOnWeeklyMatrix")

End Function 'b_ClkHourOnWeeklyMatrix





function bMoveServerEx(sServerName as string, sFromSite as String, sToSite as String) as long

EnterSub("bMoveServerEX [" + sServerName + "] (from->to : [" + sFromSite + "] -> [" + sToSite + "]")

	
	bMoveServerEx =  false
	
	if WTreeItemExists(ORD_1,sFromSite) then

		WTreeItemExpand(ORD_1,sFromSite)

		Sleep(MIN_WAIT)

		WTreeItemClk(ORD_1,sFromSite)

	else
		
		LogIt(LVL_STATUSINFO, "Can not locate Tree Item : " + sFromSite + ". Test will sleep ")
		Sleep(MIN_WAIT)

		if WTreeItemExists(ORD_1,sFromSite) then

			Sleep(MIN_WAIT)
		
			WTreeItemClk(ORD_1,sFromSite)

			WTreeItemClk(ORD_1,sFromSite)
		else
			
			LogIt(LVL_STATUSINFO, "Can not locate Tree Item : " + sFromSite)
		
			bMoveServerEX = false
		
			exit function

		end if


	end if
		



	if not b_wViewItemClk_Ex(ORD_1,SERVERS_NODE) then
		
		LogIt(LVL_STATUSINFO, "Can not locate view item : " + SERVERS_NODE )
		
		bMoveServerEX = false
		
		exit function

	end if

	if not b_wViewItemClk_Ex(ORD_1,SERVERS_NODE) then
		
		LogIt(LVL_STATUSINFO, "Can not locate view item : " + SERVERS_NODE )
		
		bMoveServerEX = false
		
		exit function

	end if

	WViewItemDblClk(ORD_1,SERVERS_NODE)
	Sleep(MIN_WAIT)

	if not b_wViewItemClk_Ex(ORD_1,sServerName,VK_RBUTTON) then
		
		LogIt(LVL_STATUSINFO, "Can not locate view item : " + sServerName )
		
		bMoveServerEX = false
		
		exit function

	end if





'Select move menu item
	if not b_wMenuSelect_Ex(MNU_MOVE_NO_HOTKEY) then
		
		bMoveServerEx = false
		exit function

	end if

	
'Find the site to move the server to in the view list
	if not b_wViewItemClk_Ex(DEFAULT_ORDINAL, sToSite) then

		bMoveServerEx = false
		LogIt(LVL_STATUSINFO, "Can not locate object in view : " + sToSite)
		exit function

	end if

	if b_wButtonClick_Ex(BTN_OK) then
		
		LogIt(LVL_STATUSINFO, "Move completed successfully")
		bMoveServerEX = TRUE

	end if
		




	


ExitSub("bMoveServerEX [" + sServerName + "] (from->to : [" + sFromSite + "] -> [" + sToSite + "]")

end function 'function bMoveServerEx(sServerName as string, sFromSite as String, sToSite as String) as long


'------------------------------------------------------------------------------
'------------------------------------------------------------------------------

function bMakeServerGCex(sSiteName as String,sServerName as String,State as Integer) as long
	
EnterSub("bMakeServerGC")

Dim ErrorValue as String

ErrorValue = ""

' Expand Sites Node

	if WTreeItemExists(ORD_1,SITES_NODE) then
		
		WTreeItemExpand(ORD_1,SITES_NODE)

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)

'Expand Site

	if WTreeItemExists(ORD_1,sSiteName) then
		
		WTreeItemExpand(ORD_1,sSiteName)

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)

'Expand Server Node

	if WTreeItemExists(ORD_1,SERVERS_NODE) then
		
		WTreeItemExpand(ORD_1,SERVERS_NODE)

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)


'Expand Server 

	if WTreeItemExists(ORD_1,sServerName) then
		
		WTreeItemExpand(ORD_1,sServerName)

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)


'Expand properties node of NTDS Setting node

	if WTreeItemExists(ORD_1,NTDSSETTINGS_NODE) then
		
		WTreeItemClk(ORD_1,NTDSSETTINGS_NODE,VK_RBUTTON)

		Sleep(MIN_WAIT)

		WMenuSelect(SM_STR_PROPERTIES)

		Sleep(MIN_WAIT)

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)


'Check or Uncheck the 

	if WCheckExists(ORD_1) then

		Select case WCheckState(ORD_1)
		
			case 0 
				
				WCheckCheck(ORD_1)

			case 1

				WCheckUnCheck(ORD_1,CHECKED)

		end select

	else
		
		bMakeServerGCex = FALSE

		exit function

	end if

	Sleep(MIN_WAIT)


' Close the dialog

	WButtonClick(BTN_OK)

	bMakeServerGCex = TRUE




ExitSub("bMakeServerGC")
	
end function  'function bMakeServerGC(sSiteName as String,sServerName as String) as long

'------------------------------------------------------------------------------

function bMakeServerNOTGCex(sSiteName as String,sServerName as String) as long
	
EnterSub("bMakeServerGC")

	WTreeItemExpand(ORD_1,sSiteName)
	Sleep (MIN_WAIT)
	WTreeItemClk(ORD_1,sSiteName)
	Sleep (MIN_WAIT)
	WViewItemDblClk(ORD_1,SERVERS_NODE)
	Sleep (MIN_WAIT)
	WViewItemDblClk(ORD_1,sServerName)
	Sleep (MIN_WAIT)
	WViewItemClk(ORD_1,NTDSSETTINGS_NODE,VK_RBUTTON)
	Sleep (MIN_WAIT)
	WMenuSelect(SM_STR_PROPERTIES)
	Sleep (MIN_WAIT)
	WCheckState("Global Catalog",UNCHECKED)
	Sleep (MIN_WAIT)
	WButtonClick("OK")
	


ExitSub("bMakeServerGC")
	
end function  'function bMakeServerGC(sSiteName as String,sServerName as String) as long



'------------------------------------------------------------------------------
function bCreateSitelinkEX(strSiteLinkName as string,strCost as string,strInterval as string,strMemberList() as string,length as integer)

Dim i

   WTreeItemExpand(ORD_1,SITES_NODE)

   Sleep(MIN_WAIT)

   WTreeItemExpand(ORD_1,INTERSITE_TRANSPORTS_NODE)

   Sleep(MIN_WAIT)

   WTreeItemClk(ORD_1,IP_NODE,VK_RBUTTON)

   Sleep(MIN_WAIT)

   WMenuSelect(MNU_CREATE_NEW_SITELINK)

   Sleep(MIN_WAIT)

   WEditSetText(ORD_1,strSiteLinkName)

   Sleep(MIN_WAIT)

   for i = 0 to length -1 
		
		if WListItemExists(ORD_1,strMemberList(i)) then

			WListItemClk(ORD_1,strMemberList(i))
			WButtonClick("~" + SM_STR_ADD)

		end if

   next

   WButtonClick(BTN_OK)

   CaptionSleep(CAP_ACTIVE_DIRECTORY)
	
	if GetText(wGetActWnd()) = (CAP_ACTIVE_DIRECTORY) then

		WButtonClick(BTN_OK)
		Sleep(MIN_WAIT)
		WButtonClick(BTN_CANCEL)

	end if


   WTreeItemExpand(ORD_1,SITES_NODE)

   Sleep(MIN_WAIT)

   WTreeItemExpand(ORD_1,INTERSITE_TRANSPORTS_NODE)

   Sleep(MIN_WAIT)

   WTreeItemClk(ORD_1,IP_NODE)

	Sleep(MIN_WAIT)

   if not WViewItemExists(ORD_1,strSiteLinkName) then
		exit function
   end if

   WViewItemClk(ORD_1,strSiteLinkName,VK_RButton)

   Sleep(MIN_WAIT)

   WMenuSelect(CAP_PROPERTIES)

   Sleep(MIN_WAIT)

   WEditSetText(ORD_2,strCost)

    Sleep(MIN_WAIT)

   WEditSetText(ORD_3,strInterval)

   WButtonClick(BTN_OK)

end function

'------------------------------------------------------------------------------


function exCreateSubnet(strIPAddress as string, strMask as string , strSiteName as string)

	if bOpenSubnetsContainer() = FALSE then

		FailIt(LVL_VERBOSE, "Could not open Subnets container.")

	end if

	'Select new subnet from context menu
	If b_wTreeItemClk_Ex(DEFAULT_ORDINAL, SUBNETS_NODE, VK_RBUTTON) = FALSE then

		FailIt(LVL_VERBOSE, "Could not find subnets container.")

	elseIf b_wMenuSelect_Ex(MNU_CREATE_NEW_SUBNET) = FALSE then

		FailIt(LVL_VERBOSE, "Could not select/find new subnet on context menu.")

	end if
		

'New subnet dialog should appear
	CaptionSleep(CAP_CREATE_NEW)



'Enter each of the pieces of the IP address in turn
	b_Play_Ex(strIPAddress)

'Move on to mask field
	b_Play_Ex("{TAB}")

'Input the mask
	b_Play_Ex(strMask)



'The IP address and mask are now entered.  Select site to map to.
	b_wViewItemClk_Ex(ORD_1, strSiteName)

'All necessary information inputted.  Click OK
	if b_wButtonClick_Ex(BTN_OK) = FALSE then

		FailIt(LVL_VERBOSE, "unexpected error involving cancel button???!?!?")

	end if

	Sleep(MIN_WAIT)

	if WButtonExists(BTN_OK) then
		
		WButtonClick(BTN_OK)

		Sleep(MIN_WAIT)

		WButtonClick(BTN_CANCEL)

	end if

end function
'------------------------------------------------------------------------------
sub saveScreenShot(sFilename = "" as string, sImagename = "" as string,sCaptureMode = "" as string)

'////////////////////////////////////////////////////////////

'// Screen shot is saved to a Visual Test screen file (.SCN)

'// Multiple images may be saved to the same file

'// File may be viewed or manipulated with Visual Test Screen Utility 

'// Optional parameters may be entered or environmental variables may be used

'// Optional:

'//          sFilename = "" as string

'//                      if "" then environmental variables are used

'//                      otherwise is the same as %SCREENCAP_FILENAME%

'// sImagename = "" as string

'//                      ignored if sFilename is ""

'//                      otherwise is the same as %SCREENCAP_IMAGENAME%

'// sCaptureMode = "" as string

'//                      ignored if sFilename is ""

'//                      otherwise is the same as %SCREENCAP_CAPTUREMODE%

'// Three environmental variables may used

'// %SCREENCAP_FILENAME%

'//                      "" saves the file as ENVIRON$("COMPUTERNAME") + "_" + sNewDate + ".SCN"  *** This is only used when not called from FailIt.

'//                      "DATE" saves the file as ENVIRON$("COMPUTERNAME") + "_" + sNewDate + ".SCN"

'//                      "DEFAULT" saves the file as "FailItScreen.SCN"

'//                      Any other text saves the file as the text

'//                      *** %SCREENCAP_FILENAME% must be set for FailIt to call this sub***

'// %SCREENCAP_IMAGENAME%

'//                      "" sets the image name to calling .pc6 file + Unique ID + Failit #

'//                      "OVERWRITE" set the image name to "CurrentWindow"

'//                      Any other text image name is the text

'// %SCREENCAP_CAPTUREMODE%

'//                      "ACTIVE" captures only the active window

'//                      Anything else captures the Desktop (minus the Taskbar)  *** This can consume a lot of disk space so it isn't recommended.

'//

'// Calling this sub with no optional parameters and/or no environmental variables set will create a screen dump with the default settings.

'// 

'// Called from FailIt

'// Created by edfrench 10/24/01

'///////////////////////////////////////////////////////////

 

            Dim iLen                                               as Integer                      '//Counter for converting " " to "_" in date

            Dim sDate                                             as string                        '//Current Date setting

            dim sNewDate                           as string                        '//Converted date

            dim sHowToNameFile                 as string                        '//Stores how to create the .SCN file name

            dim sScreenShotFilename          as string                        '//The .SCN filename

            dim sScreenShotFullPath           as string                        '//Full path to the .SCN filename

            dim hDesktop                            as HANDLE                   '//Handle to the Desktop window

            dim sHowToNameImage             as string                        '//Stores how to name them image

            dim tScnFileInfo             as SCNFILEINFO           '//Structure containing info about an .SCN file

            dim iImageCount                                    as integer                      '//Number of images in the .SCN file

            dim iFreeSpace                         as double                      '//Free space on Temp folder hard drive

            dim iFileSize                             as double                      '//Size of image 

            '//get current date to create filename

            sDate     = DATE$

            sNewDate  = ""

            '//Convert date from 01 12 2001 to 01_12_2001 for use as part of a filename and trim trailing characters

            for iLen = 1 to len(sDate)

                        if ASC(sDate) >= ASC("0") and ASC(sDate) <= ASC("9") then

                                    sNewDate = sNewDate + CHR(ASC(sDate))

                        else

                                    sNewDate = sNewDate + "_"

                        endif

 

                        sDate = right(sDate, len(sDate)-1)

            next iLen

            

            '//Get the current settings

            if sFilename = "" then

                        '//get settings from environmental variables

                        sHowToNameFile = ENVIRON$ ( "SCREENCAP_FILENAME" ) 

                        sHowToNameImage = ENVIRON$ ( "SCREENCAP_IMAGENAME" ) 

                        sCaptureMode = ENVIRON$ ( "SCREENCAP_CAPTUREMODE" ) 

            else

                        '//use the optional parameters

                        sHowToNameFile = sFilename

                        sHowToNameImage = sImagename

                        sCaptureMode = sCaptureMode

            end if

            

            '//Create the filename      

            '//use the default file name UNLESS the specific file name has been

            '//specified using the %SCREENCAP_FILENAME% environment variable or sFilename parameter

            if sHowToNameFile = "DEFAULT" then

                        sScreenShotFilename = "FailItScreen.SCN"

            elseif sHowToNameFile = "DATE" then

                        sScreenShotFilename = ENVIRON$("COMPUTERNAME") + "_" + sNewDate+ ".SCN" 

            elseif sHowToNameFile = "" then

                        sScreenShotFilename = ENVIRON$("COMPUTERNAME") + "_" + sNewDate + ".SCN" 

            else

                        sScreenShotFilename = sHowToNameFile

            end if

            '//Prepend the Temp folder path

            sScreenShotFullPath = gstrTempPath + sScreenShotFilename

 

            '//Overwrite the current image unless

            '//specified by entering text in the %SCREENCAP_IMAGENAME% environment variable or sImagename parameter

            if sHowToNameImage = "" then

                        '//create a unique name using the calling scenario filename and an ID number

                        '//get count of images in the file

                        if EXISTS (sScreenShotFullPath) then

                                    ScnFileInfo ( sScreenShotFullPath, tScnFileInfo )

                                    iImageCount= tScnFileInfo.NumScreens

                        else

                                    iImageCount = 0

                        end if

 

                        '//Use the scenario file name as the image name and append unique ID number and the FailIt #

                        sImageName=NAME$(0) + "_"+ trim(str(iImageCount+1))+ "FailItNum_" + trim(str(giFailCount))

            elseif sHowToNameImage = "OVERWRITE" then'//overwrite the default image

                        sImageName="CurrentWindow"

            else 

                        '// any text other than "OVERWRITE" will be used as the image name

                        sImageName=sHowToNameImage

            end if

            '//Log the file and image name

            LogIt (LVL_VERBOSE,"Saving screen shot filename: " + sScreenShotFullPath + " | Image name: " + sImageName)

 

            '//****************************************************

            '//***To Do***

            '//Calculate size of image then 

            '//check for free disk space before writing to the file

            '//****************************************************

 

            iFreeSpace =2 '//Placeholder for To Do item

            iFileSize = 1 '//Placeholder for To Do item            

            if iFreeSpace > iFileSize then

                        '//Set %SCREENCAP_CAPTUREMODE% or sCaptureMode to ACTIVE to just capture the Active window

                        '//Anything else will default to capturing the Desktop (Full screen except the Taskbar)

                        if sCaptureMode="ACTIVE" then

                                    '//get the handle of the active window, then save image to the specified file.

                                    ScnCaptureWindow ( sScreenShotFullPath, sImageName, 0, FALSE )

                        else

                                    '//Get the window handle of the desktop, then save image to the specified file.

                                    hDesktop= WDesktopFind ( )

                                    ScnCaptureWindow ( sScreenShotFullPath, sImageName, hDesktop, FALSE )

                        end if

            else

                        LogIt(LVL_VERBOSE,"There is not enough free space on the Temp folder hard drive to save this image.")

            end if

 

end sub '//saveScreenShot


function b_VerifySitelink(SiteLinkName as string,ExpectedCost as string, ExpectedInterval as string) as long

	if WViewItemExists(ORD_1,SiteLinkName) then
		
		bOpenProperties(ORD_1,SiteLinkName)


		'Verify that Cost is set to expected value

		if EditText(ORD_2) = ExpectedCost then
		
		
			
			LogIt(LVL_STATUSINFO,"Cost is correctly set to : " + ExpectedCost + " on Sitelink : " + SiteLinkName)
			b_VerifySitelink = TRUE

			
			'At this point Cost is set to Expected value, so also check Interval. Verify that it is set to expected value

			if EditText(ORD_3) = ExpectedInterval then
			

				LogIt(LVL_STATUSINFO,"Interval is correctly set to : " + ExpectedInterval + " on Sitelink : " + SiteLinkName)
				b_VerifySitelink = TRUE

			
			else

				'Interval is not set to correct value report

				LogIt(LVL_STATUSINFO,"FAIL : Interval is not correctly set. Expected : " + ExpectedInterval + " Found : " + EditText(ORD_2))
				b_VerifySitelink = FALSE
			
			end if 'if EditText(ORD_3) = ExpectedInterval then

			
		else


			' Cost is not set to correct value

			LogIt(LVL_STATUSINFO,"FAIL : Cost is not correctly set. Expected : " + ExpectedCost + " Found : " + EditText(ORD_2))
			b_VerifySitelink = FALSE
			
		end if ' if EditText(ORD_2) = ExpectedCost then




	else

		LogIt(LVL_STATUSINFO, "FAIL : Can not locate sitelink : " + SiteLinkName)
		b_VerifySitelink = FALSE


	end if

	WButtonClick(BTN_CANCEL)

end function
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\ExternalCFunc.cpp ===
// ExternalCFunc.cpp
//
// Export C Function that converts PUID to ANID
// This is solely for the purpose of interop to C# code
//
// by Raphael Mun

#include "Source/stdafx.h"

extern "C" __declspec(dllexport) int ConvertPUIDToANID(PWSTR pwszPUID, // [in]
					  DWORD PUIDchCount, // [in]
					  PSTR pszANID, // [out]
					  DWORD ANIDchCount) // [in]
{
	CANIDHasher anidHasher;

	if (anidHasher.Initialize (NULL) != S_OK)
		return -1;

	if (anidHasher.HashPUIDToANID (pwszPUID, PUIDchCount, pszANID, ANIDchCount) != S_OK)
		return -1;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Headers\anidconst.h ===
//-----------------------------------------------------------------------------
// Microsoft User Services and Revenue Technologies
//
// File:			ANIDConst.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Comments: 		Definition of the constants for ANID feature
//
// History:			09/22/04 	WenjunQ
//-----------------------------------------------------------------------------
#pragma once

// ANID constants
const int ANID_LSB		= 0xFFFFFFFF;			// the last 4 bytes denote an ANID. 	
const WCHAR k_wszANID_LSB[] = L"FFFFFFFF";	// the unicode version of the ANID_LSB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Headers\Hex.h ===
//------------------------------------------------------------------------------
//
// Microsoft User Services and Revenue Technologies
// Copyright (C) Microsoft Corporation
//
// File: 		Hex.h
//
// Contents:	Support for encoding/decoding binary with hex encoding.
//
// History:		04/19/04	AlexPort	Created (based on ATL 7.0).
//										This was needed because of several bugs
//										in the ATL implementation.
//
//------------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline unsigned int HexEncodeGetRequiredLength( unsigned int nSrcLen )
{
	return 2 * nSrcLen;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline unsigned int HexDecodeGetRequiredLength( unsigned int nSrcLen )
{
	return ( nSrcLen / 2 );
}

//-----------------------------------------------------------------------------
// Get the decimal value of a hexadecimal character.
//-----------------------------------------------------------------------------
inline char GetHexValue( char ch )
{
	if (ch >= '0' && ch <= '9')
		return (ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (ch - 'a' + 10);
	return -1;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline bool HexEncode( const BYTE *pbSrc, unsigned int cbSrc, char* szDest, unsigned int *pcchDest )
{
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
										  'A', 'B', 'C', 'D', 'E', 'F'};

	const BYTE* pbEndSrc = pbSrc + cbSrc;

	if ( !pbSrc || !szDest || !pcchDest || (*pcchDest < HexEncodeGetRequiredLength(cbSrc)) )
	{
		return FALSE;
	}

	while ( pbSrc < pbEndSrc )
	{
		BYTE ch = *pbSrc++;
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
	}

	*pcchDest = HexEncodeGetRequiredLength(cbSrc);

	return TRUE;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline BOOL HexDecode( const char* pSrc, unsigned int cchSrc, LPBYTE pbDest, unsigned int* pcbDest )
{
	const char* pEndSrc = pSrc + cchSrc;

	if ( !pSrc || !pbDest || !pcbDest || (cchSrc%2 != 0) || (*pcbDest < HexDecodeGetRequiredLength(cchSrc)) )
	{
		return FALSE;
	}

	while ( pSrc < pEndSrc )
	{
		char ch1 = GetHexValue( *pSrc++ );
		char ch2 = GetHexValue( *pSrc++ );

		if ((ch1 < 0) || (ch2 < 0))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
	}

	*pcbDest = HexDecodeGetRequiredLength(cchSrc);

	return TRUE;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline BOOL HexDecode( PCWSTR pSrc, unsigned int cchSrc, LPBYTE pbDest, unsigned int* pcbDest )
{
	PCWSTR pEndSrc = pSrc + cchSrc;

	if ( !pSrc || !pbDest || !pcbDest || (cchSrc%2 != 0) || (*pcbDest < HexDecodeGetRequiredLength(cchSrc)) )
	{
		return FALSE;
	}

	while ( pSrc < pEndSrc )
	{
		if ((*pSrc > 0x7f) || (*pSrc < 0))
			return FALSE;
	
		char ch1 = GetHexValue( (CHAR)*pSrc++ );
		char ch2 = GetHexValue( (CHAR)*pSrc++ );

		if ((ch1 < 0) || (ch2 < 0))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
	}

	*pcbDest = HexDecodeGetRequiredLength(cchSrc);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Headers\NAP.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAP.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		The class to encrypt/decrypt NAP cookie
//
// History:		09/13/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

// The maximum sizes for the NAP cookie elements.
// The sizes are number of characters in hex, including the NULL terminater.
const DWORD MAX_NAP_VERSION_CCH 		= 10;
const DWORD MAX_NAP_EXPIRATION_CCH	= 5;
const DWORD MAX_NAP_PROFILE_CCH		= 64;
const DWORD MAX_NAP_WRITES_CCH		= 5;

const USHORT DEFAULT_EXPIRATION 		= 135;
const USHORT DEFAULT_REFRESH			= 65;

// Profile data format for NAP cookie
#include <pshpack1.h>
typedef struct tagNAPData
{
	UINT	Region;
	CHAR	Country[2];
	USHORT	Language;
	UINT 	BirthDate;	// Number of days since 12/30/1899
	CHAR	Gender;		// M, F, or U
	CHAR	Occupation;
	CHAR	PostalCode[15];	// Pad with NULL if needed
} NAP_DATA, *PNAP_DATA;
#include <poppack.h>


// NAP cookie elements
// As in/out parameter( e.g. pNewCookie in UpdateNAPCookie()), 
// cbxxx should be the size of the corresponding pszxxx buffer. 
// As in parameter( e.g. pOldCookie in UpdateNAPCookie()),  
// cbxxx should be the actual data size in the corresponding pszxxx
// excluding the NULL terminater.
typedef struct tagNAPCookie
{
PSTR 	pszVersion;	// Pointer to the V element of the NAP cookie
DWORD	cbVersion;

PSTR 	pszExpiration; // Pointer to the E element of the NAP cookie
DWORD	cbExpiration;

PSTR 	pszProfile;	// Pointer to the C element of the NAP cookie
DWORD	cbProfile;

PSTR 	pszWrites;	// Pointer to the W element of the NAP cookie
DWORD 	cbWrites;

} NAP_COOKIE, *PNAP_COOKIE;


// Pair of NAP encryption keys
typedef struct tagNAPKeys
{
	USHORT  	usPrevKeyVersion;
	USHORT  	usKeyVersion;
	HCRYPTKEY	hPrevKey;
	HCRYPTKEY	hKey;
}NAP_KEYS, *PNAP_KEYS;


// Enum values to tell whether the cookie should be written 
// and the type of write.
typedef enum 
{
	eCWTNoWrite = 0,
	eCWTFirstTimeWrite,
	eCWTOverWrite,
	eCWTRefreshWrite
} eCookieWriteType;


//------------------------------------------------------------------------------
// CCookieExpiration
// 
// The class to handle cookie expiration and refresh,
// used by CNAPEncrypt and CANIDHasher.
//
class CCookieExpiration
{
public:
	CCookieExpiration() ;
	
//-----------------------------------------------------------------------------
// CCookieExpiration::SetExpiration()
//
// Set cookie expiration interval and refresh interval 
//-----------------------------------------------------------------------------
	inline void SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays)
	{
		m_cExpiration = cLifespanDays;
		m_cRefresh = cRefreshIntervalDays;
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::NeedRefresh()
//
// Given the current date and E tag value, returns whether the cookie should be refreshed.
//-----------------------------------------------------------------------------
	inline BOOL NeedRefresh(
		DATE dtNow,
		USHORT usEValue
	)
	{
		if ( m_cRefresh && (dtNow >= m_dwDaysToJan2004 + usEValue))
			return TRUE;

		return FALSE;
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::GetETagValue()
//
// Given the cookie expiration date, calculate the E tag value.
//-----------------------------------------------------------------------------
	inline USHORT GetETagValue(DWORD dwExpireDate)
	{
		return (USHORT)(dwExpireDate - m_cRefresh - m_dwDaysToJan2004 );
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::GetExpireDate()
//
// Given the current date, calculate the cookie expiration date.
//-----------------------------------------------------------------------------
	inline DATE GetExpireDate(DATE dtNow)
	{
		return dtNow + m_cExpiration;
	};

private:
	USHORT		m_cExpiration;
	USHORT 		m_cRefresh;
	DWORD 		m_dwDaysToJan2004;
};


//------------------------------------------------------------------------------
// CNAPEncrypt
// 
// The class to encrypt/decrypt NAP cookie
//
class CNAPEncrypt
{
public:
	CNAPEncrypt();
	~CNAPEncrypt();

	HRESULT Initialize(
		PCWSTR pwszKeys,
		PCWSTR* ppwszErrAPI
	);
	
	HRESULT ParseKeys(
		PCWSTR pwszKeys,
		PNAP_KEYS pnapKeys,
		PCWSTR* ppwszErrAPI
	);

	HRESULT SetKeys(PNAP_KEYS pnapKeys);
		
	HRESULT SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays);

	HRESULT DecryptNAPCookie(
		PNAP_COOKIE pCookie,
		PNAP_DATA pData
	);

	// Note: Content of pOldCookie may be changed by the function
	HRESULT UpdateNAPCookie(
		PNAP_COOKIE pOldCookie,
		PNAP_DATA pOldData,
		PNAP_DATA pNewData,
		PNAP_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
	);
	
private:

	int ParseKeyString(
		PCWSTR pwszKeys,
		DWORD 	cMaxKeys,
		USHORT 	*rgusVer,
		PWSTR	*rgpwszKey
	);

	HRESULT ImportOneKey(
		PWSTR 		pwszKey,
		HCRYPTKEY	*phKey,
		PCWSTR* ppwszErrAPI
	);

	BOOL ParseVersionString(
		PSTR 		pszVer,
		DWORD		cbVer,
		USHORT*		pusFormatVer,
		USHORT*		pusKeyVer
	);

	BOOL CreateVersionString(
		PSTR 		pszVer,
		DWORD*		pcbVer
	);

	HRESULT CreateNewCookie( 
		PNAP_COOKIE pNewCookie,
		PNAP_DATA pNewData,
		USHORT usWrites,
		DWORD dwExpire);

//-----------------------------------------------------------------------------
// CNAPEncrypt::DestroyNAPKeys()
//
// Destroy the current and previous NAP keys
//-----------------------------------------------------------------------------
	inline void DestroyNAPKeys()
	{
		if (m_napKeys.hKey != NULL)
		{
			CryptDestroyKey(m_napKeys.hKey);
			m_napKeys.hKey = NULL;
		}

		if (m_napKeys.hPrevKey != NULL)
		{
			CryptDestroyKey(m_napKeys.hPrevKey);
			m_napKeys.hPrevKey = NULL;
		}
	}

	HRESULT DecryptNAPData( 
		PSTR 	pszProfile,
		DWORD	cbProfile,
		USHORT  usKeyVer,
		PNAP_DATA pData
	);

	HRESULT EncryptNAPData(
		PNAP_DATA pData,
		PSTR 	pszProfile,
		DWORD*	pcbProfile
	);

	HRESULT ProcessOldCookie(
		PNAP_COOKIE pOldCookie,
		PNAP_DATA pOldData,
		eCookieWriteType *peCWT,
		BOOL 	*pfCurrentVer,
		USHORT 	*pusEValue,
		USHORT *pusWrites
	);
			

	HCRYPTPROV	m_hCryptProv;
	NAP_KEYS 	m_napKeys;
	BYTE		m_rgbRandom[7];
	HCRYPTKEY	m_hKeyFixed;
	LONG		m_lCounter;		
	CCookieExpiration m_cookieExp;
	DWORD		m_cbEncodedData;
};


// The maximum sizes for the ANON cookie elements.
// The sizes are number of characters in hex, including the NULL terminater.
const DWORD ANID_CCH 					= 33;
const DWORD MAX_ANID_EXPIRATION_CCH	= 5;
const DWORD MAX_ANID_WRITES_CCH		= 5;

// ANON cookie elements
// As in/out parameter( e.g. pNewCookie in UpdateANONCookie()), 
// cbxxx should be the size of the corresponding pszxxx buffer. 
// As in parameter( e.g. pOldCookie in UpdateANONCookie()),  
// cbxxx should be the actual data size in the corresponding pszxxx
// excluding the NULL terminater.
typedef struct tagANIDCookie
{
PSTR 	pszExpiration; // Pointer to the E element of the ANON cookie
DWORD	cbExpiration;	

PSTR 	pszANID;	// Pointer to the ANID element of the ANON cookie
DWORD	cbANID;	

PSTR 	pszWrites;	// Pointer to the W element of the ANON cookie
DWORD 	cbWrites;

} ANID_COOKIE, *PANID_COOKIE;

//------------------------------------------------------------------------------
// CANIDHasher
//  
// The class to hash a PUID to an ANID. 
//
class CANIDHasher
{
public:

	CANIDHasher();
	~CANIDHasher();
	HRESULT Initialize(PCWSTR* ppwszErrAPI);

	// Note: Content of pwszPUID may be changed the function
	HRESULT UpdateANONCookie(
		PANID_COOKIE pOldCookie,
		PWSTR pwszPUID,
		DWORD cchPUID,
		PANID_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
	);

	HRESULT SetExpiration(
			USHORT cLifespanDays, 
			USHORT cRefreshIntervalDays
	);

	HRESULT HashPUIDToANID( 
			PWSTR 	pwszPUID, 
			DWORD 	cchPUID, 
			PSTR 	pszANID, 
			DWORD 	cchANID
	);

private:

	HRESULT HashData( 
			const BYTE* pbText, 
			DWORD cbText, 
			BYTE* pbHashValue, 
			DWORD* pcbHashValue 
	);

	HRESULT CreateNewCookie(
			PANID_COOKIE pNewCookie,
			PWSTR pwszPUID,
			DWORD cchPUID,
			USHORT usWrites,
			DWORD dwExpire);
	
	
	HCRYPTPROV		m_hCryptProv;
	HCRYPTKEY		m_hKeyHMAC;	
	CCookieExpiration m_cookieExp;

	static const unsigned int	s_KeyLength			= 16;		// A key length of 128 bits is sufficient for the HMAC key used to hash the PUID.
	static const BYTE 	s_rgbKey[s_KeyLength];			// 64 bits key length (no max with HMAC).

	static const ALG_ID	s_HashAlgId			= CALG_MD5;	// MD5 is used as the hashing algorithm.
	static const unsigned int		s_HashAlgHashLength	= 16;		// 128 bits max hash length with MD5.

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Headers\NAPFixedKey.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPFixedKey.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		24 byte data generated by CryptGenRandom to derive the NAP fixed key.
//
// History:		09/15/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

extern const __declspec(selectany) BYTE NAP_FIXED_KEY[] = {
	0xba, 0xdb, 0x5c, 0xd5, 0x8c, 0x51, 0xb9, 0xd1, 0x11, 0xf9, 0x62, 0xe0,
	0xfd, 0x32, 0x15, 0x59, 0x03, 0x0b, 0x63, 0x92, 0x85, 0xb7, 0xfd, 0x79
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Headers\UrlSafeBase64.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			UrlSafeBase64.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Base 64 Encoding with URL and Filename Safe Alphabet ( section 4 of rfc3548 )
//
// History:		10/15/04 WenjunQ Created.
//-----------------------------------------------------------------------------
/*	
	 Table 2: The "URL and Filename safe" Base 64 Alphabet

    Value Encoding  Value Encoding  Value Encoding  Value Encoding
       0 A            17 R            34 i            51 z
       1 B            18 S            35 j            52 0
       2 C            19 T            36 k            53 1
       3 D            20 U            37 l            54 2
       4 E            21 V            38 m            55 3
       5 F            22 W            39 n            56 4
       6 G            23 X            40 o            57 5
       7 H            24 Y            41 p            58 6
       8 I            25 Z            42 q            59 7
       9 J            26 a            43 r            60 8
      10 K            27 b            44 s            61 9
      11 L            28 c            45 t            62 - (minus)
      12 M            29 d            46 u            63 _ (understrike)
      13 N            30 e            47 v
      14 O            31 f            48 w         (pad) =
      15 P            32 g            49 x
      16 Q            33 h            50 y

*/

 #pragma	once


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	int	Base64EncodeGetRequiredLength(
	int	nSrcLen
)
{
	return ( nSrcLen * 4 + 2 ) / 3;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	int	Base64DecodeGetRequiredLength(
	int	nSrcLen
)
{
	return nSrcLen * 3 / 4;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	BOOL Base64Encode(
	const BYTE*	pbSrcData,	//[in]	pointer	to buffer to encode
	int			nSrcLen,	//[in]	length of data to encode
	LPSTR		szDest,		//[out]	pointer	to output buffer for encoded data, must	be allocated by	caller
	int	*		pnDestLen	//[out] length of encoded data, which is	always longer then input data length
)
{
	static const char s_chBase64EncodingTable[64] = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
		'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
		'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_' };

	if ( (NULL != pbSrcData) &&	(NULL != szDest) && (NULL != pnDestLen) && (*pnDestLen >= Base64EncodeGetRequiredLength(nSrcLen)) )
	{
		LPSTR szDestStart = szDest;
		const BYTE*	pbSrcEnd = pbSrcData + nSrcLen;

		while ( pbSrcData < pbSrcEnd )
		{
			if ( (pbSrcEnd-pbSrcData) >= 3 )
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*pbSrcData << 4) & 0x3f) | (*(pbSrcData+1) >> 4) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*(pbSrcData+1) << 2) & 0x3f) | (*(pbSrcData+2) >> 6) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ *(pbSrcData+2) & 0x3f ];
				++szDest;
				pbSrcData += 3;
			}
			else if ( (pbSrcEnd-pbSrcData) == 2 )
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*pbSrcData << 4) & 0x3f) | (*(pbSrcData+1) >> 4) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ (*(pbSrcData+1) << 2) & 0x3f ];
				++szDest;
				break;
			}
			else
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ (*pbSrcData << 4) & 0x3f ];
				++szDest;
				break;
			}
		}

		*pnDestLen = szDest - szDestStart;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	BOOL Base64Decode(
	LPCSTR	szSrc,		// [in]		Pointer	to buffer to decode.
	int		nSrcLen,	// [in]		Length of buffer to	decode.
	PBYTE	pbDest,		// [out]	Pointer	to decoded output buffer, must be allocated	by caller.
	int	*	pnDestLen	// [in]		Pointer	to the size	of decoded buffer.
						// [out]	Pointer	to the length decoded data,	or the required	size in	order to store the data	in case	of failure.
)
{
													//	 0	 1	 2	 3	 4	 5	 6	 7	 8	 9 
	static const char s_cBase64DecodingTable[] =	{	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	 0 -   9
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	10 -  19
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	20 -  29
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	30 -  39
														-1,	-1,	-1,	-1,	-1,	62,	-1,	-1,	52,	53,	//	40 -  49
														54,	55,	56,	57,	58,	59,	60,	61,	-1,	-1,	//	50 -  59
														-1,	-1,	-1,	-1,	-1,	 0,	 1,	 2,	 3,	 4,	//	60 -  69
														 5,	 6,	 7,	 8,	 9,	10,	11,	12,	13,	14,	//	70 -  79
														15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	//	80 -  89
														25,	-1,	-1,	-1,	-1,	63,	-1,	26,	27,	28,	//	90 -  99
														29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	// 100 - 109
														39,	40,	41,	42,	43,	44,	45,	46,	47,	48,	// 110 - 119
														49,	50,	51,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 120 - 129
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 130 - 139
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 140 - 149
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 150 - 159
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 160 - 169
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 170 - 179
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 180 - 189
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 190 - 199
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 200 - 209
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 210 - 219
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 220 - 229
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 230 - 239
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 240 - 249
														-1,	-1,	-1,	-1,	-1,	-1					// 250 - 256
													};
	// Parameter check.
	if ( (NULL != szSrc) && (NULL != pbDest) && (NULL != pnDestLen) && (*pnDestLen >= Base64DecodeGetRequiredLength(nSrcLen)) )
	{
		BYTE* pbDestStart = pbDest;
		LPCSTR szSrcEnd = szSrc + nSrcLen;

		char c, c1;

		while ( szSrc < szSrcEnd )
		{
			c = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
			++szSrc;

			if ( (c != -1) && (szSrc < szSrcEnd) )
			{
				c1 = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
				++szSrc;

				if ( c1 != -1 )
				{
					*pbDest = (c << 2) | (c1 >> 4);
					++pbDest;

					if ( szSrc < szSrcEnd )
					{
						c = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
						++szSrc;

						if ( c != -1 )
						{
							*pbDest = (c1 << 4) | (c >> 2);
							++pbDest;

							if ( szSrc < szSrcEnd )
							{
								c1 = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
								++szSrc;

								if ( c1 != -1 )
								{
									*pbDest = (c << 6) | c1;
									++pbDest;
								}
								else
									return FALSE; // Bad character encountered.
							}
							else
								break;
						}
						else
							return FALSE; // Bad character encountered.
					}
					else
						break;
				}
				else
					return FALSE; // Bad character encountered.
			}
			else
				return FALSE; // Bad character encountered of not enough data.
		}

		*pnDestLen = pbDest - pbDestStart;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\ANIDHasher.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			ANIDHasher.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Class to hash a PUID or a 16 byte data stream to an ANID. 
//
// History:		05/19/04   Debbief   Created.
//				09/21/04   WenjunQ Moved to NAP library.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "../Headers/anidconst.h"

// This is a byte key that will be used by the HMAC algorithm to convert the PUID to an ANID. This key has been generated by CryptGenRandom API 
const BYTE CANIDHasher::s_rgbKey[s_KeyLength] = {0x58,0x41,0x0F,0x3B,0x3F,0xBE,0x34,0x64,0xA4,0xAA,0x7B,0x5D,0xD2,0xD8,0xCE,0x1B};	

const DWORD MAX_PUID_CCH 				= 33;
const DWORD MIN_PUID_CCH 				= 16;

//-----------------------------------------------------------------------------
// CANIDHasher::CANIDHasher()
//
// Constructor.
//-----------------------------------------------------------------------------
CANIDHasher::CANIDHasher()
{
	m_hCryptProv = NULL;
	m_hKeyHMAC = NULL;
}

//-----------------------------------------------------------------------------
// CANIDHasher::~CANIDHasher()
//
// Destructor.
//-----------------------------------------------------------------------------
CANIDHasher::~CANIDHasher()
{
	// Release the handle to the session key.
	if ( m_hKeyHMAC )
	{
		CryptDestroyKey( m_hKeyHMAC );
		m_hKeyHMAC = NULL;
	}

	// Release the handle to the cryptographic service provider.
	if ( m_hCryptProv )
	{
		CryptReleaseContext( m_hCryptProv, 0 );
		m_hCryptProv = NULL;
	}

}


//-----------------------------------------------------------------------------
// CANIDHasher::Initialize()
//
// Initializes the hash objects and the hash key.
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::Initialize(PCWSTR *ppwszErrAPI)
{
	HRESULT hr = S_OK;
	HCRYPTHASH 	hHashMD5 = NULL;

	// Check for double init.
	if ( m_hCryptProv )
	{
		hr = E_UNEXPECTED;
		goto Exit;
	}

	if ( ppwszErrAPI )
	{
		*ppwszErrAPI = NULL;
	}

	// Acquire a cryptographic provider context handle.
	if ( !CryptAcquireContext( &m_hCryptProv,NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptAcquireContext");
		goto Exit;			
	}

	// Create an MD5 hash object.
	if ( !CryptCreateHash( m_hCryptProv, s_HashAlgId, 0, 0, &hHashMD5 ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptCreateHash");
		goto Exit;
	}

	// Hash in the key data.
	if ( !CryptHashData( hHashMD5, s_rgbKey, sizeof(s_rgbKey), 0) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptHashData");
		goto Exit;
	}

	// Derive a session key from the hash object.  
	if ( !CryptDeriveKey( m_hCryptProv, CALG_RC2, hHashMD5, 0, &m_hKeyHMAC ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptDeriveKey");
		goto Exit;
	}

Exit:
	// Destroy the hash object.
	if ( hHashMD5 )
	{
		CryptDestroyHash( hHashMD5 );
		hHashMD5 = NULL;
	}
	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::HashData()
//
// Encrypts the binary buffer into a binary hash buffer using the preset encryption key.
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::HashData( 
	const BYTE* pbText, 
	DWORD cbText, 
	BYTE* pbHashValue, 
	DWORD* pcbHashValue 
)
{
	HRESULT hr = E_UNEXPECTED;

	HCRYPTHASH  hHashHMAC = NULL;
	HMAC_INFO 	hmacInfo = {0};
	
	// We have to recreate the HMAC object everytime though the key is constant since there is no way of resetting the HMAC object.
	if ( !CryptCreateHash( m_hCryptProv, CALG_HMAC, m_hKeyHMAC, 0, &hHashHMAC ) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Set the HMAC underlying hash function to MD5.
	hmacInfo.HashAlgid = s_HashAlgId;
	if ( !CryptSetHashParam( hHashHMAC, HP_HMAC_INFO, (BYTE*)&hmacInfo, 0 ) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Hash the data.
	if ( !CryptHashData( hHashHMAC, pbText, cbText, 0) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Get the hash value.
	if ( !CryptGetHashParam( hHashHMAC, HP_HASHVAL, pbHashValue,pcbHashValue, 0) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Sanity check that the data has been written properly.
	if ( s_HashAlgHashLength != *pcbHashValue )
	{
		hr = E_UNEXPECTED;
		goto Exit;
	}

	hr = S_OK;

Exit:
	// Destroy the hash object.
	if ( hHashHMAC )
	{
		CryptDestroyHash( hHashHMAC );
	}

	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::UpdateANONCookie()
//
// Generates an ANID from a PUID and implements the logic that determines 
// when the ANON cookie should be re-written.  
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::UpdateANONCookie(
		PANID_COOKIE pOldCookie,
		PWSTR pwszPUID,
		DWORD cchPUID,
		PANID_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
)
{
	HRESULT hr = S_OK;
	USHORT usWrites=0;
	DATE dtNow = 0;
	BOOL fNewANIDReady = FALSE;

	if ( !pwszPUID ||cchPUID < MIN_PUID_CCH || cchPUID > MAX_PUID_CCH ||
		!pdtExpire || !peCWT ||!pNewCookie ||!pNewCookie->pszExpiration ||
		!pNewCookie->pszANID || !pNewCookie->pszWrites )
	{
		return E_INVALIDARG;	
	}

	*peCWT = eCWTNoWrite;

	if ( pOldCookie )
	{
		// Examine the old cookie to decide whether we need to update it
		USHORT usEValue=0;
		
		// Parse E and W 
		if (!HexStringToUShortA( pOldCookie->pszExpiration,
								pOldCookie->cbExpiration,
								&usEValue ) ||
		     !HexStringToUShortA( pOldCookie->pszWrites,
		     						pOldCookie->cbWrites,
		     						&usWrites ) )
		{
			// Invalid E or W
			*peCWT = eCWTOverWrite;	
		}
		else
		{
			// Generate the ANID to do comparison
			hr = HashPUIDToANID( pwszPUID, 
								cchPUID, 
								pNewCookie->pszANID,
								pNewCookie->cbANID);
			if ( FAILED(hr))
			{
				goto Exit;
			}

			fNewANIDReady = TRUE;
			// Exclude the NULL terminator from the size
			pNewCookie->cbANID = ANID_CCH - 1;

			// Compare the old and new ANID
			if ( !pOldCookie->pszANID || pOldCookie->cbANID != ANID_CCH - 1 
				|| memcmp( pOldCookie->pszANID, pNewCookie->pszANID, ANID_CCH - 1 ) != 0 )
			{
				*peCWT = eCWTOverWrite;	
			}
			else
			{
				// Check whether we need to refresh the expiration date
				GetCurrentTimeAsDATE( &dtNow );
				if ( m_cookieExp.NeedRefresh( dtNow, usEValue) )
				{
					*peCWT = eCWTRefreshWrite;
				}
			}

		}
		
	}
	else
	{
		// No old cookie
		*peCWT = eCWTFirstTimeWrite;
	}

	// Update fields in pNewCookie
	if ( *peCWT != eCWTNoWrite )
	{
		// Increment write count
		if ( *peCWT != eCWTRefreshWrite )
		{
			if ( usWrites < USHRT_MAX )
			{
				usWrites ++;
			}
		}

		// Write the cookie expiration date
		GetCurrentTimeAsDATE( &dtNow );
		*pdtExpire =  m_cookieExp.GetExpireDate(dtNow);

		hr = CreateNewCookie( pNewCookie,
							fNewANIDReady? NULL : pwszPUID,
							cchPUID,
							usWrites,
							(DWORD)(*pdtExpire));
		
			
	}


Exit:
	return hr;
		
}

//-----------------------------------------------------------------------------
// CANIDHasher::CreateNewCookie()
//
// Generate elements for the new cookie
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::CreateNewCookie(
	PANID_COOKIE pNewCookie,
	PWSTR pwszPUID,
	DWORD cchPUID,
	USHORT usWrites,
	DWORD dwExpire)
{
	HRESULT hr = S_OK;
		
	if ( pwszPUID )
	{
		// Generate the ANID 
		hr = HashPUIDToANID( pwszPUID, 
							cchPUID, 
							pNewCookie->pszANID,
							pNewCookie->cbANID);
		if ( FAILED(hr))
		{
			goto Exit;
		}

		// Exclude the NULL terminator from the size
		pNewCookie->cbANID = ANID_CCH - 1;

	}

	// Write to pszWrites in pNewCookie
	if (!UShortToHexStringA( usWrites,
							pNewCookie->pszWrites,
							&pNewCookie->cbWrites))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}

	// Write to pszExpiration in pNewCookie
	if (!UShortToHexStringA( m_cookieExp.GetETagValue(dwExpire),
							pNewCookie->pszExpiration,
							&pNewCookie->cbExpiration))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}
		
Exit:
	return hr;

}


//-----------------------------------------------------------------------------
// CANIDHasher::HashPUIDToANID()
//
// Generate an ANID from a PUID
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::HashPUIDToANID( 
	PWSTR 	pwszPUID, 
	DWORD 	cchPUID, 
	PSTR 	pszANID, 
	DWORD 	cchANID
)
{
	WCHAR wszPUID[MAX_PUID_CCH];
	BYTE bHashValue[ s_HashAlgHashLength];
	DWORD cbHashValue = sizeof(bHashValue);
	DWORD cchANIDString = cchANID;
	HRESULT hr = E_UNEXPECTED;

	if ( !pwszPUID || !pszANID ||
		cchPUID < MIN_PUID_CCH || cchPUID > MAX_PUID_CCH )
	{
		return E_INVALIDARG;
	}	
		
	if ( cchANIDString < ANID_CCH )
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}

	if (!m_hCryptProv || !m_hKeyHMAC)
	{
		return E_UNEXPECTED;
	}

	_wcsupr(pwszPUID);

	// Pad with NULL if necessary
	if ( cchPUID < MAX_PUID_CCH )
	{
		memcpy( wszPUID, pwszPUID, cchPUID * sizeof(WCHAR));
		memset( &wszPUID[cchPUID], 0, (MAX_PUID_CCH-cchPUID) * sizeof(WCHAR));
		pwszPUID = wszPUID;
	}
	else
	{
		// Make sure it's NULL terminated
		pwszPUID[cchPUID-1] = 0;
	}

	hr = HashData( (BYTE*)pwszPUID, MAX_PUID_CCH * sizeof(WCHAR),
					bHashValue, &cbHashValue );

	if ( SUCCEEDED(hr))
	{
		// Convert this to an ANID.
		memset(&bHashValue[s_HashAlgHashLength-sizeof(ANID_LSB)], ANID_LSB, sizeof(ANID_LSB));
		
		// Encode the hash so that we can henceforth treat it as a string.
		hr = HexEncode( bHashValue, cbHashValue, pszANID, (unsigned int *)&cchANID )? S_OK: E_UNEXPECTED;

		if ( SUCCEEDED(hr))
		{
			// Null terminate the buffer
			if(cchANIDString > cchANID)	// Make sure we are not writing into the end of the buffer.
			{
				pszANID[cchANID] = '\0';
			}
			else
			{
				hr = E_UNEXPECTED;	// Shouldn't happen. Buffer size checked at the begining.
			}
		}
		
	}

	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::SetExpiration()
//
// Set ANID cookie expiration interval and refresh interval 
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays
)
{
	m_cookieExp.SetExpiration( cLifespanDays, cRefreshIntervalDays );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\Expiration.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			Expiration.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		The class to handle cookie expiration
//
// History:		09/18/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#include "stdafx.h"

const SYSTEMTIME  JAN_2004_SYSTEMTIME	= { 2004,1,4,1,0,0,0,0};

//-----------------------------------------------------------------------------
// CCookieExpiration::CCookieExpiration()
//
// Constructor.
//-----------------------------------------------------------------------------
CCookieExpiration::CCookieExpiration()
{
	m_cExpiration = DEFAULT_EXPIRATION;
	m_cRefresh = DEFAULT_REFRESH;

	DATE dt;
	int iRet = SystemTimeToVariantTime((LPSYSTEMTIME )&JAN_2004_SYSTEMTIME, &dt);
	m_dwDaysToJan2004 = iRet?(DWORD)dt : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\makefile.inc ===
!INCLUDE $(_NTTREE)\private\fixes\make\passmake.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\NAPUtil.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPUtil.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Utility functions for NAP library
//
// History:		09/16/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#include "stdafx.h"

static const char chNibbleLookup[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

//-----------------------------------------------------------------------------
// HexStringToUShort
//
// Convert a UNICODE hex string into USHORT
//-----------------------------------------------------------------------------
BOOL HexStringToUShort(
	PCWSTR pwszString,
	DWORD cchString,
	USHORT *pusNumber)
{
	USHORT usNumber = 0;

	if ( !pwszString || !pusNumber || !cchString  || cchString > 4 )
	{
		return FALSE;
	}
	
	for( DWORD dw = 0; dw < cchString; ++dw, ++pwszString )
	{
		usNumber = (usNumber << 4) ;
		if( (*pwszString >= L'0') && (*pwszString <= L'9' ) )
		{
			usNumber += (*pwszString - L'0');
		}
		else if( (*pwszString >= L'a') && (*pwszString <= L'f'))
		{
			usNumber += (*pwszString - L'a') + 10;
		}
		else if( (*pwszString >= L'A') && (*pwszString <= L'F'))
		{
			usNumber += (*pwszString - L'A') + 10;
		}
		else 
		{
			return FALSE;
		}
	}

	*pusNumber = usNumber;

	return TRUE;
	
}

//-----------------------------------------------------------------------------
// HexStringToUShortA
//
// Convert an ANSI hex string into USHORT
//-----------------------------------------------------------------------------
BOOL HexStringToUShortA(
	PCSTR pszString,
	DWORD cchString,
	USHORT *pusNumber)
{
	USHORT usNumber = 0;

	if ( !pszString || !pusNumber || !cchString  || cchString > 4 )
	{
		return FALSE;
	}
	
	for( DWORD dw = 0; dw < cchString; ++dw, ++pszString )
	{
		usNumber = (usNumber << 4) ;
		if( (*pszString >=  '0') && (*pszString <=  '9' ) )
		{
			usNumber += (*pszString -  '0');
		}
		else if( (*pszString >=  'a') && (*pszString <=  'f'))
		{
			usNumber += (*pszString -  'a') + 10;
		}
		else if( (*pszString >=  'A') && (*pszString <=  'F'))
		{
			usNumber += (*pszString -  'A') + 10;
		}
		else 
		{
			return FALSE;
		}
	}

	*pusNumber = usNumber;

	return TRUE;
	
}

//-----------------------------------------------------------------------------
// UShortToHexStringA
//
// Convert a USHORT into an ANSI hex string
//-----------------------------------------------------------------------------
BOOL UShortToHexStringA(
	USHORT usNumber,
	PSTR pszBuffer,
	DWORD *pcbBuffer)
{

	LPBYTE pBuffer = (LPBYTE)&usNumber;
	DWORD  cch = 0, cbBuffer;
	int i = sizeof(USHORT) - 1;

	if ( !pszBuffer || !pcbBuffer || *pcbBuffer <= 2 )
	{
		return FALSE;
	}

	cbBuffer = *pcbBuffer;

	while (  i >=0 && cch < cbBuffer-1 )
	{
		BYTE hi = (pBuffer[i] & 0xf0) >> 4;
		BYTE lo = pBuffer[i] & 0xf;
		if ( hi || cch )
			pszBuffer[cch++] = chNibbleLookup[hi];
		if ( lo || cch )
			pszBuffer[cch++] = chNibbleLookup[lo];
		i--;
	}

	// the string buffer is not big enough
	if ( i >= 0 || cch >= cbBuffer )
	{
		return FALSE;
	}

	// Handle usNumber is 0
	if (cch == 0 )
	{
		pszBuffer[cch++] = '0';
	}
		
	// NULL terminate the string
	pszBuffer[cch] = 0;
	*pcbBuffer = cch;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\NAP.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:            NAP.cpp
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        The class to encrypt/decrypt NAP cookie
//
// History:     09/13/04 WenjunQ Created.
//-----------------------------------------------------------------------------

#ifdef BUILD_DEBUG
#pragma comment(lib,"Debug/ThirdPartyCookies.lib")
#else
#pragma comment(lib,"Retail/ThirdPartyCookies.lib")
#endif

#include "stdafx.h"
#include "../Headers/NAPFixedKey.h"
#include <OleDbErr.h>       // For DB_S_NORESULT


const DWORD ENCRYPTED_KEY_LEN       =  52;
const DWORD HEX_ENCODED_KEY_CCH     = 104;
const DWORD MAX_KEY_NUMBER          = 2;

const DWORD RC4_SALT_SIZE = 11;

const DWORD ENCRYPTED_DATA_LEN      = sizeof( NAP_DATA)+RC4_SALT_SIZE;

const DWORD NAP_DATA_FORMAT_VERSION     = 1;
const char NAP_VERSION_PREFIX[] = "1.";
const DWORD NAP_VERSION_PREFIX_LEN = sizeof(NAP_VERSION_PREFIX) - 1;

//-----------------------------------------------------------------------------
// CNAPEncrypt::CNAPEncrypt()
//
// Constructor.
//-----------------------------------------------------------------------------
CNAPEncrypt::CNAPEncrypt()
{
    m_hCryptProv = NULL;
    memset( &m_napKeys, 0, sizeof(NAP_KEYS) );

    memset( m_rgbRandom, 0, sizeof(m_rgbRandom) );
    m_lCounter = 0;

    m_hKeyFixed = NULL;

    m_cbEncodedData = Base64EncodeGetRequiredLength(ENCRYPTED_DATA_LEN);
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::~CNAPEncrypt()
//
// Destructor.
//-----------------------------------------------------------------------------
CNAPEncrypt::~CNAPEncrypt()
{
    DestroyNAPKeys();

    if (m_hKeyFixed != NULL)
    {
        CryptDestroyKey(m_hKeyFixed);
        m_hKeyFixed = NULL;
    }

    if (m_hCryptProv != NULL)
    {
        CryptReleaseContext(m_hCryptProv, 0);
        m_hCryptProv = NULL;
    }
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::Initialize()
//
// Initialize the object, and optionally intialize the encryption key(s)
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::Initialize(
        PCWSTR pwszKeys,
        PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    HCRYPTHASH  hHashMD5 = NULL;

    if ( m_hCryptProv )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if ( ppwszErrAPI )
    {
        *ppwszErrAPI = NULL;
    }

    // Acquire a cryptographic provider context handle.
    if ( !CryptAcquireContext( &m_hCryptProv,NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptAcquireContext");
        goto Exit;
    }

    // Initialize the salt random values
    if (!CryptGenRandom(m_hCryptProv, sizeof(m_rgbRandom), m_rgbRandom))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptGenRandom");
        goto Exit;
    }

    if (!CryptGenRandom(m_hCryptProv, sizeof(m_lCounter), (BYTE*)&m_lCounter))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptGenRandom");
        goto Exit;
    }

    // Create an MD5 hash object.
    if ( !CryptCreateHash( m_hCryptProv, CALG_MD5, 0, 0, &hHashMD5 ) )
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptCreateHash");
        goto Exit;
    }

    // Hash NAP_FIXED_KEY byte array
    if ( !CryptHashData( hHashMD5, NAP_FIXED_KEY, sizeof(NAP_FIXED_KEY), 0 ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptHashData");
        goto Exit;
    }

    // Derive the fixed 3DES key from the hash
    if( !CryptDeriveKey( m_hCryptProv, CALG_3DES, hHashMD5, CRYPT_EXPORTABLE | 0x00C00000, &m_hKeyFixed ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptDeriveKey");
        goto Exit;
    }

    // If pwsKeys is not NULL, intialize the encryption key(s)
    if ( pwszKeys )
    {
        NAP_KEYS napKeys;

        hr = ParseKeys(  pwszKeys, &napKeys, ppwszErrAPI );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

        hr = SetKeys( &napKeys );
    }


Exit:

    if (hHashMD5 != NULL)
        CryptDestroyHash( hHashMD5 );

    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseKeys()
//
// Take key string in format of ver1=key1&ver2=key2, decrypt the keys and
// create the key handles.
//
// pwszKeys is expected to be NULL terminated
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ParseKeys(
    PCWSTR pwszKeys,
    PNAP_KEYS pnapKeys,
    PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    USHORT rgusVer[MAX_KEY_NUMBER] = { 0, 0 };
    PWSTR rgpwszKey[MAX_KEY_NUMBER] = {NULL, NULL};
//  USHORT usVerTemp;
//  PWSTR pwszTemp;
    int iKeys;
    int iKeyCurrent=1, iKeyPrevious=0;

    if ( !pwszKeys || !pnapKeys )
    {
        return E_INVALIDARG;
    }

    // Parse the key string and get the result in rgusVer and rgpwszKey
    iKeys = ParseKeyString(pwszKeys,MAX_KEY_NUMBER,rgusVer,rgpwszKey);
    if ( iKeys <= 0 || rgusVer[0] == rgusVer[1] )
    {
        return E_INVALIDARG;
    }

    // Initialize the output param
    memset( pnapKeys, 0, sizeof(NAP_KEYS) );
    if ( ppwszErrAPI )
    {
        *ppwszErrAPI = NULL;
    }

    // Pick the high version key to be the current one
    if ( rgusVer[0] > rgusVer[1] )
    {
        iKeyCurrent = 0;
        iKeyPrevious = 1;
    }

    // Import the current key
    pnapKeys->usKeyVersion = rgusVer[iKeyCurrent];
    hr = ImportOneKey(rgpwszKey[iKeyCurrent], &pnapKeys->hKey, ppwszErrAPI );
    if ( FAILED(hr) )
    {
        goto Exit;
    }

    // Import the previous key, which doesn't have to exist
    if ( rgusVer[iKeyPrevious] )
    {
        pnapKeys->usPrevKeyVersion = rgusVer[iKeyPrevious];
        hr = ImportOneKey(rgpwszKey[iKeyPrevious], &pnapKeys->hPrevKey, ppwszErrAPI );
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }


Exit:
    if ( FAILED(hr) )
    {
        if ( pnapKeys->hKey != NULL )
        {
            CryptDestroyKey(pnapKeys->hKey);
            pnapKeys->hKey = NULL;
        }

        if ( pnapKeys->hPrevKey != NULL )
        {
            CryptDestroyKey(pnapKeys->hPrevKey);
            pnapKeys->hPrevKey = NULL;
        }
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseKeyString()
//
// Parse key string in format of ver1=key1&ver2=key2, write the parse result to
// rgusVer and rgpwszKey, return the number of keys found.
//
// pwszKeys is expected to be NULL terminated
//-----------------------------------------------------------------------------
int CNAPEncrypt::ParseKeyString(
        PCWSTR pwszKeys,
        DWORD cMaxKeys,
        USHORT *rgusVer,
        PWSTR   *rgpwszKey
)
{
    DWORD i = 0;
    PWSTR pwszCur = (PWSTR)pwszKeys, pwszVer = (PWSTR)pwszKeys;

    if ( !pwszKeys || !rgusVer || !rgpwszKey )
    {
        return -1;
    }

    while (  i < cMaxKeys )
    {
        // Look for seperator between version and key
        while ( *pwszCur && *pwszCur != L'=' && pwszCur < pwszVer + 4 )
        {
            pwszCur ++;
        }

        // We have reached the end of the string or advanced 4 characters
        // without finding '='. It's unexpected.
        if ( *pwszCur != L'=' )
        {
            return -1;
        }

        // Convert version string to USHORT.
        // Version number 0 is invalid.
        if ( !HexStringToUShort( pwszVer,
                                pwszCur - pwszVer,
                                &rgusVer[i] )
            ||rgusVer[i] == 0 )
        {
            return -1;
        }

        // Let rgpwszKey[i] points to the key
        rgpwszKey[i] = ++pwszCur;

        // Look for seperator between keys.
        while ( *pwszCur && *pwszCur != L'&' &&
            pwszCur < rgpwszKey[i] + HEX_ENCODED_KEY_CCH )
        {
            pwszCur ++;
        }

        // Verify hex encoded key length
        if (pwszCur-rgpwszKey[i] != HEX_ENCODED_KEY_CCH
            || ( *pwszCur && *pwszCur != L'&' ) )
        {
            return -1;
        }

        i ++;
        if ( *pwszCur )
        {
            // Move on to the next key.
            pwszVer = ++pwszCur;
        }
        else
        {
            // We have reached the end of the string, break.
            break;
        }
    }

    return i;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ImportOneKey()
//
// Get a NAP encryption key string, hex decode, decrypt using the fixed key, and
// create the key handle
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ImportOneKey(
        PWSTR       pwszKey,
        HCRYPTKEY   *phKey,
        PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    BYTE rgbKey[ENCRYPTED_KEY_LEN];
    DWORD cbKey = ENCRYPTED_KEY_LEN;
//  HCRYPTKEY   hKeyFixed = NULL;

    if ( !pwszKey || !phKey )
    {
        return E_INVALIDARG;
    }

    if (!m_hCryptProv )
    {
        return E_UNEXPECTED;
    }

    // First convert the key to binay
    if ( !HexDecode(pwszKey, HEX_ENCODED_KEY_CCH, rgbKey, ( unsigned int *)&cbKey) )
    {
        return E_INVALIDARG;
    }

    // Create the key handle
    if (!CryptImportKey(m_hCryptProv, rgbKey, cbKey, m_hKeyFixed, 0, phKey ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptImportKey");
        goto Exit;
    }


Exit:
    // Clear out the memory for the encrypted key
    memset( rgbKey, 0, sizeof(rgbKey) );

    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::SetExpiration()
//
// Set NAP cookie expiration interval and refresh interval
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::SetExpiration(
        USHORT cLifespanDays,
        USHORT cRefreshIntervalDays
)
{
    m_cookieExp.SetExpiration( cLifespanDays, cRefreshIntervalDays );

    return S_OK;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::DecryptNAPCookie()
//
// Decrypt a NAP cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::DecryptNAPCookie(
        PNAP_COOKIE pCookie,
        PNAP_DATA pData
)
{
//  HRESULT hr = S_OK;
    USHORT usFormatVer, usKeyVer;


    if ( !pCookie || !pData )
    {
        return E_INVALIDARG;
    }

    // The version string is in wrong format, return S_FALSE
    if ( !ParseVersionString (  pCookie->pszVersion,
                            pCookie->cbVersion,
                            &usFormatVer,
                            &usKeyVer ))
    {
        return S_FALSE;
    }

    // If the keys haven't been set, return DB_S_NORESULT
    if (!m_napKeys.hKey)
    {
        return DB_S_NORESULT;
    }

    return DecryptNAPData(  pCookie->pszProfile,
                        pCookie->cbProfile,
                        usKeyVer,
                        pData );


}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseVersionString()
//
// Parse the version string in x.y format ( x being format version, y being key version )
//-----------------------------------------------------------------------------
BOOL CNAPEncrypt::ParseVersionString(
        PSTR        pszVer,
        DWORD       cbVer,
        USHORT*     pusFormatVer,
        USHORT*     pusKeyVer
)
{
    PSTR pszCur = pszVer;
    PSTR pszEnd;

    if ( !pszVer || !cbVer || !pusFormatVer || !pusKeyVer )
    {
        return FALSE;
    }

    pszEnd = pszVer + cbVer;

    // Look for '.' in version string
    while ( *pszCur != '.'  && pszCur < pszEnd )
    {
        pszCur ++;
    }

    // We have reached the end of the string without
    // finding '.', which is unexpected.
    if ( pszCur == pszEnd )
    {
        return FALSE;
    }

    // convert format version to USHORT
    if (!HexStringToUShortA( pszVer,
                            pszCur - pszVer,
                            pusFormatVer)
        || *pusFormatVer == 0 )
    {
        return FALSE;
    }

    // convert key version to USHORT
    pszCur ++;
    if (!HexStringToUShortA( pszCur,
                            pszEnd - pszCur,
                            pusKeyVer)
        || *pusKeyVer == 0 )
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::SetKeys()
//
// Provide the decryption keys to the object, and destroy the old keys
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::SetKeys(PNAP_KEYS pnapKeys)
{
    if ( !pnapKeys )
    {
        return E_INVALIDARG;
    }

    DestroyNAPKeys();
    memcpy( &m_napKeys, pnapKeys, sizeof(NAP_KEYS) );

    return S_OK;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::DecryptNAPData()
//
// Decrypt a NAP data string
//
// Return codes:
// S_OK - The cookie is successfully decrypted
// S_FALSE -The cookie could not be decrypted because the cookie was invalid.
// Error HRESULT - Any failure not caused by a bad cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::DecryptNAPData(
        PSTR    pszProfile,
        DWORD   cbProfile,
        USHORT  usKeyVer,
        PNAP_DATA pData
)
{
    HRESULT hr = S_OK;
    HCRYPTKEY   hKeyLocal = NULL;
    HCRYPTKEY   hKeyMaster = NULL;
    BYTE        rgbData[ENCRYPTED_DATA_LEN];
    DWORD       cbData = sizeof(rgbData);

    // We will proceed if the data size longer than expected. (This is
    // to handle the forward compatibility if we append new fields
    // to NAP_DATA in future. ) But we return S_FALSE if the data size
    // is too short.
    if (  cbProfile < m_cbEncodedData )
    {
        return S_FALSE;
    }

    // Pick the key to use
    if ( usKeyVer == m_napKeys.usKeyVersion )
    {
        hKeyMaster = m_napKeys.hKey;
    }
    else if (  usKeyVer == m_napKeys.usPrevKeyVersion )
    {
        hKeyMaster = m_napKeys.hPrevKey;
    }
    else
    {
        // We don't have the version of key to decrypt data
        return S_FALSE;
    }

    // Decode the profile data
    if (!Base64Decode(  pszProfile, m_cbEncodedData,
                        rgbData, (int*)&cbData) ||
        cbData != ENCRYPTED_DATA_LEN )
    {
        return S_FALSE;
    }

    // Duplicate the master key
    if (!CryptDuplicateKey(hKeyMaster, NULL, 0, &hKeyLocal) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Assign the salt to the key
    if (!CryptSetKeyParam(hKeyLocal, KP_SALT, rgbData, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // Decrypt the data
    if (!CryptDecrypt( hKeyLocal, 0, TRUE, 0, rgbData, &cbData ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if ( hr == NTE_BAD_DATA )
        {
            hr = S_FALSE;
        }
        goto Exit;
    }

    // Copy the data to the output buffer
    memcpy( pData, rgbData+RC4_SALT_SIZE, sizeof(NAP_DATA)  );


Exit:

    if ( hKeyLocal )
    {
        CryptDestroyKey(hKeyLocal);
        hKeyLocal = NULL;
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::EncryptNAPData()
//
// Encrypt NAP data using the current key
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::EncryptNAPData(
        PNAP_DATA pData,
        PSTR    pszProfile,
        DWORD   *pcbProfile
)
{
    HRESULT hr = S_OK;
    HCRYPTKEY   hKeyLocal = NULL;
    BYTE        rgbBuffer[ENCRYPTED_DATA_LEN];
    DWORD       cbData = ENCRYPTED_DATA_LEN;
    static BYTE     rgbSaltBlob[RC4_SALT_SIZE];
    LONG        lCounter;

    if ( !pData || !pszProfile )
    {
        return E_INVALIDARG;
    }

    if ( *pcbProfile <= m_cbEncodedData )
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    // If the keys haven't been set, return E_FAIL
    if ( !m_napKeys.hKey )
    {
        return E_UNEXPECTED;
    }

    // Duplicate the master key
    if (!CryptDuplicateKey(m_napKeys.hKey, NULL, 0, &hKeyLocal) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lCounter = InterlockedIncrement(&m_lCounter);
    // Call CryptGenRandom for the higher 7 bytes of the salt
    // every 2^28  requests
    if (  (lCounter & 0xfffffff) == 0 )
    {
        if (!CryptGenRandom(m_hCryptProv, sizeof(m_rgbRandom), m_rgbRandom))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    memcpy(rgbSaltBlob, m_rgbRandom, sizeof(m_rgbRandom));
    memcpy(rgbSaltBlob+sizeof(m_rgbRandom), &lCounter, sizeof(lCounter));


    // Assign the salt to the key
    if (!CryptSetKeyParam(hKeyLocal, KP_SALT, rgbSaltBlob, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // Copy memory since CryptEncrypt works in place.
    memcpy( rgbBuffer+RC4_SALT_SIZE, pData, sizeof(NAP_DATA));

    // The padding size is the same as the salt size.
    memset(rgbBuffer, 0, RC4_SALT_SIZE);

    // Encrypt the data
    if (!CryptEncrypt(hKeyLocal, NULL, TRUE, 0, rgbBuffer, &cbData, sizeof(rgbBuffer)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Copy the salt into the buffer
    memcpy(rgbBuffer, rgbSaltBlob, RC4_SALT_SIZE);

    //Base64 encode the data
    if (!Base64Encode( rgbBuffer, cbData, pszProfile, (int*)pcbProfile)
        ||*pcbProfile != m_cbEncodedData )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // NULL terminate the buffer
    pszProfile[m_cbEncodedData] = 0;

Exit:
    if ( hKeyLocal )
    {
        CryptDestroyKey(hKeyLocal);
        hKeyLocal = NULL;
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ProcessOldCookie()
//
// Called by UpdateNAPCookie to process the old cookie
// On return if *peCW is set to eCWTOverWrite, it could be the following cases:
// 1. Any cookie element is invalid.
// 2. The key version is neither current version nor current version + 1.
// 3. The key version is current, however we fail to decrypt the data.
//
// If *peCWT is eCWTNoWrite and *pfCurrentVer is TRUE, the caller still needs to
// compare the old and new binary data blobs to decide whether to overwrite the
// cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ProcessOldCookie(
    PNAP_COOKIE pOldCookie,
    PNAP_DATA pOldData,
    eCookieWriteType *peCWT,
    BOOL    *pfCurrentVer,
    USHORT  *pusEValue,
    USHORT  *pusWrites
)
{
    // Initialize to S_FALSE to indicate that we haven't decrypted pOldCookie
    // into pOldData
    HRESULT hr = S_FALSE;
    USHORT usFormatVer=0, usKeyVer=0;

    *peCWT =  eCWTNoWrite;
    *pfCurrentVer = FALSE;
    *pusEValue = 0;
    *pusWrites = 0;

    // Parse the version string.
    if ( !ParseVersionString (  pOldCookie->pszVersion,
                            pOldCookie->cbVersion,
                            &usFormatVer,
                            &usKeyVer ))
    {
        // Invalid version string
        *peCWT = eCWTOverWrite;
        goto Exit;
    }


    // Parse E and W
    if (!HexStringToUShortA( pOldCookie->pszExpiration,
                            pOldCookie->cbExpiration,
                            pusEValue ) ||
         !HexStringToUShortA( pOldCookie->pszWrites,
                                pOldCookie->cbWrites,
                                pusWrites ) )
    {
        // Invalid E or W
        *peCWT = eCWTOverWrite;
        goto Exit;
    }

    // Different logic based on the version numbers
    // For future format versions, we don't overwrite but still
    // try to decrypt.
    if ( usFormatVer == NAP_DATA_FORMAT_VERSION )
    {
        if ( usKeyVer == m_napKeys.usKeyVersion )
        {
            *pfCurrentVer = TRUE;
        }
        else if ( usKeyVer == m_napKeys.usPrevKeyVersion )
        {
            // If the key version is our previous version, we still
            // want to do DecryptNAPData below.
            *peCWT = eCWTOverWrite;
        }
        else
        {
            // We don't overwrite current key version + 1
            if ( usKeyVer != m_napKeys.usKeyVersion + 1 )
            {
                *peCWT = eCWTOverWrite;
            }
            goto Exit;
        }

    }

    // Decrypt the old data
    if (  pOldData )
    {
        hr = DecryptNAPData(  pOldCookie->pszProfile,
                            pOldCookie->cbProfile,
                            usKeyVer,
                            pOldData );

        if ( hr != S_OK && usFormatVer == NAP_DATA_FORMAT_VERSION )
        {
            *peCWT = eCWTOverWrite;
            goto Exit;
        }
    }


Exit:
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::CreateVersionString()
//
// Create a string for V element in the NAP cookie
//-----------------------------------------------------------------------------
BOOL CNAPEncrypt::CreateVersionString(
        PSTR        pszVer,
        DWORD*      pcbVer
)
{
    if ( pszVer && *pcbVer > NAP_VERSION_PREFIX_LEN )
    {
        memcpy ( pszVer, NAP_VERSION_PREFIX, NAP_VERSION_PREFIX_LEN );

        DWORD cbRet = *pcbVer - NAP_VERSION_PREFIX_LEN;

        if ( UShortToHexStringA(
                m_napKeys.usKeyVersion,
                pszVer + NAP_VERSION_PREFIX_LEN,
                &cbRet))
        {
            *pcbVer = NAP_VERSION_PREFIX_LEN + cbRet;
            return TRUE;
        }

    }

    return FALSE;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::UpdateNAPCookie()
//
// Perform the encryption operation on the NAP data and implement the logic that
// determines when the NAP cookie should be written.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::UpdateNAPCookie(
        PNAP_COOKIE pOldCookie,
        PNAP_DATA pOldData,
        PNAP_DATA pNewData,
        PNAP_COOKIE pNewCookie,
        DATE *pdtExpire,
        eCookieWriteType *peCWT
)
{
    HRESULT hr = S_OK;
    BOOL fHasOldData = FALSE;
    USHORT usWrites=0;
    DATE dtNow = 0;

    if ( !pNewData || !pNewCookie || !pdtExpire || !peCWT ||
        !pNewCookie->pszExpiration || !pNewCookie->pszProfile ||
        !pNewCookie->pszVersion || !pNewCookie->pszWrites )
    {
        return E_INVALIDARG;
    }

    *peCWT = eCWTNoWrite;

    if ( pOldCookie )
    {
        BOOL fCurrentVer = FALSE;
        USHORT usEValue=0;
        NAP_DATA oldData;
        PNAP_DATA pOldDataLocal = pOldData;

        if (!pOldDataLocal)
        {
            pOldDataLocal = &oldData;
        }

        hr = ProcessOldCookie( pOldCookie, pOldDataLocal, peCWT,
                            &fCurrentVer, &usEValue, &usWrites);

        if ( hr == S_OK )
        {
            fHasOldData = TRUE;
        }

        // If the key version in the old cookie is current, we still need to compare the
        // binary data blob and check if the cookie needs refresh
        if ( *peCWT == eCWTNoWrite && fCurrentVer)
        {
            if ( memcmp( pOldDataLocal,  pNewData, sizeof(NAP_DATA)) != 0 )
            {
                *peCWT = eCWTOverWrite;
            }
            else
            {
                // Check whether we need to refresh the expiration date
                GetCurrentTimeAsDATE( &dtNow );
                if ( m_cookieExp.NeedRefresh( dtNow, usEValue) )
                {
                    *peCWT = eCWTRefreshWrite;
                }
            }
        }

    }
    else
    {
        // No old cookie
        *peCWT = eCWTFirstTimeWrite;
    }

    // Update fields in pNewCookie
    if ( *peCWT != eCWTNoWrite )
    {
        // increment write count
        if ( *peCWT != eCWTRefreshWrite )
        {
            if ( usWrites < USHRT_MAX )
            {
                usWrites ++;
            }
        }

        // Write the cookie expiration date
        GetCurrentTimeAsDATE( &dtNow );
        *pdtExpire =  m_cookieExp.GetExpireDate(dtNow);

        // Create the new cookie elements
        hr = CreateNewCookie( pNewCookie,
                            pNewData,
                            usWrites,
                            (DWORD)(*pdtExpire));
        if ( FAILED(hr))
        {
            goto Exit;
        }

    }


Exit:
    if ( hr == S_OK )
    {
        if ( pOldData && !fHasOldData )
            hr = S_FALSE;
    }
    return hr;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::CreateNewCookie()
//
// Generate elements for the new cookie
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::CreateNewCookie(
        PNAP_COOKIE pNewCookie,
        PNAP_DATA pNewData,
        USHORT usWrites,
        DWORD dwExpire)
{
    HRESULT hr = S_OK;
//  int cchRet;

    // Write to pszProfile in pNewCookie
    hr = EncryptNAPData(    pNewData,
                        pNewCookie->pszProfile,
                        &pNewCookie->cbProfile );
    if ( FAILED(hr) )

    {
        goto Exit;
    }

    // Write to pszWrites in pNewCookie
    if (!UShortToHexStringA( usWrites,
                            pNewCookie->pszWrites,
                            &pNewCookie->cbWrites))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // Write to pszExpiration in pNewCookie
    if (!UShortToHexStringA( m_cookieExp.GetETagValue(dwExpire),
                            pNewCookie->pszExpiration,
                            &pNewCookie->cbExpiration))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //Write to pszVersion in pNewCookie
    if (!CreateVersionString(pNewCookie->pszVersion,
                        &pNewCookie->cbVersion))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\NAPUtil.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPUtil.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Utility functions for NAP library
//
// History:		09/16/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

BOOL HexStringToUShort(
	PCWSTR pwszString,
	DWORD cchString,
	USHORT *pusNumber);

BOOL HexStringToUShortA(
	PCSTR pszString,
	DWORD cchString,
	USHORT *pusNumber);

BOOL UShortToHexStringA(
	USHORT usNumber,
	PSTR pszBuffer,
	DWORD *pcbBuffer);

inline void GetCurrentTimeAsDATE( DATE *pdtDate )
{
	// The check is an optimization so we don't do this twice.
	if ( *pdtDate == 0 )
	{
		SYSTEMTIME st;
		GetSystemTime(&st); 
		SystemTimeToVariantTime(&st, pdtDate);
	}
}

inline HRESULT HandleCryptoError( PCWSTR* ppwszErr, PCWSTR pwszAPI )
{
	if ( ppwszErr )
	{
		*ppwszErr = pwszAPI;
	}

	return HRESULT_FROM_WIN32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAP\NAP\Source\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif     // Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <wincrypt.h>
#include <oleauto.h>

#include <limits.h>
#include "../Headers/hex.h"
#define UTILITY_DECLSPEC
#include "../Headers/UrlSafeBase64.h"
#include "NAPUtil.h"
#include "../Headers/NAP.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\anidconst.h ===
//-----------------------------------------------------------------------------
// Microsoft User Services and Revenue Technologies
//
// File:			ANIDConst.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Comments: 		Definition of the constants for ANID feature
//
// History:			09/22/04 	WenjunQ
//-----------------------------------------------------------------------------
#pragma once

// ANID constants
const int ANID_LSB		= 0xFFFFFFFF;			// the last 4 bytes denote an ANID. 	
const WCHAR k_wszANID_LSB[] = L"FFFFFFFF";	// the unicode version of the ANID_LSB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAPDllInteropTest\NAPDllTest\Program.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;

namespace NAPDllTest
{
    class Program
    {
        // C#:
        [DllImport("NAP.dll", EntryPoint="ConvertPUIDToANID",CallingConvention=CallingConvention.Cdecl)]
        public static extern int ConvertPUIDToANID([MarshalAs(UnmanagedType.BStr)] string pwszPUID, // [in]
                                                   UInt32 PUIDchCount, // [in]
                                                   StringBuilder pszANID, // [out]
                                                   UInt32 ANIDchCount);

        static void Main(string[] args)
        {
            Console.WriteLine("Testing NAP.dll...");
            StringBuilder tempANID = new StringBuilder(200);
            long hexNum = 2600292954997745;//2600292954993870;// 0x0003000081e1f95c;
            ConvertPUIDToANID(String.Format ("{0:x16}", hexNum), 16, tempANID, 200);
            //ConvertPUIDToANID("testPUID1234567890", 18, tempANID, 200);
            Console.WriteLine("ANID: {0}", tempANID);

            hexNum = 2600292954993871;// 0x0003000081e1f95c;
            ConvertPUIDToANID(String.Format("{0:x16}", hexNum), 16, tempANID, 200);
            //ConvertPUIDToANID("testPUID1234567890", 18, tempANID, 200);
            Console.WriteLine("ANID: {0}", tempANID);

            hexNum = 2600292954993872;// 0x0003000081e1f95c;
            ConvertPUIDToANID(String.Format("{0:x16}", hexNum), 16, tempANID, 200);
            //ConvertPUIDToANID("testPUID1234567890", 18, tempANID, 200);
            Console.WriteLine("ANID: {0}", tempANID);

            //ConvertPUIDToANID("0003000081e1f95c", 16, tempANID, 200);
            ConvertPUIDToANID("00000000F00DCAFE", 16, tempANID, 200);
            //ConvertPUIDToANID("testPUID1234567890", 18, tempANID, 200);
            Console.WriteLine("ANID: {0}", tempANID);
            Console.ReadKey();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\Expiration.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			Expiration.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		The class to handle cookie expiration
//
// History:		09/18/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#include "stdafx.h"

const SYSTEMTIME  JAN_2004_SYSTEMTIME	= { 2004,1,4,1,0,0,0,0};

//-----------------------------------------------------------------------------
// CCookieExpiration::CCookieExpiration()
//
// Constructor.
//-----------------------------------------------------------------------------
CCookieExpiration::CCookieExpiration()
{
	m_cExpiration = DEFAULT_EXPIRATION;
	m_cRefresh = DEFAULT_REFRESH;

	DATE dt;
	int iRet = SystemTimeToVariantTime((LPSYSTEMTIME )&JAN_2004_SYSTEMTIME, &dt);
	m_dwDaysToJan2004 = iRet?(DWORD)dt : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\ANIDHasher.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			ANIDHasher.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Class to hash a PUID or a 16 byte data stream to an ANID. 
//
// History:		05/19/04   Debbief   Created.
//				09/21/04   WenjunQ Moved to NAP library.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "anidconst.h"

// This is a byte key that will be used by the HMAC algorithm to convert the PUID to an ANID. This key has been generated by CryptGenRandom API 
const BYTE CANIDHasher::s_rgbKey[s_KeyLength] = {0x58,0x41,0x0F,0x3B,0x3F,0xBE,0x34,0x64,0xA4,0xAA,0x7B,0x5D,0xD2,0xD8,0xCE,0x1B};	

const DWORD MAX_PUID_CCH 				= 33;
const DWORD MIN_PUID_CCH 				= 16;

//-----------------------------------------------------------------------------
// CANIDHasher::CANIDHasher()
//
// Constructor.
//-----------------------------------------------------------------------------
CANIDHasher::CANIDHasher()
{
	m_hCryptProv = NULL;
	m_hKeyHMAC = NULL;
}

//-----------------------------------------------------------------------------
// CANIDHasher::~CANIDHasher()
//
// Destructor.
//-----------------------------------------------------------------------------
CANIDHasher::~CANIDHasher()
{
	// Release the handle to the session key.
	if ( m_hKeyHMAC )
	{
		CryptDestroyKey( m_hKeyHMAC );
		m_hKeyHMAC = NULL;
	}

	// Release the handle to the cryptographic service provider.
	if ( m_hCryptProv )
	{
		CryptReleaseContext( m_hCryptProv, 0 );
		m_hCryptProv = NULL;
	}

}


//-----------------------------------------------------------------------------
// CANIDHasher::Initialize()
//
// Initializes the hash objects and the hash key.
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::Initialize(PCWSTR *ppwszErrAPI)
{
	HRESULT hr = S_OK;
	HCRYPTHASH 	hHashMD5 = NULL;

	// Check for double init.
	if ( m_hCryptProv )
	{
		hr = E_UNEXPECTED;
		goto Exit;
	}

	if ( ppwszErrAPI )
	{
		*ppwszErrAPI = NULL;
	}

	// Acquire a cryptographic provider context handle.
	if ( !CryptAcquireContext( &m_hCryptProv,NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptAcquireContext");
		goto Exit;			
	}

	// Create an MD5 hash object.
	if ( !CryptCreateHash( m_hCryptProv, s_HashAlgId, 0, 0, &hHashMD5 ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptCreateHash");
		goto Exit;
	}

	// Hash in the key data.
	if ( !CryptHashData( hHashMD5, s_rgbKey, sizeof(s_rgbKey), 0) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptHashData");
		goto Exit;
	}

	// Derive a session key from the hash object.  
	if ( !CryptDeriveKey( m_hCryptProv, CALG_RC2, hHashMD5, 0, &m_hKeyHMAC ) )
	{
		hr = HandleCryptoError(ppwszErrAPI, L"CryptDeriveKey");
		goto Exit;
	}

Exit:
	// Destroy the hash object.
	if ( hHashMD5 )
	{
		CryptDestroyHash( hHashMD5 );
		hHashMD5 = NULL;
	}
	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::HashData()
//
// Encrypts the binary buffer into a binary hash buffer using the preset encryption key.
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::HashData( 
	const BYTE* pbText, 
	DWORD cbText, 
	BYTE* pbHashValue, 
	DWORD* pcbHashValue 
)
{
	HRESULT hr = E_UNEXPECTED;

	HCRYPTHASH  hHashHMAC = NULL;
	HMAC_INFO 	hmacInfo = {0};
	
	// We have to recreate the HMAC object everytime though the key is constant since there is no way of resetting the HMAC object.
	if ( !CryptCreateHash( m_hCryptProv, CALG_HMAC, m_hKeyHMAC, 0, &hHashHMAC ) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Set the HMAC underlying hash function to MD5.
	hmacInfo.HashAlgid = s_HashAlgId;
	if ( !CryptSetHashParam( hHashHMAC, HP_HMAC_INFO, (BYTE*)&hmacInfo, 0 ) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Hash the data.
	if ( !CryptHashData( hHashHMAC, pbText, cbText, 0) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Get the hash value.
	if ( !CryptGetHashParam( hHashHMAC, HP_HASHVAL, pbHashValue,pcbHashValue, 0) )
	{
		hr =  HRESULT_FROM_WIN32( ::GetLastError() );
		goto Exit;
	}

	// Sanity check that the data has been written properly.
	if ( s_HashAlgHashLength != *pcbHashValue )
	{
		hr = E_UNEXPECTED;
		goto Exit;
	}

	hr = S_OK;

Exit:
	// Destroy the hash object.
	if ( hHashHMAC )
	{
		CryptDestroyHash( hHashHMAC );
	}

	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::UpdateANONCookie()
//
// Generates an ANID from a PUID and implements the logic that determines 
// when the ANON cookie should be re-written.  
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::UpdateANONCookie(
		PANID_COOKIE pOldCookie,
		PWSTR pwszPUID,
		DWORD cchPUID,
		PANID_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
)
{
	HRESULT hr = S_OK;
	USHORT usWrites=0;
	DATE dtNow = 0;
	BOOL fNewANIDReady = FALSE;

	if ( !pwszPUID ||cchPUID < MIN_PUID_CCH || cchPUID > MAX_PUID_CCH ||
		!pdtExpire || !peCWT ||!pNewCookie ||!pNewCookie->pszExpiration ||
		!pNewCookie->pszANID || !pNewCookie->pszWrites )
	{
		return E_INVALIDARG;	
	}

	*peCWT = eCWTNoWrite;

	if ( pOldCookie )
	{
		// Examine the old cookie to decide whether we need to update it
		USHORT usEValue=0;
		
		// Parse E and W 
		if (!HexStringToUShortA( pOldCookie->pszExpiration,
								pOldCookie->cbExpiration,
								&usEValue ) ||
		     !HexStringToUShortA( pOldCookie->pszWrites,
		     						pOldCookie->cbWrites,
		     						&usWrites ) )
		{
			// Invalid E or W
			*peCWT = eCWTOverWrite;	
		}
		else
		{
			// Generate the ANID to do comparison
			hr = HashPUIDToANID( pwszPUID, 
								cchPUID, 
								pNewCookie->pszANID,
								pNewCookie->cbANID);
			if ( FAILED(hr))
			{
				goto Exit;
			}

			fNewANIDReady = TRUE;
			// Exclude the NULL terminator from the size
			pNewCookie->cbANID = ANID_CCH - 1;

			// Compare the old and new ANID
			if ( !pOldCookie->pszANID || pOldCookie->cbANID != ANID_CCH - 1 
				|| memcmp( pOldCookie->pszANID, pNewCookie->pszANID, ANID_CCH - 1 ) != 0 )
			{
				*peCWT = eCWTOverWrite;	
			}
			else
			{
				// Check whether we need to refresh the expiration date
				GetCurrentTimeAsDATE( &dtNow );
				if ( m_cookieExp.NeedRefresh( dtNow, usEValue) )
				{
					*peCWT = eCWTRefreshWrite;
				}
			}

		}
		
	}
	else
	{
		// No old cookie
		*peCWT = eCWTFirstTimeWrite;
	}

	// Update fields in pNewCookie
	if ( *peCWT != eCWTNoWrite )
	{
		// Increment write count
		if ( *peCWT != eCWTRefreshWrite )
		{
			if ( usWrites < USHRT_MAX )
			{
				usWrites ++;
			}
		}

		// Write the cookie expiration date
		GetCurrentTimeAsDATE( &dtNow );
		*pdtExpire =  m_cookieExp.GetExpireDate(dtNow);

		hr = CreateNewCookie( pNewCookie,
							fNewANIDReady? NULL : pwszPUID,
							cchPUID,
							usWrites,
							(DWORD)(*pdtExpire));
		
			
	}


Exit:
	return hr;
		
}

//-----------------------------------------------------------------------------
// CANIDHasher::CreateNewCookie()
//
// Generate elements for the new cookie
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::CreateNewCookie(
	PANID_COOKIE pNewCookie,
	PWSTR pwszPUID,
	DWORD cchPUID,
	USHORT usWrites,
	DWORD dwExpire)
{
	HRESULT hr = S_OK;
		
	if ( pwszPUID )
	{
		// Generate the ANID 
		hr = HashPUIDToANID( pwszPUID, 
							cchPUID, 
							pNewCookie->pszANID,
							pNewCookie->cbANID);
		if ( FAILED(hr))
		{
			goto Exit;
		}

		// Exclude the NULL terminator from the size
		pNewCookie->cbANID = ANID_CCH - 1;

	}

	// Write to pszWrites in pNewCookie
	if (!UShortToHexStringA( usWrites,
							pNewCookie->pszWrites,
							&pNewCookie->cbWrites))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}

	// Write to pszExpiration in pNewCookie
	if (!UShortToHexStringA( m_cookieExp.GetETagValue(dwExpire),
							pNewCookie->pszExpiration,
							&pNewCookie->cbExpiration))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		goto Exit;
	}
		
Exit:
	return hr;

}


//-----------------------------------------------------------------------------
// CANIDHasher::HashPUIDToANID()
//
// Generate an ANID from a PUID
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::HashPUIDToANID( 
	PWSTR 	pwszPUID, 
	DWORD 	cchPUID, 
	PSTR 	pszANID, 
	DWORD 	cchANID
)
{
	WCHAR wszPUID[MAX_PUID_CCH];
	BYTE bHashValue[ s_HashAlgHashLength];
	DWORD cbHashValue = sizeof(bHashValue);
	DWORD cchANIDString = cchANID;
	HRESULT hr = E_UNEXPECTED;

	if ( !pwszPUID || !pszANID ||
		cchPUID < MIN_PUID_CCH || cchPUID > MAX_PUID_CCH )
	{
		return E_INVALIDARG;
	}	
		
	if ( cchANIDString < ANID_CCH )
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}

	if (!m_hCryptProv || !m_hKeyHMAC)
	{
		return E_UNEXPECTED;
	}

	_wcsupr(pwszPUID);

	// Pad with NULL if necessary
	if ( cchPUID < MAX_PUID_CCH )
	{
		memcpy( wszPUID, pwszPUID, cchPUID * sizeof(WCHAR));
		memset( &wszPUID[cchPUID], 0, (MAX_PUID_CCH-cchPUID) * sizeof(WCHAR));
		pwszPUID = wszPUID;
	}
	else
	{
		// Make sure it's NULL terminated
		pwszPUID[cchPUID-1] = 0;
	}

	hr = HashData( (BYTE*)pwszPUID, MAX_PUID_CCH * sizeof(WCHAR),
					bHashValue, &cbHashValue );

	if ( SUCCEEDED(hr))
	{
		// Convert this to an ANID.
		memset(&bHashValue[s_HashAlgHashLength-sizeof(ANID_LSB)], ANID_LSB, sizeof(ANID_LSB));
		
		// Encode the hash so that we can henceforth treat it as a string.
		hr = HexEncode( bHashValue, cbHashValue, pszANID, (unsigned int *)&cchANID )? S_OK: E_UNEXPECTED;

		if ( SUCCEEDED(hr))
		{
			// Null terminate the buffer
			if(cchANIDString > cchANID)	// Make sure we are not writing into the end of the buffer.
			{
				pszANID[cchANID] = '\0';
			}
			else
			{
				hr = E_UNEXPECTED;	// Shouldn't happen. Buffer size checked at the begining.
			}
		}
		
	}

	return hr;

}

//-----------------------------------------------------------------------------
// CANIDHasher::SetExpiration()
//
// Set ANID cookie expiration interval and refresh interval 
//-----------------------------------------------------------------------------
HRESULT CANIDHasher::SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays
)
{
	m_cookieExp.SetExpiration( cLifespanDays, cRefreshIntervalDays );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\Hex.h ===
//------------------------------------------------------------------------------
//
// Microsoft User Services and Revenue Technologies
// Copyright (C) Microsoft Corporation
//
// File: 		Hex.h
//
// Contents:	Support for encoding/decoding binary with hex encoding.
//
// History:		04/19/04	AlexPort	Created (based on ATL 7.0).
//										This was needed because of several bugs
//										in the ATL implementation.
//
//------------------------------------------------------------------------------


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline unsigned int HexEncodeGetRequiredLength( unsigned int nSrcLen )
{
	return 2 * nSrcLen;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline unsigned int HexDecodeGetRequiredLength( unsigned int nSrcLen )
{
	return ( nSrcLen / 2 );
}

//-----------------------------------------------------------------------------
// Get the decimal value of a hexadecimal character.
//-----------------------------------------------------------------------------
inline char GetHexValue( char ch )
{
	if (ch >= '0' && ch <= '9')
		return (ch - '0');
	if (ch >= 'A' && ch <= 'F')
		return (ch - 'A' + 10);
	if (ch >= 'a' && ch <= 'f')
		return (ch - 'a' + 10);
	return -1;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline bool HexEncode( const BYTE *pbSrc, unsigned int cbSrc, char* szDest, unsigned int *pcchDest )
{
	static const char s_chHexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
										  'A', 'B', 'C', 'D', 'E', 'F'};

	const BYTE* pbEndSrc = pbSrc + cbSrc;

	if ( !pbSrc || !szDest || !pcchDest || (*pcchDest < HexEncodeGetRequiredLength(cbSrc)) )
	{
		return FALSE;
	}

	while ( pbSrc < pbEndSrc )
	{
		BYTE ch = *pbSrc++;
		*szDest++ = s_chHexChars[(ch >> 4) & 0x0F];
		*szDest++ = s_chHexChars[ch & 0x0F];
	}

	*pcchDest = HexEncodeGetRequiredLength(cbSrc);

	return TRUE;
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline BOOL HexDecode( const char* pSrc, unsigned int cchSrc, LPBYTE pbDest, unsigned int* pcbDest )
{
	const char* pEndSrc = pSrc + cchSrc;

	if ( !pSrc || !pbDest || !pcbDest || (cchSrc%2 != 0) || (*pcbDest < HexDecodeGetRequiredLength(cchSrc)) )
	{
		return FALSE;
	}

	while ( pSrc < pEndSrc )
	{
		char ch1 = GetHexValue( *pSrc++ );
		char ch2 = GetHexValue( *pSrc++ );

		if ((ch1 < 0) || (ch2 < 0))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
	}

	*pcbDest = HexDecodeGetRequiredLength(cchSrc);

	return TRUE;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
inline BOOL HexDecode( PCWSTR pSrc, unsigned int cchSrc, LPBYTE pbDest, unsigned int* pcbDest )
{
	PCWSTR pEndSrc = pSrc + cchSrc;

	if ( !pSrc || !pbDest || !pcbDest || (cchSrc%2 != 0) || (*pcbDest < HexDecodeGetRequiredLength(cchSrc)) )
	{
		return FALSE;
	}

	while ( pSrc < pEndSrc )
	{
		if ((*pSrc > 0x7f) || (*pSrc < 0))
			return FALSE;
	
		char ch1 = GetHexValue( (CHAR)*pSrc++ );
		char ch2 = GetHexValue( (CHAR)*pSrc++ );

		if ((ch1 < 0) || (ch2 < 0))
		{
			return FALSE;
		}
		*pbDest++ = (BYTE)(16*ch1+ch2);
	}

	*pcbDest = HexDecodeGetRequiredLength(cchSrc);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\NAPDllInteropTest\NAPDllTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NAPDllTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("NAPDllTest")]
[assembly: AssemblyCopyright("Copyright © MS 2007")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4daa5098-8940-4833-9258-23507823e75b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\ExternalCFunc.cpp ===
// ExternalCFunc.cpp
//
// Export C Function that converts PUID to ANID
// This is solely for the purpose of interop to C# code
//
// by Raphael Mun

#include "stdafx.h"

int ConvertPUIDToANID(PWSTR pwszPUID, // [in]
					  DWORD PUIDchCount, // [in]
					  PSTR pszANID, // [out]
					  DWORD ANIDchCount) // [in]
{
	CANIDHasher anidHasher;

	if (anidHasher.Initialize (NULL) != S_OK)
		return -1;

	if (anidHasher.HashPUIDToANID (pwszPUID, PUIDchCount, pszANID, ANIDchCount) != S_OK)
		return -1;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\NAPFixedKey.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPFixedKey.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		24 byte data generated by CryptGenRandom to derive the NAP fixed key.
//
// History:		09/15/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

extern const __declspec(selectany) BYTE NAP_FIXED_KEY[] = {
	0xba, 0xdb, 0x5c, 0xd5, 0x8c, 0x51, 0xb9, 0xd1, 0x11, 0xf9, 0x62, 0xe0,
	0xfd, 0x32, 0x15, 0x59, 0x03, 0x0b, 0x63, 0x92, 0x85, 0xb7, 0xfd, 0x79
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\NAP.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:            NAP.cpp
//
// Copyright:       Copyright (c) Microsoft Corporation
//
// Contents:        The class to encrypt/decrypt NAP cookie
//
// History:     09/13/04 WenjunQ Created.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "NAPFixedKey.h"
#include <OleDbErr.h>       // For DB_S_NORESULT


const DWORD ENCRYPTED_KEY_LEN       =  52;
const DWORD HEX_ENCODED_KEY_CCH     = 104;
const DWORD MAX_KEY_NUMBER          = 2;

const DWORD RC4_SALT_SIZE = 11;

const DWORD ENCRYPTED_DATA_LEN      = sizeof( NAP_DATA)+RC4_SALT_SIZE;

const DWORD NAP_DATA_FORMAT_VERSION     = 1;
const char NAP_VERSION_PREFIX[] = "1.";
const DWORD NAP_VERSION_PREFIX_LEN = sizeof(NAP_VERSION_PREFIX) - 1;

//-----------------------------------------------------------------------------
// CNAPEncrypt::CNAPEncrypt()
//
// Constructor.
//-----------------------------------------------------------------------------
CNAPEncrypt::CNAPEncrypt()
{
    m_hCryptProv = NULL;
    memset( &m_napKeys, 0, sizeof(NAP_KEYS) );

    memset( m_rgbRandom, 0, sizeof(m_rgbRandom) );
    m_lCounter = 0;

    m_hKeyFixed = NULL;

    m_cbEncodedData = Base64EncodeGetRequiredLength(ENCRYPTED_DATA_LEN);
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::~CNAPEncrypt()
//
// Destructor.
//-----------------------------------------------------------------------------
CNAPEncrypt::~CNAPEncrypt()
{
    DestroyNAPKeys();

    if (m_hKeyFixed != NULL)
    {
        CryptDestroyKey(m_hKeyFixed);
        m_hKeyFixed = NULL;
    }

    if (m_hCryptProv != NULL)
    {
        CryptReleaseContext(m_hCryptProv, 0);
        m_hCryptProv = NULL;
    }
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::Initialize()
//
// Initialize the object, and optionally intialize the encryption key(s)
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::Initialize(
        PCWSTR pwszKeys,
        PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    HCRYPTHASH  hHashMD5 = NULL;

    if ( m_hCryptProv )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    if ( ppwszErrAPI )
    {
        *ppwszErrAPI = NULL;
    }

    // Acquire a cryptographic provider context handle.
    if ( !CryptAcquireContext( &m_hCryptProv,NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptAcquireContext");
        goto Exit;
    }

    // Initialize the salt random values
    if (!CryptGenRandom(m_hCryptProv, sizeof(m_rgbRandom), m_rgbRandom))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptGenRandom");
        goto Exit;
    }

    if (!CryptGenRandom(m_hCryptProv, sizeof(m_lCounter), (BYTE*)&m_lCounter))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptGenRandom");
        goto Exit;
    }

    // Create an MD5 hash object.
    if ( !CryptCreateHash( m_hCryptProv, CALG_MD5, 0, 0, &hHashMD5 ) )
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptCreateHash");
        goto Exit;
    }

    // Hash NAP_FIXED_KEY byte array
    if ( !CryptHashData( hHashMD5, NAP_FIXED_KEY, sizeof(NAP_FIXED_KEY), 0 ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptHashData");
        goto Exit;
    }

    // Derive the fixed 3DES key from the hash
    if( !CryptDeriveKey( m_hCryptProv, CALG_3DES, hHashMD5, CRYPT_EXPORTABLE | 0x00C00000, &m_hKeyFixed ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptDeriveKey");
        goto Exit;
    }

    // If pwsKeys is not NULL, intialize the encryption key(s)
    if ( pwszKeys )
    {
        NAP_KEYS napKeys;

        hr = ParseKeys(  pwszKeys, &napKeys, ppwszErrAPI );
        if ( FAILED(hr) )
        {
            goto Exit;
        }

        hr = SetKeys( &napKeys );
    }


Exit:

    if (hHashMD5 != NULL)
        CryptDestroyHash( hHashMD5 );

    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseKeys()
//
// Take key string in format of ver1=key1&ver2=key2, decrypt the keys and
// create the key handles.
//
// pwszKeys is expected to be NULL terminated
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ParseKeys(
    PCWSTR pwszKeys,
    PNAP_KEYS pnapKeys,
    PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    USHORT rgusVer[MAX_KEY_NUMBER] = { 0, 0 };
    PWSTR rgpwszKey[MAX_KEY_NUMBER] = {NULL, NULL};
//  USHORT usVerTemp;
//  PWSTR pwszTemp;
    int iKeys;
    int iKeyCurrent=1, iKeyPrevious=0;

    if ( !pwszKeys || !pnapKeys )
    {
        return E_INVALIDARG;
    }

    // Parse the key string and get the result in rgusVer and rgpwszKey
    iKeys = ParseKeyString(pwszKeys,MAX_KEY_NUMBER,rgusVer,rgpwszKey);
    if ( iKeys <= 0 || rgusVer[0] == rgusVer[1] )
    {
        return E_INVALIDARG;
    }

    // Initialize the output param
    memset( pnapKeys, 0, sizeof(NAP_KEYS) );
    if ( ppwszErrAPI )
    {
        *ppwszErrAPI = NULL;
    }

    // Pick the high version key to be the current one
    if ( rgusVer[0] > rgusVer[1] )
    {
        iKeyCurrent = 0;
        iKeyPrevious = 1;
    }

    // Import the current key
    pnapKeys->usKeyVersion = rgusVer[iKeyCurrent];
    hr = ImportOneKey(rgpwszKey[iKeyCurrent], &pnapKeys->hKey, ppwszErrAPI );
    if ( FAILED(hr) )
    {
        goto Exit;
    }

    // Import the previous key, which doesn't have to exist
    if ( rgusVer[iKeyPrevious] )
    {
        pnapKeys->usPrevKeyVersion = rgusVer[iKeyPrevious];
        hr = ImportOneKey(rgpwszKey[iKeyPrevious], &pnapKeys->hPrevKey, ppwszErrAPI );
        if ( FAILED(hr) )
        {
            goto Exit;
        }
    }


Exit:
    if ( FAILED(hr) )
    {
        if ( pnapKeys->hKey != NULL )
        {
            CryptDestroyKey(pnapKeys->hKey);
            pnapKeys->hKey = NULL;
        }

        if ( pnapKeys->hPrevKey != NULL )
        {
            CryptDestroyKey(pnapKeys->hPrevKey);
            pnapKeys->hPrevKey = NULL;
        }
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseKeyString()
//
// Parse key string in format of ver1=key1&ver2=key2, write the parse result to
// rgusVer and rgpwszKey, return the number of keys found.
//
// pwszKeys is expected to be NULL terminated
//-----------------------------------------------------------------------------
int CNAPEncrypt::ParseKeyString(
        PCWSTR pwszKeys,
        DWORD cMaxKeys,
        USHORT *rgusVer,
        PWSTR   *rgpwszKey
)
{
    DWORD i = 0;
    PWSTR pwszCur = (PWSTR)pwszKeys, pwszVer = (PWSTR)pwszKeys;

    if ( !pwszKeys || !rgusVer || !rgpwszKey )
    {
        return -1;
    }

    while (  i < cMaxKeys )
    {
        // Look for seperator between version and key
        while ( *pwszCur && *pwszCur != L'=' && pwszCur < pwszVer + 4 )
        {
            pwszCur ++;
        }

        // We have reached the end of the string or advanced 4 characters
        // without finding '='. It's unexpected.
        if ( *pwszCur != L'=' )
        {
            return -1;
        }

        // Convert version string to USHORT.
        // Version number 0 is invalid.
        if ( !HexStringToUShort( pwszVer,
                                pwszCur - pwszVer,
                                &rgusVer[i] )
            ||rgusVer[i] == 0 )
        {
            return -1;
        }

        // Let rgpwszKey[i] points to the key
        rgpwszKey[i] = ++pwszCur;

        // Look for seperator between keys.
        while ( *pwszCur && *pwszCur != L'&' &&
            pwszCur < rgpwszKey[i] + HEX_ENCODED_KEY_CCH )
        {
            pwszCur ++;
        }

        // Verify hex encoded key length
        if (pwszCur-rgpwszKey[i] != HEX_ENCODED_KEY_CCH
            || ( *pwszCur && *pwszCur != L'&' ) )
        {
            return -1;
        }

        i ++;
        if ( *pwszCur )
        {
            // Move on to the next key.
            pwszVer = ++pwszCur;
        }
        else
        {
            // We have reached the end of the string, break.
            break;
        }
    }

    return i;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ImportOneKey()
//
// Get a NAP encryption key string, hex decode, decrypt using the fixed key, and
// create the key handle
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ImportOneKey(
        PWSTR       pwszKey,
        HCRYPTKEY   *phKey,
        PCWSTR* ppwszErrAPI
)
{
    HRESULT hr = S_OK;
    BYTE rgbKey[ENCRYPTED_KEY_LEN];
    DWORD cbKey = ENCRYPTED_KEY_LEN;
//  HCRYPTKEY   hKeyFixed = NULL;

    if ( !pwszKey || !phKey )
    {
        return E_INVALIDARG;
    }

    if (!m_hCryptProv )
    {
        return E_UNEXPECTED;
    }

    // First convert the key to binay
    if ( !HexDecode(pwszKey, HEX_ENCODED_KEY_CCH, rgbKey, ( unsigned int *)&cbKey) )
    {
        return E_INVALIDARG;
    }

    // Create the key handle
    if (!CryptImportKey(m_hCryptProv, rgbKey, cbKey, m_hKeyFixed, 0, phKey ))
    {
        hr = HandleCryptoError(ppwszErrAPI, L"CryptImportKey");
        goto Exit;
    }


Exit:
    // Clear out the memory for the encrypted key
    memset( rgbKey, 0, sizeof(rgbKey) );

    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::SetExpiration()
//
// Set NAP cookie expiration interval and refresh interval
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::SetExpiration(
        USHORT cLifespanDays,
        USHORT cRefreshIntervalDays
)
{
    m_cookieExp.SetExpiration( cLifespanDays, cRefreshIntervalDays );

    return S_OK;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::DecryptNAPCookie()
//
// Decrypt a NAP cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::DecryptNAPCookie(
        PNAP_COOKIE pCookie,
        PNAP_DATA pData
)
{
//  HRESULT hr = S_OK;
    USHORT usFormatVer, usKeyVer;


    if ( !pCookie || !pData )
    {
        return E_INVALIDARG;
    }

    // The version string is in wrong format, return S_FALSE
    if ( !ParseVersionString (  pCookie->pszVersion,
                            pCookie->cbVersion,
                            &usFormatVer,
                            &usKeyVer ))
    {
        return S_FALSE;
    }

    // If the keys haven't been set, return DB_S_NORESULT
    if (!m_napKeys.hKey)
    {
        return DB_S_NORESULT;
    }

    return DecryptNAPData(  pCookie->pszProfile,
                        pCookie->cbProfile,
                        usKeyVer,
                        pData );


}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ParseVersionString()
//
// Parse the version string in x.y format ( x being format version, y being key version )
//-----------------------------------------------------------------------------
BOOL CNAPEncrypt::ParseVersionString(
        PSTR        pszVer,
        DWORD       cbVer,
        USHORT*     pusFormatVer,
        USHORT*     pusKeyVer
)
{
    PSTR pszCur = pszVer;
    PSTR pszEnd;

    if ( !pszVer || !cbVer || !pusFormatVer || !pusKeyVer )
    {
        return FALSE;
    }

    pszEnd = pszVer + cbVer;

    // Look for '.' in version string
    while ( *pszCur != '.'  && pszCur < pszEnd )
    {
        pszCur ++;
    }

    // We have reached the end of the string without
    // finding '.', which is unexpected.
    if ( pszCur == pszEnd )
    {
        return FALSE;
    }

    // convert format version to USHORT
    if (!HexStringToUShortA( pszVer,
                            pszCur - pszVer,
                            pusFormatVer)
        || *pusFormatVer == 0 )
    {
        return FALSE;
    }

    // convert key version to USHORT
    pszCur ++;
    if (!HexStringToUShortA( pszCur,
                            pszEnd - pszCur,
                            pusKeyVer)
        || *pusKeyVer == 0 )
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::SetKeys()
//
// Provide the decryption keys to the object, and destroy the old keys
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::SetKeys(PNAP_KEYS pnapKeys)
{
    if ( !pnapKeys )
    {
        return E_INVALIDARG;
    }

    DestroyNAPKeys();
    memcpy( &m_napKeys, pnapKeys, sizeof(NAP_KEYS) );

    return S_OK;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::DecryptNAPData()
//
// Decrypt a NAP data string
//
// Return codes:
// S_OK - The cookie is successfully decrypted
// S_FALSE -The cookie could not be decrypted because the cookie was invalid.
// Error HRESULT - Any failure not caused by a bad cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::DecryptNAPData(
        PSTR    pszProfile,
        DWORD   cbProfile,
        USHORT  usKeyVer,
        PNAP_DATA pData
)
{
    HRESULT hr = S_OK;
    HCRYPTKEY   hKeyLocal = NULL;
    HCRYPTKEY   hKeyMaster = NULL;
    BYTE        rgbData[ENCRYPTED_DATA_LEN];
    DWORD       cbData = sizeof(rgbData);

    // We will proceed if the data size longer than expected. (This is
    // to handle the forward compatibility if we append new fields
    // to NAP_DATA in future. ) But we return S_FALSE if the data size
    // is too short.
    if (  cbProfile < m_cbEncodedData )
    {
        return S_FALSE;
    }

    // Pick the key to use
    if ( usKeyVer == m_napKeys.usKeyVersion )
    {
        hKeyMaster = m_napKeys.hKey;
    }
    else if (  usKeyVer == m_napKeys.usPrevKeyVersion )
    {
        hKeyMaster = m_napKeys.hPrevKey;
    }
    else
    {
        // We don't have the version of key to decrypt data
        return S_FALSE;
    }

    // Decode the profile data
    if (!Base64Decode(  pszProfile, m_cbEncodedData,
                        rgbData, (int*)&cbData) ||
        cbData != ENCRYPTED_DATA_LEN )
    {
        return S_FALSE;
    }

    // Duplicate the master key
    if (!CryptDuplicateKey(hKeyMaster, NULL, 0, &hKeyLocal) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Assign the salt to the key
    if (!CryptSetKeyParam(hKeyLocal, KP_SALT, rgbData, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // Decrypt the data
    if (!CryptDecrypt( hKeyLocal, 0, TRUE, 0, rgbData, &cbData ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if ( hr == NTE_BAD_DATA )
        {
            hr = S_FALSE;
        }
        goto Exit;
    }

    // Copy the data to the output buffer
    memcpy( pData, rgbData+RC4_SALT_SIZE, sizeof(NAP_DATA)  );


Exit:

    if ( hKeyLocal )
    {
        CryptDestroyKey(hKeyLocal);
        hKeyLocal = NULL;
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::EncryptNAPData()
//
// Encrypt NAP data using the current key
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::EncryptNAPData(
        PNAP_DATA pData,
        PSTR    pszProfile,
        DWORD   *pcbProfile
)
{
    HRESULT hr = S_OK;
    HCRYPTKEY   hKeyLocal = NULL;
    BYTE        rgbBuffer[ENCRYPTED_DATA_LEN];
    DWORD       cbData = ENCRYPTED_DATA_LEN;
    static BYTE     rgbSaltBlob[RC4_SALT_SIZE];
    LONG        lCounter;

    if ( !pData || !pszProfile )
    {
        return E_INVALIDARG;
    }

    if ( *pcbProfile <= m_cbEncodedData )
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    // If the keys haven't been set, return E_FAIL
    if ( !m_napKeys.hKey )
    {
        return E_UNEXPECTED;
    }

    // Duplicate the master key
    if (!CryptDuplicateKey(m_napKeys.hKey, NULL, 0, &hKeyLocal) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lCounter = InterlockedIncrement(&m_lCounter);
    // Call CryptGenRandom for the higher 7 bytes of the salt
    // every 2^28  requests
    if (  (lCounter & 0xfffffff) == 0 )
    {
        if (!CryptGenRandom(m_hCryptProv, sizeof(m_rgbRandom), m_rgbRandom))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    memcpy(rgbSaltBlob, m_rgbRandom, sizeof(m_rgbRandom));
    memcpy(rgbSaltBlob+sizeof(m_rgbRandom), &lCounter, sizeof(lCounter));


    // Assign the salt to the key
    if (!CryptSetKeyParam(hKeyLocal, KP_SALT, rgbSaltBlob, 0))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // Copy memory since CryptEncrypt works in place.
    memcpy( rgbBuffer+RC4_SALT_SIZE, pData, sizeof(NAP_DATA));

    // The padding size is the same as the salt size.
    memset(rgbBuffer, 0, RC4_SALT_SIZE);

    // Encrypt the data
    if (!CryptEncrypt(hKeyLocal, NULL, TRUE, 0, rgbBuffer, &cbData, sizeof(rgbBuffer)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Copy the salt into the buffer
    memcpy(rgbBuffer, rgbSaltBlob, RC4_SALT_SIZE);

    //Base64 encode the data
    if (!Base64Encode( rgbBuffer, cbData, pszProfile, (int*)pcbProfile)
        ||*pcbProfile != m_cbEncodedData )
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // NULL terminate the buffer
    pszProfile[m_cbEncodedData] = 0;

Exit:
    if ( hKeyLocal )
    {
        CryptDestroyKey(hKeyLocal);
        hKeyLocal = NULL;
    }
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::ProcessOldCookie()
//
// Called by UpdateNAPCookie to process the old cookie
// On return if *peCW is set to eCWTOverWrite, it could be the following cases:
// 1. Any cookie element is invalid.
// 2. The key version is neither current version nor current version + 1.
// 3. The key version is current, however we fail to decrypt the data.
//
// If *peCWT is eCWTNoWrite and *pfCurrentVer is TRUE, the caller still needs to
// compare the old and new binary data blobs to decide whether to overwrite the
// cookie.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::ProcessOldCookie(
    PNAP_COOKIE pOldCookie,
    PNAP_DATA pOldData,
    eCookieWriteType *peCWT,
    BOOL    *pfCurrentVer,
    USHORT  *pusEValue,
    USHORT  *pusWrites
)
{
    // Initialize to S_FALSE to indicate that we haven't decrypted pOldCookie
    // into pOldData
    HRESULT hr = S_FALSE;
    USHORT usFormatVer=0, usKeyVer=0;

    *peCWT =  eCWTNoWrite;
    *pfCurrentVer = FALSE;
    *pusEValue = 0;
    *pusWrites = 0;

    // Parse the version string.
    if ( !ParseVersionString (  pOldCookie->pszVersion,
                            pOldCookie->cbVersion,
                            &usFormatVer,
                            &usKeyVer ))
    {
        // Invalid version string
        *peCWT = eCWTOverWrite;
        goto Exit;
    }


    // Parse E and W
    if (!HexStringToUShortA( pOldCookie->pszExpiration,
                            pOldCookie->cbExpiration,
                            pusEValue ) ||
         !HexStringToUShortA( pOldCookie->pszWrites,
                                pOldCookie->cbWrites,
                                pusWrites ) )
    {
        // Invalid E or W
        *peCWT = eCWTOverWrite;
        goto Exit;
    }

    // Different logic based on the version numbers
    // For future format versions, we don't overwrite but still
    // try to decrypt.
    if ( usFormatVer == NAP_DATA_FORMAT_VERSION )
    {
        if ( usKeyVer == m_napKeys.usKeyVersion )
        {
            *pfCurrentVer = TRUE;
        }
        else if ( usKeyVer == m_napKeys.usPrevKeyVersion )
        {
            // If the key version is our previous version, we still
            // want to do DecryptNAPData below.
            *peCWT = eCWTOverWrite;
        }
        else
        {
            // We don't overwrite current key version + 1
            if ( usKeyVer != m_napKeys.usKeyVersion + 1 )
            {
                *peCWT = eCWTOverWrite;
            }
            goto Exit;
        }

    }

    // Decrypt the old data
    if (  pOldData )
    {
        hr = DecryptNAPData(  pOldCookie->pszProfile,
                            pOldCookie->cbProfile,
                            usKeyVer,
                            pOldData );

        if ( hr != S_OK && usFormatVer == NAP_DATA_FORMAT_VERSION )
        {
            *peCWT = eCWTOverWrite;
            goto Exit;
        }
    }


Exit:
    return hr;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::CreateVersionString()
//
// Create a string for V element in the NAP cookie
//-----------------------------------------------------------------------------
BOOL CNAPEncrypt::CreateVersionString(
        PSTR        pszVer,
        DWORD*      pcbVer
)
{
    if ( pszVer && *pcbVer > NAP_VERSION_PREFIX_LEN )
    {
        memcpy ( pszVer, NAP_VERSION_PREFIX, NAP_VERSION_PREFIX_LEN );

        DWORD cbRet = *pcbVer - NAP_VERSION_PREFIX_LEN;

        if ( UShortToHexStringA(
                m_napKeys.usKeyVersion,
                pszVer + NAP_VERSION_PREFIX_LEN,
                &cbRet))
        {
            *pcbVer = NAP_VERSION_PREFIX_LEN + cbRet;
            return TRUE;
        }

    }

    return FALSE;

}

//-----------------------------------------------------------------------------
// CNAPEncrypt::UpdateNAPCookie()
//
// Perform the encryption operation on the NAP data and implement the logic that
// determines when the NAP cookie should be written.
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::UpdateNAPCookie(
        PNAP_COOKIE pOldCookie,
        PNAP_DATA pOldData,
        PNAP_DATA pNewData,
        PNAP_COOKIE pNewCookie,
        DATE *pdtExpire,
        eCookieWriteType *peCWT
)
{
    HRESULT hr = S_OK;
    BOOL fHasOldData = FALSE;
    USHORT usWrites=0;
    DATE dtNow = 0;

    if ( !pNewData || !pNewCookie || !pdtExpire || !peCWT ||
        !pNewCookie->pszExpiration || !pNewCookie->pszProfile ||
        !pNewCookie->pszVersion || !pNewCookie->pszWrites )
    {
        return E_INVALIDARG;
    }

    *peCWT = eCWTNoWrite;

    if ( pOldCookie )
    {
        BOOL fCurrentVer = FALSE;
        USHORT usEValue=0;
        NAP_DATA oldData;
        PNAP_DATA pOldDataLocal = pOldData;

        if (!pOldDataLocal)
        {
            pOldDataLocal = &oldData;
        }

        hr = ProcessOldCookie( pOldCookie, pOldDataLocal, peCWT,
                            &fCurrentVer, &usEValue, &usWrites);

        if ( hr == S_OK )
        {
            fHasOldData = TRUE;
        }

        // If the key version in the old cookie is current, we still need to compare the
        // binary data blob and check if the cookie needs refresh
        if ( *peCWT == eCWTNoWrite && fCurrentVer)
        {
            if ( memcmp( pOldDataLocal,  pNewData, sizeof(NAP_DATA)) != 0 )
            {
                *peCWT = eCWTOverWrite;
            }
            else
            {
                // Check whether we need to refresh the expiration date
                GetCurrentTimeAsDATE( &dtNow );
                if ( m_cookieExp.NeedRefresh( dtNow, usEValue) )
                {
                    *peCWT = eCWTRefreshWrite;
                }
            }
        }

    }
    else
    {
        // No old cookie
        *peCWT = eCWTFirstTimeWrite;
    }

    // Update fields in pNewCookie
    if ( *peCWT != eCWTNoWrite )
    {
        // increment write count
        if ( *peCWT != eCWTRefreshWrite )
        {
            if ( usWrites < USHRT_MAX )
            {
                usWrites ++;
            }
        }

        // Write the cookie expiration date
        GetCurrentTimeAsDATE( &dtNow );
        *pdtExpire =  m_cookieExp.GetExpireDate(dtNow);

        // Create the new cookie elements
        hr = CreateNewCookie( pNewCookie,
                            pNewData,
                            usWrites,
                            (DWORD)(*pdtExpire));
        if ( FAILED(hr))
        {
            goto Exit;
        }

    }


Exit:
    if ( hr == S_OK )
    {
        if ( pOldData && !fHasOldData )
            hr = S_FALSE;
    }
    return hr;
}

//-----------------------------------------------------------------------------
// CNAPEncrypt::CreateNewCookie()
//
// Generate elements for the new cookie
//-----------------------------------------------------------------------------
HRESULT CNAPEncrypt::CreateNewCookie(
        PNAP_COOKIE pNewCookie,
        PNAP_DATA pNewData,
        USHORT usWrites,
        DWORD dwExpire)
{
    HRESULT hr = S_OK;
//  int cchRet;

    // Write to pszProfile in pNewCookie
    hr = EncryptNAPData(    pNewData,
                        pNewCookie->pszProfile,
                        &pNewCookie->cbProfile );
    if ( FAILED(hr) )

    {
        goto Exit;
    }

    // Write to pszWrites in pNewCookie
    if (!UShortToHexStringA( usWrites,
                            pNewCookie->pszWrites,
                            &pNewCookie->cbWrites))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    // Write to pszExpiration in pNewCookie
    if (!UShortToHexStringA( m_cookieExp.GetETagValue(dwExpire),
                            pNewCookie->pszExpiration,
                            &pNewCookie->cbExpiration))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //Write to pszVersion in pNewCookie
    if (!CreateVersionString(pNewCookie->pszVersion,
                        &pNewCookie->cbVersion))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

Exit:
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\NAPUtil.cpp ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPUtil.cpp
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Utility functions for NAP library
//
// History:		09/16/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#include "stdafx.h"

static const char chNibbleLookup[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

//-----------------------------------------------------------------------------
// HexStringToUShort
//
// Convert a UNICODE hex string into USHORT
//-----------------------------------------------------------------------------
BOOL HexStringToUShort(
	PCWSTR pwszString,
	DWORD cchString,
	USHORT *pusNumber)
{
	USHORT usNumber = 0;

	if ( !pwszString || !pusNumber || !cchString  || cchString > 4 )
	{
		return FALSE;
	}
	
	for( DWORD dw = 0; dw < cchString; ++dw, ++pwszString )
	{
		usNumber = (usNumber << 4) ;
		if( (*pwszString >= L'0') && (*pwszString <= L'9' ) )
		{
			usNumber += (*pwszString - L'0');
		}
		else if( (*pwszString >= L'a') && (*pwszString <= L'f'))
		{
			usNumber += (*pwszString - L'a') + 10;
		}
		else if( (*pwszString >= L'A') && (*pwszString <= L'F'))
		{
			usNumber += (*pwszString - L'A') + 10;
		}
		else 
		{
			return FALSE;
		}
	}

	*pusNumber = usNumber;

	return TRUE;
	
}

//-----------------------------------------------------------------------------
// HexStringToUShortA
//
// Convert an ANSI hex string into USHORT
//-----------------------------------------------------------------------------
BOOL HexStringToUShortA(
	PCSTR pszString,
	DWORD cchString,
	USHORT *pusNumber)
{
	USHORT usNumber = 0;

	if ( !pszString || !pusNumber || !cchString  || cchString > 4 )
	{
		return FALSE;
	}
	
	for( DWORD dw = 0; dw < cchString; ++dw, ++pszString )
	{
		usNumber = (usNumber << 4) ;
		if( (*pszString >=  '0') && (*pszString <=  '9' ) )
		{
			usNumber += (*pszString -  '0');
		}
		else if( (*pszString >=  'a') && (*pszString <=  'f'))
		{
			usNumber += (*pszString -  'a') + 10;
		}
		else if( (*pszString >=  'A') && (*pszString <=  'F'))
		{
			usNumber += (*pszString -  'A') + 10;
		}
		else 
		{
			return FALSE;
		}
	}

	*pusNumber = usNumber;

	return TRUE;
	
}

//-----------------------------------------------------------------------------
// UShortToHexStringA
//
// Convert a USHORT into an ANSI hex string
//-----------------------------------------------------------------------------
BOOL UShortToHexStringA(
	USHORT usNumber,
	PSTR pszBuffer,
	DWORD *pcbBuffer)
{

	LPBYTE pBuffer = (LPBYTE)&usNumber;
	DWORD  cch = 0, cbBuffer;
	int i = sizeof(USHORT) - 1;

	if ( !pszBuffer || !pcbBuffer || *pcbBuffer <= 2 )
	{
		return FALSE;
	}

	cbBuffer = *pcbBuffer;

	while (  i >=0 && cch < cbBuffer-1 )
	{
		BYTE hi = (pBuffer[i] & 0xf0) >> 4;
		BYTE lo = pBuffer[i] & 0xf;
		if ( hi || cch )
			pszBuffer[cch++] = chNibbleLookup[hi];
		if ( lo || cch )
			pszBuffer[cch++] = chNibbleLookup[lo];
		i--;
	}

	// the string buffer is not big enough
	if ( i >= 0 || cch >= cbBuffer )
	{
		return FALSE;
	}

	// Handle usNumber is 0
	if (cch == 0 )
	{
		pszBuffer[cch++] = '0';
	}
		
	// NULL terminate the string
	pszBuffer[cch] = 0;
	*pcbBuffer = cch;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\NAPUtil.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAPUtil.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Utility functions for NAP library
//
// History:		09/16/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

BOOL HexStringToUShort(
	PCWSTR pwszString,
	DWORD cchString,
	USHORT *pusNumber);

BOOL HexStringToUShortA(
	PCSTR pszString,
	DWORD cchString,
	USHORT *pusNumber);

BOOL UShortToHexStringA(
	USHORT usNumber,
	PSTR pszBuffer,
	DWORD *pcbBuffer);

inline void GetCurrentTimeAsDATE( DATE *pdtDate )
{
	// The check is an optimization so we don't do this twice.
	if ( *pdtDate == 0 )
	{
		SYSTEMTIME st;
		GetSystemTime(&st); 
		SystemTimeToVariantTime(&st, pdtDate);
	}
}

inline HRESULT HandleCryptoError( PCWSTR* ppwszErr, PCWSTR pwszAPI )
{
	if ( ppwszErr )
	{
		*ppwszErr = pwszAPI;
	}

	return HRESULT_FROM_WIN32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\NAP.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			NAP.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		The class to encrypt/decrypt NAP cookie
//
// History:		09/13/04 WenjunQ Created.
//-----------------------------------------------------------------------------
#pragma once

// The maximum sizes for the NAP cookie elements.
// The sizes are number of characters in hex, including the NULL terminater.
const DWORD MAX_NAP_VERSION_CCH 		= 10;
const DWORD MAX_NAP_EXPIRATION_CCH	= 5;
const DWORD MAX_NAP_PROFILE_CCH		= 64;
const DWORD MAX_NAP_WRITES_CCH		= 5;

const USHORT DEFAULT_EXPIRATION 		= 135;
const USHORT DEFAULT_REFRESH			= 65;

// Profile data format for NAP cookie
#include <pshpack1.h>
typedef struct tagNAPData
{
	UINT	Region;
	CHAR	Country[2];
	USHORT	Language;
	UINT 	BirthDate;	// Number of days since 12/30/1899
	CHAR	Gender;		// M, F, or U
	CHAR	Occupation;
	CHAR	PostalCode[15];	// Pad with NULL if needed
} NAP_DATA, *PNAP_DATA;
#include <poppack.h>


// NAP cookie elements
// As in/out parameter( e.g. pNewCookie in UpdateNAPCookie()), 
// cbxxx should be the size of the corresponding pszxxx buffer. 
// As in parameter( e.g. pOldCookie in UpdateNAPCookie()),  
// cbxxx should be the actual data size in the corresponding pszxxx
// excluding the NULL terminater.
typedef struct tagNAPCookie
{
PSTR 	pszVersion;	// Pointer to the V element of the NAP cookie
DWORD	cbVersion;

PSTR 	pszExpiration; // Pointer to the E element of the NAP cookie
DWORD	cbExpiration;

PSTR 	pszProfile;	// Pointer to the C element of the NAP cookie
DWORD	cbProfile;

PSTR 	pszWrites;	// Pointer to the W element of the NAP cookie
DWORD 	cbWrites;

} NAP_COOKIE, *PNAP_COOKIE;


// Pair of NAP encryption keys
typedef struct tagNAPKeys
{
	USHORT  	usPrevKeyVersion;
	USHORT  	usKeyVersion;
	HCRYPTKEY	hPrevKey;
	HCRYPTKEY	hKey;
}NAP_KEYS, *PNAP_KEYS;


// Enum values to tell whether the cookie should be written 
// and the type of write.
typedef enum 
{
	eCWTNoWrite = 0,
	eCWTFirstTimeWrite,
	eCWTOverWrite,
	eCWTRefreshWrite
} eCookieWriteType;


//------------------------------------------------------------------------------
// CCookieExpiration
// 
// The class to handle cookie expiration and refresh,
// used by CNAPEncrypt and CANIDHasher.
//
class CCookieExpiration
{
public:
	CCookieExpiration() ;
	
//-----------------------------------------------------------------------------
// CCookieExpiration::SetExpiration()
//
// Set cookie expiration interval and refresh interval 
//-----------------------------------------------------------------------------
	inline void SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays)
	{
		m_cExpiration = cLifespanDays;
		m_cRefresh = cRefreshIntervalDays;
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::NeedRefresh()
//
// Given the current date and E tag value, returns whether the cookie should be refreshed.
//-----------------------------------------------------------------------------
	inline BOOL NeedRefresh(
		DATE dtNow,
		USHORT usEValue
	)
	{
		if ( m_cRefresh && (dtNow >= m_dwDaysToJan2004 + usEValue))
			return TRUE;

		return FALSE;
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::GetETagValue()
//
// Given the cookie expiration date, calculate the E tag value.
//-----------------------------------------------------------------------------
	inline USHORT GetETagValue(DWORD dwExpireDate)
	{
		return (USHORT)(dwExpireDate - m_cRefresh - m_dwDaysToJan2004 );
	};

//-----------------------------------------------------------------------------
// CCookieExpiration::GetExpireDate()
//
// Given the current date, calculate the cookie expiration date.
//-----------------------------------------------------------------------------
	inline DATE GetExpireDate(DATE dtNow)
	{
		return dtNow + m_cExpiration;
	};

private:
	USHORT		m_cExpiration;
	USHORT 		m_cRefresh;
	DWORD 		m_dwDaysToJan2004;
};


//------------------------------------------------------------------------------
// CNAPEncrypt
// 
// The class to encrypt/decrypt NAP cookie
//
class CNAPEncrypt
{
public:
	CNAPEncrypt();
	~CNAPEncrypt();

	HRESULT Initialize(
		PCWSTR pwszKeys,
		PCWSTR* ppwszErrAPI
	);
	
	HRESULT ParseKeys(
		PCWSTR pwszKeys,
		PNAP_KEYS pnapKeys,
		PCWSTR* ppwszErrAPI
	);

	HRESULT SetKeys(PNAP_KEYS pnapKeys);
		
	HRESULT SetExpiration(
		USHORT cLifespanDays, 
		USHORT cRefreshIntervalDays);

	HRESULT DecryptNAPCookie(
		PNAP_COOKIE pCookie,
		PNAP_DATA pData
	);

	// Note: Content of pOldCookie may be changed by the function
	HRESULT UpdateNAPCookie(
		PNAP_COOKIE pOldCookie,
		PNAP_DATA pOldData,
		PNAP_DATA pNewData,
		PNAP_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
	);
	
private:

	int ParseKeyString(
		PCWSTR pwszKeys,
		DWORD 	cMaxKeys,
		USHORT 	*rgusVer,
		PWSTR	*rgpwszKey
	);

	HRESULT ImportOneKey(
		PWSTR 		pwszKey,
		HCRYPTKEY	*phKey,
		PCWSTR* ppwszErrAPI
	);

	BOOL ParseVersionString(
		PSTR 		pszVer,
		DWORD		cbVer,
		USHORT*		pusFormatVer,
		USHORT*		pusKeyVer
	);

	BOOL CreateVersionString(
		PSTR 		pszVer,
		DWORD*		pcbVer
	);

	HRESULT CreateNewCookie( 
		PNAP_COOKIE pNewCookie,
		PNAP_DATA pNewData,
		USHORT usWrites,
		DWORD dwExpire);

//-----------------------------------------------------------------------------
// CNAPEncrypt::DestroyNAPKeys()
//
// Destroy the current and previous NAP keys
//-----------------------------------------------------------------------------
	inline void DestroyNAPKeys()
	{
		if (m_napKeys.hKey != NULL)
		{
			CryptDestroyKey(m_napKeys.hKey);
			m_napKeys.hKey = NULL;
		}

		if (m_napKeys.hPrevKey != NULL)
		{
			CryptDestroyKey(m_napKeys.hPrevKey);
			m_napKeys.hPrevKey = NULL;
		}
	}

	HRESULT DecryptNAPData( 
		PSTR 	pszProfile,
		DWORD	cbProfile,
		USHORT  usKeyVer,
		PNAP_DATA pData
	);

	HRESULT EncryptNAPData(
		PNAP_DATA pData,
		PSTR 	pszProfile,
		DWORD*	pcbProfile
	);

	HRESULT ProcessOldCookie(
		PNAP_COOKIE pOldCookie,
		PNAP_DATA pOldData,
		eCookieWriteType *peCWT,
		BOOL 	*pfCurrentVer,
		USHORT 	*pusEValue,
		USHORT *pusWrites
	);
			

	HCRYPTPROV	m_hCryptProv;
	NAP_KEYS 	m_napKeys;
	BYTE		m_rgbRandom[7];
	HCRYPTKEY	m_hKeyFixed;
	LONG		m_lCounter;		
	CCookieExpiration m_cookieExp;
	DWORD		m_cbEncodedData;
};


// The maximum sizes for the ANON cookie elements.
// The sizes are number of characters in hex, including the NULL terminater.
const DWORD ANID_CCH 					= 33;
const DWORD MAX_ANID_EXPIRATION_CCH	= 5;
const DWORD MAX_ANID_WRITES_CCH		= 5;

// ANON cookie elements
// As in/out parameter( e.g. pNewCookie in UpdateANONCookie()), 
// cbxxx should be the size of the corresponding pszxxx buffer. 
// As in parameter( e.g. pOldCookie in UpdateANONCookie()),  
// cbxxx should be the actual data size in the corresponding pszxxx
// excluding the NULL terminater.
typedef struct tagANIDCookie
{
PSTR 	pszExpiration; // Pointer to the E element of the ANON cookie
DWORD	cbExpiration;	

PSTR 	pszANID;	// Pointer to the ANID element of the ANON cookie
DWORD	cbANID;	

PSTR 	pszWrites;	// Pointer to the W element of the ANON cookie
DWORD 	cbWrites;

} ANID_COOKIE, *PANID_COOKIE;

//------------------------------------------------------------------------------
// CANIDHasher
//  
// The class to hash a PUID to an ANID. 
//
class CANIDHasher
{
public:

	CANIDHasher();
	~CANIDHasher();
	HRESULT Initialize(PCWSTR* ppwszErrAPI);

	// Note: Content of pwszPUID may be changed the function
	HRESULT UpdateANONCookie(
		PANID_COOKIE pOldCookie,
		PWSTR pwszPUID,
		DWORD cchPUID,
		PANID_COOKIE pNewCookie,
		DATE *pdtExpire,
		eCookieWriteType *peCWT
	);

	HRESULT SetExpiration(
			USHORT cLifespanDays, 
			USHORT cRefreshIntervalDays
	);

	HRESULT HashPUIDToANID( 
			PWSTR 	pwszPUID, 
			DWORD 	cchPUID, 
			PSTR 	pszANID, 
			DWORD 	cchANID
	);

private:

	HRESULT HashData( 
			const BYTE* pbText, 
			DWORD cbText, 
			BYTE* pbHashValue, 
			DWORD* pcbHashValue 
	);

	HRESULT CreateNewCookie(
			PANID_COOKIE pNewCookie,
			PWSTR pwszPUID,
			DWORD cchPUID,
			USHORT usWrites,
			DWORD dwExpire);
	
	
	HCRYPTPROV		m_hCryptProv;
	HCRYPTKEY		m_hKeyHMAC;	
	CCookieExpiration m_cookieExp;

	static const unsigned int	s_KeyLength			= 16;		// A key length of 128 bits is sufficient for the HMAC key used to hash the PUID.
	static const BYTE 	s_rgbKey[s_KeyLength];			// 64 bits key length (no max with HMAC).

	static const ALG_ID	s_HashAlgId			= CALG_MD5;	// MD5 is used as the hashing algorithm.
	static const unsigned int		s_HashAlgHashLength	= 16;		// 128 bits max hash length with MD5.

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif     // Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <wincrypt.h>
#include <oleauto.h>

#include <limits.h>
#include "hex.h"
#define UTILITY_DECLSPEC
#include "UrlSafeBase64.h"
#include "NAPUtil.h"
#include "NAP.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\NAP\Src\UrlSafeBase64.h ===
//-----------------------------------------------------------------------------
// Microsoft User Service and Revenue Technologies
//
// File:			UrlSafeBase64.h
//
// Copyright:		Copyright (c) Microsoft Corporation
//
// Contents: 		Base 64 Encoding with URL and Filename Safe Alphabet ( section 4 of rfc3548 )
//
// History:		10/15/04 WenjunQ Created.
//-----------------------------------------------------------------------------
/*	
	 Table 2: The "URL and Filename safe" Base 64 Alphabet

    Value Encoding  Value Encoding  Value Encoding  Value Encoding
       0 A            17 R            34 i            51 z
       1 B            18 S            35 j            52 0
       2 C            19 T            36 k            53 1
       3 D            20 U            37 l            54 2
       4 E            21 V            38 m            55 3
       5 F            22 W            39 n            56 4
       6 G            23 X            40 o            57 5
       7 H            24 Y            41 p            58 6
       8 I            25 Z            42 q            59 7
       9 J            26 a            43 r            60 8
      10 K            27 b            44 s            61 9
      11 L            28 c            45 t            62 - (minus)
      12 M            29 d            46 u            63 _ (understrike)
      13 N            30 e            47 v
      14 O            31 f            48 w         (pad) =
      15 P            32 g            49 x
      16 Q            33 h            50 y

*/

 #pragma	once


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	int	Base64EncodeGetRequiredLength(
	int	nSrcLen
)
{
	return ( nSrcLen * 4 + 2 ) / 3;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	int	Base64DecodeGetRequiredLength(
	int	nSrcLen
)
{
	return nSrcLen * 3 / 4;
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	BOOL Base64Encode(
	const BYTE*	pbSrcData,	//[in]	pointer	to buffer to encode
	int			nSrcLen,	//[in]	length of data to encode
	LPSTR		szDest,		//[out]	pointer	to output buffer for encoded data, must	be allocated by	caller
	int	*		pnDestLen	//[out] length of encoded data, which is	always longer then input data length
)
{
	static const char s_chBase64EncodingTable[64] = {
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
		'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
		'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
		'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_' };

	if ( (NULL != pbSrcData) &&	(NULL != szDest) && (NULL != pnDestLen) && (*pnDestLen >= Base64EncodeGetRequiredLength(nSrcLen)) )
	{
		LPSTR szDestStart = szDest;
		const BYTE*	pbSrcEnd = pbSrcData + nSrcLen;

		while ( pbSrcData < pbSrcEnd )
		{
			if ( (pbSrcEnd-pbSrcData) >= 3 )
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*pbSrcData << 4) & 0x3f) | (*(pbSrcData+1) >> 4) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*(pbSrcData+1) << 2) & 0x3f) | (*(pbSrcData+2) >> 6) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ *(pbSrcData+2) & 0x3f ];
				++szDest;
				pbSrcData += 3;
			}
			else if ( (pbSrcEnd-pbSrcData) == 2 )
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ ((*pbSrcData << 4) & 0x3f) | (*(pbSrcData+1) >> 4) ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ (*(pbSrcData+1) << 2) & 0x3f ];
				++szDest;
				break;
			}
			else
			{
				*szDest = s_chBase64EncodingTable[ *pbSrcData >> 2 ];
				++szDest;
				*szDest = s_chBase64EncodingTable[ (*pbSrcData << 4) & 0x3f ];
				++szDest;
				break;
			}
		}

		*pnDestLen = szDest - szDestStart;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
UTILITY_DECLSPEC inline	BOOL Base64Decode(
	LPCSTR	szSrc,		// [in]		Pointer	to buffer to decode.
	int		nSrcLen,	// [in]		Length of buffer to	decode.
	PBYTE	pbDest,		// [out]	Pointer	to decoded output buffer, must be allocated	by caller.
	int	*	pnDestLen	// [in]		Pointer	to the size	of decoded buffer.
						// [out]	Pointer	to the length decoded data,	or the required	size in	order to store the data	in case	of failure.
)
{
													//	 0	 1	 2	 3	 4	 5	 6	 7	 8	 9 
	static const char s_cBase64DecodingTable[] =	{	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	 0 -   9
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	10 -  19
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	20 -  29
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	//	30 -  39
														-1,	-1,	-1,	-1,	-1,	62,	-1,	-1,	52,	53,	//	40 -  49
														54,	55,	56,	57,	58,	59,	60,	61,	-1,	-1,	//	50 -  59
														-1,	-1,	-1,	-1,	-1,	 0,	 1,	 2,	 3,	 4,	//	60 -  69
														 5,	 6,	 7,	 8,	 9,	10,	11,	12,	13,	14,	//	70 -  79
														15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	//	80 -  89
														25,	-1,	-1,	-1,	-1,	63,	-1,	26,	27,	28,	//	90 -  99
														29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	// 100 - 109
														39,	40,	41,	42,	43,	44,	45,	46,	47,	48,	// 110 - 119
														49,	50,	51,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 120 - 129
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 130 - 139
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 140 - 149
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 150 - 159
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 160 - 169
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 170 - 179
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 180 - 189
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 190 - 199
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 200 - 209
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 210 - 219
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 220 - 229
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 230 - 239
														-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	// 240 - 249
														-1,	-1,	-1,	-1,	-1,	-1					// 250 - 256
													};
	// Parameter check.
	if ( (NULL != szSrc) && (NULL != pbDest) && (NULL != pnDestLen) && (*pnDestLen >= Base64DecodeGetRequiredLength(nSrcLen)) )
	{
		BYTE* pbDestStart = pbDest;
		LPCSTR szSrcEnd = szSrc + nSrcLen;

		char c, c1;

		while ( szSrc < szSrcEnd )
		{
			c = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
			++szSrc;

			if ( (c != -1) && (szSrc < szSrcEnd) )
			{
				c1 = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
				++szSrc;

				if ( c1 != -1 )
				{
					*pbDest = (c << 2) | (c1 >> 4);
					++pbDest;

					if ( szSrc < szSrcEnd )
					{
						c = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
						++szSrc;

						if ( c != -1 )
						{
							*pbDest = (c1 << 4) | (c >> 2);
							++pbDest;

							if ( szSrc < szSrcEnd )
							{
								c1 = s_cBase64DecodingTable[ (unsigned char)*szSrc ];
								++szSrc;

								if ( c1 != -1 )
								{
									*pbDest = (c << 6) | c1;
									++pbDest;
								}
								else
									return FALSE; // Bad character encountered.
							}
							else
								break;
						}
						else
							return FALSE; // Bad character encountered.
					}
					else
						break;
				}
				else
					return FALSE; // Bad character encountered.
			}
			else
				return FALSE; // Bad character encountered of not enough data.
		}

		*pnDestLen = pbDest - pbDestStart;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\PassportIDCRL\4.0\Debug\msidcrl.h ===
/*******************************************************************************
 * FILE
 *      ppcrl.h
 *
 * DESCRIPTION
 *      Public Passport client runtime library header. Distributed to partners
 *      along with the associated exports library and dynamic link library. Defines
 *      the public interface by which hosting partner applications make use
 *      of the Passport client runtime library.
 *
 * COMPATIBILITY NOTES
 *      Current implementation is per M2 Passport functionality. Contents
 *      of this file subject to change prior to 3.0 release. After 3.0, the
 *      header and library will maintain backward compile compatibility
 *      in subsequent versions.
 *
 *      Support for authentication based on client certificates was pulled
 *      from the 3.0 release. As a result, all cert-based code related to
 *      the API has been disabled. Fields are still left in the API's
 *      in anticipation of this future functionality, but the calls
 *      will fail with PPCRL_E_CERTIFICATE_AUTHENTICATION_NOT_SUPPORTED
 *      if non null/empty values are passed in.
 *
 * (C) Copyright 2002-2004, Microsoft Corporation. All Right Reserved.
 *
 ******************************************************************************/
#ifndef PPCRL_SCRIPT_ERROR_CODES
#pragma once

// #ifdef PPCRL_LIB
#define IDCRL_API  HRESULT __stdcall

/* disabled - otherwise IA64 build in NT complain multiple defineition of the same function Uniniatlize
#else
#ifdef PPCRL_EXPORTS
#define IDCRL_API __declspec(dllexport) HRESULT __stdcall
#else
#define IDCRL_API __declspec(dllimport) HRESULT __stdcall
#endif
#endif
*/

#define IDCRL_API_VERSION_1 1
#define IDCRL_API_VERSION_CURRENT IDCRL_API_VERSION_1

#define  IDCRL_BINARY_VERSION   "4"
#define  IDCRL_UI_CONTRACT_VERSION "1"


#ifdef __cplusplus
extern "C" {
#endif

#endif /* not defined PPCRL_SCRIPT_ERROR_CODES */

//
// Error/success code definitions
//

#ifdef PPCRL_SCRIPT_ERROR_CODES
    #define SEVERITY_SUCCESS 0
    #define SEVERITY_ERROR 1
    #define FACILITY_ITF 4
    #define MAKE_HRESULT(sev,fac,code) (((sev<<31)|(fac<<16)|((code))))
#endif

#define PPCRL_HRESULT_BASE    0x8800

#define PPCRL_SUCCESS_CODE(x) MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PPCRL_HRESULT_BASE|(x))
#define PPCRL_ERROR_CODE(x) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_HRESULT_BASE|(x))

//
// Authentication State
//

//
// Failure codes are 0x800488XX, success codes are 0x000488XX
// TODO: Go through and update comments with all actual codes for reference just prior to release
//

#define PPCRL_AUTHSTATE_E_UNAUTHENTICATED                           PPCRL_ERROR_CODE(0x00)  // 0x80048800

// returned by STS in as auth state, when the DA ticket is expired
#define PPCRL_AUTHSTATE_E_EXPIRED                                   PPCRL_ERROR_CODE(0x01) 
#define PPCRL_AUTHSTATE_S_AUTHENTICATED_OFFLINE                     PPCRL_SUCCESS_CODE(0x02) // Offline login from hashed creds
#define PPCRL_AUTHSTATE_S_AUTHENTICATED_PASSWORD                    PPCRL_SUCCESS_CODE(0x03) // Online login with password, Returned by the server?

//Reserved
//#define PPCRL_AUTHSTATE_S_AUTHENTICATED_SECURITY_KEY                PPCRL_SUCCESS_CODE(0x04)
//#define PPCRL_AUTHSTATE_S_AUTHENTICATED_STRONG_PASSWORD             PPCRL_SUCCESS_CODE(0x05) // ?? Returned by the server ??
//FUTURE: #define PPCRL_AUTHSTATE_S_AUTHENTICATED_CERTIFICATE                 PPCRL_SUCCESS_CODE(0x06)

#define PPCRL_AUTHREQUIRED_E_PASSWORD                               PPCRL_ERROR_CODE(0x10) // password is required for authentication
//Reserved
#define PPCRL_AUTHREQUIRED_E_SECURITY_KEY                           PPCRL_ERROR_CODE(0x11)
//#define PPCRL_AUTHREQUIRED_E_STRONG_PASSWORD                        PPCRL_ERROR_CODE(0x12)
#define PPCRL_AUTHREQUIRED_E_CERTIFICATE                            PPCRL_ERROR_CODE(0x13)

// The auth required status is unknown, in case, we cannot retrieve it from the token bag
#define PPCRL_AUTHREQUIRED_E_UNKNOWN                                PPCRL_ERROR_CODE(0x14)

#define PPCRL_REQUEST_E_AUTH_SERVER_ERROR                           PPCRL_ERROR_CODE(0x20) // Request failure, IDCRL did not get back a response
#define PPCRL_REQUEST_E_BAD_MEMBER_NAME_OR_PASSWORD                 PPCRL_ERROR_CODE(0x21)
#define PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT                         PPCRL_ERROR_CODE(0x23)
#define PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT_BAD_PASSWORD_OR_HIP     PPCRL_ERROR_CODE(0x24)
#define PPCRL_REQUEST_E_TOU_CONSENT_REQUIRED                        PPCRL_ERROR_CODE(0x25) // not used
#define PPCRL_REQUEST_E_FORCE_RENAME_REQUIRED                       PPCRL_ERROR_CODE(0x26)
#define PPCRL_REQUEST_E_FORCE_CHANGE_PASSWORD_REQUIRED              PPCRL_ERROR_CODE(0x27)
#define PPCRL_REQUEST_E_STRONG_PASSWORD_REQUIRED                    PPCRL_ERROR_CODE(0x28)
#define PPCRL_REQUEST_E_NO_CERTIFICATES_AVAILABLE                   PPCRL_ERROR_CODE(0x29)
#define PPCRL_REQUEST_E_PARTNER_NOT_FOUND                           PPCRL_ERROR_CODE(0x2a)
#define PPCRL_REQUEST_E_PARTNER_HAS_NO_ASYMMETRIC_KEY               PPCRL_ERROR_CODE(0x2b)
#define PPCRL_REQUEST_E_INVALID_POLICY                              PPCRL_ERROR_CODE(0x2c)
#define PPCRL_REQUEST_E_INVALID_MEMBER_NAME                         PPCRL_ERROR_CODE(0x2d)
#define PPCRL_REQUEST_E_MISSING_PRIMARY_CREDENTIAL                  PPCRL_ERROR_CODE(0x2e)
#define PPCRL_REQUEST_E_PENDING_NETWORK_REQUEST                     PPCRL_ERROR_CODE(0x2f)
#define PPCRL_REQUEST_E_FORCE_CHANGE_SQSA                           PPCRL_ERROR_CODE(0x30)
#define PPCRL_REQUEST_E_PASSWORD_EXPIRED                            PPCRL_ERROR_CODE(0x31)
#define PPCRL_REQUEST_E_PENDING_USER_INPUT                          PPCRL_ERROR_CODE(0x32)
#define PPCRL_REQUEST_E_MISSING_HIP_SOLUTION                        PPCRL_ERROR_CODE(0x33)
#define PPCRL_REQUEST_E_PROFILE_ACCRUE_REQUIRED                     PPCRL_ERROR_CODE(0x34)
#define PPCRL_REQUEST_S_PROFILE_ACCRUE_DONE                         PPCRL_SUCCESS_CODE(0x35)
#define PPCRL_REQUEST_E_EMAIL_VALIDATION_REQUIRED                   PPCRL_ERROR_CODE(0x36)
#define PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW                       PPCRL_ERROR_CODE(0x37)
#define PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW_EXPIRY                PPCRL_ERROR_CODE(0x38)
//Login server sends this request status when DA ticket is expired, apps should use this request
// status to determine if the ticket is expired.
#define PPCRL_REQUEST_E_AUTH_EXPIRED                                PPCRL_ERROR_CODE(0x39)

#define PPCRL_REQUEST_E_USER_REQUESTED_HELP                         PPCRL_ERROR_CODE(0x40)
#define PPCRL_REQUEST_E_USER_FORGOT_PASSWORD                        PPCRL_ERROR_CODE(0x41)
#define PPCRL_REQUEST_E_USER_CANCELED                               PPCRL_ERROR_CODE(0x42)
#define PPCRL_REQUEST_E_USER_EDIT_PASSPORT                          PPCRL_ERROR_CODE(0x43)
#define PPCRL_REQUEST_E_USER_PASSPORTLOGO                           PPCRL_ERROR_CODE(0x44)
#define PPCRL_REQUEST_E_USER_SHOW_PRIVACY_STATEMENT                 PPCRL_ERROR_CODE(0x45)
#define PPCRL_REQUEST_E_USER_SHOW_TERMS_OF_USE                      PPCRL_ERROR_CODE(0x46)
#define PPCRL_REQUEST_S_IO_PENDING                                  PPCRL_SUCCESS_CODE(0x47)
#define PPCRL_REQUEST_E_NO_NETWORK                                  PPCRL_ERROR_CODE(0x48)
// The request status is unknown, in case, we cannot retrieve it from the token bag
#define PPCRL_REQUEST_E_UNKNOWN                                     PPCRL_ERROR_CODE(0x49)

// reserved
#define PPCRL_REQUEST_E_TOKEN_BEYOND_LIFTIME                        PPCRL_ERROR_CODE(0x50)

// reserved
#define PPCRL_REQUEST_E_TOKEN_TARGETS_MISMATCH                      PPCRL_ERROR_CODE(0x51)

//  indicate the client needs to re-post to another STS
//  STS url should be part of the response
#define PPCRL_REQUEST_E_WRONG_DA                                    PPCRL_ERROR_CODE(0x52)

// parent consent for the KID is required
#define PPCRL_REQUEST_E_KID_HAS_NO_CONSENT                          PPCRL_ERROR_CODE(0x53)

// new error code 3.2
#define PPCRL_REQUEST_E_RSTR_MISSING_REFERENCE_URI                  PPCRL_ERROR_CODE(0x54)
//reserved
#define PPCRL_REQUEST_E_RSTR_FAULT                                  PPCRL_ERROR_CODE(0x55)
#define PPCRL_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN               PPCRL_ERROR_CODE(0x56)
#define PPCRL_REQUEST_E_RSTR_MISSING_BASE64CERT                     PPCRL_ERROR_CODE(0x57)
#define PPCRL_REQUEST_E_RSTR_MISSING_TOKENTYPE                      PPCRL_ERROR_CODE(0x58)
#define PPCRL_REQUEST_E_RSTR_MISSING_SERVICENAME                    PPCRL_ERROR_CODE(0x59)
#define PPCRL_REQUEST_E_RSTR_INVALID_TOKENTYPE                      PPCRL_ERROR_CODE(0x5a)
#define PPCRL_REQUEST_E_RSTR_MISSING_PRIVATE_KEY                    PPCRL_ERROR_CODE(0x5b)

// This error is returned if the STS cannot verify the timestamp on the request. In this case,
// STS will also send back the server time and IDCRL can adjust 
#define PPCRL_REQUEST_E_INVALID_SERVICE_TIMESTAMP                   PPCRL_ERROR_CODE(0x5c) //0x8004885c
#define PPCRL_REQUEST_E_INVALID_PKCS10_TIMESTAMP                    PPCRL_ERROR_CODE(0x5d) //0x8004885d
#define PPCRL_REQUEST_E_INVALID_PKCS10                              PPCRL_ERROR_CODE(0x5e) //0x8004885e
// NOTE: 2nd range for PPCRL_REQUEST_E errors starts at 0x800488E0. This one is full!

#define PPCRL_S_NO_MORE_IDENTITIES                                  PPCRL_SUCCESS_CODE(0x60)
#define PPCRL_S_TOKEN_TYPE_DOES_NOT_SUPPORT_SESSION_KEY             PPCRL_SUCCESS_CODE(0x61)
#define PPCRL_S_NO_SUCH_CREDENTIAL                                  PPCRL_SUCCESS_CODE(0x62)
#define PPCRL_S_NO_AUTHENTICATION_REQUIRED                          PPCRL_SUCCESS_CODE(0x63)

#define PPCRL_E_AUTH_CONTEXT_ALREADY_IN_USE                         PPCRL_ERROR_CODE(0x60)
#define PPCRL_E_IDENTITY_NOT_AUTHENTICATED                          PPCRL_ERROR_CODE(0x61)
#define PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN                    PPCRL_ERROR_CODE(0x62)

//Reserved
//#define PPCRL_E_INVALID_DERIVATION_METHOD                           PPCRL_ERROR_CODE(0x63)
//#define PPCRL_E_INVALID_DERIVATION_PARAMS                           PPCRL_ERROR_CODE(0x64)
//#define PPCRL_E_INVALID_DERIVATION_ITERATIONS_PARAM                 PPCRL_ERROR_CODE(0x65)
//#define PPCRL_E_INVALID_DERIVATION_SALT_PARAM                       PPCRL_ERROR_CODE(0x66)
//#define PPCRL_E_INVALID_DERIVED_KEY_LENGTH                          PPCRL_ERROR_CODE(0x67)
#define PPCRL_E_CERTIFICATE_AUTHENTICATION_NOT_SUPPORTED            PPCRL_ERROR_CODE(0x68)
#define PPCRL_E_AUTH_SERVICE_UNAVAILABLE                            PPCRL_ERROR_CODE(0x69)
#define PPCRL_E_INVALID_AUTH_SERVICE_RESPONSE                       PPCRL_ERROR_CODE(0x6a)
#define PPCRL_E_UNABLE_TO_INITIALIZE_CRYPTO_PROVIDER                PPCRL_ERROR_CODE(0x6b)
#define PPCRL_E_NO_MEMBER_NAME_SET                                  PPCRL_ERROR_CODE(0x6c)
#define PPCRL_E_CALLBACK_REQUIRED                                   PPCRL_ERROR_CODE(0x6d)
#define PPCRL_E_DISCONTINUE_AUTHENTICATION                          PPCRL_ERROR_CODE(0x6e)
#define PPCRL_E_INVALIDFLAGS                                        PPCRL_ERROR_CODE(0x6f)
#define PPCRL_E_UNABLE_TO_RETRIEVE_CERT                             PPCRL_ERROR_CODE(0x70)
#define PPCRL_E_INVALID_RSTPARAMS                                   PPCRL_ERROR_CODE(0x71)
#define PPCRL_E_MISSING_FILE                                        PPCRL_ERROR_CODE(0x72)
#define PPCRL_E_ILLEGAL_LOGONIDENTITY_FLAG                          PPCRL_ERROR_CODE(0x73)

#define PPCRL_E_CERT_NOT_VALID_FOR_MINTTL                           PPCRL_ERROR_CODE(0x74) // the certificate is found, but not valid for the minTTL, minTTL could be too big
#define PPCRL_S_OK_CLIENTTIME                                       PPCRL_SUCCESS_CODE(0x75)

#define PPCRL_E_CERT_INVALID_ISSUER                                 PPCRL_ERROR_CODE(0x76) // the certificate is found, but not valid for the minTTL, minTTL could be too big
#define PPCRL_E_NO_CERTSTORE_FOR_ISSUERS                            PPCRL_ERROR_CODE(0x77)

// Indicates there was a problem with offline login, more information can be had by calling GetAuthState API.
#define PPCRL_E_OFFLINE_AUTH                                        PPCRL_ERROR_CODE(0x78)

// GetCertificate failed because POP message could not be signed. This is an unexepcted error.
#define PPCRL_E_SIGN_POP_FAILED                                    PPCRL_ERROR_CODE(0x79)

// VerifyCertificate failed because POP was invalid. Sender may not possess the private key
// for the certificate
#define PPCRL_E_CERT_INVALID_POP                                    PPCRL_ERROR_CODE(0x80)

// The calling application is not signed. In order to call GetCertificate API, the application exe
// must be signed with Microsoft Code signing certificate (https://codesignaoc for more details)
// 
#define PPCRL_E_CALLER_NOT_SIGNED                                   PPCRL_ERROR_CODE(0x81) ////0x80048881

// Identity is processing another API call. Please wait for some time and retry the call
#define PPCRL_E_BUSY                                                PPCRL_ERROR_CODE(0x82) ////0x80048882

// There was a failure while downloading the config or ui dlls from passport
// config servers. Most likely internet connection is not setup correctly.
#define PPCRL_E_DOWNLOAD_FILE_FAILED                                PPCRL_ERROR_CODE(0x83) ////0x80048883

// There was an error generating the certificate request. The error could be due
// to bad parameters supplied by the application (usually out of range keylength)
// See CryptGenKey API for allowed key lengths. 0 and 384-16,384 will usually
// work. Trace will provide more info on exact cause.
#define PPCRL_E_BUILD_CERT_REQUEST_FAILED                           PPCRL_ERROR_CODE(0x84) ////0x80048884

// Returned by GetCertificate API if it cannot find a certificate for the identity
#define PPCRL_E_CERTIFICATE_NOT_FOUND                               PPCRL_ERROR_CODE(0x85) ////0x80048885

// Returned by ExportAuthState API
#define PPCRL_E_AUTHBLOB_TOO_LARGE                                  PPCRL_ERROR_CODE(0x86) ////0x80048886
#define PPCRL_E_AUTHBLOB_NOT_FOUND                                  PPCRL_ERROR_CODE(0x87) ////0x80048887
#define PPCRL_E_AUTHBLOB_INVALID                                    PPCRL_ERROR_CODE(0x88) ////0x80048888

#define PPCRL_E_EXTPROP_NOTFOUND                                    PPCRL_ERROR_CODE(0x89) ////0x80048889

#define PPCRL_E_RESPONSE_TOO_LARGE                                   PPCRL_ERROR_CODE(0x8A) ////0x8004888A

#define PPCRL_E_EXTENDED_ERROR_NOT_SET                              PPCRL_ERROR_CODE(0x8B) ////0x8004888B

#define PPCRL_E_USER_NOTFOUND                                       PPCRL_ERROR_CODE(0x8C) ////0x8004888C

// Added in 4.0. Returned by Initialize(Ex) if signature on ppcrlconfig.dll or
// ppcrlui.dll cannot be validated.
#define PPCRL_E_SIGCHECK_FAILED                                     PPCRL_ERROR_CODE(0x8D) ////0x8004888D

//******************************************************************************
// 2nd range of request status codes starts with 0x800488E0

// User requested offline login but there was no hashed password. They must 
// create hashed password first by doing a successful online login.
#define PPCRL_REQUEST_E_MISSING_HASHED_PASSWORD                   PPCRL_ERROR_CODE(0xE0) ////0x800488E0

// The client issuing this request is no longer supported by passport login server. 
// User must upgrade to a newer version of the application built with a supported 
// version of IDCRL. It may be returned in request status by LogonIdentity* APIs.
#define PPCRL_REQUEST_E_CLIENT_DEPRECATED                         PPCRL_ERROR_CODE(0xE1) ////0x800488E1

// The request was cancelled by calling CancelPendingRequest API.
#define PPCRL_REQUEST_E_CANCELLED                                 PPCRL_ERROR_CODE(0xE2) ////0x800488E2

// Application provided incorrect key length for certificate request.
#define PPCRL_REQUEST_E_INVALID_PKCS10_KEYLEN                     PPCRL_ERROR_CODE(0xE3) ////0x800488E3

// Application tried to submit a request with duplicate service target names in PCMultiRSTParams parameter. 
// This is not supported. In this case no network call is made. This error can be returned by the 
// LogonIdentityEx or AuthIdentityToServiceEx fuctions.
#define  PPCRL_REQUEST_E_DUPLICATE_SERVICETARGET                  PPCRL_ERROR_CODE(0xE4) ////0x800488E4

// The authentication token has expired, re-authentication is required by the partner. Different partners
// choose different time windows for authentication. In a multiple request, some requests may succeed
// and others fail with this error.
#define PPCRL_REQUEST_E_FORCE_SIGNIN                              PPCRL_ERROR_CODE(0xE5) ////0x800488E5

// Partner needs a certificate to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_CERTIFICATE                  PPCRL_ERROR_CODE(0xE6) ////0x800488E6

// Partner needs a PIN to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_PIN                          PPCRL_ERROR_CODE(0xE7) ////0x800488E7

// Partner needs a password to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_PASSWORD                     PPCRL_ERROR_CODE(0xE8) ////0x800488E8

// Following two error codes are returned by LogonIdentityEx, AuthIdentityToServiceEx
// if we are unable to generate the SLC request (this will happen for guest users)
// In this case IDCRL automatically submits the request without the SLC and returned
// one of these return codes. PPCRL_S_OK_NO_SLC for sync and PPCRL_S_IO_PENDING_NO_SLC for async
#define PPCRL_REQUEST_S_OK_NO_SLC                                           PPCRL_SUCCESS_CODE(0xE9)
#define PPCRL_REQUEST_S_IO_PENDING_NO_SLC                                   PPCRL_SUCCESS_CODE(0xEA)


// There was an schannel failure while sending the request. Make sure SSL is enabled in IE.
#define PPCRL_REQUEST_E_SCHANNEL_ERROR                            PPCRL_ERROR_CODE(0xEB) ////0x800488EB

// There was an error parsing the certificate blob in the response.
#define PPCRL_REQUEST_E_CERT_PARSE_ERROR                       PPCRL_ERROR_CODE(0xEC) ////0x800488EC

//-----------------------------------------------------------------------------
//
//  Error codes from ppclienterr.h
//
// Most errors in this section are either developer actionable during development
// (PP_E_CRL_NOT_INITIALIZED: fix code to initialize IDCRL before using APIs) or
// not actionable at all (PP_E_CRL_OUT_OF_MEMORY: system is low on memory).
//
// There are a few errors that the user can fix or investigate. Search for 
// 'USER ACTIONABLE' to find such error codes.
//-----------------------------------------------------------------------------

#define     PP_E_CRL_BASE                       0x8000
// Denotes Out of memory condition, not actionable.
#define     PP_E_CRL_OUT_OF_MEMORY              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  1) // 0x8001

// Returned by some utility functions for NULL arguments, not actionable.
#define     PP_E_CRL_UNEXPECTED_NULL_ARG        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  2) // 0x8002

//Returned by some utility functions if they fail to load the UI or config dlls, 
// force download of new files from passport servers by deleting the current files
#define     PP_E_CRL_CREATE_XMLDOC_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  3) // 0x8003
#define     PP_E_CRL_LOAD_XMLDOC_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  4) // 0x8004

// Reserved
#define     PP_E_CRL_CREATE_FILE_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  5) // 0x8005

// Could not acquire a mutex for an operation. Close other idcrl enabled applications and try again.
#define     PP_E_CRL_CREATE_MUTEX_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  6) // 0x8006
#define     PP_E_CRL_OBTAIN_MUTEX_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  7) // 0x8007

// IDCRL is not initialized, call initialize(Ex) before calling any other APIs
#define     PP_E_CRL_NOT_INITIALIZED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  8) // 0x8008

// Reserved
#define     PP_E_CRL_TOKENS_TOO_LONG            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  9) // 0x8009
#define     PP_E_CRL_TOKENFILE_NOT_CREATED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  10) // 0x800a

// primary credential(password) is not set on the identity handle, Call API to set password first.
#define     PPCRL_PRIMARYCREDS_MISSING          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  11) // 0x800b

// The handle specified by the application is invalid, make sure it is not destroyed already.
#define     PPCRL_NO_SUCH_HANDLE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  12) // 0x800c

// Session key was not found, not actionable.
#define     PPCRL_NO_SESSION_KEY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  14) // 0x800e

// Used for identity sharing, reserved.
#define     PP_E_CRL_WRONG_TOKEN_VERSION        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  15) // 0x800f
#define     PP_E_CRL_WRONG_TOKENFILE_SIZE       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  16) // 0x8010

// Reserved
#define     PPCRL_CERTCONTEXT_MISSING           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  17) // 0x8011
#define     PPCRL_SECONDARYCREDS_MISSING        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  18) // 0x8012
#define     PPCRL_SITEID_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  19) // 0x8013
#define     PPCRL_CONSENT_NEEDED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  20) // 0x8014
#define     PP_E_CRL_INVALID_REDIRECT_URL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  21) // 0x8015

// Some parameters to make a request to the login server are missing, not actionable.
#define     PPCRL_REQUESTPARAMS_MISSING         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  24) // 0x8018

// Reserved
#define     PPCRL_REQUEST_NOT_MADE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  25) // 0x8019

// Initialize(Ex) called with an invalid GUID, make sure it is in the registry format {DF60E2DF-88AD-4526-AE21-83D130EF0F68}
#define     PP_E_CRL_INVALID_APP_GUID           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  26) // 0x801a

// Initialize(Ex) called with an invalid client version, use IDCRL_API_VERSION_CURRENT defined in msidcrl.h
#define     PP_E_CRL_INVALID_VERSION            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  27) // 0x801b

// Reserved
#define     PP_E_CRL_INVALID_HANDLE_NAME        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  28) // 0x801c

// CreateIdentityHandle was passed an invalid flag
#define     PP_E_CRL_ILLEGAL_IDENTITY_FLAG      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  29) // 0x801d

// Invalid pointer was given to an internal API to free, not actionable.
#define     PP_E_CRL_NOT_PPCRL_MEMORY           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  30) // 0x801e

// Application tried to get or set an invalid identity property name, must come from PASSPORTIDENTITYPROPERTY enum
#define     PP_E_CRL_INVALID_PROPERTY_TYPE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  31) // 0x801f

// Application tried to call an API with an invalid identity handle. Make sure it is not destroyed already.
#define     PP_E_CRL_NO_SUCH_IDENTITY           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  32) // 0x8020

//Reserved
#define     PP_E_CRL_UNKOWN_CRED_TYPE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 33) // 0x8021
#define     PP_E_CRL_BAD_FILE                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  34) // 0x8022
#define     PP_E_CRL_INVALID_MEMBER_NAME        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  35) // 0x8023

// Application could not read password while trying to save or validate hashed password, Call API to set password first
#define     PP_E_PPCRL_MISSING_PASSWORD         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 36) // 0x8025

// Reserved
#define     PP_E_PPCRL_AUTH_NEED_TOU            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 38)
#define     PP_E_PPCRL_AUTH_NEED_EMAIL_VALIDATIION MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 39)
#define     PP_S_TOKEN_REQUEST_FAILED           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE + 40)

// USER ACTIONABLE: Secure storage is not available on this OS (pstorec.dll is missing). Make sure you are running XP.
#define     PPCRL_E_PLATFORM_SECURE_STORAGE_NOT_AVAILABLE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 41)

// Reserved
#define     PP_E_CRL_BAD_OPTION                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2A)

// InitializeEx was called with one of the options having an incorrect length, fix application code
#define     PP_E_CRL_BAD_OPTIONLENGTH           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2B)

// InitializEx was called with ivalid option id. Use one from IDCRL_OPTION_ID enum.
#define     PP_E_CRL_BAD_OPTIONID               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2C)

// USER ACTIONABLE: InitializeEx was called with a very long Proxy list. Max supported is 4*INTERNET_MAX_URL_LENGTH.
#define     PP_E_CRL_PROXYLIST_TOOLONG          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2D)

// USER ACTIONABLE: InitializeEx was called with a very long Proxy bypass list. Max supported is 4*INTERNET_MAX_URL_LENGTH.
#define     PP_E_CRL_PROXYBYPASSLIST_TOOLONG    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2E)

// USER ACTIONABLE: InitializeEx was called with a NULL option value. Remove the option if the value is NULL.
#define     PP_E_CRL_NULL_OPTION                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2F)

// Inialize(Ex) was called with NO_UI mode, but a UI API was called. Initialize IDCRL in the UI mode to use UI.
#define     PPCRL_E_NO_UI_MODE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x30)

// AuthIdentityToServiceEx was called with some value in dwTokenRequestFlags, it must be 0.
#define     PP_E_CRL_ILLEGAL_REQUEST_FLAG       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x31)

// Reserved
#define     PP_E_CRL_NO_SERVICE_NAME            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x32)

// No token bag was associated to the identity handle, make sure identity handle is not destroyed.
#define     PP_E_CRL_NO_TOKENBAG                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x33)

// Reserved
#define     PP_E_CRL_STATUS_UNINITIALIZED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x34)

#define     PPCRL_E_LOCK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x36)
#define     PPCRL_E_SYNC_NOLOCK                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x37)
#define     PPCRL_E_HTTP_QUERYINFO             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x38)


// IDCRL blocked your network call because you tried to use the callback thread
// to make other requests. This is against Wininet recommendations and can cause
// wininet problems. You must change your code to make network calls from another
// thread.
#define     PP_E_CRL_NW_CALL_BLOCKED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x39) // 0x8039

// Notification manager is not initialized. This is a code bug in IDCRL. Report
// to IDCRL team for investigation.
#define     PP_E_CRL_NOTIFY_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x40) // 0x8040

// Error while sending notification
#define     PP_E_CRL_NOTIFY_SEND_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x41) // 0x8041

// Error while receiving notification, this error will not be visible to the calling application
#define     PP_E_CRL_NOTIFY_RECV_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x42) // 0x8042

// Error while receiving notification, this error will not be visible to the calling application.
#define     PP_E_CRL_NOTIFY_NO_MESSAGE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x43) // 0x8043

// IDCRL is already initialized
// This is not an error in 4.0 because multiple "apps" may try to initialize IDCRL in
// the same process in 4.0 (BHO and WinLive favorites in the browser)
#define     PPCRL_S_ALREADY_INITIALIZED        MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x44) // 0x8044

// Some other app is also using IDCRL, unitialize was skipped
#define     PPCRL_S_STILL_INUSE                MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x45) // 0x8045

// Some other app has already initialized IDCRL to point to a different environment.
// This is an error condition and application cannot continue.
#define     PPCRL_E_INITIALIED_DIFF_ENVIRONMENT MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x46) // 0x8046


#define     PP_E_PROTOCOL_BASE                  PP_E_CRL_BASE + 0x100

// Reserved
#define     PPCRL_SESSIONKEY_MISSING            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 1) // 0x8101
#define     PPCRL_ERROR_RESPONSE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 2) // 0x8102

// Bad response xml was received from the server. Not actionable.
#define     PPCRL_RESPONSE_BADXML               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 3) // 0x8103

//Reserved
#define     PPCRL_REQUEST_BADXML                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 4) // 0x8104

// GetWebAuthUrl was called but the token could not be read (t= was missing or the length was 0). Not actionable.
#define     PPCRL_TOKEN_CORRUPTED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 5) // 0x8105

// Could not decode session key from auth response, not actionable.
#define     PPCRL_BASE64DECODE_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 6) //0x8106

// Malformed response from login server, not actionable.
#define     PPCRL_RESPONSE_MISSINGREF           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 7) // 0x8107
#define     PPCRL_RESPONSE_NOTIMESTAMPORRSTR    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 8) // 0x8108
#define     PPCRL_RESPONSE_NOSIGNATUREELEMENT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 9) // 0x8109
#define     PPCRL_RESPONSE_NOCIPHERELEMENT      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 0xa) // 0x810a

// GetWebAuthUrl was called but the token type is not SERVICE_TOKEN_TYPE_PROPRIETARY. Call logon identity to get legacy passport token.
#define     PPCRL_TOKEN_WRONG_TYPE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 0xb) // 0x810b

#define     PP_E_CRED_BASE                      PP_E_CRL_BASE + 0x200

//Reserved
#define     PP_E_DYNAMIC_SALT_CORRUPTED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 1) // 0x8201
#define     PP_E_DECRYPTION_FAILURE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 2) // 0x8202
#define     PP_E_TAMPERED_DATA                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 3) // 0x8203

// Internal obfuscator class is not initialized, not actionable.
#define     PP_E_OBFUSCATOR_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 4) // 0x8204

//Reserved
#define     PPCRL_NOT_INITIALIZED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 5) // 0x8205
#define     PPCRL_ENCODING_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 6) // 0x8206


#define     PP_E_CRL_CONFIG_BASE                PP_E_CRL_BASE + 0x250
// Reserved
#define     PP_E_CRL_CONFIG_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0) // 0x8250

// Registry operations failed, use trace to determine problem.
#define     PP_E_CRL_REG_OPEN_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 1) // 0x8251
#define     PP_E_CRL_REG_QUERY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 2) // 0x8252
#define     PP_E_CRL_REG_SET_FAILED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 3) // 0x8253

// Reserved
#define     PP_E_CRL_GETWINDOWSDIR_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 4) // 0x8254
#define     PP_E_OBFUSCATE_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 5) // 0x825
#define     PP_E_LOAD_CONFIGDATA_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 6) // 0x8256
#define     PP_E_CRL_SAVE_DATA_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 7) // 0x8257
#define     PP_E_CRL_WRITE_DATA_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 8) // 0x8258

// IDCRL is already initialized, review code and remove multiple Initialization calls.
#define     PP_E_CRL_CONFIG_ALREADY_INITIALIZED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 9) // 0x8259

// Required files or directories were missing/could not be created. Use trace to determine problem.
#define     PP_E_CRL_CACHE_DIR_ERROR            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 10)// 0x825a

// Downloading of config or ui dlls failed. Make sure passport service is not down, internet connection is good and proxy is setup correctly.
#define     PP_E_CRL_SERVICE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 11)// 0x825b

// Reserved
#define     PP_E_CORRUPT                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 20) // 0x8264

// USER ACTIONABLE: IDCRL tried to download config or UI dlls but there was no internet connection. Make sure internet connection is good.
#define     PP_E_NOTCONNECTED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 21) // 0x8265

//Reserved
#define     PP_E_PASSPORTDOWN                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 22) // 0x8266
#define     PP_E_UPDATEFAILED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 23) // 0x8267
#define     PP_E_UPDATEINPROGRESS               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 24) // 0x8268

// System API to create a temp file name failed. Not actionable.
#define     PP_E_CRL_GET_TEMP_FILENAME_FAILED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 25) // 0x8269

// Temp UI file name was empty. Not actionable.
#define     PP_E_CRL_EMPTY_TEMP_FILE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 26) // 0x826A

// Could not read data from Config dll. Try to download config dll again and reinitialize IDCRL.
#define     PP_E_CRL_SELECTNODE_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 27) // 0x826B
#define     PP_E_CRL_GET_ATTR_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 28) // 0x826C
#define     PP_E_CRL_GET_ITEM_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 29) // 0x826D
#define     PP_E_CRL_TOOMANY_XMLNODES           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0x2a) // 0x826E
#define     PP_E_CRL_TOOMANY_XMLATTRIBS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0x2b) // 0x826F

// Reserved
#define     PP_E_CRL_AQURIE_CONTEXT_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 38) // 0x8276
#define     PP_E_CRL_IMPORT_KEY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 39) // 0x8277
#define     PP_E_CRL_CREATE_HASH_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 40) // 0x8278
#define     PP_E_CRL_HASH_DATA_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 41) // 0x8279

//Signature verification on response failed. Not actionable.
#define     PP_E_CRL_INVALID_SIG                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 42) // 0x827A
#define     PP_E_CRL_DECODE_KEY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 43) // 0x827B
#define     PP_E_CRL_DECODE_SIG_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 44) // 0x827C

// file found in place of directory, when trying to load configuration dll.
#define     PP_E_CRL_FILE_INSTEAD_OF_DIR        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 45)// 0x827D

#define     PP_E_CRL_CREDUI_BASE                    PP_E_CRL_BASE + 0x300

// Could not initialize ATL support for the UI. Not actionable.
#define     PP_E_CRL_CREDUI_ATLAXWININIT_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x1) // 0x8301

// Could not create the UI. Not actionable.
#define     PP_E_CRL_CREDUI_CREATEWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x2) // 0x8302

// Reserved
#define     PP_E_CRL_CREDUI_HOSTRETRIEVAL_FAIL      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x3) // 0x8303

// Could not get Host window pointer. Not actionable.
#define     PP_E_CRL_CREDUI_CONTROLRETRIEVAL_FAIL   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x4) // 0x8304

//Reserved
#define     PP_E_CRL_CREDUI_SHOWWINDOW_FAIL         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x5) // 0x8305
#define     PP_E_CRL_CREDUI_UPDATEWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x6) // 0x8306
#define     PP_E_CRL_CREDUI_REDRAWWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x7) // 0x8307
#define     PP_E_CRL_CREDUI_INVALIDSIZE_FAIL        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x8) // 0x8308
#define     PP_E_CRL_CREDUI_USERNOTSPECIFIED_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x9) // 0x8309

//Could not retrieve UI file name. Not actionable.
#define     PP_E_CRL_CREDUI_LOCALUIMISSING          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0xA) // 0x830A


//
// This section defines errors reported by GetExtendedError API for SQM
//
#define     PPCRL_E_SQM_BASE                    PP_E_CRL_BASE + 0x400

// Could not lock the identity or request handle. This should never happen. :)
#define     PPCRL_E_SQM_UNKNOWN                                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1) // 0x8401
#define     PPCRL_E_SQM_REQUEST_CANCELLED                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2) // 0x8402
#define     PPCRL_E_SQM_QUERY_STATUSCODE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x3) // 0x8403
#define     PPCRL_E_SQM_OUTOFMEMORY                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x4) // 0x8404
#define     PPCRL_E_SQM_READRESPONSE                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x5) // 0x8405
#define     PPCRL_E_SQM_RESPONSE_BADXML                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x6) // 0x8406
#define     PPCRL_E_SQM_INTERNET_OTHER                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x7) // 0x8407
#define     PPCRL_E_SQM_INTERNET_UI                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x8) // 0x840B
#define     PPCRL_E_SQM_INTERNET_SYNTAX                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x9) // 0x8409
#define     PPCRL_E_SQM_INTERNET_NAME_NOT_RESOLVED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xA) // 0x840A
#define     PPCRL_E_SQM_INTERNET_LOGIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xB) // 0x840B
#define     PPCRL_E_SQM_INTERNET_PROXY                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xC) // 0x840C
#define     PPCRL_E_SQM_INTERNET_OPERATION_CANCELLED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xD) // 0x840D
#define     PPCRL_E_SQM_INTERNET_INCORRECT_HANDLE_STATE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xE) // 0x840E
#define     PPCRL_E_SQM_INTERNET_CANNOT_CONNECT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xF) // 0x840F
#define     PPCRL_E_SQM_INTERNET_CONNECTION_ABORTED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x10) // 0x8410
#define     PPCRL_E_SQM_INTERNET_CONNECTION_RESET                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x11) // 0X8411
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_DATE_INVALID            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x12) // 0X8412
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_CN_INVALID              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x13) // 0X8413
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_ERRORS                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x14) // 0X8414
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_NO_REV                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x15) // 0X8415
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_REV_FAILED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x16) // 0X8416
#define     PPCRL_E_SQM_INTERNET_CLIENT_AUTH_CERT_NEEDED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x17) // 0X8417
#define     PPCRL_E_SQM_INTERNET_INVALID_CA                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x18) // 0X8418
#define     PPCRL_E_SQM_INTERNET_SECURITY_WARNING                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x19) // 0X8419
#define     PPCRL_E_SQM_INTERNET_POST_IS_NON_SECURE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1A) // 0X841A
#define     PPCRL_E_SQM_FTP                                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1B) // 0X841B
#define     PPCRL_E_SQM_GOPHER                                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1C) // 0X841C
#define     PPCRL_E_SQM_HTTP_HEADER                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1D) // 0X841D
#define     PPCRL_E_SQM_HTTP_DOWNLEVEL_SERVER                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1E) // 0X841E
#define     PPCRL_E_SQM_HTTP_INVALID_SERVER_RESPONSE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1F) // 0X841F
#define     PPCRL_E_SQM_HTTP_INVALID_QUERY_REQUEST                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x20) // 0X8420
#define     PPCRL_E_SQM_HTTP_REDIRECT                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x21) // 0X8421
#define     PPCRL_E_SQM_HTTP_COOKIE                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x22) // 0X8422
#define     PPCRL_E_SQM_INTERNET_SECURITY_CHANNEL_ERROR           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x23) // 0X8423
#define     PPCRL_E_SQM_INTERNET_DISCONNECTED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x24) // 0X8424
#define     PPCRL_E_SQM_INTERNET_SERVER_UNREACHABLE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x25) // 0X8425
#define     PPCRL_E_SQM_INTERNET_PROXY_SERVER_UNREACHABLE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x26) // 0X8426
#define     PPCRL_E_SQM_INTERNET_PROXYSCRIPT                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x27) // 0X8427
#define     PPCRL_E_SQM_INTERNET_SEC_INVALID_CERT                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x28) // 0X8428
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_REVOKED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x29) // 0X8429
#define     PPCRL_E_SQM_INTERNET_AUTODIAL                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2A) // 0X842A
#define     PPCRL_E_SQM_INTERNET_NOT_INITIALIZED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2B) // 0X842B
#define     PPCRL_E_SQM_LOCK                                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2C) // 0X842C
#define     PPCRL_E_SQM_SYNC_NOLOCK                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2D) // 0X842D
#define     PPCRL_E_SQM_HTTP_QUERYINFO                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2E) // 0X842E
#define     PPCRL_E_SQM_RESPONSE_TOO_LARGE                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2F) // 0X842F
#define     PPCRL_E_SQM_INVALID_AUTH_SERVICE_RESPONSE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x30) // 0X8430
#define     PPCRL_E_SQM_NO_TOKENBAG                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x31) // 0X8431
#define     PPCRL_E_SQM_RESPONSE_NOTIMESTAMPORRSTR                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x32) // 0X8432
#define     PPCRL_E_SQM_RESPONSE_NOSIGNATUREELEMENT               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x33) // 0X8433
#define     PPCRL_E_SQM_RESPONSE_NOCIPHERELEMENT                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x34) // 0X8434
#define     PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCE_URI      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x35) // 0X8435
#define     PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x36) // 0X8436
#define     PPCRL_E_SQM_WAIT_ABANDONED                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x37) // 0X8437
#define     PPCRL_E_SQM_WAIT_TIMEOUT                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x38) // 0X8438
#define     PPCRL_E_SQM_INTERNET_TIMEOUT                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x39) // 0x8439

#ifndef PPCRL_SCRIPT_ERROR_CODES

//
// PPCRL function declarations
//

#ifdef __cplusplus
namespace IDCRL
{
#endif
    /***************************************************************************
     * PassportIdentityHandle & PassportUIAuthContextHandle
     **************************************************************************/
    typedef struct _tagPIH {} * PassportIdentityHandle;
    typedef struct _tagPUACH {} * PassportUIAuthContextHandle;
    typedef struct _tagPEIH {} * PassportEnumIdentitiesHandle;

#ifdef __cplusplus
    #define INVALID_PASSPORTIDENTITYHANDLE ((IDCRL::PassportIdentityHandle)0)
    #define INVALID_PASSPORTUIAUTHCONTEXTHANDLE ((IDCRL::PassportUIAuthContextHandle)0)
    #define INVALID_PASSPORTENUMIDENTITIESHANDLE ((IDCRL::PassportEnumIdentitiesHandle)0)
#else
    #define INVALID_PASSPORTIDENTITYHANDLE ((PassportIdentityHandle)0)
    #define INVALID_PASSPORTUIAUTHCONTEXTHANDLE ((PassportUIAuthContextHandle)0)
    #define INVALID_PASSPORTENUMIDENTITIESHANDLE ((PassportEnumIdentitiesHandle)0)
#endif

    /***************************************************************************
     * NOTIFICATION_CHANGE_TYPE enum
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      IDS_USER_ACCOUNT_CHANGE: Creds were persisted or removed.
     *      IDS_USER_PROPERTY_CHANGE: user property, extended property changed.
     *      
     *
     **************************************************************************/
    typedef enum _NOTIFICATION_CHANGE_TYPE
    {
        NOTIFICATION_CHANGE_ALL_BIT = 0x000000003,  // reserved
        IDS_USER_ACCOUNT_CHANGE     = 0x000000001,
        IDS_USER_PROPERTY_CHANGE    = 0x000000002
    } NOTIFICATION_CHANGE_TYPE;


    /***************************************************************************
     * NOTIFICATION_ACTION_TYPE enum
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      IDS_NOTIFY_ADD: notification target was added
     *      IDS_NOTIFY_UPDATE: notification target was updated
     *      IDS_NOTIFY_DELETE: notification target was deleted
     *      
     *
     **************************************************************************/
    typedef enum _NOTIFICATION_ACTION_TYPE
    {
        IDS_NOTIFY_ACTION_ALL_BIT = 0x000000007,  // reserved
        IDS_NOTIFY_ACTION_ADD       = 0x000000001,
        IDS_NOTIFY_ACTION_UPDATE    = 0x000000002,
        IDS_NOTIFY_ACTION_DELETE    = 0x000000004
    } NOTIFICATION_ACTION_TYPE;

    /***************************************************************************
     * IDSUserNotification
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Structure to the change data that is given to the application in the
     *      UserStateChangeCallback.
     * NOTE
     *      Application must make a copy of string buffers before returning
     *      from the callback because the memory will be freed by IDCRL as soon as 
     *      the callback function returns
     **************************************************************************/
    typedef struct {
        DWORD   dwType;         //This and dwChangeID in the callback are the same
        DWORD   dwAction;       //Add or delete
        LPCWSTR wszAccountName;
        LPCWSTR wszCredType;
    } IDSUserNotification;

    /***************************************************************************
     * IDSUserPropertyNotification
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Structure to the change data that is given to the application in the
     *      UserStateChangeCallback.
     * NOTE
     *      Application must make a copy of string buffers before returning
     *      from the callback because the memory will be freed by IDCRL as soon as 
     *      the callback function returns.
     *      If the property value is too large to pass in the notification,
     *      fValueTooLarge flag will be set to True. Apps must call 
     *      GetUserExtendedProperty to get the actual value in this case.
     **************************************************************************/
    typedef struct {
        DWORD dwType;             // This and dwChangeID in the callback are same
        DWORD dwAction;           // Add, update or delete
        bool  bValueTooLarge;     // Property value is too large
        LPCWSTR wszAccountName; 
        LPCWSTR wszPropertyName;
        LPCWSTR wszPropertyValue;
    } IDSUserPropertyNotification;

    /***************************************************************************
     * UserStateChangedCallback
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Callback notification for use state changes. This is called whenever
     *      there is a change to the user state. E.g. user tile change, persisted
     *      credentials change.
     *
     * INPUTS
     *      dwChangeID - Type of change, from NOTIFICATION_CHANGE_TYPE enum. This
     *                   same ID is also provided in the IDSUserNotification struct.
     *      pbChangeData - Pointer to the notification data. Exact type depends
     *      on the change ID.
     *
     * RESULT
     *
     * IMPORTANT
     *      This may be called by any number of threads and could be called
     *      by multiple threads at the same time. The implementor should take
     *      care to protect any resources accessed by this implementation
     *      from such clashes of access.
     *
     **************************************************************************/
    typedef HRESULT (__stdcall * UserStateChangedCallback)(
                __in DWORD    dwChangeID,
                __in LPVOID   pbChangeData);


    /***************************************************************************
     * IdentityChangedCallback
     *
     * DESCRIPTION
     *      Callback notification for asynchronous identity activity. This
     *      is used for all UI-based authentications, and optionally for
     *      asynchronous ui-less authentications. This is called whenever
     *      the state of the identity is changed and the hosting application
     *      may want to react to this change.
     *
     *      The hosting application can check the state of the identity
     *      to determine further action (see GetAuthState, below).
     *
     * INPUTS
     *      hIdentity - The identity with state that has changed
     *      pvVoid - Void pointer that was passed in to the LogonIdentity
     *          call for the hosting application to track state.
     *      bCanContinue - The library can continue with the authentication.
     *
     * RESULT
     *      Any failed HRESULT will cause the library to discontinue any
     *      pending authentication. Any successful HRESULT will cause
     *      the library to continue this authentication if it is able.
     *      Return PPCRL_E_DISCONTINUE_AUTHENTICATION to explicitly stop
     *      a pending authentication for no other reason than
     *      control of flow.
     *
     * IMPORTANT
     *      This may be called by any number of threads and could be called
     *      by multiple threads at the same time. The implementor should take
     *      care to protect any resources accessed by this implementation
     *      from such clashes of access.
     *
     **************************************************************************/

    typedef HRESULT (__stdcall * IdentityChangedCallback)(
                __in PassportIdentityHandle hIdentity,
                __in void * pvVoid,
                __in bool bCanContinue);

    /***************************************************************************
     * UPDATE_FLAG enum
     *
     * DESCRIPTION
     *      Flags controlling general behavior of the library passed
     *      in during the Initialize call. Normally the update
     *      mechanism operates periodically and automatically based
     *      on a time-out policy. These flags allow the hosting application
     *      to over-ride this behavior. They also allow the hosting application
     *      to indicate that it can operate in offline mode (an M2 feature).
     *
     *      IDCRL 3.2: OFFLINE_MODE_ALLOWED is ignored, it will mean the same as
     *      UPDATE_DEFAULT.
     *
     *      IDCRL 3.2: SKIP_CONNECTION_CHECK: When this mode is set, IDCRL will
     *      not check if a network and Internet connection is enabled before
     *      making network calls. In this case, you will get the default windows
     *      dialog to establish a connection if you are not connected already.
     *      The default IDCRL behavior is to fail with an error if there is no
     *      connection available or default connection is not established and
     *      user has chosen to "Always dial my default connection" setting in IE.
     *
     **************************************************************************/
    typedef enum _UPDATE_FLAG
    {
        UPDATE_FLAG_ALL_BIT = 0x00000000F,            // reserved
        DEFAULT_UPDATE_POLICY =   0x00000000,
        OFFLINE_MODE_ALLOWED =    0x00000001,
        NO_UI                =    0x00000002,
        SKIP_CONNECTION_CHECK=    0x00000004,
        SET_EXTENDED_ERROR =      0x00000008,
        UPDATE_DEFAULT       =    DEFAULT_UPDATE_POLICY // online, fall back to offline

    } UPDATE_FLAG;

    /***************************************************************************
     * PASSPORTCREDUIINFO structure
     *
     * DESCRIPTION
     *      Describes the user interface for those API calls in which
     *      the client runtime library may need to create a user interface
     *      to interact with the user. (Currently only LogonIdentity.)
     *
     **************************************************************************/
    typedef struct _PASSPORTCREDUIINFO
    {
        HWND hwndParent;
        POINT ptPosition;
        SIZE szSize;
        BOOL bShow;
    } PASSPORTCREDUIINFO, *PPASSPORTCREDUIINFO;
    typedef const PPASSPORTCREDUIINFO PCPASSPORTCREDUIINFO;

    /***************************************************************************
     * PASSPORTCREDCUSTOMUI structure
     *
     * DESCRIPTION
     *      Describes customizations to the appearance of the user
     *      interface.
     *
     **************************************************************************/


    typedef struct _PASSPORT_NAME_VALUE_PAIR
    {
        LPCWSTR szName;
        LPCWSTR szValue;
    } PASSPORT_NAME_VALUE;

    typedef struct _PASSPORTCREDCUSTOMUI
    {
        DWORD  cElements;
        PASSPORT_NAME_VALUE* customValues;    // # of element == cElements
    } PASSPORTCREDCUSTOMUI, *PPASSPORTCREDCUSTOMUI;
    typedef const PPASSPORTCREDCUSTOMUI PCPASSPORTCREDCUSTOMUI;



    /***************************************************************************
     * PASSPORTCREDTYPE enum
     *
     * DESCRIPTION
     *      Bit-wise flags representing the various types of credentials
     *      the client runtime can use. Supports the UI-less API surface.
     *
     **************************************************************************/
//    #define PPCRL_CREDTYPE_PASSWORD_A "ps:password"
// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define PPCRL_CREDTYPE_PIN_A "ps:pin"

    #define PPCRL_CREDTYPE_PASSWORD         L"ps:password"
    #define PPCRL_CREDTYPE_MEMBERNAMEONLY   L"ps:membernameonly"
    #define PPCRL_CREDTYPE_VIRUTUALAPPPrefix L"ps:virtualapp="

// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define PPCRL_CREDTYPE_PIN_W L"ps:pin"

    /***************************************************************************
     * SERVICETOKENFLAGS enum
     *
     * DESCRIPTION
     *      Used for retrieving properties about a given identity handle.
     *
     **************************************************************************/
    typedef enum _SERVICETOKENFLAGS
    {
        SERVICE_TOKEN_TYPE_LEGACY_PASSPORT          = 0x00000001, //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY

        SERVICE_TOKEN_TYPE_WEBSSO                   = 0x00000002, //Deprecated, use SERVICE_TOKEN_TYPE_SAML

        SERVICE_TOKEN_TYPE_COMPACT_WEBSSO           = 0x00000004, //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY

        // This can be set in RSTParams.dwRequestFlags to request a SLC
        //
        SERVICE_TOKEN_TYPE_X509V3                   = 0x00000008, // added in 3.2

        SERVICE_TOKEN_CERT_IN_MEMORY_PRIVATE_KEY    = 0x00000010, // this can be used with SERVICE_TOKEN_TYPE_X509V3

#ifdef  __TOKEN_TYPE        // REMOVED
        // Rest of bits in first byte reserved
        SERVICE_TOKEN_TYPE_ANY                      = 0x000000ff,
#endif

        //
        // Check the local cache for an existing service ticket.
        // If not set a call always results in a server request.
        // This is particularly useful for async service request
        // calls where the result puts the ticket in the
        // cache where it can be retrieved with a subsequent
        // call.
        //
        SERVICE_TOKEN_FROM_CACHE                    = 0x00010000,

        SERVICE_TOKEN_TYPE_SAML                     = SERVICE_TOKEN_TYPE_WEBSSO, //Response only

        // Proprietary ticket type includes both PPM and Compact tickets
        // These token types are combined into one to not break older clients
        // Older client will continue to see LEGACY_PASSPORT token type for 
        // compact tickets and they can keep sending them to the partner server
        // just like they do the PPM tickets.
        SERVICE_TOKEN_TYPE_PROPRIETARY              = SERVICE_TOKEN_TYPE_LEGACY_PASSPORT //Response only

    } SERVICETOKENFLAGS;

    typedef enum _SERVICETOKEN_REQUEST_FLAGS
    {

        SERVICE_TOKEN_REQUEST_TYPE_NONE            = 0x00000000,

        SERVICE_TOKEN_REQUEST_TYPE_X509V3          = SERVICE_TOKEN_TYPE_X509V3

    } SERVICETOKEN_REQUEST_FLAGS;

    //
    // Used internally by IDCRL to indicate that no certificate requests
    // are to be made. MSN unified v2 bug 161946.
    //
    typedef enum _MULTIRSTPARAMS_FLAGS
    {
        REQUEST_DEFAULT                            = 0x00000000,
        REQUEST_NO_SLC                             = 0x00000001

    } MULTIRSTPARAMS_FLAGS;

    /***************************************************************************
     * OfflinePBKDF2Params structure
     *
     * DESCRIPTION
     *      Params for a PBKDF2-based session key derivation from the
     *      offline credentials. See DeriveOfflineKey, below.
     *
     **************************************************************************/
    typedef struct _OfflinePBKDF2Params
    {
        ALG_ID algId;
        DWORD dwIterations;
        void * pvSalt;
        DWORD cbSaltLength;
        DWORD cbDerivedKeyLength;
    } OfflinePBKDF2Params, *POfflinePBKDF2Params;
    typedef const POfflinePBKDF2Params PCOfflinePBKDF2Params;

    /***************************************************************************
     * OfflineKeyMethod enum
     *
     * DESCRIPTION
     *      Determines the algorithm to use to derive the offline key.
     *
     **************************************************************************/
    typedef enum _OfflineKeyMethod
    {
        OFFLINE_KEY_PBKDF2_ON_PASSWORD              = 1
    } OfflineKeyMethod;


    /***************************************************************************
     * IDENTITY_FLAG enum
     *
     * DESCRIPTION
     *      Flags controlling properties of a particular identity
     *      handle. May be combined and passed in to the
     *      dwFlags parameter to CreateIdentityHandle.
     *
     **************************************************************************/
    typedef enum _IDENTITY_FLAG
    {
        IDENTITY_ALL_BIT                   =        0x000003ff, // reserved
        IDENTITY_SHARE_ALL                 =        0x000000ff, // Specific bit semantics are reserved
        IDENTITY_LOAD_FROM_PERSISTED_STORE =        0x00000100, // this requires member name, and will do a look up in the persisted store
        IDENTITY_AUTHSTATE_ENCRYPTED       =        0x00000200  // used by CreateIdentityHandleFromAuthState to indicate if the auth info is encrypted
    } IDENTITY_FLAG;


    /***************************************************************************
     * LOGON_FLAG enum
     *
     * DESCRIPTION
     *      Flags that can be passed into the various LogonIdentity API's
     *      to control the authentication process.
     *
     **************************************************************************/
    typedef enum _LOGON_FLAG
    {
        LOGONIDENTITY_ALL_BIT                   =   0x0000000F, // reserved
        LOGONIDENTITY_DEFAULT                   =   0x00000000,
        LOGONIDENTITY_ALLOW_OFFLINE             =   0x00000001,
        LOGONIDENTITY_FORCE_OFFLINE             =   0x00000002,
        LOGONIDENTITY_CREATE_OFFLINE_HASH       =   0x00000004,
        LOGONIDENTITY_ALLOW_PERSISTENT_COOKIES  =   0x00000008
    } LOGON_FLAG;

    /***************************************************************************
     * IDCRL_OPTION_IDS enum
     *
     * DESCRIPTION
     *      IDs of valid options that can be given to InitializeEx  or 
     *      SetIdcrlOptions APIs. (Except IDCRL_OPTION_ENVIRONMENT, which can only
     *      be specified at Initialization time)
     *
     *      IDCRL_OPTION_ENVIRONMENT
     *      Valid environments names are Betaprep, INT, PPE and PROD plus some 
     *      internal passport test environments. Apps can import environments.reg 
     *      file to import URLs to all passport environments. Note that this option
     *      can only be specified at Initialization time.
     *
     **************************************************************************/
    typedef enum {
        IDCRL_OPTION_ALL_BIT                = 0x0000007F, // reserved
        IDCRL_OPTION_PROXY                  = 0x00000001, //INTERNET_OPTION_PROXY
        IDCRL_OPTION_CONNECT_TIMEOUT        = 0x00000002, //INTERNET_OPTION_CONNECT_TIMEOUT
        IDCRL_OPTION_SEND_TIMEOUT           = 0x00000004, //INTERNET_OPTION_SEND_TIMEOUT
        IDCRL_OPTION_RECEIVE_TIMEOUT        = 0x00000008, //INTERNET_OPTION_RECEIVE_TIMEOUT
        IDCRL_OPTION_PROXY_PASSWORD         = 0x00000010, //INTERNET_OPTION_PROXY_PASSWORD
        IDCRL_OPTION_PROXY_USERNAME         = 0x00000020, //INTERNET_OPTION_PROXY_USERNAME
        IDCRL_OPTION_ENVIRONMENT            = 0x00000040  //Point to the named environment
    } IDCRL_OPTION_ID;

    /***************************************************************************
     * IDCRL_SETOPTIONS_FLAG enum
     *
     * DESCRIPTION
     *      IDs of valid options that can be given to InitializeEx call
     *
     **************************************************************************/
    typedef enum {
        IDCRL_SETOPTIONS_DEFAULT             = 0x00000000,
        IDCRL_SETOPTIONS_SET                 = IDCRL_SETOPTIONS_DEFAULT,
        IDCRL_SETOPTIONS_RESET               = 0x00000001
    } IDCRL_SETOPTIONS_FLAG;

    /***************************************************************************
     * IDCRL_OPTION struct
     *
     * DESCRIPTION
     *      Holds an option for IDCRL initialization through InitializeEx API.
     *      dwId   : option id from IDCRL_OPTION_ID enum
     *      pValue : Option value passed in as a BYTE *. The actual data 
     *                 structure will differ with the option id
     *      cbValue  : Byte size of the value
     *
     **************************************************************************/
    typedef struct {
        IDCRL_OPTION_ID dwId;
        BYTE *          pValue;
        size_t          cbValue;
    } IDCRL_OPTION, * LPIDCRL_OPTION;

    /***************************************************************************
     * IDCRL_OPTIONS struct
     *
     * DESCRIPTION
     *      Holds all options for IDCRL initialization through InitializeEx API.
     *      dwCount : Number of options
     *      arrOptions : Array of options
     *
     **************************************************************************/
    typedef struct {
        DWORD            dwCount;
        IDCRL_OPTION *   arrOptions; // Points to an array of structs with the size
                                       // given by dwCount
    } IDCRL_OPTIONS, * LPIDCRL_OPTIONS;

    /***************************************************************************
     * RSTParams - Request Security Token Params
     *   - added in IDCRL 3.2 to allow application to request multiple tokens
     *
     * DESCRIPTION
     *      the structure to hold information related to request a service token
     *
     **************************************************************************/
    typedef struct _RSTParams
    {
        __in DWORD   cbSize;             // size of the struct
        __in LPCWSTR wzServiceTarget;    // dname of the service
        __in LPCWSTR wzServicePolicy;    // policy for issuing the token
        __in DWORD   dwTokenFlags;       // for SLC, use SERVICE_TOKEN_TYPE_X509V3                                         // otherwise, 0
        __in DWORD   dwTokenParam;       // Params -
                                         // SLC, key size in bit
                                         // otherwise, 0
    } RSTParams, *PRSTParams;
    typedef const PRSTParams PCRSTParams;

    /***************************************************************************
     * MultiRSTParams
     *   - added in IDCRL 3.2 to allow application to request multiple tokens
     *
     * DESCRIPTION
     *      parameter required to
     *
     **************************************************************************/
    typedef struct _MultiRSTParams
    {
        DWORD       dwRSTParamsCount;    // # of RSTParams in the array, 0 is invalid
        PRSTParams  pRSTParams;    // pointer to the array of RSTParams
        DWORD       dwMultiRSTParamsFlags; // flags from MULTIRSTPARAMS_FLAGS
    } MultiRSTParams, *PMultiRSTParams;
    typedef const PMultiRSTParams PCMultiRSTParams;


    /***************************************************************************
     * Client-defined policy constants
     *
     * DESCRIPTION
     *      Constants allowing the hosting application to indicate particular
     *      common policy attributes.
     *
     **************************************************************************/

    #define AUTH_POLICY_DEFAULT NULL

// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define AUTH_POLICY_REQUIRE_PIN_A       "ppcrl:pin"
// 116306     #define AUTH_POLICY_REQUIRE_PIN_W       L"ppcrl:pin"

    // FUTURE: #define AUTH_POLICY_REQUIRE_CERT_A      "ppcrl:cert"
    // FUTURE: #define AUTH_POLICY_REQUIRE_CERT_W      L"ppcrl:cert"

    /***************************************************************************
     * Client-defined service name constants
     *
     * DESCRIPTION
     *      Constants allowing the hosting application to indicate particular
     *      service targets.
     *
     **************************************************************************/

    #define SERVICE_TARGET_PASSPORT     L"http://Passport.NET/tb"


    #define ENV_PRODUCTION              L"production"

    /***************************************************************************
     * Initialize
     *
     * DESCRIPTION
     *      Must be called before and return successfully before any other
     *      client runtime library functions are called.
     *
     * INPUTS
     *      guid - A GUID that uniquely identifies the hosting application.
     *              This allows features such as customized user interfaces
     *              to match the hosting application's look and feel.
     *      lPPCRLVersion - Binary version of the API
     *      dwFlags - Initialization flags from the UPDATE_FLAG enum above.
     *
     **************************************************************************/
IDCRL_API Initialize(
        __in REFGUID guid,
        __in LONG lPPCRLVersion,
        __in DWORD dwFlags);

    /***************************************************************************
     * InitializeEx
     *
     * DESCRIPTION
     *      Must be called before and return successfully before any other
     *      client runtime library functions are called. This function supports
     *      setting some optional parameters that Initialize does not support.
     *
     * INPUTS
     *      guid - A GUID that uniquely identifies the hosting application.
     *              This allows features such as customized user interfaces
     *              to match the hosting application's look and feel.
     *      lPPCRLVersion - Binary version of the API
     *      dwFlags - Initialization flags from the UPDATE_FLAG enum above.
     *      pOptions - Additional options to set. e.g. proxy information.
     *      dwOptions - count of options in pOptions.
     *
     **************************************************************************/
IDCRL_API InitializeEx(
        __in REFGUID         guid,
        __in LONG            lPPCRLVersion,
        __in DWORD           dwFlags,
        __in_opt LPIDCRL_OPTION  pOptions,
        __in_opt DWORD           dwOptions);


    /***************************************************************************
     * Uninitialize
     *
     * DESCRIPTION
     *      Must be called when shutting down the client runtime library. This
     *      will immediately invalidate any extant identity handles.
     *
     **************************************************************************/

IDCRL_API Uninitialize(void);

    /***************************************************************************
     * CreateIdentityHandle
     *
     * DESCRIPTION
     *      Used to create new identity handles, which then be authenticated
     *      with credentials and acquire authentication tokens.
     *
     * INPUTS
     *      szMemberName - Member name to initialize the identity to. May
     *              be NULL and set later with SetIdentityProperty (or
     *              by the user if UI is being used).
     *      dwFlags - Identity creation flags.
     *
     * OUTPUTS
     *      pihIdentity - New identity handle. May be passed to LogonIdentity, etc.
     *              Must be released with CloseIdentityHandle eventually.
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandle(
        __in_opt LPCWSTR wszMemberName,
        __in DWORD dwFlags,
        __out PassportIdentityHandle * pihIdentity);

    /***************************************************************************
     * CloseIdentityHandle
     *
     * DESCRIPTION
     *      Closes an identity handle previously opened with CreateIdentityHandle
     *      freeing any resources associated with the identity.
     *
     * INPUTS
     *      hIdentity - Identity handle to close.
     *
     **************************************************************************/
IDCRL_API CloseIdentityHandle(
        __in PassportIdentityHandle hIdentity);

    /***************************************************************************
     * CreatePassportAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Creates a UI context for the PPCRL to use its built-in user
     *      interface for credential collection and error handling when
     *      dealing with the user to authenticate.
     *
     * INPUTS
     *      pcuiInfo - describes the configurable attributes of the built-in
     *                  user interface
     *      ppachAuthContext - Address to receive the auth context handle
     *                  for the newly-created context.
     *
     * RESULTS
     *      Creates a UI authentication context that can be used when
     *      authenticating identities.
     *
     **************************************************************************/
    IDCRL_API CreatePassportAuthUIContext(
            __in const PASSPORTCREDUIINFO * pcuiInfo,
            __in const PASSPORTCREDCUSTOMUI * pcuiCustomUI,
            __out PassportUIAuthContextHandle * ppachAuthContext);

    /***************************************************************************
     * GetPreferredAuthUIContextSize
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Returns the preferred screen dimensions for an AuthUIContext.
     *      This may change depending upon the state of the identity handle
     *      (some error flows recommend a large window). Therefore the
     *      authentication and request states of the given identity
     *      will be taken into account.
     *
     * INPUTS
     *      hIdentity - Optional identity to return the preferred dimensions
     *          for. Of a NULL handle is given, the preferred dimensions for
     *          initial authenticaiton are returned.
     *
     * RESULTS
     *      Returns the width and height that are preferred to perform
     *      an authentication with UI for the given identity.
     *
     **************************************************************************/

IDCRL_API GetPreferredAuthUIContextSize(
        __in PassportIdentityHandle hIdentity,
        __out SIZE * pszSize
        );

    /***************************************************************************
     * MoveAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Allows a hosting application to change the size of an
     *      authentication UI context that has already been created. This
     *      is most useful to handling error flows, etc. where the size
     *      returned by GetPreferredAuthUIContextSize indicates a different
     *      size would be more appropriate.
     *
     * INPUTS
     *      hAuthContext - Authentication context to resize and/or move
     *      szNewSize - New size for the authentication context
     *
     * RESULTS
     *      The authentication context is resized.
     *
     **************************************************************************/

IDCRL_API MoveAuthUIContext(
        __in PassportUIAuthContextHandle hAuthContext,
        __in POINT ptPosition,
        __in SIZE szNewSize
        );

    /***************************************************************************
     * DestroyPassportAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Destroys a previously-allocated UI context, freeing the resources
     *      associated with it.
     *
     **************************************************************************/
IDCRL_API DestroyPassportAuthUIContext(
        __in PassportUIAuthContextHandle pachAuthContext);

    /***************************************************************************
     * SetCredential
     *
     * DESCRIPTION
     *      Sets a specified credential on the given identity handle. Any
     *      set credential will be used, as-needed, for all future authentication
     *      requests on this identity.
     *
     * INPUTS
     *      hIdentity - Identity handle to close.
     *      wszCredType - Credential type to set (from PPCRL_CREDTYPE_*
     *                  definitions, above).
     *      wszCredValue - Credential to associate with the identity.
     *
     **************************************************************************/
IDCRL_API SetCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType,
        __in LPCWSTR wszCredValue);

    /***************************************************************************
     * SetIdentityCallback
     *
     * DESCRIPTION
     *      Associates a callback procedure with the identity for asynchronous
     *      functionality. Any identity without an associated callback will
     *      operate synchronously.
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API SetIdentityCallback(
        __in PassportIdentityHandle hIdentity,
        __in IdentityChangedCallback pfCallbackNotification,
        __in_opt void * pvCallbackData
        );


    /***************************************************************************
     * CancelPendingRequest - Added in 3.2
     *
     * DESCRIPTION
     *      Cancel the pending request, so callback function will not be called
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API CancelPendingRequest(
        __in PassportIdentityHandle hIdentity
        );


    /***************************************************************************
     * LogonIdentity(Ex)
     *
     * DESCRIPTION
     *      Fundamental call of the Passport client runtime library. Allows
     *      the creation of an authenticated identity. This version of the
     *      call allows credentials to be provided by the calling application.
     *
     * RESULTS
     *      Upon success, the given identity handle will possess the
     *      appropriate authentication state based on the credentials
     *      presented.
     *
     *      Service tokens are requested with Ex version.
     *      the service tokens will be put in cache, use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     **************************************************************************/
IDCRL_API LogonIdentity(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags // From LOGON_FLAG enum above
        );

IDCRL_API LogonIdentityEx(  // new for 3.2
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszAuthPolicy,
        __in DWORD dwAuthFlags, // From LOGON_FLAG enum above
        __in_opt PCRSTParams pcRSTParams,   // service tokens requests
        __in_opt DWORD       dwRSTParamsCount
        );


    /***************************************************************************
     * BuildAuthTokenRequest INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      Get XML that would be sent out in LogonIdentity API
     *
     *
     **************************************************************************/
IDCRL_API BuildAuthTokenRequest(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags,
        __out LPWSTR * pszRequestXML
        );

// TODO: rename the existing function as its internal
IDCRL_API BuildAuthTokenRequestEx(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags,
        __in_opt PCRSTParams pcRSTParams,   // service tokens requests
        __in_opt DWORD       dwRSTParamsCount,
        __out LPWSTR * szRequestXML
        );

    /***************************************************************************
     * GetWebAuthUrl
     *
     * DESCRIPTION
     *      Get Url and post data for web authentication. E.g. for hotmail inbox
     * INPUTS
     *      hIdentity: Identity handle created previously
     *      szTargetServiceName: Reserved
     *      szServicePolicy:     Reserved
     *      szAdditionalPostParams: Other params required for the call the core
     *      params computed by the API. For MD5, these include: ru, kv, svc, rru,
     *      id and sid.
     *      szSourceServiceName: Service name used earlier to authenticate the user
     *      pszWebAuthUrl: Output param that holds the URL to post the data
     *      pszPostData: Post data to be sent with the request, it includes the
     *      additional post params specified in szAdditionalPostParams
     * RESULTS
     *      Upon success, the API will give a URL with a blob of data that
     *      can be POSTed to the URL for authentication
     * NOTES
     *      Calling application must set the following header:
     *            Content-Type: application/x-www-form-urlencoded
     *      for the POST request to be accepted by the login server.
     **************************************************************************/
IDCRL_API GetWebAuthUrl(
            __in     PassportIdentityHandle hIdentity,
            __in_opt LPCWSTR                szTargetServiceName,
            __in_opt LPCWSTR                szServicePolicy,
            __in     LPCWSTR                szAdditionalPostParams,
            __in     LPCWSTR                szSourceServiceName,
            __out    LPWSTR *               pszWebAuthUrl,
            __out    LPWSTR *               pszPostData);

    /***************************************************************************
     * GetWebAuthUrlEx
     *
     * DESCRIPTION
     *      Get Url and post data for web authentication. E.g. for hotmail inbox
     * INPUTS
     *      hIdentity: Identity handle created previously
     *      szTargetServiceUrl: target service url. If you specify the svc
     *      or ru param in additional post data, you must NOT specify this.
     *      szServicePolicy:     policy for the service ticket
     *      szAdditionalPostParams: Other params required for the call the core
     *      params computed by the API. 
     *      pszWebAuthUrl: Output param that holds the URL to post the data
     *      pszPostData: Post data to be sent with the request, it includes the
     *      additional post params specified in szAdditionalPostParams
     * RESULTS
     *      Upon success, the API will give a URL with a blob of data that
     *      can be POSTed to the URL for authentication, this is using PSHA1Auth
     *      E_INVALIDARG
     *      PP_E_CRL_NOT_INITIALIZED
     *      PP_E_CRL_NO_SUCH_IDENTITY
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PPCRL_E_NO_SESSION_KEY
     *      E_OUTOFMEMORY
     *
     * NOTES
     *      Calling application must set the following header:
     *            Content-Type: application/x-www-form-urlencoded
     *      for the POST request to be accepted by the login server.
     **************************************************************************/
     
    typedef enum {
        IDCRL_WEBAUTH_NONE                  = 0x00000000,
        IDCRL_WEBAUTH_REAUTH                = 0x00000001
    } IDCRL_WEBAUTHOPTION;
    
IDCRL_API GetWebAuthUrlEx(
            __in     PassportIdentityHandle hIdentity,
            __in     DWORD                  dwFlags,              // IDCRL_WEBAUTHOPTION
            __in_opt LPCWSTR                szTargetServiceUrl,
            __in_opt LPCWSTR                szServicePolicy,
            __in     LPCWSTR                szAdditionalPostParams,
            __out    LPWSTR *               pszWebAuthUrl,
            __out    LPWSTR *               pszPostData);



    /***************************************************************************
     * LogonIdentityWithUI
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Requests an authentication using the client runtime's built-in
     *      user interface for credential collection and error handling.
     *
     *      UI-based authentications are always asynchronous in nature (as
     *      they depend on user input), so a valid call-back is required.
     *      This also means that this call always returns immediately
     *      to the caller, and the authentication process occurs over
     *      time as Windows messages are pumped and the library is
     *      able to interact with the user and the auth servers.
     *
     * INPUTS
     *      pachAuthContext - The UI authentication context to be used
     *          for this authentication. This comes from
     *          CreatePassportAuthUIContext function, above.
     *      pihUser - Identity handle to authenticate.
     *      szPolicy - Optional policy to apply to the authentication
     *      dwAuthFlags - Flags controlling the authentication.
     *
     * RESULTS
     *      Upon success, the given identity handle will possess the
     *      appropriate authentication state based on the credentials
     *      presented.
     *
     *      Service tokens are requested with Ex version.
     *      the service tokens will be put in cache, use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     **************************************************************************/
IDCRL_API LogonIdentityWithUI(
        __in PassportUIAuthContextHandle pachAuthContext,
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags // From LOGON_FLAG enum above
        );


	/***************************************************************************
	 * Names of credential properties
	 * These can be used with GetIdentityPropertyByName API
	***************************************************************************/
	#define PPCRL_CREDPROPERTY_MEMBER_NAME            L"MemberName"
	#define PPCRL_CREDPROPERTY_PUIDSTR                L"PUID"
	#define PPCRL_CREDPROPERTY_ONETIMECREDENTIAL      L"OneTimeCredential"
	#define PPCRL_CREDPROPERTY_CID                    L"CID"
	#define PPCRL_CREDPROPERTY_MAINBRANDID            L"MainBrandID"
	#define PPCRL_CREDPROPERTY_BRANDIDLIST            L"BrandIDList"
	#define PPCRL_CREDPROPERTY_ISWINLIVEUSER          L"IsWinLiveUser"

	/***************************************************************************
     * PASSPORTIDENTITYPROPERTY enum
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Used for retrieving properties about a given identity handle.
     *      This enum is used with the now deprecated GetIdentityProperty API.
     *      Apps should use GetIdentityPropertyByName to get all properties.
     *
     **************************************************************************/
    typedef enum _PASSPORTIDENTITYPROPERTY
    {
        IDENTITY_MEMBER_NAME        = 1,
        IDENTITY_PUIDSTR            = 2
    } PASSPORTIDENTITYPROPERTY;

    /***************************************************************************
     * GetIdentityProperty
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Retrieves the value of a property associated with an identity handle.
     *      This API is deprecated. Use GetIdentityPropertyByName instead.
     *
     * RESULTS
     *      Upon success, the value of the property will be stored on the
     *      szPropertyValue buffer. The buffer must be freed with a call
     *      to
     *
     **************************************************************************/
IDCRL_API GetIdentityProperty(
        __in PassportIdentityHandle hIdentity,
        __in PASSPORTIDENTITYPROPERTY ipProperty,
        __out LPWSTR * szPropertyValue
        );

    /***************************************************************************
     * GetIdentityPropertyByName
     *
     * DESCRIPTION
     *      Retrieves the value of a property associated with an identity handle.
     *
     * RESULTS
     *      Upon success, the value of the property will be stored on the
     *      wszPropertyValue buffer. The buffer must be freed with a call
     *      to
     *
     **************************************************************************/
IDCRL_API GetIdentityPropertyByName(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszPropertyName,
        __out LPWSTR * pwszPropertyValue);

    /***************************************************************************
     * SetIdentityProperty
     *
     * DESCRIPTION
     *      Sets the specified property on the identity. Note that not all
     *      properties are settable. Currently apps may only set IDENTITY_MEMBER_NAME
     *      using this API.
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API SetIdentityProperty(
        __in PassportIdentityHandle hIdentity,
        __in PASSPORTIDENTITYPROPERTY ipProperty,
        __in LPCWSTR wszPropertyValue
        );

    /***************************************************************************
     * GetAuthState
     *
     * DESCRIPTION
     *      Returns the authentication and request state associated
     *      with the given identity handle. This allows the calling
     *      application to determine not only the current authentication
     *      state, but the state of the last request made on behalf
     *      of this identity. The calling application can use this
     *      information to deal with the state/errors appropriately.
     *
     *      The Ex version is used to query states for a particular service token
     *      When wzServiceTarget == NULL, the states from last request is returned
     *
     * RESULTS
     *      Returns the authentication status, the authentication
     *      required (if any), the status of the last request
     *      based on this identity, and may optionally
     *      return a URL that the hosting application can take
     *      the user to in order to explain and/or resolve the
     *      error.
     *
     **************************************************************************/
IDCRL_API GetAuthState(
        __in PassportIdentityHandle hIdentity,
        __out_opt HRESULT * phrAuthState,
        __out_opt HRESULT * phrAuthRequired,
        __out_opt HRESULT * phrRequestStatus,
        __out_opt LPWSTR * szWebFlowUrl = 0
        );

IDCRL_API GetAuthStateEx( // new in 3.2
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR        wzServiceTarget,
        __out_opt HRESULT * phrAuthState,
        __out_opt HRESULT * phrAuthRequired,
        __out_opt HRESULT * phrRequestStatus,
        __out_opt LPWSTR * szWebFlowUrl = 0
        );

    /***************************************************************************
     * EnumIdentitiesWithCachedCredentials
     *
     * DESCRIPTION
     *      Enumerates stored credentials allowing the hosting
     *      application to determine which credentials are
     *      present.
     *
     * INPUTS
     *      szCachedCredType - If non-NULL and non-empty, specifies
     *      the credential type to limit iteration of. For example,
     *      if PPCRL_CREDTYPE_PASSWORD is passed here, only identities
     *      with cached passwords will be iterated. If NULL or an
     *      empty string is passed here, then all identities with
     *      any type of cached credential will be iterated.
     *
     * RESULTS
     *      A enumeration handle that allows iteration through
     *      the identities.
     *
     **************************************************************************/
IDCRL_API EnumIdentitiesWithCachedCredentials(
        __in_opt LPCWSTR wszCachedCredType,
        __out PassportEnumIdentitiesHandle * peihEnumHandle
        );

    /***************************************************************************
     * NextIdentity
     *
     * DESCRIPTION
     *      Returns the next identity for the given enumeration handle.
     *
     * INPUTS
     *      hEnumHandle - Handle as returned from EnumIdentities* call
     *      above.
     *
     * OUTPUTS
     *      szMemberName - The member name with cached credentials
     *
     * NOTES
     *      Any strings returned as outputs must be freed with PassportFreeMemory.
     *      However, if the pointers are passed back in as outputs to
     *      a PPCRL call, any previous string will be correctly freed.
     *
     **************************************************************************/
IDCRL_API NextIdentity(
        __in PassportEnumIdentitiesHandle hEnumHandle,
        __out LPWSTR * wszMemberName
        );

    /***************************************************************************
     * HasPersistedCredential
     *
     * DESCRIPTION
     *      Returns whether or not the specified identity has a persisted
     *      credential of the specified type.
     *
     * INPUTS
     *      hIdentity - the identity to check persisted credentials of
     *      szCredType - the credential type to check for persistence
     *
     * OUTPUTS
     *      pbHasPersistentCred - Whether or not there is a persistent
     *          credential.
     *
     **************************************************************************/
IDCRL_API HasPersistedCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szCredType,
        __out bool * pbHasPersistentCred
        );

    /***************************************************************************
     * PersistCredential
     *
     * DESCRIPTION
     *      Stores, updates and/or deletes stored credentials.
     *
     * INPUTS
     *      pihIdentity - Identity from to persist credentials for.
     *      wszCredType - Credential type on the identity to persist.
     *
     * RESULTS
     *      The persistent credential store is updated based on the
     *      credentials stored on the identity.
     *
     **************************************************************************/
IDCRL_API PersistCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType
        );

    /***************************************************************************
     * RemovePersistedCredential
     *
     * DESCRIPTION
     *      Removes credentials from persistent storage.
     *
     * INPUTS
     *      pihIdentity - Identity from which to remove credentials
     *      wszCredType - Credential type to delete from the store
     *
     * RESULTS
     *      Any previously persisted credential will be deleted from
     *      the store. Any transient credential left on the identity
     *      itself is left unchanged.
     *
     **************************************************************************/
IDCRL_API RemovePersistedCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType
        );

    /***************************************************************************
     * CloseEnumIdentitiesHandle
     *
     * DESCRIPTION
     *      Closes an identity iterator, freeing resource associated with it.
     *
     * INPUTS
     *      hEnumHandle - The iterator to close
     *
     **************************************************************************/
IDCRL_API CloseEnumIdentitiesHandle(
        __in PassportEnumIdentitiesHandle hEnumHandle);

    /***************************************************************************
     * AuthIdentityToService
     *
     * DESCRIPTION
     *      Using an authenticated identity, attempts to retrieve a service
     *      token for that identity to the specified resource. If additional
     *      user interface interaction is required from the user, this
     *      call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      szServiceTarget - URI representing the webservice. This is primarily
     *              to identity the resource and need not necessarily represent
     *              a real service URL.
     *      szServicePolicy - Policy if the application knows
     *              it or can provide it directly. This may be provided by the
     *              hosting application directly or extract from the application-
     *              level challenge from an initial attempt to access the
     *              resource.
     *
     * OUTPUTS
     *      pcbSessionKey / pcbSessionKeyLength - If the service token format
     *              supports it, this will return a session key to the hosting
     *              application that matches the symmetric session key inside
     *              the service token. This key material is binary, so care
     *              should be taken to not utilize any manipulations that
     *              may terminate on embedded null or non-printable characters.
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API AuthIdentityToService(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget,
        __in_opt LPCWSTR szServicePolicy,
        __in DWORD dwTokenRequestFlags,
        __out LPWSTR * szToken,
        __out_opt DWORD * pdwResultFlags,
        __out_opt BYTE ** ppbSessionKey,
        __out_opt DWORD * pcbSessionKeyLength
        );

    /***************************************************************************
     * AuthIdentityToServiceEx - added in 3.2
     *
     * DESCRIPTION
     *      Using an authenticated identity, attempts to retrieve a set of
     *      service tokens for that identity to the specified resources.
     *      If additional
     *      user interface interaction is required from the user, this
     *      call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      pcRSTParams - parameters for service tokens
     *      dwRSTParamsCount - number of parameters
     *
     * OUTPUTS
     *      the service tokens will be put in cache if async,
     *      use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API AuthIdentityToServiceEx(
        __in PassportIdentityHandle hIdentity,
        __in DWORD dwRequestFlags,      // Must be 0, Reserved
        __in PCRSTParams pcRSTParams,   // service tokens requests
        __in DWORD       dwRSTParamsCount
        );

    /***************************************************************************
     * CERTREQUESTFLAGS enum
     *
     * DESCRIPTION
     *      flags for GetCertificate call.
     *
     **************************************************************************/
    typedef enum _CERTREQUESTFLAGS
    {
        //
        // If CERT_FROM_CACHE is set, a call only checks cache
        // if CERT_FROM_NETWORK is set, request always results in a network call
        // if neither is set: a cached one is returned if a cacked one satisfies the TTL
        // otherwise, it results in a network call
        //
        CERT_FROM_CACHE                    = SERVICE_TOKEN_FROM_CACHE,
        CERT_FROM_SERVER                   = 0x00020000,

    } CERTREQUESTFLAGS;


    /***************************************************************************
     * GetCertificate - added in 3.2
     *
     * DESCRIPTION
     *      Using an authenticated identity to get a certficate for this user
     *      for that identity to the specified service name.
     *      If additional user interface interaction is required from the user,
     *      this call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      pcRSTParams - parameters for the certificate request
     *      pdwTTL      - If getting from cache, as input, minimum acceptable TTL
     *                    as output, actual remaining TTL. Has no effect for a
     *                    new certificate request from network.
     *      dwRequestFlags - indicate if the cert should be from the cache
     *
     *
     * OUTPUTS
     *      ppCertContext - the cert context, this context can be used with
     *           cryto API for cert/public key/private key related operations.
     *           IDCRL maitains the private key for this cert.  It clears
     *           the private key when it requesing a new cert from passport.
     *           Application must call CertFreeCertificateContext and
     *           stop using the certcontext before the next GetCerficate call.
     *      ppbPOP     - Optional parameter to receive the proof of possession
     *           blob. Applications can give this blob to VerifyCertificate API
     *           to perform POP check on the certificate. Application must free
     *           it with PassportFreeMemory API after using.
     *      pcbPOP     - If ppbPOP is not NULL, you must also pass this parameter
     *           to get the size of the POP blob.
     *      ppCACertContext - Optional parameter to receive the CA certificate
     *           context. Application must free it with CertFreeCertificateContext
     *           API after using. The CA cert context may be expired in time but
     *           corresponds to the signature on the subject certificate.
     *
     * RESULTS
     *      S_OK if successful
     *      PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
     *
     **************************************************************************/
IDCRL_API GetCertificate(
        __in PassportIdentityHandle hIdentity,
        __in PCRSTParams     pcRSTParams,
        __inout DWORD *      pdwTTL,           // determines TTL if get from cache
                                                // this doesn't control the TTL
                                                // for a new cert. in seconds
        __in DWORD           dwRequestFlags,    // 0 or CERT_FROM_CACHE
                                                //      CERT_FROM_NETWORK
        __out     PCCERT_CONTEXT* ppCertContext,   // Cert context
        __out_opt BYTE**          ppbPOP = NULL,          // Optional POP blob
        __out_opt DWORD*          pcbPOP = NULL,          // Size of POP blob
        __out_opt PCCERT_CONTEXT* ppCACertContext = NULL  // CA Cert context
        );


    /***************************************************************************
     * BuildServiceTokenRequest - INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      Get XML string for Service request, without sending the request
     *
     * INPUTS - see AuthIdentityToService
     *
     * OUTPUTS
     *      szXML: the request in xml format
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API BuildServiceTokenRequest(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget,
        __in_opt LPCWSTR szServicePolicy,
        __in DWORD dwTokenRequestFlags,
        __out LPWSTR * szRequestXML
        );

// TODO: change name: new for 3.2
IDCRL_API BuildServiceTokenRequestEx(
        __in PassportIdentityHandle hIdentity,
        __in PCRSTParams pcRSTParams,   // service tokens requests
        __in DWORD       dwRSTParamsCount,
        __out LPWSTR * szRequestXML
        );


    /***************************************************************************
     * RESPONSE_TYPE enum
     *
     * DESCRIPTION
     *      flags for the internal PutTokenResponse function.
     *
     **************************************************************************/
    typedef enum _RESPONSE_TYPE
    {
        //
        // RESPONSE_TYPE_AUTH indicates response to an auth request.
        // RESPONSE_TYPE_SERVICE indicates responset to a service token request.
        //
        PPCRL_RESPONSE_TYPE_AUTH                    = 0x00000000,
        PPCRL_RESPONSE_TYPE_SERVICE                 = 0x00000001,

    } RESPONSE_TYPE;

    /***************************************************************************
     * PutTokenResponse - INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      parse the RST response XML, and put tokens in cache,
     *      by putting a Auth response using this API, IDCRL can be used to
     *      request service tokens. Response type must be RESPONSE_TYPE_AUTH
     *      or RESPONSE_TYPE_SERVICE.
     *
     * NOTE
     *      Removed out params from function in 3.2 because nobody uses them.
     *      Changed to use enum to indicate auth vs service response
     *
     **************************************************************************/
IDCRL_API PutTokenResponse(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
        __in LPCWSTR  szResponse,
        __out_opt LPWSTR * szToken,
        __out_opt DWORD * pdwResultFlags,
        __out_opt BYTE ** ppbSessionKey,
        __out_opt DWORD * pcbSessionKeyLength
        );

// new for 3.2
IDCRL_API PutTokenResponseEx(
        __in PassportIdentityHandle hIdentity,
        __in DWORD    dwResponseType,
        __in LPCWSTR  szResponse
        );

    /***************************************************************************
     * DeriveOfflineKey
     *
     * DESCRIPTION
     *      For offline scenarios, this method can be used to return a key
     *      derived from the user's credentials.
     *
     * INPUTS
     *      hIdentity       - Identity handle holding credentials from
     *                        which to derive the offline key.
     *      okmMethod       - Desired method of offline key derivation
     *      vpOfflineKeyParameters - Parameters for the key
     *                        derivation. These are dependent upon okmMethod
     *
     * OUTPUTS
     *      vpOfflineKeyMaterial - Buffer to accept raw key material if
     *                        it is desired. Buffer must be at least large
     *                        enough to accept the key material appropriate
     *                        for the derivation method (e.g., for PBKDF2
     *                        this is defined by the cbDerivedKeyLength
     *                        parameter).
     *      phSessionKey    - CryptoAPI key handle with the key material
     *                        imported into it.
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
#ifdef  __PPCRL_SUPPORT_OFFLINE_KEY
IDCRL_API DeriveOfflineKey(
        __in PassportIdentityHandle hIdentity,
        __in OfflineKeyMethod okmMethod,
        __in_opt void * vpOfflineKeyParameters,
        __out_opt void * vpOfflineKeyMaterial,
        __in_opt HCRYPTPROV hCryptProv,
        __out_opt HCRYPTKEY * phSessionKey
        );

#endif // #ifdef  __PPCRL_SUPPORT_OFFLINE_KEY

    /***************************************************************************
     * PassportFreeMemory
     *
     * DESCRIPTION
     *      Frees buffers allocated and returned by the client runtime library.
     *
     * INPUTS
     *      TBD
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API PassportFreeMemory(
        __in void * pMemoryToFree
        );

    /***************************************************************************
     * VerifyCertificate
     *
     * DESCRIPTION
     *      check if the cert can be chained back to one of the certs in config.
     *
     * INPUTS
     *      PCERT_CONTEXT - Pointer to a cert context of the certificate you
     *      dwTTL         - As input, it is the minimum acceptable TTL, as output
     *                      it is the actual remaining TTL.
     *      pbPOP         - POP blob to verify
     *      cbPOP         - size of the pop blob in bytes
     *      ppCACertContext - Optional parameter to receive the CA certificate
     *           context. Application must free it with CertFreeCertificateContext
     *           API after using. The CA cert context may be expired in time but
     *           corresponds to the signature on the subject certificate.
     *
     * RESULTS
     *      S_OK if the cert matches. S_FALSE if no match present, and E_INVALIDARG if invalid args passed in
     *      PPCRL_S_OK_CLIENTTIME if the clock skew is not set
     *
     **************************************************************************/
IDCRL_API VerifyCertificate(
        __in PCCERT_CONTEXT pCertContext,
        __inout DWORD *     pdwTTL,
        __in_opt    BYTE*       pbPOP = NULL,           //  POP blob
        __in_opt    DWORD       cbPOP = 0,              // size of POP blob
        __out_opt   PCCERT_CONTEXT* ppCACertContext = NULL // CA cert context
        );


    /***************************************************************************
     * GetExtendedError
     *
     * DESCRIPTION
     *      Gives extended error information for certain IDCRL error conditions.
     *      Its functionality is similar to GetLastError system API at the identity
     *      handle scope.
     *
     * INPUTS
     *      hIdentity: Identity handle.
     *
     * OUTPUT
     *      pdwCategory: error category, from the IDCRL_ERROR_CATEGORY enum.
     *      pdwError:    Actual error code. It will be the unmasked error at the
     *                   point of failure. The error is from the PPCRL_E_SQM_
     *                   errors defined in this file.
     *      pszErrorBlob: A string blob with additional error information (trace
     *      statements, request or response data, etc).
     *
     * RESULT
     *       PPCRL_E_EXTENDED_ERROR_NOT_SET: You must initialize IDCRL with the
     *       SET_EXTENDED_ERROR  flag to set extended error information.
     *
     *       S_FALSE: No extended error information is set on this identity handle.
     *
     * NOTES
     *      The error state is reset when the application calls any IDCRL API
     *      except GetAuthState(Ex).
     *      Caller must free pszErrorBlob by calling PassportFreeMemory when done.
     *
     **************************************************************************/

typedef enum _IDCRL_ERROR_CATEGORY
{
    IDCRL_REQUEST_BUILD_ERROR               = 0x00000001,
    IDCRL_REQUEST_SEND_ERROR                = 0x00000002,
    IDCRL_RESPONSE_RECEIVE_ERROR            = 0x00000003,
    IDCRL_RESPONSE_READ_ERROR               = 0x00000004,
    IDCRL_REPSONSE_PARSE_ERROR              = 0x00000005,
    IDCRL_RESPONSE_SIG_DECRYPT_ERROR        = 0x00000006,
    IDCRL_RESPONSE_PARSE_HEADER_ERROR       = 0x00000007,
    IDCRL_RESPONSE_PARSE_TOKEN_ERROR        = 0x00000008,
    IDCRL_RESPONSE_PUTCERT_ERROR            = 0x00000009
} IDCRL_ERROR_CATEGORY;

IDCRL_API GetExtendedError(
    __in      PassportIdentityHandle hIdentity,
    __in      LPVOID   pReserved,
    __out     DWORD   *pdwCategory,
    __out     DWORD   *pdwError, 
    __out_opt LPWSTR  *pszErrorBlob);

    /***************************************************************************
     * ExportAuthState - Export AuthToken into a blob
     *
     * DESCRIPTION
     *      Export authenticate token and its session key into an xml blob
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      wszAuthToken: the request in xml format
     *             
     * NOTE: 
     *      wszAuthToken: should be free'ed with PassportFreeMemory
     * RESULTS
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      E_INVALIDARG
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PP_E_CRL_NOT_INITIALIZED
     *      
     *
     **************************************************************************/
IDCRL_API ExportAuthState(
        __in PassportIdentityHandle hIdentity,
        __in DWORD dwFlags,                 //  == 0, reserved 
        __out LPWSTR * wszAuthToken
        );

    /***************************************************************************
     * CreateIdentityHandleFromAuthState - create an identity handle, and import
     *                                     the authtoken blob
     *
     * DESCRIPTION
     *      wszAuthToken: the auth token
     *      dwFlags:      IDENTITY_FLAG
     * INPUTS - 
     *
     * OUTPUTS
     *      pihIdentity: the identity handle, this should be closed by: CloseIdentityHandle
     *
     * RESULTS
     *      E_INVALIDARG
     *      E_POINTER  -- when pihIdentity is NULL
     *      PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
     *      PP_E_CRL_NOT_INITIALIZED
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandleFromAuthState(
        __in LPCWSTR wszAuthToken,
        __in DWORD dwFlags,                             // IDENTITY_FLAG
        __out PassportIdentityHandle * pihIdentity);


    /***************************************************************************
     * CacheAuthState - cache auth state for a virtual application
     *
     * DESCRIPTION
     *      hIdentity: identity handle
     *      wszVirtualAppName: the name of the virtual application - suggest GUID
     *      dwFlags: reserved
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      write auth state block in cred manager under the virutal application
     *
     * RESULTS
     *      E_INVALIDARG
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PPCRL_E_AUTHBLOB_TOO_LARGE (64 * 256 bytes)
     *      
     *
     **************************************************************************/
IDCRL_API CacheAuthState(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszVirtualAppName,     // required
        __in DWORD dwFlags                 //  == 0, reserved 
        );

    /***************************************************************************
     * RemoveAuthStateFromCache - remove cached auth state for a virtual application
     *
     * DESCRIPTION
     *      hIdentity: identity handle - can be NULL, when NULL, user name is
     *                 not checked, and all users removed under the same virtual app
     *      wszVirtualAppName: the name of the virtual application - can be NULL,
     *                         when NULL, virtual app name is not checked, and all removed
     *      dwFlags: reserved
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      write auth state block in cred manager under the virutal application
     *
     * RESULTS
     *      PPCRL_E_AUTHBLOB_NOT_FOUND
     *
     **************************************************************************/
IDCRL_API RemoveAuthStateFromCache(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszVirtualAppName,     // required
        __in DWORD dwFlags                 //  == 0, reserved 
        );

    /***************************************************************************
     * CreateIdentityHandleFromCachedAuthState - create an identity handle, and import
     *                                     the authtoken blob from cache
     *
     * DESCRIPTION
     *      wszUserName: the name of the user - NULL, any user
     *      wszVirtualAppName: the name of the virtual app - NULL, any app
     *      dwFlags: IDENTITY_FLAG
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      pihIdentity: the identity handle, this should be closed by: CloseIdentityHandle
     *
     * RESULTS
     *      E_INVALIDARG
     *      E_POINTER  -- when pihIdentity is NULL
     *      PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
     *      PP_E_CRL_NOT_INITIALIZED
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandleFromCachedAuthState(
        __in_opt LPCWSTR wszUserName,
        __in LPCWSTR wszVirtualAppName,
        __in DWORD dwFlags,                             // IDENTITY_FLAG
        __out PassportIdentityHandle * pihIdentity);


//
// extended properties for all the users on the windows logon session
#define EXT_PROPERTY_NAME_PUBLICCOMPUTER    L"PublicComputer"
#define EXT_PROPERTY_VALUE_TRUE             L"1"
#define EXT_PROPERTY_VALUE_FALSE            L"0"
#define EXT_PROPERTY_VALUE_REMOVE           NULL

/***************************************************************************
 * SetExtendedProperty - set name value pair - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *      wszPropertyValue: value of the property, NULL or empty string will delete an existing value
 *
 * INPUTS - 
 *
 * OUTPUTS
 *
 * RESULTS
 *      E_INVALIDARG
 *      Error from registry access API:RegOpenKeyEx RegSetValueEx RegDeleteValue
 *
 **************************************************************************/
IDCRL_API SetExtendedProperty(
        __in LPCWSTR wszPropertyName,
        __in LPCWSTR wszPropertyValue);

/***************************************************************************
 * GetExtendedProperty - get the value for a given name - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *
 * INPUTS - 
 *
 * OUTPUTS
 *      pwszPropertyValue: value of the property, IDCRL allocates the buffer, and it 
 *                         should be freed with PassportFreeMemory call
 *
 * RESULTS
 *      
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_CRL_NOT_INITIALIZED
 *      Error from registry access API:RegOpenKeyEx RegGetValueEx
 *
 **************************************************************************/
IDCRL_API GetExtendedProperty(
        __in LPCWSTR wszPropertyName,
        __out LPWSTR* pwszPropertyValue);

/***************************************************************************
 * GetServiceConfig - get config settings in the config xml
 *
 * DESCRIPTION
 *
 * INPUTS - 
 *      wszServiceName: name of the entry
 *
 * OUTPUTS
 *      pwszURLValue: IDCRL allocates the buffer, which should be released with 
 *                    PassportFreeMemory call
 *
 * RESULTS
 *      E_INVALIDARG
 *      S_FALSE : not found
 *
 **************************************************************************/
IDCRL_API GetServiceConfig(
        __in LPCWSTR wszValueName,
        __out LPWSTR* pwszURLValue);

/***************************************************************************
 * MigratePersistedCredentials - migrate the users from registry to cred man for a specific app
 *
 * DESCRIPTION
 *
 * INPUTS - 
 *      guid: the GUID of the app
 *      bKeepOldCreds: If true, IDCRL will NOT delete old credentials after migrating
 *      to Credman store. This is application for scenarios where a user may want
 *      to downgrade to a previous version of the app.
 *      Note: It is a security risk to preserve old credentials and apps should
 *      make the decision to keep or delete them carefully.
 *
 * OUTPUTS
 *      dwUserCount: number of users being migrated 
 *
 * RESULTS
 *      E_INVALIDARG
 *
 **************************************************************************/
IDCRL_API MigratePersistedCredentials(
        __in REFGUID guid,
        __in bool    bKeepOldCreds,
        __out_opt DWORD* pdwUserCount);


/***************************************************************************
 * SetIdcrlOptions
 *
 * DESCRIPTION
 *      Call this to update optional settings for IDCRL. You may call it
 *      after Initializing IDCRL to update settings.
 *
 * INPUTS
 *      pOptions - Additional options to set. e.g. proxy information.
 *      dwOptions - count of options in pOptions.
 *      dwFlags   - Flags to the API, current supported flags are defined in
 *                  IDCRL_SETOPTIONS_FLAG enum. Default behavior is to set the
 *                  options. This API does not take IDCRL_OPTION_ENVIRONMENT
 *                  flag.
 *      
 * RETURN
 *      PPCRL_E_INVALIDFLAGS
 *      PP_E_CRL_NULL_OPTION
 *      PP_E_CRL_BAD_OPTIONLENGTH
 *      PP_E_CRL_PROXYLIST_TOOLONG
 *      PP_E_CRL_PROXYBYPASSLIST_TOOLONG
 *
 * REMARKS
 *      IDCRL_SETOPTIONS_SET and IDCRL_SETOPTIONS_RESET flags are mutually
 *      exclusive.
 *
 **************************************************************************/
IDCRL_API SetIdcrlOptions(
        __in LPIDCRL_OPTION  pOptions,
        __in DWORD           dwOptions,
        __in_opt DWORD       dwFlags = IDCRL_SETOPTIONS_DEFAULT);

/***************************************************************************
 * EncryptWithSessionKey
 *
 * DESCRIPTION
 *      Call this to encrypt data blob with session key in the service token
 *      the encrypted blob can be sent to the target service
 *
 * INPUTS
 *
 * OUTPUTS
 *      ppbCipher   - IDCRL will allocate buffer upon success, PassportFreeMemory 
 *                    should be used to free the memory
 *      
 * RETURN
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_CRL_NO_SUCH_IDENTITY
 *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
 *      PPCRL_E_NO_SESSION_KEY
 *
 * REMARKS
 *     3DES and HMAC_SHA1 are used
 *
 **************************************************************************/
IDCRL_API EncryptWithSessionKey(
    __in PassportIdentityHandle hIdentity,
    __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
    __in ALG_ID  algIdEncrypt,
    __in ALG_ID  algIdHash,
    __in BYTE*   pData,
    __in DWORD   cbData,
    __out BYTE ** ppbCipher,
    __out DWORD * pcbCipher);

/***************************************************************************
 * DecryptWithSessionKey
 *
 * DESCRIPTION
 *      Call this to decrypt data encrypted with EncryptWithSessionKey, 
 *      this data can be from IDCRL or RPS on the service target machine
 *
 * INPUTS
 *
 * OUTPUTS
 *      ppbCipher   - IDCRL will allocate buffer upon success, PassportFreeMemory 
 *                    should be used to free the memory
 *      
 * RETURN
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_SESSIONKEY_INVALIDDATA
 *      PP_E_SESSIONKEY_INVALIDSIGNATURE
 *      PPCRL_E_NO_SESSION_KEY
 *
 * REMARKS
 *     3DES and HMAC_SHA1 are used
 *
 **************************************************************************/
IDCRL_API DecryptWithSessionKey(
    __in PassportIdentityHandle hIdentity,
    __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
    __in ALG_ID  algIdEncrypt,
    __in ALG_ID  algIdHash,
    __in BYTE*   pCipher,
    __in DWORD   cbCipher,
    __out BYTE ** ppbData,
    __out DWORD * pcbData);


//
// extended user properties for all the users on the windows logon session
#define EXT_USER_PROPERTY_NAME_USERTILEURL    L"UserTileUrl"
#define EXT_USER_PROPERTY_NAME_IDTILETIMESTAMP L"IDTileTimestamp"

#define EXT_USER_PROPERTY_VALUE_REMOVE           NULL

/***************************************************************************
 * SetUserExtendedProperty - set name value pair - per windows logon property
 *
 * DESCRIPTION
 *      wszMemberName: 
 *      wszPropertyName: name of the property
 *      wszPropertyValue: value of the property, NULL or empty string will delete an existing value
 *
 *    can only set the property if the user chosed to store his/her user name
 *
 * INPUTS - 
 *
 * OUTPUTS
 *
 * RESULTS
 *      E_INVALIDARG
 *      PPCRL_E_USER_NOTFOUND
 *      Error from registry access API:RegOpenKeyEx RegSetValueEx RegDeleteValue
 *
 **************************************************************************/
IDCRL_API SetUserExtendedProperty(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszPropertyName,
        __in LPCWSTR wszPropertyValue);

/***************************************************************************
 * GetUserExtendedProperty - get the value for a given name - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *
 * INPUTS - 
 *
 * OUTPUTS
 *      pwszPropertyValue: value of the property, IDCRL allocates the buffer, and it 
 *                         should be freed with PassportFreeMemory call
 *
 * RESULTS
 *      
 *      E_INVALIDARG
 *      PPCRL_E_USER_NOTFOUND
 *      Error from registry access API:RegOpenKeyEx RegGetValueEx
 *
 **************************************************************************/
IDCRL_API GetUserExtendedProperty(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszPropertyName,
        __out LPWSTR* pwszPropertyValue);


/***************************************************************************
 * SetChangeNotificationCallback
 *
 * ADDED IN RELEASE
 *      4.0
 *
 * DESCRIPTION
 *      Registers the callback for user account state change notifications.
 *
 *      Current triggers for notifications are:
 *      1. PersistCredential and the credential was not previously persisted.
 *      2. RemovePersistedCredential and the cred was previously persisted.
 *      3. SetUserExtendedProperty (always).
 *
 * INPUTS -
 *     wszVirtualApp: Name of the virtual application.
 *     dwReserverd: Reserved
 *     UserStateChangedCallback: Pointer to the application's callback function.
 *     See UserStateChangedCallback in the header file for the signature.
 *
 * RESULTS
 *      
 *      S_OK
 *
 **************************************************************************/
IDCRL_API SetChangeNotificationCallback(
       __in LPCWSTR wszVirtualApp, 
       __in DWORD dwReserved, 
       __in UserStateChangedCallback pfCallbackNotification);

/***************************************************************************
 * RemoveChangeNotificationCallback
 *
 * ADDED IN RELEASE
 *      4.0
 *
 * DESCRIPTION
 *      Removes the callback for user account state change notifications
 *
 * INPUTS -
 *
 * RESULTS
 *      
 *      S_OK
 *
 **************************************************************************/
IDCRL_API RemoveChangeNotificationCallback();

#ifdef __cplusplus
} // Namespace IDCRL
#endif


#ifdef __cplusplus
}; // extern "C"
#endif


#endif /* not defined PPCRL_SCRIPT_ERROR_CODES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\PassportIDCRL\4.0\Debug\specstrings.h ===
/***************************************************************\
*                                                               *
* SpecStrings.h - markers for documenting the semantics of APIs *
*                                                               *
* Version 1.0                                                   *
*                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                               *
\***************************************************************/

// @@BEGIN_DDKSPLIT

// -------------------------------------------------------------------------------
// Introduction
//
// SpecStrings.h provides a set of annotations to describe how a function uses its
// parameters - the assumptions it makes about them, and the guarantees it makes
// upon finishing.
//
// Annotations may be placed before either a function parameter's type or its return
// type, and describe the function's behavior regarding the parameter or return value.
// There are two classes of annotations: buffer annotations and advanced annotations.
// Buffer annotations describe how functions use their pointer parameters, and
// advanced annotations either describe complex/unusual buffer behavior, or provide
// additional information about a parameter that is not otherwise expressible.
//
// -------------------------------------------------------------------------------
// Buffer Annotations
//
// The most important annotations in SpecStrings.h provide a consistent way to annotate
// buffer parameters or return values for a function. Each of these annotations describes
// a single buffer (which could be a string, a fixed-length or variable-length array,
// or just a pointer) that the function interacts with: where it is, how large it is,
// how much is initialized, and what the function does with it.
//
// The appropriate macro for a given buffer can be constructed using the table below.
// Just pick the appropriate values from each category, and combine them together
// with a leading underscore. Some combinations of values do not make sense as buffer
// annotations. Only meaningful annotations can be added to your code; for a list of
// these, see the buffer annotation definitions section.
//
// Only a single buffer annotation should be used for each parameter.
//
// |------------|------------|---------|--------|----------|---------------|
// |   Level    |   Usage    |  Size   | Output | Optional |  Parameters   |
// |------------|------------|---------|--------|----------|---------------|
// | <>         | <>         | <>      | <>     | <>       | <>            |
// | _deref     | _in        | _ecount | _full  | _opt     | (size)        |
// | _deref_opt | _out       | _bcount | _part  |          | (size,length) |
// |            | _inout     |         |        |          |               |
// |            |            |         |        |          |               |
// |------------|------------|---------|--------|----------|---------------|
//
// Level: Describes the buffer pointer's level of indirection from the parameter or
//          return value 'p'.
//
// <>         : p is the buffer pointer.
// _deref     : *p is the buffer pointer. p must not be NULL.
// _deref_opt : *p may be the buffer pointer. p may be NULL, in which case the rest of
//                the annotation is ignored.
//
// Usage: Describes how the function uses the buffer.
//
// <>     : The buffer is not accessed. If used on the return value or with _deref, the
//            function will provide the buffer, and it will be uninitialized at exit.
//            Otherwise, the caller must provide the buffer. This should only be used
//            for alloc and free functions.
// _in    : The function will only read from the buffer. The caller must provide the
//            buffer and initialize it.
// _out   : The function will only write to the buffer. If used on the return value or
//            with _deref, the function will provide the buffer and initialize it.
//            Otherwise, the caller must provide the buffer, and the function will
//            initialize it.
// _inout : The function may freely read from and write to the buffer. The caller must
//            provide the buffer and initialize it. If used with _deref, the buffer may
//            be reallocated by the function.
//
// Size: Describes the total size of the buffer. This may be less than the space actually
//         allocated for the buffer, in which case it describes the accessible amount.
//
// <>      : No buffer size is given. If the type specifies the buffer size (such as
//             with LPSTR and LPWSTR), that amount is used. Otherwise, the buffer is one
//             element long. Must be used with _in, _out, or _inout.
// _ecount : The buffer size is an explicit element count.
// _bcount : The buffer size is an explicit byte count.
//
// Output: Describes how much of the buffer will be initialized by the function. For
//           _inout buffers, this also describes how much is initialized at entry. Omit this
//           category for _in buffers; they must be fully initialized by the caller.
//
// <>    : The type specifies how much is initialized. For instance, a function initializing
//           an LPWSTR must NULL-terminate the string.
// _full : The function initializes the entire buffer.
// _part : The function initializes part of the buffer, and explicitly indicates how much.
//
// Optional: Describes if the buffer itself is optional.
//
// <>   : The pointer to the buffer must not be NULL.
// _opt : The pointer to the buffer might be NULL. It will be checked before being dereferenced.
//
// Parameters: Gives explicit counts for the size and length of the buffer.
//
// <>            : There is no explicit count. Use when neither _ecount nor _bcount is used.
// (size)        : Only the buffer's total size is given. Use with _ecount or _bcount but not _part.
// (size,length) : The buffer's total size and initialized length are given. Use with _ecount_part
//                   and _bcount_part.
//
// -------------------------------------------------------------------------------
// Buffer Annotation Examples
//
// LWSTDAPI_(BOOL) StrToIntExA(
//     LPCSTR pszString,                    // No annotation required, const implies __in.
//     DWORD dwFlags,
//     __out int *piRet                     // A pointer whose dereference will be filled in.
// );
//
// void MyPaintingFunction(
//     __in HWND hwndControl,               // An initialized read-only parameter.
//     __in_opt HDC hdcOptional,            // An initialized read-only parameter that might be NULL.
//     __inout IPropertyStore *ppsStore     // An initialized parameter that may be freely used
//                                          //   and modified.
// );
//
// LWSTDAPI_(BOOL) PathCompactPathExA(
//     __out_ecount(cchMax) LPSTR pszOut,   // A string buffer with cch elements that will
//                                          //   be NULL terminated on exit.
//     LPCSTR pszSrc,                       // No annotation required, const implies __in.
//     UINT cchMax,
//     DWORD dwFlags
// );
//
// HRESULT SHLocalAllocBytes(
//     size_t cb,
//     __deref_bcount(cb) T **ppv           // A pointer whose dereference will be set to an
//                                          //   uninitialized buffer with cb bytes.
// );
//
// __inout_bcount_full(cb) : A buffer with cb elements that is fully initialized at
//     entry and exit, and may be written to by this function.
//
// __out_ecount_part(count, *countOut) : A buffer with count elements that will be
//     partially initialized by this function. The function indicates how much it
//     initialized by setting *countOut.
//
// -------------------------------------------------------------------------------
// Advanced Annotations
//
// Advanced annotations describe behavior that is not expressible with the regular
// buffer macros. These may be used either to annotate buffer parameters that involve
// complex or conditional behavior, or to enrich existing annotations with additional
// information.
//
// __success(expr) f :
//     <expr> indicates whether function f succeeded or not. If <expr> is true at exit,
//     all the function's guarantees (as given by other annotations) must hold. If <expr>
//     is false at exit, the caller should not expect any of the function's guarantees
//     to hold. If not used, the function must always satisfy its guarantees. Added
//     automatically to functions that indicate success in standard ways, such as by
//     returning an HRESULT.
//
// __out_awcount(expr, size) p :
//     Pointer p is a buffer whose size may be given in either bytes or elements. If
//     <expr> is true, this acts like __out_bcount. If <expr> is false, this acts
//     like __out_ecount. This should only be used to annotate old APIs.
//
// __in_awcount(expr, size) p :
//     Pointer p is a buffer whose size may be given in either bytes or elements. If
//     <expr> is true, this acts like __in_bcount. If <expr> is false, this acts
//     like __in_ecount. This should only be used to annotate old APIs.
//
// __nullterminated p :
//     Pointer p is a buffer that may be read or written up to and including the first
//     NULL character or pointer. May be used on typedefs, which marks valid (properly
//     initialized) instances of that type as being NULL-terminated.
//
// __nullnullterminated p :
//     Pointer p is a buffer that may be read or written up to and including the first
//     sequence of two NULL characters or pointers. May be used on typedefs, which marks
//     valid instances of that type as being double-NULL terminated.
//
// __reserved v :
//     Value v must be 0/NULL, reserved for future use.
//
// __checkReturn v :
//     Return value v must not be ignored by callers of this function.
//
// __typefix(ctype) v :
//     Value v should be treated as an instance of ctype, rather than its declared type.
//
// __override f :
//     Specify C#-style 'override' behaviour for overriding virtual methods.
//
// __callback f :
//     Function f can be used as a function pointer.
//
// __format_string p :
//     Pointer p is a string that contains % markers in the style of printf.
//
// __blocksOn(resource) f :
//     Function f blocks on the resource 'resource'.
//
// __fallthrough :
//     Annotates switch statement labels where fall-through is desired, to distinguish
//     from forgotten break statements.
//
// -------------------------------------------------------------------------------
// Advanced Annotation Examples
//
// __success(return == TRUE) LWSTDAPI_(BOOL) 
// PathCanonicalizeA(__out_ecount(MAX_PATH) LPSTR pszBuf, LPCSTR pszPath) :
//     pszBuf is only guaranteed to be NULL-terminated when TRUE is returned.
//
// typedef __nullterminated WCHAR* LPWSTR : Initialized LPWSTRs are NULL-terminated strings.
//
// __out_ecount(cch) __typefix(LPWSTR) void *psz : psz is a buffer parameter which will be
//     a NULL-terminated WCHAR string at exit, and which initially contains cch WCHARs.
//
// -------------------------------------------------------------------------------

// @@END_DDKSPLIT

#if _MSC_VER > 1000
#pragma once
#endif  // #if _MSC_VER > 1000

#define __specstrings

#ifdef  __cplusplus
#ifndef __nothrow
# define __nothrow __declspec(nothrow)
#endif
extern "C" {
#else
#ifndef __nothrow
# define __nothrow
#endif
#endif  // #ifdef __cplusplus

// @@BEGIN_DDKSPLIT

// -------------------------------------------------------------------------------
// Helper Macro Definitions
//
// These express behavior common to many of the high-level annotations.
// DO NOT USE THESE IN YOUR CODE.
// -------------------------------------------------------------------------------

// The helper annotations are only understood by the compiler version used by various
// defect detection tools. When the regular compiler is running, they are defined into
// nothing, and do not affect the compiled code.
#if (_MSC_VER >= 1000) && !defined(MIDL_PASS) && defined(_PREFAST_)

    // In the primitive __declspec("SAL_*") annotations "SAL" stands for Standard
    // Annotation Language.  These __declspec("SAL_*") annotations are the
    // primitives the compiler understands and all high-level SpecString MACROs
    // will decompose into these primivates.

    #define SPECSTRINGIZE( x ) #x

    //
    // __null p
    // __notnull p
    // __maybenull p
    //
    // Annotates a pointer p. States that pointer p is null. Commonly used
    // in the negated form __notnull or the possibly null form __maybenull.
    //
    #define __null                  __declspec("SAL_null")
    #define __notnull               __declspec("SAL_notnull")
    #define __maybenull             __declspec("SAL_maybenull")

    //
    // __readonly l
    // __notreadonly l
    // __mabyereadonly l
    //
    // Annotates a location l. States that location l is not modified after
    // this point.  If the annotation is placed on the precondition state of
    // a function, the restriction only applies until the postcondition state
    // of the function.  __maybereadonly states that the annotated location
    // may be modified, whereas __notreadonly states that a location must be
    // modified.
    //
    #define __readonly              __declspec("SAL_readonly")
    #define __notreadonly           __declspec("SAL_notreadonly")
    #define __maybereadonly         __declspec("SAL_maybereadonly")

    //
    // __valid v
    // __notvalid v
    // __maybevalid v
    //
    // Annotates any value v. States that the value satisfies all properties of
    // valid values of its type. For example, for a string buffer, valid means
    // that the buffer pointer is either NULL or points to a NULL-terminated string.
    //
    #define __valid                 __declspec("SAL_valid")
    #define __notvalid              __declspec("SAL_notvalid")
    #define __maybevalid            __declspec("SAL_maybevalid")

    //
    // __readableTo(extent) p
    //
    // Annotates a buffer pointer p.  If the buffer can be read, extent describes
    // how much of the buffer is readable. For a reader of the buffer, this is
    // an explicit permission to read up to that amount, rather than a restriction to
    // read only up to it.
    //
    #define __readableTo(extent)    __declspec("SAL_readableTo("SPECSTRINGIZE(extent)")")

    //
    // __elem_readableTo(size)
    //
    // Annotates a buffer pointer p as being readable to size elements.
    //
    #define __elem_readableTo(size)   __declspec("SAL_readableTo(elementCount("SPECSTRINGIZE(size)"))")
    
    //
    // __byte_readableTo(size)
    //
    // Annotates a buffer pointer p as being readable to size bytes.
    //
    #define __byte_readableTo(size)   __declspec("SAL_readableTo(byteCount("SPECSTRINGIZE(size)"))")
    
    //
    // __writableTo(extent) p
    //
    // Annotates a buffer pointer p. If the buffer can be modified, extent
    // describes how much of the buffer is writable (usually the allocation
    // size). For a writer of the buffer, this is an explicit permission to
    // write up to that amount, rather than a restriction to write only up to it.
    //
    #define __writableTo(size)   __declspec("SAL_writableTo("SPECSTRINGIZE(size)")")

    //
    // __elem_writableTo(size)
    //
    // Annotates a buffer pointer p as being writable to size elements.
    //
    #define __elem_writableTo(size)   __declspec("SAL_writableTo(elementCount("SPECSTRINGIZE(size)"))")
    
    //
    // __byte_writableTo(size)
    //
    // Annotates a buffer pointer p as being writable to size bytes.
    //
    #define __byte_writableTo(size)   __declspec("SAL_writableTo(byteCount("SPECSTRINGIZE(size)"))")

    //
    // __deref p
    //
    // Annotates a pointer p. The next annotation applies one dereference down
    // in the type. If readableTo(p, size) then the next annotation applies to
    // all elements *(p+i) for which i satisfies the size. If p is a pointer
    // to a struct, the next annotation applies to all fields of the struct.
    //
    #define __deref                 __declspec("SAL_deref")
    
    //
    // __pre __next_annotation
    //
    // The next annotation applies in the precondition state
    //
    #define __pre                   __declspec("SAL_pre")
    
    //
    // __post __next_annotation
    //
    // The next annotation applies in the postcondition state
    //
    #define __post                  __declspec("SAL_post")
    
    //
    // __precond(<expr>)
    //
    // When <expr> is true, the next annotation applies in the precondition state
    // (currently not enabled)
    //
    #define __precond(expr)         __pre

    //
    // __postcond(<expr>)
    //
    // When <expr> is true, the next annotation applies in the postcondition state
    // (currently not enabled)
    //
    #define __postcond(expr)        __post

    //
    // __exceptthat
    //
    // Given a set of annotations Q containing __exceptthat maybeP, the effect of
    // the except clause is to erase any P or notP annotations (explicit or
    // implied) within Q at the same level of dereferencing that the except
    // clause appears, and to replace it with maybeP.
    //
    //  Example 1: __valid __exceptthat __maybenull on a pointer p means that the
    //             pointer may be null, and is otherwise valid, thus overriding
    //             the implicit notnull annotation implied by __valid on
    //             pointers.
    //
    //  Example 2: __valid __deref __exceptthat __maybenull on an int **p means
    //             that p is not null (implied by valid), but the elements
    //             pointed to by p could be null, and are otherwise valid. 
    //
    #define __exceptthat                __declspec("SAL_except")

    //
    // _refparam
    //
    // Added to all out parameter macros to indicate that they are all reference
    // parameters.
    //
    #define __refparam                  __deref __notreadonly

    //
    // __inner_*
    //
    // Helper macros that directly correspond to certain high-level annotations.
    //
    //

    // Macros to classify the entrypoints and indicate their category.
    //
    //
    // Pre-defined control point categories include: RPC, LPC, DeviceDriver, UserToKernel, ISAPI, COM.
    //
    #define __inner_control_entrypoint(category) __declspec("SAL_entrypoint(controlEntry, "SPECSTRINGIZE(category)")")

    //
    // Pre-defined data entry point categories include: Registry, File, Network.
    //
    #define __inner_data_entrypoint(category)    __declspec("SAL_entrypoint(dataEntry, "SPECSTRINGIZE(category)")")

    #define __inner_success(expr)               __declspec("SAL_success("SPECSTRINGIZE(expr)")")
    #define __inner_checkReturn                 __declspec("SAL_checkReturn")
    #define __inner_typefix(ctype)              __declspec("SAL_typefix("SPECSTRINGIZE(ctype)")")
    #define __inner_override                    __declspec("__override")
    #define __inner_callback                    __declspec("__callback")
    #define __inner_blocksOn(resource)          __declspec("SAL_blocksOn("SPECSTRINGIZE(resource)")")
    #define __inner_fallthrough_dec             __inline __nothrow void __FallThrough() {}
    #define __inner_fallthrough                 __FallThrough();

#else

// @@END_DDKSPLIT

    #define __null
    #define __notnull
    #define __maybenull
    #define __readonly
    #define __notreadonly
    #define __maybereadonly
    #define __valid
    #define __notvalid
    #define __maybevalid
    #define __readableTo(extent)
    #define __elem_readableTo(size)
    #define __byte_readableTo(size)
    #define __writableTo(size)
    #define __elem_writableTo(size)
    #define __byte_writableTo(size)
    #define __deref
    #define __pre
    #define __post
    #define __precond(expr)
    #define __postcond(expr)
    #define __exceptthat
    #define __inner_success(expr)
    #define __inner_checkReturn
    #define __inner_typefix(ctype)
    #define __inner_override
    #define __inner_callback
    #define __inner_blocksOn(resource)
    #define __inner_fallthrough_dec
    #define __inner_fallthrough
    #define __refparam
    #define __inner_control_entrypoint(category)
    #define __inner_data_entrypoint(category)
// @@BEGIN_DDKSPLIT
#endif // #if (_MSC_VER >= 1000) && !defined(MIDL_PASS) && defined(_PREFAST_)
// -------------------------------------------------------------------------------
// Buffer Annotation Definitions
//
// Any of these may be used to directly annotate functions, but only one should
// be used for each parameter. To determine which annotation to use for a given
// buffer, use the table in the buffer annotations section.
// -------------------------------------------------------------------------------
// @@END_DDKSPLIT

#define __ecount(size)                                          __notnull __elem_writableTo(size)
#define __bcount(size)                                          __notnull __byte_writableTo(size)
#define __in                                                    __pre __valid __pre __deref __readonly
#define __in_ecount(size)                                       __in __pre __elem_readableTo(size)
#define __in_bcount(size)                                       __in __pre __byte_readableTo(size)
#define __out                                                   __ecount(1) __post __valid __refparam
#define __out_ecount(size)                                      __ecount(size) __post __valid __refparam
#define __out_bcount(size)                                      __bcount(size) __post __valid __refparam
#define __out_ecount_part(size,length)                          __out_ecount(size) __post __elem_readableTo(length)
#define __out_bcount_part(size,length)                          __out_bcount(size) __post __byte_readableTo(length)
#define __out_ecount_full(size)                                 __out_ecount_part(size,size)
#define __out_bcount_full(size)                                 __out_bcount_part(size,size)
#define __inout                                                 __pre __valid __post __valid __refparam
#define __inout_ecount(size)                                    __out_ecount(size) __pre __valid
#define __inout_bcount(size)                                    __out_bcount(size) __pre __valid
#define __inout_ecount_part(size,length)                        __out_ecount_part(size,length) __pre __valid __pre __elem_readableTo(length)
#define __inout_bcount_part(size,length)                        __out_bcount_part(size,length) __pre __valid __pre __byte_readableTo(length)
#define __inout_ecount_full(size)                               __inout_ecount_part(size,size)
#define __inout_bcount_full(size)                               __inout_bcount_part(size,size)

#define __ecount_opt(size)                                      __ecount(size)                              __exceptthat __maybenull
#define __bcount_opt(size)                                      __bcount(size)                              __exceptthat __maybenull
#define __in_opt                                                __in                                        __exceptthat __maybenull
#define __in_ecount_opt(size)                                   __in_ecount(size)                           __exceptthat __maybenull
#define __in_bcount_opt(size)                                   __in_bcount(size)                           __exceptthat __maybenull
#define __out_opt                                               __out                                       __exceptthat __maybenull
#define __out_ecount_opt(size)                                  __out_ecount(size)                          __exceptthat __maybenull
#define __out_bcount_opt(size)                                  __out_bcount(size)                          __exceptthat __maybenull
#define __out_ecount_part_opt(size,length)                      __out_ecount_part(size,length)              __exceptthat __maybenull
#define __out_bcount_part_opt(size,length)                      __out_bcount_part(size,length)              __exceptthat __maybenull
#define __out_ecount_full_opt(size)                             __out_ecount_full(size)                     __exceptthat __maybenull
#define __out_bcount_full_opt(size)                             __out_bcount_full(size)                     __exceptthat __maybenull
#define __inout_opt                                             __inout                                     __exceptthat __maybenull
#define __inout_ecount_opt(size)                                __inout_ecount(size)                        __exceptthat __maybenull
#define __inout_bcount_opt(size)                                __inout_bcount(size)                        __exceptthat __maybenull
#define __inout_ecount_part_opt(size,length)                    __inout_ecount_part(size,length)            __exceptthat __maybenull
#define __inout_bcount_part_opt(size,length)                    __inout_bcount_part(size,length)            __exceptthat __maybenull
#define __inout_ecount_full_opt(size)                           __inout_ecount_full(size)                   __exceptthat __maybenull
#define __inout_bcount_full_opt(size)                           __inout_bcount_full(size)                   __exceptthat __maybenull

#define __deref_ecount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __elem_writableTo(size)
#define __deref_bcount(size)                                    __ecount(1) __post __elem_readableTo(1) __post __deref __notnull __post __deref __byte_writableTo(size)
#define __deref_in                                              __in __pre __deref __deref __readonly
#define __deref_in_ecount(size)                                 __deref_in __pre __deref __elem_readableTo(size)
#define __deref_in_bcount(size)                                 __deref_in __pre __deref __byte_readableTo(size)
#define __deref_out                                             __deref_ecount(1) __post __deref __valid __refparam
#define __deref_out_ecount(size)                                __deref_ecount(size) __post __deref __valid __refparam
#define __deref_out_bcount(size)                                __deref_bcount(size) __post __deref __valid __refparam
#define __deref_out_ecount_part(size,length)                    __deref_out_ecount(size) __post __deref __elem_readableTo(length)
#define __deref_out_bcount_part(size,length)                    __deref_out_bcount(size) __post __deref __byte_readableTo(length)
#define __deref_out_ecount_full(size)                           __deref_out_ecount_part(size,size)
#define __deref_out_bcount_full(size)                           __deref_out_bcount_part(size,size)
#define __deref_inout                                           __notnull __elem_readableTo(1) __pre __deref __valid __post __deref __valid __refparam
#define __deref_inout_ecount(size)                              __deref_inout __pre __deref __elem_writableTo(size) __post __deref __elem_writableTo(size)
#define __deref_inout_bcount(size)                              __deref_inout __pre __deref __byte_writableTo(size) __post __deref __byte_writableTo(size)
#define __deref_inout_ecount_part(size,length)                  __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length)
#define __deref_inout_bcount_part(size,length)                  __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length)
#define __deref_inout_ecount_full(size)                         __deref_inout_ecount_part(size,size)
#define __deref_inout_bcount_full(size)                         __deref_inout_bcount_part(size,size)

#define __deref_ecount_opt(size)                                __deref_ecount(size)                        __post __deref __exceptthat __maybenull
#define __deref_bcount_opt(size)                                __deref_bcount(size)                        __post __deref __exceptthat __maybenull
#define __deref_in_opt                                          __deref_in                                  __pre __deref __exceptthat __maybenull
#define __deref_in_ecount_opt(size)                             __deref_in_ecount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_in_bcount_opt(size)                             __deref_in_bcount(size)                     __pre __deref __exceptthat __maybenull
#define __deref_out_opt                                         __deref_out                                 __post __deref __exceptthat __maybenull
#define __deref_out_ecount_opt(size)                            __deref_out_ecount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_bcount_opt(size)                            __deref_out_bcount(size)                    __post __deref __exceptthat __maybenull
#define __deref_out_ecount_part_opt(size,length)                __deref_out_ecount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_bcount_part_opt(size,length)                __deref_out_bcount_part(size,length)        __post __deref __exceptthat __maybenull
#define __deref_out_ecount_full_opt(size)                       __deref_out_ecount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_out_bcount_full_opt(size)                       __deref_out_bcount_full(size)               __post __deref __exceptthat __maybenull
#define __deref_inout_opt                                       __deref_inout                               __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_opt(size)                          __deref_inout_ecount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_opt(size)                          __deref_inout_bcount(size)                  __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_part_opt(size,length)              __deref_inout_ecount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_part_opt(size,length)              __deref_inout_bcount_part(size,length)      __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_ecount_full_opt(size)                     __deref_inout_ecount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull
#define __deref_inout_bcount_full_opt(size)                     __deref_inout_bcount_full(size)             __pre __deref __exceptthat __maybenull __post __deref __exceptthat __maybenull

#define __deref_opt_ecount(size)                                __deref_ecount(size)                        __exceptthat __maybenull
#define __deref_opt_bcount(size)                                __deref_bcount(size)                        __exceptthat __maybenull
#define __deref_opt_in                                          __deref_in                                  __exceptthat __maybenull
#define __deref_opt_in_ecount(size)                             __deref_in_ecount(size)                     __exceptthat __maybenull
#define __deref_opt_in_bcount(size)                             __deref_in_bcount(size)                     __exceptthat __maybenull
#define __deref_opt_out                                         __deref_out                                 __exceptthat __maybenull
#define __deref_opt_out_ecount(size)                            __deref_out_ecount(size)                    __exceptthat __maybenull
#define __deref_opt_out_bcount(size)                            __deref_out_bcount(size)                    __exceptthat __maybenull
#define __deref_opt_out_ecount_part(size,length)                __deref_out_ecount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_bcount_part(size,length)                __deref_out_bcount_part(size,length)        __exceptthat __maybenull
#define __deref_opt_out_ecount_full(size)                       __deref_out_ecount_full(size)               __exceptthat __maybenull
#define __deref_opt_out_bcount_full(size)                       __deref_out_bcount_full(size)               __exceptthat __maybenull
#define __deref_opt_inout                                       __deref_inout                               __exceptthat __maybenull
#define __deref_opt_inout_ecount(size)                          __deref_inout_ecount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_bcount(size)                          __deref_inout_bcount(size)                  __exceptthat __maybenull
#define __deref_opt_inout_ecount_part(size,length)              __deref_inout_ecount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_bcount_part(size,length)              __deref_inout_bcount_part(size,length)      __exceptthat __maybenull
#define __deref_opt_inout_ecount_full(size)                     __deref_inout_ecount_full(size)             __exceptthat __maybenull
#define __deref_opt_inout_bcount_full(size)                     __deref_inout_bcount_full(size)             __exceptthat __maybenull

#define __deref_opt_ecount_opt(size)                            __deref_ecount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_bcount_opt(size)                            __deref_bcount_opt(size)                    __exceptthat __maybenull
#define __deref_opt_in_opt                                      __deref_in_opt                              __exceptthat __maybenull
#define __deref_opt_in_ecount_opt(size)                         __deref_in_ecount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_in_bcount_opt(size)                         __deref_in_bcount_opt(size)                 __exceptthat __maybenull
#define __deref_opt_out_opt                                     __deref_out_opt                             __exceptthat __maybenull
#define __deref_opt_out_ecount_opt(size)                        __deref_out_ecount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_bcount_opt(size)                        __deref_out_bcount_opt(size)                __exceptthat __maybenull
#define __deref_opt_out_ecount_part_opt(size,length)            __deref_out_ecount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_bcount_part_opt(size,length)            __deref_out_bcount_part_opt(size,length)    __exceptthat __maybenull
#define __deref_opt_out_ecount_full_opt(size)                   __deref_out_ecount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_out_bcount_full_opt(size)                   __deref_out_bcount_full_opt(size)           __exceptthat __maybenull
#define __deref_opt_inout_opt                                   __deref_inout_opt                           __exceptthat __maybenull
#define __deref_opt_inout_ecount_opt(size)                      __deref_inout_ecount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_bcount_opt(size)                      __deref_inout_bcount_opt(size)              __exceptthat __maybenull
#define __deref_opt_inout_ecount_part_opt(size,length)          __deref_inout_ecount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_bcount_part_opt(size,length)          __deref_inout_bcount_part_opt(size,length)  __exceptthat __maybenull
#define __deref_opt_inout_ecount_full_opt(size)                 __deref_inout_ecount_full_opt(size)         __exceptthat __maybenull
#define __deref_opt_inout_bcount_full_opt(size)                 __deref_inout_bcount_full_opt(size)         __exceptthat __maybenull

// @@BEGIN_DDKSPLIT
// -------------------------------------------------------------------------------
// Advanced Annotation Definitions
//
// Any of these may be used to directly annotate functions, and may be used in
// combination with each other or with regular buffer macros. For an explanation
// of each annotation, see the advanced annotations section.
// -------------------------------------------------------------------------------
// @@END_DDKSPLIT

#define __out_awcount(expr,size)            __pre __notnull \
                                            __precond(expr) __byte_writableTo(size) \
                                            __precond(!(expr)) __byte_writableTo((size)*2) \
                                            __post __valid __refparam
#define __in_awcount(expr,size)             __pre __valid \
                                            __pre __deref __readonly \
                                            __precond(expr) __byte_readableTo(size) \
                                            __precond(!(expr)) __elem_readableTo(size)
#define __success(expr)                     __inner_success(expr)
#define __nullterminated                    __readableTo(sentinel(0))
#define __nullnullterminated
#define __reserved                          __pre __null
#define __checkReturn                       __inner_checkReturn
#define __typefix(ctype)                    __inner_typefix(ctype)
#define __override                          __inner_override
#define __callback                          __inner_callback
#define __format_string
#define __blocksOn(resource)                __inner_blocksOn(resource)
#define __control_entrypoint(category)      __inner_control_entrypoint(category)
#define __data_entrypoint(category)         __inner_data_entrypoint(category)

#ifndef __fallthrough
    __inner_fallthrough_dec
    #define __fallthrough __inner_fallthrough
#endif

// -------------------------------------------------------------------------------
// Deprecated Annotation Definitions
//
// These should be removed from existing code.
// -------------------------------------------------------------------------------

// #define __opt                               __exceptthat __maybenull

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\PassportIDCRL\4.0\Retail\msidcrl.h ===
/*******************************************************************************
 * FILE
 *      ppcrl.h
 *
 * DESCRIPTION
 *      Public Passport client runtime library header. Distributed to partners
 *      along with the associated exports library and dynamic link library. Defines
 *      the public interface by which hosting partner applications make use
 *      of the Passport client runtime library.
 *
 * COMPATIBILITY NOTES
 *      Current implementation is per M2 Passport functionality. Contents
 *      of this file subject to change prior to 3.0 release. After 3.0, the
 *      header and library will maintain backward compile compatibility
 *      in subsequent versions.
 *
 *      Support for authentication based on client certificates was pulled
 *      from the 3.0 release. As a result, all cert-based code related to
 *      the API has been disabled. Fields are still left in the API's
 *      in anticipation of this future functionality, but the calls
 *      will fail with PPCRL_E_CERTIFICATE_AUTHENTICATION_NOT_SUPPORTED
 *      if non null/empty values are passed in.
 *
 * (C) Copyright 2002-2004, Microsoft Corporation. All Right Reserved.
 *
 ******************************************************************************/
#ifndef PPCRL_SCRIPT_ERROR_CODES
#pragma once

// #ifdef PPCRL_LIB
#define IDCRL_API  HRESULT __stdcall

/* disabled - otherwise IA64 build in NT complain multiple defineition of the same function Uniniatlize
#else
#ifdef PPCRL_EXPORTS
#define IDCRL_API __declspec(dllexport) HRESULT __stdcall
#else
#define IDCRL_API __declspec(dllimport) HRESULT __stdcall
#endif
#endif
*/

#define IDCRL_API_VERSION_1 1
#define IDCRL_API_VERSION_CURRENT IDCRL_API_VERSION_1

#define  IDCRL_BINARY_VERSION   "4"
#define  IDCRL_UI_CONTRACT_VERSION "1"


#ifdef __cplusplus
extern "C" {
#endif

#endif /* not defined PPCRL_SCRIPT_ERROR_CODES */

//
// Error/success code definitions
//

#ifdef PPCRL_SCRIPT_ERROR_CODES
    #define SEVERITY_SUCCESS 0
    #define SEVERITY_ERROR 1
    #define FACILITY_ITF 4
    #define MAKE_HRESULT(sev,fac,code) (((sev<<31)|(fac<<16)|((code))))
#endif

#define PPCRL_HRESULT_BASE    0x8800

#define PPCRL_SUCCESS_CODE(x) MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PPCRL_HRESULT_BASE|(x))
#define PPCRL_ERROR_CODE(x) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_HRESULT_BASE|(x))

//
// Authentication State
//

//
// Failure codes are 0x800488XX, success codes are 0x000488XX
// TODO: Go through and update comments with all actual codes for reference just prior to release
//

#define PPCRL_AUTHSTATE_E_UNAUTHENTICATED                           PPCRL_ERROR_CODE(0x00)  // 0x80048800

// returned by STS in as auth state, when the DA ticket is expired
#define PPCRL_AUTHSTATE_E_EXPIRED                                   PPCRL_ERROR_CODE(0x01) 
#define PPCRL_AUTHSTATE_S_AUTHENTICATED_OFFLINE                     PPCRL_SUCCESS_CODE(0x02) // Offline login from hashed creds
#define PPCRL_AUTHSTATE_S_AUTHENTICATED_PASSWORD                    PPCRL_SUCCESS_CODE(0x03) // Online login with password, Returned by the server?

//Reserved
//#define PPCRL_AUTHSTATE_S_AUTHENTICATED_SECURITY_KEY                PPCRL_SUCCESS_CODE(0x04)
//#define PPCRL_AUTHSTATE_S_AUTHENTICATED_STRONG_PASSWORD             PPCRL_SUCCESS_CODE(0x05) // ?? Returned by the server ??
//FUTURE: #define PPCRL_AUTHSTATE_S_AUTHENTICATED_CERTIFICATE                 PPCRL_SUCCESS_CODE(0x06)

#define PPCRL_AUTHREQUIRED_E_PASSWORD                               PPCRL_ERROR_CODE(0x10) // password is required for authentication
//Reserved
#define PPCRL_AUTHREQUIRED_E_SECURITY_KEY                           PPCRL_ERROR_CODE(0x11)
//#define PPCRL_AUTHREQUIRED_E_STRONG_PASSWORD                        PPCRL_ERROR_CODE(0x12)
#define PPCRL_AUTHREQUIRED_E_CERTIFICATE                            PPCRL_ERROR_CODE(0x13)

// The auth required status is unknown, in case, we cannot retrieve it from the token bag
#define PPCRL_AUTHREQUIRED_E_UNKNOWN                                PPCRL_ERROR_CODE(0x14)

#define PPCRL_REQUEST_E_AUTH_SERVER_ERROR                           PPCRL_ERROR_CODE(0x20) // Request failure, IDCRL did not get back a response
#define PPCRL_REQUEST_E_BAD_MEMBER_NAME_OR_PASSWORD                 PPCRL_ERROR_CODE(0x21)
#define PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT                         PPCRL_ERROR_CODE(0x23)
#define PPCRL_REQUEST_E_PASSWORD_LOCKED_OUT_BAD_PASSWORD_OR_HIP     PPCRL_ERROR_CODE(0x24)
#define PPCRL_REQUEST_E_TOU_CONSENT_REQUIRED                        PPCRL_ERROR_CODE(0x25) // not used
#define PPCRL_REQUEST_E_FORCE_RENAME_REQUIRED                       PPCRL_ERROR_CODE(0x26)
#define PPCRL_REQUEST_E_FORCE_CHANGE_PASSWORD_REQUIRED              PPCRL_ERROR_CODE(0x27)
#define PPCRL_REQUEST_E_STRONG_PASSWORD_REQUIRED                    PPCRL_ERROR_CODE(0x28)
#define PPCRL_REQUEST_E_NO_CERTIFICATES_AVAILABLE                   PPCRL_ERROR_CODE(0x29)
#define PPCRL_REQUEST_E_PARTNER_NOT_FOUND                           PPCRL_ERROR_CODE(0x2a)
#define PPCRL_REQUEST_E_PARTNER_HAS_NO_ASYMMETRIC_KEY               PPCRL_ERROR_CODE(0x2b)
#define PPCRL_REQUEST_E_INVALID_POLICY                              PPCRL_ERROR_CODE(0x2c)
#define PPCRL_REQUEST_E_INVALID_MEMBER_NAME                         PPCRL_ERROR_CODE(0x2d)
#define PPCRL_REQUEST_E_MISSING_PRIMARY_CREDENTIAL                  PPCRL_ERROR_CODE(0x2e)
#define PPCRL_REQUEST_E_PENDING_NETWORK_REQUEST                     PPCRL_ERROR_CODE(0x2f)
#define PPCRL_REQUEST_E_FORCE_CHANGE_SQSA                           PPCRL_ERROR_CODE(0x30)
#define PPCRL_REQUEST_E_PASSWORD_EXPIRED                            PPCRL_ERROR_CODE(0x31)
#define PPCRL_REQUEST_E_PENDING_USER_INPUT                          PPCRL_ERROR_CODE(0x32)
#define PPCRL_REQUEST_E_MISSING_HIP_SOLUTION                        PPCRL_ERROR_CODE(0x33)
#define PPCRL_REQUEST_E_PROFILE_ACCRUE_REQUIRED                     PPCRL_ERROR_CODE(0x34)
#define PPCRL_REQUEST_S_PROFILE_ACCRUE_DONE                         PPCRL_SUCCESS_CODE(0x35)
#define PPCRL_REQUEST_E_EMAIL_VALIDATION_REQUIRED                   PPCRL_ERROR_CODE(0x36)
#define PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW                       PPCRL_ERROR_CODE(0x37)
#define PPCRL_REQUEST_E_PARTNER_NEED_STRONGPW_EXPIRY                PPCRL_ERROR_CODE(0x38)
//Login server sends this request status when DA ticket is expired, apps should use this request
// status to determine if the ticket is expired.
#define PPCRL_REQUEST_E_AUTH_EXPIRED                                PPCRL_ERROR_CODE(0x39)

#define PPCRL_REQUEST_E_USER_REQUESTED_HELP                         PPCRL_ERROR_CODE(0x40)
#define PPCRL_REQUEST_E_USER_FORGOT_PASSWORD                        PPCRL_ERROR_CODE(0x41)
#define PPCRL_REQUEST_E_USER_CANCELED                               PPCRL_ERROR_CODE(0x42)
#define PPCRL_REQUEST_E_USER_EDIT_PASSPORT                          PPCRL_ERROR_CODE(0x43)
#define PPCRL_REQUEST_E_USER_PASSPORTLOGO                           PPCRL_ERROR_CODE(0x44)
#define PPCRL_REQUEST_E_USER_SHOW_PRIVACY_STATEMENT                 PPCRL_ERROR_CODE(0x45)
#define PPCRL_REQUEST_E_USER_SHOW_TERMS_OF_USE                      PPCRL_ERROR_CODE(0x46)
#define PPCRL_REQUEST_S_IO_PENDING                                  PPCRL_SUCCESS_CODE(0x47)
#define PPCRL_REQUEST_E_NO_NETWORK                                  PPCRL_ERROR_CODE(0x48)
// The request status is unknown, in case, we cannot retrieve it from the token bag
#define PPCRL_REQUEST_E_UNKNOWN                                     PPCRL_ERROR_CODE(0x49)

// reserved
#define PPCRL_REQUEST_E_TOKEN_BEYOND_LIFTIME                        PPCRL_ERROR_CODE(0x50)

// reserved
#define PPCRL_REQUEST_E_TOKEN_TARGETS_MISMATCH                      PPCRL_ERROR_CODE(0x51)

//  indicate the client needs to re-post to another STS
//  STS url should be part of the response
#define PPCRL_REQUEST_E_WRONG_DA                                    PPCRL_ERROR_CODE(0x52)

// parent consent for the KID is required
#define PPCRL_REQUEST_E_KID_HAS_NO_CONSENT                          PPCRL_ERROR_CODE(0x53)

// new error code 3.2
#define PPCRL_REQUEST_E_RSTR_MISSING_REFERENCE_URI                  PPCRL_ERROR_CODE(0x54)
//reserved
#define PPCRL_REQUEST_E_RSTR_FAULT                                  PPCRL_ERROR_CODE(0x55)
#define PPCRL_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN               PPCRL_ERROR_CODE(0x56)
#define PPCRL_REQUEST_E_RSTR_MISSING_BASE64CERT                     PPCRL_ERROR_CODE(0x57)
#define PPCRL_REQUEST_E_RSTR_MISSING_TOKENTYPE                      PPCRL_ERROR_CODE(0x58)
#define PPCRL_REQUEST_E_RSTR_MISSING_SERVICENAME                    PPCRL_ERROR_CODE(0x59)
#define PPCRL_REQUEST_E_RSTR_INVALID_TOKENTYPE                      PPCRL_ERROR_CODE(0x5a)
#define PPCRL_REQUEST_E_RSTR_MISSING_PRIVATE_KEY                    PPCRL_ERROR_CODE(0x5b)

// This error is returned if the STS cannot verify the timestamp on the request. In this case,
// STS will also send back the server time and IDCRL can adjust 
#define PPCRL_REQUEST_E_INVALID_SERVICE_TIMESTAMP                   PPCRL_ERROR_CODE(0x5c) //0x8004885c
#define PPCRL_REQUEST_E_INVALID_PKCS10_TIMESTAMP                    PPCRL_ERROR_CODE(0x5d) //0x8004885d
#define PPCRL_REQUEST_E_INVALID_PKCS10                              PPCRL_ERROR_CODE(0x5e) //0x8004885e
// NOTE: 2nd range for PPCRL_REQUEST_E errors starts at 0x800488E0. This one is full!

#define PPCRL_S_NO_MORE_IDENTITIES                                  PPCRL_SUCCESS_CODE(0x60)
#define PPCRL_S_TOKEN_TYPE_DOES_NOT_SUPPORT_SESSION_KEY             PPCRL_SUCCESS_CODE(0x61)
#define PPCRL_S_NO_SUCH_CREDENTIAL                                  PPCRL_SUCCESS_CODE(0x62)
#define PPCRL_S_NO_AUTHENTICATION_REQUIRED                          PPCRL_SUCCESS_CODE(0x63)

#define PPCRL_E_AUTH_CONTEXT_ALREADY_IN_USE                         PPCRL_ERROR_CODE(0x60)
#define PPCRL_E_IDENTITY_NOT_AUTHENTICATED                          PPCRL_ERROR_CODE(0x61)
#define PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN                    PPCRL_ERROR_CODE(0x62)

//Reserved
//#define PPCRL_E_INVALID_DERIVATION_METHOD                           PPCRL_ERROR_CODE(0x63)
//#define PPCRL_E_INVALID_DERIVATION_PARAMS                           PPCRL_ERROR_CODE(0x64)
//#define PPCRL_E_INVALID_DERIVATION_ITERATIONS_PARAM                 PPCRL_ERROR_CODE(0x65)
//#define PPCRL_E_INVALID_DERIVATION_SALT_PARAM                       PPCRL_ERROR_CODE(0x66)
//#define PPCRL_E_INVALID_DERIVED_KEY_LENGTH                          PPCRL_ERROR_CODE(0x67)
#define PPCRL_E_CERTIFICATE_AUTHENTICATION_NOT_SUPPORTED            PPCRL_ERROR_CODE(0x68)
#define PPCRL_E_AUTH_SERVICE_UNAVAILABLE                            PPCRL_ERROR_CODE(0x69)
#define PPCRL_E_INVALID_AUTH_SERVICE_RESPONSE                       PPCRL_ERROR_CODE(0x6a)
#define PPCRL_E_UNABLE_TO_INITIALIZE_CRYPTO_PROVIDER                PPCRL_ERROR_CODE(0x6b)
#define PPCRL_E_NO_MEMBER_NAME_SET                                  PPCRL_ERROR_CODE(0x6c)
#define PPCRL_E_CALLBACK_REQUIRED                                   PPCRL_ERROR_CODE(0x6d)
#define PPCRL_E_DISCONTINUE_AUTHENTICATION                          PPCRL_ERROR_CODE(0x6e)
#define PPCRL_E_INVALIDFLAGS                                        PPCRL_ERROR_CODE(0x6f)
#define PPCRL_E_UNABLE_TO_RETRIEVE_CERT                             PPCRL_ERROR_CODE(0x70)
#define PPCRL_E_INVALID_RSTPARAMS                                   PPCRL_ERROR_CODE(0x71)
#define PPCRL_E_MISSING_FILE                                        PPCRL_ERROR_CODE(0x72)
#define PPCRL_E_ILLEGAL_LOGONIDENTITY_FLAG                          PPCRL_ERROR_CODE(0x73)

#define PPCRL_E_CERT_NOT_VALID_FOR_MINTTL                           PPCRL_ERROR_CODE(0x74) // the certificate is found, but not valid for the minTTL, minTTL could be too big
#define PPCRL_S_OK_CLIENTTIME                                       PPCRL_SUCCESS_CODE(0x75)

#define PPCRL_E_CERT_INVALID_ISSUER                                 PPCRL_ERROR_CODE(0x76) // the certificate is found, but not valid for the minTTL, minTTL could be too big
#define PPCRL_E_NO_CERTSTORE_FOR_ISSUERS                            PPCRL_ERROR_CODE(0x77)

// Indicates there was a problem with offline login, more information can be had by calling GetAuthState API.
#define PPCRL_E_OFFLINE_AUTH                                        PPCRL_ERROR_CODE(0x78)

// GetCertificate failed because POP message could not be signed. This is an unexepcted error.
#define PPCRL_E_SIGN_POP_FAILED                                    PPCRL_ERROR_CODE(0x79)

// VerifyCertificate failed because POP was invalid. Sender may not possess the private key
// for the certificate
#define PPCRL_E_CERT_INVALID_POP                                    PPCRL_ERROR_CODE(0x80)

// The calling application is not signed. In order to call GetCertificate API, the application exe
// must be signed with Microsoft Code signing certificate (https://codesignaoc for more details)
// 
#define PPCRL_E_CALLER_NOT_SIGNED                                   PPCRL_ERROR_CODE(0x81) ////0x80048881

// Identity is processing another API call. Please wait for some time and retry the call
#define PPCRL_E_BUSY                                                PPCRL_ERROR_CODE(0x82) ////0x80048882

// There was a failure while downloading the config or ui dlls from passport
// config servers. Most likely internet connection is not setup correctly.
#define PPCRL_E_DOWNLOAD_FILE_FAILED                                PPCRL_ERROR_CODE(0x83) ////0x80048883

// There was an error generating the certificate request. The error could be due
// to bad parameters supplied by the application (usually out of range keylength)
// See CryptGenKey API for allowed key lengths. 0 and 384-16,384 will usually
// work. Trace will provide more info on exact cause.
#define PPCRL_E_BUILD_CERT_REQUEST_FAILED                           PPCRL_ERROR_CODE(0x84) ////0x80048884

// Returned by GetCertificate API if it cannot find a certificate for the identity
#define PPCRL_E_CERTIFICATE_NOT_FOUND                               PPCRL_ERROR_CODE(0x85) ////0x80048885

// Returned by ExportAuthState API
#define PPCRL_E_AUTHBLOB_TOO_LARGE                                  PPCRL_ERROR_CODE(0x86) ////0x80048886
#define PPCRL_E_AUTHBLOB_NOT_FOUND                                  PPCRL_ERROR_CODE(0x87) ////0x80048887
#define PPCRL_E_AUTHBLOB_INVALID                                    PPCRL_ERROR_CODE(0x88) ////0x80048888

#define PPCRL_E_EXTPROP_NOTFOUND                                    PPCRL_ERROR_CODE(0x89) ////0x80048889

#define PPCRL_E_RESPONSE_TOO_LARGE                                   PPCRL_ERROR_CODE(0x8A) ////0x8004888A

#define PPCRL_E_EXTENDED_ERROR_NOT_SET                              PPCRL_ERROR_CODE(0x8B) ////0x8004888B

#define PPCRL_E_USER_NOTFOUND                                       PPCRL_ERROR_CODE(0x8C) ////0x8004888C

// Added in 4.0. Returned by Initialize(Ex) if signature on ppcrlconfig.dll or
// ppcrlui.dll cannot be validated.
#define PPCRL_E_SIGCHECK_FAILED                                     PPCRL_ERROR_CODE(0x8D) ////0x8004888D

//******************************************************************************
// 2nd range of request status codes starts with 0x800488E0

// User requested offline login but there was no hashed password. They must 
// create hashed password first by doing a successful online login.
#define PPCRL_REQUEST_E_MISSING_HASHED_PASSWORD                   PPCRL_ERROR_CODE(0xE0) ////0x800488E0

// The client issuing this request is no longer supported by passport login server. 
// User must upgrade to a newer version of the application built with a supported 
// version of IDCRL. It may be returned in request status by LogonIdentity* APIs.
#define PPCRL_REQUEST_E_CLIENT_DEPRECATED                         PPCRL_ERROR_CODE(0xE1) ////0x800488E1

// The request was cancelled by calling CancelPendingRequest API.
#define PPCRL_REQUEST_E_CANCELLED                                 PPCRL_ERROR_CODE(0xE2) ////0x800488E2

// Application provided incorrect key length for certificate request.
#define PPCRL_REQUEST_E_INVALID_PKCS10_KEYLEN                     PPCRL_ERROR_CODE(0xE3) ////0x800488E3

// Application tried to submit a request with duplicate service target names in PCMultiRSTParams parameter. 
// This is not supported. In this case no network call is made. This error can be returned by the 
// LogonIdentityEx or AuthIdentityToServiceEx fuctions.
#define  PPCRL_REQUEST_E_DUPLICATE_SERVICETARGET                  PPCRL_ERROR_CODE(0xE4) ////0x800488E4

// The authentication token has expired, re-authentication is required by the partner. Different partners
// choose different time windows for authentication. In a multiple request, some requests may succeed
// and others fail with this error.
#define PPCRL_REQUEST_E_FORCE_SIGNIN                              PPCRL_ERROR_CODE(0xE5) ////0x800488E5

// Partner needs a certificate to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_CERTIFICATE                  PPCRL_ERROR_CODE(0xE6) ////0x800488E6

// Partner needs a PIN to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_PIN                          PPCRL_ERROR_CODE(0xE7) ////0x800488E7

// Partner needs a password to login.
#define PPCRL_REQUEST_E_PARTNER_NEED_PASSWORD                     PPCRL_ERROR_CODE(0xE8) ////0x800488E8

// Following two error codes are returned by LogonIdentityEx, AuthIdentityToServiceEx
// if we are unable to generate the SLC request (this will happen for guest users)
// In this case IDCRL automatically submits the request without the SLC and returned
// one of these return codes. PPCRL_S_OK_NO_SLC for sync and PPCRL_S_IO_PENDING_NO_SLC for async
#define PPCRL_REQUEST_S_OK_NO_SLC                                           PPCRL_SUCCESS_CODE(0xE9)
#define PPCRL_REQUEST_S_IO_PENDING_NO_SLC                                   PPCRL_SUCCESS_CODE(0xEA)


// There was an schannel failure while sending the request. Make sure SSL is enabled in IE.
#define PPCRL_REQUEST_E_SCHANNEL_ERROR                            PPCRL_ERROR_CODE(0xEB) ////0x800488EB

// There was an error parsing the certificate blob in the response.
#define PPCRL_REQUEST_E_CERT_PARSE_ERROR                       PPCRL_ERROR_CODE(0xEC) ////0x800488EC

//-----------------------------------------------------------------------------
//
//  Error codes from ppclienterr.h
//
// Most errors in this section are either developer actionable during development
// (PP_E_CRL_NOT_INITIALIZED: fix code to initialize IDCRL before using APIs) or
// not actionable at all (PP_E_CRL_OUT_OF_MEMORY: system is low on memory).
//
// There are a few errors that the user can fix or investigate. Search for 
// 'USER ACTIONABLE' to find such error codes.
//-----------------------------------------------------------------------------

#define     PP_E_CRL_BASE                       0x8000
// Denotes Out of memory condition, not actionable.
#define     PP_E_CRL_OUT_OF_MEMORY              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  1) // 0x8001

// Returned by some utility functions for NULL arguments, not actionable.
#define     PP_E_CRL_UNEXPECTED_NULL_ARG        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  2) // 0x8002

//Returned by some utility functions if they fail to load the UI or config dlls, 
// force download of new files from passport servers by deleting the current files
#define     PP_E_CRL_CREATE_XMLDOC_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  3) // 0x8003
#define     PP_E_CRL_LOAD_XMLDOC_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  4) // 0x8004

// Reserved
#define     PP_E_CRL_CREATE_FILE_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  5) // 0x8005

// Could not acquire a mutex for an operation. Close other idcrl enabled applications and try again.
#define     PP_E_CRL_CREATE_MUTEX_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  6) // 0x8006
#define     PP_E_CRL_OBTAIN_MUTEX_FAILED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  7) // 0x8007

// IDCRL is not initialized, call initialize(Ex) before calling any other APIs
#define     PP_E_CRL_NOT_INITIALIZED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  8) // 0x8008

// Reserved
#define     PP_E_CRL_TOKENS_TOO_LONG            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  9) // 0x8009
#define     PP_E_CRL_TOKENFILE_NOT_CREATED      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  10) // 0x800a

// primary credential(password) is not set on the identity handle, Call API to set password first.
#define     PPCRL_PRIMARYCREDS_MISSING          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  11) // 0x800b

// The handle specified by the application is invalid, make sure it is not destroyed already.
#define     PPCRL_NO_SUCH_HANDLE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  12) // 0x800c

// Session key was not found, not actionable.
#define     PPCRL_NO_SESSION_KEY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  14) // 0x800e

// Used for identity sharing, reserved.
#define     PP_E_CRL_WRONG_TOKEN_VERSION        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  15) // 0x800f
#define     PP_E_CRL_WRONG_TOKENFILE_SIZE       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  16) // 0x8010

// Reserved
#define     PPCRL_CERTCONTEXT_MISSING           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  17) // 0x8011
#define     PPCRL_SECONDARYCREDS_MISSING        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  18) // 0x8012
#define     PPCRL_SITEID_MISSING                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  19) // 0x8013
#define     PPCRL_CONSENT_NEEDED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  20) // 0x8014
#define     PP_E_CRL_INVALID_REDIRECT_URL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  21) // 0x8015

// Some parameters to make a request to the login server are missing, not actionable.
#define     PPCRL_REQUESTPARAMS_MISSING         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  24) // 0x8018

// Reserved
#define     PPCRL_REQUEST_NOT_MADE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  25) // 0x8019

// Initialize(Ex) called with an invalid GUID, make sure it is in the registry format {DF60E2DF-88AD-4526-AE21-83D130EF0F68}
#define     PP_E_CRL_INVALID_APP_GUID           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  26) // 0x801a

// Initialize(Ex) called with an invalid client version, use IDCRL_API_VERSION_CURRENT defined in msidcrl.h
#define     PP_E_CRL_INVALID_VERSION            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  27) // 0x801b

// Reserved
#define     PP_E_CRL_INVALID_HANDLE_NAME        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  28) // 0x801c

// CreateIdentityHandle was passed an invalid flag
#define     PP_E_CRL_ILLEGAL_IDENTITY_FLAG      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  29) // 0x801d

// Invalid pointer was given to an internal API to free, not actionable.
#define     PP_E_CRL_NOT_PPCRL_MEMORY           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  30) // 0x801e

// Application tried to get or set an invalid identity property name, must come from PASSPORTIDENTITYPROPERTY enum
#define     PP_E_CRL_INVALID_PROPERTY_TYPE      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  31) // 0x801f

// Application tried to call an API with an invalid identity handle. Make sure it is not destroyed already.
#define     PP_E_CRL_NO_SUCH_IDENTITY           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  32) // 0x8020

//Reserved
#define     PP_E_CRL_UNKOWN_CRED_TYPE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 33) // 0x8021
#define     PP_E_CRL_BAD_FILE                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  34) // 0x8022
#define     PP_E_CRL_INVALID_MEMBER_NAME        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE +  35) // 0x8023

// Application could not read password while trying to save or validate hashed password, Call API to set password first
#define     PP_E_PPCRL_MISSING_PASSWORD         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 36) // 0x8025

// Reserved
#define     PP_E_PPCRL_AUTH_NEED_TOU            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 38)
#define     PP_E_PPCRL_AUTH_NEED_EMAIL_VALIDATIION MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 39)
#define     PP_S_TOKEN_REQUEST_FAILED           MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE + 40)

// USER ACTIONABLE: Secure storage is not available on this OS (pstorec.dll is missing). Make sure you are running XP.
#define     PPCRL_E_PLATFORM_SECURE_STORAGE_NOT_AVAILABLE MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 41)

// Reserved
#define     PP_E_CRL_BAD_OPTION                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2A)

// InitializeEx was called with one of the options having an incorrect length, fix application code
#define     PP_E_CRL_BAD_OPTIONLENGTH           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2B)

// InitializEx was called with ivalid option id. Use one from IDCRL_OPTION_ID enum.
#define     PP_E_CRL_BAD_OPTIONID               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2C)

// USER ACTIONABLE: InitializeEx was called with a very long Proxy list. Max supported is 4*INTERNET_MAX_URL_LENGTH.
#define     PP_E_CRL_PROXYLIST_TOOLONG          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2D)

// USER ACTIONABLE: InitializeEx was called with a very long Proxy bypass list. Max supported is 4*INTERNET_MAX_URL_LENGTH.
#define     PP_E_CRL_PROXYBYPASSLIST_TOOLONG    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2E)

// USER ACTIONABLE: InitializeEx was called with a NULL option value. Remove the option if the value is NULL.
#define     PP_E_CRL_NULL_OPTION                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x2F)

// Inialize(Ex) was called with NO_UI mode, but a UI API was called. Initialize IDCRL in the UI mode to use UI.
#define     PPCRL_E_NO_UI_MODE                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x30)

// AuthIdentityToServiceEx was called with some value in dwTokenRequestFlags, it must be 0.
#define     PP_E_CRL_ILLEGAL_REQUEST_FLAG       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x31)

// Reserved
#define     PP_E_CRL_NO_SERVICE_NAME            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x32)

// No token bag was associated to the identity handle, make sure identity handle is not destroyed.
#define     PP_E_CRL_NO_TOKENBAG                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x33)

// Reserved
#define     PP_E_CRL_STATUS_UNINITIALIZED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x34)

#define     PPCRL_E_LOCK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x36)
#define     PPCRL_E_SYNC_NOLOCK                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x37)
#define     PPCRL_E_HTTP_QUERYINFO             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x38)


// IDCRL blocked your network call because you tried to use the callback thread
// to make other requests. This is against Wininet recommendations and can cause
// wininet problems. You must change your code to make network calls from another
// thread.
#define     PP_E_CRL_NW_CALL_BLOCKED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x39) // 0x8039

// Notification manager is not initialized. This is a code bug in IDCRL. Report
// to IDCRL team for investigation.
#define     PP_E_CRL_NOTIFY_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x40) // 0x8040

// Error while sending notification
#define     PP_E_CRL_NOTIFY_SEND_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x41) // 0x8041

// Error while receiving notification, this error will not be visible to the calling application
#define     PP_E_CRL_NOTIFY_RECV_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x42) // 0x8042

// Error while receiving notification, this error will not be visible to the calling application.
#define     PP_E_CRL_NOTIFY_NO_MESSAGE          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_BASE + 0x43) // 0x8043

// IDCRL is already initialized
// This is not an error in 4.0 because multiple "apps" may try to initialize IDCRL in
// the same process in 4.0 (BHO and WinLive favorites in the browser)
#define     PPCRL_S_ALREADY_INITIALIZED        MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x44) // 0x8044

// Some other app is also using IDCRL, unitialize was skipped
#define     PPCRL_S_STILL_INUSE                MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x45) // 0x8045

// Some other app has already initialized IDCRL to point to a different environment.
// This is an error condition and application cannot continue.
#define     PPCRL_E_INITIALIED_DIFF_ENVIRONMENT MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, PP_E_CRL_BASE +  0x46) // 0x8046


#define     PP_E_PROTOCOL_BASE                  PP_E_CRL_BASE + 0x100

// Reserved
#define     PPCRL_SESSIONKEY_MISSING            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 1) // 0x8101
#define     PPCRL_ERROR_RESPONSE                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 2) // 0x8102

// Bad response xml was received from the server. Not actionable.
#define     PPCRL_RESPONSE_BADXML               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 3) // 0x8103

//Reserved
#define     PPCRL_REQUEST_BADXML                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 4) // 0x8104

// GetWebAuthUrl was called but the token could not be read (t= was missing or the length was 0). Not actionable.
#define     PPCRL_TOKEN_CORRUPTED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 5) // 0x8105

// Could not decode session key from auth response, not actionable.
#define     PPCRL_BASE64DECODE_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 6) //0x8106

// Malformed response from login server, not actionable.
#define     PPCRL_RESPONSE_MISSINGREF           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 7) // 0x8107
#define     PPCRL_RESPONSE_NOTIMESTAMPORRSTR    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 8) // 0x8108
#define     PPCRL_RESPONSE_NOSIGNATUREELEMENT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 9) // 0x8109
#define     PPCRL_RESPONSE_NOCIPHERELEMENT      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 0xa) // 0x810a

// GetWebAuthUrl was called but the token type is not SERVICE_TOKEN_TYPE_PROPRIETARY. Call logon identity to get legacy passport token.
#define     PPCRL_TOKEN_WRONG_TYPE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_PROTOCOL_BASE + 0xb) // 0x810b

#define     PP_E_CRED_BASE                      PP_E_CRL_BASE + 0x200

//Reserved
#define     PP_E_DYNAMIC_SALT_CORRUPTED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 1) // 0x8201
#define     PP_E_DECRYPTION_FAILURE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 2) // 0x8202
#define     PP_E_TAMPERED_DATA                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 3) // 0x8203

// Internal obfuscator class is not initialized, not actionable.
#define     PP_E_OBFUSCATOR_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 4) // 0x8204

//Reserved
#define     PPCRL_NOT_INITIALIZED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 5) // 0x8205
#define     PPCRL_ENCODING_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRED_BASE + 6) // 0x8206


#define     PP_E_CRL_CONFIG_BASE                PP_E_CRL_BASE + 0x250
// Reserved
#define     PP_E_CRL_CONFIG_NOT_INITIALIZED     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0) // 0x8250

// Registry operations failed, use trace to determine problem.
#define     PP_E_CRL_REG_OPEN_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 1) // 0x8251
#define     PP_E_CRL_REG_QUERY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 2) // 0x8252
#define     PP_E_CRL_REG_SET_FAILED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 3) // 0x8253

// Reserved
#define     PP_E_CRL_GETWINDOWSDIR_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 4) // 0x8254
#define     PP_E_OBFUSCATE_FAILED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 5) // 0x825
#define     PP_E_LOAD_CONFIGDATA_FAILED         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 6) // 0x8256
#define     PP_E_CRL_SAVE_DATA_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 7) // 0x8257
#define     PP_E_CRL_WRITE_DATA_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 8) // 0x8258

// IDCRL is already initialized, review code and remove multiple Initialization calls.
#define     PP_E_CRL_CONFIG_ALREADY_INITIALIZED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 9) // 0x8259

// Required files or directories were missing/could not be created. Use trace to determine problem.
#define     PP_E_CRL_CACHE_DIR_ERROR            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 10)// 0x825a

// Downloading of config or ui dlls failed. Make sure passport service is not down, internet connection is good and proxy is setup correctly.
#define     PP_E_CRL_SERVICE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 11)// 0x825b

// Reserved
#define     PP_E_CORRUPT                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 20) // 0x8264

// USER ACTIONABLE: IDCRL tried to download config or UI dlls but there was no internet connection. Make sure internet connection is good.
#define     PP_E_NOTCONNECTED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 21) // 0x8265

//Reserved
#define     PP_E_PASSPORTDOWN                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 22) // 0x8266
#define     PP_E_UPDATEFAILED                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 23) // 0x8267
#define     PP_E_UPDATEINPROGRESS               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 24) // 0x8268

// System API to create a temp file name failed. Not actionable.
#define     PP_E_CRL_GET_TEMP_FILENAME_FAILED   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 25) // 0x8269

// Temp UI file name was empty. Not actionable.
#define     PP_E_CRL_EMPTY_TEMP_FILE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 26) // 0x826A

// Could not read data from Config dll. Try to download config dll again and reinitialize IDCRL.
#define     PP_E_CRL_SELECTNODE_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 27) // 0x826B
#define     PP_E_CRL_GET_ATTR_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 28) // 0x826C
#define     PP_E_CRL_GET_ITEM_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 29) // 0x826D
#define     PP_E_CRL_TOOMANY_XMLNODES           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0x2a) // 0x826E
#define     PP_E_CRL_TOOMANY_XMLATTRIBS         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 0x2b) // 0x826F

// Reserved
#define     PP_E_CRL_AQURIE_CONTEXT_FAILED       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 38) // 0x8276
#define     PP_E_CRL_IMPORT_KEY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 39) // 0x8277
#define     PP_E_CRL_CREATE_HASH_FAILED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 40) // 0x8278
#define     PP_E_CRL_HASH_DATA_FAILED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 41) // 0x8279

//Signature verification on response failed. Not actionable.
#define     PP_E_CRL_INVALID_SIG                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 42) // 0x827A
#define     PP_E_CRL_DECODE_KEY_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 43) // 0x827B
#define     PP_E_CRL_DECODE_SIG_FAILED           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 44) // 0x827C

// file found in place of directory, when trying to load configuration dll.
#define     PP_E_CRL_FILE_INSTEAD_OF_DIR        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CONFIG_BASE + 45)// 0x827D

#define     PP_E_CRL_CREDUI_BASE                    PP_E_CRL_BASE + 0x300

// Could not initialize ATL support for the UI. Not actionable.
#define     PP_E_CRL_CREDUI_ATLAXWININIT_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x1) // 0x8301

// Could not create the UI. Not actionable.
#define     PP_E_CRL_CREDUI_CREATEWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x2) // 0x8302

// Reserved
#define     PP_E_CRL_CREDUI_HOSTRETRIEVAL_FAIL      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x3) // 0x8303

// Could not get Host window pointer. Not actionable.
#define     PP_E_CRL_CREDUI_CONTROLRETRIEVAL_FAIL   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x4) // 0x8304

//Reserved
#define     PP_E_CRL_CREDUI_SHOWWINDOW_FAIL         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x5) // 0x8305
#define     PP_E_CRL_CREDUI_UPDATEWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x6) // 0x8306
#define     PP_E_CRL_CREDUI_REDRAWWINDOW_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x7) // 0x8307
#define     PP_E_CRL_CREDUI_INVALIDSIZE_FAIL        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x8) // 0x8308
#define     PP_E_CRL_CREDUI_USERNOTSPECIFIED_FAIL       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0x9) // 0x8309

//Could not retrieve UI file name. Not actionable.
#define     PP_E_CRL_CREDUI_LOCALUIMISSING          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PP_E_CRL_CREDUI_BASE + 0xA) // 0x830A


//
// This section defines errors reported by GetExtendedError API for SQM
//
#define     PPCRL_E_SQM_BASE                    PP_E_CRL_BASE + 0x400

// Could not lock the identity or request handle. This should never happen. :)
#define     PPCRL_E_SQM_UNKNOWN                                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1) // 0x8401
#define     PPCRL_E_SQM_REQUEST_CANCELLED                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2) // 0x8402
#define     PPCRL_E_SQM_QUERY_STATUSCODE                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x3) // 0x8403
#define     PPCRL_E_SQM_OUTOFMEMORY                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x4) // 0x8404
#define     PPCRL_E_SQM_READRESPONSE                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x5) // 0x8405
#define     PPCRL_E_SQM_RESPONSE_BADXML                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x6) // 0x8406
#define     PPCRL_E_SQM_INTERNET_OTHER                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x7) // 0x8407
#define     PPCRL_E_SQM_INTERNET_UI                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x8) // 0x840B
#define     PPCRL_E_SQM_INTERNET_SYNTAX                           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x9) // 0x8409
#define     PPCRL_E_SQM_INTERNET_NAME_NOT_RESOLVED                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xA) // 0x840A
#define     PPCRL_E_SQM_INTERNET_LOGIN                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xB) // 0x840B
#define     PPCRL_E_SQM_INTERNET_PROXY                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xC) // 0x840C
#define     PPCRL_E_SQM_INTERNET_OPERATION_CANCELLED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xD) // 0x840D
#define     PPCRL_E_SQM_INTERNET_INCORRECT_HANDLE_STATE           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xE) // 0x840E
#define     PPCRL_E_SQM_INTERNET_CANNOT_CONNECT                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0xF) // 0x840F
#define     PPCRL_E_SQM_INTERNET_CONNECTION_ABORTED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x10) // 0x8410
#define     PPCRL_E_SQM_INTERNET_CONNECTION_RESET                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x11) // 0X8411
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_DATE_INVALID            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x12) // 0X8412
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_CN_INVALID              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x13) // 0X8413
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_ERRORS                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x14) // 0X8414
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_NO_REV                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x15) // 0X8415
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_REV_FAILED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x16) // 0X8416
#define     PPCRL_E_SQM_INTERNET_CLIENT_AUTH_CERT_NEEDED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x17) // 0X8417
#define     PPCRL_E_SQM_INTERNET_INVALID_CA                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x18) // 0X8418
#define     PPCRL_E_SQM_INTERNET_SECURITY_WARNING                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x19) // 0X8419
#define     PPCRL_E_SQM_INTERNET_POST_IS_NON_SECURE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1A) // 0X841A
#define     PPCRL_E_SQM_FTP                                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1B) // 0X841B
#define     PPCRL_E_SQM_GOPHER                                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1C) // 0X841C
#define     PPCRL_E_SQM_HTTP_HEADER                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1D) // 0X841D
#define     PPCRL_E_SQM_HTTP_DOWNLEVEL_SERVER                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1E) // 0X841E
#define     PPCRL_E_SQM_HTTP_INVALID_SERVER_RESPONSE              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x1F) // 0X841F
#define     PPCRL_E_SQM_HTTP_INVALID_QUERY_REQUEST                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x20) // 0X8420
#define     PPCRL_E_SQM_HTTP_REDIRECT                             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x21) // 0X8421
#define     PPCRL_E_SQM_HTTP_COOKIE                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x22) // 0X8422
#define     PPCRL_E_SQM_INTERNET_SECURITY_CHANNEL_ERROR           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x23) // 0X8423
#define     PPCRL_E_SQM_INTERNET_DISCONNECTED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x24) // 0X8424
#define     PPCRL_E_SQM_INTERNET_SERVER_UNREACHABLE               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x25) // 0X8425
#define     PPCRL_E_SQM_INTERNET_PROXY_SERVER_UNREACHABLE         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x26) // 0X8426
#define     PPCRL_E_SQM_INTERNET_PROXYSCRIPT                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x27) // 0X8427
#define     PPCRL_E_SQM_INTERNET_SEC_INVALID_CERT                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x28) // 0X8428
#define     PPCRL_E_SQM_INTERNET_SEC_CERT_REVOKED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x29) // 0X8429
#define     PPCRL_E_SQM_INTERNET_AUTODIAL                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2A) // 0X842A
#define     PPCRL_E_SQM_INTERNET_NOT_INITIALIZED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2B) // 0X842B
#define     PPCRL_E_SQM_LOCK                                      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2C) // 0X842C
#define     PPCRL_E_SQM_SYNC_NOLOCK                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2D) // 0X842D
#define     PPCRL_E_SQM_HTTP_QUERYINFO                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2E) // 0X842E
#define     PPCRL_E_SQM_RESPONSE_TOO_LARGE                        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x2F) // 0X842F
#define     PPCRL_E_SQM_INVALID_AUTH_SERVICE_RESPONSE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x30) // 0X8430
#define     PPCRL_E_SQM_NO_TOKENBAG                               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x31) // 0X8431
#define     PPCRL_E_SQM_RESPONSE_NOTIMESTAMPORRSTR                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x32) // 0X8432
#define     PPCRL_E_SQM_RESPONSE_NOSIGNATUREELEMENT               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x33) // 0X8433
#define     PPCRL_E_SQM_RESPONSE_NOCIPHERELEMENT                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x34) // 0X8434
#define     PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCE_URI      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x35) // 0X8435
#define     PPCRL_E_SQM_REQUEST_E_RSTR_MISSING_REFERENCED_TOKEN   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x36) // 0X8436
#define     PPCRL_E_SQM_WAIT_ABANDONED                            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x37) // 0X8437
#define     PPCRL_E_SQM_WAIT_TIMEOUT                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x38) // 0X8438
#define     PPCRL_E_SQM_INTERNET_TIMEOUT                          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, PPCRL_E_SQM_BASE + 0x39) // 0x8439

#ifndef PPCRL_SCRIPT_ERROR_CODES

//
// PPCRL function declarations
//

#ifdef __cplusplus
namespace IDCRL
{
#endif
    /***************************************************************************
     * PassportIdentityHandle & PassportUIAuthContextHandle
     **************************************************************************/
    typedef struct _tagPIH {} * PassportIdentityHandle;
    typedef struct _tagPUACH {} * PassportUIAuthContextHandle;
    typedef struct _tagPEIH {} * PassportEnumIdentitiesHandle;

#ifdef __cplusplus
    #define INVALID_PASSPORTIDENTITYHANDLE ((IDCRL::PassportIdentityHandle)0)
    #define INVALID_PASSPORTUIAUTHCONTEXTHANDLE ((IDCRL::PassportUIAuthContextHandle)0)
    #define INVALID_PASSPORTENUMIDENTITIESHANDLE ((IDCRL::PassportEnumIdentitiesHandle)0)
#else
    #define INVALID_PASSPORTIDENTITYHANDLE ((PassportIdentityHandle)0)
    #define INVALID_PASSPORTUIAUTHCONTEXTHANDLE ((PassportUIAuthContextHandle)0)
    #define INVALID_PASSPORTENUMIDENTITIESHANDLE ((PassportEnumIdentitiesHandle)0)
#endif

    /***************************************************************************
     * NOTIFICATION_CHANGE_TYPE enum
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      IDS_USER_ACCOUNT_CHANGE: Creds were persisted or removed.
     *      IDS_USER_PROPERTY_CHANGE: user property, extended property changed.
     *      
     *
     **************************************************************************/
    typedef enum _NOTIFICATION_CHANGE_TYPE
    {
        NOTIFICATION_CHANGE_ALL_BIT = 0x000000003,  // reserved
        IDS_USER_ACCOUNT_CHANGE     = 0x000000001,
        IDS_USER_PROPERTY_CHANGE    = 0x000000002
    } NOTIFICATION_CHANGE_TYPE;


    /***************************************************************************
     * NOTIFICATION_ACTION_TYPE enum
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      IDS_NOTIFY_ADD: notification target was added
     *      IDS_NOTIFY_UPDATE: notification target was updated
     *      IDS_NOTIFY_DELETE: notification target was deleted
     *      
     *
     **************************************************************************/
    typedef enum _NOTIFICATION_ACTION_TYPE
    {
        IDS_NOTIFY_ACTION_ALL_BIT = 0x000000007,  // reserved
        IDS_NOTIFY_ACTION_ADD       = 0x000000001,
        IDS_NOTIFY_ACTION_UPDATE    = 0x000000002,
        IDS_NOTIFY_ACTION_DELETE    = 0x000000004
    } NOTIFICATION_ACTION_TYPE;

    /***************************************************************************
     * IDSUserNotification
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Structure to the change data that is given to the application in the
     *      UserStateChangeCallback.
     * NOTE
     *      Application must make a copy of string buffers before returning
     *      from the callback because the memory will be freed by IDCRL as soon as 
     *      the callback function returns
     **************************************************************************/
    typedef struct {
        DWORD   dwType;         //This and dwChangeID in the callback are the same
        DWORD   dwAction;       //Add or delete
        LPCWSTR wszAccountName;
        LPCWSTR wszCredType;
    } IDSUserNotification;

    /***************************************************************************
     * IDSUserPropertyNotification
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Structure to the change data that is given to the application in the
     *      UserStateChangeCallback.
     * NOTE
     *      Application must make a copy of string buffers before returning
     *      from the callback because the memory will be freed by IDCRL as soon as 
     *      the callback function returns.
     *      If the property value is too large to pass in the notification,
     *      fValueTooLarge flag will be set to True. Apps must call 
     *      GetUserExtendedProperty to get the actual value in this case.
     **************************************************************************/
    typedef struct {
        DWORD dwType;             // This and dwChangeID in the callback are same
        DWORD dwAction;           // Add, update or delete
        bool  bValueTooLarge;     // Property value is too large
        LPCWSTR wszAccountName; 
        LPCWSTR wszPropertyName;
        LPCWSTR wszPropertyValue;
    } IDSUserPropertyNotification;

    /***************************************************************************
     * UserStateChangedCallback
     *
     * ADDED IN RELEASE
     *      4.0
     *
     * DESCRIPTION
     *      Callback notification for use state changes. This is called whenever
     *      there is a change to the user state. E.g. user tile change, persisted
     *      credentials change.
     *
     * INPUTS
     *      dwChangeID - Type of change, from NOTIFICATION_CHANGE_TYPE enum. This
     *                   same ID is also provided in the IDSUserNotification struct.
     *      pbChangeData - Pointer to the notification data. Exact type depends
     *      on the change ID.
     *
     * RESULT
     *
     * IMPORTANT
     *      This may be called by any number of threads and could be called
     *      by multiple threads at the same time. The implementor should take
     *      care to protect any resources accessed by this implementation
     *      from such clashes of access.
     *
     **************************************************************************/
    typedef HRESULT (__stdcall * UserStateChangedCallback)(
                __in DWORD    dwChangeID,
                __in LPVOID   pbChangeData);


    /***************************************************************************
     * IdentityChangedCallback
     *
     * DESCRIPTION
     *      Callback notification for asynchronous identity activity. This
     *      is used for all UI-based authentications, and optionally for
     *      asynchronous ui-less authentications. This is called whenever
     *      the state of the identity is changed and the hosting application
     *      may want to react to this change.
     *
     *      The hosting application can check the state of the identity
     *      to determine further action (see GetAuthState, below).
     *
     * INPUTS
     *      hIdentity - The identity with state that has changed
     *      pvVoid - Void pointer that was passed in to the LogonIdentity
     *          call for the hosting application to track state.
     *      bCanContinue - The library can continue with the authentication.
     *
     * RESULT
     *      Any failed HRESULT will cause the library to discontinue any
     *      pending authentication. Any successful HRESULT will cause
     *      the library to continue this authentication if it is able.
     *      Return PPCRL_E_DISCONTINUE_AUTHENTICATION to explicitly stop
     *      a pending authentication for no other reason than
     *      control of flow.
     *
     * IMPORTANT
     *      This may be called by any number of threads and could be called
     *      by multiple threads at the same time. The implementor should take
     *      care to protect any resources accessed by this implementation
     *      from such clashes of access.
     *
     **************************************************************************/

    typedef HRESULT (__stdcall * IdentityChangedCallback)(
                __in PassportIdentityHandle hIdentity,
                __in void * pvVoid,
                __in bool bCanContinue);

    /***************************************************************************
     * UPDATE_FLAG enum
     *
     * DESCRIPTION
     *      Flags controlling general behavior of the library passed
     *      in during the Initialize call. Normally the update
     *      mechanism operates periodically and automatically based
     *      on a time-out policy. These flags allow the hosting application
     *      to over-ride this behavior. They also allow the hosting application
     *      to indicate that it can operate in offline mode (an M2 feature).
     *
     *      IDCRL 3.2: OFFLINE_MODE_ALLOWED is ignored, it will mean the same as
     *      UPDATE_DEFAULT.
     *
     *      IDCRL 3.2: SKIP_CONNECTION_CHECK: When this mode is set, IDCRL will
     *      not check if a network and Internet connection is enabled before
     *      making network calls. In this case, you will get the default windows
     *      dialog to establish a connection if you are not connected already.
     *      The default IDCRL behavior is to fail with an error if there is no
     *      connection available or default connection is not established and
     *      user has chosen to "Always dial my default connection" setting in IE.
     *
     **************************************************************************/
    typedef enum _UPDATE_FLAG
    {
        UPDATE_FLAG_ALL_BIT = 0x00000000F,            // reserved
        DEFAULT_UPDATE_POLICY =   0x00000000,
        OFFLINE_MODE_ALLOWED =    0x00000001,
        NO_UI                =    0x00000002,
        SKIP_CONNECTION_CHECK=    0x00000004,
        SET_EXTENDED_ERROR =      0x00000008,
        UPDATE_DEFAULT       =    DEFAULT_UPDATE_POLICY // online, fall back to offline

    } UPDATE_FLAG;

    /***************************************************************************
     * PASSPORTCREDUIINFO structure
     *
     * DESCRIPTION
     *      Describes the user interface for those API calls in which
     *      the client runtime library may need to create a user interface
     *      to interact with the user. (Currently only LogonIdentity.)
     *
     **************************************************************************/
    typedef struct _PASSPORTCREDUIINFO
    {
        HWND hwndParent;
        POINT ptPosition;
        SIZE szSize;
        BOOL bShow;
    } PASSPORTCREDUIINFO, *PPASSPORTCREDUIINFO;
    typedef const PPASSPORTCREDUIINFO PCPASSPORTCREDUIINFO;

    /***************************************************************************
     * PASSPORTCREDCUSTOMUI structure
     *
     * DESCRIPTION
     *      Describes customizations to the appearance of the user
     *      interface.
     *
     **************************************************************************/


    typedef struct _PASSPORT_NAME_VALUE_PAIR
    {
        LPCWSTR szName;
        LPCWSTR szValue;
    } PASSPORT_NAME_VALUE;

    typedef struct _PASSPORTCREDCUSTOMUI
    {
        DWORD  cElements;
        PASSPORT_NAME_VALUE* customValues;    // # of element == cElements
    } PASSPORTCREDCUSTOMUI, *PPASSPORTCREDCUSTOMUI;
    typedef const PPASSPORTCREDCUSTOMUI PCPASSPORTCREDCUSTOMUI;



    /***************************************************************************
     * PASSPORTCREDTYPE enum
     *
     * DESCRIPTION
     *      Bit-wise flags representing the various types of credentials
     *      the client runtime can use. Supports the UI-less API surface.
     *
     **************************************************************************/
//    #define PPCRL_CREDTYPE_PASSWORD_A "ps:password"
// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define PPCRL_CREDTYPE_PIN_A "ps:pin"

    #define PPCRL_CREDTYPE_PASSWORD         L"ps:password"
    #define PPCRL_CREDTYPE_MEMBERNAMEONLY   L"ps:membernameonly"
    #define PPCRL_CREDTYPE_VIRUTUALAPPPrefix L"ps:virtualapp="

// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define PPCRL_CREDTYPE_PIN_W L"ps:pin"

    /***************************************************************************
     * SERVICETOKENFLAGS enum
     *
     * DESCRIPTION
     *      Used for retrieving properties about a given identity handle.
     *
     **************************************************************************/
    typedef enum _SERVICETOKENFLAGS
    {
        SERVICE_TOKEN_TYPE_LEGACY_PASSPORT          = 0x00000001, //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY

        SERVICE_TOKEN_TYPE_WEBSSO                   = 0x00000002, //Deprecated, use SERVICE_TOKEN_TYPE_SAML

        SERVICE_TOKEN_TYPE_COMPACT_WEBSSO           = 0x00000004, //Deprecated, use SERVICE_TOKEN_TYPE_PROPRIETARY

        // This can be set in RSTParams.dwRequestFlags to request a SLC
        //
        SERVICE_TOKEN_TYPE_X509V3                   = 0x00000008, // added in 3.2

        SERVICE_TOKEN_CERT_IN_MEMORY_PRIVATE_KEY    = 0x00000010, // this can be used with SERVICE_TOKEN_TYPE_X509V3

#ifdef  __TOKEN_TYPE        // REMOVED
        // Rest of bits in first byte reserved
        SERVICE_TOKEN_TYPE_ANY                      = 0x000000ff,
#endif

        //
        // Check the local cache for an existing service ticket.
        // If not set a call always results in a server request.
        // This is particularly useful for async service request
        // calls where the result puts the ticket in the
        // cache where it can be retrieved with a subsequent
        // call.
        //
        SERVICE_TOKEN_FROM_CACHE                    = 0x00010000,

        SERVICE_TOKEN_TYPE_SAML                     = SERVICE_TOKEN_TYPE_WEBSSO, //Response only

        // Proprietary ticket type includes both PPM and Compact tickets
        // These token types are combined into one to not break older clients
        // Older client will continue to see LEGACY_PASSPORT token type for 
        // compact tickets and they can keep sending them to the partner server
        // just like they do the PPM tickets.
        SERVICE_TOKEN_TYPE_PROPRIETARY              = SERVICE_TOKEN_TYPE_LEGACY_PASSPORT //Response only

    } SERVICETOKENFLAGS;

    typedef enum _SERVICETOKEN_REQUEST_FLAGS
    {

        SERVICE_TOKEN_REQUEST_TYPE_NONE            = 0x00000000,

        SERVICE_TOKEN_REQUEST_TYPE_X509V3          = SERVICE_TOKEN_TYPE_X509V3

    } SERVICETOKEN_REQUEST_FLAGS;

    //
    // Used internally by IDCRL to indicate that no certificate requests
    // are to be made. MSN unified v2 bug 161946.
    //
    typedef enum _MULTIRSTPARAMS_FLAGS
    {
        REQUEST_DEFAULT                            = 0x00000000,
        REQUEST_NO_SLC                             = 0x00000001

    } MULTIRSTPARAMS_FLAGS;

    /***************************************************************************
     * OfflinePBKDF2Params structure
     *
     * DESCRIPTION
     *      Params for a PBKDF2-based session key derivation from the
     *      offline credentials. See DeriveOfflineKey, below.
     *
     **************************************************************************/
    typedef struct _OfflinePBKDF2Params
    {
        ALG_ID algId;
        DWORD dwIterations;
        void * pvSalt;
        DWORD cbSaltLength;
        DWORD cbDerivedKeyLength;
    } OfflinePBKDF2Params, *POfflinePBKDF2Params;
    typedef const POfflinePBKDF2Params PCOfflinePBKDF2Params;

    /***************************************************************************
     * OfflineKeyMethod enum
     *
     * DESCRIPTION
     *      Determines the algorithm to use to derive the offline key.
     *
     **************************************************************************/
    typedef enum _OfflineKeyMethod
    {
        OFFLINE_KEY_PBKDF2_ON_PASSWORD              = 1
    } OfflineKeyMethod;


    /***************************************************************************
     * IDENTITY_FLAG enum
     *
     * DESCRIPTION
     *      Flags controlling properties of a particular identity
     *      handle. May be combined and passed in to the
     *      dwFlags parameter to CreateIdentityHandle.
     *
     **************************************************************************/
    typedef enum _IDENTITY_FLAG
    {
        IDENTITY_ALL_BIT                   =        0x000003ff, // reserved
        IDENTITY_SHARE_ALL                 =        0x000000ff, // Specific bit semantics are reserved
        IDENTITY_LOAD_FROM_PERSISTED_STORE =        0x00000100, // this requires member name, and will do a look up in the persisted store
        IDENTITY_AUTHSTATE_ENCRYPTED       =        0x00000200  // used by CreateIdentityHandleFromAuthState to indicate if the auth info is encrypted
    } IDENTITY_FLAG;


    /***************************************************************************
     * LOGON_FLAG enum
     *
     * DESCRIPTION
     *      Flags that can be passed into the various LogonIdentity API's
     *      to control the authentication process.
     *
     **************************************************************************/
    typedef enum _LOGON_FLAG
    {
        LOGONIDENTITY_ALL_BIT                   =   0x0000000F, // reserved
        LOGONIDENTITY_DEFAULT                   =   0x00000000,
        LOGONIDENTITY_ALLOW_OFFLINE             =   0x00000001,
        LOGONIDENTITY_FORCE_OFFLINE             =   0x00000002,
        LOGONIDENTITY_CREATE_OFFLINE_HASH       =   0x00000004,
        LOGONIDENTITY_ALLOW_PERSISTENT_COOKIES  =   0x00000008
    } LOGON_FLAG;

    /***************************************************************************
     * IDCRL_OPTION_IDS enum
     *
     * DESCRIPTION
     *      IDs of valid options that can be given to InitializeEx  or 
     *      SetIdcrlOptions APIs. (Except IDCRL_OPTION_ENVIRONMENT, which can only
     *      be specified at Initialization time)
     *
     *      IDCRL_OPTION_ENVIRONMENT
     *      Valid environments names are Betaprep, INT, PPE and PROD plus some 
     *      internal passport test environments. Apps can import environments.reg 
     *      file to import URLs to all passport environments. Note that this option
     *      can only be specified at Initialization time.
     *
     **************************************************************************/
    typedef enum {
        IDCRL_OPTION_ALL_BIT                = 0x0000007F, // reserved
        IDCRL_OPTION_PROXY                  = 0x00000001, //INTERNET_OPTION_PROXY
        IDCRL_OPTION_CONNECT_TIMEOUT        = 0x00000002, //INTERNET_OPTION_CONNECT_TIMEOUT
        IDCRL_OPTION_SEND_TIMEOUT           = 0x00000004, //INTERNET_OPTION_SEND_TIMEOUT
        IDCRL_OPTION_RECEIVE_TIMEOUT        = 0x00000008, //INTERNET_OPTION_RECEIVE_TIMEOUT
        IDCRL_OPTION_PROXY_PASSWORD         = 0x00000010, //INTERNET_OPTION_PROXY_PASSWORD
        IDCRL_OPTION_PROXY_USERNAME         = 0x00000020, //INTERNET_OPTION_PROXY_USERNAME
        IDCRL_OPTION_ENVIRONMENT            = 0x00000040  //Point to the named environment
    } IDCRL_OPTION_ID;

    /***************************************************************************
     * IDCRL_SETOPTIONS_FLAG enum
     *
     * DESCRIPTION
     *      IDs of valid options that can be given to InitializeEx call
     *
     **************************************************************************/
    typedef enum {
        IDCRL_SETOPTIONS_DEFAULT             = 0x00000000,
        IDCRL_SETOPTIONS_SET                 = IDCRL_SETOPTIONS_DEFAULT,
        IDCRL_SETOPTIONS_RESET               = 0x00000001
    } IDCRL_SETOPTIONS_FLAG;

    /***************************************************************************
     * IDCRL_OPTION struct
     *
     * DESCRIPTION
     *      Holds an option for IDCRL initialization through InitializeEx API.
     *      dwId   : option id from IDCRL_OPTION_ID enum
     *      pValue : Option value passed in as a BYTE *. The actual data 
     *                 structure will differ with the option id
     *      cbValue  : Byte size of the value
     *
     **************************************************************************/
    typedef struct {
        IDCRL_OPTION_ID dwId;
        BYTE *          pValue;
        size_t          cbValue;
    } IDCRL_OPTION, * LPIDCRL_OPTION;

    /***************************************************************************
     * IDCRL_OPTIONS struct
     *
     * DESCRIPTION
     *      Holds all options for IDCRL initialization through InitializeEx API.
     *      dwCount : Number of options
     *      arrOptions : Array of options
     *
     **************************************************************************/
    typedef struct {
        DWORD            dwCount;
        IDCRL_OPTION *   arrOptions; // Points to an array of structs with the size
                                       // given by dwCount
    } IDCRL_OPTIONS, * LPIDCRL_OPTIONS;

    /***************************************************************************
     * RSTParams - Request Security Token Params
     *   - added in IDCRL 3.2 to allow application to request multiple tokens
     *
     * DESCRIPTION
     *      the structure to hold information related to request a service token
     *
     **************************************************************************/
    typedef struct _RSTParams
    {
        __in DWORD   cbSize;             // size of the struct
        __in LPCWSTR wzServiceTarget;    // dname of the service
        __in LPCWSTR wzServicePolicy;    // policy for issuing the token
        __in DWORD   dwTokenFlags;       // for SLC, use SERVICE_TOKEN_TYPE_X509V3                                         // otherwise, 0
        __in DWORD   dwTokenParam;       // Params -
                                         // SLC, key size in bit
                                         // otherwise, 0
    } RSTParams, *PRSTParams;
    typedef const PRSTParams PCRSTParams;

    /***************************************************************************
     * MultiRSTParams
     *   - added in IDCRL 3.2 to allow application to request multiple tokens
     *
     * DESCRIPTION
     *      parameter required to
     *
     **************************************************************************/
    typedef struct _MultiRSTParams
    {
        DWORD       dwRSTParamsCount;    // # of RSTParams in the array, 0 is invalid
        PRSTParams  pRSTParams;    // pointer to the array of RSTParams
        DWORD       dwMultiRSTParamsFlags; // flags from MULTIRSTPARAMS_FLAGS
    } MultiRSTParams, *PMultiRSTParams;
    typedef const PMultiRSTParams PCMultiRSTParams;


    /***************************************************************************
     * Client-defined policy constants
     *
     * DESCRIPTION
     *      Constants allowing the hosting application to indicate particular
     *      common policy attributes.
     *
     **************************************************************************/

    #define AUTH_POLICY_DEFAULT NULL

// 116306    PPCRL: DCR -- Remove support for Security PIN (seclevel=100)
// 116306     #define AUTH_POLICY_REQUIRE_PIN_A       "ppcrl:pin"
// 116306     #define AUTH_POLICY_REQUIRE_PIN_W       L"ppcrl:pin"

    // FUTURE: #define AUTH_POLICY_REQUIRE_CERT_A      "ppcrl:cert"
    // FUTURE: #define AUTH_POLICY_REQUIRE_CERT_W      L"ppcrl:cert"

    /***************************************************************************
     * Client-defined service name constants
     *
     * DESCRIPTION
     *      Constants allowing the hosting application to indicate particular
     *      service targets.
     *
     **************************************************************************/

    #define SERVICE_TARGET_PASSPORT     L"http://Passport.NET/tb"


    #define ENV_PRODUCTION              L"production"

    /***************************************************************************
     * Initialize
     *
     * DESCRIPTION
     *      Must be called before and return successfully before any other
     *      client runtime library functions are called.
     *
     * INPUTS
     *      guid - A GUID that uniquely identifies the hosting application.
     *              This allows features such as customized user interfaces
     *              to match the hosting application's look and feel.
     *      lPPCRLVersion - Binary version of the API
     *      dwFlags - Initialization flags from the UPDATE_FLAG enum above.
     *
     **************************************************************************/
IDCRL_API Initialize(
        __in REFGUID guid,
        __in LONG lPPCRLVersion,
        __in DWORD dwFlags);

    /***************************************************************************
     * InitializeEx
     *
     * DESCRIPTION
     *      Must be called before and return successfully before any other
     *      client runtime library functions are called. This function supports
     *      setting some optional parameters that Initialize does not support.
     *
     * INPUTS
     *      guid - A GUID that uniquely identifies the hosting application.
     *              This allows features such as customized user interfaces
     *              to match the hosting application's look and feel.
     *      lPPCRLVersion - Binary version of the API
     *      dwFlags - Initialization flags from the UPDATE_FLAG enum above.
     *      pOptions - Additional options to set. e.g. proxy information.
     *      dwOptions - count of options in pOptions.
     *
     **************************************************************************/
IDCRL_API InitializeEx(
        __in REFGUID         guid,
        __in LONG            lPPCRLVersion,
        __in DWORD           dwFlags,
        __in_opt LPIDCRL_OPTION  pOptions,
        __in_opt DWORD           dwOptions);


    /***************************************************************************
     * Uninitialize
     *
     * DESCRIPTION
     *      Must be called when shutting down the client runtime library. This
     *      will immediately invalidate any extant identity handles.
     *
     **************************************************************************/

IDCRL_API Uninitialize(void);

    /***************************************************************************
     * CreateIdentityHandle
     *
     * DESCRIPTION
     *      Used to create new identity handles, which then be authenticated
     *      with credentials and acquire authentication tokens.
     *
     * INPUTS
     *      szMemberName - Member name to initialize the identity to. May
     *              be NULL and set later with SetIdentityProperty (or
     *              by the user if UI is being used).
     *      dwFlags - Identity creation flags.
     *
     * OUTPUTS
     *      pihIdentity - New identity handle. May be passed to LogonIdentity, etc.
     *              Must be released with CloseIdentityHandle eventually.
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandle(
        __in_opt LPCWSTR wszMemberName,
        __in DWORD dwFlags,
        __out PassportIdentityHandle * pihIdentity);

    /***************************************************************************
     * CloseIdentityHandle
     *
     * DESCRIPTION
     *      Closes an identity handle previously opened with CreateIdentityHandle
     *      freeing any resources associated with the identity.
     *
     * INPUTS
     *      hIdentity - Identity handle to close.
     *
     **************************************************************************/
IDCRL_API CloseIdentityHandle(
        __in PassportIdentityHandle hIdentity);

    /***************************************************************************
     * CreatePassportAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Creates a UI context for the PPCRL to use its built-in user
     *      interface for credential collection and error handling when
     *      dealing with the user to authenticate.
     *
     * INPUTS
     *      pcuiInfo - describes the configurable attributes of the built-in
     *                  user interface
     *      ppachAuthContext - Address to receive the auth context handle
     *                  for the newly-created context.
     *
     * RESULTS
     *      Creates a UI authentication context that can be used when
     *      authenticating identities.
     *
     **************************************************************************/
    IDCRL_API CreatePassportAuthUIContext(
            __in const PASSPORTCREDUIINFO * pcuiInfo,
            __in const PASSPORTCREDCUSTOMUI * pcuiCustomUI,
            __out PassportUIAuthContextHandle * ppachAuthContext);

    /***************************************************************************
     * GetPreferredAuthUIContextSize
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Returns the preferred screen dimensions for an AuthUIContext.
     *      This may change depending upon the state of the identity handle
     *      (some error flows recommend a large window). Therefore the
     *      authentication and request states of the given identity
     *      will be taken into account.
     *
     * INPUTS
     *      hIdentity - Optional identity to return the preferred dimensions
     *          for. Of a NULL handle is given, the preferred dimensions for
     *          initial authenticaiton are returned.
     *
     * RESULTS
     *      Returns the width and height that are preferred to perform
     *      an authentication with UI for the given identity.
     *
     **************************************************************************/

IDCRL_API GetPreferredAuthUIContextSize(
        __in PassportIdentityHandle hIdentity,
        __out SIZE * pszSize
        );

    /***************************************************************************
     * MoveAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Allows a hosting application to change the size of an
     *      authentication UI context that has already been created. This
     *      is most useful to handling error flows, etc. where the size
     *      returned by GetPreferredAuthUIContextSize indicates a different
     *      size would be more appropriate.
     *
     * INPUTS
     *      hAuthContext - Authentication context to resize and/or move
     *      szNewSize - New size for the authentication context
     *
     * RESULTS
     *      The authentication context is resized.
     *
     **************************************************************************/

IDCRL_API MoveAuthUIContext(
        __in PassportUIAuthContextHandle hAuthContext,
        __in POINT ptPosition,
        __in SIZE szNewSize
        );

    /***************************************************************************
     * DestroyPassportAuthUIContext
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Destroys a previously-allocated UI context, freeing the resources
     *      associated with it.
     *
     **************************************************************************/
IDCRL_API DestroyPassportAuthUIContext(
        __in PassportUIAuthContextHandle pachAuthContext);

    /***************************************************************************
     * SetCredential
     *
     * DESCRIPTION
     *      Sets a specified credential on the given identity handle. Any
     *      set credential will be used, as-needed, for all future authentication
     *      requests on this identity.
     *
     * INPUTS
     *      hIdentity - Identity handle to close.
     *      wszCredType - Credential type to set (from PPCRL_CREDTYPE_*
     *                  definitions, above).
     *      wszCredValue - Credential to associate with the identity.
     *
     **************************************************************************/
IDCRL_API SetCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType,
        __in LPCWSTR wszCredValue);

    /***************************************************************************
     * SetIdentityCallback
     *
     * DESCRIPTION
     *      Associates a callback procedure with the identity for asynchronous
     *      functionality. Any identity without an associated callback will
     *      operate synchronously.
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API SetIdentityCallback(
        __in PassportIdentityHandle hIdentity,
        __in IdentityChangedCallback pfCallbackNotification,
        __in_opt void * pvCallbackData
        );


    /***************************************************************************
     * CancelPendingRequest - Added in 3.2
     *
     * DESCRIPTION
     *      Cancel the pending request, so callback function will not be called
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API CancelPendingRequest(
        __in PassportIdentityHandle hIdentity
        );


    /***************************************************************************
     * LogonIdentity(Ex)
     *
     * DESCRIPTION
     *      Fundamental call of the Passport client runtime library. Allows
     *      the creation of an authenticated identity. This version of the
     *      call allows credentials to be provided by the calling application.
     *
     * RESULTS
     *      Upon success, the given identity handle will possess the
     *      appropriate authentication state based on the credentials
     *      presented.
     *
     *      Service tokens are requested with Ex version.
     *      the service tokens will be put in cache, use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     **************************************************************************/
IDCRL_API LogonIdentity(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags // From LOGON_FLAG enum above
        );

IDCRL_API LogonIdentityEx(  // new for 3.2
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszAuthPolicy,
        __in DWORD dwAuthFlags, // From LOGON_FLAG enum above
        __in_opt PCRSTParams pcRSTParams,   // service tokens requests
        __in_opt DWORD       dwRSTParamsCount
        );


    /***************************************************************************
     * BuildAuthTokenRequest INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      Get XML that would be sent out in LogonIdentity API
     *
     *
     **************************************************************************/
IDCRL_API BuildAuthTokenRequest(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags,
        __out LPWSTR * pszRequestXML
        );

// TODO: rename the existing function as its internal
IDCRL_API BuildAuthTokenRequestEx(
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags,
        __in_opt PCRSTParams pcRSTParams,   // service tokens requests
        __in_opt DWORD       dwRSTParamsCount,
        __out LPWSTR * szRequestXML
        );

    /***************************************************************************
     * GetWebAuthUrl
     *
     * DESCRIPTION
     *      Get Url and post data for web authentication. E.g. for hotmail inbox
     * INPUTS
     *      hIdentity: Identity handle created previously
     *      szTargetServiceName: Reserved
     *      szServicePolicy:     Reserved
     *      szAdditionalPostParams: Other params required for the call the core
     *      params computed by the API. For MD5, these include: ru, kv, svc, rru,
     *      id and sid.
     *      szSourceServiceName: Service name used earlier to authenticate the user
     *      pszWebAuthUrl: Output param that holds the URL to post the data
     *      pszPostData: Post data to be sent with the request, it includes the
     *      additional post params specified in szAdditionalPostParams
     * RESULTS
     *      Upon success, the API will give a URL with a blob of data that
     *      can be POSTed to the URL for authentication
     * NOTES
     *      Calling application must set the following header:
     *            Content-Type: application/x-www-form-urlencoded
     *      for the POST request to be accepted by the login server.
     **************************************************************************/
IDCRL_API GetWebAuthUrl(
            __in     PassportIdentityHandle hIdentity,
            __in_opt LPCWSTR                szTargetServiceName,
            __in_opt LPCWSTR                szServicePolicy,
            __in     LPCWSTR                szAdditionalPostParams,
            __in     LPCWSTR                szSourceServiceName,
            __out    LPWSTR *               pszWebAuthUrl,
            __out    LPWSTR *               pszPostData);

    /***************************************************************************
     * GetWebAuthUrlEx
     *
     * DESCRIPTION
     *      Get Url and post data for web authentication. E.g. for hotmail inbox
     * INPUTS
     *      hIdentity: Identity handle created previously
     *      szTargetServiceUrl: target service url. If you specify the svc
     *      or ru param in additional post data, you must NOT specify this.
     *      szServicePolicy:     policy for the service ticket
     *      szAdditionalPostParams: Other params required for the call the core
     *      params computed by the API. 
     *      pszWebAuthUrl: Output param that holds the URL to post the data
     *      pszPostData: Post data to be sent with the request, it includes the
     *      additional post params specified in szAdditionalPostParams
     * RESULTS
     *      Upon success, the API will give a URL with a blob of data that
     *      can be POSTed to the URL for authentication, this is using PSHA1Auth
     *      E_INVALIDARG
     *      PP_E_CRL_NOT_INITIALIZED
     *      PP_E_CRL_NO_SUCH_IDENTITY
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PPCRL_E_NO_SESSION_KEY
     *      E_OUTOFMEMORY
     *
     * NOTES
     *      Calling application must set the following header:
     *            Content-Type: application/x-www-form-urlencoded
     *      for the POST request to be accepted by the login server.
     **************************************************************************/
     
    typedef enum {
        IDCRL_WEBAUTH_NONE                  = 0x00000000,
        IDCRL_WEBAUTH_REAUTH                = 0x00000001
    } IDCRL_WEBAUTHOPTION;
    
IDCRL_API GetWebAuthUrlEx(
            __in     PassportIdentityHandle hIdentity,
            __in     DWORD                  dwFlags,              // IDCRL_WEBAUTHOPTION
            __in_opt LPCWSTR                szTargetServiceUrl,
            __in_opt LPCWSTR                szServicePolicy,
            __in     LPCWSTR                szAdditionalPostParams,
            __out    LPWSTR *               pszWebAuthUrl,
            __out    LPWSTR *               pszPostData);



    /***************************************************************************
     * LogonIdentityWithUI
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Requests an authentication using the client runtime's built-in
     *      user interface for credential collection and error handling.
     *
     *      UI-based authentications are always asynchronous in nature (as
     *      they depend on user input), so a valid call-back is required.
     *      This also means that this call always returns immediately
     *      to the caller, and the authentication process occurs over
     *      time as Windows messages are pumped and the library is
     *      able to interact with the user and the auth servers.
     *
     * INPUTS
     *      pachAuthContext - The UI authentication context to be used
     *          for this authentication. This comes from
     *          CreatePassportAuthUIContext function, above.
     *      pihUser - Identity handle to authenticate.
     *      szPolicy - Optional policy to apply to the authentication
     *      dwAuthFlags - Flags controlling the authentication.
     *
     * RESULTS
     *      Upon success, the given identity handle will possess the
     *      appropriate authentication state based on the credentials
     *      presented.
     *
     *      Service tokens are requested with Ex version.
     *      the service tokens will be put in cache, use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     **************************************************************************/
IDCRL_API LogonIdentityWithUI(
        __in PassportUIAuthContextHandle pachAuthContext,
        __in PassportIdentityHandle hIdentity,
        __in_opt LPCWSTR wszPolicy,
        __in DWORD dwAuthFlags // From LOGON_FLAG enum above
        );


	/***************************************************************************
	 * Names of credential properties
	 * These can be used with GetIdentityPropertyByName API
	***************************************************************************/
	#define PPCRL_CREDPROPERTY_MEMBER_NAME            L"MemberName"
	#define PPCRL_CREDPROPERTY_PUIDSTR                L"PUID"
	#define PPCRL_CREDPROPERTY_ONETIMECREDENTIAL      L"OneTimeCredential"
	#define PPCRL_CREDPROPERTY_CID                    L"CID"
	#define PPCRL_CREDPROPERTY_MAINBRANDID            L"MainBrandID"
	#define PPCRL_CREDPROPERTY_BRANDIDLIST            L"BrandIDList"
	#define PPCRL_CREDPROPERTY_ISWINLIVEUSER          L"IsWinLiveUser"

	/***************************************************************************
     * PASSPORTIDENTITYPROPERTY enum
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Used for retrieving properties about a given identity handle.
     *      This enum is used with the now deprecated GetIdentityProperty API.
     *      Apps should use GetIdentityPropertyByName to get all properties.
     *
     **************************************************************************/
    typedef enum _PASSPORTIDENTITYPROPERTY
    {
        IDENTITY_MEMBER_NAME        = 1,
        IDENTITY_PUIDSTR            = 2
    } PASSPORTIDENTITYPROPERTY;

    /***************************************************************************
     * GetIdentityProperty
     *
     *                     !!! D E P R E C A T E D !!!
     *                     !!! D E P R E C A T E D !!!
     *
     * DESCRIPTION
     *      Retrieves the value of a property associated with an identity handle.
     *      This API is deprecated. Use GetIdentityPropertyByName instead.
     *
     * RESULTS
     *      Upon success, the value of the property will be stored on the
     *      szPropertyValue buffer. The buffer must be freed with a call
     *      to
     *
     **************************************************************************/
IDCRL_API GetIdentityProperty(
        __in PassportIdentityHandle hIdentity,
        __in PASSPORTIDENTITYPROPERTY ipProperty,
        __out LPWSTR * szPropertyValue
        );

    /***************************************************************************
     * GetIdentityPropertyByName
     *
     * DESCRIPTION
     *      Retrieves the value of a property associated with an identity handle.
     *
     * RESULTS
     *      Upon success, the value of the property will be stored on the
     *      wszPropertyValue buffer. The buffer must be freed with a call
     *      to
     *
     **************************************************************************/
IDCRL_API GetIdentityPropertyByName(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszPropertyName,
        __out LPWSTR * pwszPropertyValue);

    /***************************************************************************
     * SetIdentityProperty
     *
     * DESCRIPTION
     *      Sets the specified property on the identity. Note that not all
     *      properties are settable. Currently apps may only set IDENTITY_MEMBER_NAME
     *      using this API.
     *
     * RESULTS
     *
     **************************************************************************/
IDCRL_API SetIdentityProperty(
        __in PassportIdentityHandle hIdentity,
        __in PASSPORTIDENTITYPROPERTY ipProperty,
        __in LPCWSTR wszPropertyValue
        );

    /***************************************************************************
     * GetAuthState
     *
     * DESCRIPTION
     *      Returns the authentication and request state associated
     *      with the given identity handle. This allows the calling
     *      application to determine not only the current authentication
     *      state, but the state of the last request made on behalf
     *      of this identity. The calling application can use this
     *      information to deal with the state/errors appropriately.
     *
     *      The Ex version is used to query states for a particular service token
     *      When wzServiceTarget == NULL, the states from last request is returned
     *
     * RESULTS
     *      Returns the authentication status, the authentication
     *      required (if any), the status of the last request
     *      based on this identity, and may optionally
     *      return a URL that the hosting application can take
     *      the user to in order to explain and/or resolve the
     *      error.
     *
     **************************************************************************/
IDCRL_API GetAuthState(
        __in PassportIdentityHandle hIdentity,
        __out_opt HRESULT * phrAuthState,
        __out_opt HRESULT * phrAuthRequired,
        __out_opt HRESULT * phrRequestStatus,
        __out_opt LPWSTR * szWebFlowUrl = 0
        );

IDCRL_API GetAuthStateEx( // new in 3.2
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR        wzServiceTarget,
        __out_opt HRESULT * phrAuthState,
        __out_opt HRESULT * phrAuthRequired,
        __out_opt HRESULT * phrRequestStatus,
        __out_opt LPWSTR * szWebFlowUrl = 0
        );

    /***************************************************************************
     * EnumIdentitiesWithCachedCredentials
     *
     * DESCRIPTION
     *      Enumerates stored credentials allowing the hosting
     *      application to determine which credentials are
     *      present.
     *
     * INPUTS
     *      szCachedCredType - If non-NULL and non-empty, specifies
     *      the credential type to limit iteration of. For example,
     *      if PPCRL_CREDTYPE_PASSWORD is passed here, only identities
     *      with cached passwords will be iterated. If NULL or an
     *      empty string is passed here, then all identities with
     *      any type of cached credential will be iterated.
     *
     * RESULTS
     *      A enumeration handle that allows iteration through
     *      the identities.
     *
     **************************************************************************/
IDCRL_API EnumIdentitiesWithCachedCredentials(
        __in_opt LPCWSTR wszCachedCredType,
        __out PassportEnumIdentitiesHandle * peihEnumHandle
        );

    /***************************************************************************
     * NextIdentity
     *
     * DESCRIPTION
     *      Returns the next identity for the given enumeration handle.
     *
     * INPUTS
     *      hEnumHandle - Handle as returned from EnumIdentities* call
     *      above.
     *
     * OUTPUTS
     *      szMemberName - The member name with cached credentials
     *
     * NOTES
     *      Any strings returned as outputs must be freed with PassportFreeMemory.
     *      However, if the pointers are passed back in as outputs to
     *      a PPCRL call, any previous string will be correctly freed.
     *
     **************************************************************************/
IDCRL_API NextIdentity(
        __in PassportEnumIdentitiesHandle hEnumHandle,
        __out LPWSTR * wszMemberName
        );

    /***************************************************************************
     * HasPersistedCredential
     *
     * DESCRIPTION
     *      Returns whether or not the specified identity has a persisted
     *      credential of the specified type.
     *
     * INPUTS
     *      hIdentity - the identity to check persisted credentials of
     *      szCredType - the credential type to check for persistence
     *
     * OUTPUTS
     *      pbHasPersistentCred - Whether or not there is a persistent
     *          credential.
     *
     **************************************************************************/
IDCRL_API HasPersistedCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szCredType,
        __out bool * pbHasPersistentCred
        );

    /***************************************************************************
     * PersistCredential
     *
     * DESCRIPTION
     *      Stores, updates and/or deletes stored credentials.
     *
     * INPUTS
     *      pihIdentity - Identity from to persist credentials for.
     *      wszCredType - Credential type on the identity to persist.
     *
     * RESULTS
     *      The persistent credential store is updated based on the
     *      credentials stored on the identity.
     *
     **************************************************************************/
IDCRL_API PersistCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType
        );

    /***************************************************************************
     * RemovePersistedCredential
     *
     * DESCRIPTION
     *      Removes credentials from persistent storage.
     *
     * INPUTS
     *      pihIdentity - Identity from which to remove credentials
     *      wszCredType - Credential type to delete from the store
     *
     * RESULTS
     *      Any previously persisted credential will be deleted from
     *      the store. Any transient credential left on the identity
     *      itself is left unchanged.
     *
     **************************************************************************/
IDCRL_API RemovePersistedCredential(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszCredType
        );

    /***************************************************************************
     * CloseEnumIdentitiesHandle
     *
     * DESCRIPTION
     *      Closes an identity iterator, freeing resource associated with it.
     *
     * INPUTS
     *      hEnumHandle - The iterator to close
     *
     **************************************************************************/
IDCRL_API CloseEnumIdentitiesHandle(
        __in PassportEnumIdentitiesHandle hEnumHandle);

    /***************************************************************************
     * AuthIdentityToService
     *
     * DESCRIPTION
     *      Using an authenticated identity, attempts to retrieve a service
     *      token for that identity to the specified resource. If additional
     *      user interface interaction is required from the user, this
     *      call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      szServiceTarget - URI representing the webservice. This is primarily
     *              to identity the resource and need not necessarily represent
     *              a real service URL.
     *      szServicePolicy - Policy if the application knows
     *              it or can provide it directly. This may be provided by the
     *              hosting application directly or extract from the application-
     *              level challenge from an initial attempt to access the
     *              resource.
     *
     * OUTPUTS
     *      pcbSessionKey / pcbSessionKeyLength - If the service token format
     *              supports it, this will return a session key to the hosting
     *              application that matches the symmetric session key inside
     *              the service token. This key material is binary, so care
     *              should be taken to not utilize any manipulations that
     *              may terminate on embedded null or non-printable characters.
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API AuthIdentityToService(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget,
        __in_opt LPCWSTR szServicePolicy,
        __in DWORD dwTokenRequestFlags,
        __out LPWSTR * szToken,
        __out_opt DWORD * pdwResultFlags,
        __out_opt BYTE ** ppbSessionKey,
        __out_opt DWORD * pcbSessionKeyLength
        );

    /***************************************************************************
     * AuthIdentityToServiceEx - added in 3.2
     *
     * DESCRIPTION
     *      Using an authenticated identity, attempts to retrieve a set of
     *      service tokens for that identity to the specified resources.
     *      If additional
     *      user interface interaction is required from the user, this
     *      call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      pcRSTParams - parameters for service tokens
     *      dwRSTParamsCount - number of parameters
     *
     * OUTPUTS
     *      the service tokens will be put in cache if async,
     *      use AuthIdentityToService
     *      with SERVICE_TOKEN_FROM_CACHE flag to retrieve from cache
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API AuthIdentityToServiceEx(
        __in PassportIdentityHandle hIdentity,
        __in DWORD dwRequestFlags,      // Must be 0, Reserved
        __in PCRSTParams pcRSTParams,   // service tokens requests
        __in DWORD       dwRSTParamsCount
        );

    /***************************************************************************
     * CERTREQUESTFLAGS enum
     *
     * DESCRIPTION
     *      flags for GetCertificate call.
     *
     **************************************************************************/
    typedef enum _CERTREQUESTFLAGS
    {
        //
        // If CERT_FROM_CACHE is set, a call only checks cache
        // if CERT_FROM_NETWORK is set, request always results in a network call
        // if neither is set: a cached one is returned if a cacked one satisfies the TTL
        // otherwise, it results in a network call
        //
        CERT_FROM_CACHE                    = SERVICE_TOKEN_FROM_CACHE,
        CERT_FROM_SERVER                   = 0x00020000,

    } CERTREQUESTFLAGS;


    /***************************************************************************
     * GetCertificate - added in 3.2
     *
     * DESCRIPTION
     *      Using an authenticated identity to get a certficate for this user
     *      for that identity to the specified service name.
     *      If additional user interface interaction is required from the user,
     *      this call may fail with an error code indicating that LogonIdentity
     *      needs to be called to enhance the authentication state before
     *      the service token can be granted (e.g., if a PIN needs
     *      to be collected).
     *
     * INPUTS
     *      hIdentity - Authenticated identity handle returned from LogonIdentity
     *      pcRSTParams - parameters for the certificate request
     *      pdwTTL      - If getting from cache, as input, minimum acceptable TTL
     *                    as output, actual remaining TTL. Has no effect for a
     *                    new certificate request from network.
     *      dwRequestFlags - indicate if the cert should be from the cache
     *
     *
     * OUTPUTS
     *      ppCertContext - the cert context, this context can be used with
     *           cryto API for cert/public key/private key related operations.
     *           IDCRL maitains the private key for this cert.  It clears
     *           the private key when it requesing a new cert from passport.
     *           Application must call CertFreeCertificateContext and
     *           stop using the certcontext before the next GetCerficate call.
     *      ppbPOP     - Optional parameter to receive the proof of possession
     *           blob. Applications can give this blob to VerifyCertificate API
     *           to perform POP check on the certificate. Application must free
     *           it with PassportFreeMemory API after using.
     *      pcbPOP     - If ppbPOP is not NULL, you must also pass this parameter
     *           to get the size of the POP blob.
     *      ppCACertContext - Optional parameter to receive the CA certificate
     *           context. Application must free it with CertFreeCertificateContext
     *           API after using. The CA cert context may be expired in time but
     *           corresponds to the signature on the subject certificate.
     *
     * RESULTS
     *      S_OK if successful
     *      PPCRL_S_OK_CLIENTTIME if successful but the clock skew is not set
     *
     **************************************************************************/
IDCRL_API GetCertificate(
        __in PassportIdentityHandle hIdentity,
        __in PCRSTParams     pcRSTParams,
        __inout DWORD *      pdwTTL,           // determines TTL if get from cache
                                                // this doesn't control the TTL
                                                // for a new cert. in seconds
        __in DWORD           dwRequestFlags,    // 0 or CERT_FROM_CACHE
                                                //      CERT_FROM_NETWORK
        __out     PCCERT_CONTEXT* ppCertContext,   // Cert context
        __out_opt BYTE**          ppbPOP = NULL,          // Optional POP blob
        __out_opt DWORD*          pcbPOP = NULL,          // Size of POP blob
        __out_opt PCCERT_CONTEXT* ppCACertContext = NULL  // CA Cert context
        );


    /***************************************************************************
     * BuildServiceTokenRequest - INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      Get XML string for Service request, without sending the request
     *
     * INPUTS - see AuthIdentityToService
     *
     * OUTPUTS
     *      szXML: the request in xml format
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API BuildServiceTokenRequest(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget,
        __in_opt LPCWSTR szServicePolicy,
        __in DWORD dwTokenRequestFlags,
        __out LPWSTR * szRequestXML
        );

// TODO: change name: new for 3.2
IDCRL_API BuildServiceTokenRequestEx(
        __in PassportIdentityHandle hIdentity,
        __in PCRSTParams pcRSTParams,   // service tokens requests
        __in DWORD       dwRSTParamsCount,
        __out LPWSTR * szRequestXML
        );


    /***************************************************************************
     * RESPONSE_TYPE enum
     *
     * DESCRIPTION
     *      flags for the internal PutTokenResponse function.
     *
     **************************************************************************/
    typedef enum _RESPONSE_TYPE
    {
        //
        // RESPONSE_TYPE_AUTH indicates response to an auth request.
        // RESPONSE_TYPE_SERVICE indicates responset to a service token request.
        //
        PPCRL_RESPONSE_TYPE_AUTH                    = 0x00000000,
        PPCRL_RESPONSE_TYPE_SERVICE                 = 0x00000001,

    } RESPONSE_TYPE;

    /***************************************************************************
     * PutTokenResponse - INTERNAL FUNC bahavior & signature change in 3.2
     *
     * DESCRIPTION
     *      parse the RST response XML, and put tokens in cache,
     *      by putting a Auth response using this API, IDCRL can be used to
     *      request service tokens. Response type must be RESPONSE_TYPE_AUTH
     *      or RESPONSE_TYPE_SERVICE.
     *
     * NOTE
     *      Removed out params from function in 3.2 because nobody uses them.
     *      Changed to use enum to indicate auth vs service response
     *
     **************************************************************************/
IDCRL_API PutTokenResponse(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
        __in LPCWSTR  szResponse,
        __out_opt LPWSTR * szToken,
        __out_opt DWORD * pdwResultFlags,
        __out_opt BYTE ** ppbSessionKey,
        __out_opt DWORD * pcbSessionKeyLength
        );

// new for 3.2
IDCRL_API PutTokenResponseEx(
        __in PassportIdentityHandle hIdentity,
        __in DWORD    dwResponseType,
        __in LPCWSTR  szResponse
        );

    /***************************************************************************
     * DeriveOfflineKey
     *
     * DESCRIPTION
     *      For offline scenarios, this method can be used to return a key
     *      derived from the user's credentials.
     *
     * INPUTS
     *      hIdentity       - Identity handle holding credentials from
     *                        which to derive the offline key.
     *      okmMethod       - Desired method of offline key derivation
     *      vpOfflineKeyParameters - Parameters for the key
     *                        derivation. These are dependent upon okmMethod
     *
     * OUTPUTS
     *      vpOfflineKeyMaterial - Buffer to accept raw key material if
     *                        it is desired. Buffer must be at least large
     *                        enough to accept the key material appropriate
     *                        for the derivation method (e.g., for PBKDF2
     *                        this is defined by the cbDerivedKeyLength
     *                        parameter).
     *      phSessionKey    - CryptoAPI key handle with the key material
     *                        imported into it.
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
#ifdef  __PPCRL_SUPPORT_OFFLINE_KEY
IDCRL_API DeriveOfflineKey(
        __in PassportIdentityHandle hIdentity,
        __in OfflineKeyMethod okmMethod,
        __in_opt void * vpOfflineKeyParameters,
        __out_opt void * vpOfflineKeyMaterial,
        __in_opt HCRYPTPROV hCryptProv,
        __out_opt HCRYPTKEY * phSessionKey
        );

#endif // #ifdef  __PPCRL_SUPPORT_OFFLINE_KEY

    /***************************************************************************
     * PassportFreeMemory
     *
     * DESCRIPTION
     *      Frees buffers allocated and returned by the client runtime library.
     *
     * INPUTS
     *      TBD
     *
     * RESULTS
     *      TBD
     *
     **************************************************************************/
IDCRL_API PassportFreeMemory(
        __in void * pMemoryToFree
        );

    /***************************************************************************
     * VerifyCertificate
     *
     * DESCRIPTION
     *      check if the cert can be chained back to one of the certs in config.
     *
     * INPUTS
     *      PCERT_CONTEXT - Pointer to a cert context of the certificate you
     *      dwTTL         - As input, it is the minimum acceptable TTL, as output
     *                      it is the actual remaining TTL.
     *      pbPOP         - POP blob to verify
     *      cbPOP         - size of the pop blob in bytes
     *      ppCACertContext - Optional parameter to receive the CA certificate
     *           context. Application must free it with CertFreeCertificateContext
     *           API after using. The CA cert context may be expired in time but
     *           corresponds to the signature on the subject certificate.
     *
     * RESULTS
     *      S_OK if the cert matches. S_FALSE if no match present, and E_INVALIDARG if invalid args passed in
     *      PPCRL_S_OK_CLIENTTIME if the clock skew is not set
     *
     **************************************************************************/
IDCRL_API VerifyCertificate(
        __in PCCERT_CONTEXT pCertContext,
        __inout DWORD *     pdwTTL,
        __in_opt    BYTE*       pbPOP = NULL,           //  POP blob
        __in_opt    DWORD       cbPOP = 0,              // size of POP blob
        __out_opt   PCCERT_CONTEXT* ppCACertContext = NULL // CA cert context
        );


    /***************************************************************************
     * GetExtendedError
     *
     * DESCRIPTION
     *      Gives extended error information for certain IDCRL error conditions.
     *      Its functionality is similar to GetLastError system API at the identity
     *      handle scope.
     *
     * INPUTS
     *      hIdentity: Identity handle.
     *
     * OUTPUT
     *      pdwCategory: error category, from the IDCRL_ERROR_CATEGORY enum.
     *      pdwError:    Actual error code. It will be the unmasked error at the
     *                   point of failure. The error is from the PPCRL_E_SQM_
     *                   errors defined in this file.
     *      pszErrorBlob: A string blob with additional error information (trace
     *      statements, request or response data, etc).
     *
     * RESULT
     *       PPCRL_E_EXTENDED_ERROR_NOT_SET: You must initialize IDCRL with the
     *       SET_EXTENDED_ERROR  flag to set extended error information.
     *
     *       S_FALSE: No extended error information is set on this identity handle.
     *
     * NOTES
     *      The error state is reset when the application calls any IDCRL API
     *      except GetAuthState(Ex).
     *      Caller must free pszErrorBlob by calling PassportFreeMemory when done.
     *
     **************************************************************************/

typedef enum _IDCRL_ERROR_CATEGORY
{
    IDCRL_REQUEST_BUILD_ERROR               = 0x00000001,
    IDCRL_REQUEST_SEND_ERROR                = 0x00000002,
    IDCRL_RESPONSE_RECEIVE_ERROR            = 0x00000003,
    IDCRL_RESPONSE_READ_ERROR               = 0x00000004,
    IDCRL_REPSONSE_PARSE_ERROR              = 0x00000005,
    IDCRL_RESPONSE_SIG_DECRYPT_ERROR        = 0x00000006,
    IDCRL_RESPONSE_PARSE_HEADER_ERROR       = 0x00000007,
    IDCRL_RESPONSE_PARSE_TOKEN_ERROR        = 0x00000008,
    IDCRL_RESPONSE_PUTCERT_ERROR            = 0x00000009
} IDCRL_ERROR_CATEGORY;

IDCRL_API GetExtendedError(
    __in      PassportIdentityHandle hIdentity,
    __in      LPVOID   pReserved,
    __out     DWORD   *pdwCategory,
    __out     DWORD   *pdwError, 
    __out_opt LPWSTR  *pszErrorBlob);

    /***************************************************************************
     * ExportAuthState - Export AuthToken into a blob
     *
     * DESCRIPTION
     *      Export authenticate token and its session key into an xml blob
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      wszAuthToken: the request in xml format
     *             
     * NOTE: 
     *      wszAuthToken: should be free'ed with PassportFreeMemory
     * RESULTS
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      E_INVALIDARG
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PP_E_CRL_NOT_INITIALIZED
     *      
     *
     **************************************************************************/
IDCRL_API ExportAuthState(
        __in PassportIdentityHandle hIdentity,
        __in DWORD dwFlags,                 //  == 0, reserved 
        __out LPWSTR * wszAuthToken
        );

    /***************************************************************************
     * CreateIdentityHandleFromAuthState - create an identity handle, and import
     *                                     the authtoken blob
     *
     * DESCRIPTION
     *      wszAuthToken: the auth token
     *      dwFlags:      IDENTITY_FLAG
     * INPUTS - 
     *
     * OUTPUTS
     *      pihIdentity: the identity handle, this should be closed by: CloseIdentityHandle
     *
     * RESULTS
     *      E_INVALIDARG
     *      E_POINTER  -- when pihIdentity is NULL
     *      PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
     *      PP_E_CRL_NOT_INITIALIZED
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandleFromAuthState(
        __in LPCWSTR wszAuthToken,
        __in DWORD dwFlags,                             // IDENTITY_FLAG
        __out PassportIdentityHandle * pihIdentity);


    /***************************************************************************
     * CacheAuthState - cache auth state for a virtual application
     *
     * DESCRIPTION
     *      hIdentity: identity handle
     *      wszVirtualAppName: the name of the virtual application - suggest GUID
     *      dwFlags: reserved
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      write auth state block in cred manager under the virutal application
     *
     * RESULTS
     *      E_INVALIDARG
     *      PPCRL_E_NO_MEMBER_NAME_SET
     *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
     *      PPCRL_E_AUTHBLOB_TOO_LARGE (64 * 256 bytes)
     *      
     *
     **************************************************************************/
IDCRL_API CacheAuthState(
        __in PassportIdentityHandle hIdentity,
        __in LPCWSTR wszVirtualAppName,     // required
        __in DWORD dwFlags                 //  == 0, reserved 
        );

    /***************************************************************************
     * RemoveAuthStateFromCache - remove cached auth state for a virtual application
     *
     * DESCRIPTION
     *      hIdentity: identity handle - can be NULL, when NULL, user name is
     *                 not checked, and all users removed under the same virtual app
     *      wszVirtualAppName: the name of the virtual application - can be NULL,
     *                         when NULL, virtual app name is not checked, and all removed
     *      dwFlags: reserved
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      write auth state block in cred manager under the virutal application
     *
     * RESULTS
     *      PPCRL_E_AUTHBLOB_NOT_FOUND
     *
     **************************************************************************/
IDCRL_API RemoveAuthStateFromCache(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszVirtualAppName,     // required
        __in DWORD dwFlags                 //  == 0, reserved 
        );

    /***************************************************************************
     * CreateIdentityHandleFromCachedAuthState - create an identity handle, and import
     *                                     the authtoken blob from cache
     *
     * DESCRIPTION
     *      wszUserName: the name of the user - NULL, any user
     *      wszVirtualAppName: the name of the virtual app - NULL, any app
     *      dwFlags: IDENTITY_FLAG
     *
     * INPUTS - 
     *
     * OUTPUTS
     *      pihIdentity: the identity handle, this should be closed by: CloseIdentityHandle
     *
     * RESULTS
     *      E_INVALIDARG
     *      E_POINTER  -- when pihIdentity is NULL
     *      PP_E_CRL_ILLEGAL_IDENTITY_FLAG - 
     *      PP_E_CRL_NOT_INITIALIZED
     *
     **************************************************************************/
IDCRL_API CreateIdentityHandleFromCachedAuthState(
        __in_opt LPCWSTR wszUserName,
        __in LPCWSTR wszVirtualAppName,
        __in DWORD dwFlags,                             // IDENTITY_FLAG
        __out PassportIdentityHandle * pihIdentity);


//
// extended properties for all the users on the windows logon session
#define EXT_PROPERTY_NAME_PUBLICCOMPUTER    L"PublicComputer"
#define EXT_PROPERTY_VALUE_TRUE             L"1"
#define EXT_PROPERTY_VALUE_FALSE            L"0"
#define EXT_PROPERTY_VALUE_REMOVE           NULL

/***************************************************************************
 * SetExtendedProperty - set name value pair - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *      wszPropertyValue: value of the property, NULL or empty string will delete an existing value
 *
 * INPUTS - 
 *
 * OUTPUTS
 *
 * RESULTS
 *      E_INVALIDARG
 *      Error from registry access API:RegOpenKeyEx RegSetValueEx RegDeleteValue
 *
 **************************************************************************/
IDCRL_API SetExtendedProperty(
        __in LPCWSTR wszPropertyName,
        __in LPCWSTR wszPropertyValue);

/***************************************************************************
 * GetExtendedProperty - get the value for a given name - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *
 * INPUTS - 
 *
 * OUTPUTS
 *      pwszPropertyValue: value of the property, IDCRL allocates the buffer, and it 
 *                         should be freed with PassportFreeMemory call
 *
 * RESULTS
 *      
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_CRL_NOT_INITIALIZED
 *      Error from registry access API:RegOpenKeyEx RegGetValueEx
 *
 **************************************************************************/
IDCRL_API GetExtendedProperty(
        __in LPCWSTR wszPropertyName,
        __out LPWSTR* pwszPropertyValue);

/***************************************************************************
 * GetServiceConfig - get config settings in the config xml
 *
 * DESCRIPTION
 *
 * INPUTS - 
 *      wszServiceName: name of the entry
 *
 * OUTPUTS
 *      pwszURLValue: IDCRL allocates the buffer, which should be released with 
 *                    PassportFreeMemory call
 *
 * RESULTS
 *      E_INVALIDARG
 *      S_FALSE : not found
 *
 **************************************************************************/
IDCRL_API GetServiceConfig(
        __in LPCWSTR wszValueName,
        __out LPWSTR* pwszURLValue);

/***************************************************************************
 * MigratePersistedCredentials - migrate the users from registry to cred man for a specific app
 *
 * DESCRIPTION
 *
 * INPUTS - 
 *      guid: the GUID of the app
 *      bKeepOldCreds: If true, IDCRL will NOT delete old credentials after migrating
 *      to Credman store. This is application for scenarios where a user may want
 *      to downgrade to a previous version of the app.
 *      Note: It is a security risk to preserve old credentials and apps should
 *      make the decision to keep or delete them carefully.
 *
 * OUTPUTS
 *      dwUserCount: number of users being migrated 
 *
 * RESULTS
 *      E_INVALIDARG
 *
 **************************************************************************/
IDCRL_API MigratePersistedCredentials(
        __in REFGUID guid,
        __in bool    bKeepOldCreds,
        __out_opt DWORD* pdwUserCount);


/***************************************************************************
 * SetIdcrlOptions
 *
 * DESCRIPTION
 *      Call this to update optional settings for IDCRL. You may call it
 *      after Initializing IDCRL to update settings.
 *
 * INPUTS
 *      pOptions - Additional options to set. e.g. proxy information.
 *      dwOptions - count of options in pOptions.
 *      dwFlags   - Flags to the API, current supported flags are defined in
 *                  IDCRL_SETOPTIONS_FLAG enum. Default behavior is to set the
 *                  options. This API does not take IDCRL_OPTION_ENVIRONMENT
 *                  flag.
 *      
 * RETURN
 *      PPCRL_E_INVALIDFLAGS
 *      PP_E_CRL_NULL_OPTION
 *      PP_E_CRL_BAD_OPTIONLENGTH
 *      PP_E_CRL_PROXYLIST_TOOLONG
 *      PP_E_CRL_PROXYBYPASSLIST_TOOLONG
 *
 * REMARKS
 *      IDCRL_SETOPTIONS_SET and IDCRL_SETOPTIONS_RESET flags are mutually
 *      exclusive.
 *
 **************************************************************************/
IDCRL_API SetIdcrlOptions(
        __in LPIDCRL_OPTION  pOptions,
        __in DWORD           dwOptions,
        __in_opt DWORD       dwFlags = IDCRL_SETOPTIONS_DEFAULT);

/***************************************************************************
 * EncryptWithSessionKey
 *
 * DESCRIPTION
 *      Call this to encrypt data blob with session key in the service token
 *      the encrypted blob can be sent to the target service
 *
 * INPUTS
 *
 * OUTPUTS
 *      ppbCipher   - IDCRL will allocate buffer upon success, PassportFreeMemory 
 *                    should be used to free the memory
 *      
 * RETURN
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_CRL_NO_SUCH_IDENTITY
 *      PPCRL_E_UNABLE_TO_RETRIEVE_SERVICE_TOKEN
 *      PPCRL_E_NO_SESSION_KEY
 *
 * REMARKS
 *     3DES and HMAC_SHA1 are used
 *
 **************************************************************************/
IDCRL_API EncryptWithSessionKey(
    __in PassportIdentityHandle hIdentity,
    __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
    __in ALG_ID  algIdEncrypt,
    __in ALG_ID  algIdHash,
    __in BYTE*   pData,
    __in DWORD   cbData,
    __out BYTE ** ppbCipher,
    __out DWORD * pcbCipher);

/***************************************************************************
 * DecryptWithSessionKey
 *
 * DESCRIPTION
 *      Call this to decrypt data encrypted with EncryptWithSessionKey, 
 *      this data can be from IDCRL or RPS on the service target machine
 *
 * INPUTS
 *
 * OUTPUTS
 *      ppbCipher   - IDCRL will allocate buffer upon success, PassportFreeMemory 
 *                    should be used to free the memory
 *      
 * RETURN
 *      E_INVALIDARG
 *      E_OUTOFMEMORY
 *      PP_E_SESSIONKEY_INVALIDDATA
 *      PP_E_SESSIONKEY_INVALIDSIGNATURE
 *      PPCRL_E_NO_SESSION_KEY
 *
 * REMARKS
 *     3DES and HMAC_SHA1 are used
 *
 **************************************************************************/
IDCRL_API DecryptWithSessionKey(
    __in PassportIdentityHandle hIdentity,
    __in LPCWSTR szServiceTarget, // when this is NULL, it's auth response
    __in ALG_ID  algIdEncrypt,
    __in ALG_ID  algIdHash,
    __in BYTE*   pCipher,
    __in DWORD   cbCipher,
    __out BYTE ** ppbData,
    __out DWORD * pcbData);


//
// extended user properties for all the users on the windows logon session
#define EXT_USER_PROPERTY_NAME_USERTILEURL    L"UserTileUrl"
#define EXT_USER_PROPERTY_NAME_IDTILETIMESTAMP L"IDTileTimestamp"

#define EXT_USER_PROPERTY_VALUE_REMOVE           NULL

/***************************************************************************
 * SetUserExtendedProperty - set name value pair - per windows logon property
 *
 * DESCRIPTION
 *      wszMemberName: 
 *      wszPropertyName: name of the property
 *      wszPropertyValue: value of the property, NULL or empty string will delete an existing value
 *
 *    can only set the property if the user chosed to store his/her user name
 *
 * INPUTS - 
 *
 * OUTPUTS
 *
 * RESULTS
 *      E_INVALIDARG
 *      PPCRL_E_USER_NOTFOUND
 *      Error from registry access API:RegOpenKeyEx RegSetValueEx RegDeleteValue
 *
 **************************************************************************/
IDCRL_API SetUserExtendedProperty(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszPropertyName,
        __in LPCWSTR wszPropertyValue);

/***************************************************************************
 * GetUserExtendedProperty - get the value for a given name - per windows logon property
 *
 * DESCRIPTION
 *      wszPropertyName: name of the property
 *
 * INPUTS - 
 *
 * OUTPUTS
 *      pwszPropertyValue: value of the property, IDCRL allocates the buffer, and it 
 *                         should be freed with PassportFreeMemory call
 *
 * RESULTS
 *      
 *      E_INVALIDARG
 *      PPCRL_E_USER_NOTFOUND
 *      Error from registry access API:RegOpenKeyEx RegGetValueEx
 *
 **************************************************************************/
IDCRL_API GetUserExtendedProperty(
        __in LPCWSTR wszUserName,
        __in LPCWSTR wszPropertyName,
        __out LPWSTR* pwszPropertyValue);


/***************************************************************************
 * SetChangeNotificationCallback
 *
 * ADDED IN RELEASE
 *      4.0
 *
 * DESCRIPTION
 *      Registers the callback for user account state change notifications.
 *
 *      Current triggers for notifications are:
 *      1. PersistCredential and the credential was not previously persisted.
 *      2. RemovePersistedCredential and the cred was previously persisted.
 *      3. SetUserExtendedProperty (always).
 *
 * INPUTS -
 *     wszVirtualApp: Name of the virtual application.
 *     dwReserverd: Reserved
 *     UserStateChangedCallback: Pointer to the application's callback function.
 *     See UserStateChangedCallback in the header file for the signature.
 *
 * RESULTS
 *      
 *      S_OK
 *
 **************************************************************************/
IDCRL_API SetChangeNotificationCallback(
       __in LPCWSTR wszVirtualApp, 
       __in DWORD dwReserved, 
       __in UserStateChangedCallback pfCallbackNotification);

/***************************************************************************
 * RemoveChangeNotificationCallback
 *
 * ADDED IN RELEASE
 *      4.0
 *
 * DESCRIPTION
 *      Removes the callback for user account state change notifications
 *
 * INPUTS -
 *
 * RESULTS
 *      
 *      S_OK
 *
 **************************************************************************/
IDCRL_API RemoveChangeNotificationCallback();

#ifdef __cplusplus
} // Namespace IDCRL
#endif


#ifdef __cplusplus
}; // extern "C"
#endif


#endif /* not defined PPCRL_SCRIPT_ERROR_CODES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\PassportRPS\4.5.2135\inc\errormsg.h ===
// Master error message MC file
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_PP_USERINPUT            0x4
#define FACILITY_PP_UPPI                 0xFFF
#define FACILITY_PP_RESERVED             0xFFE
#define FACILITY_PP_INTERNAL             0x4
#define FACILITY_PP_DB                   0xFFF


//
// Define the severity codes
//
#define SEVERITY_PP_SUCCESS              0x0
#define SEVERITY_PP_ERROR                0x2
#define SEVERITY_PP_DBERROR              0x3


//
// MessageId: PP_E_INTERNAL_ERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal error (hr=%1), please try later.
//
#define PP_E_INTERNAL_ERROR              ((HRESULT)0x8FFE0001L)

//
// MessageId: PP_E_NOT_PP_ERROR
//
// MessageText:
//
//  This is not an error code defined by Passport (hr=%1).
//
#define PP_E_NOT_PP_ERROR                ((HRESULT)0x8FFE0002L)    

// base 0x1000
//
// MessageId: PP_S_TIMEZONE_OLD
//
// MessageText:
//
//  A pre 2.0 time zone is detected.
//
#define PP_S_TIMEZONE_OLD                ((HRESULT)0x00041000L)

//
// MessageId: PP_S_REDIRECT_TO_PARTNER
//
// MessageText:
//
//  Login is successful; redirect back to the partner.
//
#define PP_S_REDIRECT_TO_PARTNER         ((HRESULT)0x00041001L)

//
// MessageId: E_PPFAIL
//
// MessageText:
//
//  Login server failed to read site object properties.
//
#define E_PPFAIL                         ((HRESULT)0x80040FFFL)

//
// MessageId: PP_E_COMFAIL
//
// MessageText:
//
//  The PPMT callback failed to either set or get properties.
//
#define PP_E_COMFAIL                     ((HRESULT)0x80041000L)

//
// MessageId: PP_E_TOOMANYREQUESTS
//
// MessageText:
//
//  Login server has detected too many cookie copy request for the same cookie in the configured time window.
//
#define PP_E_TOOMANYREQUESTS             ((HRESULT)0x80041002L)

//
// MessageId: PP_E_SVC_NOT_CONFIGURED
//
// MessageText:
//
//  The delegated admin service was not configured with the crypt COM object, or the login server could not find the domain for a webSSO request.
//
#define PP_E_SVC_NOT_CONFIGURED          ((HRESULT)0x80041003L)

//
// MessageId: PP_E_PROFILENOTEXIST
//
// MessageText:
//
//  Profile was not found.
//
#define PP_E_PROFILENOTEXIST             ((HRESULT)0x80041007L)

//
// MessageId: PP_E_TICKETEXPIRED
//
// MessageText:
//
//  The Passport authentication ticket has expired
//
#define PP_E_TICKETEXPIRED               ((HRESULT)0x80041008L)

//
// MessageId: PP_E_TICKETNOTEXIST
//
// MessageText:
//
//  The current client does not have a Passport auth. ticket.
//
#define PP_E_TICKETNOTEXIST              ((HRESULT)0x80041009L)

//
// MessageId: PP_E_SECTICKETNOTEXIST
//
// MessageText:
//
//  Missing secure ticket.
//
#define PP_E_SECTICKETNOTEXIST           ((HRESULT)0x8004100AL)

//
// MessageId: PP_E_SECTICKETNOTMATCH
//
// MessageText:
//
//  The secure ticket has invalid length.
//
#define PP_E_SECTICKETNOTMATCH           ((HRESULT)0x8004100BL)

//
// MessageId: PP_E_FORCESIGNIN
//
// MessageText:
//
//  The client is required to sign in because the ticket is not present or the partner requires a forced-sign in.
//
#define PP_E_FORCESIGNIN                 ((HRESULT)0x8004100CL)

//
// MessageId: PP_E_EXCLUDED
//
// MessageText:
//
//  The credential is blocked.
//
#define PP_E_EXCLUDED                    ((HRESULT)0x80041010L)

//
// MessageId: PP_E_MEMBER_LOCKED
//
// MessageText:
//
//  The credential is locked out.
//
#define PP_E_MEMBER_LOCKED               ((HRESULT)0x80041011L)

//
// MessageId: PP_E_BAD_PASSWORD
//
// MessageText:
//
//  The entered and stored passwords do not match.
//
#define PP_E_BAD_PASSWORD                ((HRESULT)0x80041012L)

//
// MessageId: PP_E_NOT_OVER_SSL
//
// MessageText:
//
//  The request needs to be made over SSL.
//
#define PP_E_NOT_OVER_SSL                ((HRESULT)0x80041016L)

//
// MessageId: PP_E_INVALIDSITEID
//
// MessageText:
//
//  The site id could be invalid, or the specified return URL does not match the return URL for the site, or the return URL for the given site is not valid.
//
#define PP_E_INVALIDSITEID               ((HRESULT)0x80041018L)

//
// MessageId: PP_E_INVALIDMEMBERNAME
//
// MessageText:
//
//  The specified member name is invalid; the domain or syntax could be invalid.
//
#define PP_E_INVALIDMEMBERNAME           ((HRESULT)0x80041019L)

//
// MessageId: PP_E_INVALIDRETURNURL
//
// MessageText:
//
//  The return URL for the given site is not valid.
//
#define PP_E_INVALIDRETURNURL            ((HRESULT)0x8004101AL)

//
// MessageId: PP_E_INVALIDKEYVERSION
//
// MessageText:
//
//  The key for the specified version could not be found.
//
#define PP_E_INVALIDKEYVERSION           ((HRESULT)0x8004101BL)

//
// MessageId: PP_E_INVALIDREQUEST
//
// MessageText:
//
//  The member name or Passport ticket is invalid during password reset.
//
#define PP_E_INVALIDREQUEST              ((HRESULT)0x8004101CL)

//
// MessageId: PP_E_INVALIDPARAMS
//
// MessageText:
//
//  An invalid parameter or member variable was encountered.
//
#define PP_E_INVALIDPARAMS               ((HRESULT)0x8004101DL)

//
// MessageId: PP_E_NOCREDENTIALS
//
// MessageText:
//
//  No credential was found in the DB for the specified name.
//
#define PP_E_NOCREDENTIALS               ((HRESULT)0x8004101EL)

//
// MessageId: PP_E_NOAUTH
//
// MessageText:
//
//  No value was found for the MSPAuth cookie in MD5 auth.
//
#define PP_E_NOAUTH                      ((HRESULT)0x8004101FL)

//
// MessageId: PP_E_NO_SL
//
// MessageText:
//
//  No value was found for the session length in MD5 auth
//
#define PP_E_NO_SL                       ((HRESULT)0x80041020L)

//
// MessageId: PP_E_NO_ALIAS
//
// MessageText:
//
//  The member name was not specified in MD5 auth or password change.
//
#define PP_E_NO_ALIAS                    ((HRESULT)0x80041022L)

//
// MessageId: PP_E_NO_PASSWORD
//
// MessageText:
//
//  No password was entered for the password change.
//
#define PP_E_NO_PASSWORD                 ((HRESULT)0x80041023L)

//
// MessageId: PP_E_NO_DOMAIN
//
// MessageText:
//
//  There is no domain in the specified member name.
//
#define PP_E_NO_DOMAIN                   ((HRESULT)0x80041024L)

//
// MessageId: PP_E_INVALIDMODE
//
// MessageText:
//
//  The domain portion of the member name specified in the XML registration is invalid.
//
#define PP_E_INVALIDMODE                 ((HRESULT)0x80041026L)

//
// MessageId: PP_E_USER_BAD_LOGIN
//
// MessageText:
//
//  The client could not login.
//
#define PP_E_USER_BAD_LOGIN              ((HRESULT)0x80041027L)

//
// MessageId: PP_E_DIFFERENT_USER
//
// MessageText:
//
//  The current ticket does not belong to the specified member.
//
#define PP_E_DIFFERENT_USER              ((HRESULT)0x80041029L)

//
// MessageId: PP_E_NOT_EMAIL_INPUT
//
// MessageText:
//
//  The specified member name does not have the right syntax; the '@' is missing.
//
#define PP_E_NOT_EMAIL_INPUT             ((HRESULT)0x8004102FL)

//
// MessageId: PP_E_MISSING_CREDS
//
// MessageText:
//
//  The hash is not provided during MD5 or digest auth.
//
#define PP_E_MISSING_CREDS               ((HRESULT)0x80041030L)

//
// MessageId: PP_E_MISSING_MEMBERNAME
//
// MessageText:
//
//  The specified member name during password reset or certificate login is empty.
//
#define PP_E_MISSING_MEMBERNAME          ((HRESULT)0x80041031L)

//
// MessageId: PP_E_MISSING_PASSWORD
//
// MessageText:
//
//  No password was specified during login.
//
#define PP_E_MISSING_PASSWORD            ((HRESULT)0x80041032L)

//
// MessageId: PP_E_INVALID_MEMBERNAME
//
// MessageText:
//
//  The specified member name is either invalid or empty.
//
#define PP_E_INVALID_MEMBERNAME          ((HRESULT)0x80041034L)

//
// MessageId: PP_E_WRONG_DA_DOMAIN
//
// MessageText:
//
//  The domain is not supported.
//
#define PP_E_WRONG_DA_DOMAIN             ((HRESULT)0x80041035L)

//
// MessageId: PP_E_LOCATION_WRONG
//
// MessageText:
//
//  The specified country, postal code or region is wrong or empty.
//
#define PP_E_LOCATION_WRONG              ((HRESULT)0x80041038L)

//
// MessageId: PP_E_SECRET_ANS_WRONG
//
// MessageText:
//
//  The specified country, postal code or region does not match the ones in the profile, or the secret answer does not match the one in the DB.
//
#define PP_E_SECRET_ANS_WRONG            ((HRESULT)0x80041039L)

//
// MessageId: PP_E_KID_HAS_NO_CONSENT
//
// MessageText:
//
//  The PP kids account does not have consent.
//
#define PP_E_KID_HAS_NO_CONSENT          ((HRESULT)0x8004103AL)

//
// MessageId: PP_E_NO_COUNTRY
//
// MessageText:
//
//  The specified country is empty during password reset.
//
#define PP_E_NO_COUNTRY                  ((HRESULT)0x8004103BL)

//
// MessageId: PP_E_NO_REGION
//
// MessageText:
//
//  The specified region is empty during password reset.
//
#define PP_E_NO_REGION                   ((HRESULT)0x8004103CL)

//
// MessageId: PP_E_NO_POSTALCODE
//
// MessageText:
//
//  The specified postal code is empty during password reset.
//
#define PP_E_NO_POSTALCODE               ((HRESULT)0x8004103DL)

//
// MessageId: PP_E_NO_SECRET_ANSWER
//
// MessageText:
//
//  No secret answer was provided.
//
#define PP_E_NO_SECRET_ANSWER            ((HRESULT)0x8004103EL)

//
// MessageId: PP_E_NEED_STRONG_CREDENTIALS
//
// MessageText:
//
//  Strong credential is needed. The current ticket with strong credential could have expired.
//
#define PP_E_NEED_STRONG_CREDENTIALS     ((HRESULT)0x80041040L)

//
// MessageId: PP_E_BAD_PIN
//
// MessageText:
//
//  The entered PIN does not match one in the DB for the member.
//
#define PP_E_BAD_PIN                     ((HRESULT)0x80041041L)

//
// MessageId: PP_E_EMAIL_TAKEN
//
// MessageText:
//
//  The specified member name is being used.
//
#define PP_E_EMAIL_TAKEN                 ((HRESULT)0x80041042L)

//
// MessageId: PP_E_BAD_PINSA
//
// MessageText:
//
//  The answer for the secret question during secure auth is incorrect.
//
#define PP_E_BAD_PINSA                   ((HRESULT)0x80041043L)

//
// MessageId: PP_E_MISSING_PIN
//
// MessageText:
//
//  No PIN was entered.
//
#define PP_E_MISSING_PIN                 ((HRESULT)0x80041044L)

//
// MessageId: PP_E_MISSING_PINSA
//
// MessageText:
//
//  Not all the secret questions were answered.
//
#define PP_E_MISSING_PINSA               ((HRESULT)0x80041045L)

//
// MessageId: PP_E_PIN_MISMATCH
//
// MessageText:
//
//  The confirmation and specified PINs do not match for mobile auth.
//
#define PP_E_PIN_MISMATCH                ((HRESULT)0x80041046L)

//
// MessageId: PP_E_PIN_INVALID
//
// MessageText:
//
//  The PIN entered for mobile auth is invalid.
//
#define PP_E_PIN_INVALID                 ((HRESULT)0x80041047L)

//
// MessageId: PP_E_PIN_BLANK
//
// MessageText:
//
//  No PIN was entered for mobile auth.
//
#define PP_E_PIN_BLANK                   ((HRESULT)0x80041048L)

//
// MessageId: PP_E_PIN_TOO_SHORT
//
// MessageText:
//
//  The entered PIN for mobile auth is too short. The default minimum is 6 characters.
//
#define PP_E_PIN_TOO_SHORT               ((HRESULT)0x80041049L)

//
// MessageId: PP_E_PIN_TOO_LONG
//
// MessageText:
//
//  The entered PIN for mobile auth is too long. The default maximum is 16 characters.
//
#define PP_E_PIN_TOO_LONG                ((HRESULT)0x8004104AL)

//
// MessageId: PP_E_PIN_CONTAINS_MEMBERNAME
//
// MessageText:
//
//  The entered PIN for mobile auth contains the member name.
//
#define PP_E_PIN_CONTAINS_MEMBERNAME     ((HRESULT)0x8004104BL)

//
// MessageId: PP_E_FORCE_RENAME
//
// MessageText:
//
//  The credential is in a forced renamed state (either non-active, or active but not managed in a managed domain.)
//
#define PP_E_FORCE_RENAME                ((HRESULT)0x8004104CL)

//
// MessageId: PP_E_MISSING_PHONENUM
//
// MessageText:
//
//  No phone number was entered.
//
#define PP_E_MISSING_PHONENUM            ((HRESULT)0x8004104DL)

//
// MessageId: PP_E_MISSING_PHONEPIN
//
// MessageText:
//
//  No phone PIN was provided for auth.
//
#define PP_E_MISSING_PHONEPIN            ((HRESULT)0x8004104EL)

//
// MessageId: PP_E_PPM_NOTCAPABLE
//
// MessageText:
//
//  The mobile login request came through an unsupported version of passport manager.
//
#define PP_E_PPM_NOTCAPABLE              ((HRESULT)0x8004104FL)

//
// MessageId: PP_E_CREATECOOKIE_FAILED
//
// MessageText:
//
//  Failed to create profile cookie.
//
#define PP_E_CREATECOOKIE_FAILED         ((HRESULT)0x80041050L)

//
// MessageId: PP_E_BLANK_PASSWORD
//
// MessageText:
//
//  The current password is empty.
//
#define PP_E_BLANK_PASSWORD              ((HRESULT)0x80041053L)

//
// MessageId: PP_E_LOADSTRING_NOT_HANDLED
//
// MessageText:
//
//  The string is not handled by the current handler.
//
#define PP_E_LOADSTRING_NOT_HANDLED      ((HRESULT)0x80041054L)

//
// MessageId: PP_E_INVALIDNAMESPACE
//
// MessageText:
//
//  (This error code needs to be deprecated.)
//
#define PP_E_INVALIDNAMESPACE            ((HRESULT)0x80041058L)

//
// MessageId: PP_E_NOBROWSERINFO
//
// MessageText:
//
//  Failed to get browser info.
//
#define PP_E_NOBROWSERINFO               ((HRESULT)0x80041059L)

//
// MessageId: PP_E_NOSERVERNAME
//
// MessageText:
//
//  Failed to retrieve the server's host name for the current request.
//
#define PP_E_NOSERVERNAME                ((HRESULT)0x80041060L)

//
// MessageId: PP_E_NO_URL
//
// MessageText:
//
//  Failed to get the URL of the current request.
//
#define PP_E_NO_URL                      ((HRESULT)0x80041061L)

//
// MessageId: PP_E_NO_AUTHHEADER
//
// MessageText:
//
//  Failed to find the HTTP_authorization or tweener signature in the header.
//
#define PP_E_NO_AUTHHEADER               ((HRESULT)0x80041062L)

//
// MessageId: PP_E_DONT_EVER_RETURN_THIS
//
// MessageText:
//
//  This error code is not supposed to be return. It should be reported and the code should be fixed.
//
#define PP_E_DONT_EVER_RETURN_THIS       ((HRESULT)0x80041063L)

//
// MessageId: PP_E_PCR_COUNTRY
//
// MessageText:
//
//  Country must be U.S.A., U.S. Territory or Korea. (This message is deprecated.)
//
#define PP_E_PCR_COUNTRY                 ((HRESULT)0x80041065L)

//
// MessageId: PP_E_PCR_BIRTHDATE
//
// MessageText:
//
//  Age is above valid value. (This message is deprecated.)
//
#define PP_E_PCR_BIRTHDATE               ((HRESULT)0x80041066L)

//
// MessageId: PP_E_INVALID_TPF
//
// MessageText:
//
//  The signature on the query string is incorrect. (This message is deprecated.)
//
#define PP_E_INVALID_TPF                 ((HRESULT)0x80041068L)

//
// MessageId: PP_E_URL_NOT_HANDLED
//
// MessageText:
//
//  The default handler could not be found for the URL.
//
#define PP_E_URL_NOT_HANDLED             ((HRESULT)0x80041069L)

//
// MessageId: PP_E_URL_NOT_INIT
//
// MessageText:
//
//  The URL builder object was not initialized before it is used.
//
#define PP_E_URL_NOT_INIT                ((HRESULT)0x80041070L)

//
// MessageId: PP_E_REJECT_RESPONSE
//
// MessageText:
//
//  The user has rejected a password reset from email.
//
#define PP_E_REJECT_RESPONSE             ((HRESULT)0x80041072L)

//
// MessageId: PP_E_GETPPHANDLER_FAILED
//
// MessageText:
//
//  No PP handler was found.
//
#define PP_E_GETPPHANDLER_FAILED         ((HRESULT)0x80041075L)

//
// MessageId: PP_E_GETSTRINGTABLE_FAILED
//
// MessageText:
//
//  The internal string table cannot be retrieved.
//
#define PP_E_GETSTRINGTABLE_FAILED       ((HRESULT)0x80041076L)

//
// MessageId: PP_E_LOGIN_CERT_NOTSUPPORTED
//
// MessageText:
//
//  The partner site does not support this seclevel.
//
#define PP_E_LOGIN_CERT_NOTSUPPORTED     ((HRESULT)0x8004107CL)

//
// MessageId: PP_E_LOGIN_NEED_CERT_PROVISIONING
//
// MessageText:
//
//  The account needs to go through certificate provisioning flow.
//
#define PP_E_LOGIN_NEED_CERT_PROVISIONING ((HRESULT)0x8004107DL)

//
// MessageId: PP_E_LOGIN_RESTRICTIONS
//
// MessageText:
//
//  The account is in a forced renamed state.
//
#define PP_E_LOGIN_RESTRICTIONS          ((HRESULT)0x8004107EL)

//
// MessageId: PP_E_LOGIN_NEED_STRONGPW
//
// MessageText:
//
//  A site requires strong password and account does not have it.
//
#define PP_E_LOGIN_NEED_STRONGPW         ((HRESULT)0x8004107FL)

//
// MessageId: PP_E_LOGIN_NEED_EXPIRY
//
// MessageText:
//
//  The site requires password expiry.
//
#define PP_E_LOGIN_NEED_EXPIRY           ((HRESULT)0x80041080L)

//
// MessageId: PP_E_LOGIN_NEED_EXPIRY_WARINING
//
// MessageText:
//
//  After logging in successfully, the password is about to expire.
//
#define PP_E_LOGIN_NEED_EXPIRY_WARINING  ((HRESULT)0x80041081L)

//
// MessageId: PP_E_LOGIN_EXPIRED_PASSWORD
//
// MessageText:
//
//  The password for the account has expired.
//
#define PP_E_LOGIN_EXPIRED_PASSWORD      ((HRESULT)0x80041082L)

//
// MessageId: PP_E_LOGIN_FORCECHANGE_SQSA
//
// MessageText:
//
//  The secret question and answer has to be changed.
//
#define PP_E_LOGIN_FORCECHANGE_SQSA      ((HRESULT)0x80041083L)

//
// MessageId: PP_E_LOGIN_FORCECHANGE_PASSWORD
//
// MessageText:
//
//  The password has to be changed.
//
#define PP_E_LOGIN_FORCECHANGE_PASSWORD  ((HRESULT)0x80041084L)

//
// MessageId: PP_E_NO_VALID_LOGIN_KEYS
//
// MessageText:
//
//  No login server symmetric key is found.
//
#define PP_E_NO_VALID_LOGIN_KEYS         ((HRESULT)0x80041085L)

//
// MessageId: PP_E_NO_VALID_SITE10_KEYS
//
// MessageText:
//
//  No site 10 symmetric key is found.
//
#define PP_E_NO_VALID_SITE10_KEYS        ((HRESULT)0x80041086L)

//
// MessageId: PP_E_INVALID_SITE_KEY
//
// MessageText:
//
//  The symmetric key data read out from the Key DB is bad.
//
#define PP_E_INVALID_SITE_KEY            ((HRESULT)0x80041087L)

//
// MessageId: PP_E_NO_ASYNC_SUPPORT
//
// MessageText:
//
//  A third party DB provider is called without a callback function.
//
#define PP_E_NO_ASYNC_SUPPORT            ((HRESULT)0x8004108AL)

//
// MessageId: PP_E_UNKNOWN_THIRDPARTY_DB_ERROR
//
// MessageText:
//
//  An unknown third party DB provider error.
//
#define PP_E_UNKNOWN_THIRDPARTY_DB_ERROR ((HRESULT)0x8004108BL)

//
// MessageId: PP_E_INVALID_REALM_CERT
//
// MessageText:
//
//  No certificate was found for a trusted realm, or the login server failed to instantiate a certificate context.
//
#define PP_E_INVALID_REALM_CERT          ((HRESULT)0x8004108EL)

//
// MessageId: PP_E_PPMGR_NOT_INITED
//
// MessageText:
//
//  Passport manager has failed to update the local nexus configuration.
//
#define PP_E_PPMGR_NOT_INITED            ((HRESULT)0x8004108FL)

//
// MessageId: PP_E_SECLEVEL_NOTSUPPORTED
//
// MessageText:
//
//  The requested secure level is not supported.
//
#define PP_E_SECLEVEL_NOTSUPPORTED       ((HRESULT)0x80041090L)

//
// MessageId: PP_E_TOU_NOTSUPPORTEDBYMOBILE
//
// MessageText:
//
//  No TOU support for mobile devices.
//
#define PP_E_TOU_NOTSUPPORTEDBYMOBILE    ((HRESULT)0x80041091L)

//
// MessageId: PP_E_MOBILE_CANCEL_SIGNIN
//
// MessageText:
//
//  The mobile sign in is canceled.
//
#define PP_E_MOBILE_CANCEL_SIGNIN        ((HRESULT)0x80041093L)

//
// MessageId: PP_E_NAME_BLANK
//
// MessageText:
//
//  The signin name is blank.
//
#define PP_E_NAME_BLANK                  ((HRESULT)0x80041100L)

//
// MessageId: PP_E_NAME_TOO_SHORT
//
// MessageText:
//
//  The signin name is too short.
//
#define PP_E_NAME_TOO_SHORT              ((HRESULT)0x80041101L)

//
// MessageId: PP_E_NAME_TOO_LONG
//
// MessageText:
//
//  The signin name is too long.
//
#define PP_E_NAME_TOO_LONG               ((HRESULT)0x80041102L)

//
// MessageId: PP_E_NAME_INVALID
//
// MessageText:
//
//  The signin name is incomplete or has invalid characters.
//
#define PP_E_NAME_INVALID                ((HRESULT)0x80041103L)

//
// MessageId: PP_E_PASSWORD_BLANK
//
// MessageText:
//
//  The password is blank.
//
#define PP_E_PASSWORD_BLANK              ((HRESULT)0x80041104L)

//
// MessageId: PP_E_PASSWORD_TOO_SHORT
//
// MessageText:
//
//  The password is too short.
//
#define PP_E_PASSWORD_TOO_SHORT          ((HRESULT)0x80041105L)

//
// MessageId: PP_E_PASSWORD_TOO_LONG
//
// MessageText:
//
//  The password is too long.
//
#define PP_E_PASSWORD_TOO_LONG           ((HRESULT)0x80041106L)

//
// MessageId: PP_E_PASSWORD_CONTAINS_MEMBERNAME
//
// MessageText:
//
//  The password contains the member name.
//
#define PP_E_PASSWORD_CONTAINS_MEMBERNAME ((HRESULT)0x80041107L)

//
// MessageId: PP_E_PASSWORD_INVALID
//
// MessageText:
//
//  The password contains invalid characters.
//
#define PP_E_PASSWORD_INVALID            ((HRESULT)0x80041108L)

//
// MessageId: PP_E_PASSWORD_MISMATCH
//
// MessageText:
//
//  The passwords do not match.
//
#define PP_E_PASSWORD_MISMATCH           ((HRESULT)0x80041109L)

//
// MessageId: PP_E_EMAIL_BLANK
//
// MessageText:
//
//  The email is blank.
//
#define PP_E_EMAIL_BLANK                 ((HRESULT)0x8004110AL)

//
// MessageId: PP_E_EMAIL_INVALID
//
// MessageText:
//
//  The email is invalid.
//
#define PP_E_EMAIL_INVALID               ((HRESULT)0x8004110BL)

//
// MessageId: PP_E_EMAIL_RIGHT_TOO_LONG
//
// MessageText:
//
//  The string after the '@' in the email address is too long.
//
#define PP_E_EMAIL_RIGHT_TOO_LONG        ((HRESULT)0x8004110CL)

//
// MessageId: PP_E_EMAIL_INCOMPLETE
//
// MessageText:
//
//  The email address is incomplete. This is usually due to missing '@' or '.'.
//
#define PP_E_EMAIL_INCOMPLETE            ((HRESULT)0x8004110DL)

//
// MessageId: PP_E_EMAIL_INVALID_CHARS
//
// MessageText:
//
//  There is invalid characters in the email address.
//
#define PP_E_EMAIL_INVALID_CHARS         ((HRESULT)0x8004110EL)

//
// MessageId: PP_E_BIRTHDATE_NOTENTERED
//
// MessageText:
//
//  No birth date was entered.
//
#define PP_E_BIRTHDATE_NOTENTERED        ((HRESULT)0x8004110FL)

//
// MessageId: PP_E_BIRTHYEAR_INVALID_CHARS
//
// MessageText:
//
//  The year of birth has invalid characters.
//
#define PP_E_BIRTHYEAR_INVALID_CHARS     ((HRESULT)0x80041110L)

//
// MessageId: PP_E_BIRTHYEAR_NOT_4DIGIT
//
// MessageText:
//
//  The year of birth is not four digit long.
//
#define PP_E_BIRTHYEAR_NOT_4DIGIT        ((HRESULT)0x80041111L)

//
// MessageId: PP_E_BIRTHYEAR_TOO_LOW
//
// MessageText:
//
//  The year of birth is too small.
//
#define PP_E_BIRTHYEAR_TOO_LOW           ((HRESULT)0x80041112L)

//
// MessageId: PP_E_BIRTHYEAR_MISSING
//
// MessageText:
//
//  The year of birth is missing.
//
#define PP_E_BIRTHYEAR_MISSING           ((HRESULT)0x80041113L)

//
// MessageId: PP_E_BIRTHMONTH_MISSING
//
// MessageText:
//
//  The month of birth is missing.
//
#define PP_E_BIRTHMONTH_MISSING          ((HRESULT)0x80041114L)

//
// MessageId: PP_E_BIRTHMONTH_INVALID
//
// MessageText:
//
//  The year of birth is invalid.
//
#define PP_E_BIRTHMONTH_INVALID          ((HRESULT)0x80041115L)

//
// MessageId: PP_E_BIRTHDAY_MISSING
//
// MessageText:
//
//  The day of birth is missing.
//
#define PP_E_BIRTHDAY_MISSING            ((HRESULT)0x80041116L)

//
// MessageId: PP_E_BIRTHDAY_INVALID
//
// MessageText:
//
//  The day of birth is invalid.
//
#define PP_E_BIRTHDAY_INVALID            ((HRESULT)0x80041117L)

//
// MessageId: PP_E_BADDAYFORMONTH
//
// MessageText:
//
//  The day of the month is invalid.
//
#define PP_E_BADDAYFORMONTH              ((HRESULT)0x80041118L)

//
// MessageId: PP_E_BIRTHDATE_UNDER18
//
// MessageText:
//
//  The person is under 18. (This message should be deprecated.)
//
#define PP_E_BIRTHDATE_UNDER18           ((HRESULT)0x80041119L)

//
// MessageId: PP_E_BIRTHDATE_IN_FUTURE
//
// MessageText:
//
//  The date of birth is in the future.
//
#define PP_E_BIRTHDATE_IN_FUTURE         ((HRESULT)0x8004111AL)

//
// MessageId: PP_E_PARENT_UNDER13
//
// MessageText:
//
//  A parent is under 13.
//
#define PP_E_PARENT_UNDER13              ((HRESULT)0x8004111BL)

//
// MessageId: PP_E_SECRETQA_NOQUESTION
//
// MessageText:
//
//  No secret question was entered or found.
//
#define PP_E_SECRETQA_NOQUESTION         ((HRESULT)0x8004111CL)

//
// MessageId: PP_E_SECRETQA_NOANSWER
//
// MessageText:
//
//  No answer to secret question was entered or found.
//
#define PP_E_SECRETQA_NOANSWER           ((HRESULT)0x8004111DL)

//
// MessageId: PP_E_SQ_INVALID
//
// MessageText:
//
//  The secret question is invalid.(This message should be deprecated.)
//
#define PP_E_SQ_INVALID                  ((HRESULT)0x8004111EL)

//
// MessageId: PP_E_SA_INVALID
//
// MessageText:
//
//  The answer to the secret question is invalid. (This message should be deprecated.)
//
#define PP_E_SA_INVALID                  ((HRESULT)0x8004111FL)

//
// MessageId: PP_E_SA_TOOSHORT
//
// MessageText:
//
//  The answer to the secret question is too short.
//
#define PP_E_SA_TOOSHORT                 ((HRESULT)0x80041120L)

//
// MessageId: PP_E_SA_TOOLONG
//
// MessageText:
//
//  The answer to the secret question is too long.
//
#define PP_E_SA_TOOLONG                  ((HRESULT)0x80041121L)

//
// MessageId: PP_E_SQ_TOOSHORT
//
// MessageText:
//
//  The secret question is too short.
//
#define PP_E_SQ_TOOSHORT                 ((HRESULT)0x80041122L)

//
// MessageId: PP_E_SQ_TOOLONG
//
// MessageText:
//
//  The secret question is too long.
//
#define PP_E_SQ_TOOLONG                  ((HRESULT)0x80041123L)

//
// MessageId: PP_E_LOCATION_INVALID_REGION
//
// MessageText:
//
//  No country or region was found.
//
#define PP_E_LOCATION_INVALID_REGION     ((HRESULT)0x80041124L)

//
// MessageId: PP_E_LOCATION_INVALID_POSTALCODE
//
// MessageText:
//
//  No postal was found.
//
#define PP_E_LOCATION_INVALID_POSTALCODE ((HRESULT)0x80041125L)

//
// MessageId: PP_E_LOCATION_INVALID_POSTALCODECHARS
//
// MessageText:
//
//  The postal code has invalid characters.
//
#define PP_E_LOCATION_INVALID_POSTALCODECHARS ((HRESULT)0x80041126L)

//
// MessageId: PP_E_LOCATION_INVALID_COUNTRY
//
// MessageText:
//
//  The value for country has invalid length.
//
#define PP_E_LOCATION_INVALID_COUNTRY    ((HRESULT)0x80041127L)

//
// MessageId: PP_E_GENDER_BLANK
//
// MessageText:
//
//  The gender field is blank.
//
#define PP_E_GENDER_BLANK                ((HRESULT)0x80041128L)

//
// MessageId: PP_E_GENDER_INVALID
//
// MessageText:
//
//  The gender is invalid.
//
#define PP_E_GENDER_INVALID              ((HRESULT)0x80041129L)

//
// MessageId: PP_E_LANGUAGE_BLANK
//
// MessageText:
//
//  The language is blank.
//
#define PP_E_LANGUAGE_BLANK              ((HRESULT)0x8004112AL)

//
// MessageId: PP_E_TIMEZONE_BLANK
//
// MessageText:
//
//  The time zone is blank.
//
#define PP_E_TIMEZONE_BLANK              ((HRESULT)0x8004112BL)

//
// MessageId: PP_E_OCCUPATION_BLANK
//
// MessageText:
//
//  The occupation is blank.
//
#define PP_E_OCCUPATION_BLANK            ((HRESULT)0x8004112CL)

//
// MessageId: PP_E_SVC_BLANK
//
// MessageText:
//
//  The service routing parameter is blank.
//
#define PP_E_SVC_BLANK                   ((HRESULT)0x8004112DL)

//
// MessageId: PP_E_SAVEPASSWORD_BLANK
//
// MessageText:
//
//  The save password parameter is blank.
//
#define PP_E_SAVEPASSWORD_BLANK          ((HRESULT)0x8004112EL)

//
// MessageId: PP_E_ACCESSIBILITY_BLANK
//
// MessageText:
//
//  The assessibility parameter is blank.
//
#define PP_E_ACCESSIBILITY_BLANK         ((HRESULT)0x8004112FL)

//
// MessageId: PP_E_ALLOWEMAILINPROFILE_BLANK
//
// MessageText:
//
//  The allow email in profile parameter is blank.
//
#define PP_E_ALLOWEMAILINPROFILE_BLANK   ((HRESULT)0x80041130L)

//
// MessageId: PP_E_ALLOWPASSPORTNETWORKEMAIL_BLANK
//
// MessageText:
//
//  The allow passport network email parameter is blank.
//
#define PP_E_ALLOWPASSPORTNETWORKEMAIL_BLANK ((HRESULT)0x80041131L)

//
// MessageId: PP_E_MEMBER_EXIST
//
// MessageText:
//
//  The non EASI member exists.
//
#define PP_E_MEMBER_EXIST                ((HRESULT)0x80041132L)

//
// MessageId: PP_E_EMAIL_MEMBER_EXIST
//
// MessageText:
//
//  The EASI member exists.
//
#define PP_E_EMAIL_MEMBER_EXIST          ((HRESULT)0x80041133L)

//
// MessageId: PP_E_EMAIL_MANAGED
//
// MessageText:
//
//  The domain is managed.
//
#define PP_E_EMAIL_MANAGED               ((HRESULT)0x80041134L)

//
// MessageId: PP_E_SECRETQA_DUPLICATE_Q
//
// MessageText:
//
//  The secret question is duplicated.
//
#define PP_E_SECRETQA_DUPLICATE_Q        ((HRESULT)0x80041135L)

//
// MessageId: PP_E_FIRSTNAME_BLANK
//
// MessageText:
//
//  The first name is blank.
//
#define PP_E_FIRSTNAME_BLANK             ((HRESULT)0x80041136L)

//
// MessageId: PP_E_LASTNAME_BLANK
//
// MessageText:
//
//  The last name is blank.
//
#define PP_E_LASTNAME_BLANK              ((HRESULT)0x80041137L)

//
// MessageId: PP_E_NICKNAME_BLANK
//
// MessageText:
//
//  The nick name is blank.
//
#define PP_E_NICKNAME_BLANK              ((HRESULT)0x80041138L)

//
// MessageId: PP_E_EMAIL_RESERVED
//
// MessageText:
//
//  The domain does not allow the name to be changed.
//
#define PP_E_EMAIL_RESERVED              ((HRESULT)0x80041139L)

//
// MessageId: PP_E_DOMAIN_INVALID
//
// MessageText:
//
//  The domain does not exist.
//
#define PP_E_DOMAIN_INVALID              ((HRESULT)0x8004113AL)

//
// MessageId: PP_E_SECRETQA_DUPLICATE_A
//
// MessageText:
//
//  The answer to the secret question is duplicated.
//
#define PP_E_SECRETQA_DUPLICATE_A        ((HRESULT)0x8004113BL)

//
// MessageId: PP_E_SECRETQA_NOMATCH
//
// MessageText:
//
//  (This error is not used in the code!)
//
#define PP_E_SECRETQA_NOMATCH            ((HRESULT)0x8004113CL)

//
// MessageId: PP_E_EXTERNALFIELD_BLANK
//
// MessageText:
//
//  (This error is not used in the code!)
//
#define PP_E_EXTERNALFIELD_BLANK         ((HRESULT)0x8004113DL)

//
// MessageId: PP_E_PARENT_INVALID
//
// MessageText:
//
//  This is not the parent.
//
#define PP_E_PARENT_INVALID              ((HRESULT)0x8004113EL)

//
// MessageId: PP_E_INVALID_PHONENUMBER
//
// MessageText:
//
//  (This error is not used in the code!)
//
#define PP_E_INVALID_PHONENUMBER         ((HRESULT)0x8004113FL)

//
// MessageId: PP_E_PHONENUMBER_EXIST
//
// MessageText:
//
//  (This error is not used in the code!).
//
#define PP_E_PHONENUMBER_EXIST           ((HRESULT)0x80041140L)

//
// MessageId: PP_E_TIMEZONE_INVALID
//
// MessageText:
//
//  The time zone is invalid.
//
#define PP_E_TIMEZONE_INVALID            ((HRESULT)0x80041141L)

//
// MessageId: PP_E_OCCUPATION_INVALID
//
// MessageText:
//
//  The occupation is invalid.
//
#define PP_E_OCCUPATION_INVALID          ((HRESULT)0x80041142L)

//
// MessageId: PP_E_LANGUAGE_INVALID
//
// MessageText:
//
//  The language is invalid.
//
#define PP_E_LANGUAGE_INVALID            ((HRESULT)0x80041143L)

//
// MessageId: PP_E_INVALID_PINNUMBER
//
// MessageText:
//
//  The PIN is invalid.
//
#define PP_E_INVALID_PINNUMBER           ((HRESULT)0x80041144L)

//
// MessageId: PP_E_SECUREPIN_MISMATCH
//
// MessageText:
//
//  The secure PIN does not match.
//
#define PP_E_SECUREPIN_MISMATCH          ((HRESULT)0x80041145L)

//
// MessageId: PP_E_SECUREPIN_INVALID
//
// MessageText:
//
//  The secure PIN is invalid.
//
#define PP_E_SECUREPIN_INVALID           ((HRESULT)0x80041146L)

//
// MessageId: PP_E_SECUREPIN_BLANK
//
// MessageText:
//
//  The secure PIN is blank.
//
#define PP_E_SECUREPIN_BLANK             ((HRESULT)0x80041147L)

//
// MessageId: PP_E_SECUREPIN_TOO_SHORT
//
// MessageText:
//
//  The secure PIN is too short.
//
#define PP_E_SECUREPIN_TOO_SHORT         ((HRESULT)0x80041148L)

//
// MessageId: PP_E_SECUREPIN_TOO_LONG
//
// MessageText:
//
//  The secure PIN is too long.
//
#define PP_E_SECUREPIN_TOO_LONG          ((HRESULT)0x80041149L)

//
// MessageId: PP_E_SECUREPIN_CONTAINS_MEMBERNAME
//
// MessageText:
//
//  The secure PIN contains the member name.
//
#define PP_E_SECUREPIN_CONTAINS_MEMBERNAME ((HRESULT)0x8004114AL)

//
// MessageId: PP_E_SECRETQA_VERIFY_NOANSWER
//
// MessageText:
//
//  The answer to verify secret question is blank.
//
#define PP_E_SECRETQA_VERIFY_NOANSWER    ((HRESULT)0x8004114BL)

//
// MessageId: PP_E_FIELD_TOO_LONG
//
// MessageText:
//
//  The field is too long.
//
#define PP_E_FIELD_TOO_LONG              ((HRESULT)0x8004114CL)

//
// MessageId: PP_E_FIRSTNAME_TOO_LONG
//
// MessageText:
//
//  The first name is too long.
//
#define PP_E_FIRSTNAME_TOO_LONG          ((HRESULT)0x8004114DL)

//
// MessageId: PP_E_LASTNAME_TOO_LONG
//
// MessageText:
//
//  The last name is too long.
//
#define PP_E_LASTNAME_TOO_LONG           ((HRESULT)0x8004114EL)

//
// MessageId: PP_E_FORCERENAME_RESPONSE_INVALID
//
// MessageText:
//
//  The password entered matches one of the accounts with the same member name.
//
#define PP_E_FORCERENAME_RESPONSE_INVALID ((HRESULT)0x8004114FL)

//
// MessageId: PP_E_LOCATION_INVALID_POSTALCODEBLANK
//
// MessageText:
//
//  The postal code is blank.
//
#define PP_E_LOCATION_INVALID_POSTALCODEBLANK ((HRESULT)0x80041150L)

//
// MessageId: PP_E_EMAIL_TOO_LONG
//
// MessageText:
//
//  The email address is too long.
//
#define PP_E_EMAIL_TOO_LONG              ((HRESULT)0x80041151L)

//
// MessageId: PP_E_NAME_FIRST_LAST_DOT
//
// MessageText:
//
//  The email name starts and ends with '.'.
//
#define PP_E_NAME_FIRST_LAST_DOT         ((HRESULT)0x80041153L)

//
// MessageId: PP_E_NAME_DOT_AFTER_DOT
//
// MessageText:
//
//  The email name starts after a '.'.
//
#define PP_E_NAME_DOT_AFTER_DOT          ((HRESULT)0x80041154L)

//
// MessageId: PP_E_DOMAIN_INVALID_CHAR
//
// MessageText:
//
//  The domain has invalid characters.
//
#define PP_E_DOMAIN_INVALID_CHAR         ((HRESULT)0x80041155L)

//
// MessageId: PP_E_NAME_INVALID_CHAR
//
// MessageText:
//
//  The email name has invalid characters.
//
#define PP_E_NAME_INVALID_CHAR           ((HRESULT)0x80041156L)

//
// MessageId: PP_E_DOMAIN_FIRST_LAST_CHAR_INVALID
//
// MessageText:
//
//  The first and last characters of the domain are invalid.
//
#define PP_E_DOMAIN_FIRST_LAST_CHAR_INVALID ((HRESULT)0x80041157L)

//
// MessageId: PP_E_DOMAIN_DOT_AFTER_DOT
//
// MessageText:
//
//  The domain portion begins with a dot.
//
#define PP_E_DOMAIN_DOT_AFTER_DOT        ((HRESULT)0x80041158L)

//
// MessageId: PP_E_FIELD_STARTS_ENDS_WITH_WHITESPACE
//
// MessageText:
//
//  The field starts or ends with white space.
//
#define PP_E_FIELD_STARTS_ENDS_WITH_WHITESPACE ((HRESULT)0x80041159L)

//
// MessageId: PP_E_NAME_STARTS_ENDS_WITH_WHITESPACE
//
// MessageText:
//
//  The name start or ends with white space.
//
#define PP_E_NAME_STARTS_ENDS_WITH_WHITESPACE ((HRESULT)0x8004115AL)

//
// MessageId: PP_E_SECRETA_STARTS_ENDS_WITH_WHITESPACE
//
// MessageText:
//
//  The answer to the secret question starts or ends with white space.
//
#define PP_E_SECRETA_STARTS_ENDS_WITH_WHITESPACE ((HRESULT)0x8004115BL)

//
// MessageId: PP_E_POSTALCODE_STARTS_ENDS_WITH_WHITESPACE
//
// MessageText:
//
//  The postal code starts or ends with white space.
//
#define PP_E_POSTALCODE_STARTS_ENDS_WITH_WHITESPACE ((HRESULT)0x8004115CL)

//
// MessageId: PP_E_TOUVERSION_INVALID
//
// MessageText:
//
//  The TOU version either has invalid characters or newer than the current version.
//
#define PP_E_TOUVERSION_INVALID          ((HRESULT)0x8004115DL)

//
// MessageId: PP_E_EMAIL_SAME
//
// MessageText:
//
//  The alternate email is the same as the member name.
//
#define PP_E_EMAIL_SAME                  ((HRESULT)0x8004115EL)

//
// MessageId: PP_E_FIRSTNAME_FORBIDDEN
//
// MessageText:
//
//  The first name contains a phrase or word that is not allowed.
//
#define PP_E_FIRSTNAME_FORBIDDEN         ((HRESULT)0x8004115FL)

//
// MessageId: PP_E_LASTNAME_FORBIDDEN
//
// MessageText:
//
//  The last name contains a phrase or word that is not allowed.
//
#define PP_E_LASTNAME_FORBIDDEN          ((HRESULT)0x80041160L)

//
// MessageId: PP_E_PASSWORD_MISMATCH_WITH_DB
//
// MessageText:
//
//  The password does not match the one in the DB.
//
#define PP_E_PASSWORD_MISMATCH_WITH_DB   ((HRESULT)0x80041161L)

//
// MessageId: PP_E_SECUREPIN_MISMATCH_WITH_DB
//
// MessageText:
//
//  The secure PIN does not match the one in the DB.
//
#define PP_E_SECUREPIN_MISMATCH_WITH_DB  ((HRESULT)0x80041162L)

//
// MessageId: PP_E_FIELD_CONTAINS_INVALID_CHARS
//
// MessageText:
//
//  The field contains invalid characters.
//
#define PP_E_FIELD_CONTAINS_INVALID_CHARS ((HRESULT)0x80041163L)

//
// MessageId: PP_E_PASSWORD_SAME_AS_SA
//
// MessageText:
//
//  The password is the same as the answer for the secret question.
//
#define PP_E_PASSWORD_SAME_AS_SA         ((HRESULT)0x80041164L)

//
// MessageId: PP_E_SECRETQ_CONTAINS_SECRETA
//
// MessageText:
//
//  The secret question contains the answer.
//
#define PP_E_SECRETQ_CONTAINS_SECRETA    ((HRESULT)0x80041165L)

//
// MessageId: PP_E_PASSWORD_CONTAINED_IN_SA
//
// MessageText:
//
//  The password is contained in the answer for the secret question.
//
#define PP_E_PASSWORD_CONTAINED_IN_SA    ((HRESULT)0x80041166L)

//
// MessageId: PP_E_PASSWORD_CONTAINED_IN_SQ
//
// MessageText:
//
//  The password is contained in the secret question.
//
#define PP_E_PASSWORD_CONTAINED_IN_SQ    ((HRESULT)0x80041167L)

//
// MessageId: PP_E_PASSWORD_CONTAINS_FIRSTNAME
//
// MessageText:
//
//  The password contains the first name.
//
#define PP_E_PASSWORD_CONTAINS_FIRSTNAME ((HRESULT)0x80041168L)

//
// MessageId: PP_E_PASSWORD_CONTAINS_LASTNAME
//
// MessageText:
//
//  The password contains the last name.
//
#define PP_E_PASSWORD_CONTAINS_LASTNAME  ((HRESULT)0x80041169L)

//
// MessageId: PP_E_SA_CONTAINS_MEMBERNAME
//
// MessageText:
//
//  The answer for the secret question contains the member name.
//
#define PP_E_SA_CONTAINS_MEMBERNAME      ((HRESULT)0x8004116AL)

//
// MessageId: PP_E_PASSWORD_INVALID_MSN
//
// MessageText:
//
//  The password is invalid; it must be at least 6 characters long.
//
#define PP_E_PASSWORD_INVALID_MSN        ((HRESULT)0x8004116BL)

//
// MessageId: PP_E_FIRSTNAME_FORBIDDEN_MSN
//
// MessageText:
//
//  The first name contains a phrase or word that is not allowed in MSN.
//
#define PP_E_FIRSTNAME_FORBIDDEN_MSN     ((HRESULT)0x8004116CL)

//
// MessageId: PP_E_NAME_FORBIDDEN_GENERIC
//
// MessageText:
//
//  The name contains a phrase or word that is not allowed.
//
#define PP_E_NAME_FORBIDDEN_GENERIC      ((HRESULT)0x8004116DL)

//
// MessageId: PP_E_FIRSTNAME_TOO_SHORT
//
// MessageText:
//
//  The first name is too short.
//
#define PP_E_FIRSTNAME_TOO_SHORT         ((HRESULT)0x8004116EL)

//
// MessageId: PP_E_LASTNAME_TOO_SHORT
//
// MessageText:
//
//  The last name is too short.
//
#define PP_E_LASTNAME_TOO_SHORT          ((HRESULT)0x8004116FL)

//
// MessageId: PP_E_LASTNAME_FORBIDDEN_MSN
//
// MessageText:
//
//  The last name contains a phrase or word that is not allowed in MSN.
//
#define PP_E_LASTNAME_FORBIDDEN_MSN      ((HRESULT)0x80041170L)

//
// MessageId: PP_E_FIRSTNAME_FORBIDDEN_HOTMAIL
//
// MessageText:
//
//  The first name contains a phrase or word that is not allowed in Hotmail.
//
#define PP_E_FIRSTNAME_FORBIDDEN_HOTMAIL ((HRESULT)0x80041171L)

//
// MessageId: PP_E_LASTNAME_FORBIDDEN_HOTMAIL
//
// MessageText:
//
//  The last name contains a phrase or word that is not allowed in Hotmail.
//
#define PP_E_LASTNAME_FORBIDDEN_HOTMAIL  ((HRESULT)0x80041172L)

//
// MessageId: PP_E_INVALID_DA_DOMAIN
//
// MessageText:
//
//  Invalid domain name for EASI account.
//
#define PP_E_INVALID_DA_DOMAIN           ((HRESULT)0x80041173L)

//
// MessageId: PP_E_EMAIL_CANT_BEGIN_WITH_HYPHEN
//
// MessageText:
//
//  The email name can not begin with hyphen.
//
#define PP_E_EMAIL_CANT_BEGIN_WITH_HYPHEN ((HRESULT)0x80041174L)

//
// MessageId: PP_E_EMAIL_CANT_BEGIN_WITH_DOT
//
// MessageText:
//
//  The email name can not begin with a dot.
//
#define PP_E_EMAIL_CANT_BEGIN_WITH_DOT   ((HRESULT)0x80041175L)

//
// MessageId: PP_E_EMAIL_CANT_END_WITH_HYPHEN
//
// MessageText:
//
//  The email name can not end with hyphen.
//
#define PP_E_EMAIL_CANT_END_WITH_HYPHEN  ((HRESULT)0x80041176L)

//
// MessageId: PP_E_EMAIL_CANT_END_WITH_DOT
//
// MessageText:
//
//  The email name can not end with a dot.
//
#define PP_E_EMAIL_CANT_END_WITH_DOT     ((HRESULT)0x80041177L)

//
// MessageId: PP_E_EMAIL_CANT_END_WITH_DOTORHYPHEN
//
// MessageText:
//
//  The email name can not end with a dot or hyphen.
//
#define PP_E_EMAIL_CANT_END_WITH_DOTORHYPHEN ((HRESULT)0x80041178L)

//
// MessageId: PP_E_EMAIL_CANT_BEGIN_WITH_DOTORHYPHEN
//
// MessageText:
//
//  The email name can not begin with a dot or hyphen.
//
#define PP_E_EMAIL_CANT_BEGIN_WITH_DOTORHYPHEN ((HRESULT)0x80041179L)

//
// MessageId: PP_E_DOMAIN_HYPHEN_AFTER_HYPHEN
//
// MessageText:
//
//  The domain portion of the email address cannot contain two consecutive hyphens.
//
#define PP_E_DOMAIN_HYPHEN_AFTER_HYPHEN  ((HRESULT)0x8004117AL)

//
// MessageId: PP_E_DOMAIN_CANT_END_WITH_DOTORHYPHEN
//
// MessageText:
//
//  The domain portion of the email address cannot end with dot or hyphen.
//
#define PP_E_DOMAIN_CANT_END_WITH_DOTORHYPHEN ((HRESULT)0x8004117BL)

//
// MessageId: PP_E_DOMAIN_CANT_BEGIN_WITH_DOTORHYPHEN
//
// MessageText:
//
//  The domain portion of the email address cannot start with dot or hyphen.
//
#define PP_E_DOMAIN_CANT_BEGIN_WITH_DOTORHYPHEN ((HRESULT)0x8004117CL)

//
// MessageId: PP_E_SECRETA_CONTAINS_SECRETQ
//
// MessageText:
//
//  The answer to the secret question contains that question.
//
#define PP_E_SECRETA_CONTAINS_SECRETQ    ((HRESULT)0x8004117DL)

//
// MessageId: PP_E_PASSWORD_CONTAINS_SA
//
// MessageText:
//
//  The password validation code detected the answer to the secret question in the password.
//
#define PP_E_PASSWORD_CONTAINS_SA        ((HRESULT)0x8004117EL)

//
// MessageId: PP_E_EMAIL_DOT_AFTER_DOT
//
// MessageText:
//
//  The email name cannot have two consecutive dots.
//
#define PP_E_EMAIL_DOT_AFTER_DOT         ((HRESULT)0x80041180L)

//
// MessageId: PP_E_REQUIRED_INPUTFIELD_MISSING
//
// MessageText:
//
//  The required field is blank.
//
#define PP_E_REQUIRED_INPUTFIELD_MISSING ((HRESULT)0x8004118DL)

//
// MessageId: PP_E_REQUIRED_DROPDOWNFIELD_MISSING
//
// MessageText:
//
//  The required field is blank.
//
#define PP_E_REQUIRED_DROPDOWNFIELD_MISSING ((HRESULT)0x8004118EL)

//
// MessageId: PP_E_PARENT_NOT_OLD_ENOUGH
//
// MessageText:
//
//  The parent is not old enough.
//
#define PP_E_PARENT_NOT_OLD_ENOUGH       ((HRESULT)0x8004118FL)

//
// MessageId: PP_E_FRIENDLYNAME_BLANK
//
// MessageText:
//
//  The friendly name is blank.
//
#define PP_E_FRIENDLYNAME_BLANK          ((HRESULT)0x8004119AL)

//
// MessageId: PP_E_PASSWORD_SAME_AS_CURRENT
//
// MessageText:
//
//  The password has not changed.
//
#define PP_E_PASSWORD_SAME_AS_CURRENT    ((HRESULT)0x8004119DL)

//
// MessageId: PP_E_PASSWORD_SAME_AS_OLD
//
// MessageText:
//
//  The new and old passwords are the same.
//
#define PP_E_PASSWORD_SAME_AS_OLD        ((HRESULT)0x8004119EL)

//
// MessageId: PP_E_PASSWORD_TOO_SIMILAR_TO_CURRENT
//
// MessageText:
//
//  The new password is too similar to the current password.
//
#define PP_E_PASSWORD_TOO_SIMILAR_TO_CURRENT ((HRESULT)0x8004119FL)

//
// MessageId: PP_E_TOUACCEPT_VALIDATION_WRONG
//
// MessageText:
//
//  The TOU is not validated properly; enter the email again.
//
#define PP_E_TOUACCEPT_VALIDATION_WRONG  ((HRESULT)0x800411A0L)

//
// MessageId: PP_E_GLOBALINIT_MISSING_STRINGTABLE_SERVICE
//
// MessageText:
//
//  The string table COM object has not been configured for this service. The string table service is not loaded.
//
#define PP_E_GLOBALINIT_MISSING_STRINGTABLE_SERVICE ((HRESULT)0x80041403L)

//
// MessageId: PP_E_GLOBALINIT_MISSING_MANAGER_SERVICE
//
// MessageText:
//
//  The Passport Manager instance is not configured for this service. Make sure that config.ini has Passport.Manager.
//
#define PP_E_GLOBALINIT_MISSING_MANAGER_SERVICE ((HRESULT)0x80041408L)

//
// MessageId: PP_E_GLOBALINIT_ADDSTRING_FAILED
//
// MessageText:
//
//  Failed to load strings from registry into the string table.
//
#define PP_E_GLOBALINIT_ADDSTRING_FAILED ((HRESULT)0x80041409L)

//
// MessageId: PP_E_GLOBALINIT_ADDNUMBER_FAILED
//
// MessageText:
//
//  Failed to add one of the strings referred to in UI resources strings into the string table.
//
#define PP_E_GLOBALINIT_ADDNUMBER_FAILED ((HRESULT)0x8004140CL)

//
// MessageId: PP_E_GLOBALINIT_BADPTR
//
// MessageText:
//
//  Failed to add substitution strings into the string table.
//
#define PP_E_GLOBALINIT_BADPTR           ((HRESULT)0x80041410L)

//
// MessageId: PP_E_GLOBALCOMMIT_BADPTR
//
// MessageText:
//
//  Bad service provider pointer.
//
#define PP_E_GLOBALCOMMIT_BADPTR         ((HRESULT)0x80041411L)

//
// MessageId: PP_E_GLOBALLOADDOMAIN_BADPTR
//
// MessageText:
//
//  Bad service provider pointer during domain loading.
//
#define PP_E_GLOBALLOADDOMAIN_BADPTR     ((HRESULT)0x80041412L)

//
// MessageId: PP_E_GLOBALLOADDOMAIN_STRINGTABLE_BADPTR
//
// MessageText:
//
//  Bad string table pointer during domain loading.
//
#define PP_E_GLOBALLOADDOMAIN_STRINGTABLE_BADPTR ((HRESULT)0x80041413L)

//
// MessageId: PP_E_GLOBALLOADREG_STRINGTABLE_BADPTR
//
// MessageText:
//
//  Bad string table pointer during loading from registry.
//
#define PP_E_GLOBALLOADREG_STRINGTABLE_BADPTR ((HRESULT)0x80041414L)

//
// MessageId: PP_E_GLOBALLOADSTRING_STRINGTABLE_BADPTR
//
// MessageText:
//
//  Bad string table pointer during loading of substitution resource strings.
//
#define PP_E_GLOBALLOADSTRING_STRINGTABLE_BADPTR ((HRESULT)0x80041415L)

//
// MessageId: PP_E_GLOBALLOADCONFIG_BADPTR
//
// MessageText:
//
//  Bad service provider pointer during global initialization.
//
#define PP_E_GLOBALLOADCONFIG_BADPTR     ((HRESULT)0x80041416L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_BADPTR
//
// MessageText:
//
//  Bad Passport Manager pointer during domain loading.
//
#define PP_E_GLOBALGETDOMAIN_BADPTR      ((HRESULT)0x80041417L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_BADVARTYPE
//
// MessageText:
//
//  Bad data type for domains returned by Passport Manager. 
//
#define PP_E_GLOBALGETDOMAIN_BADVARTYPE  ((HRESULT)0x80041418L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_BADACCESSPTR
//
// MessageText:
//
//  Bad safe array access pointer to read domains returned from Passport Manager.
//
#define PP_E_GLOBALGETDOMAIN_BADACCESSPTR ((HRESULT)0x80041419L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_TOOMANYDOMAINS
//
// MessageText:
//
//  More than 64 domains were read by Passport Manager during global initialization.
//
#define PP_E_GLOBALGETDOMAIN_TOOMANYDOMAINS ((HRESULT)0x80041420L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_BADDOMAINVARTYPE
//
// MessageText:
//
//  The domain variant type is unexpected when loading a domain that was read by Passport Manager during global initialization.
//
#define PP_E_GLOBALGETDOMAIN_BADDOMAINVARTYPE ((HRESULT)0x80041421L)

//
// MessageId: PP_E_GLOBALGETDOMAIN_BADDOMAINPTR
//
// MessageText:
//
//  The pointer to the domain value is bad when loading a domain that was read by Passport Manager during global initialization.
//
#define PP_E_GLOBALGETDOMAIN_BADDOMAINPTR ((HRESULT)0x80041422L)

//
// MessageId: PP_E_MD5SILENT_SITEID_IS_ONE
//
// MessageText:
//
//  The messenger application partner id is 1.
//
#define PP_E_MD5SILENT_SITEID_IS_ONE     ((HRESULT)0x80041600L)

//
// MessageId: PP_E_MD5SILENT_INVALID_SITE
//
// MessageText:
//
//  Invalid site for MD5.
//
#define PP_E_MD5SILENT_INVALID_SITE      ((HRESULT)0x80041604L)

//
// MessageId: PP_E_HASHSTRING_ADDRECORD_FAILED
//
// MessageText:
//
//  Failed to add string into the string table.
//
#define PP_E_HASHSTRING_ADDRECORD_FAILED ((HRESULT)0x80041900L)

//
// MessageId: PP_E_MD5_HASH_FAILED
//
// MessageText:
//
//  Failed to compute the MD5 hash.
//
#define PP_E_MD5_HASH_FAILED             ((HRESULT)0x80041901L)

//
// MessageId: PP_E_EMAILRESPONSE_INTERNALERROR
//
// MessageText:
//
//  Internal error while processing the email response.
//
#define PP_E_EMAILRESPONSE_INTERNALERROR ((HRESULT)0x80041D01L)

//
// MessageId: PP_E_EMAIL_NOT_FOUND
//
// MessageText:
//
//  Failed to find email record in DB to validate email response.
//
#define PP_E_EMAIL_NOT_FOUND             ((HRESULT)0x80041D02L)

//
// MessageId: PP_E_EMAILRESPONSE_CHECKSECRET
//
// MessageText:
//
//  The email response has failed validation.
//
#define PP_E_EMAILRESPONSE_CHECKSECRET   ((HRESULT)0x80041D04L)

//
// MessageId: PP_E_EMAIL_ALREADY_PROCESSED
//
// MessageText:
//
//  The email response was previously processed.
//
#define PP_E_EMAIL_ALREADY_PROCESSED     ((HRESULT)0x80041D08L)

//
// MessageId: PP_E_PSTUTIL_INVALID_EMAIL_STATUS
//
// MessageText:
//
//  The email validation for an account has reached a state that email can not be resent.
//
#define PP_E_PSTUTIL_INVALID_EMAIL_STATUS ((HRESULT)0x80041E00L)

//
// MessageId: PP_E_LOGIN_NEED_STRONGPW_EXPIRY
//
// MessageText:
//
//  The partner site requires a strong password and password expiry.
//
#define PP_E_LOGIN_NEED_STRONGPW_EXPIRY  ((HRESULT)0x80041E01L)

//
// MessageId: PP_E_BROWSERINFO_INITFAIL
//
// MessageText:
//
//  The browser info look up failed because the internal browser table is not set up. 
//
#define PP_E_BROWSERINFO_INITFAIL        ((HRESULT)0x80042050L)

//
// MessageId: PP_E_CBROWSERINFO_INITFAIL
//
// MessageText:
//
//  The handler could not get browser info on this request.
//
#define PP_E_CBROWSERINFO_INITFAIL       ((HRESULT)0x80042051L)

//
// MessageId: PP_E_URL_TOOLONG
//
// MessageText:
//
//  The URL is too long.
//
#define PP_E_URL_TOOLONG                 ((HRESULT)0x80042700L)

//
// MessageId: PP_E_NO_FIELD
//
// MessageText:
//
//  Failed to get the field id from its name.
//
#define PP_E_NO_FIELD                    ((HRESULT)0x80043401L)

//
// MessageId: PP_E_INVALID_FIELD
//
// MessageText:
//
//  The field value is invalid.
//
#define PP_E_INVALID_FIELD               ((HRESULT)0x80043402L)

//
// MessageId: PP_E_CRITICAL
//
// MessageText:
//
//  Failed to set a cookie due to insufficient buffer to format cookie content.
//
#define PP_E_CRITICAL                    ((HRESULT)0x80043403L)

//
// MessageId: PP_E_TRUSTED_REALM_NOT_FOUND
//
// MessageText:
//
//  Unable to find trusted realm.
//
#define PP_E_TRUSTED_REALM_NOT_FOUND     ((HRESULT)0x80043404L)

//
// MessageId: PP_E_CERT_BLOB_UNDECODEABLE
//
// MessageText:
//
//  Unable to decode trusted realm certificate blob.
//
#define PP_E_CERT_BLOB_UNDECODEABLE      ((HRESULT)0x80043405L)

//
// MessageId: PP_E_NAME_DOMAINFIXED_BLANK
//
// MessageText:
//
//  The member name is blank.
//
#define PP_E_NAME_DOMAINFIXED_BLANK      ((HRESULT)0x80043406L)

//
// MessageId: PP_E_NAME_DOMAINFIXED_TOO_SHORT
//
// MessageText:
//
//  The member name is too short.
//
#define PP_E_NAME_DOMAINFIXED_TOO_SHORT  ((HRESULT)0x80043407L)

//
// MessageId: PP_E_NAME_DOMAINFIXED_TOO_LONG
//
// MessageText:
//
//  The member name is too long.
//
#define PP_E_NAME_DOMAINFIXED_TOO_LONG   ((HRESULT)0x80043408L)

//
// MessageId: PP_E_NAME_DOMAINFIXED_INVALID
//
// MessageText:
//
//  The member name has invalid characters.
//
#define PP_E_NAME_DOMAINFIXED_INVALID    ((HRESULT)0x80043409L)

//
// MessageId: PP_E_ALTEMAIL_SAMEASMEMNAME
//
// MessageText:
//
//  The alternate email address is the same as the member name.
//
#define PP_E_ALTEMAIL_SAMEASMEMNAME      ((HRESULT)0x8004340AL)

//
// MessageId: PP_E_MEMBER_EXISTHOTMAIL
//
// MessageText:
//
//  The users email already exists
//
#define PP_E_MEMBER_EXISTHOTMAIL         ((HRESULT)0x8004340BL)

//
// MessageId: PP_E_BROWSER_NOT_SUPPORTED
//
// MessageText:
//
//  The browser the user is using is not supported by the Passport Network.
//
#define PP_E_BROWSER_NOT_SUPPORTED       ((HRESULT)0x8004340CL)

//
// MessageId: PP_E_TIMEZONE_NOTMATCHCOUNTRY
//
// MessageText:
//
//  The user has selected a timezone that does not match their country
//
#define PP_E_TIMEZONE_NOTMATCHCOUNTRY    ((HRESULT)0x8004340DL)

//
// MessageId: PP_E_LOCATION_INVALID_CITY
//
// MessageText:
//
//  Country does not allow city in profile.
//
#define PP_E_LOCATION_INVALID_CITY       ((HRESULT)0x8004340EL)

//
// MessageId: PP_E_LOCATION_INVALID_ADDRESS
//
// MessageText:
//
//  Country does not allow address in profile.
//
#define PP_E_LOCATION_INVALID_ADDRESS    ((HRESULT)0x8004340FL)

//
// MessageId: PP_E_RESETPWD_MEMBER_LOCKED
//
// MessageText:
//
//  The credential is locked out.
//
#define PP_E_RESETPWD_MEMBER_LOCKED      ((HRESULT)0x80043410L)

//
// MessageId: PP_E_RESETPWDBYEMAIL_MEMBER_LOCKED
//
// MessageText:
//
//  The credential is locked out while reset password by email.
//
#define PP_E_RESETPWDBYEMAIL_MEMBER_LOCKED ((HRESULT)0x80043411L)

//
// MessageId: PP_E_RESETPWD_CRED_BLANK
//
// MessageText:
//
//  The membername is not entered during reset password.
//
#define PP_E_RESETPWD_CRED_BLANK         ((HRESULT)0x80043412L)

//
// MessageId: PP_E_RESETPWD_CRED_INVALID_FORMAT
//
// MessageText:
//
//  The membername does not follow SMTP standard.
//
#define PP_E_RESETPWD_CRED_INVALID_FORMAT ((HRESULT)0x80043413L)

//
// MessageId: PP_E_RESETPWD_HIP_BLANK
//
// MessageText:
//
//  The HIP is not entered during reset password.
//
#define PP_E_RESETPWD_HIP_BLANK          ((HRESULT)0x80043414L)

//
// MessageId: PP_E_RESETPWD_CRED_HIP_MISMATCH
//
// MessageText:
//
//  The membername and/or HIP is not correctly entered during reset password.
//
#define PP_E_RESETPWD_CRED_HIP_MISMATCH  ((HRESULT)0x80043415L)

//
// MessageId: PP_E_RESETPWD_HIP_MISMATCH
//
// MessageText:
//
//  The HIP is not correctly entered during reset password.
//
#define PP_E_RESETPWD_HIP_MISMATCH       ((HRESULT)0x80043416L)

//
// MessageId: PP_E_RESETPWD_PROFSA_BLANK
//
// MessageText:
//
//  The Secret Answer is not entered during reset password.
//
#define PP_E_RESETPWD_PROFSA_BLANK       ((HRESULT)0x80043417L)

//
// MessageId: PP_E_RESETPWD_PROFSA_MISMATCH
//
// MessageText:
//
//  The Profile and/or Secret Answer is not correctly entered during reset password.
//
#define PP_E_RESETPWD_PROFSA_MISMATCH    ((HRESULT)0x80043418L)

//
// MessageId: PP_E_RESETPWD_CCINFO_BLANK
//
// MessageText:
//
//  The billing information is not entered during reset password.
//
#define PP_E_RESETPWD_CCINFO_BLANK       ((HRESULT)0x80043419L)

//
// MessageId: PP_E_RESETPWD_CCINFO_MISMATCH
//
// MessageText:
//
//  The billing information is not correctly entered during reset password.
//
#define PP_E_RESETPWD_CCINFO_MISMATCH    ((HRESULT)0x8004341AL)

//
// MessageId: PP_E_INVALID_REALM_AUTHURL
//
// MessageText:
//
//  No Atuh URL was found for a trusted realm.
//
#define PP_E_INVALID_REALM_AUTHURL       ((HRESULT)0x8004341BL)

//
// MessageId: PP_E_SA_CONTAINS_PASSWORD
//
// MessageText:
//
//  The answer for the secret question contains the password.
//
#define PP_E_SA_CONTAINS_PASSWORD        ((HRESULT)0x8004341CL)

//
// MessageId: PP_E_SA_CONTAINED_IN_PASSWORD
//
// MessageText:
//
//  The answer for the secret question contained in the password.
//
#define PP_E_SA_CONTAINED_IN_PASSWORD    ((HRESULT)0x8004341DL)

//
// MessageId: PP_E_SQ_CONTAINS_PASSWORD
//
// MessageText:
//
//  The secret question contains the password.
//
#define PP_E_SQ_CONTAINS_PASSWORD        ((HRESULT)0x8004341EL)

//
// MessageId: PP_E_RESETPWD_WRONG_EMAIL
//
// MessageText:
//
//  The wrong e-mail is entered incorrectly during reset password by email.
//
#define PP_E_RESETPWD_WRONG_EMAIL        ((HRESULT)0x8004341FL)

//
// MessageId: PP_E_RESETPWD_WRONG_SA
//
// MessageText:
//
//  The secret answer is entered incorrectly during reset strong password by email.
//
#define PP_E_RESETPWD_WRONG_SA           ((HRESULT)0x80043420L)

//
// MessageId: PP_E_CUSTOMSTR_NOT_HANDLED
//
// MessageText:
//
//  The custom string requested is not handled.
//
#define PP_E_CUSTOMSTR_NOT_HANDLED       ((HRESULT)0x80043421L)

//
// MessageId: PP_E_FLOWDISABLED
//
// MessageText:
//
//  The flow has been disabled via CCM.
//
#define PP_E_FLOWDISABLED                ((HRESULT)0x80043422L)

//
// MessageId: PP_E_EMAIL_CHANGE_NOT_ALLOWED
//
// MessageText:
//
//  The email domain does not allow email name change.
//
#define PP_E_EMAIL_CHANGE_NOT_ALLOWED    ((HRESULT)0x80043423L)

//
// MessageId: PP_E_EMAIL_CONTAINS_PASSWORD
//
// MessageText:
//
//  The left part of the email name cannot contain the password.
//
#define PP_E_EMAIL_CONTAINS_PASSWORD     ((HRESULT)0x80043424L)

//
// MessageId: PP_E_EMAIL_LINK_INVALID
//
// MessageText:
//
//  The email link has expired.
//
#define PP_E_EMAIL_LINK_INVALID          ((HRESULT)0x80043425L)

// base 0x1200
// Errors
//#define PP_E_TMP  0x1200
//
// MessageId: PP_E_DB_DOMAINNOTSUPPORTED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DB_DOMAINNOTSUPPORTED       ((HRESULT)0x80041226L)

//
// MessageId: PP_E_DB_SERVERDOWNSTATE0
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DB_SERVERDOWNSTATE0         ((HRESULT)0x80041227L)

//
// MessageId: PP_E_DB_SERVERDOWNSTATE1
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DB_SERVERDOWNSTATE1         ((HRESULT)0x80041228L)

//
// MessageId: PP_E_DB_SERVERDOWNSTATE2
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DB_SERVERDOWNSTATE2         ((HRESULT)0x80041229L)

//
// MessageId: PP_E_DBSTATUS_ERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DBSTATUS_ERROR              ((HRESULT)0x80041230L)

//
// MessageId: PP_E_SRFCONTENTERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_SRFCONTENTERROR             ((HRESULT)0x80041231L)

//
// MessageId: PP_E_DBGLOBALNULL
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DBGLOBALNULL                ((HRESULT)0x80041232L)

//
// MessageId: PP_E_NOOTHERCREDENTIAL
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_NOOTHERCREDENTIAL           ((HRESULT)0x80041233L)

//
// MessageId: PP_E_DB_CERTASSOCDOESNOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_DB_CERTASSOCDOESNOTEXIST    ((HRESULT)0x80041234L)

//
// MessageId: PP_E_MEMBER_IN_DELAYED_RECYCLE
//
// MessageText:
//
//  Membername cannot be used at this time
//
#define PP_E_MEMBER_IN_DELAYED_RECYCLE   ((HRESULT)0x80041238L)

// BKWD COMPAT WITH 2.5 ERROR CODES
//
// MessageId: PP_E_OLDDB_STRINGTOOLONG
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_STRINGTOOLONG         ((HRESULT)0x80041200L)

//
// MessageId: PP_E_OLDDB_STRINGTOOSHORT
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_STRINGTOOSHORT        ((HRESULT)0x80041201L)

//
// MessageId: PP_E_OLDDB_INVALIDPASSWORD
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_INVALIDPASSWORD       ((HRESULT)0x80041202L)

//
// MessageId: PP_E_OLDDB_INVALIDEMAIL
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_INVALIDEMAIL          ((HRESULT)0x80041203L)

//
// MessageId: PP_E_OLDDB_INVALIDMEMBERNAME
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_INVALIDMEMBERNAME     ((HRESULT)0x80041204L)

//
// MessageId: PP_E_OLDDB_MISSINGPARAMETERS
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_MISSINGPARAMETERS     ((HRESULT)0x80041205L)

//
// MessageId: PP_E_OLDDB_FORBIDDENWORD
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_FORBIDDENWORD         ((HRESULT)0x80041206L)

//
// MessageId: PP_E_OLDDB_INVALIDDOMAINNAME
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_INVALIDDOMAINNAME     ((HRESULT)0x80041207L)

//
// MessageId: PP_E_OLDDB_CRITICALERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_CRITICALERROR         ((HRESULT)0x80041208L)

//
// MessageId: PP_E_OLDDB_ERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_ERROR                 ((HRESULT)0x80041209L)

//
// MessageId: PP_E_OLDDB_MEMBEREXISTS
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_MEMBEREXISTS          ((HRESULT)0x8004120AL)

//
// MessageId: PP_E_OLDDB_MEMBERDOESNOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_MEMBERDOESNOTEXIST    ((HRESULT)0x8004120BL)

//
// MessageId: PP_E_OLDDB_NODATA
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_NODATA                ((HRESULT)0x8004120CL)

//
// MessageId: PP_E_OLDDB_DUPLICATEFRIENDLYNAME
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_DUPLICATEFRIENDLYNAME ((HRESULT)0x8004120DL)

//
// MessageId: PP_E_OLDDB_ADDRESSDOESNOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_ADDRESSDOESNOTEXIST   ((HRESULT)0x8004120EL)

//
// MessageId: PP_E_OLDDB_CARDDOESNOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_CARDDOESNOTEXIST      ((HRESULT)0x8004120FL)

//
// MessageId: PP_E_OLDDB_ADDRESSREFERENCEDBYCARD
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_ADDRESSREFERENCEDBYCARD ((HRESULT)0x80041210L)

//
// MessageId: PP_E_OLDDB_KIDSSITENOTLISTED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_KIDSSITENOTLISTED     ((HRESULT)0x80041211L)

//
// MessageId: PP_E_OLDDB_SITEALREADYREQUESTED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_SITEALREADYREQUESTED  ((HRESULT)0x80041212L)

//
// MessageId: PP_E_OLDDB_CONNECTIONTIMEOUT
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_CONNECTIONTIMEOUT     ((HRESULT)0x80041213L)

//
// MessageId: PP_E_OLDDB_NOCONNECTIONAVAILABLE
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_NOCONNECTIONAVAILABLE ((HRESULT)0x80041224L)

//
// MessageId: PP_E_OLDDB_TOOMANYUSERSWITHTHISNAME
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_TOOMANYUSERSWITHTHISNAME ((HRESULT)0x80041225L)

//
// MessageId: PP_E_OLDDB_CERTSTOOMANY
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_CERTSTOOMANY          ((HRESULT)0x80041235L)

//
// MessageId: PP_E_OLDDB_EMAILBITWRONGCREDTYPE
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_OLDDB_EMAILBITWRONGCREDTYPE ((HRESULT)0x80041236L)

// base 0x1300
// Errors
#define PP_E_XML_BASE  0x1300
//
// MessageId: PP_E_XML_PARSE_ERROR
//
// MessageText:
//
//  Failed to Parse XML input.
//
#define PP_E_XML_PARSE_ERROR             ((HRESULT)0x80041300L)

//
// MessageId: PP_E_XML_NO_CLIENTINFO
//
// MessageText:
//
//  The client info not is absent.
//
#define PP_E_XML_NO_CLIENTINFO           ((HRESULT)0x80041301L)

//
// MessageId: PP_E_XML_UNKNOWN_CLIENTVERSION
//
// MessageText:
//
//  Client version is not supported.
//
#define PP_E_XML_UNKNOWN_CLIENTVERSION   ((HRESULT)0x80041302L)

//
// MessageId: PP_E_XML_NAME_AND_PASSWORD_BLANK
//
// MessageText:
//
//  User name or password is blank.
//
#define PP_E_XML_NAME_AND_PASSWORD_BLANK ((HRESULT)0x80041303L)

//
// MessageId: PP_E_XML_DOMAIN_BLANK
//
// MessageText:
//
//  Domain field is blank.
//
#define PP_E_XML_DOMAIN_BLANK            ((HRESULT)0x80041304L)

//
// MessageId: PP_E_XML_INCOMPLETE_MEMBERNAME
//
// MessageText:
//
//  Membername is incomplete.
//
#define PP_E_XML_INCOMPLETE_MEMBERNAME   ((HRESULT)0x80041305L)

//
// MessageId: PP_E_XML_NO_SUCH_NODE
//
// MessageText:
//
//  Missing XML node.
//
#define PP_E_XML_NO_SUCH_NODE            ((HRESULT)0x80041306L)

//
// MessageId: PP_E_XML_NO_TEXT
//
// MessageText:
//
//  The XML node has no text.
//
#define PP_E_XML_NO_TEXT                 ((HRESULT)0x80041307L)

//
// MessageId: PP_E_XML_INVALID_ROOTTAG
//
// MessageText:
//
//  The ROOT tag is invalid.
//
#define PP_E_XML_INVALID_ROOTTAG         ((HRESULT)0x80041308L)

//
// MessageId: PP_E_XML_USER_ALREADY_LOGGEDIN
//
// MessageText:
//
//  The user was already logged in.
//
#define PP_E_XML_USER_ALREADY_LOGGEDIN   ((HRESULT)0x80041309L)

//
// MessageId: PP_E_XML_KEYVERSION_NOT_A_NUMBER
//
// MessageText:
//
//  Key version is not a valid number.
//
#define PP_E_XML_KEYVERSION_NOT_A_NUMBER ((HRESULT)0x8004130AL)

//
// MessageId: PP_E_XML_NO_USER_LOGGED_IN
//
// MessageText:
//
//  No user has logged in.
//
#define PP_E_XML_NO_USER_LOGGED_IN       ((HRESULT)0x8004130BL)

//
// MessageId: PP_E_XML_NO_SUCH_ATTRIBUTE
//
// MessageText:
//
//  Missing XML attribute.
//
#define PP_E_XML_NO_SUCH_ATTRIBUTE       ((HRESULT)0x8004130CL)

//
// MessageId: PP_E_XML_PROXY_SITE_NOT_ALLOWED
//
// MessageText:
//
//  Proxy is not allowed for the site.
//
#define PP_E_XML_PROXY_SITE_NOT_ALLOWED  ((HRESULT)0x8004130DL)

//
// MessageId: PP_E_XML_PROXY_INVALID_LOGIN_SITE
//
// MessageText:
//
//  Proxy cannot sign in to the site.
//
#define PP_E_XML_PROXY_INVALID_LOGIN_SITE ((HRESULT)0x8004130EL)

//
// MessageId: PP_E_XML_PROXY_FAILED_TIMEWINDOW
//
// MessageText:
//
//  Invalid time window for xml proxy auth.
//
#define PP_E_XML_PROXY_FAILED_TIMEWINDOW ((HRESULT)0x8004130FL)

//
// MessageId: PP_E_XML_PROXY_PUID_INVALID
//
// MessageText:
//
//  Invalid PUID for xml proxy auth.
//
#define PP_E_XML_PROXY_PUID_INVALID      ((HRESULT)0x80041310L)

//
// MessageId: PP_E_XML_PROXY_PROOF_INVALID
//
// MessageText:
//
//  Invalid proof for proxy auth.
//
#define PP_E_XML_PROXY_PROOF_INVALID     ((HRESULT)0x80041311L)

//
// MessageId: PP_E_XML_PROXY_NOT_NAMESPACE_OWNER
//
// MessageText:
//
//  The proxy site does not own the namespace.
//
#define PP_E_XML_PROXY_NOT_NAMESPACE_OWNER ((HRESULT)0x80041312L)

//
// MessageId: PP_E_XML_NO_SIGNATURE_ELEMENT
//
// MessageText:
//
//  XML signature is missing.
//
#define PP_E_XML_NO_SIGNATURE_ELEMENT    ((HRESULT)0x80041313L)

//
// MessageId: PP_E_XML_INVALID_SIGNATURE
//
// MessageText:
//
//  Invalid XML signature.
//
#define PP_E_XML_INVALID_SIGNATURE       ((HRESULT)0x80041317L)

//
// MessageId: PP_E_XML_LOADFAILED
//
// MessageText:
//
//  Failed to load xml into DOM.
//
#define PP_E_XML_LOADFAILED              ((HRESULT)0x80041318L)

//
// MessageId: PP_E_XMLSIG_INCOMPLETE_INFO
//
// MessageText:
//
//  Incomplete XML signature.
//
#define PP_E_XMLSIG_INCOMPLETE_INFO      ((HRESULT)0x80041319L)

//
// MessageId: PP_E_XMLSIG_BAD_SIG_XML_TEXT
//
// MessageText:
//
//  XML signature text is incorrect.
//
#define PP_E_XMLSIG_BAD_SIG_XML_TEXT     ((HRESULT)0x8004131AL)

//
// MessageId: PP_E_XML_FCP_USER_NOT_FCP_IN_DB
//
// MessageText:
//
//  User force change password state was not written in DB.
//
#define PP_E_XML_FCP_USER_NOT_FCP_IN_DB  ((HRESULT)0x8004131BL)

// base 0x1500
//
// MessageId: PP_E_DIGEST_PARSE_AUTH_HEADER
//
// MessageText:
//
//  Failed to parse digest header.
//
#define PP_E_DIGEST_PARSE_AUTH_HEADER    ((HRESULT)0x80041500L)

//
// MessageId: PP_E_DIGEST_OPAQUE_MISSMATCH
//
// MessageText:
//
//  OPAQUE in the digest header does not match the challenge.
//
#define PP_E_DIGEST_OPAQUE_MISSMATCH     ((HRESULT)0x80041501L)

//
// MessageId: PP_E_DIGEST_ALGORITHM_MISSMATCH
//
// MessageText:
//
//  The Digest algorithm does not match the challenge.
//
#define PP_E_DIGEST_ALGORITHM_MISSMATCH  ((HRESULT)0x80041502L)

//
// MessageId: PP_E_DIGEST_REALMS_MISSMATCH
//
// MessageText:
//
//  Realms in the digest header does not match the challenge.
//
#define PP_E_DIGEST_REALMS_MISSMATCH     ((HRESULT)0x80041503L)

//
// MessageId: PP_E_DIGEST_URI_MISSMATCH
//
// MessageText:
//
//  Worng URI.
//
#define PP_E_DIGEST_URI_MISSMATCH        ((HRESULT)0x80041504L)

//
// MessageId: PP_E_DIGEST_USERNAME_MISSING
//
// MessageText:
//
//  User name is missing from the digest header.
//
#define PP_E_DIGEST_USERNAME_MISSING     ((HRESULT)0x80041505L)

//
// MessageId: PP_E_DIGEST_CNONCE_MISSING
//
// MessageText:
//
//  The CNONCE is missing from the digest header.
//
#define PP_E_DIGEST_CNONCE_MISSING       ((HRESULT)0x80041506L)

//
// MessageId: PP_E_DIGEST_NONCE_COUNT_MISSING
//
// MessageText:
//
//  The Nonce count is missing from the digest header.
//
#define PP_E_DIGEST_NONCE_COUNT_MISSING  ((HRESULT)0x80041507L)

//
// MessageId: PP_E_DIGEST_NONCE_MISSING
//
// MessageText:
//
//  The Nonce is missing from the digest header.
//
#define PP_E_DIGEST_NONCE_MISSING        ((HRESULT)0x80041508L)

//
// MessageId: PP_E_DIGEST_UNSUPPORTED_KPP_MODE
//
// MessageText:
//
//  The given KPP mode is not supported by Digest protocol.
//
#define PP_E_DIGEST_UNSUPPORTED_KPP_MODE ((HRESULT)0x80041509L)

//
// MessageId: PP_E_DIGEST_NONCE_MISSMATCH
//
// MessageText:
//
//  The Nonce does not match the challenge.
//
#define PP_E_DIGEST_NONCE_MISSMATCH      ((HRESULT)0x8004150AL)

//
// MessageId: PP_E_DIGEST_RESPONSE_TIMEOUT
//
// MessageText:
//
//  The response has timeout.
//
#define PP_E_DIGEST_RESPONSE_TIMEOUT     ((HRESULT)0x8004150BL)

//
// MessageId: PP_E_DIGEST_RESPONSE_MISSING
//
// MessageText:
//
//  The digest response is missing.
//
#define PP_E_DIGEST_RESPONSE_MISSING     ((HRESULT)0x8004150CL)

//
// MessageId: PP_E_DIGEST_QOP_MISSMATCH
//
// MessageText:
//
//  The digest QOP does not match the chellenge.
//
#define PP_E_DIGEST_QOP_MISSMATCH        ((HRESULT)0x8004150DL)

//
// MessageId: PP_E_DIGEST_INVALID_NONCE_COUNT
//
// MessageText:
//
//  The Nonce count in the header is invalid.
//
#define PP_E_DIGEST_INVALID_NONCE_COUNT  ((HRESULT)0x8004150EL)

//
// MessageId: PP_E_DIGEST_HOTMAIL_USERNAME_MISMATCH
//
// MessageText:
//
//  The user name in the header does not match the request. For HM account only.
//
#define PP_E_DIGEST_HOTMAIL_USERNAME_MISMATCH ((HRESULT)0x8004150FL)

// base 0x1800
// Errors
#define PP_E_NETPARTNERINFO_BASE  0x1800
//
// MessageId: PP_E_NETPARTNERINFO_UNINITIALZED
//
// MessageText:
//
//  The Netpartnerinfo object is uninitialized.
//
#define PP_E_NETPARTNERINFO_UNINITIALZED ((HRESULT)0x80041800L)

//
// MessageId: PP_E_NETPARTNERINFO_SITEID_NOT_FOUND
//
// MessageText:
//
//  The site id does not exist.
//
#define PP_E_NETPARTNERINFO_SITEID_NOT_FOUND ((HRESULT)0x80041801L)

//
// MessageId: PP_E_NETPARTNERINFO_DECRYPT_FAILED
//
// MessageText:
//
//  Failed to decrypt data. Check error code for reason.
//
#define PP_E_NETPARTNERINFO_DECRYPT_FAILED ((HRESULT)0x80041802L)

//
// MessageId: PP_E_NETPARTNERINFO_KEYSIZE_MISMATCH
//
// MessageText:
//
//  The size of the partner key is invalid.
//
#define PP_E_NETPARTNERINFO_KEYSIZE_MISMATCH ((HRESULT)0x80041803L)

//
// MessageId: PP_E_NETPARTNERINFO_CREATEFILE
//
// MessageText:
//
//  Failed to create the file for cached sites.
//
#define PP_E_NETPARTNERINFO_CREATEFILE   ((HRESULT)0x80041804L)

//
// MessageId: PP_E_NETPARTNERINFO_WRITEFILE
//
// MessageText:
//
//  Failed to write to site cache file.
//
#define PP_E_NETPARTNERINFO_WRITEFILE    ((HRESULT)0x80041805L)

//
// MessageId: PP_E_NETPARTNERINFO_READFILE
//
// MessageText:
//
//  Failed to read from the site cache file.
//
#define PP_E_NETPARTNERINFO_READFILE     ((HRESULT)0x80041806L)

//
// MessageId: PP_E_NETPARTNERINFO_KEY_EXPIRED
//
// MessageText:
//
//  The specific partner key has expired.
//
#define PP_E_NETPARTNERINFO_KEY_EXPIRED  ((HRESULT)0x80041807L)

//
// MessageId: PP_E_NSO_NOT_STARTED
//
// MessageText:
//
//  The NSO object is not started.
//
#define PP_E_NSO_NOT_STARTED             ((HRESULT)0x80041808L)

//
// MessageId: PP_E_ASYMKEYVER_BADKEYGROUP
//
// MessageText:
//
//  The value used for "keygroup" for the multiinstance property "AsymKeyGroupKeyIdPair" in CCM for this service is not supported.
//
#define PP_E_ASYMKEYVER_BADKEYGROUP      ((HRESULT)0x80041809L)

//
// MessageId: PP_E_ASYMKEYVER_NOTFOUND
//
// MessageText:
//
//  The asymmetric key for the specified key version and keygroup & key/key id cannot be found.
//
#define PP_E_ASYMKEYVER_NOTFOUND         ((HRESULT)0x8004180AL)

//
// MessageId: PP_E_ASYMKEYSKI_NOTFOUND
//
// MessageText:
//
//  The asymmetric key for the specified subject key identifier and keygroup & key/key id cannot be found.
//
#define PP_E_ASYMKEYSKI_NOTFOUND         ((HRESULT)0x8004180BL)

//
// MessageId: PP_E_ASYMKEY_DB_BADTYPE
//
// MessageText:
//
//  The data type for the row in PPKeys DB is not VT_BSTR or the PFX is 0 byte length.
//
#define PP_E_ASYMKEY_DB_BADTYPE          ((HRESULT)0x8004180CL)

//
// MessageId: PP_E_ASYMKEY_NONE_VALID
//
// MessageText:
//
//  No valid asymmetric keys (ie PFX) was found for the given key group and key id.
//
#define PP_E_ASYMKEY_NONE_VALID          ((HRESULT)0x8004180DL)

//
// MessageId: PP_E_ASYMKEY_HEXENCODE_SKI
//
// MessageText:
//
//  Fail to hex encode the subject key identifier.
//
#define PP_E_ASYMKEY_HEXENCODE_SKI       ((HRESULT)0x8004180EL)

//
// MessageId: PP_E_ASYMKEY_NOCOLON_KEYGROUPKEYIDPAIR
//
// MessageText:
//
//  The value for an instance of AsymKeyGroupKeyIdPair in CCM for the service is missing a colon.
//
#define PP_E_ASYMKEY_NOCOLON_KEYGROUPKEYIDPAIR ((HRESULT)0x8004180FL)

//
// MessageId: PP_E_ASYMKEY_KEYGROUP_INVALID
//
// MessageText:
//
//  The KeyGroup value for an instance of AsymKeyGroupKeyIdPair in CCM for the service is not supported.
//
#define PP_E_ASYMKEY_KEYGROUP_INVALID    ((HRESULT)0x80041810L)

//
// MessageId: PP_E_ASYMKEY_KEYID_MISSING
//
// MessageText:
//
//  The KeyId value for an instance of AsymKeyGroupKeyIdPair in CCM for the service is not missing. The format of the AsymKeyGroupKeyIdPair is keygroup:keyid.
//
#define PP_E_ASYMKEY_KEYID_MISSING       ((HRESULT)0x80041811L)

//
// MessageId: PP_E_ASYMKEY_KEYID_INVALID
//
// MessageText:
//
//  The KeyId value for an instance of AsymKeyGroupKeyIdPair in CCM for the service is invalid.
//
#define PP_E_ASYMKEY_KEYID_INVALID       ((HRESULT)0x80041812L)

//
// MessageId: PP_E_ASYMKEY_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  There are more key group and key id combination than expected.
//
#define PP_E_ASYMKEY_INSUFFICIENT_BUFFER ((HRESULT)0x80041813L)

//
// MessageId: PP_E_ASYMKEY_NOT_INITIALIZED
//
// MessageText:
//
//  The asymmetric key cache has not been initialized.
//
#define PP_E_ASYMKEY_NOT_INITIALIZED     ((HRESULT)0x80041814L)

//
// MessageId: PP_E_ASYMKEYINFO_NOTINIT
//
// MessageText:
//
//  The asymmetric key interface was not initialized in the current object.
//
#define PP_E_ASYMKEYINFO_NOTINIT         ((HRESULT)0x80041815L)

// base 0x1A00
//
// MessageId: PP_E_GLOBALIZATION_INVALID_COUNTRY_ID
//
// MessageText:
//
//  Invalid Country Code specified. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_COUNTRY_ID ((HRESULT)0x80041A00L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_GEO_ID
//
// MessageText:
//
//  Invalid GEOID. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_GEO_ID ((HRESULT)0x80041A03L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_TIMEZONE_ID
//
// MessageText:
//
//  Invalid Timezone ID. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_TIMEZONE_ID ((HRESULT)0x80041A04L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_TIMEZONE
//
// MessageText:
//
//  Invalid Timezone. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_TIMEZONE ((HRESULT)0x80041A06L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_INDEX
//
// MessageText:
//
//  Invalid index into an array or list speficied. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_INDEX ((HRESULT)0x80041A07L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_DATA
//
// MessageText:
//
//  Invalid data specified. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_DATA  ((HRESULT)0x80041A08L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_DATA_TYPE
//
// MessageText:
//
//  Data has invalid data type. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_DATA_TYPE ((HRESULT)0x80041A09L)

//
// MessageId: PP_E_GLOBALIZATION_OBJ_IS_NULL
//
// MessageText:
//
//  Object is NULL. (hr=%1)
//
#define PP_E_GLOBALIZATION_OBJ_IS_NULL   ((HRESULT)0x80041A0AL)

//
// MessageId: PP_E_GLOBALIZATION_PTR_IS_NULL
//
// MessageText:
//
//  Pointer is NULL. (hr=%1)
//
#define PP_E_GLOBALIZATION_PTR_IS_NULL   ((HRESULT)0x80041A0BL)

//
// MessageId: PP_E_GLOBALIZATION_STREAM_IS_NULL
//
// MessageText:
//
//  File reading stream is NULL. (hr=%1)
//
#define PP_E_GLOBALIZATION_STREAM_IS_NULL ((HRESULT)0x80041A0CL)

//
// MessageId: PP_E_GLOBALIZATION_LCIDINFO_PARSE_ERROR
//
// MessageText:
//
//  Error parsing LCIDInfo file. (hr=%1)
//
#define PP_E_GLOBALIZATION_LCIDINFO_PARSE_ERROR ((HRESULT)0x80041A0EL)

//
// MessageId: PP_E_GLOBALIZATION_LCIDMAP_PARSE_ERR
//
// MessageText:
//
//  Error parsing LCID Map. (hr=%1)
//
#define PP_E_GLOBALIZATION_LCIDMAP_PARSE_ERR ((HRESULT)0x80041A0FL)

//
// MessageId: PP_E_GLOBALIZATION_ALREADY_LOADED
//
// MessageText:
//
//  Engine already loaded. (hr=%1)
//
#define PP_E_GLOBALIZATION_ALREADY_LOADED ((HRESULT)0x80041A10L)

//
// MessageId: PP_E_GLOBALIZATION_LCIDINFO_NOT_LOADED
//
// MessageText:
//
//  LCIDInfo is not yet loaded. (hr=%1)
//
#define PP_E_GLOBALIZATION_LCIDINFO_NOT_LOADED ((HRESULT)0x80041A11L)

//
// MessageId: PP_E_GLOBALIZATION_LCIDINFO_NOT_PREPARED
//
// MessageText:
//
//  LCIDInfo not prepared for reload. (hr=%1)
//
#define PP_E_GLOBALIZATION_LCIDINFO_NOT_PREPARED ((HRESULT)0x80041A12L)

//
// MessageId: PP_E_GLOBALIZATION_REGION_LOAD_FAILED
//
// MessageText:
//
//  Error loading Region object. (hr=%1)
//
#define PP_E_GLOBALIZATION_REGION_LOAD_FAILED ((HRESULT)0x80041A13L)

//
// MessageId: PP_E_GLOBALIZATION_TIMEZONE_LOAD_FAILED
//
// MessageText:
//
//  Error loading Timezone object. (hr=%1)
//
#define PP_E_GLOBALIZATION_TIMEZONE_LOAD_FAILED ((HRESULT)0x80041A14L)

//
// MessageId: PP_E_GLOBALIZATION_LOOKUP_OBJ_FAILED
//
// MessageText:
//
//  Error looking up a glb object such as country or region. (hr=%1)
//
#define PP_E_GLOBALIZATION_LOOKUP_OBJ_FAILED ((HRESULT)0x80041A15L)

//
// MessageId: PP_E_GLOBALIZATION_LOADVALUES_FAILED
//
// MessageText:
//
//  Data population failed. (hr=%1)
//
#define PP_E_GLOBALIZATION_LOADVALUES_FAILED ((HRESULT)0x80041A16L)

//
// MessageId: PP_E_GLOBALIZATION_GETLOCALEINFO_FAILED
//
// MessageText:
//
//  Error getting LocaleInfo object. (hr=%1)
//
#define PP_E_GLOBALIZATION_GETLOCALEINFO_FAILED ((HRESULT)0x80041A17L)

//
// MessageId: PP_E_GLOBALIZATION_STRING_RETURNED
//
// MessageText:
//
//  Error parsing.  String returned. (hr=%1)
//
#define PP_E_GLOBALIZATION_STRING_RETURNED ((HRESULT)0x80041A18L)

//
// MessageId: PP_E_GLOBALIZATION_W2A_FAILED
//
// MessageText:
//
//  String conversion failed. (hr=%1)
//
#define PP_E_GLOBALIZATION_W2A_FAILED    ((HRESULT)0x80041A19L)

//
// MessageId: PP_E_GLOBALIZATION_A2W_FAILED
//
// MessageText:
//
//  String conversion failed. (hr=%1)
//
#define PP_E_GLOBALIZATION_A2W_FAILED    ((HRESULT)0x80041A1AL)

//
// MessageId: PP_E_GLOBALIZATION_INSTREAM_FAILED
//
// MessageText:
//
//  Stream failure. (hr=%1)
//
#define PP_E_GLOBALIZATION_INSTREAM_FAILED ((HRESULT)0x80041A1BL)

//
// MessageId: PP_E_GLOBALIZATION_GET_LCIDINFODIR_FAILED
//
// MessageText:
//
//  Error getting the LCIDInfo directory. (hr=%1)
//
#define PP_E_GLOBALIZATION_GET_LCIDINFODIR_FAILED ((HRESULT)0x80041A1CL)

//
// MessageId: PP_E_GLOBALIZATION_STRING_TOO_LONG
//
// MessageText:
//
//  String too long. (hr=%1)
//
#define PP_E_GLOBALIZATION_STRING_TOO_LONG ((HRESULT)0x80041A1DL)

//
// MessageId: PP_E_GLOBALIZATION_IDTABLE_NOT_INIT
//
// MessageText:
//
//  IDTable not initialized yet. (hr=%1)
//
#define PP_E_GLOBALIZATION_IDTABLE_NOT_INIT ((HRESULT)0x80041A1EL)

//
// MessageId: PP_E_GLOBALIZATION_CS_INIT_FAILED
//
// MessageText:
//
//  CriticalSection init failed. (hr=%1)
//
#define PP_E_GLOBALIZATION_CS_INIT_FAILED ((HRESULT)0x80041A20L)

//
// MessageId: PP_E_GLOBALIZATION_DICTIONARY_IS_NULL
//
// MessageText:
//
//  Dictionary is null. (hr=%1)
//
#define PP_E_GLOBALIZATION_DICTIONARY_IS_NULL ((HRESULT)0x80041A21L)

//
// MessageId: PP_E_GLOBALIZATION_GET_LIBRARYPATH_FAILED
//
// MessageText:
//
//  Getting the library path failed. (hr=%1)
//
#define PP_E_GLOBALIZATION_GET_LIBRARYPATH_FAILED ((HRESULT)0x80041A22L)

//
// MessageId: PP_E_GLOBALIZATION_EUCOUNTRYNEEDSOPTOUT
//
// MessageText:
//
//  Eu country is missing opt out data. (hr=%1)
//
#define PP_E_GLOBALIZATION_EUCOUNTRYNEEDSOPTOUT ((HRESULT)0x80041A23L)

//
// MessageId: PP_E_GLOBALIZATION_INVALID_LOCATION_ELEMENT_NAME
//
// MessageText:
//
//  Invalid location element name. (hr=%1)
//
#define PP_E_GLOBALIZATION_INVALID_LOCATION_ELEMENT_NAME ((HRESULT)0x80041A24L)

//
// MessageId: PP_E_GLOBALIZATION_DUPLICATE_LOCATION_ELEMENT_NAME
//
// MessageText:
//
//  Duplicate location element name. (hr=%1)
//
#define PP_E_GLOBALIZATION_DUPLICATE_LOCATION_ELEMENT_NAME ((HRESULT)0x80041A25L)

// base 0x1B00
//
// MessageId: PP_E_DELEGADMIN_INVALID_ADMIN_ELE
//
// MessageText:
//
//  Invalid Admin element
//
#define PP_E_DELEGADMIN_INVALID_ADMIN_ELE ((HRESULT)0x80041B00L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_ADMIN_TICKET
//
// MessageText:
//
//  Invalid Admin Ticket
//
#define PP_E_DELEGADMIN_INVALID_ADMIN_TICKET ((HRESULT)0x80041B01L)

//
// MessageId: PP_E_DELEGADMIN_DOMAIN_ALREADY_MANAGED
//
// MessageText:
//
//  Domain already managed
//
#define PP_E_DELEGADMIN_DOMAIN_ALREADY_MANAGED ((HRESULT)0x80041B02L)

//
// MessageId: PP_E_DELEGADMIN_DOMAIN_NOT_MANAGED
//
// MessageText:
//
//  Domain not managed
//
#define PP_E_DELEGADMIN_DOMAIN_NOT_MANAGED ((HRESULT)0x80041B03L)

//
// MessageId: PP_E_DELEGADMIN_DOMAIN_NOT_PARTNERS
//
// MessageText:
//
//  Domain not managed by partner
//
#define PP_E_DELEGADMIN_DOMAIN_NOT_PARTNERS ((HRESULT)0x80041B04L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_NS_ADMIN
//
// MessageText:
//
//  Invalid namespace admin
//
#define PP_E_DELEGADMIN_INVALID_NS_ADMIN ((HRESULT)0x80041B05L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_PARTNER_ADMIN
//
// MessageText:
//
//  Invalid partner admin
//
#define PP_E_DELEGADMIN_INVALID_PARTNER_ADMIN ((HRESULT)0x80041B06L)

//
// MessageId: PP_E_DELEGADMIN_ERROR_LOADING_XMLRQ
//
// MessageText:
//
//  Error loading XML request
//
#define PP_E_DELEGADMIN_ERROR_LOADING_XMLRQ ((HRESULT)0x80041B07L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_AUTH_ELE
//
// MessageText:
//
//  Invalid Authorization element
//
#define PP_E_DELEGADMIN_INVALID_AUTH_ELE ((HRESULT)0x80041B08L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_DOMAIN
//
// MessageText:
//
//  Invalid domain - invalid character or too many characters in domain name.
//
#define PP_E_DELEGADMIN_INVALID_DOMAIN   ((HRESULT)0x80041B09L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_ACTION
//
// MessageText:
//
//  Invalid action paramter
//
#define PP_E_DELEGADMIN_INVALID_ACTION   ((HRESULT)0x80041B0AL)

//
// MessageId: PP_E_DELEGADMIN_NOTALLOWED
//
// MessageText:
//
//  Action not allowed
//
#define PP_E_DELEGADMIN_NOTALLOWED       ((HRESULT)0x80041B0CL)

//
// MessageId: PP_E_DELEGADMIN_INVALID_CLIENTVERSION
//
// MessageText:
//
//  Invalid version
//
#define PP_E_DELEGADMIN_INVALID_CLIENTVERSION ((HRESULT)0x80041B0BL)

//
// MessageId: PP_E_DELEGADMIN_INVALID_USER
//
// MessageText:
//
//  Invalid user
//
#define PP_E_DELEGADMIN_INVALID_USER     ((HRESULT)0x80041B0DL)

//
// MessageId: PP_E_DELEGADMIN_INVALID_USER_ELE
//
// MessageText:
//
//  Invalid user element
//
#define PP_E_DELEGADMIN_INVALID_USER_ELE ((HRESULT)0x80041B0EL)

//
// MessageId: PP_E_DELEGADMIN_INVALID_PARAM
//
// MessageText:
//
//  Invalid parameter
//
#define PP_E_DELEGADMIN_INVALID_PARAM    ((HRESULT)0x80041B0FL)

//
// MessageId: PP_E_DELEGADMIN_NOT_NAMESPACE_PARTNER
//
// MessageText:
//
//  Not a namespace partner
//
#define PP_E_DELEGADMIN_NOT_NAMESPACE_PARTNER ((HRESULT)0x80041B10L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_SITEID
//
// MessageText:
//
//  Invalid site ID
//
#define PP_E_DELEGADMIN_INVALID_SITEID   ((HRESULT)0x80041B11L)

//
// MessageId: PP_E_DELEGADMIN_TICKET_EXPIRED
//
// MessageText:
//
//  Admin ticket has expired
//
#define PP_E_DELEGADMIN_TICKET_EXPIRED   ((HRESULT)0x80041B12L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_ENUM_TYPE
//
// MessageText:
//
//  Invalid enumeration type
//
#define PP_E_DELEGADMIN_INVALID_ENUM_TYPE ((HRESULT)0x80041B14L)

//
// MessageId: PP_E_DELEGADMIN_ALREADY_AN_ADMIN
//
// MessageText:
//
//  Already an admin
//
#define PP_E_DELEGADMIN_ALREADY_AN_ADMIN ((HRESULT)0x80041B15L)

//
// MessageId: PP_E_DELEGADMIN_LAST_ADMIN
//
// MessageText:
//
//  Can't delete last admin
//
#define PP_E_DELEGADMIN_LAST_ADMIN       ((HRESULT)0x80041B16L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_ADMIN
//
// MessageText:
//
//  Invalid admin
//
#define PP_E_DELEGADMIN_INVALID_ADMIN    ((HRESULT)0x80041B17L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_CRED_TYPE
//
// MessageText:
//
//  Invalid credential type
//
#define PP_E_DELEGADMIN_INVALID_CRED_TYPE ((HRESULT)0x80041B18L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_PASSWORD
//
// MessageText:
//
//  Invalid password
//
#define PP_E_DELEGADMIN_INVALID_PASSWORD ((HRESULT)0x80041B1BL)

//
// MessageId: PP_E_DELEGADMIN_INVALID_STATUS
//
// MessageText:
//
//  Invalid status
//
#define PP_E_DELEGADMIN_INVALID_STATUS   ((HRESULT)0x80041B20L)

//
// MessageId: PP_E_DELEGADMIN_CANTRELEASEINTERNAL
//
// MessageText:
//
//  Can not release internally managed domain
//
#define PP_E_DELEGADMIN_CANTRELEASEINTERNAL ((HRESULT)0x80041B21L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_OPTIONS_ELE
//
// MessageText:
//
//  Error in Options element
//
#define PP_E_DELEGADMIN_INVALID_OPTIONS_ELE ((HRESULT)0x80041B22L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_FIELDS_ELE
//
// MessageText:
//
//  Invalid Fields element
//
#define PP_E_DELEGADMIN_INVALID_FIELDS_ELE ((HRESULT)0x80041B23L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_CATEGORY
//
// MessageText:
//
//  Invalid or missing category
//
#define PP_E_DELEGADMIN_INVALID_CATEGORY ((HRESULT)0x80041B24L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_START_TIME
//
// MessageText:
//
//  Invalid or missing start date/time
//
#define PP_E_DELEGADMIN_INVALID_START_TIME ((HRESULT)0x80041B25L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_END_TIME
//
// MessageText:
//
//  Invalid or missing end date/time
//
#define PP_E_DELEGADMIN_INVALID_END_TIME ((HRESULT)0x80041B26L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_DA
//
// MessageText:
//
//  Invalid DA
//
#define PP_E_DELEGADMIN_INVALID_DA       ((HRESULT)0x80041B27L)

//
// MessageId: PP_E_DELEGADMIN_INVALID_MAXRECORDS
//
// MessageText:
//
//  Invalid maximum number of records
//
#define PP_E_DELEGADMIN_INVALID_MAXRECORDS ((HRESULT)0x80041B28L)

// base 0x1D00
//------------------------------------------------------------------------
// Profile Server error codes
//------------------------------------------------------------------------
//
// MessageId: PP_E_UPDATE_UPDATES_NOT_ALLOWED
//
// MessageText:
//
//  Partner not allowed to update protected field.
//
#define PP_E_UPDATE_UPDATES_NOT_ALLOWED  ((HRESULT)0x80041C00L)

//
// MessageId: PP_E_UPDATE_PARSER_NOTINITED
//
// MessageText:
//
//  Update parser was not initialized before use.
//
#define PP_E_UPDATE_PARSER_NOTINITED     ((HRESULT)0x80041B29L)

//
// MessageId: PP_E_UPDATE_DECRYPT_FAILED
//
// MessageText:
//
//  Update was unable to decrypt input.
//
#define PP_E_UPDATE_DECRYPT_FAILED       ((HRESULT)0x80041C01L)

//
// MessageId: PP_E_UPDATE_MULTIBYTECONVERSIONFAILED
//
// MessageText:
//
//  Update was unable to convert multi-byte input to wide char.
//
#define PP_E_UPDATE_MULTIBYTECONVERSIONFAILED ((HRESULT)0x80041C02L)

//
// MessageId: PP_E_UPDATE_UNABLETOGETPUID
//
// MessageText:
//
//  Update was unable to find a PUID for the provided user information.
//
#define PP_E_UPDATE_UNABLETOGETPUID      ((HRESULT)0x80041C03L)

#define PP_E_PROFILE_BASE 0x1D09
//
// MessageId: PP_E_KID_CANNOT_CHANGE_PROPERTY
//
// MessageText:
//
//  Child not allowed to change age-based policy dependent property.
//
#define PP_E_KID_CANNOT_CHANGE_PROPERTY  ((HRESULT)0x80041D09L)

//
// MessageId: PP_E_CCVALIDATIONFAILED
//
// MessageText:
//
//  Credit card validation failed.
//
#define PP_E_CCVALIDATIONFAILED          ((HRESULT)0x80041D0AL)

//
// MessageId: PP_E_PROFILEFLAGS_MISSING
//
// MessageText:
//
//  Passport Manager could not return the Profile flags.
//
#define PP_E_PROFILEFLAGS_MISSING        ((HRESULT)0x80041B2AL)

//
// MessageId: PP_E_XMLEDITPROF_FAILED
//
// MessageText:
//
//  XML Edit Profile failed due to validation errors.
//
#define PP_E_XMLEDITPROF_FAILED          ((HRESULT)0x80041D0BL)

//
// MessageId: PP_E_XMLREG_FAILED
//
// MessageText:
//
//  XML Registration failed.
//
#define PP_E_XMLREG_FAILED               ((HRESULT)0x80041B2BL)

//
// MessageId: PP_E_EMAILRESPONSE_ERROR
//
// MessageText:
//
//  The email response returned an error.
//
#define PP_E_EMAILRESPONSE_ERROR         ((HRESULT)0x80041B2CL)

//
// MessageId: PP_E_IsSiteIDValid_RETURN_INVALID
//
// MessageText:
//
//  IsSiteIDValid function returned an invalid result.
//
#define PP_E_IsSiteIDValid_RETURN_INVALID ((HRESULT)0x80041B2DL)

//
// MessageId: PP_E_dwAuxErr
//
// MessageText:
//
//  An error occurred during XML Registration.
//
#define PP_E_dwAuxErr                    ((HRESULT)0x80041B2EL)

//
// MessageId: PP_E_PROFILEVERSION_IS_EMPTY
//
// MessageText:
//
//  The setting for the Profile Version property is empty.
//
#define PP_E_PROFILEVERSION_IS_EMPTY     ((HRESULT)0x80041B2FL)

//
// MessageId: PP_E_COUNTRY_IS_NOTBSTR
//
// MessageText:
//
//  The profile property Country is set with an unexpected type.
//
#define PP_E_COUNTRY_IS_NOTBSTR          ((HRESULT)0x80041B30L)

//
// MessageId: PP_E_POSTALCODE_IS_NOTBSTR
//
// MessageText:
//
//  The profile property Postal Code is set with an unexpected type.
//
#define PP_E_POSTALCODE_IS_NOTBSTR       ((HRESULT)0x80041B31L)

//
// MessageId: PP_E_FIRSTNAME_IS_NOTBSTR
//
// MessageText:
//
//  The profile property First Name is set with an unexpected type.
//
#define PP_E_FIRSTNAME_IS_NOTBSTR        ((HRESULT)0x80041B32L)

//
// MessageId: PP_E_LASTNAME_IS_NOTBSTR
//
// MessageText:
//
//  The profile property Last Name is set with an unexpected type.
//
#define PP_E_LASTNAME_IS_NOTBSTR         ((HRESULT)0x80041B33L)

//
// MessageId: PP_E_OCCUPATION_IS_NOTBSTR
//
// MessageText:
//
//  The profile property Occupation is set with an unexpected type.
//
#define PP_E_OCCUPATION_IS_NOTBSTR       ((HRESULT)0x80041B34L)

//Profile
////#define PP_E_PROFILE_BASE 0x1D30
//
// MessageId: PP_E_PROF_GETREQUESTLOCALE_FAILED
//
// MessageText:
//
//  GetRequestLocale failed
//
#define PP_E_PROF_GETREQUESTLOCALE_FAILED ((HRESULT)0x80041D30L)

//
// MessageId: PP_E_PROF_GETDICTIONARY_FAILED
//
// MessageText:
//
//  GetDictionary failed
//
#define PP_E_PROF_GETDICTIONARY_FAILED   ((HRESULT)0x80041D31L)

//
// MessageId: PP_E_PROF_UNABLE_TO_GET_VALIDATOROBJECT
//
// MessageText:
//
//  GetValidatorObject failed
//
#define PP_E_PROF_UNABLE_TO_GET_VALIDATOROBJECT ((HRESULT)0x80041D32L)

//
// MessageId: PP_E_PROF_PCR_RELATIONSHIPID_NULL
//
// MessageText:
//
//  Parent-Child relationship ID is null
//
#define PP_E_PROF_PCR_RELATIONSHIPID_NULL ((HRESULT)0x80041D33L)

//
// MessageId: PP_E_PROF_GLOBALIZATION_DICTIONARY_IS_NULL
//
// MessageText:
//
//  GetDictionaryObject returned a Null pointer
//
#define PP_E_PROF_GLOBALIZATION_DICTIONARY_IS_NULL ((HRESULT)0x80041D34L)

//
// MessageId: PP_E_PROF_XMLEDITPROF_FAILED
//
// MessageText:
//
//  XML Edit profile failed
//
#define PP_E_PROF_XMLEDITPROF_FAILED     ((HRESULT)0x80041D35L)

//
// MessageId: PP_E_PROF_IsSiteIDValid_RETURN_INVALID
//
// MessageText:
//
//  Invalid site ID fallthrough case
//
#define PP_E_PROF_IsSiteIDValid_RETURN_INVALID ((HRESULT)0x80041D36L)

//
// MessageId: PP_E_PROF_PROFILEFLAGS_MISSING
//
// MessageText:
//
//  Profile flags missing
//
#define PP_E_PROF_PROFILEFLAGS_MISSING   ((HRESULT)0x80041D37L)

//
// MessageId: PP_E_PROF_EMAILRESPONSE_ERROR
//
// MessageText:
//
//  EmailResponse is returning S_FALSE, which is actually an error condition
//
#define PP_E_PROF_EMAILRESPONSE_ERROR    ((HRESULT)0x80041D38L)

//
// MessageId: PP_E_PROF_CCVALIDATIONFAILED
//
// MessageText:
//
//  Credit card validation failed
//
#define PP_E_PROF_CCVALIDATIONFAILED     ((HRESULT)0x80041D0CL)

//
// MessageId: PP_E_PROF_KID_CANNOT_CHANGE_PROPERTY
//
// MessageText:
//
//  Kid can not change property
//
#define PP_E_PROF_KID_CANNOT_CHANGE_PROPERTY ((HRESULT)0x80041D0DL)

//
// MessageId: PP_E_PROF_DELETEACCOUNTNOTALLOWED
//
// MessageText:
//
//  The account being closed has issues preventing it from being deleted.
//
#define PP_E_PROF_DELETEACCOUNTNOTALLOWED ((HRESULT)0x80041D39L)

//Registration
////#define PP_E_REG_BASE 0x7600
//
// MessageId: PP_E_REG_NO_STEPS_PRESENT
//
// MessageText:
//
//  No steps present
//
#define PP_E_REG_NO_STEPS_PRESENT        ((HRESULT)0x80047600L)

//
// MessageId: PP_E_REG_dwAuxErr
//
// MessageText:
//
//  XML Reg internal error
//
#define PP_E_REG_dwAuxErr                ((HRESULT)0x80047601L)

//
// MessageId: PP_E_REG_XMLREG_FAILED
//
// MessageText:
//
//  XML Reg failed
//
#define PP_E_REG_XMLREG_FAILED           ((HRESULT)0x80047602L)

//
// MessageId: PP_E_UPDATE_INVALID_BAMDATE
//
// MessageText:
//
//  Invalid bam date string passed to update server
//
#define PP_E_UPDATE_INVALID_BAMDATE      ((HRESULT)0x80047603L)

//
// MessageId: PP_E_MEMBERNAMEMALFORMED
//
// MessageText:
//
//  Membername is not in the expected format
//
#define PP_E_MEMBERNAMEMALFORMED         ((HRESULT)0x80047604L)

//
// MessageId: PP_E_MOBILEREGNOTPOST
//
// MessageText:
//
//  All requests to mobile reg must be posts
//
#define PP_E_MOBILEREGNOTPOST            ((HRESULT)0x80047605L)

// base 0x1E10
//
// MessageId: PP_E_PST_INVSEARCHTYPE
//
// MessageText:
//
//  Invalid search type
//
#define PP_E_PST_INVSEARCHTYPE           ((HRESULT)0x80047606L)

//
// MessageId: PP_E_PST_INVSIGNIN
//
// MessageText:
//
//  Invalid sign in
//
#define PP_E_PST_INVSIGNIN               ((HRESULT)0x80047607L)

//
// MessageId: PP_E_PST_INVPUID
//
// MessageText:
//
//  Invalid PUID
//
#define PP_E_PST_INVPUID                 ((HRESULT)0x80047608L)

//
// MessageId: PP_E_PST_SEARCH_ERR
//
// MessageText:
//
//  Search error
//
#define PP_E_PST_SEARCH_ERR              ((HRESULT)0x80047609L)

//
// MessageId: PP_E_PST_SEARCH_NOTFOUND
//
// MessageText:
//
//  Not found
//
#define PP_E_PST_SEARCH_NOTFOUND         ((HRESULT)0x8004760AL)

//
// MessageId: PP_E_PST_SEARCH_BADRESULTS
//
// MessageText:
//
//  Bad results from search
//
#define PP_E_PST_SEARCH_BADRESULTS       ((HRESULT)0x8004760BL)

//
// MessageId: PP_E_PST_INVTICKET
//
// MessageText:
//
//  Invalid ticket
//
#define PP_E_PST_INVTICKET               ((HRESULT)0x8004760CL)

//
// MessageId: PP_E_PST_INVDUALINPUT
//
// MessageText:
//
//  Dual input
//
#define PP_E_PST_INVDUALINPUT            ((HRESULT)0x8004760DL)

//
// MessageId: PP_E_PST_INVDUALEMPTY
//
// MessageText:
//
//  No input
//
#define PP_E_PST_INVDUALEMPTY            ((HRESULT)0x8004760EL)

//
// MessageId: PP_E_PST_DECLERR
//
// MessageText:
//
//  Declaration error
//
#define PP_E_PST_DECLERR                 ((HRESULT)0x8004760FL)

//
// MessageId: PP_E_PST_INVNAME
//
// MessageText:
//
//  Invalid name
//
#define PP_E_PST_INVNAME                 ((HRESULT)0x80047610L)

//
// MessageId: PP_E_PST_CSRSEARCH_BADRESULTS
//
// MessageText:
//
//  Bad results
//
#define PP_E_PST_CSRSEARCH_BADRESULTS    ((HRESULT)0x80047611L)

//
// MessageId: PP_E_PST_FINDCSR_EMPTY
//
// MessageText:
//
//  No CSRs
//
#define PP_E_PST_FINDCSR_EMPTY           ((HRESULT)0x80047612L)

//
// MessageId: PP_E_PST_NOHEADERFORCALL
//
// MessageText:
//
//  Missing Header
//
#define PP_E_PST_NOHEADERFORCALL         ((HRESULT)0x80047613L)

//
// MessageId: PP_E_PST_NOEXTPROF
//
// MessageText:
//
//  No Extended Profile
//
#define PP_E_PST_NOEXTPROF               ((HRESULT)0x80047614L)

//
// MessageId: PP_E_PST_NOROLE
//
// MessageText:
//
//  No Extended Profile
//
#define PP_E_PST_NOROLE                  ((HRESULT)0x80047615L)

//
// MessageId: PP_E_PST_INVCSRXML
//
// MessageText:
//
//  Invalid Query CSRs XML
//
#define PP_E_PST_INVCSRXML               ((HRESULT)0x80047616L)

//
// MessageId: PP_E_PST_INVMENUXML
//
// MessageText:
//
//  Invalid Menu XML
//
#define PP_E_PST_INVMENUXML              ((HRESULT)0x80047617L)

//
// MessageId: PP_E_PST_INVPROFXML
//
// MessageText:
//
//  Invalid Profile XML
//
#define PP_E_PST_INVPROFXML              ((HRESULT)0x80047618L)

//
// MessageId: PP_E_PST_INVEXTPROFXML
//
// MessageText:
//
//  Invalid CSR Ext Profile XML
//
#define PP_E_PST_INVEXTPROFXML           ((HRESULT)0x80047619L)

//
// MessageId: PP_E_PST_INVCREDXML
//
// MessageText:
//
//  Invalid Credentials XML
//
#define PP_E_PST_INVCREDXML              ((HRESULT)0x8004761AL)

//
// MessageId: PP_E_PST_INVRELSXML
//
// MessageText:
//
//  Invalid Relationships (internally generated) XML
//
#define PP_E_PST_INVRELSXML              ((HRESULT)0x8004761BL)

//
// MessageId: PP_E_PST_INVKCONSXML
//
// MessageText:
//
//  Invalid Per site consent XML
//
#define PP_E_PST_INVKCONSXML             ((HRESULT)0x8004761CL)

//
// MessageId: PP_E_PST_INVFTCONSXML
//
// MessageText:
//
//  Invalid Per policy group consent XML
//
#define PP_E_PST_INVFTCONSXML            ((HRESULT)0x8004761DL)

//
// MessageId: PP_E_PST_INVINTXML
//
// MessageText:
//
//  Invalid Intention XML
//
#define PP_E_PST_INVINTXML               ((HRESULT)0x8004761EL)

//
// MessageId: PP_E_PST_INVAUTHZXML
//
// MessageText:
//
//  Invalid AuthZ XML
//
#define PP_E_PST_INVAUTHZXML             ((HRESULT)0x8004761FL)

//
// MessageId: PP_E_PST_INVEVALAUTHZXML
//
// MessageText:
//
//  Invalid EvalAuthZ XML
//
#define PP_E_PST_INVEVALAUTHZXML         ((HRESULT)0x80047620L)

//
// MessageId: PP_E_PST_INVROLELISTXML
//
// MessageText:
//
//  Invalid RoleList XML
//
#define PP_E_PST_INVROLELISTXML          ((HRESULT)0x80047621L)

//
// MessageId: PP_E_PST_INVFIELDONLYREPORTXML
//
// MessageText:
//
//  Invalid Field only report XML
//
#define PP_E_PST_INVFIELDONLYREPORTXML   ((HRESULT)0x80047622L)

//
// MessageId: PP_E_PST_INVCREDRENAMEREPORTXML
//
// MessageText:
//
//  Invalid Credential rename report XML
//
#define PP_E_PST_INVCREDRENAMEREPORTXML  ((HRESULT)0x80047623L)

//
// MessageId: PP_E_PST_INVATTRONLYREPORTXML
//
// MessageText:
//
//  Invalid Attribute only report XML
//
#define PP_E_PST_INVATTRONLYREPORTXML    ((HRESULT)0x80047624L)

//
// MessageId: PP_E_PST_INVCERTXML
//
// MessageText:
//
//  Invalid Certificates XML
//
#define PP_E_PST_INVCERTXML              ((HRESULT)0x80047625L)

//
// MessageId: PP_E_PST_INVCLOGREPORTXML
//
// MessageText:
//
//  Invalid CLog report XML
//
#define PP_E_PST_INVCLOGREPORTXML        ((HRESULT)0x80047626L)

//
// MessageId: PP_E_PST_INVPUID2SIXML
//
// MessageText:
//
//  Invalid PUID to SignIn XML
//
#define PP_E_PST_INVPUID2SIXML           ((HRESULT)0x80047627L)

//
// MessageId: PP_E_PST_INVPROFFAILXML
//
// MessageText:
//
//  Invalid Profile failures XML
//
#define PP_E_PST_INVPROFFAILXML          ((HRESULT)0x80047628L)

//
// MessageId: PP_E_PST_INVSOAPFAILXML
//
// MessageText:
//
//  Invalid SOAP failure XML
//
#define PP_E_PST_INVSOAPFAILXML          ((HRESULT)0x80047629L)

//
// MessageId: PP_E_PST_PARTNERXMLLOOKUPFAILED
//
// MessageText:
//
//  Unable to look up URL in Partner XML
//
#define PP_E_PST_PARTNERXMLLOOKUPFAILED  ((HRESULT)0x8004762AL)

//
// MessageId: PP_E_PST_NOPPTICKET
//
// MessageText:
//
//  No passport Ticket information available to put into the request
//
#define PP_E_PST_NOPPTICKET              ((HRESULT)0x8004762BL)

// base 0x1f00
// Errors
#define PP_E_MSPPEXT_BASE  0x1F00
//
// MessageId: PP_E_MSPPEXT_GETEXTVERSION_FAILED
//
// MessageText:
//
//  The web service has failed during initialization of the ISAPI extension. Threads and memory are initialized during this time.
//
#define PP_E_MSPPEXT_GETEXTVERSION_FAILED ((HRESULT)0x80041F00L)

//
// MessageId: PP_E_MSPPEXT_GETENV_FAILED
//
// MessageText:
//
//  The config.ini file used by the web service does not have an "environment" section.
//
#define PP_E_MSPPEXT_GETENV_FAILED       ((HRESULT)0x80041F01L)

//
// MessageId: PP_E_MSPPEXT_SET_EVENT_FAILED
//
// MessageText:
//
//  The web service has failed during initialization: it has failed to set the event to mark the start of execution.
//
#define PP_E_MSPPEXT_SET_EVENT_FAILED    ((HRESULT)0x80041F02L)

//
// MessageId: PP_E_MSPPEXT_INIT_UPDATEMGR_FAILED
//
// MessageText:
//
//  The web service has failed during initialization: it has failed to initialize the live prop component.
//
#define PP_E_MSPPEXT_INIT_UPDATEMGR_FAILED ((HRESULT)0x80041F03L)

//
// MessageId: PP_E_MSPPEXT_INIT_EVENT_FAILED
//
// MessageText:
//
//  The web service has failed during initialization: it has failed to reset the events to mark the reload of COM components.
//
#define PP_E_MSPPEXT_INIT_EVENT_FAILED   ((HRESULT)0x80041F04L)

//
// MessageId: PP_E_MSPPEXT_CREATE_THREAD_FAILED
//
// MessageText:
//
//  The web service has failed during initialization: it has failed to create the thread that CoInitialize, loads all the COM components and waits for shutdown.
//
#define PP_E_MSPPEXT_CREATE_THREAD_FAILED ((HRESULT)0x80041F05L)

//
// MessageId: PP_E_MSPPEXT_WAIT_EVENT_FAILED
//
// MessageText:
//
//  The web service has failed during initialization: the Initialize thread has either failed on a wait for services to load, or at least one service has failed to load.
//
#define PP_E_MSPPEXT_WAIT_EVENT_FAILED   ((HRESULT)0x80041F06L)

//
// MessageId: PP_E_MSPPEXT_SERVICE_NOT_LOADED
//
// MessageText:
//
//  The queried service or interface is not among the loaded services (i.e., COM components.)
//
#define PP_E_MSPPEXT_SERVICE_NOT_LOADED  ((HRESULT)0x80041F08L)

//
// MessageId: PP_E_MSPPEXT_SERVICEMGR_PATH_NOTFOUND
//
// MessageText:
//
//  The web service has failed during initialization: it has failed to get its ADS path.
//
#define PP_E_MSPPEXT_SERVICEMGR_PATH_NOTFOUND ((HRESULT)0x80041F0CL)

// base 0x2200
//
// MessageId: PP_E_MEMMGR_HEAPCREATE
//
// MessageText:
//
//  The memory manager failed to create a heap.
//
#define PP_E_MEMMGR_HEAPCREATE           ((HRESULT)0x80042200L)

//
// MessageId: PP_E_MEMMGR_SETTLSVALUE
//
// MessageText:
//
//  The memory manager failed to set the TLS with the heap object pointer.
//
#define PP_E_MEMMGR_SETTLSVALUE          ((HRESULT)0x80042202L)

//
// MessageId: PP_E_MEMMGR_BADTLS
//
// MessageText:
//
//  The memory manager failed to set the TLS with -1 to mark it as bad.
//
#define PP_E_MEMMGR_BADTLS               ((HRESULT)0x80042203L)

//
// MessageId: PP_E_MEMMGR_INIT_ALREADY
//
// MessageText:
//
//  The memory manager was initialized previously.
//
#define PP_E_MEMMGR_INIT_ALREADY         ((HRESULT)0x80042204L)

//
// MessageId: PP_E_MEMMGR_THREADHEAPCREATE
//
// MessageText:
//
//  The memory manager failed to allocate memory for the CThreadHeap object.
//
#define PP_E_MEMMGR_THREADHEAPCREATE     ((HRESULT)0x80042205L)

//
// MessageId: PP_E_MEMMGR_INIT_SETTLS
//
// MessageText:
//
//  The memory manager failed to initalize the TLS.
//
#define PP_E_MEMMGR_INIT_SETTLS          ((HRESULT)0x80042206L)

//
// MessageId: PP_E_MEMMGR_PPHEAPCREATE
//
// MessageText:
//
//  The memory manager failed to allocate memory for CPPHeap object.
//
#define PP_E_MEMMGR_PPHEAPCREATE         ((HRESULT)0x80042207L)

//
// MessageId: PP_E_MEMMGR_FINISH_TLS
//
// MessageText:
//
//  The memory manager failed to zero out the TLS.
//
#define PP_E_MEMMGR_FINISH_TLS           ((HRESULT)0x8004220BL)

//
// MessageId: PP_E_MEMMGR_NOTINITIALIZED
//
// MessageText:
//
//  The memory manager is called without being initialized.
//
#define PP_E_MEMMGR_NOTINITIALIZED       ((HRESULT)0x8004220CL)

//
// MessageId: PP_E_MEMMGR_FINISH
//
// MessageText:
//
//  No TLS value was found at the end of a request.
//
#define PP_E_MEMMGR_FINISH               ((HRESULT)0x8004220DL)

//
// MessageId: PP_E_MEMMGR_FINISH_NOTLS
//
// MessageText:
//
//  The TLS value for this thread does not hold a pointer to a CPPHeap object.
//
#define PP_E_MEMMGR_FINISH_NOTLS         ((HRESULT)0x8004220EL)

// base 0x2500
//
// MessageId: PP_E_SOAP_XMLDOC
//
// MessageText:
//
//  The XML document is invalid
//
#define PP_E_SOAP_XMLDOC                 ((HRESULT)0x80042500L)

//
// MessageId: PP_E_SOAP_ENV
//
// MessageText:
//
//  The soap envelope is invalid
//
#define PP_E_SOAP_ENV                    ((HRESULT)0x80042501L)

//
// MessageId: PP_E_SOAP_BODY
//
// MessageText:
//
//  The soap body is invalid
//
#define PP_E_SOAP_BODY                   ((HRESULT)0x80042502L)

//
// MessageId: PP_E_SOAP_METHOD
//
// MessageText:
//
//  No soap method found
//
#define PP_E_SOAP_METHOD                 ((HRESULT)0x80042503L)

//
// MessageId: PP_E_SOAP_FAULT
//
// MessageText:
//
//  The response contains a soap fault
//
#define PP_E_SOAP_FAULT                  ((HRESULT)0x80042504L)

// base 0x2600
//
// MessageId: PP_E_SCHEMA_ELE
//
// MessageText:
//
//  Returned when the number of attributes in the profile or ticket schema is 0.
//
#define PP_E_SCHEMA_ELE                  ((HRESULT)0x80042600L)

//
// MessageId: PP_E_SCHEMA_DATATYPE
//
// MessageText:
//
//  Schema has an invalid datatype for one of the attributes.
//
#define PP_E_SCHEMA_DATATYPE             ((HRESULT)0x80042601L)

// base 0x2900
//
// MessageId: PP_E_CRYPT_DECRYPT
//
// MessageText:
//
//  Failed to decrypt Key.
//
#define PP_E_CRYPT_DECRYPT               ((HRESULT)0x80042900L)

//
// MessageId: PP_E_CRYPT_KEYSIZE
//
// MessageText:
//
//  The key has incorrect size.
//
#define PP_E_CRYPT_KEYSIZE               ((HRESULT)0x80042901L)

//
// MessageId: PP_E_KEYINSTALL_NODCOM
//
// MessageText:
//
//  DCOM is not enabled on the machine.
//
#define PP_E_KEYINSTALL_NODCOM           ((HRESULT)0x80042902L)

//
// MessageId: PP_E_CRYPT_ENCRYPT
//
// MessageText:
//
//  Failed to encrypt.
//
#define PP_E_CRYPT_ENCRYPT               ((HRESULT)0x80042903L)

//
// MessageId: PP_E_CRYPT_DATATOOLARGE
//
// MessageText:
//
//  Data is too large for encryption or decryption.
//
#define PP_E_CRYPT_DATATOOLARGE          ((HRESULT)0x80042904L)

//
// MessageId: PP_E_CRYPT_BADKV
//
// MessageText:
//
//  Key cannot be found, could be an invalid key version.
//
#define PP_E_CRYPT_BADKV                 ((HRESULT)0x80042905L)

//
// MessageId: PP_E_CRYPT_NOKEY
//
// MessageText:
//
//  Registry Key KeyData is missing.
//
#define PP_E_CRYPT_NOKEY                 ((HRESULT)0x80042906L)

//
// MessageId: PP_E_PPCRYPT_FAILED
//
// MessageText:
//
//  Failed to encrypt/decrypt crypto key.
//
#define PP_E_PPCRYPT_FAILED              ((HRESULT)0x80043100L)

//
// MessageId: PP_E_SESSIONKEY_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object has already been initialized.
//
#define PP_E_SESSIONKEY_ALREADY_INITIALIZED ((HRESULT)0x80043101L)

//
// MessageId: PP_E_SESSIONKEY_NOT_INITIALIZED
//
// MessageText:
//
//  The object has not been initialized.
//
#define PP_E_SESSIONKEY_NOT_INITIALIZED  ((HRESULT)0x80043102L)

//
// MessageId: PP_E_SESSIONKEY_INVALIDDATA
//
// MessageText:
//
//  The data is invalid.
//
#define PP_E_SESSIONKEY_INVALIDDATA      ((HRESULT)0x80043103L)

//
// MessageId: PP_E_SESSIONKEY_INVALIDSIGNATURE
//
// MessageText:
//
//  The hash doesn't match.
//
#define PP_E_SESSIONKEY_INVALIDSIGNATURE ((HRESULT)0x80043104L)

// base 0x3201
// webstore errors, from wststoreidl.idl, inca build
// these first three are from original file, legacy.
// the facility used is Internal.
//
// MessageId: PP_E_WSTORE_CheckOLEDBVersion
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WSTORE_CheckOLEDBVersion    ((HRESULT)0x80043201L)

//
// MessageId: PP_E_WSTORE_GetNewAccountIDByPadding
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WSTORE_GetNewAccountIDByPadding ((HRESULT)0x80043202L)

//
// MessageId: PP_E_WSTORE__FetchNewBlock
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WSTORE__FetchNewBlock       ((HRESULT)0x80043203L)

// 3.0m2, PP version of webstore errors, 
// using passport database facility code
//#define WST_E_CONNECTIONTIMEOUT      ((HRESULT)-2001) // 0xFFFFF82F
//
// MessageId: PP_E_WST_E_CONNECTIONTIMEOUT
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_CONNECTIONTIMEOUT     ((HRESULT)0xCFFFF82FL)

//#define WST_E_NOCONNECTIONAVAIL      ((HRESULT)-2002) // 0xFFFFF82E
//
// MessageId: PP_E_WST_E_NOCONNECTIONAVAIL
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_NOCONNECTIONAVAIL     ((HRESULT)0xCFFFF82EL)

//#define WST_E_MARKEDOFFLINE          ((HRESULT)-2005) // 0xFFFFF82B
//
// MessageId: PP_E_WST_E_MARKEDOFFLINE
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_MARKEDOFFLINE         ((HRESULT)0xCFFFF82BL)

//#define WST_E_MARKEDREADONLY         ((HRESULT)-2006) // 0xFFFFF82A
//
// MessageId: PP_E_WST_E_MARKEDREADONLY
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_MARKEDREADONLY        ((HRESULT)0xCFFFF82AL)

//#define kErrorWstTimeOutNoFailover           -2008 // 0xFFFFF828
//
// MessageId: PP_E_kErrorWstTimeOutNoFailover
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_kErrorWstTimeOutNoFailover  ((HRESULT)0xCFFFF828L)

//#define kErrorWstCmdOrConnectionFailed      -2009 // 0xFFFFF827
//
// MessageId: PP_E_kErrorWstCmdOrConnectionFailed
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_kErrorWstCmdOrConnectionFailed ((HRESULT)0xCFFFF827L)

// webstore error
//#define WST_E_SERVERNOTREGISTERED    ((HRESULT)-2027) // 0xFFFFF815
//
// MessageId: PP_E_WST_E_SERVERNOTREGISTERED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_SERVERNOTREGISTERED   ((HRESULT)0xCFFFF815L)

//
// MessageId: PP_E_WST_E_APPLICATIONNOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_APPLICATIONNOTEXIST   ((HRESULT)0xCFFFF447L)

//#define WST_E_TRANCOUNTEXIST         ((HRESULT)-3002) // 0xFFFFF446
//
// MessageId: PP_E_WST_E_TRANCOUNTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_TRANCOUNTEXIST        ((HRESULT)0xCFFFF446L)

//#define WST_E_ADMINCONSOLENOTEXIST   ((HRESULT)-3003) // 0xFFFFF445
//
// MessageId: PP_E_WST_E_ADMINCONSOLENOTEXIST
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_ADMINCONSOLENOTEXIST  ((HRESULT)0xCFFFF445L)

//#define WST_E_MISMATCHVERSION        ((HRESULT)-3004) // 0xFFFFF444
//
// MessageId: PP_E_WST_E_MISMATCHVERSION
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_MISMATCHVERSION       ((HRESULT)0xCFFFF444L)

// #define WST_E_NOSERVICEAVAIL         ((HRESULT)-3005) // 0xFFFFF443
//
// MessageId: PP_E_WST_E_NOSERVICEAVAIL
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_NOSERVICEAVAIL        ((HRESULT)0xCFFFF443L)

// #define WST_E_NOREGISTRY             ((HRESULT)-3006) // 0xFFFFF442
//
// MessageId: PP_E_WST_E_NOREGISTRY
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_NOREGISTRY            ((HRESULT)0xCFFFF442L)

// #define WST_E_APPCONFIGCHANGED       ((HRESULT)-3007) // 0xFFFFF441
//
// MessageId: PP_E_WST_E_APPCONFIGCHANGED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_APPCONFIGCHANGED      ((HRESULT)0xCFFFF441L)

// #define WST_E_NAMEDPIPE              ((HRESULT)-3008) // 0xFFFFF440
//
// MessageId: PP_E_WST_E_NAMEDPIPE
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_NAMEDPIPE             ((HRESULT)0xCFFFF440L)

// #define WST_E_NOTINITIALIZED         ((HRESULT)-3009) // 0xFFFFF43F
//
// MessageId: PP_E_WST_E_NOTINITIALIZED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_NOTINITIALIZED        ((HRESULT)0xCFFFF43FL)

// #define WST_E_BADTICKET              ((HRESULT)-3010) // 0xFFFFF43E
//
// MessageId: PP_E_WST_E_BADTICKET
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_BADTICKET             ((HRESULT)0xCFFFF43EL)

// #define WST_E_ALREADYINITIALIZED     ((HRESULT)-3011) // 0xFFFFF43D
//
// MessageId: PP_E_WST_E_ALREADYINITIALIZED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_ALREADYINITIALIZED    ((HRESULT)0xCFFFF43DL)

// #define WST_E_CONFIGEXPIRED          ((HRESULT)-3012) // 0xFFFFF43C
//
// MessageId: PP_E_WST_E_CONFIGEXPIRED
//
// MessageText:
//
//  Service temporarily unavailable due to internal Database error (hr=%1), please try later.
//
#define PP_E_WST_E_CONFIGEXPIRED         ((HRESULT)0xCFFFF43CL)

// base 0x3684
//
// MessageId: PP_E_SETUP_KEYMIG_ERROR
//
// MessageText:
//
//  Could not migrate passport manager key to new version. Please update the key in the registry manually.
//
#define PP_E_SETUP_KEYMIG_ERROR          ((HRESULT)0x80043684L)

// base 0x3801
//
// MessageId: PP_E_KEYMIG_MAPREAD
//
// MessageText:
//
//  Failed to import networkserver.xml to nexus db (2.5 only)
//
#define PP_E_KEYMIG_MAPREAD              ((HRESULT)0x80043801L)

//
// MessageId: PP_E_KEYMIG_DECRYPTKEY
//
// MessageText:
//
//  Failed to decrypt nexus site key for key export (2.5 only)
//
#define PP_E_KEYMIG_DECRYPTKEY           ((HRESULT)0x80043802L)

//
// MessageId: PP_E_KEYMIG_LOADDOC
//
// MessageText:
//
//  Failed to open xml file for import (2.5 only)
//
#define PP_E_KEYMIG_LOADDOC              ((HRESULT)0x80043803L)

//
// MessageId: PP_E_KEYMIG_SITELIST
//
// MessageText:
//
//  No kid site in the site list (2.5 only)
//
#define PP_E_KEYMIG_SITELIST             ((HRESULT)0x80043804L)

//
// MessageId: PP_E_LOADNAMESPACE
//
// MessageText:
//
//  Failed to load xml (Gerneric error used by multiple obj?)
//
#define PP_E_LOADNAMESPACE               ((HRESULT)0x80043805L)

//
// MessageId: PP_E_SITEMGR
//
// MessageText:
//
//  Generic error for parsing ns xml. (2.5 only)
//
#define PP_E_SITEMGR                     ((HRESULT)0x80043806L)

//
// MessageId: PP_E_MODIFYANTIHACKPARAM
//
// MessageText:
//
//  AntihackerTuner tool. Generic xml error.
//
#define PP_E_MODIFYANTIHACKPARAM         ((HRESULT)0x80043809L)

//
// MessageId: PP_E_SITEMGR_SITE_EXCLUDED
//
// MessageText:
//
//  Provisioning. The given site id is not allow to modify.
//
#define PP_E_SITEMGR_SITE_EXCLUDED       ((HRESULT)0x8004380AL)

//
// MessageId: PP_E_SITEMGR_SITE_NOT_EXIST
//
// MessageText:
//
//  Provisioning. Try to modify site key with a non existing site id.
//
#define PP_E_SITEMGR_SITE_NOT_EXIST      ((HRESULT)0x8004380BL)

//
// MessageId: PP_E_SITEMGR_NESTED_ROOT
//
// MessageText:
//
//  Provisioning. Try to crete nested root share key. Only single level share root is allowed.
//
#define PP_E_SITEMGR_NESTED_ROOT         ((HRESULT)0x8004380CL)

//
// MessageId: PP_E_SITEMGR_UNSHARED_ROOT
//
// MessageText:
//
//  Provisioning. Try to unshare site key with the root site, but site does not has root id.
//
#define PP_E_SITEMGR_UNSHARED_ROOT       ((HRESULT)0x8004380DL)

//
// MessageId: PP_E_SITEMGR_SITE_HAS_ROOT
//
// MessageText:
//
//  Provisioning. Beacuse this site has root site id it's not allow to modify site key.
//
#define PP_E_SITEMGR_SITE_HAS_ROOT       ((HRESULT)0x8004380EL)

//
// MessageId: PP_E_LOADSERVERFROMFILE_GENERAL_ERROR
//
// MessageText:
//
//  Refresh util. Failed to load server file.
//
#define PP_E_LOADSERVERFROMFILE_GENERAL_ERROR ((HRESULT)0x8004380FL)

//
// MessageId: PP_E_LOADCONFIG_GENERAL_ERROR
//
// MessageText:
//
//  Refresh util. Failed to load configuation file.
//
#define PP_E_LOADCONFIG_GENERAL_ERROR    ((HRESULT)0x80043810L)

//
// MessageId: PP_E_LOADXML_GENERAL_ERROR
//
// MessageText:
//
//  Refresh util. Failed to load xml.
//
#define PP_E_LOADXML_GENERAL_ERROR       ((HRESULT)0x80043811L)

//
// MessageId: PP_E_LOADREFRESHCONFIG_GENERAL_ERROR
//
// MessageText:
//
//  Refresh util. Failed to load configuation file.
//
#define PP_E_LOADREFRESHCONFIG_GENERAL_ERROR ((HRESULT)0x80043812L)

// base 0x3901
//
// MessageId: PP_E_MD_INVALIDLOCATION
//
// MessageText:
//
//  Minidump location path in registry or INI file is missing or invalid (longer than MAX_PATH).
//
#define PP_E_MD_INVALIDLOCATION          ((HRESULT)0x80043901L)

//
// MessageId: PP_E_MD_INVALIDPREFIX
//
// MessageText:
//
//  Minidump prefix in INI file is missing or invalid (longer than MAX_PATH).
//
#define PP_E_MD_INVALIDPREFIX            ((HRESULT)0x80043902L)

//
// MessageId: PP_E_MD_INVALIDDUMPTYPE
//
// MessageText:
//
//  Minidump type in INI file is missing or invalid (Valid values are 0,1,2,4,8,16).
//
#define PP_E_MD_INVALIDDUMPTYPE          ((HRESULT)0x80043903L)

//
// MessageId: PP_E_MD_FAILTOCREATEFILE
//
// MessageText:
//
//  Failed to create the minidump file. Check the event log for error code.
//
#define PP_E_MD_FAILTOCREATEFILE         ((HRESULT)0x80043904L)

//
// MessageId: PP_E_MD_FAILTOWRITEDUMP
//
// MessageText:
//
//  Failed to write the minidump file. Check the event log for error code.
//
#define PP_E_MD_FAILTOWRITEDUMP          ((HRESULT)0x80043905L)

//
// MessageId: PP_E_MD_LOADLIB
//
// MessageText:
//
//  Failed to load the dbghelp DLL (Either ppdbghelp.dll or dbghelp.dll).
//
#define PP_E_MD_LOADLIB                  ((HRESULT)0x80043906L)

//
// MessageId: PP_E_MD_GETPROC
//
// MessageText:
//
//  Failed to get the address of MiniDumpWriteDump function from the DLL.
//
#define PP_E_MD_GETPROC                  ((HRESULT)0x80043907L)

//
// MessageId: PP_E_MD_NOTINIT
//
// MessageText:
//
//  Minidump not initialized.
//
#define PP_E_MD_NOTINIT                  ((HRESULT)0x80043908L)

// base 0x3a00
//
// MessageId: PP_E_RADIUS_INVALIDCONFIG
//
// MessageText:
//
//  Invalid Radius Configuration.
//
#define PP_E_RADIUS_INVALIDCONFIG        ((HRESULT)0x80043A02L)

//
// MessageId: PP_E_RADIUS_GETENV_FAILED
//
// MessageText:
//
//  Failed to Get environment settings in config.
//
#define PP_E_RADIUS_GETENV_FAILED        ((HRESULT)0x80043A03L)

//
// MessageId: PP_E_RADIUS_ATTRNOTFOUND
//
// MessageText:
//
//  Missing Radius Attribute in request.
//
#define PP_E_RADIUS_ATTRNOTFOUND         ((HRESULT)0x80043A09L)

//
// MessageId: PP_E_RADIUS_ATTRTYPEMISMATCH
//
// MessageText:
//
//  Attribute type mismatch.
//
#define PP_E_RADIUS_ATTRTYPEMISMATCH     ((HRESULT)0x80043A0AL)

//
// MessageId: PP_E_RADIUS_PSAINITFAILED
//
// MessageText:
//
//  PSA initilization failed.
//
#define PP_E_RADIUS_PSAINITFAILED        ((HRESULT)0x80043A0BL)

//
// MessageId: PP_E_RADIUS_UNINITIALIZE
//
// MessageText:
//
//  Failed to unitialize Radius.
//
#define PP_E_RADIUS_UNINITIALIZE         ((HRESULT)0x80043A0CL)

//
// MessageId: PP_E_RADIUS_INVALID_DOMAIN
//
// MessageText:
//
//  The user domain is not valid.
//
#define PP_E_RADIUS_INVALID_DOMAIN       ((HRESULT)0x80043A0EL)

//
// MessageId: PP_E_RADIUS_INVALID_ATTRIBUTE_SIZE
//
// MessageText:
//
//  The attribute is either too large or too small.
//
#define PP_E_RADIUS_INVALID_ATTRIBUTE_SIZE ((HRESULT)0x80043A0FL)

//
// MessageId: PP_E_RADIUS_INVALID_ATTRIBUTE
//
// MessageText:
//
//  Invalid Radius attributes.
//
#define PP_E_RADIUS_INVALID_ATTRIBUTE    ((HRESULT)0x80043A10L)

//
// MessageId: PP_E_RADIUS_INVALID_AUTHMETHOD
//
// MessageText:
//
//  Authentication method is not allowed for the site.
//
#define PP_E_RADIUS_INVALID_AUTHMETHOD   ((HRESULT)0x80043A12L)

//
// MessageId: PP_E_RADIUS_INVALID_PACKET
//
// MessageText:
//
//  Invalid Radius Packet.
//
#define PP_E_RADIUS_INVALID_PACKET       ((HRESULT)0x80043A13L)

//
// MessageId: PP_E_RADIUS_CRP_NULL_SERVICE
//
// MessageText:
//
//  Cannot access service object in SDO.
//
#define PP_E_RADIUS_CRP_NULL_SERVICE     ((HRESULT)0x80043A14L)

//
// MessageId: PP_E_RADIUS_CRP_NULL_DICTIONARY
//
// MessageText:
//
//  Cannot access directory object in SDO.
//
#define PP_E_RADIUS_CRP_NULL_DICTIONARY  ((HRESULT)0x80043A15L)

//
// MessageId: PP_E_RADIUS_CREATEATTR_BADARG
//
// MessageText:
//
//  Invalid Attribute for SDO.
//
#define PP_E_RADIUS_CREATEATTR_BADARG    ((HRESULT)0x80043A16L)

//
// MessageId: PP_E_RADIUS_CCM_NOTIFY_SINK_ALREADY_SET
//
// MessageText:
//
//  Radius CCM change notification sink was already setup.
//
#define PP_E_RADIUS_CCM_NOTIFY_SINK_ALREADY_SET ((HRESULT)0x80043A19L)

//
// MessageId: PP_E_RADIUS_CCM_NOTIFY_SINK_NOT_SET
//
// MessageText:
//
//  Radius CCM change notification sink has not been setup.
//
#define PP_E_RADIUS_CCM_NOTIFY_SINK_NOT_SET ((HRESULT)0x80043A1AL)

// base 0x4000
//relationship server error code
//#define PP_E_SOAPSERVICE_BASE                0x4000
//
// MessageId: PP_E_CERTPROV_INSTALLSTS_NO_CONTEXT
//
// MessageText:
//
//  The service failed to retrieve the certificate context for the Passport login server.
//
#define PP_E_CERTPROV_INSTALLSTS_NO_CONTEXT ((HRESULT)0x80044006L)

//
// MessageId: PP_E_SS_INVALIDSCHEMA
//
// MessageText:
//
//  The application contains invalid schema. For information about valid schema formats, see the WSDL documents.
//
#define PP_E_SS_INVALIDSCHEMA            ((HRESULT)0x80044007L)

//
// MessageId: PP_E_SS_SCHEMA_NOTFOUND
//
// MessageText:
//
//  The service cannot use the schema specified in the application. For information about valid schema formats, see the WSDL documents.
//
#define PP_E_SS_SCHEMA_NOTFOUND          ((HRESULT)0x80044008L)

//
// MessageId: PP_E_SS_SCHEMA_NOTINITIALISED
//
// MessageText:
//
//  The service was unable to initialize the schema in the request.
//
#define PP_E_SS_SCHEMA_NOTINITIALISED    ((HRESULT)0x80044009L)

//
// MessageId: PP_E_SS_NODATA
//
// MessageText:
//
//  The input data is empty
//
#define PP_E_SS_NODATA                   ((HRESULT)0x8004400AL)

//
// MessageId: PP_E_SS_MISCONFIGURED
//
// MessageText:
//
//  Internal error: the soap service is misconfigured
//
#define PP_E_SS_MISCONFIGURED            ((HRESULT)0x8004400DL)

//
// MessageId: PP_E_SS_TICKETFIELDMISSING
//
// MessageText:
//
//  The credential field does not contain any data.
//
#define PP_E_SS_TICKETFIELDMISSING       ((HRESULT)0x8004400EL)

//
// MessageId: PP_E_SS_CRYPTOBJECTEMPTY
//
// MessageText:
//
//  The service cannot decrypt the credential specified in the request.
//
#define PP_E_SS_CRYPTOBJECTEMPTY         ((HRESULT)0x8004400FL)

//
// MessageId: PP_E_SS_INVALIDPUID
//
// MessageText:
//
//  The application attempted to reference an invalid .NET Passport unique identifier (PUID).
//
#define PP_E_SS_INVALIDPUID              ((HRESULT)0x80044010L)

//
// MessageId: PP_E_SS_INVALIDNAMESPACE
//
// MessageText:
//
//  The application attempted to reference an invalid namespace.
//
#define PP_E_SS_INVALIDNAMESPACE         ((HRESULT)0x80044011L)

//
// MessageId: PP_E_SS_HEADERTOOLARGE
//
// MessageText:
//
//  The request header exceeds the maximum size allowed. For more information, see the WSDL documents.
//
#define PP_E_SS_HEADERTOOLARGE           ((HRESULT)0x80044012L)

//
// MessageId: PP_E_SS_INVALIDHEADERVERSION
//
// MessageText:
//
//  The request header version is invalid. For more information, see the WSDL documents.
//
#define PP_E_SS_INVALIDHEADERVERSION     ((HRESULT)0x80044013L)

//
// MessageId: PP_E_SS_INVALIDHEADERNAMESPACE
//
// MessageText:
//
//  The request header does not contain a namespace. For more information, see the WSDL documents.
//
#define PP_E_SS_INVALIDHEADERNAMESPACE   ((HRESULT)0x80044014L)

//
// MessageId: PP_E_SS_REQUIREDNODEMISSING
//
// MessageText:
//
//  One or more required nodes are missing. For more information, see the WSDL documents.
//
#define PP_E_SS_REQUIREDNODEMISSING      ((HRESULT)0x80044016L)

//
// MessageId: PP_E_SS_NAMESPACEMISSING
//
// MessageText:
//
//  The request does not contain a namespace. For more information, see the WSDL documents.
//
#define PP_E_SS_NAMESPACEMISSING         ((HRESULT)0x80044017L)

//
// MessageId: PP_E_SS_INVALIDNUMERIC
//
// MessageText:
//
//  The application attempted to reference an invalid numeric value. For more information, see the WSDL documents.
//
#define PP_E_SS_INVALIDNUMERIC           ((HRESULT)0x80044018L)

//
// MessageId: PP_E_SS_INVALIDSITEID
//
// MessageText:
//
//  The application specified an invalid site identifier (SiteID).
//
#define PP_E_SS_INVALIDSITEID            ((HRESULT)0x80044019L)

//
// MessageId: PP_E_SS_INVALIDSTATUS
//
// MessageText:
//
//  The application specified an invalid status field value.
//
#define PP_E_SS_INVALIDSTATUS            ((HRESULT)0x8004401AL)

//
// MessageId: PP_E_SS_INVALIDCLIENTPARAMS
//
// MessageText:
//
//  The request contains parameters that do not conform to the specifications described in the WSDL documents.
//
#define PP_E_SS_INVALIDCLIENTPARAMS      ((HRESULT)0x8004401CL)

//
// MessageId: PP_E_SS_HTTPS_REQUIRED
//
// MessageText:
//
//  This service can only be accessed using HTTPS.
//
#define PP_E_SS_HTTPS_REQUIRED           ((HRESULT)0x8004401EL)

//
// MessageId: PP_W_SS_SENDMAILFAILED
//
// MessageText:
//
//  An unexpected error occurred while trying to send the e-mail you requested. Please try again.
//
#define PP_W_SS_SENDMAILFAILED           ((HRESULT)0x80044020L)

//
// MessageId: PP_E_SS_SITE_NOTAUTHENTICATED
//
// MessageText:
//
//  The site cannot be authenticated, the certificate provided cannot be verified.
//
#define PP_E_SS_SITE_NOTAUTHENTICATED    ((HRESULT)0x80044021L)

//
// MessageId: PP_E_SS_SITE_NOTAUTHORIZED
//
// MessageText:
//
//  The site is not authorized to execute this method.
//
#define PP_E_SS_SITE_NOTAUTHORIZED       ((HRESULT)0x80044022L)

//
// MessageId: PP_E_SS_NOCRYPTPROV
//
// MessageText:
//
//  Internal error: cannot acquire a crypt provider
//
#define PP_E_SS_NOCRYPTPROV              ((HRESULT)0x80044023L)

//
// MessageId: PP_E_SS_CLIENTCERT_INVALID
//
// MessageText:
//
//  The client certificate is invalid. The calling site cannot be authenticated.
//
#define PP_E_SS_CLIENTCERT_INVALID       ((HRESULT)0x80044024L)

//
// MessageId: PP_E_SS_CERTCN_INVALID
//
// MessageText:
//
//  The client certificate contains an invalid common name (CN). The calling site cannot be authenticated.
//
#define PP_E_SS_CERTCN_INVALID           ((HRESULT)0x80044025L)

//
// MessageId: PP_E_SS_INVALIDPGROUP
//
// MessageText:
//
//  The application specified an invalid policy group name (PGroup).
//
#define PP_E_SS_INVALIDPGROUP            ((HRESULT)0x80044026L)

//
// MessageId: PP_E_NO_KEY_FOUND
//
// MessageText:
//
//  The pfx not found for the site (Empty rowset).
//
#define PP_E_NO_KEY_FOUND                ((HRESULT)0x80044027L)

//
// MessageId: PP_E_SS_INVALIDHEADERXML
//
// MessageText:
//
//  Invalid soap header xml. The request contains parameters that do not conform to the specifications described in the WSDL documents.
//
#define PP_E_SS_INVALIDHEADERXML         ((HRESULT)0x80044028L)

//
// MessageId: PP_E_EMAIL_LIMITED_ACCT
//
// MessageText:
//
//  Trying to send e-mails to a Limited Passport account.
//
#define PP_E_EMAIL_LIMITED_ACCT          ((HRESULT)0x80044029L)

//
// MessageId: PP_E_EMAIL_MISSINGDATA
//
// MessageText:
//
//  Some required data missing when trying to send e-mail
//
#define PP_E_EMAIL_MISSINGDATA           ((HRESULT)0x8004402AL)

//
// MessageId: PP_E_SS_INVALIDSOAPMETHOD
//
// MessageText:
//
//  Invalid soap method. The requested method does not conform to the specifications described in the WSDL documents.
//
#define PP_E_SS_INVALIDSOAPMETHOD        ((HRESULT)0x8004402BL)

//
// MessageId: PP_E_SS_AUDITINFO_TOOLARGE
//
// MessageText:
//
//  The audit information exceeds the maximum size allowed.
//
#define PP_E_SS_AUDITINFO_TOOLARGE       ((HRESULT)0x8004402CL)

//
// MessageId: PP_E_SS_URL_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small for the service root url
//
#define PP_E_SS_URL_BUFFERTOOSMALL       ((HRESULT)0x8004402DL)

//
// MessageId: PP_E_SS_SITETOKEN_INVALID
//
// MessageText:
//
//  Site token xml is empty
//
#define PP_E_SS_SITETOKEN_INVALID        ((HRESULT)0x8004402EL)

//
// MessageId: PP_E_SS_ISSUER_NOTSUPPORTED
//
// MessageText:
//
//  The websso issuer is not supported
//
#define PP_E_SS_ISSUER_NOTSUPPORTED      ((HRESULT)0x8004402FL)

//
// MessageId: PP_E_SS_SENDEMAIL_EFAIL
//
// MessageText:
//
//  Sending email returns an E_FAIL
//
#define PP_E_SS_SENDEMAIL_EFAIL          ((HRESULT)0x80044030L)

// base 0x4050
//PP SAX parser error code
//base = 0x4055
//
// MessageId: PP_E_SS_SAX_NOTINITIALIZED
//
// MessageText:
//
//  Internal error: Sax parser is not initialzied properly
//
#define PP_E_SS_SAX_NOTINITIALIZED       ((HRESULT)0x80044055L)

//
// MessageId: PP_E_SS_SAX_INVALIDMAPENTRY
//
// MessageText:
//
//  Internal error: SaxParser, invalid methods/namespaces map entry
//
#define PP_E_SS_SAX_INVALIDMAPENTRY      ((HRESULT)0x80044056L)

//
// MessageId: PP_E_SS_SAX_INVALIDSAXNODE
//
// MessageText:
//
//  Internal error: SaxParser, unexpected sax node
//
#define PP_E_SS_SAX_INVALIDSAXNODE       ((HRESULT)0x80044057L)

//
// MessageId: PP_E_SS_SAX_BADSTACK
//
// MessageText:
//
//  Internal error: SaxParser, bad stack
//
#define PP_E_SS_SAX_BADSTACK             ((HRESULT)0x80044058L)

//
// MessageId: PP_E_SS_SAX_BADCALLBACK
//
// MessageText:
//
//  Internal error: SaxParser, invalid callback type
//
#define PP_E_SS_SAX_BADCALLBACK          ((HRESULT)0x80044059L)

//
// MessageId: PP_E_SS_SAX_INVALIDNUMERIC
//
// MessageText:
//
//  Invalid data, expected numeric
//
#define PP_E_SS_SAX_INVALIDNUMERIC       ((HRESULT)0x8004405AL)

//
// MessageId: PP_E_SS_SAX_INVALIDPUID
//
// MessageText:
//
//  Invalid data, expected puid
//
#define PP_E_SS_SAX_INVALIDPUID          ((HRESULT)0x8004405BL)

//
// MessageId: PP_E_SS_SAX_INVALIDGUID
//
// MessageText:
//
//  Invalid data, expected guid
//
#define PP_E_SS_SAX_INVALIDGUID          ((HRESULT)0x8004405CL)

//
// MessageId: PP_E_SS_SAX_INVALIDDATE
//
// MessageText:
//
//  Invalid data, expected date
//
#define PP_E_SS_SAX_INVALIDDATE          ((HRESULT)0x8004405DL)

//
// MessageId: PP_E_SS_SAX_INVALIDBOOL
//
// MessageText:
//
//  Invalid data, expected bool
//
#define PP_E_SS_SAX_INVALIDBOOL          ((HRESULT)0x8004405EL)

//
// MessageId: PP_E_SS_SAX_INVALIDHANDLER
//
// MessageText:
//
//  Internal error: SaxParser, invalid content handler
//
#define PP_E_SS_SAX_INVALIDHANDLER       ((HRESULT)0x8004405FL)

//
// MessageId: PP_E_SS_SAX_INVALIDSAXREADER
//
// MessageText:
//
//  Internal error: SaxParser, invalid sax reader
//
#define PP_E_SS_SAX_INVALIDSAXREADER     ((HRESULT)0x80044060L)

//
// MessageId: PP_E_SS_SAX_NONODEPARSED
//
// MessageText:
//
//  Internal error: SaxParser, no node has been parsed yet
//
#define PP_E_SS_SAX_NONODEPARSED         ((HRESULT)0x80044061L)

//
// MessageId: PP_E_SS_SAX_BADINDEX
//
// MessageText:
//
//  Internal error: SaxParser, bad internal index
//
#define PP_E_SS_SAX_BADINDEX             ((HRESULT)0x80044062L)

//
// MessageId: PP_E_SS_SAX_BADVARIANT
//
// MessageText:
//
//  Internal error: SaxWriter, msxml bad variant
//
#define PP_E_SS_SAX_BADVARIANT           ((HRESULT)0x80044063L)

//
// MessageId: PP_E_SS_SAX_PARSER_ERROR
//
// MessageText:
//
//  Invalid data, the xml input does not conform with the XML standards
//
#define PP_E_SS_SAX_PARSER_ERROR         ((HRESULT)0x80044064L)

//
// MessageId: PP_E_SS_SAX_WRITER_ERROR
//
// MessageText:
//
//  Internal error: the msxml writer failed
//
#define PP_E_SS_SAX_WRITER_ERROR         ((HRESULT)0x80044065L)

//
// MessageId: PP_E_SS_SAX_NODEINVALID
//
// MessageText:
//
//  The node/attribute is not valid in the current schema
//
#define PP_E_SS_SAX_NODEINVALID          ((HRESULT)0x80044066L)

//
// MessageId: PP_E_SS_SAX_ESCAPEXMLFAILED
//
// MessageText:
//
//  Escape xml failed
//
#define PP_E_SS_SAX_ESCAPEXMLFAILED      ((HRESULT)0x80044067L)

// base 0x4080
//relationship server error code
//#define PP_E_RELSERVICE_BASE                0x4080
//
// MessageId: PP_E_RS_RELATIONSHIPID_NULL
//
// MessageText:
//
//  No data exists in the RelationshipID field, or the request did not contain a RelationshipID field.
//
#define PP_E_RS_RELATIONSHIPID_NULL      ((HRESULT)0x80044081L)

//
// MessageId: PP_E_RS_INVALIDRESOLVEPENDING
//
// MessageText:
//
//  A relationship may be resolved only to the following values: accepted, declined, or deleted.
//
#define PP_E_RS_INVALIDRESOLVEPENDING    ((HRESULT)0x80044085L)

//
// MessageId: PP_E_RS_ORIGINATORUNDEFINED
//
// MessageText:
//
//  The request does not specify the originator of the request.
//  
//
#define PP_E_RS_ORIGINATORUNDEFINED      ((HRESULT)0x80044086L)

//
// MessageId: PP_E_RS_SOURCEANDTARGETNULL
//
// MessageText:
//
//  No data exists in the .NET Passport Source and Target user identification fields.
//
#define PP_E_RS_SOURCEANDTARGETNULL      ((HRESULT)0x80044087L)

//
// MessageId: PP_E_RS_SOURCEANDTARGETEQUAL
//
// MessageText:
//
//  A relationship can be proposed only between different users; the Source and Target user identification fields cannot be identical.
//
#define PP_E_RS_SOURCEANDTARGETEQUAL     ((HRESULT)0x80044088L)

//
// MessageId: PP_E_RS_ORIGNOTMANAGER
//
// MessageText:
//
//  The originator of the request is not a manager of the relationship.
//
#define PP_E_RS_ORIGNOTMANAGER           ((HRESULT)0x8004408AL)

//
// MessageId: PP_E_RS_INVALIDRELATIONSHIPID
//
// MessageText:
//
//  The application specified an invalid relationship identifier (RelationshipID).
//
#define PP_E_RS_INVALIDRELATIONSHIPID    ((HRESULT)0x8004408BL)

//
// MessageId: PP_E_RS_INVALIDPOLICYID
//
// MessageText:
//
//  The application specified an invalid policy identifier (PolicyID).
//
#define PP_E_RS_INVALIDPOLICYID          ((HRESULT)0x8004408CL)

//
// MessageId: PP_E_RS_INVALIDPASSID
//
// MessageText:
//
//  The application specified an invalid .NET Passport identifier (PASSID).
//
#define PP_E_RS_INVALIDPASSID            ((HRESULT)0x8004408DL)

//
// MessageId: PP_E_RS_INVALIDGUID
//
// MessageText:
//
//  The relationship specified an invalid globally unique identifier (GUID).
//
#define PP_E_RS_INVALIDGUID              ((HRESULT)0x8004408EL)

//
// MessageId: PP_E_RS_QUERYRESULTERROR
//
// MessageText:
//
//  An unexpected error occurred while processing your query. Please try again.
//
#define PP_E_RS_QUERYRESULTERROR         ((HRESULT)0x8004408FL)

//
// MessageId: PP_E_RS_RELIDNOTFOUND
//
// MessageText:
//
//  The application specified a relationship identifier (RelationshipID) that does not exist.
//
#define PP_E_RS_RELIDNOTFOUND            ((HRESULT)0x80044090L)

//
// MessageId: PP_E_RS_ROWNOTFOUND
//
// MessageText:
//
//  The row you specified does not exist in the database.
//
#define PP_E_RS_ROWNOTFOUND              ((HRESULT)0x80044091L)

//
// MessageId: PP_E_RS_UPDATEFAILED
//
// MessageText:
//
//  Relationship update failed.
//
#define PP_E_RS_UPDATEFAILED             ((HRESULT)0x80044092L)

//
// MessageId: PP_E_RS_VALIDATIONFAILED
//
// MessageText:
//
//  The service is unable to validate your request.
//
#define PP_E_RS_VALIDATIONFAILED         ((HRESULT)0x80044094L)

//
// MessageId: PP_E_RS_PROPOSERELFAILED
//
// MessageText:
//
//  The service is unable to process your request because the Propose Relationship function failed.
//
#define PP_E_RS_PROPOSERELFAILED         ((HRESULT)0x80044095L)

//
// MessageId: PP_E_RS_RESOLVERELFAILED
//
// MessageText:
//
//  The service is unable to process your request because the Resolve Relationship function failed.
//
#define PP_E_RS_RESOLVERELFAILED         ((HRESULT)0x80044096L)

//
// MessageId: PP_E_RS_QUERYRELFAILED
//
// MessageText:
//
//  The service is unable to process your request because the Query Relationship function failed.
//
#define PP_E_RS_QUERYRELFAILED           ((HRESULT)0x80044097L)

//
// MessageId: PP_E_RS_INVALIDTARGETARRAY
//
// MessageText:
//
//  The request contained an invalid array of .NET Passport identifiers.
//
#define PP_E_RS_INVALIDTARGETARRAY       ((HRESULT)0x80044098L)

//
// MessageId: PP_E_RS_ORIGINRESOLVEAPPROVE
//
// MessageText:
//
//  Third party approval of relationship is not allowed without being eithera manager of the managed or has BDB data.
//
#define PP_E_RS_ORIGINRESOLVEAPPROVE     ((HRESULT)0x80044099L)

//
// MessageId: PP_W_RS_VALIDATIONFAILED
//
// MessageText:
//
//  Relationship validation failed.
//
#define PP_W_RS_VALIDATIONFAILED         ((HRESULT)0x8004409BL)

//
// MessageId: PP_E_RS_NOVALIDATIONDATA
//
// MessageText:
//
//  The request did not contain validation data.
//
#define PP_E_RS_NOVALIDATIONDATA         ((HRESULT)0x8004409DL)

//
// MessageId: PP_E_RS_NOPUIDORMEMBERNAME
//
// MessageText:
//
//  The request failed because no valid puid or membername was supplied.
//
#define PP_E_RS_NOPUIDORMEMBERNAME       ((HRESULT)0x8004409EL)

//
// MessageId: PP_E_RS_GETRELTICKETFAILED
//
// MessageText:
//
//  Get relationship ticket failed.
//
#define PP_E_RS_GETRELTICKETFAILED       ((HRESULT)0x800440A0L)

//
// MessageId: PP_E_RS_PACKRELTICKETERROR
//
// MessageText:
//
//  Service temporarily unavailable due to internal RelationshipServer Component error (hr=%1), please try later.
//
#define PP_E_RS_PACKRELTICKETERROR       ((HRESULT)0x800440A1L)

//
// MessageId: PP_E_RS_KIDDENYREL_NOTALLOWED
//
// MessageText:
//
//  Kids are not allowed to deny age based relationship.
//
#define PP_E_RS_KIDDENYREL_NOTALLOWED    ((HRESULT)0x800440A2L)

//
// MessageId: PP_E_RS_BDBVALIDATIONFAILED
//
// MessageText:
//
//  BDB validation failed.
//
#define PP_E_RS_BDBVALIDATIONFAILED      ((HRESULT)0x800440A3L)

//
// MessageId: PP_E_RS_UNKNOWNVALIDATIONTYPE
//
// MessageText:
//
//  Unknown validation type.
//
#define PP_E_RS_UNKNOWNVALIDATIONTYPE    ((HRESULT)0x800440A4L)

// base 0x4200
//consent server error code
//#define PP_E_CONSENTSERVICE_BASE                0x4200
//
// MessageId: PP_E_CS_QUERYDATA_TOOLARGE
//
// MessageText:
//
//  Your query returned too many results to display. Please refine the query and try again.
//
#define PP_E_CS_QUERYDATA_TOOLARGE       ((HRESULT)0x80044200L)

//
// MessageId: PP_E_CS_INVALIDCONSENTLEVEL
//
// MessageText:
//
//  The application referenced an invalid consent level. It must specify one of the following: full, limited, or deny.
//
#define PP_E_CS_INVALIDCONSENTLEVEL      ((HRESULT)0x80044201L)

//
// MessageId: PP_E_CS_MAXPARAMSIZEEXCEEDED
//
// MessageText:
//
//  One or more parameters exceeded the maximum limit allowed.
//
#define PP_E_CS_MAXPARAMSIZEEXCEEDED     ((HRESULT)0x80044202L)

//
// MessageId: PP_E_CS_REQPARAMSMISSING
//
// MessageText:
//
//  One or more required parameters were not specified. For more information, see the Association, Consent Management, and Settings Service WSDL documents.
//
#define PP_E_CS_REQPARAMSMISSING         ((HRESULT)0x80044203L)

//
// MessageId: PP_E_CS_TSNOTSUPPORTED
//
// MessageText:
//
//  The application specified an invalid task status value. For more information, see the Consent Management Service WSDL document.
//
#define PP_E_CS_TSNOTSUPPORTED           ((HRESULT)0x80044204L)

//
// MessageId: PP_E_CS_CSNOTSUPPORTED
//
// MessageText:
//
//  The application specified a consent status that the system does not support.
//
#define PP_E_CS_CSNOTSUPPORTED           ((HRESULT)0x80044205L)

//
// MessageId: PP_E_CS_INVALIDTASKTYPE
//
// MessageText:
//
//  The manifest contains an invalid or missing task type field.
//
#define PP_E_CS_INVALIDTASKTYPE          ((HRESULT)0x80044206L)

//
// MessageId: PP_E_CS_INVALIDTASKMANIFEST
//
// MessageText:
//
//  The application specified an invalid or incomplete task manifest.
//
#define PP_E_CS_INVALIDTASKMANIFEST      ((HRESULT)0x80044207L)

//
// MessageId: PP_E_CS_INVALIDTASKID
//
// MessageText:
//
//  The application specified an invalid task identifier (TaskID) or a task that may have been deleted.
//
#define PP_E_CS_INVALIDTASKID            ((HRESULT)0x80044208L)

//
// MessageId: PP_E_CS_MAXAGEBASEDSETTINGSITEIDSEXCEEDED
//
// MessageText:
//
//  The number of siteids in request for AgeBasedConsent submit task has been exceeded.
//
#define PP_E_CS_MAXAGEBASEDSETTINGSITEIDSEXCEEDED ((HRESULT)0x8004420BL)

//
// MessageId: PP_E_CS_INVALIDSITEORPOLICYGROUP
//
// MessageText:
//
//  The application specified a non-MSN site or policy group in a consent submit call.
//
#define PP_E_CS_INVALIDSITEORPOLICYGROUP ((HRESULT)0x8004420CL)

// base 0x4280
//ManagedConsent
//#define PP_E_MANAGEDCONSENT_BASE 0x4280
//
// MessageId: PP_E_MC_KPPVCINVALID
//
// MessageText:
//
//  KPPVC has invalid data
//
#define PP_E_MC_KPPVCINVALID             ((HRESULT)0x80044280L)

//
// MessageId: PP_E_MC_KPPVCMISSING
//
// MessageText:
//
//  KPPVC is missing
//
#define PP_E_MC_KPPVCMISSING             ((HRESULT)0x80044281L)

//
// MessageId: PP_E_MC_PARENT_INVALID
//
// MessageText:
//
//  Invalid parent
//
#define PP_E_MC_PARENT_INVALID           ((HRESULT)0x80044282L)

//
// MessageId: PP_E_MC_FLOW_INVALID
//
// MessageText:
//
//  Invalid flow
//
#define PP_E_MC_FLOW_INVALID             ((HRESULT)0x80044283L)

//
// MessageId: PP_E_MC_CONSENT_INVALID
//
// MessageText:
//
//  Invalid consent level
//
#define PP_E_MC_CONSENT_INVALID          ((HRESULT)0x80044284L)

//
// MessageId: PP_E_MC_REQUIRED_INPUTFIELD_MISSING
//
// MessageText:
//
//  Required user input missing
//
#define PP_E_MC_REQUIRED_INPUTFIELD_MISSING ((HRESULT)0x80041D0EL)

// base 0x4300
//relationship server error code
//#define PP_E_PPSETTINGS_BASE                0x4300
//
// MessageId: PP_E_PPS_INVALIDQUERY
//
// MessageText:
//
//  The application specified an invalid query.
//
#define PP_E_PPS_INVALIDQUERY            ((HRESULT)0x80044300L)

//
// MessageId: PP_E_PPS_INVALIDVERSIONTOKEN
//
// MessageText:
//
//  The application specified an invalid version token.
//
#define PP_E_PPS_INVALIDVERSIONTOKEN     ((HRESULT)0x80044301L)

//
// MessageId: PP_E_PPS_SAME_SETTINGS
//
// MessageText:
//
//  The client settings have not been modified since your last query.
//
#define PP_E_PPS_SAME_SETTINGS           ((HRESULT)0x80044302L)

//
// MessageId: PP_E_PPS_NO_SETTINGS
//
// MessageText:
//
//  No .NET Passport settings exist for this user.
//
#define PP_E_PPS_NO_SETTINGS             ((HRESULT)0x80044303L)

//
// MessageId: PP_E_PPS_SITE_REQUIRES_FULL_CONSENT
//
// MessageText:
//
//  The site supports only full or denied consent settings; it does not support limited consent.
//
#define PP_E_PPS_SITE_REQUIRES_FULL_CONSENT ((HRESULT)0x80044304L)

//
// MessageId: PP_E_PPS_MAXAGEBASEDSETTINGSITEIDSEXCEEDED
//
// MessageText:
//
//  The maximum number of site ids has been exceeded in que