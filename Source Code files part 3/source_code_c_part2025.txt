               break;
                case PointsOffers.PP700: offerId = 0xFFFE07D10FF00013;
                    break;
                case PointsOffers.PP1250:      offerId = 0xFFFE07D10FF00015;
                        break;
                case PointsOffers.PP1400:      offerId = 0xFFFE07D10FF00017;
                        break;
                case PointsOffers.PP1500:      offerId = 0xFFFE07D10FF00019;
                        break;
                case PointsOffers.PP1600:      offerId = 0xFFFE07D10FF00021;
                        break;
                case PointsOffers.PP2100:      offerId = 0xFFFE07D10FF00023;
                        break;
                case PointsOffers.PP3000:      offerId = 0xFFFE07D10FF00025;
                        break;
                case PointsOffers.PP3500:      offerId = 0xFFFE07D10FF00027;
                        break;
                case PointsOffers.PP4000:      offerId = 0xFFFE07D10FF00029;
                        break;
                case PointsOffers.PP4100:      offerId = 0xFFFE07D10FF00031;
                        break;
                case PointsOffers.WH5000US:    offerId = 0xFFFE07D10FF00037;
                        break;
                case PointsOffers.WH5000CN:    offerId = 0xFFFE07D10FF00039;
                        break;
                case PointsOffers.WH1000CN:    offerId = 0xFFFE07D10FFC0001;
                        break;
                case PointsOffers.ZuneCC400:      offerId = 0xFFFE07770FF00000;
                        break;
                case PointsOffers.ZuneCC1200:      offerId = 0xFFFE07770FF00002;
                        break;
                case PointsOffers.ZuneCC2000:      offerId = 0xFFFE07770FF00006;
                        break;
                case PointsOffers.ZuneCC4000:      offerId = 0xFFFE07770FF00008;
                        break;
                case PointsOffers.ZunePP400:      offerId = 0xFFFE07770FF00010;
                        break;
                case PointsOffers.ZunePP1200:      offerId = 0xFFFE07770FF00012;
                        break;
                case PointsOffers.ZunePP2000:      offerId = 0xFFFE07770FF00014;
                        break;
                case PointsOffers.ZunePP4000:      offerId = 0xFFFE07770FF00016;
                        break;
                case PointsOffers.Promo100: offerId = 0xFFFE07D102000501;
                    break;
                case PointsOffers.Promo200: offerId = 0xFFFE07D102000502;
                    break;
                case PointsOffers.Promo300: offerId = 0xFFFE07D102000503;
                    break;
                case PointsOffers.Promo400: offerId = 0xFFFE07D102000504;
                    break;
                case PointsOffers.Promo500: offerId = 0xFFFE07D102000505 ;
                    break;
                case PointsOffers.NZPP3000: offerId = 0xFFFE07D10FF00025;
                    break;
                default:
                    throw new Exception("The specified points offer has not been defined.");
            }

            return offerId;
        }


        public static string GetPointsOfferVoucherCode(PointsOffers offer)
        {
            string voucher = "";
            switch (offer)
            {
                case PointsOffers.PP100:      voucher = "7WM36-GHCJB-X6WX2-VTTBR-Y6KCG";
                    break;
                case PointsOffers.PP160: voucher = "DJ444-2FBTG-F4BQ7-3JCTJ-MRHXQ";
                    break;
                case PointsOffers.PP700: voucher = "BFK8M-QHG36-C2QG8-CF27V-B9JXM";
                    break;
                case PointsOffers.PP1250:      voucher = "7CJJ9-28BG6-4HRC4-WHWRR-44BBP";
                        break;
                case PointsOffers.PP1400:      voucher = "84WXT-D2WJ6-277JQ-YGV9H-PQYMC";
                        break;
                case PointsOffers.PP1500:      voucher = "HWMRM-MMBHD-639CP-HXKQM-KQWG7";
                        break;
                case PointsOffers.PP1600:      voucher = "JJ39Q-P6FJY-XYBQ9-YG3Y8-JH6WR";
                        break;
                case PointsOffers.PP2100:      voucher = "9H6Y9-CHPVF-42WQ2-D9JCX-96F4C";
                //case PointsOffers.PP2100:    voucher = "6RCXQ-MWQ4M-7YGY6-8WC27-YTR8T";
                    break;
                case PointsOffers.PP3000:      voucher = "J6XK4-8W3G4-M4XM7-9B32H-4Y2CT";
                        break;
                case PointsOffers.PP3500:      voucher = "WDV7G-4X3XM-PKCKH-VKT3R-J873M";
                        break;
                case PointsOffers.PP4000:      voucher = "RPQQJ-KWXGM-JV8KV-Q8RVX-VQCD3";
                        break;
                case PointsOffers.PP4100:      voucher = "HXBG8-X7PK3-7JGWK-6X9HP-JYFP2";
                        break;
                case PointsOffers.ZunePP400: voucher = "BMF36-J22CJ-3QF7C-MTTVJ-C69VH"; //"HYQCP-V6FMX-36WYX-64M4X-6PWHV";
                        break;
                case PointsOffers.ZunePP1200: voucher = "36JCF-WVFPR-C7878-QDDFK-JYWPJ"; //"6G28G-BH8XM-W9P66-KH2M4-WQB63";
                        break;
                case PointsOffers.ZunePP2000: voucher = "GRQYW-MKR7Y-DVVQV-82H49-9FVW7"; //"MKC7J-D8YDP-FBRGY-7QF6G-DXH23";
                        break;
                case PointsOffers.ZunePP4000: voucher = "JFB8W-2TX2Y-TR236-QV4XQ-HDCPV"; //"QRKHB-TGDTR-92YTH-GPCMW-MDJWW";
                        break;

                case PointsOffers.Promo100: voucher = "X1111-11111-11111-11111-11111";
                    break;
                case PointsOffers.Promo200: voucher = "X2222-22222-22222-22222-22222";
                    break;
                case PointsOffers.Promo300: voucher = "X3333-33333-33333-33333-33333";
                    break;
                case PointsOffers.Promo400: voucher = "X4444-44444-44444-44444-44444";
                    break;
                case PointsOffers.Promo500: voucher = "X5555-55555-55555-55555-55555";
                    break;
                case PointsOffers.NZPP3000: voucher = "38e84d91-674d-41dc-8a43-4280f1c17de1";
                    break;
                default:
                    throw new Exception("The specified points offer does not have a voucher code.");
            }

            return voucher;
        }


        public enum MigrationOffers : ulong
        {
            XboxLiveMigraiton = 0xFFFE07D180000045,
            ZunePassMigration = 0xFFFE077788000018,
        }

        ///
        /// Here, we should be in sync with what's in RawCatalogDB
        /// 
        public static ulong GetMigraionOffer(ulong offerId)
        {
            uint titleId = (uint)(offerId >> 32);  
            ulong migrationOfferId = 0;
            switch(titleId)
            {
                case XOn.XENON_DASH_TITLE_ID:                     
                    migrationOfferId = (ulong)MigrationOffers.XboxLiveMigraiton;                    
                    break;
                case XOn.CRUX_TITLE_ID:
                    migrationOfferId = (ulong)MigrationOffers.ZunePassMigration;
                    break;
                default:
                    break;
            }
             return migrationOfferId;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLArgoAuthenticateAccount.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLArgoAuthenticateAccount: XRLPayload 
    {
        public ushort PassportTicketLength;
        [WireInfo(SizeParam="PassportTicketLength")]
        public string PassportTicket;

        public XRLArgoAuthenticateAccount() : base() 
        {
            UseHttpAuth = true;
            Slot.titleId = XOn.CRUX_TITLE_ID;
            
        }
        
        
        protected override string GetServiceName() 
        {
            return "/xuacs/ArgoAuthenticateAccount.ashx";
        }
        
        public bool Execute(out XRLArgoAuthenticateAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLArgoAuthenticateAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLArgoAuthenticateAccountResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLArgoAuthenticateAccountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLArgoAuthenticateAccountResponse: XRLPayload 
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public ulong OfferId;
        public int SubscriptionStatusId;
        public DateTime PurchaseDate;
        public DateTime EndDate;
        public byte HasViolations;
        public ulong renewalOfferId;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLCreateUserAndBillableAccount.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLCreateUserAndBillableAccount : XRLPayload<CreateUserAndBillableAccountRequest, CreateUserAndBillableAccountResponse>
    {

        //virtual interface to use
        public string ServerInterface=Interface.xuacs;

        //automatically set sginfo to match the request for these items
        public bool AutoSGInfoMachinePuid=true;
        public bool AutoSGInfoServices=true;

        //automatically create and cache these items
        public bool AutoCreateMachine=true;

        //
        private Dictionary<string, ulong> cachedMachine=new Dictionary<string, ulong>();


        public XRLCreateUserAndBillableAccount()
        {
            ManualPopulateSlot();

            Slot.machinePuid=0;
            Slot.ClearServices();
        
        }

        /// <summary> Perform the create request, creating a machine if required </summary>
        /// <returns>True if the request is successful, False otherwise.</returns>
        public override bool Execute()
        {
            //create user/machine if needed
            if (AutoCreateMachine)
            {
                if (!cachedMachine.ContainsKey(Global.XEnv.GetEnv()))
                {
                    cachedMachine[Global.XEnv.GetEnv()]=MachineEditor.CreateNew().Id;
                }

                Request.machinePuid=cachedMachine[Global.XEnv.GetEnv()];
            }

            //set auto sg info
            if (AutoSGInfoMachinePuid)
            {
                Slot.machinePuid=Request.machinePuid;
                Slot.SetClientType(CSGInfo.ClientInfo.ToClientType(Slot.machinePuid));
            }

            if (AutoSGInfoServices)
            {
                Slot.ClearServices();
                Slot.AddService(XOService.User_Account);
            }

            // to support schema version
            if (!CustomHeader.Contains("X-Schema-Ver:"))
                CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(Request.SchemaVersion) + "\r\n";
            
            //execute
            bool bRC = Execute(Global.XEnv.GetVirtualInterface(ServerInterface));

            return bRC;            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XeLiveAccountUser.cs ===
using System;
using System.Net;
using System.IO;
using System.Reflection;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using xonline.common.config;
using xonline.common.utilities;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.protocol;

using CreateUserParamsDict = System.Collections.Generic.Dictionary<System.String, System.Object>;

namespace ServerTestFramework.LiveService.UserAccount
{

    //If your change to this class will increase class content exposure,
    //please have a talk with fejiang, as this is a refectored class from XeUser,
    //we have long-term concerns regarding its maintainability;
    public class XeLiveAccountUser
    {
        private XeUserParam param;
        public CreateUserParamsDict outputDict;

        public XeLiveAccountUser()
        {
            outputDict = new CreateUserParamsDict();
            param = (new XeUserParam());
        }

        public XeLiveAccountUser(XeUserParam inputParam)
        {
            outputDict = new CreateUserParamsDict();
            if (inputParam == null)
            {
                throw new UnexpectedTestResultException("Input XeUserParam cannot be null.");
            }
            else
            {
                param = inputParam;
            }
        }

        public ulong UserPuid
        {
            get { return (((XRLXeCreateLiveAccountResponse)outputDict[XeUserParam.response]).UserPuid); }
        }

        public string Gamertag
        {
            get { return (((XRLXeCreateLiveAccount)outputDict[XeUserParam.request]).Gamertag); }
        }

        public void CreateUserThroughXRL(uint numOfRetries)
        {
            XRLXeCreateLiveAccount req = new XRLXeCreateLiveAccount();
            PopulateXRLRequestValue(param, req);
            RetryHelper.MethodInvocParamObj paramObj1 = new RetryHelper.MethodInvocParamObj(
                                    this, "ExecuteCreateLiveAccountRequest",
                                    new object[2] { req, new uint[2] { HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN, 
                                                                    HResult.XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG }},
                                                        BindingFlags.NonPublic | BindingFlags.Instance);
            RetryHelper.MethodInvocParamObj paramObj2 = new RetryHelper.MethodInvocParamObj(
                                                this, "UpdateGamerTag",
                                                new object[1] { req },
                                                BindingFlags.NonPublic | BindingFlags.Instance);
            RetryHelper.MethodInvocParamObj[] paramObjects = new RetryHelper.MethodInvocParamObj[1] { paramObj2 };
            RetryHelper.RetryExecution(paramObj1, paramObjects, numOfRetries);
            Global.RO.Info("User 0x{0:X} ({1}) created.", this.UserPuid, req.Gamertag);
        }

        public void PopulateXRLRequestValue(XeUserParam param, XRLXeCreateLiveAccount req)
        {
            //variable value assignment needs to follow order, because some auto-generated variable values depend on other variables;
            req.CountryId = (byte)param.paramDict[XeUserParam.countryId];
            req.MachinePuid = (ulong) param.paramDict[XeUserParam.machinePuid];

            if (param.paramDict.ContainsKey(XeUserParam.gamerTag))
            {
                req.Gamertag = (string)param.paramDict[XeUserParam.gamerTag];
            }
            else
            {
                req.Gamertag = (new RandomEx()).GenerateRandomString("XEN", 15);
            }

            if ((param.paramDict.ContainsKey(XeUserParam.parentalControlGroup)))
            {
                req.ParentalControlGroupId = (byte)param.paramDict[XeUserParam.parentalControlGroup];
            }

            //BirthDate overrides ParentalControl input;
            if (param.paramDict.ContainsKey(XeUserParam.birthdate))
            {
                req.Birthdate = (DateTime)param.paramDict[XeUserParam.birthdate];
            }
            else if ((param.paramDict.ContainsKey(XeUserParam.parentalControlGroup)))
            {
                req.Birthdate = XeUserParam.GetBirthDate(req.CountryId, (ParentalControlGroup)req.ParentalControlGroupId);
            }
            else
            {
                req.ParentalControlGroupId = (byte)ParentalControlGroup.Open;
                req.Birthdate = XeUserParam.GetBirthDate(req.CountryId, ParentalControlGroup.Open);
            }

            if (param.paramDict.ContainsKey(XeUserParam.passportUserSessionToken))
            {
                req.SignedUserPassportPuid = (byte[])param.paramDict[XeUserParam.passportUserSessionToken];
            }
            else
            {
                req.SignedUserPassportPuid = XeUserParam.CreatePassportSessionToken((byte)param.paramDict[XeUserParam.countryId]);
            }

            //ParentalControlGroup info kicks in when no other info can be used to decide;
            if (param.paramDict.ContainsKey(XeUserParam.passportOwnerSessionToken))
            {
                req.SignedOwnerPassportPuid = (byte[])param.paramDict[XeUserParam.passportOwnerSessionToken];
            }
            else if (req.Birthdate <= DateTime.UtcNow.AddYears(-(CountryDictionary.MinAge((byte)req.CountryId).Billing)))
            {
                req.SignedOwnerPassportPuid = req.SignedUserPassportPuid;
            }
            else
            {
                req.SignedOwnerPassportPuid = XeUserParam.CreatePassportSessionToken((byte)param.paramDict[XeUserParam.countryId]);
            }
            if (param.paramDict.ContainsKey(XeUserParam.offerId))
            {
                req.OfferId = (ulong)param.paramDict[XeUserParam.offerId];
            }
            else
            {
                req.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
            }

            req.Email = (string)param.paramDict[XeUserParam.email];
            req.LanguageId = (ushort)param.paramDict[XeUserParam.languageId];
            req.MsftOptIn = Convert.ToByte(param.paramDict[XeUserParam.msftOptIn]);
            req.PartnerOptIn = Convert.ToByte(param.paramDict[XeUserParam.partnerOptIn]);

            req.FirstName = "John";
            req.LastName = "Smith";
            req.AddressInfo = new AddressInfoData();
            req.AddressInfo.SetDefaultAddress((XeUser.Country)Convert.ToByte(param.paramDict[XeUserParam.countryId]));
            req.PhoneInfo = XeUserParam.GeneratePhoneInfo((XeUser.Country)param.paramDict[XeUserParam.countryId]);
            req.CreditCardInfo = new CreditCardInfoData();
            req.DirectDebitInfo = new DirectDebitInfoData();
            req.offlineXuid = (ulong) param.paramDict[XeUserParam.offlineXuid];
        }
        
        private RetryHelper.ExecutionResult ExecuteCreateLiveAccountRequest(XRLXeCreateLiveAccount req, uint[] xErrsAllowedToRetry)
        {
            XRLXeCreateLiveAccountResponse resp = new XRLXeCreateLiveAccountResponse();
            bool succeeded = req.Execute(out resp);

            if (succeeded)
            {
                if (resp.UserPuid == 0)
                {
                    throw new UnexpectedTestResultException("XeLiveAccountUser is created with UserPuid as 0; something is seriously wrong!");
                }
                //record the state of request and response for later validation outside of this class;
                outputDict.Add(XeUserParam.request, req);
                outputDict.Add(XeUserParam.response, resp);
                UacsCommon.ShowServerID(resp.UserPuid);
                return RetryHelper.ExecutionResult.Success;
            }
            else if (Array.Exists(xErrsAllowedToRetry, s => s == req.XErr))
            {
                Global.RO.Warn("User Creation Failed With Known Error {0}, Retrying ...", req.GetDumpString());
                return RetryHelper.ExecutionResult.Fail_Retryable;
            }
            else
                //return RetryHelper.ExecutionResult.Fail_NoRetry;
                throw new UnexpectedTestResultException("XeUser creation failed: " + req.GetDumpString());
        }

        private void UpdateGamerTag(XRLXeCreateLiveAccount req)
        {
            RandomEx rnd = new RandomEx();
            req.Gamertag = rnd.GenerateRandomString("XEN", 15);
        }
    }  /* *+++++ END CLASS LIGHTWGTXEUSER ++++* */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLDisableSubscription.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLDisableSubscription : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public ushort ServiceInstanceIdLength = 0;
        [WireInfo(SizeParam = "ServiceInstanceIdLength")]
        public string ServiceInstanceId;
        public int SubscriptionStatusId;
        public bool AddViolation;

        public XRLDisableSubscription()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/DisableSubscription.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\LightWgtXeUser.cs ===
using System;
using System.Net;
using System.IO;
using System.Reflection;
using System.Security;
using System.Security.Permissions;
using System.Threading;
using xonline.common.config;
using xonline.common.utilities;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.protocol;

using CreateUserParamsDict = System.Collections.Generic.Dictionary<System.String, System.Object>;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XeUserParam
    {
        //Essential Information;
        public const string birthdate = "datetimeBirthdate";
        public const string clientIP = "stringClientIP";
        public const string countryCode = "stringCountryCode";
        public const string countryId = "byteCountryId";
        public const string email = "stringEMail";
        public const string firstname = "stringFirstname";
        public const string gamerTag = "stringGamerTag";
        public const string languageId = "ushortLanguageId";
        public const string lastname = "stringLastname";
        public const string machinePuid = "ulongMachinePuid";
        public const string msftOptIn = "byteMsftOptIn";
        public const string offlineXuid = "ulongOfflineXuid";
        public const string parentalControlGroup = "uintParentalControlGroup";
        public const string partnerOptIn = "bytePartnerOptIn";

        //Passport ID information;
        public const string passportMemberName = "stringPassportMemberName";
        public const string passportPassword = "stringPassportPassword";
        public const string userPassportPuid = "ulongUserPassportPuid";
        public const string ownerPassportPuid = "ulongOwnerPassportPuid";
        public const string passportUserSessionToken = "ulongPassportUserSessionToken";
        public const string passportOwnerSessionToken = "ulongPassportOwnerSessionToken";

        //Payment and other information;
        public const string paymentInstrumentType = "PaymentInstrumentTypeEnum";
        public const string titleId = "uintTitleId";
        public const string offerId = "ulongOfferId";
        public const string billingToken = "stringBillingToken";
        public const string addressInfo = "AddressInfo";
        public const string phoneInfo = "PhoneInfo";
        public const string creditCardInfo = "CreditCardInfo";
        public const string directDebitInfo = "DirectDebitInfo";
        public const string reservedBytes = "ReservedBytes";

        //For request and response;
        public const string request = "Request";
        public const string response = "Response";

        public CreateUserParamsDict paramDict;

        public XeUserParam()
        {
            paramDict = new CreateUserParamsDict();
            EnterNewParamDictEntry(machinePuid, MachineEditor.CreateNew().Id);
            EnterNewParamDictEntry(countryId, XeUser.Country.US);
            EnterNewParamDictEntry(languageId, XeUser.Language.en);
            EnterNewParamDictEntry(gamerTag, (new RandomEx()).GenerateRandomString("XEN", 15));
            EnterNewParamDictEntry(offlineXuid, (ulong) 0);
            EnterNewParamDictEntry(partnerOptIn, 0);
            EnterNewParamDictEntry(msftOptIn, 0);
            EnterNewParamDictEntry(email, "johnsmith" + Global.PassportMemberDomain);
        }

        public void EnterNewParamDictEntry(string paramName, Object obj)
        {
            paramDict[paramName] = obj;
        }

        static public PhoneInfoData GeneratePhoneInfo(XeUser.Country country)
        {
            PhoneInfoData phoneInfo = new PhoneInfoData();
            phoneInfo.PhonePrefix = "425";
            phoneInfo.PhoneNumber = "7075555";
            return phoneInfo;
        }

        static public DateTime GetBirthDate(byte countryId, ParentalControlGroup pcg)
        {
            switch (pcg)
            {
                case ParentalControlGroup.Medium:
                    return DateTime.UtcNow.AddYears(1 - CountryDictionary.MinAge(countryId).Billing);
                case ParentalControlGroup.Restricted:
                    return DateTime.UtcNow.AddYears(1 - CountryDictionary.MinAge(countryId).User);
                default:
                    return DateTime.UtcNow.AddYears(-30);
            }
        }

        static public ParentalControlGroup GetParentalControlGroup(byte countryId, DateTime birthDate)
        {
            if (birthDate <= DateTime.UtcNow.AddYears(1 - CountryDictionary.MinAge(countryId).Billing))
            {
                return ParentalControlGroup.Open;
            }
            else if (birthDate <= DateTime.UtcNow.AddYears(1 - CountryDictionary.MinAge(countryId).User))
            {
                return ParentalControlGroup.Medium;
            }
            else
            {
                return ParentalControlGroup.Restricted;
            }
        }

        static public ulong GetPassportPuid(byte countryId, out string memberName, out string password, out byte[] userSessionToken)
        {
            // create the passport account here.
            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(countryId);
            memberName = passportUser.MemberName;
            password = passportUser.Password;
            userSessionToken = passportUser.SessionToken;

            return PassportUtilities.GetPuidFromSessionToken(userSessionToken);
        }

        static public ulong GetPassportPuid(byte countryId)
        {
            // create the passport account here.
            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(countryId);
            return PassportUtilities.GetPuidFromSessionToken(passportUser.SessionToken);
        }

        static public byte[] CreatePassportSessionToken(byte countryId, out string memberName, out string password, out ulong userPassportPuid)
        {
            // create the passport account here.
            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(countryId);
            memberName = passportUser.MemberName;
            password = passportUser.Password;
            userPassportPuid = PassportUtilities.GetPuidFromSessionToken(passportUser.SessionToken);

            return passportUser.SessionToken;
        }

        static public byte[] CreatePassportSessionToken(byte countryId)
        {
            // create the passport account here.
            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(countryId);
            return passportUser.SessionToken;
        }
    }

    public enum ParentalControlGroup : uint
    {
        Open = 0, //Adult
        Medium = 1, //Teen
        Restricted = 2, //Child
    };

    public class RetryHelper
    {        
        public enum ExecutionResult : byte
        {
            Success = 0,
            Fail_Retryable = 1,
            Fail_NoRetry = 2,
            Ignored = 4
        };

        public class MethodInvocParamObj
        {
            public object inputObject;
            public string methodName;
            public object[] paramList;
            public System.Reflection.BindingFlags invokeAttr;

            public MethodInvocParamObj(object Object1, string nameOfMethod, object[] listOfParam, System.Reflection.BindingFlags attr)
            {
                inputObject = Object1;
                methodName = nameOfMethod;
                paramList = listOfParam;
                invokeAttr = attr;
            }
        }

        static public object DelegateExecute(MethodInvocParamObj paramObj)
        {
            //Throw exception when input is invalid;
            if (paramObj == null || paramObj.inputObject == null || paramObj.paramList == null)
            {
                throw new UnexpectedTestResultException("Input MethodInvocParamObj or associated object is null!");
            }

            Type tp = paramObj.inputObject.GetType();
            if (tp == null)
            {
                throw new UnexpectedTestResultException("Type information was not found for " + paramObj.methodName);
            }

            MethodInfo inputMethod = null;
            if (tp.ToString().Equals("System.RuntimeType"))
            {
                inputMethod = ((Type)paramObj.inputObject).GetMethod(paramObj.methodName, paramObj.invokeAttr);
            }
            else
            {
                inputMethod = tp.GetMethod(paramObj.methodName, paramObj.invokeAttr);
            }
            if (inputMethod == null)
            {
                throw new UnexpectedTestResultException("Method information was not found for " + paramObj.methodName);
            }
            object result = inputMethod.Invoke(paramObj.inputObject, paramObj.paramList);
            return result;
        }


        static public bool RetryExecution(MethodInvocParamObj paramObj1, uint numTimesToRetry)
        {
            if (paramObj1 == null)
            {
                throw new UnexpectedTestResultException("Input error! The first input object cannot be null!");
            }
            return RetryExecution(paramObj1, null, numTimesToRetry);
        }

        //Limitation: the invoked method must return "ExecutionResult";
        //paramObj1 is for the primary function which is need to be retried;
        //paramObjects is for intermediate functions that need to be executed between retries;
        static public bool RetryExecution(MethodInvocParamObj paramObj1, MethodInvocParamObj[] paramObjects, uint numTimesToRetry)
        {
            if (paramObj1 == null)
            {
                throw new UnexpectedTestResultException("Input error! The first input object cannot be null!");
            }

            if (numTimesToRetry <= 0)
            {
                throw new UnexpectedTestResultException("Number of retries can not be equal to or smaller than 0.");
            }

            uint retryCount = 0;
            do
            {
                ExecutionResult result = (ExecutionResult)DelegateExecute(paramObj1);
                if (result == ExecutionResult.Success)
                {
                    return true;
                }
                else if (result == ExecutionResult.Fail_NoRetry || result == ExecutionResult.Ignored)
                {
                    return false;
                }
                else
                {
                    if (retryCount == numTimesToRetry - 1)
                    {
                        Global.RO.Warn("'{0}' has been tried {1} time(s), all failed.", paramObj1.methodName, numTimesToRetry);
                        return false;
                    }

                    if (paramObjects != null && paramObjects.Length > 0)
                    {
                        for (int idx = 0; idx < paramObjects.Length; idx++)
                        {
                            Global.RO.Info("Running intermediate method {0} for the No.{1} time.", paramObjects[idx].methodName, retryCount + 1);
                            DelegateExecute(paramObjects[idx]);
                        }
                    }

                    Global.RO.Info("Running method {0} for the No.{1} time.", paramObj1.methodName, retryCount + 2);
                }
            }
            while (retryCount++ < numTimesToRetry);

            return true;
        }

    }

    public class FieldAccessor
    {
        static public void SetProperty(object Object, string name, object value)
        {
            Type thisType = Object.GetType();
            FieldInfo fdInfo = thisType.GetField(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            if (fdInfo == null)
                throw new UnexpectedTestResultException(string.Format("Field '{0}' information was not found  in {1}", name, Object.ToString()));
            fdInfo.SetValue(Object, value);
        }

        static public void SetMultipleProperties(object Object, string[] names, object[] values)
        {
            if (names.Length != values.Length)
                throw new UnexpectedTestResultException("Number of properties does not match number of values.");

            for (int idx = 0; idx < names.Length; idx ++ )
            {
                SetProperty(Object, names[idx], values[idx]);
            }
        }

        static public object GetProperty(object Object, string name)
        {
            Type thisType = Object.GetType();
            FieldInfo fdInfo = thisType.GetField(name, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            if (fdInfo == null)
                throw new UnexpectedTestResultException(string.Format("Field information was not found for {0} in {1}", name, Object.ToString()));
            return fdInfo.GetValue(Object);
        }

        static public void CopyFieldValueFromDiffObject(object dst, string dstField,
                                                            object src, string srcField)
        {
            SetProperty(dst, dstField, GetProperty(src, srcField));
        }
    }

    public class XeUserCreator
    {
        static public uint numOfRetries = 5;
        static public LightWgtXeUser CreateXeUser()
        {
            XeUserParam param = new XeUserParam();
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateXeUserWithGivenPassport(byte[] givenUsrPsptTok, byte[] givenOwnrPsptTok)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.passportUserSessionToken, givenUsrPsptTok);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, givenOwnrPsptTok);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateXeUser(ulong machinePuid)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.machinePuid, machinePuid);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateXeUser(XeUser.Country countryId)
        {
            ushort languageId = CountryLanguage.GetFirstLanguageFromCountry((byte)countryId);
            return CreateXeUser(countryId, (XeUser.Language)languageId);
        }

        static public LightWgtXeUser CreateXeUser(XeUser.Country countryId, XeUser.Language languageId)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.countryId, countryId);
            param.EnterNewParamDictEntry(XeUserParam.languageId, languageId);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateXeUser(string gamerTag)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.gamerTag, gamerTag);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(1);
            return user;
        }

        static public LightWgtXeUser CreateXeUser(string gamerTag, XeUser.Country countryId)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.gamerTag, gamerTag);
            param.EnterNewParamDictEntry(XeUserParam.countryId, countryId);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(1);
            return user;
        }

        static public LightWgtXeUser CreateXeUser(XeUser parent, ParentalControlGroup pcg)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.parentalControlGroup, pcg);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, parent.PassportSessionToken);

            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateXeLightWtUser(XeUser.Country countryId)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.countryId, countryId);
            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreatePartialUserInDB(numOfRetries);  
            return user;
        }

        static public LightWgtXeUser CreateMinorXeUser(XeUser parent, ParentalControlGroup controlGroup)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.parentalControlGroup, controlGroup);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, parent.PassportSessionToken);

            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateMinorXeUser(byte[] passportSessionToken, ParentalControlGroup controlGroup)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.parentalControlGroup, controlGroup);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, passportSessionToken);

            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreateMinorXeUser(XeUser parent, ParentalControlGroup controlGroup, XeUser.Country countryId)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.parentalControlGroup, controlGroup);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, parent.PassportSessionToken);
            param.EnterNewParamDictEntry(XeUserParam.countryId, countryId);

            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreateUserInDB(numOfRetries);
            return user;
        }

        static public LightWgtXeUser CreatePartialMinorXeUser(XeUser parent, ParentalControlGroup controlGroup)
        {
            XeUserParam param = new XeUserParam();
            param.EnterNewParamDictEntry(XeUserParam.parentalControlGroup, controlGroup);
            param.EnterNewParamDictEntry(XeUserParam.passportOwnerSessionToken, parent.PassportSessionToken);

            LightWgtXeUser user = new LightWgtXeUser(param);
            user.CreatePartialUserInDB(numOfRetries);
            return user;
        }
    }

    //If your change to this class will increase class content exposure,
    //please have a talk with fejiang, as this is a refectored class from XeUser,
    //we have long-term concerns regarding its maintainability;
    public class LightWgtXeUser
    {
        private XeUserParam param;
        public CreateUserParamsDict outputDict;

        public LightWgtXeUser()
        {
            outputDict = new CreateUserParamsDict();
            param = (new XeUserParam());
        }

        public LightWgtXeUser(XeUserParam inputParam)
        {
            outputDict = new CreateUserParamsDict();
            if (inputParam == null)
            {
                throw new UnexpectedTestResultException("Input XeUserParam cannot be null.");
            }
            else
            {
                param = inputParam;
            }
        }

        public ulong UserPuid
        {
            get { return (((XRLCreateUserAndBillableAccount)outputDict[XeUserParam.response]).Response.userPuid); }
        }


        // Create light weight user;
        //public void CreateLightWgtUserInDB(uint numOfRetries)
        public void CreateUserInDB(uint numOfRetries)
        {
            CreatePartialUserInDB(numOfRetries);
            XRLCreateUserAndBillableAccount tempXRL;
            //Assumption: when CreateUser request succeeds, we store the response in the output dictionary;
            //output dictionary is used as input here to provide UserPuid.
            if (outputDict.ContainsKey(XeUserParam.response))
            {
                tempXRL = (XRLCreateUserAndBillableAccount)outputDict[XeUserParam.response];
            }
            else
            {
                throw new UnexpectedTestResultException("User has not been created, no where to find UserPuid yet.");
            }
            ulong userPuid = tempXRL.Response.userPuid;
            UacsCommon.WaitForValidBillingAccountId(tempXRL.Response.userPuid);
            SetAccountInfoRequestExecution(param, userPuid);
        }

        public void CreatePartialUserInDB(uint numOfRetries)
        {
            XRLCreateUserAndBillableAccount xrl = new XRLCreateUserAndBillableAccount();
            PopulateXRLRequestValue(param, xrl);
            RetryHelper.MethodInvocParamObj paramObj1 = new RetryHelper.MethodInvocParamObj(
                                                this, "ExecuteCreateLightWgtAccountRequest",
                                                new object[2] { xrl, new uint[2] { HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN, 
                                                                    HResult.XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG }},
                                                                    BindingFlags.NonPublic | BindingFlags.Instance);
            RetryHelper.MethodInvocParamObj paramObj2 = new RetryHelper.MethodInvocParamObj(
                                                this, "UpdateGamerTag",
                                                new object[1] { xrl },
                                                BindingFlags.NonPublic | BindingFlags.Instance);
            RetryHelper.MethodInvocParamObj[] paramObjects = new RetryHelper.MethodInvocParamObj[1]{paramObj2};
            RetryHelper.RetryExecution(paramObj1, paramObjects, numOfRetries);

            Global.RO.Info("User 0x{0:X} ({1}) created.", xrl.Response.userPuid, xrl.Request.gamertag);
        }

        public void PopulateXRLRequestValue(XeUserParam param, XRLCreateUserAndBillableAccount xrl)
        {            
            xrl.Request.countryId = (byte)param.paramDict[XeUserParam.countryId];
            xrl.Request.machinePuid = (ulong) param.paramDict[XeUserParam.machinePuid];

            if (param.paramDict.ContainsKey(XeUserParam.gamerTag))
            {
                xrl.Request.gamertag = (string)param.paramDict[XeUserParam.gamerTag];
            }
            else
            {
                xrl.Request.gamertag = (new RandomEx()).GenerateRandomString("XEN", 15);
            }

            //BirthDate overrides ParentalControl input;
            if (param.paramDict.ContainsKey(XeUserParam.birthdate))
            {
                xrl.Request.birthdate = (DateTime)param.paramDict[XeUserParam.birthdate];
            }
            else if ((param.paramDict.ContainsKey(XeUserParam.parentalControlGroup)))
            {
                ParentalControlGroup parentalControlGroup = (ParentalControlGroup)param.paramDict[XeUserParam.parentalControlGroup];
                xrl.Request.birthdate = XeUserParam.GetBirthDate(xrl.Request.countryId, parentalControlGroup);
            }
            else
            {
                xrl.Request.birthdate = XeUserParam.GetBirthDate(xrl.Request.countryId, ParentalControlGroup.Open);
            }

            if (param.paramDict.ContainsKey(XeUserParam.passportUserSessionToken))
            {
                xrl.Request.signedUserPassportPuid = (byte[])param.paramDict[XeUserParam.passportUserSessionToken];
            }
            else
            {
                string memberName, password;
                ulong userPassportPuid;
                xrl.Request.signedUserPassportPuid = XeUserParam.CreatePassportSessionToken(xrl.Request.countryId,
                                                                                            out memberName,
                                                                                            out password,
                                                                                            out userPassportPuid);
                outputDict.Add(XeUserParam.passportMemberName, memberName);
                outputDict.Add(XeUserParam.passportPassword, password);
                outputDict.Add(XeUserParam.userPassportPuid, userPassportPuid);
            }

            //If ParentalControlGroup info kicks in when no other info can be used to decide;
            if (param.paramDict.ContainsKey(XeUserParam.passportOwnerSessionToken))
            {
                xrl.Request.signedOwnerPassportPuid = (byte[])param.paramDict[XeUserParam.passportOwnerSessionToken];
            }
            else if (ParentalControlGroup.Open == XeUserParam.GetParentalControlGroup(xrl.Request.countryId, xrl.Request.birthdate) )
            {
                xrl.Request.signedOwnerPassportPuid = xrl.Request.signedUserPassportPuid;
            }
            else
            {
                xrl.Request.signedOwnerPassportPuid = XeUserParam.CreatePassportSessionToken(xrl.Request.countryId);
            }

            xrl.Request.email = (string)param.paramDict[XeUserParam.email];
            xrl.Request.languageId = (ushort)param.paramDict[XeUserParam.languageId];
            xrl.Request.msftOptIn = Convert.ToBoolean(param.paramDict[XeUserParam.msftOptIn]);
            xrl.Request.partnerOptIn = Convert.ToBoolean(param.paramDict[XeUserParam.partnerOptIn]);
            xrl.Request.isFreeGamertagChangeEligible = false;
            xrl.Request.offlineXuid = (ulong) param.paramDict[XeUserParam.offlineXuid];
        }

        private RetryHelper.ExecutionResult ExecuteCreateLightWgtAccountRequest(XRLCreateUserAndBillableAccount xrl, uint[] xErrsAllowedToRetry)
        {
            bool succeeded = false;
            try
            {
                succeeded = xrl.Execute();
            }
            //At this level, SocketException should not disturb the test.
            //Find out the SocketException information for analysis and evaluation.
            catch (System.Net.Sockets.SocketException e)
            {
                Global.RO.Warn("XRL execution has SocketException");
                Global.RO.Warn("Error code 0X{0:X}", e.ErrorCode);
                Global.RO.Warn("SocketError {0}", e.SocketErrorCode.ToString("F"));
                Global.RO.Warn("Error message {0}", e.Message);
                return RetryHelper.ExecutionResult.Fail_Retryable;
            }

            if (succeeded)
            {
                if (xrl.Response.userPuid == 0)
                {
                    throw new UnexpectedTestResultException("LightWgtUser is created with UserPuid as 0; something is seriously wrong!");
                }
                outputDict.Add(XeUserParam.response, xrl);
                UacsCommon.ShowServerID(xrl.Response.userPuid);
                return RetryHelper.ExecutionResult.Success;
            }
            else if (Array.Exists(xErrsAllowedToRetry, s => s == xrl.XErr))
            {
                Global.RO.Warn("User Creation Failed With Known Error {0}, Retrying ...", xrl.GetDumpString());
                return RetryHelper.ExecutionResult.Fail_Retryable;
            }
            else
                //return RetryHelper.ExecutionResult.Fail_NoRetry;
                throw new UnexpectedTestResultException("XeUser creation failed: " + xrl.GetDumpString());
        }

        //To purchas with token, lightweight user needs to have account info
        private bool SetAccountInfoRequestExecution(XeUserParam param, ulong userPuid)
        {
            if (param == null || param.paramDict == null)
            {
                throw new UnexpectedTestResultException("Input param is null.");
            }

            XRLXeSetAccountInfo request = new XRLXeSetAccountInfo();
            //
            byte countryId = (byte)param.paramDict[XeUserParam.countryId];
            if (param.paramDict.ContainsKey(XeUserParam.birthdate))
            {
                request.Birthdate = (DateTime)param.paramDict[XeUserParam.birthdate];
            }
            else if ((param.paramDict.ContainsKey(XeUserParam.parentalControlGroup)))
            {
                ParentalControlGroup parentalControlGroup = (ParentalControlGroup)param.paramDict[XeUserParam.parentalControlGroup];
                request.Birthdate = XeUserParam.GetBirthDate(countryId, parentalControlGroup);
            }
            else
            {
                request.Birthdate = XeUserParam.GetBirthDate(countryId, ParentalControlGroup.Open);
            }

            request.UserPuid = userPuid;
            request.FirstName = "John";
            request.LastName = "Smith";
            request.Email = (string)param.paramDict[XeUserParam.email]; ;
            request.LanguageId = (ushort)param.paramDict[XeUserParam.languageId];
            request.MsftOptIn = Convert.ToByte(param.paramDict[XeUserParam.msftOptIn]);
            request.PartnerOptIn = Convert.ToByte(param.paramDict[XeUserParam.partnerOptIn]);
            request.AddressInfo = new AddressInfoData();
            request.AddressInfo.SetDefaultAddress((XeUser.Country)countryId);
            request.PhoneInfo = XeUserParam.GeneratePhoneInfo((XeUser.Country)countryId);
            outputDict[XeUserParam.addressInfo] = request.AddressInfo;
            outputDict[XeUserParam.phoneInfo] = request.PhoneInfo;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XeSetAccountInfo failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeSetAccountInfo returned XErr=0x{0:x}", request.XErr));

            Global.RO.Info("Account Information has been set for user 0x{0:x}.", request.UserPuid);

            return true;
        }

        private void UpdateGamerTag(XRLCreateUserAndBillableAccount xrl)
        {
            RandomEx rnd = new RandomEx();
            xrl.Request.gamertag = rnd.GenerateRandomString("XEN", 15);
        }

    }  /* *+++++ END CLASS LIGHTWGTXEUSER ++++* */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLGetDependentSignedPuid.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


namespace ServerTestFramework.LiveService.UserAccount
{
#if false    
    public class PuidObj : WireData
    {
        private ulong _value;

        private PuidObj(ulong value)
        {
            _value = value;
        }

        public override int GetHashCode()
        {
            return _value.GetHashCode();
        }

        public override string ToString()
        {
            // the one way to display an HResult
            return "0x" + _value.ToString("X016");
        }

        public static implicit operator PuidObj(ulong value)
        {
            return new PuidObj(value);
        }

        public static implicit operator ulong(PuidObj PuidObj)
        {
            // convert a puid to ulong
            return PuidObj._value;
        }


        // explicit cast...
        public static explicit operator PuidObj(long value)
        {
            return new PuidObj((ulong)value);
        }

        public static explicit operator long(PuidObj PuidObj)
        {
            return (long)PuidObj._value;
        }

    }
#endif

    public class XRLXeGetDependentSignedPuidRequest : XRLPayload
    {
        public PassportToken ownerSessionToken;

        public Puid targetXuid;

        public XRLXeGetDependentSignedPuidRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/GetDependentSignedPuid.ashx";
        }

        public bool Execute(out XRLXeGetDependentSignedPuidResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetDependentSignedPuidResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetDependentSignedPuidResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            Console.WriteLine("Execute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeGetDependentSignedPuidResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetDependentSignedPuidResponse : XRLPayload
    {
        public PassportToken sessionToken;    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLGenerateGamertag.cs ===
using System;
using System.Collections.Generic;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLGenerateGamertag : XRLPayload<GenerateGamertagRequest, GenerateGamertagResponse>
    {
        //virtual interface to use
        public string ServerInterface=Interface.xuacs;

        //automatically set sginfo to match the request for these items
        public bool AutoSGInfoMachinePuid=true;
        public bool AutoSGInfoServices=true;

        //automatically create and cache these items
        public bool AutoCreateMachine=true;

        //
        private Dictionary<string, ulong> cachedMachine=new Dictionary<string, ulong>();

        public XRLGenerateGamertag()
        {
            ManualPopulateSlot();

            Slot.machinePuid=0;
            Slot.ClearServices();
        }

        /// <summary> Perform the create request, creating a machine if required </summary>
        /// <returns>True if the request is successful, False otherwise.</returns>
        public override bool Execute()
        {
            //create user/machine if needed
            if (AutoCreateMachine)
            {
                if (!cachedMachine.ContainsKey(Global.XEnv.GetEnv()))
                {
                    cachedMachine[Global.XEnv.GetEnv()]=MachineEditor.CreateNew().Id;
                }

                Request.machinePuid=cachedMachine[Global.XEnv.GetEnv()];
            }

            //set auto sg info
            if (AutoSGInfoMachinePuid)
            {
                Slot.machinePuid=Request.machinePuid;
                Slot.SetClientType(CSGInfo.ClientInfo.ToClientType(Slot.machinePuid));
            }

            if (AutoSGInfoServices)
            {
                Slot.ClearServices();
                Slot.AddService(XOService.User_Account);
            }

            //execute
            return Execute(Global.XEnv.GetVirtualInterface(ServerInterface));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLGetNoAgeOut.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLGetNoAgeOut : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        protected override string GetServiceName()
        {
            return "/xuacs/GetNoAgeOut.ashx";
        }

        public bool Execute(out XRLGetNoAgeOutResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLGetNoAgeOutResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLGetNoAgeOutResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLGetNoAgeOutResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLGetNoAgeOutResponse : XRLPayload
    {
        public bool  noAgeOut;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XrlGetUserBillingNotification.cs ===
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    // -- protocol

    public class XRLGetUserBillingNotifications: XRLPayload<GetUserBillingNotificationsRequest, GetUserBillingNotificationsResponse>
    {
        public bool AutoSGInfo=true;
        private static ulong cachedMachine=0;

        //Do the request using it, creating a new machine puid to use if not already done.
        public override bool Execute()
        {
            if (cachedMachine==0)
            {
                XmacsClient xmacs=new XmacsClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                xmacs.SignInXmacs();
                cachedMachine=xmacs.GetMachinePuid();
            }

            return Execute(cachedMachine);
        }

        //Do the request from an existing machine account
        public bool Execute(ulong machinePuid)
        {
            if (AutoSGInfo)
            {
                ManualSlotSetup=true;
                SetDefaultValidSGInfo(machinePuid, Request.userPuid, ref Slot);
            }

            // to support schema version
            if (!CustomHeader.Contains("X-Schema-Ver:"))
                CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            return Execute(Global.XEnv.GetVirtualInterface(Interface.xuacs));
        }

        //Sets fields in SGInfo needed to make a valid request
        public static void SetDefaultValidSGInfo(ulong machinePuid, ulong userPuid, ref CSGInfo sgInfo)
        {
            sgInfo.machinePuid=machinePuid;
            sgInfo.userPuid3=userPuid;
            sgInfo.ClearServices();
            sgInfo.AddService(XOService.User_Account);

            if (machinePuid>=0xfa00000000000000 && machinePuid<=0xfaffffffffffffff)
            {
                sgInfo.SetClientType(CSGInfo.ClientType.Xenon);
            }
            else if (machinePuid>=0xfb00000000000000 && machinePuid<=0xfbffffffffffffff)
            {
                sgInfo.SetClientType(CSGInfo.ClientType.PC);
            }
        }
    }

    // -- helpers

    public class BillingNotificationHelpers
    {
        //converts a UserBillingNotification to a string for display
        public static string NotificationToString(UserBillingNotification noti)
        {
            string s="";
            s+="\n notificationDate: "+noti.notificationDate;
            s+="\n isReadNotification: "+noti.isReadNotification;
            s+="\n notificationId: "+noti.notificationId;
            if (noti.notificationId==UserBillingNotification.notificationIdSubscriptionExpiration) s+=" (SubscriptionExpiration)";
            if (noti.notificationId==UserBillingNotification.notificationIdCreditCardDecline) s+=" (CreditCardDecline)";
            s+="\n creditCardType: "+noti.creditCardType;
            s+="\n accountNumberLastFour: "+noti.accountNumberLastFour;
            s+="\n declineReasonId: "+noti.declineReasonId;
            s+="\n subscriptionExpirationDate: "+noti.subscriptionExpirationDate;
            s+="\n subscriptionIsTrial: "+noti.subscriptionIsTrial;
            s+="\n subscriptionTitleId: "+noti.subscriptionTitleId;
            s+="\n subscriptionOfferId: "+noti.subscriptionOfferId;
            return s;
        }

        //if true, all calls to add a notification will generate debug output
        public static bool VerboseNotificationAdds=false;

        //adds a billing notification to the user for their subscription expiring
        public static void AddUserBillingNotificationSubscriptionExpire(ulong puid, System.Guid guid, System.DateTime notificationDate, byte flags, System.DateTime expireDate)
        {
            AddUserBillingNotification(puid, guid, UserBillingNotification.notificationIdSubscriptionExpiration, notificationDate, flags, expireDate, null, null, null);
        }

        //adds a billing notification to the user for their credit card being declined
        public static void AddUserBillingNotificationCCDecline(ulong puid, System.Guid guid, System.DateTime notificationDate, byte flags, byte ccType, short ccLastFour, byte ccDeclineReason)
        {
            AddUserBillingNotification(puid, guid, UserBillingNotification.notificationIdCreditCardDecline, notificationDate, flags, null, ccType, ccLastFour, ccDeclineReason);
        }

        //calls p_xuacs_user_billing_notifications_add
        public static void AddUserBillingNotification(ulong puid, System.Guid guid, int eventId, System.DateTime notificationDate, byte flags, System.Nullable<System.DateTime> expireDate, System.Nullable<byte> ccType, System.Nullable<short> ccLastFour, System.Nullable<byte> ccDeclineReason)
        {
            if (VerboseNotificationAdds)
            {
                Global.RO.Debug("Calling p_xuacs_user_billing_notifications_add: puid="+puid+" guid="+guid+" eventId="+eventId+" notificationDate="+notificationDate+" flags="+flags+" expireDate="+expireDate+" ccType="+ccType+" ccLastFour="+ccLastFour+" ccDeclineReason="+ccDeclineReason);
            }

            int bucket=UodbWS.GetHashBucket(puid);
            string expireDateValue=(expireDate==null?"null":"'"+expireDate+"'");
            string ccTypeValue=(ccType==null?"null":""+(int)ccType);
            string ccLastFourValue=(ccLastFour==null?"null":""+(int)ccLastFour);
            string ccDeclineReasonValue=(ccDeclineReason==null?"null":""+(int)ccDeclineReason);
            UodbWS.ExecuteSQLNonQuery("exec p_xuacs_user_billing_notifications_add "+(long)puid+", '"+guid+"', "+eventId+", '"+notificationDate+"', "+(int)flags+", "+expireDateValue+", "+ccTypeValue+", "+ccLastFourValue+", "+ccDeclineReasonValue+", "+bucket, puid);
        }

        public static void AddUserSubscriptionNotification(ulong puid, System.Guid trackingGuid, System.DateTime notificationDate, System.DateTime endDate, uint titleId, System.Guid offerId, ulong uodbOfferId, bool isTrial)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.SetHashVal(puid);
                ws.StoredProc = "dbo.p_xuacs_user_subscription_notifications_add";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", puid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.AddParameter("@i_event_id", UserBillingNotification.notificationIdSubscriptionExpiration);
                ws.AddParameter("@dt_arrival_datetime", notificationDate);
                ws.AddParameter("@dt_end_date", endDate);
                ws.AddParameter("@i_title_id", titleId);
                ws.AddParameter("@uid_offer_id", offerId);
                ws.AddParameter("@bi_offer_id", uodbOfferId);
                ws.AddParameter("@ti_is_trial", (isTrial ? 1 : 0));
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLGetSubscriptionInfo.cs ===
using xonline.common.service;
using xonline.common.config;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLGetSubscriptionInfo: XRLPayload<GetSubscriptionInfoRequest, GetSubscriptionInfoResponse>
    {
        public bool AutoSGInfo=true;
        private static ulong cachedMachine=0;

        //Do the request using it, creating a new machine puid to use if not already done.
        public override bool Execute()
        {
            if (cachedMachine==0)
            {
                XmacsClient xmacs=new XmacsClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                xmacs.SignInXmacs();
                cachedMachine=xmacs.GetMachinePuid();
            }

            return Execute(cachedMachine);
        }

        //Do the request from an existing machine account
        public bool Execute(ulong machinePuid)
        {
            if (AutoSGInfo)
            {
                ManualSlotSetup=true;
                SetDefaultValidSGInfo(machinePuid, Request.userPuid, ref Slot);
            }

            return Execute(Global.XEnv.GetVirtualInterface(Interface.xuacs));
        }

        //Sets fields in SGInfo needed to make a valid request
        public static void SetDefaultValidSGInfo(ulong machinePuid, ulong userPuid, ref CSGInfo sgInfo)
        {
            sgInfo.machinePuid=machinePuid;
            sgInfo.userPuid3=userPuid;
            sgInfo.ClearServices();
            sgInfo.AddService(XOService.User_Account);

            if (machinePuid>=0xfa00000000000000 && machinePuid<=0xfaffffffffffffff)
            {
                sgInfo.SetClientType(CSGInfo.ClientType.Xenon);
            }
            else if (machinePuid>=0xfb00000000000000 && machinePuid<=0xfbffffffffffffff)
            {
                sgInfo.SetClientType(CSGInfo.ClientType.PC);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLGetUserTenure.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLGetUserTenure : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;
        
        public XRLGetUserTenure()
        {
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/GetUserTenure.ashx";
        }

        public bool Execute(out XRLGetUserTenureResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLGetUserTenureResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLGetUserTenureResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLGetUserTenureResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLGetUserTenureResponse : XRLPayload
    {
        public int TenureLevel;
        public int TenureMilestone;
        public DateTime NextMilestoneDate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLPassportAddProof.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class ProofData : WireData
    {
        /// <summary>
        /// Enumeration detailing the type of the strong proof
        /// </summary>
        public byte proofType;

        /// <summary>
        /// Protocol element to hold the length of the string
        /// </summary>
        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort proofDataLength;

        /// <summary>
        /// The actual data of the strong proof.
        /// </summary>
        [WireInfo(SizeParam = "proofDataLength")]
        public string proofData;
    }

    // Test serializer does not support inheritence, so must copy the fields over from the
    // base class in order for the serialization to work properly.
    public class ProofStatus : WireData
    {
        /// <summary>
        /// Enumeration detailing the type of the strong proof
        /// </summary>
        public byte proofType;

        /// <summary>
        /// Protocol element to hold the length of the string
        /// </summary>
        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort proofDataLength;

        /// <summary>
        /// The actual data of the strong proof.
        /// </summary>
        [WireInfo(SizeParam = "proofDataLength")]
        public string proofData;

        /// <summary>
        /// Flag to state if the strong proof has already been confirmed
        /// </summary>
        public bool isConfirmed;
    }

    public class XRLPassportAddProof : XRLPayload
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        /// <summary>
        /// Standard Xbox protocol element to state that this operation should be
        /// password verified.  It represents the signed passport puid of the account
        /// being accessed.
        /// </summary>
        public PassportToken sessionToken;

        /// <summary>
        /// The strong proof data
        /// </summary>
        public ProofData proofData;

        protected override string GetServiceName()
        {
            return "/xuacs/PassportAddProof.ashx";
        }

        public bool Execute(out XRLPassportAddProofResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLPassportAddProofResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLPassportAddProofResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            Console.WriteLine("Execute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLPassportAddProofResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLPassportAddProofResponse : XRLPayload
    {
        /// <summary>
        /// Flag to state if the strong proof has already been confirmed
        /// </summary>
        public bool isConfirmed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLMergeUserEntitlements.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLMergeUserEntitlementsRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong srcUserPuid;

        [XRLPayloadFld(IsUPuid = true)]
        public ulong destUserPuid;

        public PassportToken signedUserPassportPuidToDrop;
        public PassportToken signedUserPassportPuidToKeep;

        public bool transferPoints;

        public Guid trackingGuid;


        protected override string GetServiceName()
        {
            return "/xuacs/MergeUserEntitlements.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLPassportCreateGenerated.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;

using xonline.common.service;
using xonline.common.config;
using xonline.common.protocol;
using xonline.core.wiredata;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLPassportCreateGenerated : XRLPayload<PassportCreateGeneratedRequest, PassportCreateGeneratedResponse>
    {
        //virtual interface to use
        public string ServerInterface=Interface.xuacs;

        //automatically set sginfo to match the request for these items
        public bool AutoSGInfoMachinePuid=true;
        public bool AutoSGInfoServices=true;

        //automatically create and cache these items
        public bool AutoCreateMachine=true;

        //
        private Dictionary<string, ulong> cachedMachine=new Dictionary<string, ulong>();

        private SymmetricKey symmetricKey = new SymmetricKey();
        private string password;
        
        public XRLPassportCreateGenerated()
        {
            ManualPopulateSlot();

            Slot.machinePuid=0;
            Slot.ClearServices();
        
            Request.sessionKey  = symmetricKey.Key;
            Request.sessionIV   = symmetricKey.IV;
        }

        public string Password
        {   
            get{ return password; }
        }
        
        /// <summary> Perform the create request, creating a machine if required </summary>
        /// <returns>True if the request is successful, False otherwise.</returns>
        public override bool Execute()
        {
            //create user/machine if needed
            if (AutoCreateMachine)
            {
                if (!cachedMachine.ContainsKey(Global.XEnv.GetEnv()))
                {
                    cachedMachine[Global.XEnv.GetEnv()]=MachineEditor.CreateNew().Id;
                }

                Request.machinePuid=cachedMachine[Global.XEnv.GetEnv()];
            }

            //set auto sg info
            if (AutoSGInfoMachinePuid)
            {
                Slot.machinePuid=Request.machinePuid;
                Slot.SetClientType(CSGInfo.ClientInfo.ToClientType(Slot.machinePuid));
            }

            if (AutoSGInfoServices)
            {
                Slot.ClearServices();
                Slot.AddService(XOService.User_Account);
            }

            // to support schema version
            if (!CustomHeader.Contains("X-Schema-Ver:"))
                CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(Request.SchemaVersion) + "\r\n";
            
            //execute
            bool bRC = Execute(Global.XEnv.GetVirtualInterface(ServerInterface));

            if ( bRC && null != Response )
            {
                byte[] bytePassword;
                ASCIIEncoding ascii = new ASCIIEncoding();
                
                bytePassword = symmetricKey.Decrypt( Response.encryptedPassword );
                password = ascii.GetString( bytePassword );
            }

            return bRC;            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLPassportGetProofs.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLPassportGetProofs : XRLPayload
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        /// <summary>
        /// Standard Xbox protocol element to state that this operation should be
        /// password verified.  It represents the signed passport puid of the account
        /// being accessed.
        /// </summary>
        public PassportToken sessionToken;

        protected override string GetServiceName()
        {
            return "/xuacs/PassportGetProofs.ashx";
        }

        public bool Execute(out XRLPassportGetProofsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLPassportGetProofsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLPassportGetProofsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            Console.WriteLine("Execute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLPassportGetProofsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLPassportGetProofsResponse : XRLPayload
    {
        /// <summary>
        /// Protocol element to hold the array length.
        /// </summary>
        public ushort proofsLength;

        /// <summary>
        /// The list of strong proofs returned from passport
        /// </summary>
        [WireInfo(SizeParam = "proofsLength")]
        public ProofStatus[] proofs;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLPassportGetProofTypes.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLPassportGetProofTypes : XRLPayload
    {
        /// <summary>
        /// The Xuid of the account that is attempting to perform the operation.
        /// Since the console can have multiple users attached, need to distinguish
        /// which user is making the request.
        /// </summary>
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        /// <summary>
        /// The console where the user make the request.
        /// </summary>
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        protected override string GetServiceName()
        {
            return "/xuacs/PassportGetProofTypes.ashx";
        }

        public bool Execute(out XRLPassportGetProofTypesResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLPassportGetProofTypesResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLPassportGetProofTypesResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            Console.WriteLine("Execute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLPassportGetProofTypesResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLPassportGetProofTypesResponse : XRLPayload
    {
        /// <summary>
        /// Protocol element to hold the array length
        /// </summary>
        public int proofTypesLength;

        /// <summary>
        /// Array of proof types that are tied to the account that can be
        /// queried without knowledge of the password.
        /// </summary>
        [WireInfo(SizeParam = "proofTypesLength")]
        public byte[] proofTypes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLPreviewSwitchUserCountry.cs ===
using xonline.common.config;
using xonline.common.protocol.useraccount;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLPreviewSwitchUserCountry : XRLPayload<PreviewSwitchUserCountryRequest, PreviewSwitchUserCountryResponse>
    {
        public XRLPreviewSwitchUserCountry()
        {
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLSwitchUserDateOfBirth.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLSwitchUserDateOfBirth : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        public DateTime newDateOfBirth;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public bool   TransferBalance = true;

        
        public XRLSwitchUserDateOfBirth()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/SwitchUserDateOfBirth.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLSwitchUserCountry.cs ===
using System;
using System.IO;
using System.Net;

using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLSwitchUserCountry : XRLPayload
    {
        public Guid TrackingGuid;

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        public AddressInfoData AddressInfo;

        public byte CountryId;

        public int CultureId;

        [WireInfo(Serialize=false)]
        public bool V2;

        public XRLSwitchUserCountry()
        {
            TrackingGuid = Guid.NewGuid();

            // need to use HTTP auth for web-only requests
            UseHttpAuth = true;

            // need to be the web_title_id to use this API
            Slot.titleId = XOn.WEB_TITLE_ID;
        }

        public XRLSwitchUserCountry(ulong userPuid, byte newCountryId, ushort newLanguageId)
            : this(userPuid, newCountryId, newLanguageId, false)
        {
        }

        public XRLSwitchUserCountry(ulong userPuid, byte newCountryId, ushort newLanguageId, bool V2)
            : this()
        {
            AddressInfoData newAddress = new AddressInfoData();
            newAddress.SetDefaultAddress((XeUser.Country)newCountryId);

            this.UserPuid = userPuid;
            this.AddressInfo = newAddress;
            this.CountryId = newCountryId;
            this.CultureId = CountryLanguage.GetCultureId(newCountryId, newLanguageId);
            this.V2 = V2;
        }

        protected override string GetServiceName()
        {
            if ( V2 )
            {
                return "/xuacs/SwitchUserCountryV2.ashx";
            }
            else
            {
                return "/xuacs/SwitchUserCountry.ashx";
            }
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if (bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLSwitchOwnerPassport.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLSwitchOwnerPassport : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = MachineEditor.CreateNew().Id;
        public uint   TitleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOldOwnerPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedNewOwnerPassportPuid;

        public bool   TransferBalance = true;

        
        public XRLSwitchOwnerPassport()
        {
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/SwitchOwnerPassport.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeABCHGetContactlistGamertags.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeABCHGetContactlistGamertags : XRLPayload
    {    
        static ushort QueryAtSignupForUsersInABCHandXBL         = 0x0001;
        static ushort QueryAtLoginForUsersInABCHandXBL          = 0x0002;

        public ulong userPuid;
        public ushort requestFlags; 

        public bool queryAtSignupForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtSignupForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtSignupForUsersInABCHandXBL, value, ref requestFlags);
            }
        }

        public bool queryAtLoginForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtLoginForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtLoginForUsersInABCHandXBL, value, ref requestFlags);
            }
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeABCHGetContactlistGamertags.ashx";
        }

        public bool Execute(out XRLXeABCHGetContactlistGamertagsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeABCHGetContactlistGamertagsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeABCHGetContactlistGamertagsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeABCHGetContactlistGamertagsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeABCHGetContactlistGamertagsResponse : XRLPayload
    {
        public ushort ABCHGetContactlistItemCount;
        [WireInfo(SizeParam="ABCHGetContactlistItemCount")]
        public XRLABCHGetContactlistItem [] items;
    }

    public class XRLABCHGetContactlistItem : XRLPayload
    {
        static ushort UserInABCH            = 0x0001;
        static ushort UserInXBL             = 0x0002;

        public ulong puid;
        public ushort gamertagLength = 0;
        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;
        public ushort pmnLength = 0;
        [WireInfo(SizeParam="pmnLength")]
        public string pmn;
        public ushort displayNameLength = 0;
        [WireInfo(SizeParam="displayNameLength")]
        public string displayName;
        public ushort responseFlags; 

        public bool userInABCH
        {
            get
            {
                return IsFlagSet(UserInABCH, responseFlags);
            }
            set
            {
                SetFlag(UserInABCH, value, ref responseFlags);
            }
        }

        public bool userInXBL
        {
            get
            {
                return IsFlagSet(UserInXBL, responseFlags);
            }
            set
            {
                SetFlag(UserInXBL, value, ref responseFlags);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAcknowledgeDowngrade.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAcknowledgeDowngrade : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserId;
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeAcknowledgeDowngrade.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAddDependent.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAddDependentRequest : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        // The xuid of the new dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        // The xuid of the new owner. This user must be signed in.
        [XRLPayloadFld(IsUPuid = true)]
        public ulong ownerPuid = 0;

        // The passport credentials of the old owner. If the dependent was an independent
        // account, this will be the passport of the dependent. If the dependent was owned
        // by another account and is being transferred, this is the old owner.
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldOwnerPassportPuid;

        public XRLXeAddDependentRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/AddDependent.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeAddDependentRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeAddDependentRequest Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }



        public void SetSGSlotMachinePuid(ulong machinePuid)
        {
            ManualPopulateSlot();
            Slot.machinePuid = machinePuid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAcceptTermsOfService.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAcceptTermsOfService : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong userPuid = 0;        
        [XRLPayloadFld(IsMPuid=true)]
        public ulong machinePuid = 0;        
        public uint titleId = 0;        
        public uint serviceType = 0;
        
        public XRLXeAcceptTermsOfService()
        {
            this.titleId = 0xFFFD0000; // Zune Title ID by default
        }

        protected override string GetServiceName()
        {
            return "/xuacs/AcceptTermsOfService.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAddPaymentInstrumentEx.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAddPaymentInstrumentEx : XRLPayload
    {
        public enum PaymentInstrumentTypeEnum
        {
            None            = 0,
            CreditCard      = 1,
            DirectDebit     = 2
        }

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0xfa00000012341234;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType;
        public CreditCardInfoDataEx CreditCardInfoEx;
        public DirectDebitInfoDataEx DirectDebitInfoEx;

        protected override string GetServiceName()
        {
            return "/xuacs/XeAddPaymentInstrumentEx.ashx";
        }

        public override bool Execute()
        {
            throw new Exception("You're throwing away the response by calling Execute(). Please call Execute(out XRLXeAddPaymentInstrumentResponse Response) instead.");
        }

        public bool Execute(out XRLXeAddPaymentInstrumentResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeAddPaymentInstrumentResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAddPaymentInstrumentResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeAddPaymentInstrumentResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAddPaymentInstrument.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAddPaymentInstrument : XRLPayload
    {
        public enum PaymentInstrumentTypeEnum
        {
            None            = 0,
            CreditCard      = 1,
            DirectDebit     = 2
        }

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0xfa00000012341234;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;

        public XRLXeAddPaymentInstrument()
        {
            // insert some dummy data
            this.PaymentInstrumentType = (byte)PaymentInstrumentTypeEnum.CreditCard;
            PopulateAddressInfo(out this.AddressInfo);
            PopulatePhoneInfo(out this.PhoneInfo);
            PopulateCreditCardInfo(out this.CreditCardInfo);
            PopulateDirectDebitInfo(out this.DirectDebitInfo);
        }

        private static void PopulateAddressInfo(out AddressInfoData address)
        {
            address = new AddressInfoData();
            address.Street1 = "4455 148th Ave NE";
            address.Street2 = "";
            address.City = "Bellevue";
            address.District = "";
            address.State = "WA";
            address.PostalCode = "98007";
        }

        private static void PopulatePhoneInfo(out PhoneInfoData phone)
        {
            phone = new PhoneInfoData();
            phone.PhonePrefix = "425";
            phone.PhoneNumber = "861-6245";
            phone.PhoneExtension = "";
        }

        private static void PopulateCreditCardInfo(out CreditCardInfoData creditCard)
        {
            creditCard = new CreditCardInfoData();
        
            string ccn = ServerTestFramework.Utilities.CreditCardRandomizer.GetRandomAccountNumber("visa");

            creditCard.AccountHolderName  = "Mike Martinsen";
            creditCard.AccountNumber      = ccn;
            creditCard.CardType           = (byte)CreditCardInfoData.CreditCardType.Visa;
            creditCard.CcvNumber          = "123";
            creditCard.ExpirationDate     = DateTime.UtcNow.AddYears(2);
        }

        private static void PopulateDirectDebitInfo(out DirectDebitInfoData debitInfo)
        {
            // Validate that this data meets any check constraints done
            // by the SCS 1box.
            debitInfo = new DirectDebitInfoData();

            // german direct debit 
            ServerTestFramework.Utilities.DirectDebitRandomizer ddr = new ServerTestFramework.Utilities.DirectDebitRandomizer("DE");

            ddr.Randomize();

            debitInfo.AccountHolderName  = "Mike Martinsen";
            debitInfo.AccountNumber      = ddr.AccountNumber;
            debitInfo.BankCode           = ddr.BankCode;
            debitInfo.BranchCode         = ddr.BranchCode;
            debitInfo.CheckDigits        = ddr.CheckDigits;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeAddPaymentInstrument.ashx";
        }

        public override bool Execute()
        {
            throw new Exception("You're throwing away the response by calling Execute(). Please call Execute(out XRLXeAddPaymentInstrumentResponse Response) instead.");
        }

        public bool Execute(out XRLXeAddPaymentInstrumentResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeAddPaymentInstrumentResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAddPaymentInstrumentResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeAddPaymentInstrumentResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeAddPaymentInstrumentResponse : XRLPayload
    {
        public ushort PaymentInstrumentIdLength = 0;
        [WireInfo(SizeParam="PaymentInstrumentIdLength")]
        public string PaymentInstrumentId;
    }

    public class AddressInfo : XRLPayload
    {
        public ushort Street1Length = 0;
        [WireInfo(SizeParam="Street1Length")]
        public string Street1 = "";
        public ushort Street2Length = 0;
        [WireInfo(SizeParam="Street2Length")]
        public string Street2 = "";
        public ushort CityLength = 0;
        [WireInfo(SizeParam="CityLength")]
        public string City = "";
        public ushort DistrictLength = 0;
        [WireInfo(SizeParam="DistrictLength")]
        public string District = "";
        public ushort StateLength = 0;
        [WireInfo(SizeParam="StateLength")]
        public string State = "";
        public ushort PostalCodeLength = 0;
        [WireInfo(SizeParam="PostalCodeLength")]
        public string PostalCode = "";
    }

    public class PhoneInfo : XRLPayload
    {
        public ushort PhonePrefixLength;
        [WireInfo(SizeParam="PhonePrefixLength")]
        public string PhonePrefix = "";
        public ushort PhoneNumberLength;
        [WireInfo(SizeParam="PhoneNumberLength")]
        public string PhoneNumber = "";
        public ushort PhoneExtensionLength;
        [WireInfo(SizeParam="PhoneExtensionLength")]
        public string PhoneExtension = "";
    }

    public class CreditCardInfo : XRLPayload
    {
        public byte     CardType;
        public ushort   AccountHolderNameLength = 0;
        [WireInfo(SizeParam="AccountHolderNameLength")]
        public string   AccountHolderName = "";
        public ushort   AccountNumberLength = 0;
        [WireInfo(SizeParam="AccountNumberLength")]
        public string   AccountNumber = "";
        public ushort   CcvNumberLength = 0;
        [WireInfo(SizeParam="CcvNumberLength")]
        public string   CcvNumber = "";
        public DateTime ExpirationDate = new DateTime(2001,11,15);
    }

    public class DirectDebitInfo : XRLPayload
    {
        public ushort   AccountHolderNameLength = 0;
        [WireInfo(SizeParam="AccountHolderNameLength")]
        public string   AccountHolderName = "";
        public ushort   AccountNumberLength = 0;
        [WireInfo(SizeParam="AccountNumberLength")]
        public string   AccountNumber = "";
        public ushort BankCodeLength = 0;
        [WireInfo(SizeParam="BankCodeLength")]
        public string BankCode = "";
        public ushort BranchCodeLength = 0;
        [WireInfo(SizeParam="BranchCodeLength")]
        public string BranchCode = "";
        public ushort CheckDigitsLength = 0;
        [WireInfo(SizeParam="CheckDigitsLength")]
        public string CheckDigits = "";
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeAccountQuery.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeAccountQuery : XRLPayload
    {
        public uint RequestType;
        public ushort RequestBytesLength;
        [WireInfo(SizeParam="requestBytesLength")]
        public byte[] RequestBytes;
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeAccountQuery.ashx";
        }

        public bool Execute(out XRLXeAccountQueryResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeAccountQueryResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAccountQueryResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeAccountQueryResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeAccountQueryResponse : XRLPayload
    {
        public ushort ResponseBytesLength;
        [WireInfo(SizeParam="ResponseBytesLength")]
        public byte[] ResponseBytes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeChangeSubscriptionPaymentInstrument.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeChangeSubscriptionPaymentInstrument : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort ServiceInstanceIdLength = 0;
        [WireInfo(SizeParam="ServiceInstanceIdLength")]
        public string ServiceInstanceId;
        public ushort PaymentInstrumentIdLength = 0;
        [WireInfo(SizeParam="PaymentInstrumentIdLength")]
        public string PaymentInstrumentId;
        
        public XRLXeChangeSubscriptionPaymentInstrument()
        {
            this.MachinePuid = 0xfa00000012341234;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeChangeSubscriptionPaymentInstrument.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeCreateLiveAccount.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.utilities;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using xonline.common.service;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XeUser
    {
        public XRLXeCreateLiveAccount m_request;
        public XRLXeCreateLiveAccountResponse m_response;

        private bool m_createPassport = false;
        private byte[] m_passportUserSessionToken;
        private byte[] m_passportOwnerSessionToken;
        private byte m_countryId;
        private byte m_paymentInstrumentType = 0;
        private ulong m_userPuid = 0;


        public string PassportPassword = "";
        public ulong PassportPuid = 0;
        public string FirstName = "";
        public string LastName = "";
        public bool GenerateGamertag = false;
        public string Gamertag = "";
        public string PassportMemberName = "";
        public ulong OfferId = 0;
        public string BillingToken = "";
        public DateTime BirthDate;
        public string Email;
        public ushort LanguageId;
        public int ParentalControlGroup = 0;
        public byte MsftOptIn;
        public byte PartnerOptIn;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;
        public XRLXeCreateLiveAccountExtra CreateLiveAccountExtra = null;
        public XRLXeCreateLiveAccountEntryPoint CreateLiveAccountEntryPoint = null;


        public enum Language : ushort
        {
            en = 1,     //ENGLISH
            ja = 2,     //JAPANESE
            de = 3,     //GERMAN
            fr = 4,     //FRENCH
            es = 5,     //SPANISH
            it = 6,     //ITALIAN
            ko = 7,     //KOREAN
            zh = 8,     //TCHINESE (zh-CHT)
            pt = 9,     //PORTUGUESE
            szh = 10,   //SCHINESE (zh-CHS)
            pl = 11,    //POLISH
            ru = 12,    //RUSSIAN
            da = 13,    //DANISH
            fi = 14,    //FINNISH
            nb = 15,    //NORWEGIAN (Bokml)
            nl = 16,    //DUTCH
            sv = 17,    //SWEDISH
            cs = 18,    //CZECH
            el = 19,    //GREEK
            hu = 20     //HUNGARIAN
        }

        public enum Country : byte
        {
            AE = 1,   // United Arab Emirates
            AT = 5,   // Austria
            AU = 6,   // Australia
            BE = 8,   // Belgium
            BR = 13,  // Brazil
            CA = 16,  // Canada
            CH = 18,  // Switzerland
            CL = 19,  // Chile
            CN = 20,  // China
            CO = 21,  // Colombia
            CZ = 23,  // Czech Republic
            DE = 24,  // Germany
            DK = 25,  // Denmark
            ES = 31,  // Spain
            FI = 32,  // Finland
            FR = 34,  // France
            GB = 35,  // Great Britain
            GR = 37,  // Greece
            HK = 39,  // Hong Kong
            HU = 42,  // Hungary
            IE = 44,  // Ireland
            IN = 46,  // India
            IT = 50,  // Italy
            JP = 53,  // Japan
            KR = 56,  // Korea
            NL = 74,  // Netherlands
            MX = 71,  // Mexico
            NO = 75,  // Norway
            NZ = 76,  // new zealand
            PL = 82,  // Poland
            PT = 84,  // Portugal
            RU = 88,  // Russia
            SE = 90,  // Sweden
            SG = 91,  // Singapore
            TW = 101, // Taiwan
            US = 103, // United States
            ZA = 109, // South Africa
        };

        public static implicit operator XeUser(LightWgtXeUser temp)
        {
            //if pass in a null value, then return a null value;
            if (temp == null)
            {
                return null;
            }

            //if temp doesn't contain request and response info, that means temp is empty, then return null;
            if (!temp.outputDict.ContainsKey(XeUserParam.response))
            {
                return null;
            }
            CreateUserAndBillableAccountRequest req = ((XRLCreateUserAndBillableAccount)temp.outputDict[XeUserParam.response]).Request;
            CreateUserAndBillableAccountResponse resp = ((XRLCreateUserAndBillableAccount)temp.outputDict[XeUserParam.response]).Response;

            XeUser user1 = new XeUser();

            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_passportUserSessionToken", req, "signedUserPassportPuid");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_passportOwnerSessionToken", req, "signedOwnerPassportPuid");

            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_countryId", req, "countryId");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_userPuid", resp, "userPuid");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "Gamertag", req, "gamertag");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "BirthDate", req, "birthdate");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "Email", req, "email");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "LanguageId", req, "languageId");
            FieldAccessor.SetProperty(user1, "MsftOptIn",
                                        Convert.ToByte(FieldAccessor.GetProperty(req, "msftOptIn")));
            FieldAccessor.SetProperty(user1, "PartnerOptIn",
                                        Convert.ToByte(FieldAccessor.GetProperty(req, "partnerOptIn")));
            if (temp.outputDict.ContainsKey(XeUserParam.passportPassword))
            {
                FieldAccessor.SetProperty(user1, "PassportPassword", (string)(temp.outputDict[XeUserParam.passportPassword]));
            }
            if (temp.outputDict.ContainsKey(XeUserParam.passportMemberName))
            {
                FieldAccessor.SetProperty(user1, "PassportMemberName", (string)(temp.outputDict[XeUserParam.passportMemberName]));
            }
            if (temp.outputDict.ContainsKey(XeUserParam.addressInfo))
            {
                FieldAccessor.SetProperty(user1, "AddressInfo", (AddressInfoData)(temp.outputDict[XeUserParam.addressInfo]));
            }
            if (temp.outputDict.ContainsKey(XeUserParam.phoneInfo))
            {
                FieldAccessor.SetProperty(user1, "PhoneInfo", (PhoneInfoData)(temp.outputDict[XeUserParam.phoneInfo]));
            }

            return user1;
        }

        public static implicit operator XeUser(XeLiveAccountUser temp)
        {
            //if pass in a null value, then return a null value;
            if (temp == null)
            {
                return null;
            }

            //if temp doesn't contain request and response info, that means temp is empty, then return null;
            if (!temp.outputDict.ContainsKey(XeUserParam.request) ||
                !temp.outputDict.ContainsKey(XeUserParam.response))
            {
                return null;
            }
            XRLXeCreateLiveAccount req = (XRLXeCreateLiveAccount)temp.outputDict[XeUserParam.request];
            XRLXeCreateLiveAccountResponse resp = (XRLXeCreateLiveAccountResponse)temp.outputDict[XeUserParam.response];

            XeUser user1 = new XeUser();

            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_passportUserSessionToken", req, "SignedUserPassportPuid");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_passportOwnerSessionToken", req, "SignedOwnerPassportPuid");

            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_countryId", req, "CountryId");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "m_userPuid", resp, "UserPuid");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "Gamertag", req, "Gamertag");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "BirthDate", req, "Birthdate");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "Email", req, "Email");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "LanguageId", req, "LanguageId");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "MsftOptIn", req, "MsftOptIn");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "PartnerOptIn", req, "PartnerOptIn");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "AddressInfo", req, "AddressInfo");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "PhoneInfo", req, "PhoneInfo");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "CreditCardInfo", req, "CreditCardInfo");
            FieldAccessor.CopyFieldValueFromDiffObject(user1, "DirectDebitInfo", req, "DirectDebitInfo");

            return user1;
        }

        public byte[] PassportSessionToken
        {
            get { return m_passportUserSessionToken; }
            set { m_passportUserSessionToken = value; }
        }
        public byte[] PassportOwnerSessionToken
        {
            get { return m_passportOwnerSessionToken; }
            set { m_passportOwnerSessionToken = value; }
        }
        public ulong PassportUserPuid
        {
            get { return PassportUtilities.GetPuidFromSessionToken(this.m_passportUserSessionToken); }
            set { this.m_passportUserSessionToken = PassportUtilities.GenerateSessionToken(value, xrl.Slot.Key); }
        }
        public ulong PassportOwnerPuid
        {
            get { return PassportUtilities.GetPuidFromSessionToken(this.m_passportOwnerSessionToken); }
            set { this.m_passportOwnerSessionToken = PassportUtilities.GenerateSessionToken(value, xrl.Slot.Key); }
        }
        public PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum PaymentInstrumentType
        {
            get { return (PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum)m_paymentInstrumentType; }
            set { m_paymentInstrumentType = (byte)value; }
        }
        public ulong MachinePuid
        {
            get { return m_request.MachinePuid; }
            set { m_request.MachinePuid = value; }
        }
        public byte CountryId
        {
            get { return m_countryId; }
            set { m_countryId = value; }
        }
        public int Age
        {
            get
            {
                DateTime now = DateTime.UtcNow;
                int age = now.Year - BirthDate.Year;

                if ((BirthDate.Month > now.Month) ||
                    (BirthDate.Month == now.Month) &&
                    (BirthDate.Day > now.Day))
                {
                    age--;
                }

                return age;
            }
        }
        public bool IsSilverTier
        {
            get
            {
                return (OfferId == Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial));
            }
        }
        public uint XErr
        {
            get { return m_request.XErr; }
        }
        protected void SetAddress(Country countryCode)
        {
            AddressInfo = new AddressInfoData();
            AddressInfo.SetDefaultAddress(countryCode);
            m_countryId = (byte)countryCode;
        }


        public XeUser()
        {
            InitValues(false, true, "", Country.US);
        }

        public XeUser(bool createPassport)
        {
            InitValues(createPassport, true, "", Country.US);
        }

        public XeUser(bool createPassport, ulong machinePuid)
        {
            InitValues(createPassport, true, "", Country.US);
            m_request.MachinePuid = machinePuid;
        }

        public XeUser(bool createPassport, Country countryId)
        {
            InitValues(createPassport, true, "", countryId);
        }

        public XeUser(bool createPassport, string gamerTag)
        {
            InitValues(createPassport, false, gamerTag, Country.US);
        }

        public XeUser(bool createPassport, string gamerTag, Country countryId)
        {
            InitValues(createPassport, false, gamerTag, countryId);
        }

        public ulong Create()
        {
            SetDefaults();

            int retryCount = 0;
            do
            {
                bool succeeded = false;

                try
                {
                    succeeded = m_request.Execute(out m_response);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    Global.RO.Warn("XRL execution has SocketException");
                    Global.RO.Warn("Error code 0X{0:X}", e.ErrorCode);
                    Global.RO.Warn("SocketError {0}", e.SocketErrorCode.ToString("F"));
                    Global.RO.Warn("Error message {0}", e.Message);
                    m_userPuid = 0;
                    continue;
                }

                if (succeeded)
                {
                    m_userPuid = m_response.UserPuid;
                    break;
                }
                else
                {
                    m_userPuid = 0;
                    if ((m_request.XErr != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN) || (!this.GenerateGamertag))
                    {
                        // Can't fix this error
                        break;
                    }
                    else
                    {
                        Global.RO.Info("XeUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");

                        // Generate a new gamertag and rety create
                        m_request.Gamertag = this.Gamertag = GenerateTheGamerTag();

                        UpdateUserSessionToken();
                        m_request.SignedUserPassportPuid = m_passportUserSessionToken;
                        m_request.SignedOwnerPassportPuid = m_passportOwnerSessionToken;
                    }
                }
            } while (retryCount++ < 3); // Loop while NAME_TAKEN error is returned

            // grab the fake passport info if we didn't create a passport account
            if (!m_createPassport)
            {
                m_passportUserSessionToken = m_request.SignedUserPassportPuid;
                m_passportOwnerSessionToken = m_request.SignedOwnerPassportPuid;
            }

            ShowServerID(m_userPuid);

            return m_userPuid;
        }

        public ulong CreateMinor(byte[] newParentSessionToken, byte parentCountryID, bool restricted)
        {
            int age;
            
            if(restricted)
            {
                age = CountryDictionary.MinAge(parentCountryID).User - 1;
            }
            else
            {
                age = CountryDictionary.MinAge(parentCountryID).Billing - 1;
            }
            BirthDate = DateTime.UtcNow.AddYears(-age);

            return CreateMinor(newParentSessionToken, parentCountryID, restricted, BirthDate);
        }

        public ulong CreateMinor(byte[] newParentSessionToken, byte parentCountryID, bool restricted, DateTime birthDate)
        {
            SetDefaults();
            SetMinorDefaults(newParentSessionToken, parentCountryID, restricted, birthDate);

            int retryCount = 0;
            do
            {
                bool succeeded = false;

                try
                {
                    succeeded = m_request.Execute(out m_response);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    Global.RO.Warn("XRL execution has SocketException");
                    Global.RO.Warn("Error code 0X{0:X}", e.ErrorCode);
                    Global.RO.Warn("SocketError {0}", e.SocketErrorCode.ToString("F"));
                    Global.RO.Warn("Error message {0}", e.Message);
                    m_userPuid = 0;
                    continue;
                }
                if (succeeded)
                {
                    m_userPuid = m_response.UserPuid;
                    break;
                }
                else
                {
                    m_userPuid = 0;
                    if ((m_request.XErr != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN) || (!this.GenerateGamertag))
                    {
                        // Can't fix this error
                        break;
                    }
                    else
                    {
                        Global.RO.Info("XeUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");

                        // Generate a new gamertag and rety create
                        m_request.Gamertag = this.Gamertag = GenerateTheGamerTag();
                    }
                }
            } while (retryCount++ < 3); // Loop while NAME_TAKEN error is returned

            // grab the fake passport info if we didn't create a passport account
            if (!m_createPassport)
            {
                // Owner puid and session token are set in SetMinorDefaults()
                m_passportUserSessionToken = m_request.SignedUserPassportPuid;
            }

            if (m_userPuid != 0)
                Global.RO.Info("Minor user 0x{0:x} created on partition {1}", m_userPuid, UodbWS.WhatServerIsTheUserOn(m_userPuid));

            return m_userPuid;
        }

        public ulong CreateMinor(XeUser parentUser, bool restricted)
        {
            int age;
            
            if(restricted)
            {
                age = CountryDictionary.MinAge(parentUser.CountryId).User - 1;
            }
            else
            {
                age = CountryDictionary.MinAge(parentUser.CountryId).Billing - 1;
            }
            BirthDate = DateTime.UtcNow.AddYears(-age);

            return CreateMinor(parentUser,  restricted, BirthDate);
        }

        public ulong CreateMinor(XeUser parentUser, bool restricted, DateTime birthDate)
        {
            SetDefaults();
            SetMinorDefaults(parentUser, restricted, birthDate);

            int retryCount = 0;
            do
            {
                bool succeeded = false;

                try
                {
                    succeeded = m_request.Execute(out m_response);
                }
                catch (System.Net.Sockets.SocketException e)
                {
                    Global.RO.Warn("XRL execution has SocketException");
                    Global.RO.Warn("Error code 0X{0:X}", e.ErrorCode);
                    Global.RO.Warn("SocketError {0}", e.SocketErrorCode.ToString("F"));
                    Global.RO.Warn("Error message {0}", e.Message);
                    m_userPuid = 0;
                    continue;
                }

                if (succeeded)
                {
                    m_userPuid = m_response.UserPuid;
                    break;
                }
                else
                {
                    m_userPuid = 0;
                    if ((m_request.XErr != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN) || (!this.GenerateGamertag))
                    {
                        // Can't fix this error
                        break;
                    }
                    else
                    {
                        Global.RO.Info("XeUser.Create() got XONLINE_E_ACCOUNTS_NAME_TAKEN. Retrying...");

                        // Generate a new gamertag and rety create
                        m_request.Gamertag = this.Gamertag = GenerateTheGamerTag();
                    }
                }
            } while (retryCount++ < 3); // Loop while NAME_TAKEN error is returned

            // grab the fake passport info if we didn't create a passport account
            if (!m_createPassport)
            {
                // Owner puid and session token are set in SetMinorDefaults()
                m_passportUserSessionToken = m_request.SignedUserPassportPuid;
            }

            if (m_userPuid != 0)
                Global.RO.Info("Minor user 0x{0:x} created on partition {1}", m_userPuid, UodbWS.WhatServerIsTheUserOn(m_userPuid));

            return m_userPuid;
        }

        public void CreateLightWeightUserWithOutAdress(Country countryId)
        {
            InitLightWeightValues(true, countryId, false, true);
            Create();
        }

        public void CreateLightWeightUserWithOutPersonalInfo(Country countryId)
        {
            InitLightWeightValues(true, countryId, false, false);
            Create();
        }

        public void InitLightWeightValues(bool createPassport, Country countryId, bool createAddress, bool createPersonalInfo)
        {
            m_request = new XRLXeCreateLiveAccount();
            m_response = new XRLXeCreateLiveAccountResponse();

            if (createPersonalInfo)
            {
                FirstName = "John";
                LastName = "Smith";
                PhoneInfo = new PhoneInfoData();
                GeneratePhoneInfo(countryId, out PhoneInfo);
            }
            else
            {
                FirstName = "";
                LastName = "";

                PhoneInfoData phoneInfo = new PhoneInfoData();
                phoneInfo.PhonePrefix = "";
                phoneInfo.PhoneNumber = "";

                this.PhoneInfo = phoneInfo;
            }
            this.GenerateGamertag = true;
            this.Gamertag = GenerateTheGamerTag();
            PassportMemberName = "";
            OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
            BillingToken = "";
            BirthDate = DateTime.UtcNow.AddYears(-30);
            Email = "johnsmith" + Global.PassportMemberDomain;
            LanguageId = CountryLanguage.GetFirstLanguageFromCountry((byte)countryId);
            m_countryId = (byte)countryId;
            if (createAddress)
            {
                SetAddress(countryId);
            }
            else
            {
                AddressInfoData addressInfo = new AddressInfoData();
                addressInfo.Street1 = "";
                addressInfo.Street2 = "";
                addressInfo.City = "";
                addressInfo.PostalCode = "";
                addressInfo.State = "";
                this.AddressInfo = addressInfo;
            }
            ParentalControlGroup = 0;
            MsftOptIn = 0;
            PartnerOptIn = 0;

            m_paymentInstrumentType = 0;
            CreditCardInfo = new CreditCardInfoData();
            DirectDebitInfo = new DirectDebitInfoData();
            m_createPassport = createPassport;
            //m_request.MachinePuid = 0xfa00000012341234;  // random value
            m_request.MachinePuid = MachineEditor.CreateNew().Id;
            //m_request.TitleId = 0xFFFE07D1; // xenon dash title id
            m_request.TitleId = 0xFFFE07DE; // signup app title id
        }

        public bool CreateAsGold
        {
            set
            {
                if (value)
                {
                    // By default, use the gold pre-paid one year offer for a gold subscription
                    this.CreateOffer = Offers.BaseOffers.GoldPP1Year;
                }
                else
                {
                    // And for non-gold accounts, we just use the free silver offer
                    this.CreateOffer = Offers.BaseOffers.SilverFreeTrial;
                }
            }
        }

        public Offers.BaseOffers CreateOffer
        {
            set
            {
                this.OfferId = Offers.GetBaseOfferId(value);
                try
                {
                    this.BillingToken = Offers.GetBaseOfferPrepaidVoucherCode(value);
                }
                catch (Exception)
                {
                    // We we're unable to get a voucher code for the given offer, so we'll assume it doesn't have one
                    this.BillingToken = "";
                }
            }
        }

        public void SetDefaults()
        {
            if (m_createPassport)
                UpdateUserSessionToken();
            PopulateXRLRequestValue(m_request);
        }

        //To purchas with token, lightweight user needs to have account info
        private bool SetAccountInfoRequestExecution()
        {
            XRLXeSetAccountInfo request = new XRLXeSetAccountInfo();
            request.UserPuid = m_userPuid;
            request.FirstName = FirstName;
            request.LastName = LastName;
            request.Birthdate = BirthDate;
            request.Email = Email;
            request.AddressInfo = AddressInfo;
            request.PhoneInfo = PhoneInfo;
            request.LanguageId = LanguageId;
            request.MsftOptIn = MsftOptIn;
            request.PartnerOptIn = PartnerOptIn;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XeSetAccountInfo failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeSetAccountInfo returned XErr=0x{0:x}", request.XErr));

            return true;
        }

        public ulong CreateUserAndBillableAccountRequestExecution()
        {
            XRLCreateUserAndBillableAccount xrl = new XRLCreateUserAndBillableAccount();
            xrl.Request.machinePuid = MachineEditor.CreateNew().Id;
            xrl.Request.gamertag = this.Gamertag;
            xrl.Request.signedUserPassportPuid = m_passportUserSessionToken;
            xrl.Request.signedOwnerPassportPuid = m_passportOwnerSessionToken;
            xrl.Request.birthdate = BirthDate;
            xrl.Request.email = Email;
            xrl.Request.languageId = LanguageId;
            xrl.Request.countryId = CountryId;
            xrl.Request.msftOptIn = Convert.ToBoolean(MsftOptIn);
            xrl.Request.partnerOptIn = Convert.ToBoolean(PartnerOptIn);
            xrl.Request.isFreeGamertagChangeEligible = false;
            xrl.Request.offlineXuid = 0;

            int retryCount = 0;
            int maxRetries = 5;

            while (retryCount++ < maxRetries)
            {
                Global.RO.Debug("Request: gamertag=" + xrl.Request.gamertag);

                if (!xrl.Execute())
                {
                    // Execution did not succeed;
                    if (xrl.XErr != HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN && xrl.XErr != HResult.XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG)
                        throw new Exception("XRLCreateUserAndBillableAccount failed with gamertag: " + this.Gamertag + " --- " + xrl.ErrorStatusMessage);
                    else
                    {
                        Global.RO.Info("XeUser.CreateUserAndBillableAccount() got XONLINE_E_ACCOUNTS_NAME_TAKEN or XONLINE_E_ACCOUNTS_FORBIDDEN_GAMERTAG. Retrying...");

                        // Generate a new gamertag and rety create
                        xrl.Request.gamertag = this.Gamertag = GenerateTheGamerTag();
                        if (m_createPassport)
                        {
                            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(this.CountryId);
                            this.PassportMemberName = passportUser.MemberName;
                            this.PassportPassword = passportUser.Password;

                            //If this is an independent user (non-minor user), we also need to update signedOwnerPassportPuid;
                            //If not, no need to update owner's PassportPuid;
                            if (xrl.Request.signedOwnerPassportPuid == xrl.Request.signedUserPassportPuid)
                                xrl.Request.signedOwnerPassportPuid = m_passportOwnerSessionToken = passportUser.SessionToken;
                            xrl.Request.signedUserPassportPuid = m_passportUserSessionToken = passportUser.SessionToken;
                        }
                    }
                }
                else
                    break;
            }

            if (retryCount >= maxRetries)
                throw new Exception(String.Format("XeUser.CreateUserAndBillableAccount(): unable to create user after {0} tries ...", maxRetries));

            // Execution succeeds;
            Global.RO.Debug("Response userPuid: " + xrl.Response.userPuid.ToString());

            m_userPuid = xrl.Response.userPuid;
            ShowServerID(m_userPuid);

            return xrl.Response.userPuid;
        }

        public ulong CreateUserAndBillableAccount()
        {
            if (m_createPassport)
                UpdateUserSessionToken();
            CreateUserAndBillableAccountRequestExecution();
            SetAccountInfoRequestExecution();
            return m_userPuid;
        }

        public ulong CreateMinorUserAndBillableAccount(XeUser parentUser, bool restricted)
        {
            if (m_createPassport)
                UpdateUserSessionToken();

            int age;
            
            if(restricted)
            {
                age = CountryDictionary.MinAge(parentUser.CountryId).User - 1;
            }
            else
            {
                age = CountryDictionary.MinAge(parentUser.CountryId).Billing - 1;
            }
            BirthDate = DateTime.UtcNow.AddYears(-age);
           
            SetNeededValuesForMinorUser(parentUser.PassportSessionToken, parentUser.CountryId, restricted, BirthDate);
            CreateUserAndBillableAccountRequestExecution();
            SetAccountInfoRequestExecution();
            return m_userPuid;
        }

        public string GetDumpString()
        {
            return m_request.GetDumpString();
        }

        public XRLXeCreateLiveAccount xrl
        {
            get { return m_request; }
            set { m_request = value; }
        }

        public ulong UserPuid
        {
            get { return m_userPuid; }
            set { m_userPuid = value; }
        }

        /// <summary>
        /// Facilitate the easy addition of a visa card to the user's account.
        /// </summary>
        /// <returns>Returns the PaymentInstrumentId returned from SCG</returns>
        public string AddPaymentInstrumentVisa()
        {
            XRLXeAddPaymentInstrument request;
            return AddPaymentInstrumentVisa(out request);
        }

        /// <summary>
        /// Facilitate the easy addition of a visa card to the user's account.
        /// </summary>
        /// <param name="request">Returns the request object in case the user needs the cc number/details</param>
        /// <returns>Returns the PaymentInstrumentId returned from SCG</returns>
        public string AddPaymentInstrumentVisa(out XRLXeAddPaymentInstrument request)
        {
            request = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse response;
            ExecuteAddPaymentInstrumentRequest(request, out response);
            return response.PaymentInstrumentId;
        }

        public string AddPaymentInstrumentVisa(out XRLXeAddPaymentInstrument request, out XRLXeAddPaymentInstrumentResponse response)
        {
            request = new XRLXeAddPaymentInstrument();
            ExecuteAddPaymentInstrumentRequest(request, out response);
            return response.PaymentInstrumentId;
        }

        /// <summary>
        /// Facilitate the easy addition of a visa card with a specific credit card number to this
        /// user's account.  This allows the return of certain AVS codes returned by a bank emulator on
        /// the SCG side.
        /// </summary>
        /// <param name="request">Returns the request object in case the user needs the cc number/details</param>
        /// <returns>Returns the PaymentInstrumentId returned from SCG</returns>
        public string AddPaymentInstrumentVisa(string creditCardNumber)
        {
            XRLXeAddPaymentInstrument request = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse response;
            request.CreditCardInfo.AccountNumber = creditCardNumber;

            ExecuteAddPaymentInstrumentRequest(request, out response);
            return response.PaymentInstrumentId;
        }

        /// <summary>
        /// Facilitate the easy addition of a direct debit payment instrument to the user's account.
        /// </summary>
        /// <returns>Returns the PaymentInstrumentId returned from SCG</returns>
        public string AddPaymentInstrumentDirectDebit()
        {
            string countryCode = "";
            switch ((Country)this.CountryId)
            {
                case Country.DE:
                    countryCode = "DE";
                    break;
                case Country.GB:
                    countryCode = "UK";
                    break;
                default:
                    throw new UnexpectedTestResultException("This user is not in a supported direct debit country.");
            }


            XRLXeAddPaymentInstrument request = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse response = new XRLXeAddPaymentInstrumentResponse();

            request.UserPuid = this.UserPuid;
            request.PaymentInstrumentType = (byte)XRLXeAddPaymentInstrument.PaymentInstrumentTypeEnum.DirectDebit;
            request.DirectDebitInfo.AccountHolderName = this.FirstName + " " + this.LastName;


            DirectDebitRandomizer dd = new DirectDebitRandomizer(countryCode);
            dd.Randomize();
            request.DirectDebitInfo.AccountNumber = dd.AccountNumber;
            request.DirectDebitInfo.BankCode = dd.BankCode;
            request.DirectDebitInfo.BranchCode = dd.BranchCode;
            request.DirectDebitInfo.CheckDigits = dd.CheckDigits;

            if (!request.Execute(out response))
                throw new Exception("XRLXeAddPaymentInstrument failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new Exception(String.Format("XRLXeAddPaymentInstrument returned XErr=0x{0:x}", request.XErr));

            return response.PaymentInstrumentId;
        }

        public uint AddPoints_500()
        {
            // add a temporary payment instrument (we wouldn't have to do this if the points bundel voucher was working)
            string paymentInstrumentId = this.AddPaymentInstrumentVisa();

            // we need to first check our balance so the DMP account can be created
            uint balance_before = this.GetPointsBalance();

            XRLXeOfferPurchase request = new XRLXeOfferPurchase();

            request.UserPuid = this.UserPuid;
            request.OfferID = Offers.GetPointsOfferId(Offers.PointsOffers.CC500US);   // 500 points cc offer
            request.SchemaVersion = WireData.MakeSchemaVersion(1, 0);
            request.LanguageID = this.LanguageId;
            request.CountryID = this.CountryId;
            request.Tier = 3;
            request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            request.PaymentInstrumentID = paymentInstrumentId;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));

            uint balance_after = this.GetPointsBalance();

            if (balance_after - balance_before != 500)
                throw new UnexpectedTestResultException(String.Format("Points balance is unexpected. Actual {0}, Expected {1}", balance_after, (balance_before + 500)));

            // now remove the temporary payment instrument
            XRLXeRemovePaymentInstrument removePI = new XRLXeRemovePaymentInstrument();
            removePI.UserPuid = this.UserPuid;
            removePI.PaymentInstrumentId = paymentInstrumentId;
            if (!removePI.Execute())
                throw new UnexpectedTestResultException("XRLXeRemovePaymentInstrument failed: " + removePI.GetDumpString());

            return balance_after;
        }

        public uint GetPointsBalance()
        {
            XRLXeGetPointsBalance request = new XRLXeGetPointsBalance();
            XRLXeGetPointsBalanceResponse response = new XRLXeGetPointsBalanceResponse();
            request.userPuid = this.UserPuid;

            if (!request.Execute(out response))
                throw new Exception("XRLXeGetPointsBalance failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new Exception(String.Format("XRLXeGetPointsBalance returned XErr=0x{0:x}", request.XErr));

            return response.PointsBalance;
        }

        /// <summary>
        /// Returns all payment instruments associated with this account
        /// </summary>
        /// <returns>Returns an array of payment instrument types</returns>
        public PaymentInstrumentInfoEx[] GetPaymentInstruments()
        {
            XRLXeGetPaymentInstruments request = new XRLXeGetPaymentInstruments();
            XRLXeGetPaymentInstrumentsResponse response = new XRLXeGetPaymentInstrumentsResponse();

            request.UserPuid = this.UserPuid;
            request.MaxResults = 1000;
            if (!request.Execute(out response))
                throw new Exception("XRLXeGetPaymentInstrumentsResponse failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new Exception(String.Format("XRLXeGetPaymentInstrumentsResponse returned XErr=0x{0:x}", request.XErr));

            return response.PaymentInstrumentInfo;
        }

        private void InitValues(bool createPassport, bool generateGamerTag, string gamerTag, Country countryId)
        {
            m_request = new XRLXeCreateLiveAccount();
            m_response = new XRLXeCreateLiveAccountResponse();

            string generatedGamerTag = "";
            if (generateGamerTag)
                generatedGamerTag = GenerateTheGamerTag();
            else
                generatedGamerTag = gamerTag;

            FirstName = "John";
            LastName = "Smith";
            this.GenerateGamertag = generateGamerTag;
            this.Gamertag = generatedGamerTag;
            PassportMemberName = "";
            OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
            BillingToken = "";
            BirthDate = DateTime.UtcNow.AddYears(-30);
            Email = "johnsmith" + Global.PassportMemberDomain;
            LanguageId = CountryLanguage.GetFirstLanguageFromCountry((byte)countryId);
            m_countryId = (byte)countryId;
            SetAddress(countryId);
            ParentalControlGroup = 0;
            MsftOptIn = 0;
            PartnerOptIn = 0;
            PhoneInfo = new PhoneInfoData();
            GeneratePhoneInfo(countryId, out PhoneInfo);
            m_paymentInstrumentType = 0;
            CreditCardInfo = new CreditCardInfoData();
            DirectDebitInfo = new DirectDebitInfoData();
            m_createPassport = createPassport;
            
            //m_request.MachinePuid = 0xfa00000012341234;  // random value
            m_request.MachinePuid = MachineEditor.CreateNew().Id;
            //m_request.TitleId = 0xFFFE07D1; // xenon dash title id
            m_request.TitleId = 0xFFFE07DE; // signup app title id
        }

        private string GenerateTheGamerTag()
        {
            RandomEx rnd = new RandomEx();
            return rnd.GenerateRandomString("XEN", 15);
        }

        private void GeneratePhoneInfo(Country country, out PhoneInfoData phoneInfo)
        {
            phoneInfo = new PhoneInfoData();
            phoneInfo.PhonePrefix = "425";
            phoneInfo.PhoneNumber = "7075555";
            return;
        }

        private void SetMinorDefaults(XeUser parentUser, bool restricted, DateTime birthDate)
        {
            SetNeededValuesForMinorUser(parentUser.PassportSessionToken, parentUser.CountryId, restricted, birthDate);

            m_request.Birthdate = birthDate;
            m_request.ParentalControlGroupId = ParentalControlGroup;
            m_request.SignedOwnerPassportPuid = m_passportOwnerSessionToken;
        }

        private void SetMinorDefaults(byte[] newParentSessionToken, byte parentCountryID, bool restricted, DateTime birthDate)
        {
            SetNeededValuesForMinorUser(newParentSessionToken, parentCountryID, restricted, birthDate);

            m_request.Birthdate = birthDate;
            m_request.ParentalControlGroupId = ParentalControlGroup;
            m_request.SignedOwnerPassportPuid = m_passportOwnerSessionToken;
        }

        //private method responsible for actual execution.  Guarantees only code from this class can
        //call it, and that it is therefore initialized appropriately.  All return information goes
        //through the response.
        private void ExecuteAddPaymentInstrumentRequest(XRLXeAddPaymentInstrument request,
                                                        out XRLXeAddPaymentInstrumentResponse response)
        {
            response = new XRLXeAddPaymentInstrumentResponse();
            request.UserPuid = this.UserPuid;
            request.AddressInfo.SetDefaultAddress((Country)m_countryId);

            if (!request.Execute(out response))
                throw new Exception("XRLXeAddPaymentInstrument failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new Exception(String.Format("XRLXeAddPaymentInstrument returned XErr=0x{0:x}", request.XErr));
        }

        private void ShowServerID(ulong userPuid)
        {
            if (userPuid == 0)
                Global.RO.Info("User 0x{0:x} puid is 0, not able to show server ID.", userPuid);
            else
            {
                string server = "";
                try
                {
                    server = UodbWS.WhatServerIsTheUserOn(userPuid);
                }
                catch (Exception exc)
                {
                    // It's not the end of the world if we can't figure out the server
                    server = "(error retreiving server: " + exc.Message + ")";
                }
                Global.RO.Info("User 0x{0:x} created on partition {1}", userPuid, server);
            }
        }

        private void PopulateXRLRequestValue(XRLXeCreateLiveAccount request)
        {
            request.FirstName = FirstName;
            request.LastName = LastName;
            request.Gamertag = this.Gamertag;
            request.SignedUserPassportPuid = m_passportUserSessionToken;
            request.SignedOwnerPassportPuid = m_passportOwnerSessionToken;
            request.OfferId = OfferId;
            request.BillingToken = BillingToken;
            request.Birthdate = BirthDate;
            request.Email = Email;
            request.LanguageId = LanguageId;
            request.CountryId = CountryId;
            request.ParentalControlGroupId = ParentalControlGroup;
            request.MsftOptIn = MsftOptIn;
            request.PartnerOptIn = PartnerOptIn;
            request.AddressInfo = AddressInfo;
            request.PhoneInfo = PhoneInfo;
            request.PaymentInstrumentType = m_paymentInstrumentType;
            request.CreditCardInfo = this.CreditCardInfo;
            request.DirectDebitInfo = this.DirectDebitInfo;

            // If CreateLiveAccountExtra is specified use that
            // Otherwise try to use CreateLiveAccountEntryPoint info
            if (this.CreateLiveAccountExtra != null)
            {
                request.ReservedBytes = (byte[])this.CreateLiveAccountExtra;
            }
            else if (this.CreateLiveAccountEntryPoint != null)
            {
                request.ReservedBytes =
                    (byte[])this.CreateLiveAccountEntryPoint;
            }
        }

        private void SetNeededValuesForMinorUser(byte[] newParentSessionToken, byte parentCountryID, bool restricted, DateTime birthDate)
        {
            BirthDate = birthDate;

            // For a minor, u.ParentalControlGroupId == RESTRICTED or MEDIUM
            ParentalControlGroup = restricted ? XOn.PARENTAL_CONTROL_GROUP_RESTRICTED : XOn.PARENTAL_CONTROL_GROUP_MEDIUM;

            m_passportOwnerSessionToken = newParentSessionToken;
        }

        private void UpdateUserSessionToken()
        {
            // create the passport account here.
            UacsCommon.PassportUser passportUser = (new UacsCommon()).CreatePassportUser(this.CountryId);
            PassportMemberName = passportUser.MemberName;
            PassportPassword = passportUser.Password;
            m_passportUserSessionToken = passportUser.SessionToken;
            m_passportOwnerSessionToken = passportUser.SessionToken;
        }
    }  /* *+++++ END CLASS XEUSER ++++* */








    public class XRLXeCreateLiveAccount : XRLPayload
    {

        private Random m_rnd;
        private ulong m_dummyPuid;
        public ulong DummyPuid { get { return m_dummyPuid; } }

        public XRLXeCreateLiveAccount()
        {
            m_rnd = new Random((int)DateTime.Now.Ticks);
            Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
        }

        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = MachineEditor.CreateNew().Id;  // xenon machines must start with 0xfa00
        public ulong offlineXuid = 0;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleId = 0;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName = "";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName = "";
        public ushort GamertagLength = 0;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag = "";
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedUserPassportPuid;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOwnerPassportPuid;
        public ulong OfferId = 0;
        public ushort BillingTokenLength = 0;
        [WireInfo(SizeParam="BillingTokenLength")]
        public string BillingToken = "";
        public DateTime Birthdate;
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public ushort LanguageId;
        public byte CountryId;
        public int ParentalControlGroupId = 0;
        public byte MsftOptIn;
        public byte PartnerOptIn;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType = 0;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;
        public ushort ReservedBytesLength = 0;
        [WireInfo(SizeParam="ReservedBytesLength")]
        public byte[] ReservedBytes;


        protected override string GetServiceName()
        {
            return "/xuacs/XeCreateLiveAccount.ashx";
        }

        public bool Execute(out XRLXeCreateLiveAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeCreateLiveAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeCreateLiveAccountResponse Response)
        {
            // Removed the following line because bug #48041 caused dummpy passport puids to fail user account creation
            // m_dummyPuid = (((ulong)m_rnd.Next()) << 32) + ((ulong)m_rnd.Next());
            if (this.SignedUserPassportPuid == null)
            {
                UacsCommon UACS = new UacsCommon();
                UacsCommon.PassportUser ppu = UACS.CreatePassportUser(CountryId);
                m_dummyPuid = ppu.PassportPuid;
            }
            if (this.SignedOwnerPassportPuid == null && this.SignedUserPassportPuid != null)
                this.SignedOwnerPassportPuid = this.SignedUserPassportPuid;

            if (this.SignedUserPassportPuid == null)
                this.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);
            if (this.SignedOwnerPassportPuid == null)
                this.SignedOwnerPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);


            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeCreateLiveAccountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeCreateLiveAccountExtra : XRLPayload
    {
        public bool CreateArgoProfile = false;
    }

    public class XRLXeCreateLiveAccountEntryPoint : XRLPayload
    {
        public uint ServiceType;
        public uint ClientType;
    }

    public class XRLXeCreateLiveAccountResponse : XRLPayload
    {
        public ulong  UserPuid;
        [WireInfo(ArraySize=16)] //XOn.XONLINE_KEY_LENGTH
        public byte[] XboxKey;
        [WireInfo(ArraySize=16)] //XOn.XONLINE_KEY_LENGTH
        public byte[] XenonKey;
    }


    public class XRLXeCreateWholesaleAccount : XRLPayload {

        private Random m_rnd;
        private ulong m_dummyPuid;
        public ulong DummyPuid { get { return m_dummyPuid; } }

        public XRLXeCreateWholesaleAccount()
        {
            m_rnd = new Random((int) DateTime.Now.Ticks);
            Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
        }

        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid = MachineEditor.CreateNew().Id;  // xenon machines must start with 0xfa00
        public ulong offlineXuid = 0;
        public uint WholesalePartnerId = 0;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam = "FirstNameLength")]
        public string FirstName = "";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam = "LastNameLength")]
        public string LastName = "";
        public ushort GamertagLength = 0;
        [WireInfo(SizeParam = "GamertagLength")]
        public string Gamertag = "";
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedUserPassportPuid;
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOwnerPassportPuid;
        public ulong OfferId = 0;
        public DateTime Birthdate;
        public ushort EmailLength;
        [WireInfo(SizeParam = "EmailLength")]
        public string Email;
        public ushort LanguageId;
        public byte CountryId;
        public int ParentalControlGroupId = 0;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType = 0;
        public WholesaleInfoData WholesaleInfo;
        public ushort ReservedBytesLength = 0;
        [WireInfo(SizeParam = "ReservedBytesLength")]
        public byte[] ReservedBytes;


        protected override string GetServiceName()
        {
            return "/xuacs/CreateWholesaleAccount.ashx";
        }

        public bool Execute(out XRLXeCreateWholesaleAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeCreateWholesaleAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeCreateWholesaleAccountResponse Response)
        {
            // Removed the following line because bug #48041 caused dummpy passport puids to fail user account creation
            // m_dummyPuid = (((ulong)m_rnd.Next()) << 32) + ((ulong)m_rnd.Next());
            if (this.SignedUserPassportPuid == null)
            {
                UacsCommon UACS = new UacsCommon();
                UacsCommon.PassportUser ppu = UACS.CreatePassportUser(CountryId);
                m_dummyPuid = ppu.PassportPuid;
            }
            if (this.SignedOwnerPassportPuid == null && this.SignedUserPassportPuid != null)
                this.SignedOwnerPassportPuid = this.SignedUserPassportPuid;

            if (this.SignedUserPassportPuid == null)
                this.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);
            if (this.SignedOwnerPassportPuid == null)
                this.SignedOwnerPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);


            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeCreateWholesaleAccountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeCreateWholesaleAccountResponse : XRLPayload {
        public ulong UserPuid;
        [WireInfo(ArraySize = 16)] //XOn.XONLINE_KEY_LENGTH
        public byte[] XboxKey;
        [WireInfo(ArraySize = 16)] //XOn.XONLINE_KEY_LENGTH
        public byte[] XenonKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeFamilySubscriptionAssignGoldUser.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeFamilySubscriptionAssignGoldUser : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        // The xuid of the dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        // The xuid of the owner
        [XRLPayloadFld(IsUPuid = true)]
        public ulong ownerPuid;

        public XRLXeFamilySubscriptionAssignGoldUser()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/FamilySubscriptionAssignGoldUser.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeFamilySubscriptionAssignGoldUser Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeFamilySubscriptionAssignGoldUser Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeFamilySubscriptionRemoveGoldUser.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeFamilySubscriptionRemoveGoldUser : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        // The xuid of the dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        // The xuid of the owner
        [XRLPayloadFld(IsUPuid = true)]
        public ulong ownerPuid;

        public XRLXeFamilySubscriptionRemoveGoldUser()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/FamilySubscriptionRemoveGoldUser.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }
         
        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeFamilySubscriptionRemoveGoldUser Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeFamilySubscriptionRemoveGoldUser Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeCreateXboxComAccount.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Utilities;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeCreateXboxComAccount : XRLPayload
    {
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName = "John";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName = "Smith";
        public ushort GamertagLength = 0;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag = "";
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0xffed000022224444;  // xbox.com creates accounts starting/ with 0xFFED
        public ulong UserPassportPuid = 0;
        public ulong OwnerPassportPuid = 0;
        public DateTime Birthdate = DateTime.UtcNow.AddYears(-25);
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email = "john.smith" + Global.PassportMemberDomain;
        public ushort LanguageId = 1;
        public byte CountryId = 103;
        public byte ParentalControlGroupId = 0;
        public byte MsftOptIn = 0;
        public byte PartnerOptIn = 0;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType = 0;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;

        
        private Random m_rnd;

        public XRLXeCreateXboxComAccount() : this((byte)XeUser.Country.US, (ushort)XeUser.Language.en)
        {
        }

        public XRLXeCreateXboxComAccount(byte countryId, ushort languageId)
        {
            this.CountryId = countryId;
            this.LanguageId = languageId;
            m_rnd = new Random((int)DateTime.Now.Ticks);
            RandomEx rnd = new RandomEx();
            this.Gamertag = rnd.GenerateRandomString("XEN", 15);

            this.AddressInfo = new AddressInfoData();
            this.AddressInfo.SetDefaultAddress((XeUser.Country)countryId);

            this.PhoneInfo = new PhoneInfoData();
            this.PhoneInfo.PhonePrefix = "425";
            this.PhoneInfo.PhoneNumber = "707-5555";

            this.CreditCardInfo = new CreditCardInfoData();
            this.DirectDebitInfo = new DirectDebitInfoData();

            // need to use HTTP auth for web-only requests
            UseHttpAuth = true;

            this.Slot.titleId = XOn.WEB_TITLE_ID;
        }


        protected override string GetServiceName()
        {
            return "/xuacs/XeCreateXboxComAccount.ashx";
        }

        public bool Execute(out XRLXeCreateXboxComAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeCreateXboxComAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeCreateXboxComAccountResponse Response)
        {
            // Removed the following line because bug #48041 caused dummpy passport puids to fail user account creation
            //ulong dummyPassportPuid = (((ulong)m_rnd.Next()) << 32) + ((ulong)m_rnd.Next());
            if (this.UserPassportPuid == 0)
            {
                UacsCommon UACS = new UacsCommon();
                UacsCommon.PassportUser ppu = UACS.CreatePassportUser(CountryId);
                this.UserPassportPuid = ppu.PassportPuid;
            }

            if (this.OwnerPassportPuid == 0) this.OwnerPassportPuid = this.UserPassportPuid;

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeCreateXboxComAccountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeCreateXboxComAccountResponse : XRLPayload
    {
        public ulong UserPuid = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeFamilySubscriptionGoldUserCount.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeFamilySubscriptionGoldUserCount : XRLPayload
    {
        // The xuid of the new dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        public XRLXeFamilySubscriptionGoldUserCount()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/FamilySubscriptionGoldUserCount.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public bool Execute(out XRLXeFamilySubscriptionGoldUserCountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeFamilySubscriptionGoldUserCountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeFamilySubscriptionGoldUserCountResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeFamilySubscriptionGoldUserCountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeFamilySubscriptionGoldUserCountResponse : XRLPayload
    {
        public ushort total;
        public ushort available;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeEnumFamilyMembers.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeEnumFamilyMembersRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong requestorPuid;

        [WireInfo(MinSchemaVersion = "7.0", Max = 1)]
        public ushort userPassportTokenLength = 0;

        [WireInfo(MinSchemaVersion = "7.0", SizeParam = "userPassportTokenLength")]
        public PassportToken[] userPassportToken = null;

        public XRLXeEnumFamilyMembersRequest()
        {
            // Set up a default schema version
            this.SchemaVersion = WireData.MakeSchemaVersion(6, 9);
        }

        protected override string GetServiceName()
        {
            return "/xuacs/EnumFamilyMembers.ashx";
        }

        public bool Execute(out XRLXeEnumFamilyMembersResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeEnumFamilyMembersResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeEnumFamilyMembersResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            Console.WriteLine("Execute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeEnumFamilyMembersResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class FamilyDefs
    {
        public const ushort FAMILY_OWNER = 0x0001;
        public const ushort FAMILY_SUBSCRIPTION_GOLD = 0x0002;
    }

    public class FamilyMember : WireData
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        public ushort userFlags = 0; // FAMILY_* flags from FamilyDefs

        [WireInfo(ArraySize = 16)] // XONLINE_GAMERTAG_SIZE
        public string gamertag;

		public FamilyMember()
		{
		}
		
		public FamilyMember(XeUser user, ushort UserFlags)
		{
			userPuid = user.UserPuid;
			userFlags = UserFlags;
			gamertag = user.Gamertag;
		}
    }

    public class XRLXeEnumFamilyMembersResponse : XRLPayload
    {
        // 25 dependents + owner
        public const int MAX_FAMILY_MEMBERS = 26;

        [WireInfo(Max = MAX_FAMILY_MEMBERS)]
        public ushort numFamilyMembers = 0;

        [WireInfo(SizeParam = "numFamilyMembers")]
        public FamilyMember[] familyMembers;               
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeCreateLiveAccountEx.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeCreateLiveAccountEx : XRLPayload
    {
        private Random m_rnd;
        private ulong m_dummyPuid;
        public ulong DummyPuid { get { return m_dummyPuid; } }

        public XRLXeCreateLiveAccountEx()
        {
            m_rnd = new Random((int)DateTime.Now.Ticks);
            Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
        }

        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid = MachineEditor.CreateNew().Id;  // xenon machines must start with 0xfa00
        public ulong offlineXuid = 0;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId = 0;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam = "FirstNameLength")]
        public string FirstName = "";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam = "LastNameLength")]
        public string LastName = "";
        public ushort GamertagLength = 0;
        [WireInfo(SizeParam = "GamertagLength")]
        public string Gamertag = "";
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedUserPassportPuid;
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOwnerPassportPuid;
        public ulong OfferId = 0;
        public ushort BillingTokenLength = 0;
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken = "";
        public DateTime Birthdate;
        public ushort EmailLength;
        [WireInfo(SizeParam = "EmailLength")]
        public string Email;
        public ushort LanguageId;
        public byte CountryId;
        public int ParentalControlGroupId = 0;
        public byte MsftOptIn;
        public byte PartnerOptIn;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType = 0;
        public CreditCardInfoDataEx CreditCardInfo;
        public DirectDebitInfoDataEx DirectDebitInfo;
        public ushort ReservedBytesLength = 0;
        [WireInfo(SizeParam = "ReservedBytesLength")]
        public byte[] ReservedBytes;


        protected override string GetServiceName()
        {
            return "/xuacs/XeCreateLiveAccountEx.ashx";
        }

        public bool Execute(out XRLXeCreateLiveAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeCreateLiveAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeCreateLiveAccountResponse Response)
        {
            // Removed the following line because bug #48041 caused dummpy passport puids to fail user account creation
            // m_dummyPuid = (((ulong)m_rnd.Next()) << 32) + ((ulong)m_rnd.Next());
            if (this.SignedUserPassportPuid == null)
            {
                UacsCommon UACS = new UacsCommon();
                UacsCommon.PassportUser ppu = UACS.CreatePassportUser(CountryId);
                m_dummyPuid = ppu.PassportPuid;
            }
            if (this.SignedOwnerPassportPuid == null && this.SignedUserPassportPuid != null)
                this.SignedOwnerPassportPuid = this.SignedUserPassportPuid;

            if (this.SignedUserPassportPuid == null)
                this.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);
            if (this.SignedOwnerPassportPuid == null)
                this.SignedOwnerPassportPuid = PassportUtilities.GenerateSessionToken(m_dummyPuid, Slot.Key);


            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeCreateLiveAccountResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetAccountInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetAccountInfo : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid;

        public XRLXeGetAccountInfo()
        {
            MachinePuid = MachineEditor.CreateNew().Id;
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeGetAccountInfo.ashx";
        }

        public bool Execute(out XRLXeGetAccountInfoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetAccountInfoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetAccountInfoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetAccountInfoResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetAccountInfoResponse : XRLPayload
    {
        public ushort FirstNameLength;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName;
        public ushort LastNameLength;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName;
        public DateTime Birthdate;
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public ushort LanguageId;
        public byte CountryId;
        public byte MsftOptIn;
        public byte PartnerOptIn;

        [WireInfo(MinSchemaVersion = "3.2")]
        public byte IsLightweight;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetParentalControlGroupTemplates.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetParentalControlGroupTemplatesRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        protected override string GetServiceName()
        {
            return "/xuacs/GetParentalControlGroupTemplates.ashx";
        }

        public bool Execute(out XRLXeGetParentalControlGroupTemplatesResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetParentalControlGroupTemplatesResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetParentalControlGroupTemplatesResponse Response)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeGetParentalControlGroupTemplatesRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeGetParentalControlGroupTemplatesRequest Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeGetParentalControlGroupTemplatesResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }
            return uRet;
        }
    }

    // Information about a single privilege/permission setting in a template definition
    public class ParentalControlGroupSettingDefinition : WireData
    {
        public uint settingId;
        public bool enabled;
    }

    public class ParentalControlGroupTemplateDefinition : WireData
    {
        public const byte MaxSettings = 32;

        public int parentalControlGroupId;

        // The default privileges settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte privilegeCount;

        [WireInfo(SizeParam = "privilegeCount")]
        public ParentalControlGroupSettingDefinition[] privileges;

        // The default profile permission settings for the template
        [WireInfo(Max = MaxSettings)]
        public byte permissionCount;

        [WireInfo(SizeParam = "permissionCount")]
        public ParentalControlGroupSettingDefinition[] permissions;
    }

    public class XRLXeGetParentalControlGroupTemplatesResponse : XRLPayload
    {
        [WireInfo(ArraySize = 3)]
        public ParentalControlGroupTemplateDefinition[] templates;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetParentalControls.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetParentalControls : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong requestorPuid = 0;
        
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid = 0;

        protected override string GetServiceName()
        {
            return "/xuacs/GetParentalControls.ashx";
        }

        public bool Execute(out XRLXeGetParentalControlsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetParentalControlsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetParentalControlsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(1024);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetParentalControlsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetParentalControlsResponse : XRLPayload
    {
        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userGrantPrivileges;               // the user granted privileges

        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[]       userRestrictPrivileges;               // the user restricted privileges
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetANID.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetANID : XRLPayload
    {
        public ulong UserXuid;

        public XRLXeGetANID()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetANID.ashx";
        }

        public bool Execute(out XRLXeGetANIDResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetANIDResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetANIDResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            Console.WriteLine("Excute Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Console.WriteLine("Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeGetANIDResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetANIDResponse : XRLPayload
    {
        public ushort AnidLength;
        [WireInfo(SizeParam = "AnidLength")]
        public string UserAnid;

        public uint anidHr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetLinkedGamerTag.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetLinkedGamertag : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetLinkedGamertag.ashx";
        }

        public bool Execute(out XRLXeGetLinkedGamertagResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetLinkedGamertagResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetLinkedGamertagResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetLinkedGamertagResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetLinkedGamertagResponse : XRLPayload
    {
        [WireInfo(HexString = true)]
        public ulong UserPuid;

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort GamertagLength = 0;

        [WireInfo(SizeParam = "GamertagLength")]
        public string Gamertag;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetAccountInfoFromPassport.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetAccountInfoFromPassport : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] PassportSessionToken;

        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid;

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetAccountInfoFromPassport.ashx"; 
        }

        public bool Execute(out XRLXeGetAccountInfoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetAccountInfoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetAccountInfoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetAccountInfoResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetPassportCredentialListByName.cs ===
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetPassportCredentialListByName : XRLPayload
    {    
        public ushort memberNameLength;

        [WireInfo(SizeParam = "memberNameLength")]
        public string memberName;

        protected override string GetServiceName()
        {            
            return "/xuacs/XeGetPassportCredentialListByName.ashx";
        }

        public bool Execute(out XRLXeGetPassportCredentialListByNameResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetPassportCredentialListByNameResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetPassportCredentialListByNameResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetPassportCredentialListByNameResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class PassportCredentialInfoData : WireData
    {
        [WireInfo(HexString = true)]
        public ulong PassportPuid;

        public ushort PassportMemberNameLength = 0;

        [WireInfo(SizeParam = "PassportMemberNameLength")]
        public string PassportMemberName;

        public bool IsActive;
    }
        
    public class XRLXeGetPassportCredentialListByNameResponse : XRLPayload
    {
        public ushort passportCredentialCount;
    
        [WireInfo(SizeParam="passportCredentialCount")]
        public PassportCredentialInfoData [] credentials;         
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetKey.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System.IO;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetKeyRequest : XRLPayload
	{
        public ushort KeyId;

        protected override string GetServiceName()
        {
            return "/xuacs/GetKey.ashx";
        }

        public bool Execute(out XRLXeGetKeyResponse response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int), out response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetKeyResponse response)
        {
            return Execute(sServer.EPDefault, out response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetKeyResponse response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    response = new XRLXeGetKeyResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
	}

    public class XRLXeGetKeyResponse : XRLPayload
    {
        public ushort PublicKeyLength = 0;

        [WireInfo(SizeParam = "PublicKeyLength")]
        public string PublicKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetPointsBalance.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetPointsBalance : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong userPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong machinePuid;

        
        protected override string GetServiceName()
        {
            return "/xuacs/XeGetPointsBalance.ashx";
        }

        public bool Execute(out XRLXeGetPointsBalanceResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetPointsBalanceResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetPointsBalanceResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetPointsBalanceResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetPointsBalanceResponse : XRLPayload
    {
        public uint PointsBalance;
        public byte DmpAccountStatus;
        public byte ResponseFlags;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetUserParentalControlGroup.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class UserParentalControlGroup : WireData
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        // The id of the user's parental control group, or -1 for Custom
        public int parentalControlGroupId;

        // true if any privileges/permissions have been changed
        // from the template value
        public bool custom;
    }

    public class XRLXeGetUserParentalControlGroupRequest : XRLPayload
    {
        // 25 dependents + owner
        public const byte MaxFamilyMembers = 26;

        // Must be signed in and must either be the target user (you can alway
        // see your own parental control group) or must be the owner of the target.
        [XRLPayloadFld(IsUPuid = true)]
        public ulong requestorPuid;

        // The users whose parental control group are being requested
        [WireInfo(Max = MaxFamilyMembers)]
        public byte userPuidCount;

        [WireInfo(SizeParam = "userPuidCount")]
        public ulong[] userPuids;

        protected override string GetServiceName()
        {
            return "/xuacs/GetUserParentalControlGroup.ashx";
        }

        public bool Execute(out XRLXeGetUserParentalControlGroupResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetUserParentalControlGroupResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetUserParentalControlGroupResponse Response)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeGetUserParentalControlGroupRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeGetUserParentalControlGroupRequest Internal Execute Returned {0}", bRet);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeGetUserParentalControlGroupResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }
            return uRet;
        }
    }

    public class XRLXeGetUserParentalControlGroupResponse : XRLPayload
    {
        // A list of the requested users and their effective parental control group.
        // Any requested user that the requestor doesn't have permission to see will
        // not be in the result array.
        [WireInfo(Max = XRLXeGetUserParentalControlGroupRequest.MaxFamilyMembers)]
        public byte userCount;

        [WireInfo(SizeParam = "userCount")]
        public UserParentalControlGroup[] users;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetPaymentInstruments.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetPaymentInstruments : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;
        public ushort MaxResults;
        [WireInfo(MinSchemaVersion = "5.4")]
        public bool IncludePayPalPayin;
        [WireInfo(MinSchemaVersion = "5.4")]
        public bool IncludeExpiredCreditCards = true;

        private string m_scs_fault_injection = null;

        public string ScsFaultInjection
        {
            get { return m_scs_fault_injection; }
            set { m_scs_fault_injection = value; }
        }

        public XRLXeGetPaymentInstruments()
        {
            MachinePuid = 0xfa00000012341234;
            MaxResults = 10;
            IncludeExpiredCreditCards = true; // default to pre-Geneva behavior
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetPaymentInstruments.ashx";
        }

        public bool Execute(out XRLXeGetPaymentInstrumentsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetPaymentInstrumentsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetPaymentInstrumentsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            if (m_scs_fault_injection != null)
            {
                base.CustomHeader += "InjectedScsError: " + m_scs_fault_injection + "\r\n";
            }
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetPaymentInstrumentsResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetPaymentInstrumentsResponse : XRLPayload
    {
        public ushort PaymentInstrumentCount;
        [WireInfo(SizeParam="PaymentInstrumentCount")]
        public PaymentInstrumentInfoEx[] PaymentInstrumentInfo;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetUserType.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetUserType : XRLPayload
    {

        public enum UserTypeEnum : byte
        {
            Xbox1User           = 0,
            XboxComUser         = 1,
            XenonUser           = 2,
            Xbox1LinkedUser     = 3
        }


        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0;
        public ushort GamertagLength = 0;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag;

        public XRLXeGetUserType()
        {
            this.MachinePuid = 0xfa00000012341234;
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeGetUserType.ashx";
        }

        public bool Execute(out XRLXeGetUserTypeResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetUserTypeResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetUserTypeResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetUserTypeResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetUserTypeResponse : XRLPayload
    {
        public byte UserType;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetUserInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetUserInfo : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleId;
            

        public XRLXeGetUserInfo()
        {
            this.MachinePuid = 0xfa00000012341234;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }


        protected override string GetServiceName()
        {
            return "/xuacs/XeGetUserInfo.ashx";
        }

        public bool Execute(out XRLXeGetUserInfoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetUserInfoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetUserInfoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetUserInfoResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetUserInfoResponse : XRLPayload
    {
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName;
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName;
        public AddressInfoData AddressInfo;
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public ushort LanguageId;
        public byte CountryId;
        public byte MsftOptIn;
        public byte PartnerOptIn;
        public byte Age;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetUserSubscriptionDetails.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetUserSubscriptionDetails : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ulong OfferId;
        public ushort InstanceIdLength = 0;
        [WireInfo(SizeParam="InstanceIdLength")]
        public string InstanceId = "";
        
        public XRLXeGetUserSubscriptionDetails()
        {
            this.MachinePuid = 0xfa00000012341234;            
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetUserSubscriptionDetails.ashx";
        }

        public bool Execute(out XRLXeGetUserSubscriptionDetailsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetUserSubscriptionDetailsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetUserSubscriptionDetailsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetUserSubscriptionDetailsResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetUserSubscriptionDetailsResponse : XRLPayload
    {
        public ushort SubscriptionIdLength = 0;
        [WireInfo(SizeParam="SubscriptionIdLength")]
        public string SubscriptionId = "";
        [WireInfo(Max = XeGetUserSubscriptionDetailsResponse.maxDescriptionLength)]
        public ushort DescriptionLength = 0;
        [WireInfo(SizeParam="DescriptionLength")]
        public string Description = "";
        public byte CurrentOfferStatus;

        [WireInfo(MinSchemaVersion = "4.3")]
        public bool delayedCancel;
        [WireInfo(Max = XeGetUserSubscriptionDetailsResponse.maxFriendlyNameLength)]
        public ushort FriendlyNameLength = 0;
        [WireInfo(SizeParam="FriendlyNameLength")]
        public string FriendlyName = "";
        public byte AnniversaryDate;
        public DateTime PurchaseDate = DateTime.UtcNow;
        public DateTime ActivationDate = DateTime.UtcNow;
        public DateTime EndDate = DateTime.UtcNow;
        public byte HasViolations;
        public uint RenewalGracePeriod;
        public byte RenewalOfferStatus;
        public ulong RenewalOfferId;
        public UserSubscriptionDetailsData CurrentOfferDetails;
        public UserSubscriptionDetailsData RenewalOfferDetails;
        public PaymentInstrumentInfoEx PaymentInstrument;
    }

    public class UserSubscriptionDetailsData : XRLPayload
    {   
        public uint WholePart;
        public byte FractionalPart;
        public byte CurrencyFormat;
        public ushort IsoCodeLength;
        [WireInfo(SizeParam="IsoCodeLength")]
        public string IsoCode;
        public ushort FormattedPriceLength;
        [WireInfo(SizeParam="FormattedPriceLength")]
        public string FormattedPrice;
        public uint OfferingDetails;
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGraduateUser.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGraduateUserRequest : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        // The xuid of the new dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public XRLXeGraduateUserRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGraduateUser.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            // to support schema version
            //if (!this.CustomHeader.Contains("X-Schema-Ver:"))
            //    this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            Console.WriteLine("XRLXeGraduateUserRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeGraduateUserRequest Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGetUserWebInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGetUserWebInfo : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        [WireInfo(MinSchemaVersion = "4.0")]
        public uint ServiceType = (uint)ServiceTypeEnum.XboxLive;

        public XRLXeGetUserWebInfo()
        {
            // need to use HTTP auth for web-only requests
            UseHttpAuth = true;

            // need to be the web_title_id to use this SPI
            Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGetUserWebInfo.ashx";
        }

        public bool Execute(out XRLXeGetUserWebInfoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetUserWebInfoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetUserWebInfoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetUserWebInfoResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetUserWebInfoResponse : XRLPayload
    {
        [WireInfo(Serialize = false)]
        public static DateTime DummyMinDate = new DateTime(1900, 1, 1);

        [WireInfo(ArraySize = XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[] UserPrivileges;
        public uint Tier;
        public DateTime LastWebActivity;
        public int ParentalControlGroupId;

        [WireInfo(MinSchemaVersion = "2.0")]
        public byte UserType;

        [WireInfo(MinSchemaVersion = "4.0")]
        public bool BillingUnavailable;

        [WireInfo(MinSchemaVersion = "4.0")]
        public bool IsLightweight;

        [WireInfo(MinSchemaVersion = "5.5")]
        public ushort BillingAccountIdLength;

        [WireInfo(MinSchemaVersion = "5.5", SizeParam="BillingAccountIdLength")]
        public string BillingAccountId;

        [WireInfo(MinSchemaVersion="6.1")]
        public bool isFreeGamertagChangeEligible;

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime lastMigratedDate;   

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime migrationEligibilityDate;    

        [WireInfo(MinSchemaVersion="6.6")]
        public bool isMigrationEligible;    

        [WireInfo(MinSchemaVersion="6.8")]
        public bool isParentallyControlled;    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeMigrateXbox1User.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeMigrateXbox1User : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedUserPassportPuid;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedParentPassportPuid;
        public ulong OfflineXuid;
        public ushort UserPassportMemberNameLength;
        [WireInfo(SizeParam="UserPassportMemberNameLength")]
        public string UserPassportMemberName;
        public uint TitleId;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort LanguageId;
        public ushort ReservedBytesLength = 0;
        [WireInfo(SizeParam="ReservedBytesLength")]
        public byte[] ReservedBytes;



        public XRLXeMigrateXbox1User()
        {
            this.MachinePuid = 0xfa00000012341234;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
            this.LanguageId = 1;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeMigrateXbox1User.ashx";
        }

        public bool Execute(out XRLXeMigrateXbox1UserResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeMigrateXbox1UserResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeMigrateXbox1UserResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeMigrateXbox1UserResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeMigrateXbox1UserResponse : XRLPayload
    {
        public ulong UserPuid;
        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] XenonKey;
        public ushort GamerTagLength;
        [WireInfo(SizeParam="GamerTagLength")]
        public string GamerTag;
        public ushort DomainLength;
        [WireInfo(SizeParam="DomainLength")]
        public string Domain;
        public ushort RealmLength;
        [WireInfo(SizeParam="RealmLength")]
        public string Realm;
        public int ParentalControlGroupId;
        public int CultureId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeLinkXbox1Account.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeLinkXbox1Account : XRLPayload
    {
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleId = 0;
        public ushort GamertagLength;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedUserPassportPuid;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOwnerPassportPuid;
        public PhoneInfoData PhoneInfo;
        public ushort PostalCodeLength;
        [WireInfo(SizeParam="PostalCodeLength")]
        public string PostalCode;
        public ushort CardHolderLength;
        [WireInfo(SizeParam="CardHolderLength")]
        public string CardHolder;
        public ushort CardNumberLength;
        [WireInfo(SizeParam="CardNumberLength")]
        public string CardNumber;

        public XRLXeLinkXbox1Account()
        {
            // default values
            this.Slot.SetClientType(FakeSG.CSGInfo.ClientType.Xenon);
            this.PhoneInfo = new PhoneInfoData();
            this.MachinePuid = 0xfa00000012341234;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeLinkXbox1Account.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportChangePassword.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportChangePassword : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SessionToken;

        public ushort PassportMemberNameLength = 0;
        [WireInfo(SizeParam="PassportMemberNameLength")]
        public string PassportMemberName;

        public ushort EncryptedPasswordLength = 0;
        [WireInfo(SizeParam="EncryptedPasswordLength")]
        public byte[] EncryptedPassword;

        
        protected override string GetServiceName()
        {
            return "/xuacs/XePassportChangePassword.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeMigrateXboxComUser.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.LiveService.Billing;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeMigrateXboxComUser : XRLPayload
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedPassportPuid;
        public ulong OfflineXuid;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;
        public byte CountryId;
        public ushort LanguageId;
        public ulong OfferId = 0;
        public ushort BillingTokenLength = 0;
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken = "";
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam = "FirstNameLength")]
        public string FirstName;
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam = "LastNameLength")]
        public string LastName;
        public ushort EmailLength;
        [WireInfo(SizeParam = "EmailLength")]
        public string Email;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public byte PaymentInstrumentType = 0;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;

        public XRLXeMigrateXboxComUser()
            : this((byte)XeUser.Country.US, (ushort)XeUser.Language.en)
        {
        }

        public XRLXeMigrateXboxComUser(byte countryId, ushort languageId)
        {
            Slot.SetClientType(FakeSG.CSGInfo.ClientType.Xenon);
            TitleId = XOn.XENON_DASH_TITLE_ID;
            MachinePuid = 0xfa00000012341234;
            CountryId = countryId;
            LanguageId = languageId;
            OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
            PaymentInstrumentType = (byte)XRLXeAddPaymentInstrument.PaymentInstrumentTypeEnum.None;
            FirstName = "Clippy";
            LastName = "Paperclip";
            Email = "annoyingfeature@microsoft.com";
            AddressInfo = new AddressInfoData();
            AddressInfo.SetDefaultAddress((XeUser.Country)CountryId);
            PhoneInfo = new PhoneInfoData();
            PhoneInfo.PhonePrefix = "425";
            PhoneInfo.PhoneNumber = "707-5555";
            CreditCardInfo = new CreditCardInfoData();
            DirectDebitInfo = new DirectDebitInfoData();
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeMigrateXboxComUser.ashx";
        }

        public bool Execute(out XRLXeMigrateXboxComUserResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeMigrateXboxComUserResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeMigrateXboxComUserResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeMigrateXboxComUserResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeMigrateXboxComUserResponse : XRLPayload
    {
		public ulong UserPuid;
		
        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] XenonKey;

		public ushort GamerTagLength;
		[WireInfo(SizeParam="GamerTagLength")]
		public string GamerTag;

        public ushort DomainLength;
        [WireInfo(SizeParam="DomainLength")]
        public string Domain;

        public ushort RealmLength;
        [WireInfo(SizeParam="RealmLength")]
        public string Realm;

        public int ParentalControlGroupId;

        public int CultureId;
		
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetEncryptedProxyParameters.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetEncryptedProxyParameters : XRLPayload
    {
        [WireInfo(MinSchemaVersion="3.0")]
        public int EPLServiceId = 0;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetEncryptedProxyParameters.ashx";
        }

        public bool Execute(out XRLXePassportGetEncryptedProxyParametersResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetEncryptedProxyParametersResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetEncryptedProxyParametersResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetEncryptedProxyParametersResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetEncryptedProxyParametersResponse : XRLPayload
    {
        public ushort LoginTokenRequestLength = 0;
        [WireInfo(SizeParam="LoginTokenRequestLength")]
        public string LoginTokenRequest;
        public uint PublicKeyPublicExponent;
        public ushort PublicKeyModulusLength;
        [WireInfo(SizeParam="PublicKeyModulusLength")]
        public byte[] PublicKeyModulus;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN)]
        public byte[] PublicKeyDigest;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportCreate.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportCreate : XRLPayload
    {
        public ushort PassportMemberNameLength = 0;
        [WireInfo(SizeParam="PassportMemberNameLength")]
        public string PassportMemberName;
        public ushort SecretQuestionLength = 0;
        [WireInfo(SizeParam="SecretQuestionLength")]
        public string SecretQuestion;
        public ushort EncryptedPasswordLength = 0;
        [WireInfo(SizeParam="EncryptedPasswordLength")]
        public byte[] EncryptedPassword;
        
        [WireInfo(MinSchemaVersion = "4.0")]
        public byte countryId = 0;

        [WireInfo(MinSchemaVersion = "4.0")]
        public DateTime birthdate = DateTime.FromFileTimeUtc(0);

        // Max = 1 specifies that the data is optional, no other way to declare that in wiredata
        [WireInfo(MinSchemaVersion = "7.1", Max = 1)]
        public ushort accountProofLength;

        [WireInfo(MinSchemaVersion = "7.1", SizeParam = "accountProofLength")]
        public ProofData[] accountProof;

        private bool m_useAlternateUrl = false;

        public bool UseAlternateUrl
        {
            set { m_useAlternateUrl = value; }
            get { return m_useAlternateUrl; }
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XePassportCreate.ashx";
        }

        public bool Execute(out XRLXePassportCreateResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportCreateResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportCreateResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );
            
            string[] additionalHeaderItems = null;
            if (m_useAlternateUrl)
            {
                IPAddress[] a = Dns.GetHostEntry(Dns.GetHostName()).AddressList;
                for (int i=0; i<a.Length; i++)
                {
                    if (a[i].ToString().IndexOf("10.20.2") == 0)
                    {
                        additionalHeaderItems = new string[1];
                        additionalHeaderItems[0] = "AlternatePassportUrl: http://" + a[i].ToString() + "/";
                    }
                }
            }

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportCreateResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportCreateResponse : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SessionToken;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetBuddyGamertag.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetBuddyGamertag : XRLPayload
    {    
        public ulong userPuid;
        public ushort buddyPmnLength = 0;
        [WireInfo(SizeParam="buddyPmnLength")]
        public string buddyPmn;


        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetBuddyGamertag.ashx";
        }

        public bool Execute(out XRLXePassportGetBuddyGamertagResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetBuddyGamertagResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetBuddyGamertagResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetBuddyGamertagResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetBuddyGamertagResponse : XRLPayload
    {
        public ulong buddyPuid;

        public ushort buddyGamertagLength = 0;

        [WireInfo(SizeParam="buddyGamertagLength")]
        public string buddyGamertag;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeGraduateUserEx.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeGraduateUserExRequest : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;

        // The xuid of the new dependent
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;

        public AddressInfoData AddressInfo;

        public PhoneInfoData PhoneInfo;

        public byte PaymentInstrumentType = 0;

        public CreditCardInfoDataEx CreditCardInfoEx;

        public DirectDebitInfoDataEx DirectDebitInfoEx;

        public XRLXeGraduateUserExRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeGraduateUserEx.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeGraduateUserExRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeGraduateUserExRequest Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetMemberName.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetMemberName : XRLPayload
    {    
        public ulong userPuid;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetMemberName.ashx";
        }

        public bool Execute(out XRLXePassportGetMemberNameResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetMemberNameResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetMemberNameResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetMemberNameResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetMemberNameResponse : XRLPayload
    {
        public ushort UserPmnLength = 0;        
        [WireInfo(SizeParam="UserPmnLength")]
        public string UserPmn;
        
        public ushort ParentPmnLength = 0;        
        [WireInfo(SizeParam="ParentPmnLength")]
        public string ParentPmn;

        [WireInfo(MinSchemaVersion = "3.1")]
        public ushort cidLength = 0;

        [WireInfo(SizeParam = "cidLength", MinSchemaVersion = "3.1")]
        public string userCid;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetSecretQuestions.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetSecretQuestions : XRLPayload
    {
        public ushort CountryId;
        public ushort LanguageId;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetSecretQuestions.ashx";
        }

        public bool Execute(out XRLXePassportGetSecretQuestionsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetSecretQuestionsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetSecretQuestionsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetSecretQuestionsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetSecretQuestionsResponse : XRLPayload
    {
        public ushort SecretQuestionsCount;
        [WireInfo(SizeParam="SecretQuestionsCount")]
        public XRLPassportSecretQuestion[] SecretQuestions;
    }

    public class XRLPassportSecretQuestion : XRLPayload
    {
        public ushort SecretQuestionLength;
        [WireInfo(SizeParam="SecretQuestionLength")]
        public string SecretQuestion;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetUserData.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetUserData : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SessionToken;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetUserData.ashx";
        }

        public bool Execute(out XRLXePassportGetUserDataResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetUserDataResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetUserDataResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetUserDataResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetUserDataResponse : XRLPayload
    {
        public ushort            FirstNameLength;
        [WireInfo(SizeParam="FirstNameLength")]
        public string            FirstName;
        public ushort            LastNameLength;
        [WireInfo(SizeParam="LastNameLength")]
        public string            LastName;
        public DateTime          Birthdate;
        public AddressInfoData   AddressInfo;
        public PhoneInfoData     PhoneInfo;
        public byte              CountryId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetFriendMemberName.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetFriendMemberName : XRLPayload
    {    
        public ulong userPuid;
        public ulong friendPuid;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetFriendMemberName.ashx";
        }

        public bool Execute(out XRLXePassportGetFriendMemberNameResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetFriendMemberNameResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetFriendMemberNameResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetFriendMemberNameResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportGetFriendMemberNameResponse : XRLPayload
    {
        public ushort friendPmnLength = 0;
        [WireInfo(SizeParam="friendPmnLength")]
        public string friendPmn;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportLogin.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportLogin : XRLPayload
    {
        public ushort PassportMemberNameLength = 0;
        [WireInfo(SizeParam="PassportMemberNameLength")]
        public string PassportMemberName;
        public ushort EncryptedSessionKeyLength = 0;
        [WireInfo(SizeParam="EncryptedSessionKeyLength")]
        public byte[] EncryptedSessionKey;
        public ushort EncryptedPasswordLength = 0;
        [WireInfo(SizeParam="EncryptedPasswordLength")]
        public byte[] EncryptedPassword;
        public ushort EncryptedTokenRequestLength = 0;
        [WireInfo(SizeParam="EncryptedTokenRequestLength")]
        public byte[] EncryptedTokenRequest;
        [WireInfo(MinSchemaVersion="3.0")]
        public int EPLServiceId = XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID;

        [WireInfo(Serialize=false)]
        public uint overrideRequestSchemaVersion = 0;
        [WireInfo(Serialize=false)]
        public uint overrideResponseSchemaVersion = 0;
        
        private bool m_useEmulator = false;
        private string m_alternateUrl = "";
        public bool UseEmulator { get { return m_useEmulator; } set { m_useEmulator = value; } }
        public string AlternateUrl { get { return m_alternateUrl; } set { m_alternateUrl = value;  } }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XePassportLogin.ashx";
        }

        public bool Execute(out XRLXePassportLoginResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportLoginResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportLoginResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            if (m_useEmulator)
            {
                base.CustomHeader = "AlternatePassportUrl:  " + m_alternateUrl + "\r\n"; 
            }

            // Special case for testing legacy XePassportLogin
            if(this.overrideRequestSchemaVersion != 0)
                this.SchemaVersion = this.overrideRequestSchemaVersion;

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportLoginResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    // Special case for testing legacy XePassportLogin
                    if(this.overrideResponseSchemaVersion != 0)
                        Response.SchemaVersion = this.overrideResponseSchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePassportLoginResponse : XRLPayload
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SessionToken;
        [WireInfo(MinSchemaVersion="3.0")]
        public ushort nonceLength;
        [WireInfo(SizeParam="nonceLength", MinSchemaVersion="3.0")]
        public byte[] nonce;
        [WireInfo(MinSchemaVersion="3.0")]
        public ushort cipherValueLength;
        [WireInfo(SizeParam="cipherValueLength", MinSchemaVersion="3.0")]
        public byte[] cipherValue;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePassportGetPuidFromMemberName.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXePassportGetPuidFromMemberName : XRLPayload
    {    
        public ushort memberNameLength;

        [WireInfo(SizeParam = "memberNameLength")]
        public string memberName;

        protected override string GetServiceName()
        {
            return "/xuacs/XePassportGetPuidFromMemberName.ashx";
        }

        public bool Execute(out XRLXePassportGetPuidFromMemberNameResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePassportGetPuidFromMemberNameResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePassportGetPuidFromMemberNameResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXePassportGetPuidFromMemberNameResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }
        
    public class XRLXePassportGetPuidFromMemberNameResponse : XRLPayload
    {
        [WireInfo(HexString = true)]
        public ulong passportPuid;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXePreviewMergeSubscription.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    /// <summary>
    /// Request class for Preview Merge subscription. Takes primary and secondary puid
    /// </summary>
    public class PreviewMergeSubscriptionRequest : XRLPayload
    {
        // The xuid of the primary family gold primary user
        [XRLPayloadFld(IsUPuid = true)]
        public ulong primaryUserPuid = 0;

        // The xuid of the secondary  gold  user whose subscription is being merged with Primary
        public ulong secondaryUserPuid = 0;

        // 0 if there's no owner passport token, 1 if there is.
        // a passport token is required if the secondary user is not a
        // dependent of the primary user.
        [WireInfo(Max = 1)]
        public ushort ownerPassportTokenLength;

        // The passport token of the secondary's owner
        [WireInfo(SizeParam = "ownerPassportTokenLength")]
        public PassportToken[] ownerPassportToken;

        protected override string GetServiceName()
        {
             return "/xuacs/PreviewMergeSubscription.ashx"; 
        }
        public bool Execute(out PreviewMergeSubscriptionResponse response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out response);
        }
        public bool Execute(IPEndPoint endPoint, out PreviewMergeSubscriptionResponse response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);


            byte[] httpHeader = GenerateHttpHeader(endPoint, reqStream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();


            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    response = new PreviewMergeSubscriptionResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }

    }
    /// <summary>
    /// Response for PreviewMergeSubscription Request
    /// </summary>
    public class PreviewMergeSubscriptionResponse : XRLPayload
    {
        //Months transfered to Family gold subscription
        public uint monthsTransereferred;

        //Next charge data for family gold subscription
        public DateTime nextChargeDate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeRemoveDependent.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeRemoveDependentRequest : XRLPayload
    {
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        // The xuid of the dependent being removed from the family
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        // The xuid of the owner performing the remove operation
        [XRLPayloadFld(IsUPuid = true)]
        public ulong ownerPuid;

        public XRLXeRemoveDependentRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xuacs/RemoveDependent.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeRemoveDependentRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeRemoveDependentRequest Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeRemovePaymentInstrument.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeRemovePaymentInstrument : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort PaymentInstrumentIdLength = 0;
        [WireInfo(SizeParam="PaymentInstrumentIdLength")]
        public string PaymentInstrumentId;

        public XRLXeRemovePaymentInstrument()
        {
            this.MachinePuid = 0xfa00000012341234;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeRemovePaymentInstrument.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeReplaceUserPassport.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeReplaceUserPassport : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;
        public uint TitleId;
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedNewUserPassportPuid;
        public ushort NewUserPassportMemberNameLength;
        [WireInfo(SizeParam = "NewUserPassportMemberNameLength")]
        public string NewUserPassportMemberName;
        public bool TransferBalance;

        public XRLXeReplaceUserPassport()
        {
            this.MachinePuid = MachineEditor.CreateNew().Id;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
            this.TransferBalance = true;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeReplaceUserPassport.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeReserveGamertag.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeReserveGamertag : XRLPayload
    {
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0xfa00000032323232;
        public byte CountryId = 103;
        public ushort MaxSuggestedNames = 10;
        public ushort GamertagLength  = 0;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag;
            
        protected override string GetServiceName()
        {
            return "/xuacs/XeReserveGamertag.ashx";
        }

        public bool Execute(out XRLXeReserveGamertagResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeReserveGamertagResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeReserveGamertagResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeReserveGamertagResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeReserveGamertagSuggestedName : XRLPayload
    {
        public ushort NameLength;
        [WireInfo(SizeParam="NameLength")]
        public string Name;
    }

    public class XRLXeReserveGamertagResponse : XRLPayload
    {
        public uint hr;
        public ushort NameCount;
        [WireInfo(SizeParam="NameCount")]
        public XRLXeReserveGamertagSuggestedName[] names;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeRecoverAccount.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeRecoverAccount : XRLPayload<XeRecoverAccountRequest, XeRecoverAccountResponse>
    {
        public XRLXeRecoverAccount()
        {
            // Set the machinePuid in the request to something semi-valid, but 
            // recognizable if it's not properly being set by the user
            this.Request.machinePuid = 0xFA00000012341234;

            // 10/12/2009 - RaphaMun checked in server code to validate that the calling code is at least 6.1.
            // Calls made without the schema version default to 1.0 which is rejected after RaphaMun's changes
            // This also requires adding an override to Execute to add the schema version to the header since
            // the default XRLPayload::Execute() doesn't add the schema version in the header by default
            this.SchemaVersion = WireData.MakeSchemaVersion(6, 1);
        }

        /// <summary>
        /// Execute this XeRecoverAccount request against the xuacs virtual interface
        /// </summary>
        /// <returns>True if the request was successful, false otherwise</returns>
        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        /// <summary>
        /// Execute this request using the appropriate request type and reads
        /// the response as appropriate
        /// </summary>
        /// <param name="endPoint">The endpoint against which to execute the request</param>
        /// <returns>True if the request was successfull, false otherwise.</returns>
        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            Request.WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
                {
                    if (xAct.ResponseContents.Length > 0)
                        ReadResponse(new MemoryStream(xAct.ResponseContents));
                    uRet = true;
                }
            }

            return uRet;
        }

        /// <summary>
        /// Populates the appropritate variables in the SG Slot with values from the request
        /// </summary>
        /// <param name="slot">The SGSlot to populate</param>
        public override void PopulateSlot(ref CSGInfo slot)
        {
            this.Slot.titleId = XOn.XENON_DASH_TITLE_ID;
            this.Slot.machinePuid = Request.machinePuid;
            this.Slot.SetClientType(CSGInfo.ClientInfo.ToClientType(Request.machinePuid));
            
            base.PopulateSlot(ref slot);
        }
    }

    public class XeRecoverAccountRequest60 : XRLPayload
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;

        private XRLObject2 XRLObject2Response = null;
        /// <summary>
        /// The response object that the response data will be read into after execution
        /// </summary>
        public XeRecoverAccountResponse Response
        {
            get { return (XeRecoverAccountResponse)XRLObject2Response; }
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeRecoverAccount.ashx";
        }

        public XeRecoverAccountRequest60()
        {
            // Set the machinePuid in the request to something semi-valid, but 
            // recognizable if it's not properly being set by the user
            this.machinePuid = 0xFA00000012341234;

            // 10/12/2009 - RaphaMun checked in server code to validate that the calling code is at least 6.1.
            // Calls made without the schema version default to 1.0 which is rejected after RaphaMun's changes
            // This also requires adding an override to Execute to add the schema version to the header since
            // the default XRLPayload::Execute() doesn't add the schema version in the header by default
            this.SchemaVersion = WireData.MakeSchemaVersion(6, 0);
        }

        /// <summary>
        /// Execute this XeRecoverAccount request against the xuacs virtual interface
        /// </summary>
        /// <returns>True if the request was successful, false otherwise</returns>
        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        /// <summary>
        /// Execute this request using the appropriate request type and reads
        /// the response as appropriate
        /// </summary>
        /// <param name="endPoint">The endpoint against which to execute the request</param>
        /// <returns>True if the request was successfull, false otherwise.</returns>
        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            this.WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
                {
                    if (xAct.ResponseContents.Length > 0)
                        ReadResponse(new MemoryStream(xAct.ResponseContents));
                    uRet = true;
                }
            }

            return uRet;
        }

        protected override void ReadResponse(MemoryStream responseStream)
        {
            XRLObject2Response = new XeRecoverAccountResponse();

            if (responseStream != null)
            {
                Response.ReadStream(responseStream);
            }
        }

        /// <summary>
        /// Populates the appropritate variables in the SG Slot with values from the request
        /// </summary>
        /// <param name="slot">The SGSlot to populate</param>
        public override void PopulateSlot(ref CSGInfo slot)
        {
            this.Slot.titleId = XOn.XENON_DASH_TITLE_ID;
            this.Slot.machinePuid = this.machinePuid;
            this.Slot.SetClientType(CSGInfo.ClientInfo.ToClientType(this.machinePuid));

            base.PopulateSlot(ref slot);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeReplaceOwnerPassport.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeReplaceOwnerPassport : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;
        public uint TitleId;
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedNewOwnerPassportPuid;

        public XRLXeReplaceOwnerPassport()
        {
            this.MachinePuid = MachineEditor.CreateNew().Id;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeReplaceOwnerPassport.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeSwitchUserPassport.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeSwitchUserPassport : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid = MachineEditor.CreateNew().Id;
        public uint   TitleId;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedOldUserPassportPuid;
        public ushort OldUserPassportMemberNameLength;
        [WireInfo(SizeParam="OldUserPassportMemberNameLength")]
        public string OldUserPassportMemberName;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedNewUserPassportPuid;
        public ushort NewUserPassportMemberNameLength;
        [WireInfo(SizeParam="NewUserPassportMemberNameLength")]
        public string NewUserPassportMemberName;
        public bool   TransferBalance = true;
        public ushort ReservedBytesLength = 0;
        [WireInfo(SizeParam="ReservedBytesLength")]
        public byte[] ReservedBytes;

        
        public XRLXeSwitchUserPassport()
        {
            this.TitleId = XOn.XENON_DASH_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeSwitchUserPassport.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeSetAccountInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeSetAccountInfo : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid = 0xfa00000012341234;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName;
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName;
        public DateTime Birthdate;
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public ushort LanguageId;
        public byte MsftOptIn;
        public byte PartnerOptIn;

        public XRLXeSetAccountInfo()
        {
            this.Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeSetAccountInfo.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpdateParentalControlGroup.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUpdateParentalControlGroupRequest : XRLPayload
    {
        // The target user to update
        [XRLPayloadFld(IsUPuid = true)]
        public ulong    UserPuid           =0;

        // The new parental control group to set on the target user.
        public int parentalControlGroupId;

        // 0 if there's no owner passport token, 1 if there is.
        [WireInfo(Max=1)]
        public ushort ownerPassportLength;

        // The passport token of the target's owner
        [WireInfo(SizeParam = "ownerPassportLength")]
        public PassportToken[] ownerPassport;

        protected override string GetServiceName()
        {
            return "/xuacs/UpdateParentalControlGroup.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            int class_size = this.Size();
            MemoryStream memory_stream = new MemoryStream(class_size);
            WriteStream(memory_stream);

            Console.WriteLine("XRLXeUpdateParentalControlGroupRequest Called...");

            byte[] httpHeader = GenerateHttpHeader(endPoint, memory_stream);
            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();

            Console.WriteLine("HTTP Header: {0}", new string(AE.GetChars(httpHeader)));

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, memory_stream);

            Console.WriteLine("XRLXeUpdateParentalControlGroupRequest Internal Execute Returned {0}", bRet);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }
            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeTroubleshootAccount.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeTroubleshootAccount : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort ReservedBytesLength;
        [WireInfo(SizeParam="ReservedBytesLength")]
        public byte[] ReservedBytes;
        
        public XRLXeTroubleshootAccount()
        {
            this.MachinePuid = MachineEditor.CreateNew().Id;
            this.Slot.titleId = XOn.XENON_DASH_TITLE_ID;
            this.Slot.SetClientType(FakeSG.CSGInfo.ClientType.Xenon);
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeTroubleshootAccount.ashx";
        }

        public bool Execute(out XRLXeTroubleshootAccountResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeTroubleshootAccountResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeTroubleshootAccountResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeTroubleshootAccountResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeTroubleshootAccountResponse : XRLPayload
    {
        public int NewTOS;
        public int NameChangeRequired;
        public int Downgraded;
        public DateTime SuspendedUntil = DateTime.UtcNow;
        public ushort TotalDaysSuspended;
        public DateTime VoiceBannedUntil = DateTime.UtcNow;
        public ushort TotalDaysVoiceBanned;
        public uint BillingHR;        
        [WireInfo(MinSchemaVersion = "5.1")] 
        public int userPassportInvalid;
        [WireInfo(MinSchemaVersion = "5.1")]
        public int ownerPassportInvalid;
        [WireInfo(MinSchemaVersion = "9.0")]
        public int GamertagRecycled;
        [WireInfo(Max = 1024)]
        public ushort ReservedBytesLength;
        [WireInfo(SizeParam = "ReservedBytesLength")]
        public byte[] ReservedBytes;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpdatePaymentInstrument.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUpdatePaymentInstrument : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort PaymentInstrumentIdLength = 0;
        [WireInfo(SizeParam="PaymentInstrumentIdLength")]
        public string PaymentInstrumentId;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public CreditCardInfoData CreditCardInfo;
        public DirectDebitInfoData DirectDebitInfo;
        
        public XRLXeUpdatePaymentInstrument()
        {
            this.MachinePuid = 0xfa00000012341234;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpdatePaymentInstrument.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpdateParentalControls.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class PassportToken : WireData
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;   // Passport session ticket.

        public static implicit operator byte[] (PassportToken value)
        {
            return value.signedPuid;
        }

        public static implicit operator PassportToken(byte[] value)
        {
            PassportToken t = new PassportToken();
            t.signedPuid = value;
            return t;
        }
    }
    
    public class XRLXeUpdateParentalControls : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong    UserPuid           =0;

        [WireInfo(ArraySize = 8 /*XOn.PRIVILEGE_DWORD_LENGTH*/)]
        public uint[] UserGrantPrivileges;

        [WireInfo(ArraySize = 8 /*XOn.PRIVILEGE_DWORD_LENGTH*/)]
        public uint[] UserRestrictPrivileges;

        [WireInfo(Min = 1, Max = 300/*XOn.XONLINE_MAX_PARENTAL_CONTROLS_SOURCE_LENGTH * XOn.UTF8_MULT*/ )]
        public ushort SourceLength = 0;

        [WireInfo(SizeParam = "SourceLength")]
        public string Source;

        [WireInfo(MinSchemaVersion = "6.3")]
        public ushort tokenLength = 0;

        [WireInfo(MinSchemaVersion = "6.3", SizeParam = "tokenLength")]
        public PassportToken[] Tokens;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint setProfilePermissionEntries = 0;

        [WireInfo(MinSchemaVersion = "6.5")]
        public uint clearProfilePermissionEntries = 0;

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpdateParentalControls.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(1024);
            WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpdateXboxComActivity.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;



namespace ServerTestFramework.LiveService.UserAccount
{
    public enum ServiceTypeEnum : uint
    {
        Unknown     = 0,
        XboxLive    = 1,
        Zune        = 2,
    }

    public class XRLXeUpdateXboxComActivity : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;

        [WireInfo(MinSchemaVersion = "4.0")]
        public uint ServiceType = (uint)ServiceTypeEnum.XboxLive;

        public XRLXeUpdateXboxComActivity()
        {
            // need to use HTTP auth for web-only requests
            UseHttpAuth = true;

            Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpdateXboxComActivity.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpsGetProfile.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUpsGetProfile : XRLPayload
    {
        public ulong  Puid;
        public ushort AttributesLength = 0;
        [WireInfo(SizeParam="AttributesLength")]
        public string Attributes;

        public XRLXeUpsGetProfile()
        {
            this.Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpsGetProfile.ashx";
        }

        public bool Execute(out XRLXeUpsGetProfileResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeUpsGetProfileResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeUpsGetProfileResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeUpsGetProfileResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeUpsGetProfileResponse : XRLPayload
    {
        public ushort ProfileLength = 0;
        [WireInfo(SizeParam="ProfileLength")]        
        public string Profile;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpsUpdateProfile.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUpsUpdateProfile : XRLPayload
    {
        public ushort ProfileLength = 0;
        [WireInfo(SizeParam="ProfileLength")]        
        public string Profile;

        public XRLXeUpsUpdateProfile()
        {
            Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpsUpdateProfile.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUpdatePaymentInstrumentEx.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System.IO;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUpdatePaymentInstrumentEx : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong MachinePuid;
        public ushort PaymentInstrumentIdLength = 0;
        [WireInfo(SizeParam = "PaymentInstrumentIdLength")]
        public string PaymentInstrumentId;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public CreditCardInfoDataEx CreditCardInfoEx;
        public DirectDebitInfoDataEx DirectDebitInfoEx;

        public XRLXeUpdatePaymentInstrumentEx()
        {
            this.MachinePuid = 0xfa00000012341234;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeUpdatePaymentInstrumentEx.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUserGetAge.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUserGetAgeRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;

        public XRLXeUserGetAgeRequest()
        {
            MachinePuid = MachineEditor.CreateNew().Id;
            TitleId = 0x584107f6; //TEXASHOLDEM_TITLE_ID
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeUserGetAge.ashx";
        }

        public bool Execute(out XRLXeUserGetAgeResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeUserGetAgeResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeUserGetAgeResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeUserGetAgeResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeUserGetAgeResponse : XRLPayload
    {
        public byte userAge;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUserGetAccountInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeUserGetAccountInfoRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint   TitleId;

        public XRLXeUserGetAccountInfoRequest()
        {
            MachinePuid = 0xfa00000012341234;
            TitleId     = XOn.XENON_DASH_TITLE_ID;
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeUserGetAccountInfo.ashx";
        }

        public bool Execute(out XRLXeUserGetAccountInfoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeUserGetAccountInfoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeUserGetAccountInfoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeUserGetAccountInfoResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeUserGetAccountInfoResponse : XRLPayload
    {
        public ushort FirstNameLength;
        
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName;
        
        public ushort LastNameLength;
        
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName;
        
        public AddressInfoData AddressInfo;
        
        public ushort EmailLength;
        
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        
        public ushort LanguageId;
        
        public byte   CountryId;
        
        public byte   Age;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeUserGetAgeGroup.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.Database;


namespace ServerTestFramework.LiveService.UserAccount
{

    public enum UserAgeGroupEnum : uint
    {
        Child = 0,
        Teen = 1,
        Adult = 2,
    }

    public class XRLXeUserGetAgeGroupRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong  UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong  MachinePuid;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;

        public XRLXeUserGetAgeGroupRequest()
        {
            MachinePuid = MachineEditor.CreateNew().Id;
            TitleId = 0x584107f6; //TEXASHOLDEM_TITLE_ID
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeUserGetAgeGroup.ashx";
        }

        public bool Execute(out XRLXeUserGetAgeGroupResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeUserGetAgeGroupResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeUserGetAgeGroupResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeUserGetAgeGroupResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeUserGetAgeGroupResponse : XRLPayload
    {
        public uint userAgeGroup;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeVerifyBillingInfo.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeVerifyBillingInfo : XRLPayload
    {
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ushort GamertagLength;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag;
        public ushort PhonePrefixLength;
        [WireInfo(SizeParam="PhonePrefixLength")]
        public string PhonePrefix;
        public ushort PhoneNumberLength;
        [WireInfo(SizeParam="PhoneNumberLength")]
        public string PhoneNumber;
        public ushort PhoneExtensionLength;
        [WireInfo(SizeParam="PhoneExtensionLength")]
        public string PhoneExtension;
        public ushort PostalCodeLength;
        [WireInfo(SizeParam="PostalCodeLength")]
        public string PostalCode;
        public ushort CardHolderLength;
        [WireInfo(SizeParam="CardHolderLength")]
        public string CardHolder;
        public ushort CardNumberLength;
        [WireInfo(SizeParam="CardNumberLength")]
        public string CardNumber;

        public XRLXeVerifyBillingInfo()
        {
            this.MachinePuid = 0xfa00000012341234;

            // need to use HTTP auth for web-only requests
            UseHttpAuth = true;

            Slot.titleId = XOn.WEB_TITLE_ID;
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeVerifyBillingInfo.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs_int));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeVerifyParentCreditCard.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;


namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeVerifyParentCreditCard : XRLPayload
    {
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0;
        [XRLPayloadFld(IsTitleId=true)]    
        public uint TitleId = 0;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedParentPassportPuid;
        public ushort ParentPassportMemberNameLength = 0;
        [WireInfo(SizeParam="ParentPassportMemberNameLength")]
        public string ParentPassportMemberName;
        public ushort LanguageId;
        public byte CountryId;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName = "";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName = "";
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public CreditCardInfoData CreditCardInfo;

        private ulong m_passportPuid;
        public ulong PassportPuid { get { return m_passportPuid; } }
        
        public XRLXeVerifyParentCreditCard()
        {
			this.Slot.SetClientType(FakeSG.CSGInfo.ClientType.Xenon);

			// populate with dummy data

            this.MachinePuid = 0xfa00000012341234;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;

            this.LanguageId = 1;
            this.CountryId = 103;

            this.FirstName = "MrDad";
            this.LastName = "OfMinor";
            this.Email = "MrDad.OfMinor" + Global.PassportMemberDomain;

            m_passportPuid = Utilities.PassportUtilities.GenerateRandomULong();
            this.SignedParentPassportPuid = Utilities.PassportUtilities.GenerateSessionToken(m_passportPuid, Slot.Key);
            this.ParentPassportMemberName = "xbltest-" + Guid.NewGuid().ToString() + Global.PassportMemberDomain;

            this.AddressInfo = new AddressInfoData();
            this.PhoneInfo = new PhoneInfoData();
            this.CreditCardInfo = new CreditCardInfoData();

            this.AddressInfo.Street1 = "4455 148th Ave NE";
            this.AddressInfo.Street2 = "";
            this.AddressInfo.City = "Bellevue";
            this.AddressInfo.District = "";
            this.AddressInfo.State = "WA";
            this.AddressInfo.PostalCode = "98007";

            this.PhoneInfo.PhonePrefix = "425";
            this.PhoneInfo.PhoneNumber = "861-6245";
            this.PhoneInfo.PhoneExtension = "";
        
            string ccn = ServerTestFramework.Utilities.CreditCardRandomizer.GetRandomAccountNumber("visa");
            this.CreditCardInfo.AccountHolderName = "MrDad OfMinor";
            this.CreditCardInfo.AccountNumber = ccn;
            this.CreditCardInfo.CardType = (byte)CreditCardInfoData.CreditCardType.Visa;
            this.CreditCardInfo.CcvNumber = "123";
            this.CreditCardInfo.ExpirationDate = DateTime.UtcNow.AddYears(2);
        }
        
        protected override string GetServiceName()
        {
            return "/xuacs/XeVerifyParentCreditCard.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\DBHelper.cs ===
using System;
using System.Data;
using System.Net;
using System.Data.SqlClient;
using xonline.common.config;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using ServerTestFramework.Database;

namespace ServerTestFramework.LiveService.UserSettings
{
    /// <summary>
    /// Summary description for DBHelper.
    /// </summary>
    ///
    public enum TestUSetting
    {
        Test_int64		=272670721,
        Test_Activity	=272670722,
        Test_UCC		=272670723,
        Test_Console_RO	=272670724,
        Test_Web_RO		=272670725,
        Test_Title_RO	=272670726,
        Test_Not_Shared	=272670727,
        Test_Friend_Only =272670728,
        Test_stringL1	=536977409,
        Test_stringLM	=602447873,
        Test_stringLM_1	=602382337,
        Test_stringLM_2	=569679873,
        Test_binary1	=805412865,
        Test_binary8	=805871617,
        Test_binary16	=806395905,
        Test_binary32	=807444481,
        Test_binary64	=809541633,
        Test_binaryM	=870883329,
        Test_binaryM_1	=870817793,
        Test_binaryM_2	=838115329,
        Test_bMaxNo		=870883330,

    }
    public class DBHelper
    {
        public static bool IsSettingCorrectInDB(int id ,string name, string location,int permission)
        {
            
            string query ="SELECT * from [t_stats_user_setting_ids] where [i_setting_id] = "+id+" and [vc_name] = '"+name+"' and [vc_location] = '"+location+"' and [i_permission_flags] = "+ permission;
            bool returnVal = false;
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            try
            {
                // Execute the command
                SqlDataReader myReader;
                npdb.ReadData(query, out myReader);

                using (myReader)
                {
                    if (myReader.HasRows == false) returnVal = false;
                    else
                        returnVal = true;
                }
            }
            catch(Exception ex)
            {
                Global.RO.Warn("Error quering NPDB for setting ID "+name+"\n" + ex.ToString());
                return false;
                //Global.RO.Info(ex.ToString());
            }
            finally
            {
                npdb.Close();
            }
            return returnVal;

        }
        public static int AddSetting(int id ,string name, string location,int permission)
        {
            if (IsSettingCorrectInDB(id,name,location,permission)) return 0;
            
            string query ="INSERT INTO [t_stats_user_setting_ids]([i_setting_id], [vc_name], [vc_location], [i_permission_flags])";
            query +="VALUES("+id+",'"+name+"','"+location+"',"+permission+")";
            
            int retval = 0;
            try
            {
                // Execute the command
                retval = StaticNpdb.ExecuteNonQuery(query);
            }
            catch(Exception ex)
            {
                Global.RO.Warn("Setting "+name+" already exists in NPDB. " + ex.ToString());
                //Global.RO.Info(ex.ToString());
            }

            return retval;

        }

        //adds specified service type to specified existing user (1 for XBox Live, 2 for Zune) to t_stats_user_per_service_type_data
        public static int AddServiceType(ulong userID ,int serviceType, DateTime acceptedTOS, DateTime provisioned, DateTime suspendedUntil, DateTime lastSuspended, int timesSuspended, DateTime lastActivity, int hashBucket, DateTime lastChanged)
        {
            string query ="INSERT INTO [t_user_per_service_type_data] ";
            query +="VALUES("+userID+", "+serviceType+", '"+acceptedTOS+"', '"+provisioned+"', '"+suspendedUntil+"', '"+lastSuspended+"', "+timesSuspended+", '"+lastActivity+"', "+hashBucket+",'"+lastChanged+"')";

            int retval = UodbWS.ExecuteSQLNonQuery(query, userID);
            
            return retval;

        }

        public static int ClearTestSettings()
        {
            string query= "delete FROM [t_stats_user_setting_ids] where vc_name like 'Test_%'";
            return StaticNpdb.ExecuteNonQuery(query);
        }

        //clears all rows in t_stats_user_per_service_type_data for specified user
        public static int ClearServiceTypeSettingsByUser(ulong userID)
        {
            string query= "delete FROM [t_user_per_service_type_data] where bi_user_puid = "+userID;

            int retval = UodbWS.ExecuteSQLNonQuery(query, userID);

            return retval;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRlEnumContext.cs ===
using System;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserSettings
{
	public class ContextString : WireData
	{
		public uint ContextId;
		public uint NameLen;
		public string Name;
	}    
    
	public class ContextEnumRequest : XRLPayload
	{
		[XRLPayloadFld(IsTitleId=true)]
		public uint TitleId;
		public uint ContextId;
		public ushort LocaleId;
		public uint StartingIndex;
		public uint MaxContexts;

		public ContextEnumRequest(uint title,uint CId,ushort locale,uint stIdx,uint Len)
		{
			TitleId =title;
			ContextId =CId;
			LocaleId =locale;
			StartingIndex=stIdx;
			MaxContexts=Len;


		}
        
		protected override string GetServiceName()
		{
			return "/xstats/contextenum.ashx";
		}

		public new ContextEnumResponse Execute()
		{

			ContextEnumResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );
			
			ManualPopulateSlot();
			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (ContextEnumResponse)new ContextEnumResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (ContextEnumResponse)new ContextEnumResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}
        
            
	}
    
	public class ContextEnumResponse : WireData
	{
		public uint TotalContexts;
       	public uint ContextsLen;
		public ContextString[] Contexts;

		[WireInfo(Serialize=false)]
		public uint XError;
	}
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserAccount\xenon\XRLXeVerifyParentCreditCardEx.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

using System;
using System.IO;
using System.Net;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class XRLXeVerifyParentCreditCardEx : XRLPayload
    {
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid = 0;
        [XRLPayloadFld(IsTitleId=true)]    
        public uint TitleId = 0;
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] SignedParentPassportPuid;
        public ushort ParentPassportMemberNameLength = 0;
        [WireInfo(SizeParam="ParentPassportMemberNameLength")]
        public string ParentPassportMemberName;
        public ushort LanguageId;
        public byte CountryId;
        public ushort FirstNameLength = 0;
        [WireInfo(SizeParam="FirstNameLength")]
        public string FirstName = "";
        public ushort LastNameLength = 0;
        [WireInfo(SizeParam="LastNameLength")]
        public string LastName = "";
        public ushort EmailLength;
        [WireInfo(SizeParam="EmailLength")]
        public string Email;
        public AddressInfoData AddressInfo;
        public PhoneInfoData PhoneInfo;
        public CreditCardInfoDataEx CreditCardInfoEx;
        private ulong m_passportPuid;
        public ulong PassportPuid { get { return m_passportPuid; } }

        public XRLXeVerifyParentCreditCardEx()
        {
			this.Slot.SetClientType(FakeSG.CSGInfo.ClientType.Xenon);

			// populate with dummy data

            this.MachinePuid = 0xfa00000012341234;
            this.TitleId = XOn.XENON_DASH_TITLE_ID;

            this.LanguageId = 1;
            this.CountryId = 103;

            this.FirstName = "MrDad";
            this.LastName = "OfMinor";
            this.Email = "MrDad.OfMinor" + Global.PassportMemberDomain;

            m_passportPuid = Utilities.PassportUtilities.GenerateRandomULong();
            this.SignedParentPassportPuid = Utilities.PassportUtilities.GenerateSessionToken(m_passportPuid, Slot.Key);
            this.ParentPassportMemberName = "xbltest-" + Guid.NewGuid().ToString() + Global.PassportMemberDomain;

            this.AddressInfo = new AddressInfoData();
            this.PhoneInfo = new PhoneInfoData();
            this.CreditCardInfoEx = new CreditCardInfoDataEx();

            this.AddressInfo.Street1 = "4455 148th Ave NE";
            this.AddressInfo.Street2 = "";
            this.AddressInfo.City = "Bellevue";
            this.AddressInfo.District = "";
            this.AddressInfo.State = "WA";
            this.AddressInfo.PostalCode = "98007";

            this.PhoneInfo.PhonePrefix = "425";
            this.PhoneInfo.PhoneNumber = "861-6245";
            this.PhoneInfo.PhoneExtension = "";
        
            string ccn = ServerTestFramework.Utilities.CreditCardRandomizer.GetRandomAccountNumber("visa");
            this.CreditCardInfoEx.AccountHolderName = "MrDad OfMinor";
            this.CreditCardInfoEx.EncryptedAccountNumber = ccn;
            this.CreditCardInfoEx.CardType = (byte)CreditCardInfoData.CreditCardType.Visa;
            this.CreditCardInfoEx.EncryptedCcvNumber = "123";
            this.CreditCardInfoEx.ExpirationDate = DateTime.UtcNow.AddYears(2);
        }

        protected override string GetServiceName()
        {
            return "/xuacs/XeVerifyParentCreditCardEx.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xuacs));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLClearTitle.cs ===
using System;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserSettings
{
	/// <summary>
	/// Summary description for XRLClearTitle.
	/// </summary>
	public class TitleClearRequest : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong UserId;
		public uint TitleId;

		public TitleClearRequest(ulong user,uint title)
		{
			UserId = user;
			TitleId=title;
		}
        
		protected override string GetServiceName()
		{
			return "/xstats/cleartitle.ashx";
		}
            
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLEnumTitle.cs ===
using System;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserSettings
{
	/// <summary>
	/// Summary description for XRLEnumTitle.
	/// </summary>
	public class EnumTitlesRequest : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong UserId;
		public ulong ForUserId;
		public ushort LocaleId= 1033;
		public ushort StartingIndex;
		public ushort MaxTitles;
		[WireInfo(Serialize=false)]
		public uint LogonTitle = 0;

		[WireInfo(Serialize=false)]
		public AuthModify Modifyflag = AuthModify.None;

		[WireInfo(Serialize=false)]
		public uint LanguageID = 0;

		[WireInfo(Serialize=false)]
		public uint CountryID = 32;

		//CountryID


		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);
			Slot.titleId=LogonTitle;
			
			if(Modifyflag == AuthModify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if (Modifyflag == AuthModify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
		/*	else if (Modifyflag == AuthModify.Read_Activity_All)
			{
				Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
			}
			*/
			else if (Modifyflag == AuthModify.Read_Activity_FriendOnly)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}
			else if (Modifyflag == AuthModify.Read_Activity_None)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}

            Slot.SetRegionInfo(CountryID, LanguageID);

			ManualSlotSetup=true;
		}


		

				
		public EnumTitlesRequest() {}
		public EnumTitlesRequest(ulong userId, ulong forUserId, ushort startingIndex, ushort maxTitles)
		{
			UserId = userId;
			ForUserId = forUserId;
			StartingIndex = startingIndex;
			MaxTitles = maxTitles;
		}
        

		public EnumTitlesRequest(ulong userId, ulong forUserId, ushort startingIndex, ushort maxTitles,ushort Locale)
		{
			LocaleId=Locale;
			UserId = userId;
			ForUserId = forUserId;
			StartingIndex = startingIndex;
			MaxTitles = maxTitles;
		}
        
        
		protected override string GetServiceName()
		{
			return "/xstats/enumtitles.ashx";
		}

		public new EnumTitlesResponse Execute()
		{

			EnumTitlesResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );
			
			ManualPopulateSlot();
			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (EnumTitlesResponse)new EnumTitlesResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (EnumTitlesResponse)new EnumTitlesResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}
        

		public  EnumTitlesResponse ExecuteINT()
		{

			IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd_int);
			EnumTitlesResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );
			
			//Conversions
			ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			byte [] addr = endpoint.Address.GetAddressBytes();
			uint ip=0;
			for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];


			HTTPAuthData authData = new HTTPAuthData((ushort) endpoint.Port,ip,requestId,this.UserId,51,(uint)XOService.Stats,0);
			CustomHeader= HTTPAuthData.HTTP_HEADER_AUTH_DATA +":"+authData.GetBase64EncodedString()+"\r\n";

			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd_int),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (EnumTitlesResponse)new EnumTitlesResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (EnumTitlesResponse)new EnumTitlesResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}
        
        
             
	}

	public class EnumTitlesResponse : WireData
	{
		public ushort TitlesLen;
		public UserTitle[] Titles;
		[WireInfo(Serialize=false)]
		public uint XError;
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLReadSettings.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserSettings
{

	public class PROFILE_FLG
	{
		// these are the enforcement bits applied to the setting ids
		public static  int XPROFILE_SETTING_ENFORCE_ACTIVITY     = 0x01;
		public static  int  XPROFILE_SETTING_ENFORCE_UCC         = 0x02;
		public static  int XPROFILE_SETTING_ENFORCE_FRIENDS_ONLY = 0x04;
        public static  int XPROFILE_SETTING_TRANSIENT_ONLY       = 0x08;
		        
		public static int XPROFILE_SETTING_ENFORCE_CONSOLE_RO = 0x10;
		public static int XPROFILE_SETTING_ENFORCE_WEB_RO     = 0x20;
		public static int XPROFILE_SETTING_ENFORCE_TITLE_RO   = 0x40;
		public static int XPROFILE_SETTING_ENFORCE_NOT_SHARED = 0x80;

        public const uint XPROFILE_SETTING_ENFORCE_VIDEO = 0x100;
		        
		// these are the permissions users can select for themselves
		public static byte XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE   = 0x01;
		public static byte XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS = 0x02;
		public static byte XPROFILE_PERMISSION_SHARE_UCC_NOONE        = 0x04;
		public static byte XPROFILE_PERMISSION_SHARE_UCC_FRIENDS      = 0x08;
        public static byte XPROFILE_PERMISSION_SHARE_MUSIC_NOONE      = 0x10;
        public static byte XPROFILE_PERMISSION_SHARE_MUSIC_FRIENDS    = 0x20;

        // New for XPROFILE_VIDEO_METADATA 
        public static byte XPROFILE_PERMISSION_SHARE_VIDEO_OPTION     = 0x40;
        public static byte XPROFILE_PERMISSION_SHARE_VIDEO_EVERYONE   = 0x80;

		        
		public static uint XPROFILE_PERMISSIONS             = 0x10040000;
	}


	public class ProfileDefs
	{
            //deprecated: please use the profile defs below that start with XPROFILE
		public static uint GAMER_TYPE					= 0x10040001;
		public static uint GAMER_ZONE					= 0x10040004;
		public static uint CONTROLLER_INVERSION			= 0x10040002;
		public static uint GAMER_TILE_PATH				= 0x4064000F;
		public static uint GAMER_RATING					= 0x5004000B;
		public static uint GAMER_MOTTO					= 0x402C0011;
		
		public static uint GAMER_CRED					= 0x10040006;
		public static uint TITLE_CRED_EARNED			= 0x10040038;
		public static uint ACHIEVEMENTS_EARNED			= 0x10040013;
		public static uint TITLE_ACHIEVEMENTS_EARNED	= 0x10040039;
              public static uint GAMERCARD_TITLES_PLAYED      = 0x10040012;
		


		// public static uint XPROFILE_GAMER_TIER                       = 0x1004003a;
		// public static uint XPROFILE_GAMERCARD_PICTURE_KEY            = 0x4064000F;
		// public static uint XPROFILE_GAMERCARD_PERSONAL_PICTURE       = 0x40640010;
		//this one was named differently, leaving so as to not break previous tests that might use this
		public static uint XPROFILE_SETTING_CONTROLLER_VIBRATION     = 0x10040003;

        //copied over on 1/10/08 from statsprot.cs
        public static uint XPROFILE_PERMISSIONS                          = 0x10040000;
        public static uint XPROFILE_GAMER_TYPE                           = 0x10040001;
        public static uint XPROFILE_GAMER_YAXIS_INVERSION                = 0x10040002;
        public static uint XPROFILE_OPTION_CONTROLLER_VIBRATION          = 0x10040003;
        public static uint XPROFILE_TITLE_SPECIFIC1                      = 0x63E83FFF;
        public static uint XPROFILE_TITLE_SPECIFIC2                      = 0x63E83FFE;
        public static uint XPROFILE_TITLE_SPECIFIC3                      = 0x63E83FFD;
        public static uint XPROFILE_GAMERCARD_ZONE                       = 0x10040004;
        public static uint XPROFILE_GAMERCARD_REGION                     = 0x10040005;
        public static uint XPROFILE_GAMERCARD_CRED                       = 0x10040006;
        public static uint XPROFILE_GAMER_PRESENCE_USER_STATE            = 0x10040007;
        public static uint XPROFILE_GAMERCARD_HAS_VISION                 = 0x10040008;
        public static uint XPROFILE_GAMERCARD_REP                        = 0x5004000B;
        public static uint XPROFILE_OPTION_VOICE_MUTED                   = 0x1004000C;
        public static uint XPROFILE_OPTION_VOICE_THRU_SPEAKERS           = 0x1004000D;
        public static uint XPROFILE_OPTION_VOICE_VOLUME                  = 0x1004000E;
        public static uint XPROFILE_GAMERCARD_PICTURE_KEY                = 0x4064000F;
        public static uint XPROFILE_GAMERCARD_PERSONAL_PICTURE           = 0x40640010;
        public static uint XPROFILE_GAMERCARD_MOTTO                      = 0x402C0011;
        public static uint XPROFILE_GAMERCARD_TITLES_PLAYED              = 0x10040012;
        public static uint XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED        = 0x10040013;
        public static uint XPROFILE_GAMER_DIFFICULTY                     = 0x10040015;
        public static uint XPROFILE_GAMER_CONTROL_SENSITIVITY            = 0x10040018;
        public static uint XPROFILE_GAMER_PREFERRED_COLOR_FIRST          = 0x1004001d;
        public static uint XPROFILE_GAMER_PREFERRED_COLOR_SECOND         = 0x1004001e;
        public static uint XPROFILE_GAMER_ACTION_AUTO_AIM                = 0x10040022;
        public static uint XPROFILE_GAMER_ACTION_AUTO_CENTER             = 0x10040023;
        public static uint XPROFILE_GAMER_ACTION_MOVEMENT_CONTROL        = 0x10040024;
        public static uint XPROFILE_GAMER_RACE_TRANSMISSION              = 0x10040026;
        public static uint XPROFILE_GAMER_RACE_CAMERA_LOCATION           = 0x10040027;
        public static uint XPROFILE_GAMER_RACE_BRAKE_CONTROL             = 0x10040028;
        public static uint XPROFILE_GAMER_RACE_ACCELERATOR_CONTROL       = 0x10040029;
        public static uint XPROFILE_GAMERCARD_TITLE_CRED_EARNED          = 0x10040038;
        public static uint XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED  = 0x10040039;
        public static uint XPROFILE_GAMER_TIER                           = 0x1004003A;
        public static uint XPROFILE_MESSENGER_SIGNUP_STATE               = 0x1004003B;
        public static uint XPROFILE_MESSENGER_AUTO_SIGNIN                = 0x1004003C;
        public static uint XPROFILE_SAVE_WINDOWS_LIVE_PASSWORD           = 0x1004003D;
        public static uint XPROFILE_FRIENDSAPP_SHOW_BUDDIES              = 0x1004003E;
        public static uint XPROFILE_GAMERCARD_SERVICE_TYPE_FLAGS         = 0x1004003F;
        public static uint XPROFILE_GAMERCARD_USER_NAME                  = 0x41040040;
        public static uint XPROFILE_GAMERCARD_USER_LOCATION              = 0x40520041;
        public static uint XPROFILE_GAMERCARD_USER_URL                   = 0x41900042;
        public static uint XPROFILE_GAMERCARD_USER_BIO                   = 0x43E80043;
        public static uint XPROFILE_GAMERCARD_AVATAR_INFO_1              = 0x63E80044;
        public static uint XPROFILE_GAMERCARD_AVATAR_INFO_2              = 0x63E80045;
        public static uint XPROFILE_GAMERCARD_PARTY_INFO                 = 0x61000046;
        public static uint XPROFILE_VIDEO_METADATA                       = 0x6020004A;


        // Web-only settings
        public static uint WEB_EMAIL_FORMAT                              = 0x10042000;
        public static uint WEB_FLAGS                                     = 0x10042001;
        public static uint WEB_SPAM                                      = 0x10042002;
        public static uint WEB_FAVORITE_GENRE                            = 0x10042003;
        public static uint WEB_FAVORITE_GAME                             = 0x10042004;
        public static uint WEB_FAVORITE_GAME1                            = 0x10042005;
        public static uint WEB_FAVORITE_GAME2                            = 0x10042006;
        public static uint WEB_FAVORITE_GAME3                            = 0x10042007;
        public static uint WEB_FAVORITE_GAME4                            = 0x10042008;
        public static uint WEB_FAVORITE_GAME5                            = 0x10042009;
        public static uint WEB_PLATFORMS_OWNED                           = 0x1004200a;
        public static uint WEB_CONNECTION_SPEED                          = 0x1004200b;
        public static uint WEB_FLASH                                     = 0x1004200c;
        public static uint WEB_VIDEO_PREFERENCE                          = 0x1004200d;

        // Argo/Crux settings
        public static uint XPROFILE_CRUX_MEDIA_PICTURE                   = 0x406403E8;
        public static uint XPROFILE_CRUX_MEDIA_STYLE1                    = 0x100403EA;
        public static uint XPROFILE_CRUX_MEDIA_STYLE2                    = 0x100403EB;
        public static uint XPROFILE_CRUX_MEDIA_STYLE3                    = 0x100403EC;
        public static uint XPROFILE_CRUX_TOP_ALBUM1                      = 0x100403ED;
        public static uint XPROFILE_CRUX_TOP_ALBUM2                      = 0x100403EE;
        public static uint XPROFILE_CRUX_TOP_ALBUM3                      = 0x100403EF;
        public static uint XPROFILE_CRUX_TOP_ALBUM4                      = 0x100403F0;
        public static uint XPROFILE_CRUX_TOP_ALBUM5                      = 0x100403F1;
        public static uint XPROFILE_CRUX_OFFLINE_ID                      = 0x603403F2;
        public static uint XPROFILE_CRUX_BKGD_IMAGE                      = 0x100403F3;
        public static uint XPROFILE_CRUX_LAST_CHANGE_TIME                = 0x700803F4;
        public static uint XPROFILE_CRUX_TOP_MUSIC                       = 0x60A803F5;
        public static uint XPROFILE_CRUX_MEDIA_MOTTO                     = 0x410003F6;
        public static uint XPROFILE_CRUX_TOP_MEDIAID1                    = 0x601003F7;
        public static uint XPROFILE_CRUX_TOP_MEDIAID2                    = 0x601003F8;
        public static uint XPROFILE_CRUX_TOP_MEDIAID3                    = 0x601003F9;
        public static uint XPROFILE_CRUX_BIO                             = 0x43E803FA;
        public static uint XPROFILE_CRUX_BG_SMALL_PUBLIC                 = 0x406403FD;
        public static uint XPROFILE_CRUX_BG_LARGE_PUBLIC                 = 0x406403FE;

        // Bit defines for XPROFILE_GAMER_TYPE
        public static uint XPROFILE_GAMER_TYPE_TEAM                      = 0x00000001;
        public static uint XPROFILE_GAMER_TYPE_CHEATER                   = 0x00000002;

        // Service Types
        // (service type flag) = 0x1 << (service type id)
        // service type ids are found in t_service_types
        // 1 = Xbox Live
        // 2 = Zune
        public static uint XPROFILE_SERVICE_TYPE_FLAG_XBOX = 0x2;
        public static uint XPROFILE_SERVICE_TYPE_FLAG_ZUNE = 0x4;

        //end of 1/10/08 copy from statsprot.cs

        public static uint[] XPROFILE_GAMERCARD_SETTINGS = {XPROFILE_GAMER_TYPE, XPROFILE_GAMERCARD_PICTURE_KEY, XPROFILE_GAMERCARD_CRED, XPROFILE_GAMERCARD_ZONE, XPROFILE_GAMERCARD_REP, XPROFILE_GAMERCARD_MOTTO, XPROFILE_GAMERCARD_REGION, XPROFILE_GAMER_TIER};
        public static uint[] XPROFILE_NAME_MOTTO_SETTINGS = {XPROFILE_GAMERCARD_USER_NAME, XPROFILE_GAMERCARD_MOTTO};
        public static uint[] XPROFILE_EXTENDED_PROFILE_SETTINGS = {XPROFILE_GAMERCARD_USER_NAME, XPROFILE_GAMERCARD_USER_LOCATION, XPROFILE_GAMERCARD_USER_BIO};
        public static uint[] XPROFILE_XBOXCOM_SMALL_GAMERCARD = {XPROFILE_GAMER_TYPE,XPROFILE_GAMERCARD_ZONE,XPROFILE_GAMERCARD_REGION, XPROFILE_GAMERCARD_CRED, XPROFILE_GAMER_TIER, XPROFILE_GAMERCARD_MOTTO, XPROFILE_GAMERCARD_USER_LOCATION, XPROFILE_GAMERCARD_PICTURE_KEY,XPROFILE_GAMERCARD_USER_NAME, XPROFILE_GAMERCARD_USER_URL, XPROFILE_GAMERCARD_USER_BIO, XPROFILE_GAMERCARD_REP};
        public static uint[] XPROFILE_XBOXCOM_LARGE_GAMERCARD = {0x10040000, 0x10040001, 0x10040004, 0x10040005, 0x10040006, 0x1004003a, 0x10042000, 0x10042001, 0x10042002, 0x10042003, 0x10042004, 0x10042005, 0x10042006, 0x10042007, 0x10042008, 0x10042009, 0x1004200a, 0x1004200b, 0x1004200c, 0x1004200d, 0x402c0011, 0x40520041, 0x4064000f, 0x41040040,0x41900042,0x43e80043,0x5004000b};
        public static uint[] XPROFILE_XBOXCOM_GAMERTILE = {XPROFILE_GAMERCARD_PICTURE_KEY, XPROFILE_GAMERCARD_CRED, XPROFILE_GAMERCARD_ZONE};
        public static uint[] XPROFILE_TITLE_OVERRIDE_SETTINGS = {XPROFILE_TITLE_SPECIFIC1, XPROFILE_TITLE_SPECIFIC2, XPROFILE_TITLE_SPECIFIC3, XPROFILE_GAMERCARD_PICTURE_KEY, XPROFILE_GAMER_DIFFICULTY}; //always with 1 user
        
	}

	/// <summary>
	/// Summary description for XRLReadSettings.
	/// </summary>
	public class SettingIds
    {
        private static Hashtable _settingIds = null;
        
        public static void ValidateList(uint[] ids)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            foreach (uint id in ids)
            {
                if (!_settingIds.Contains(id))
                {
                    throw new Exception( "The Setting ID 0x" + id.ToString("X") + " is unknown.");
                }
            }
        }
        
        public static void ValidateList(UserSetting[] settings)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            foreach (UserSetting setting in settings)
            {
                if (!_settingIds.Contains(setting.SettingId))
                {
                    throw new Exception("The Setting ID 0x" + setting.SettingId.ToString("X") + " is unknown.");
                }
            }
        }
        
        public static SettingInfo Item(uint id)
        {
            if (_settingIds == null)
            {
                LoadSettingIds();
            }
            
            return (SettingInfo)_settingIds[id];
        }

        public static bool isValidSettingID(uint id)
        {
            if (Item(id) == null)
            {
                return false;
            }
            return true;
        }
            
            
        private static void LoadSettingIds()
        {
            Hashtable ids = new Hashtable();
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_stats_get_setting_ids";
                SqlDataReader reader = cmd.Execute();
                
                while (reader.Read())
                {
                    SettingInfo setting = new SettingInfo();
                    
                    setting.Id = (uint)(int)reader["i_setting_id"];
                    setting.Name = (string)reader["vc_name"];
                    setting.Location = (string)reader["vc_location"];
                    setting.Permissions = (uint)(int)reader["i_permission_flags"];
                    
                    ids[setting.Id] = setting;
                }    
            }
            
            _settingIds = ids;                    
        }
        
        public static void Flush()
        {
            _settingIds = null;
        }    
    }
    
    public class SettingInfo
    {
        public uint Id;
        public string Name;
        public string Location;
        public uint Permissions;
        
        public bool IsConsoleWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_CONSOLE_RO) == 0);
        }   
        
        public bool IsWebWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_WEB_RO) == 0);
        }
    
        public bool IsTitleWritable()
        {
            return ((Permissions & XOn.XPROFILE_SETTING_ENFORCE_TITLE_RO) == 0);
        }
    }
	public class ReadSettingsRequest : XRLPayload
	{
		[XRLPayloadFld(IsTitleId=true)]
		public uint TitleId;
		[XRLPayloadFld(IsUPuid=true)]
		public ulong UserId;
        public ushort ForUserIdsLen;
		public ulong[] ForUserIds;
        public ushort SettingIdsLen;
		public uint[] SettingIds;
		[WireInfo(Serialize=false)]
		public AuthModify Modifyflag = AuthModify.None;

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			if(Modifyflag == AuthModify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if(Modifyflag == AuthModify.Change_Title_PUB)
			{
				Slot.titleId+=0xFFF00000;
			}
			else if (Modifyflag == AuthModify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			else if (Modifyflag == AuthModify.Read_Activity_FriendOnly)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);			
			}
			else if (Modifyflag == AuthModify.Read_Activity_None)
			{
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}
			else if (Modifyflag == AuthModify.Read_UCC_Friends)
			{
				Slot.UnsetPrivilege(viewFlags.XPRIVILEGE_USER_CREATED_CONTENT);
				Slot.SetPrivilege(viewFlags.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);			
			}
			else if (Modifyflag == AuthModify.Read_UCC_None)
			{
				Slot.UnsetPrivilege(viewFlags.XPRIVILEGE_USER_CREATED_CONTENT);
				Slot.UnsetPrivilege(viewFlags.XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY);
			}
		/*	else if (Modifyflag == AuthModify.Read_Activity_All)
			{
				Slot.SetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING);
				Slot.UnsetPrivilege(viewFlags.XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY);
			}
			*/
			

			ManualSlotSetup=true;
		}


		public ReadSettingsRequest(uint title , ulong user ,ulong[] friends,uint[] settingids)
		{
			TitleId=title;
			UserId =user;
			ForUserIds=friends;
			SettingIds=settingids;


		}

		public ReadSettingsRequest(uint title , ulong user ,ulong[] friends,ushort flen,uint[] settingids,ushort slen)
		{
			TitleId=title;
			UserId =user;
			ForUserIdsLen= flen;
			ForUserIds=friends;
			SettingIdsLen=slen;
			SettingIds=settingids;
			this.ManualArraySize=true;


		}

		protected override string GetServiceName()
		{
			return "/xstats/readsettings.ashx";
		}

		public new ReadSettingsResponse Execute()
		{
			System.Threading.Thread.Sleep(100);
			ReadSettingsResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			ManualPopulateSlot();

            // This fixes the problem for Read Avatar Pic which triggers off the Schema Ver header being greater than 4.4
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (ReadSettingsResponse)new ReadSettingsResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (ReadSettingsResponse)new ReadSettingsResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}

		public  ReadSettingsResponse ExecuteInt()
		{

			System.Threading.Thread.Sleep(100);
			IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd_int);

			ReadSettingsResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			//Conversions
			ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			byte [] addr = endpoint.Address.GetAddressBytes();
			uint ip=0;
			for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];


			HTTPAuthData authData = new HTTPAuthData((ushort) endpoint.Port,ip,requestId,UserId,this.TitleId,(uint)XOService.Stats,0);
			CustomHeader= HTTPAuthData.HTTP_HEADER_AUTH_DATA +":"+authData.GetBase64EncodedString()+"\r\n";
            

			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd_int),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (ReadSettingsResponse)new ReadSettingsResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (ReadSettingsResponse)new ReadSettingsResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}

	}

	public class ReadSettingsResponse : WireData
	{
		public ushort SettingsLen;
        public UserSetting[] Settings;
		[WireInfo(Serialize=false)]
		public uint XError;

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\Pcontrol.cs ===
using System;
using System.Collections;
using ServerTestFramework.Database;

using Microsoft.Xbox.Privacy.Client;

namespace ServerTestFramework.LiveService.UserSettings
{
    /// <summary>
    /// Summary description for Pcontrol.
    /// </summary>
    public class PCBase : TestNode
    {
        protected const uint GAMER_CRED = 0x10040006;
        protected static ulong Owner;
        protected static ulong Friend;
        protected static ulong NonFriend;
        protected uint Title = 0;

        public static void init(ulong owner, ulong friend, ulong nonfirend)
        {
            Owner = owner;
            Friend = friend;
            NonFriend = nonfirend;
        }

        public PCBase(uint title)
        {
            Title = title;
        }

        public PCBase()
        {
        }

        virtual protected void init() { }
        virtual protected void run() { }
        virtual protected void cleanup() { }

        public virtual void addPermission(byte svalue)
        {
            uint settingid = (uint)PROFILE_FLG.XPROFILE_PERMISSIONS;

            try
            {
                PrivacyClientInternal client = new PrivacyClientInternal(new XConfig().GetVirtualInterface("privacy_int"));
                client.SetProfilePrivacy(Owner, 0);
            }
            catch (Exception)
            {
                // This can throw a valid exception when we're using made-up users
            }

            UserSetting[] settings = new UserSetting[1];
            settings[0] = new UserSetting(Owner, settingid, new byte[] { svalue }, SettingSource.XSOURCE_DEFAULT);
            SyncSettingsRequest req = new SyncSettingsRequest(0, Owner, settings, DateTime.UtcNow);

            SyncSettingsResponse resp = req.Execute();
            if (resp.XError != 0)
                throw new Exception("Error loading settings XERROR: " + resp.XError);
        }

        public override void Run()
        {
            cleanup();
            init();
            run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\BehaviorInjection.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

namespace ServerTestFramework.Utilities
{
    public class BehaviorInjection
    {
        /// <summary>
        /// Different types of behavior injection.
        /// </summary>
        public enum INJECTION_TYPE
        {
            ALTERNATE_BILLING_URL = 0,
            ALTERNATE_MUSICNET_URL,
            ALTERNATE_DMP_URL,
            ALTERNATE_WMIS_URL,
            ALTERNATE_PASSPORT_URL,
            ALTERNATE_PASSPORT_CREDENTIAL_SERVICE_URL,
            ALTERNATE_PASSPORT_PROFILE_SERVICE_URL,
            ALTERNATE_PASSPORT_ENCRYPTED_PROXIED_AUTH_URL,
            ALTERNATE_UPS_URL,
            ALTERNATE_FINBUS_URL,
            ALTERNATE_ABCH_URL,
            ALTERNATE_CTP_URL,

            SPROC_FAILURE,
            XBANC_MISS,
            NPDB_OVERRIDE,
            DMP_FAILURE,
            PP_LOGIN_FAILURE,
            MUSICNET_FAILURE,
            SCS_FAILURE,
            UPS_FAILURE,
            ABCH_FAILURE,
            FINBUS_FAILURE,
            CTP_FAILURE,
        };

        /// <summary>
        /// Adds a new BEHAVIOR_INJECTION header to the header collection.
        /// </summary>
        /// <param name="_type">The type of behavior to add</param>
        /// <param name="_params">The specific parameters for the chosen bahavior</param>
        /// <param name="_passThrough">Should the bahaviors pass to other servers</param>
        public static string AddBehavior(INJECTION_TYPE _type, string _params, bool _passThrough)
        {
            switch (_type)
            {
                case INJECTION_TYPE.ALTERNATE_BILLING_URL:
                    return AddHeader(String.Format("AlternateBillingUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_MUSICNET_URL:
                    return AddHeader(String.Format("AlternateMusicNetUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_DMP_URL:
                    return AddHeader(String.Format("AlternateDmpUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_WMIS_URL:
                    return AddHeader(String.Format("AlternateWmisUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_PASSPORT_URL:
                    return AddHeader(String.Format("AlternatePassportUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_PASSPORT_CREDENTIAL_SERVICE_URL:
                    return AddHeader(String.Format("AlternatePpCredentialServiceApiUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_PASSPORT_PROFILE_SERVICE_URL:
                    return AddHeader(String.Format("AlternatePpProfileServiceApiUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_PASSPORT_ENCRYPTED_PROXIED_AUTH_URL:
                    return AddHeader(String.Format("AlternatePpEncryptedProxiedAuthUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_UPS_URL:
                    return AddHeader(String.Format("AlternateUpsUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_FINBUS_URL:
                    return AddHeader(String.Format("AlternateFinBusUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_ABCH_URL:
                    return AddHeader(String.Format("AlternateABCHUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ALTERNATE_CTP_URL:
                    return AddHeader(String.Format("AlternateCTPUrl;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.SPROC_FAILURE:
                    return AddHeader(String.Format("SprocFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.XBANC_MISS:
                    return AddHeader(String.Format("XbancMiss;;{0}", (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.NPDB_OVERRIDE:
                    return AddHeader(String.Format("NpdbOverride;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.DMP_FAILURE:
                    return AddHeader(String.Format("DmpFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.PP_LOGIN_FAILURE:
                    return AddHeader(String.Format("PassportLoginFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.MUSICNET_FAILURE:
                    return AddHeader(String.Format("MusicnetFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.SCS_FAILURE:
                    return AddHeader(String.Format("ScsFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.UPS_FAILURE:
                    return AddHeader(String.Format("UpsFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.ABCH_FAILURE:
                    return AddHeader(String.Format("ABCHFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.FINBUS_FAILURE:
                    return AddHeader(String.Format("FinBusFailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
                case INJECTION_TYPE.CTP_FAILURE:
                    return AddHeader(String.Format("ctptransactionfailure;{0};{1}", _params, (_passThrough == true) ? "passThrough=" : ""));
            };
            return "";
        }

        public const string BIF_KEY = "BEHAVIOR_INJECTIONS: ";

        /// <summary>
        /// Generic Header.add() this will allow non standard adds
        /// </summary>
        /// <param name="_header"></param>
        public static string AddHeader(string _header)
        {
            return String.Format("{0}{1}\r\n", BIF_KEY, _header);
        }

        /// <summary>
        /// BIF supports multiple BIF requests in one header
        /// </summary>
        /// <param name="headers"></param>
        /// <returns></returns>
        public static string AddMultiBIFs(params string[] requests)
        {
            if (requests == null | requests.Length == 0)
                throw new UnexpectedTestResultException("Requests cannot be null or emtpy.");

            StringBuilder bifs = new StringBuilder();
            bifs.Append(BIF_KEY);
            foreach (string request in requests)
            {
                string sTemp = request.Remove(0, BIF_KEY.Length);
                sTemp = sTemp.Replace("\r\n", "");
                bifs.AppendFormat("{0},", sTemp);
            }
            bifs.Remove((bifs.Length - 1), 1);  // remove the last comma
            bifs.Append("\r\n");

            return bifs.ToString();
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Specific Behavior Injection Adds
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        /// <summary>
        /// Adds an alternate Billing Url
        /// </summary>
        /// <param name="_url">The URL.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateBillingUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_BILLING_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate MusicNet Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateMusicNetUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_MUSICNET_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate DMP Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateDmpUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_DMP_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Wmis Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateWmisUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_WMIS_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Passport Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternatePassportUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_PASSPORT_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Passport CredentialServiceApi Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternatePassportCredentialServiceUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_PASSPORT_CREDENTIAL_SERVICE_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Passport ProfileServiceApi Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternatePassportProfileServiceUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_PASSPORT_PROFILE_SERVICE_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate Passport EncryptedProxiedAuth Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternatePassportEncryptedProxiedAuthUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_PASSPORT_ENCRYPTED_PROXIED_AUTH_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate UPS Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateUpsUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_UPS_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate FinBus Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateFinBusUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_FINBUS_URL, _url, _passThrough);
        }


        /// <summary>
        /// Adds an alternate ABCH Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateABCHUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_ABCH_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds an alternate CTPTransactionService Url
        /// </summary>
        /// <param name="_url">The Url.</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddAlternateCTPUrl(string _url, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ALTERNATE_CTP_URL, _url, _passThrough);
        }

        /// <summary>
        /// Adds a specific sproc failure
        /// </summary>
        /// <param name="_sprocName">Name of the sproc to fail</param>
        /// <param name="_dbName">Name of the database on which to fail all sprocs</param>
        /// <param name="_exceptionToThrow">OPTIONAL: Exception to throw on failure</param>
        /// <param name="_timeoutMS">OPTIONAL: Delay in MS</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        /// <exception cref="InvalidOperationException">Thrown if both sproc name AND db name are provided, or when neither are.</exception>
        public static string AddSprocFailure(string _sprocName, string _dbName, string _exceptionToThrow, uint _timeoutMS, bool _passThrough)
        {
            bool hasSprocName = !String.IsNullOrEmpty(_sprocName);
            bool hasDbName = !String.IsNullOrEmpty(_dbName);

            if(!hasSprocName && !hasDbName)
            {
                throw new InvalidOperationException("SprocFailure requires either a Sproc name OR a DB name.");
            }
            if(hasSprocName && hasDbName)
            {
                throw new InvalidOperationException("SprocFailure should only have a Sproc name OR a DB name, not both.");
            }

            StringBuilder stringToSend = new StringBuilder();

            if(hasSprocName)
            {
                stringToSend.Append("sproc=");
                stringToSend.Append(_sprocName);
            }
            else
            {
                stringToSend.Append("db=");
                stringToSend.Append(_dbName);
            }

            if (!String.IsNullOrEmpty(_exceptionToThrow))
            {
                stringToSend.AppendFormat(":exception={0}", _exceptionToThrow);
            }

            if (_timeoutMS != 0)
            {
                stringToSend.AppendFormat(":timeoutMS={0}", _timeoutMS);
            }

            return AddBehavior(INJECTION_TYPE.SPROC_FAILURE, stringToSend.ToString(), _passThrough);
        }

        /// <summary>
        /// Adds an xbanc Mmiss
        /// </summary>
        /// <param name="_passThrough"></param>
        public static string AddXbancMiss(bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.XBANC_MISS, "", _passThrough);
        }

        public static string AddNpdbOverride(string _setting, string _value, bool _passThrough)
        {
            string stringToSend = String.Format("setting={0}:value={1}", _setting, _value);

            return AddBehavior(INJECTION_TYPE.NPDB_OVERRIDE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API failure
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_dmpError">DMP error to raise</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddDmpFailure(string _dmpApi, string _dmpError, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", _dmpApi, _dmpError);

            return AddBehavior(INJECTION_TYPE.DMP_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API timeout
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddDmpTimeout(string _dmpApi, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", _dmpApi);

            return AddBehavior(INJECTION_TYPE.DMP_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds an XML fragment specifying one or more DMP API failures or timeouts
        /// </summary>
        /// <param name="dmpXmlText">XML fragment containing DMP API and/or timeout specifications</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddDmpBehaviorXml(string dmpXmlText, bool _passThrough)
        {
            return AddBehavior(INJECTION_TYPE.DMP_FAILURE, dmpXmlText, _passThrough);
        }

        /// <summary>
        /// Adds a Passport Login failure
        /// </summary>
        /// <param name="faultcode">Passport faultcode</param>
        /// <param name="faultstring">Passport faultstring</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddPassportLoginError(string faultcode, string faultstring, bool _passThrough)
        {
            string stringToSend = String.Format("faultcode={0}", faultcode);

            stringToSend += String.Format(":faultstring={0}", (faultstring ?? "Login failed with error 0x" + faultcode));

            return AddBehavior(INJECTION_TYPE.PP_LOGIN_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a Passport Login timeout
        /// </summary>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddPassportLoginTimeout(bool _passThrough)
        {
            string stringToSend = "timeout=0";

            return AddBehavior(INJECTION_TYPE.PP_LOGIN_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific DMP API failure
        /// </summary>
        /// <param name="error">Musicnet error code</param>
        /// <param name="message">Musicnet error message (optional)</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddMusicnetFailure(string api, int error, string message, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", api, error.ToString("d"));

            if ( !string.IsNullOrEmpty(message) )
            {
                stringToSend += String.Format(":message={0}", message);
            }

            return AddBehavior(INJECTION_TYPE.MUSICNET_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific Musicnet API timeout
        /// </summary>
        /// <param name="_dmpApi">Name of the DMP API to fail</param>
        /// <param name="_passThrough">Pass through behavior to other servers.</param>
        public static string AddMusicnetTimeout(string api, bool _passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            return AddBehavior(INJECTION_TYPE.MUSICNET_FAILURE, stringToSend, _passThrough);
        }

        /// <summary>
        /// Adds a specific SCS API failure
        /// </summary>
        /// <param name="api">Name of the SCS API to fail</param>
        /// <param name="error">SCS error to raise.  This can be either a name such as BDK_E_AUTHORIZATION_FAILED or a hex value such as 0x80047611.</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddScsFailure(string api, string error, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", api, error);

            return AddBehavior(INJECTION_TYPE.SCS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific SCS API timeout
        /// </summary>
        /// <param name="api">Name of the SCS API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddScsTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            return AddBehavior(INJECTION_TYPE.SCS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific UPS API timeout
        /// </summary>
        /// <param name="api">Name of the UPS API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddUpsTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=0", api);

            return AddBehavior(INJECTION_TYPE.UPS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific ABCH API timeout
        /// </summary>
        /// <param name="api">Name of the ABCH API to timeout</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddABCHFailure(bool passThrough)
        {
            return AddBehavior(INJECTION_TYPE.ABCH_FAILURE, "", passThrough);
        }

        /// <summary>
        /// Adds a specific FinBus API failure
        /// </summary>
        /// <param name="api">Name of the FinBus API to fail</param>
        /// <param name="errorCode">FinBus error code to include in FaultDetails</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddFinBusFailure(string api, int errorCode, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:errorCode={1}", api, errorCode);

            return AddBehavior(INJECTION_TYPE.FINBUS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific FinBus API failure
        /// </summary>
        /// <param name="api">Name of the FinBus API to fail</param>
        /// <param name="errorCode">FinBus error code to include in FaultDetails</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddFinBusFailure(string api, int errorCode, string message, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:errorCode={1}:message={2}", api, errorCode, message);

            return AddBehavior(INJECTION_TYPE.FINBUS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific FinBus API timeout
        /// </summary>
        /// <param name="api">Name of the FinBus API to fail</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddFinBusTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            return AddBehavior(INJECTION_TYPE.FINBUS_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific CTPTransactionService API failure
        /// </summary>
        /// <param name="api">Name of the FinBus API to fail</param>
        /// <param name="error">CTP error to raise</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddCTPFailure(string api, string error, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:error={1}", api, error);

            return AddBehavior(INJECTION_TYPE.CTP_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific CTPTransactionService API timeout
        /// </summary>
        /// <param name="api">Name of the CTP API to fail</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddCTPTimeout(string api, int timeoutValue, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout={1}", api, timeoutValue);

            return AddBehavior(INJECTION_TYPE.CTP_FAILURE, stringToSend, passThrough);
        }


        /// <summary>
        /// Adds a specific CTPTransactionService API timeout
        /// </summary>
        /// <param name="api">Name of the CTP API to fail</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddCTPTimeout(string api, bool passThrough)
        {
            string stringToSend = String.Format("api={0}:timeout=1", api);

            return AddBehavior(INJECTION_TYPE.CTP_FAILURE, stringToSend, passThrough);
        }

        /// <summary>
        /// Adds a specific failure for the CTPTransactionService Purchase API
        /// </summary>
        /// <param name="error">CTP error to raise</param>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddCTPPurchaseFailure(string error, bool passThrough)
        {
            return AddCTPFailure("Purchase", error, passThrough);
        }

        /// <summary>
        /// Adds a timeout for the CTPTransactionService Purchase API
        /// </summary>
        /// <param name="passThrough">Pass through behavior to other servers.</param>
        public static string AddCTPPurchaseTimeout(bool passThrough)
        {
            return AddCTPTimeout("Purchase", passThrough);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLSyncAll.cs ===
using System;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using xonline.common.config;

namespace ServerTestFramework.LiveService.UserSettings
{
	/// <summary>
	/// Summary description for XRLSyncAll.
	/// </summary>
	public class XRLSyncAllRequest : XRLPayload
	{

		[XRLPayloadFld(IsTitleId=true)]
		public uint TitleId;
		[XRLPayloadFld(IsUPuid=true)]
		public ulong UserId;
		public ushort LocaleId;
		[WireInfo(ArraySize=16)]
		public byte[] Guid;
		//Settings
		public DateTime SettingsVersion;
		public ushort SettingsLen;
		public UserSetting[] Settings;
		// titles
		public DateTime TitlesVersion;
		public ushort TitlesLen = 0;
		public UserTitle[] Titles = null;
		// achievements
		public DateTime AchievementsVersion;
		public ushort AchievementsLen = 0;
		public AchievementWD[] Achievements = null;

		[WireInfo(Serialize=false)]
		public AuthModify Modifyflag = AuthModify.None;

		public XRLSyncAllRequest() {}
		public XRLSyncAllRequest(ulong userId, uint titleId, ushort localeId, byte[] guid)
		{
			UserId = userId;
			TitleId = titleId;
			LocaleId = localeId;
			Guid = guid;
		}
            
     	protected override string GetServiceName()
		{
			return "/xstats/syncall.ashx";
		}

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);

			if(Modifyflag == AuthModify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if (Modifyflag == AuthModify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			ManualSlotSetup=true;
		}

		public new SyncAllResponse Execute()
		{

			SyncAllResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			if(Modifyflag != AuthModify.None)
				ManualPopulateSlot();


			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (SyncAllResponse)new SyncAllResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (SyncAllResponse)new SyncAllResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}

	}

	/// <summary>
	/// SyncSettingsResponse
	/// </summary>
	/// <param name="Version">Version</param>
	/// <param name="SettingsLen">Count of settings</param>
	/// <param name="Settings">User settings collection</param>
	/// <remarks>
	/// Returned in response to SyncSettingsRequest
	/// </remarks>
	public class SyncAllResponse : WireData
	{
		public SyncSettingsResponse Settings = new SyncSettingsResponse();
		public SyncTitlesResponse Titles = new SyncTitlesResponse();
		public SyncAchievementsResponse Achievements = new SyncAchievementsResponse();
		[WireInfo(Serialize=false)]
		public uint XError;
	} 
    

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLSyncTitle.cs ===
using System;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.UserSettings
{
	public class UserTitle : WireData,IComparable
	{
		public uint TitleId = 0;
		public ushort TitleNameLen = 0;
		public string TitleName = "";
		public DateTime LastPlayed = DateTime.MinValue;
		public uint NumCreds = 0;
		public ushort NumAchievements = 0;
		public ushort TotalAchievements = 0;
		public uint TotalCred = 0;
		public uint Sequence = 0;
        public byte HasExtendedData = 0;
        public byte TitleType = 0;
        public ushort PlatformFlags = 0;

		public UserTitle() {}
		public UserTitle(uint titleId, DateTime lastPlayed, uint creds, ushort achievements, uint _Sequence)
		{
            TitleId = titleId;
            LastPlayed = lastPlayed;
            NumCreds = creds;
            NumAchievements = achievements;
            Sequence = _Sequence;
		}

		public int CompareTo(object obj)
		{
			return ((UserTitle)obj).Sequence.CompareTo(Sequence);
		}

        public override bool Equals(Object obj)
        {
            bool retval= false;
            if (TitleId == ((UserTitle)obj).TitleId)
                retval = true;
            return retval;
        }

        public override int GetHashCode()
        {
            return (int)TitleId;
        }

        public void SetPlatformFlag(uint xplatformid, bool value)
        {
            uint xprofileid = XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            PlatformFlags &= (ushort)~mask;
            PlatformFlags |= (ushort)(value ? mask : 0);
        }

        public bool HasPlatformFlag(uint xplatformid)
        {
            uint xprofileid = XOnPlatformToXProfilePlatform(xplatformid);
            ushort mask = (ushort)(1 << (int)xprofileid);
            return (PlatformFlags & mask) != 0;
        }

        public bool ShouldAppearInUserHistory()
        {
            if (TotalAchievements > 0) return true;  // title has achievements, so it must be public.

            if (HasExtendedData == 0) return true;  // no extended data to base on.  can't do any further filtering.

            // for anything that's made it this far, filter out title type (system, demo, app).
            if (TitleType == XOn.TITLE_TYPE_SYSTEM) return false;
            if (TitleType == XOn.TITLE_TYPE_DEMO) return false;
            if (TitleType == XOn.TITLE_TYPE_APPLICATION) return false;

            // else
            return true;
        }

        // Platform conversion stuff
        private const uint XPROFILE_PLATFORM_TYPE_360 = 1;
        private const uint XPROFILE_PLATFORM_TYPE_PC = 2;
        private const uint XPROFILE_PLATFORM_TYPE_MOBILE = 3;
        private const uint XPROFILE_PLATFORM_TYPE_WEB_GAMES = 4;

        private static uint XOnPlatformToXProfilePlatform(uint xop)
        {
            switch (xop)
            {
                case XOn.XPLT_XBOX360:
                    return XPROFILE_PLATFORM_TYPE_360;
                case XOn.XPLT_PC:
                    return XPROFILE_PLATFORM_TYPE_PC;
                case XOn.XPLT_MOBILE:
                    return XPROFILE_PLATFORM_TYPE_MOBILE;
                case XOn.XPLT_WEB_GAMES:
                    return XPROFILE_PLATFORM_TYPE_WEB_GAMES;
                default:
                    return 0;
            }
        }

        private static uint XProfilePlatformToXOnPlatform(uint xpp)
        {
            switch (xpp)
            {
                case XPROFILE_PLATFORM_TYPE_360:
                    return XOn.XPLT_XBOX360;
                case XPROFILE_PLATFORM_TYPE_PC:
                    return XOn.XPLT_PC;
                case XPROFILE_PLATFORM_TYPE_MOBILE:
                    return XOn.XPLT_MOBILE;
                case XPROFILE_PLATFORM_TYPE_WEB_GAMES:
                    return XOn.XPLT_WEB_GAMES;
                default:
                    return 0;
            }
        }
	}
 
	public class SyncTitlesRequest : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong UserId = 0;
		public ushort LocaleId = 1033; // en-US
		public ushort StartingIndex = 0;
		public DateTime Version = DateTime.MinValue;
		public ushort TitlesLen = 0;
		public UserTitle[] Titles = null;

		[WireInfo(Serialize=false)]
		public AuthModify Modifyflag = AuthModify.None;

		

		public override void ManualPopulateSlot()
		{
			PopulateSlot(ref Slot);
			

			if(Modifyflag == AuthModify.Change_Title)
			{
				Slot.titleId+=10;
			}
			else if (Modifyflag == AuthModify.Change_User)
			{
				Slot.userPuid0+=10;
				Slot.userPuid1+=10;
				Slot.userPuid2+=10;
				Slot.userPuid3+=10;

			}
			ManualSlotSetup =true;
			
		}

		public SyncTitlesRequest(ulong userId, DateTime version ,UserTitle[] titles,ushort _StartingIndex)
		{
			UserId = userId;
			Version = version;
			Titles=titles;
			StartingIndex=_StartingIndex;
			
		} 

		public SyncTitlesRequest(ulong userId, DateTime version ,UserTitle[] titles)
		{
			UserId = userId;
			Version = version;
			Titles=titles;
			
		} 

		public SyncTitlesRequest(ulong userId,ushort Locale, DateTime version ,UserTitle[] titles)
		{
			LocaleId=  Locale;
			UserId = userId;
			Version = version;
			Titles=titles;
		} 
   
		public new SyncTitlesResponse Execute()
		{

			SyncTitlesResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			if(Modifyflag != AuthModify.None)
				ManualPopulateSlot();

			bool bRet=InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd),reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (SyncTitlesResponse)new SyncTitlesResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (SyncTitlesResponse)new SyncTitlesResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}
        

		public  SyncTitlesResponse ExecuteInt()
		{

			SyncTitlesResponse resp= null;

			MemoryStream reqStream = new MemoryStream( 512 );
			WriteStream( reqStream );

			// HTTPAUTH
			IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.progressfd_int);
			uint title= 50;
			ulong user = UserId;
			ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			byte [] addr = endpoint.Address.GetAddressBytes();
			uint ip=0;
			for(int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];
			

			HTTPAuthData authData = new HTTPAuthData((ushort) endpoint.Port,ip,requestId,user,title,(uint)XOService.Stats,0);
			CustomHeader= HTTPAuthData.HTTP_HEADER_AUTH_DATA +":"+authData.GetBase64EncodedString()+"\r\n";

			bool bRet=InternalExecute(endpoint,reqStream);

			if( (xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)) )
			{
				if (xAct.ResponseContents.Length>0)
					resp = (SyncTitlesResponse)new SyncTitlesResponse().ReadBytes(xAct.ResponseContents);

			}
			else
			{
				resp = (SyncTitlesResponse)new SyncTitlesResponse();
				resp.XError=xAct.XErr;
			}


			return resp;


		}
        
        
		
		protected override string GetServiceName()
		{
			return "/xstats/synctitles.ashx";
		}
	}        
 
    
	public class SyncTitlesResponse : WireData
	{
		public DateTime Version = DateTime.MinValue;
		 public ushort TotalTitles = 0;
    	public ushort TitlesLen = 0;
		public UserTitle[] Titles = null;
		[WireInfo(Serialize=false)]
		public uint XError;
	} 
 
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\XRLSyncSettings.cs ===
using System;
using System.Text;
using System.IO;
using ServerTestFramework;
using System.Net;
using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;
using ServerTestFramework.LiveService.UserSettings;
using ServerTestFramework.LiveService.FakeSG;


namespace ServerTestFramework.LiveService.UserSettings
{
    public class viewFlags
    {
        // Profile 
        public static byte XONLINE_PRIVILEGE_PROFILE_VIEWING = 249;
        public static byte XONLINE_PRIVILEGE_PROFILE_VIEWING_FRIENDS_ONLY = 248;
        public static byte XPRIVILEGE_USER_CREATED_CONTENT = 247;
        public static byte XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY = 246;
    }

    public class SConvert
    {
        public static byte[] Bytes(long data)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(data);

            return stream.ToArray();
        }
        public static byte[] Bytes(int data)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(data);

            return stream.ToArray();
        }
        public static byte[] Bytes(short data)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(data);

            return stream.ToArray();
        }
        public static byte[] Bytes(string data, int len)
        {

            MemoryStream stream = new MemoryStream();
            BinaryWriter writer = new BinaryWriter(stream);
            writer.Write(data);
            byte[] tmp = stream.ToArray();
            byte[] bdata = new byte[len];

            for (int i = 0; i < len; i++)
                bdata[i] = tmp[i];

            return bdata;
        }

        public static byte[] UnicodeBytes(string data)
        {

            return System.Text.UnicodeEncoding.Unicode.GetBytes(data);

        }


    }

    public class GSLimits
    {
        public static ushort XONLINE_MAX_SETTING_VALUE_BYTES = 1000;
        public static ushort XONLINE_MAX_Sync_SETTING_COUNT = 128;
        public static ushort XONLINE_MAX_SETTING_COUNT = 32;
        public static ushort XONLINE_MAX_SETTING_USERS = 16;
    }

    public enum SettingSource
    {
        XSOURCE_NO_VALUE = 0,
        XSOURCE_DEFAULT = 1,
        XSOURCE_TITLE = 2,
        XSOURCE_PERMISSION_DENIED = 3
    }

    public class Titles
    {
        public static uint Global = 0xFFFE07D1;
        public static uint PosTitle1 = 501;
        public static uint PosTitle2 = 502;
        public static uint NegTitle1 = 601;
        public static uint NegTitle2 = 60;
    }

    public class AvatarManifestHelpers
    {
        // from Jerry Weiler's statsdevtest
        public static byte[] HexToBytes(string str)
        {
            byte[] result = new byte[(str.Length + 1) / 2];

            byte[] HexValue = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0B, 0x0C, 0x0D,
                                 0x0E, 0x0F };

            int nextChar = 0;
            int nextByte = 0;

            // If we have an odd number of characters, treat the first one as the low nybble of the first byte.
            if ((str.Length % 2) == 1)
            {
                result[nextByte++] = HexValue[Char.ToUpper(str[nextChar++]) - '0'];
            }

            while (nextChar < str.Length)
            {
                result[nextByte++] = (byte)((HexValue[Char.ToUpper(str[nextChar]) - '0'] << 4) + HexValue[Char.ToUpper(str[nextChar + 1]) - '0']);
                nextChar += 2;
            }

            return result;
        }

        public static bool CompareByteArrays(byte[] b1, byte[] b2)
        {
            if (b1.Length != b2.Length)
                return false;
            for (int i = 0; i < b1.Length; ++i)
                if (b1[i] != b2[i])
                    return false;
            return true;
        }

        // copied from xonline.common.service.AvatarManifest
        public enum XAVATAR_COMPONENT_MASK : ushort
        {
            None = 0x0000,
            Head = 0x0001,
            Body = 0x0002,
            Hair = 0x0004,
            Shirt = 0x0008,
            Trousers = 0x0010,
            Shoes = 0x0020,
            Hat = 0x0040,
            Gloves = 0x0080,
            Glasses = 0x0100,
            Wristwear = 0x0200,
            Earrings = 0x0400,
            Ring = 0x0800,
            Carryable = 0x1000,
            All = 0x1FFF
        }

        // This lists that components that should appear in PreviousRequiredComponentInfo.
        // They should appear in this order.
        public static XAVATAR_COMPONENT_MASK[] s_requiredComponents =
        {
            XAVATAR_COMPONENT_MASK.Shoes,
            XAVATAR_COMPONENT_MASK.Trousers,
            XAVATAR_COMPONENT_MASK.Shirt,
            XAVATAR_COMPONENT_MASK.Hair
        };
    }

    /// <summary>
    /// XRLValidateAvatarManifest
    /// </summary>
    public class ValidateAvatarManifestRequest : XRLPayload
    {
        // Need to specify is puid for fakesg
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserId = 0;

        // currently unused
        public uint ValidationFlags = 0;

        [WireInfo(Max = 1000)]
        public ushort AvatarManifestLen = 0;

        [WireInfo(SizeParam = "AvatarManifestLen")]
        public byte[] AvatarManifest = null;

        protected override string GetServiceName()
        {
            return "/xstats/validateavatarmanifest.ashx";
        }

        public ValidateAvatarManifestRequest()
        {
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }
        // Default constructor that my tests will use.  If ValidationFlags gets used will
        // need to create a new constructor with that param.
        public ValidateAvatarManifestRequest(ulong userid, byte[] manifest)
        {
            UserId = userid;
            ValidationFlags = 0;
            AvatarManifestLen = (ushort)manifest.Length;
            AvatarManifest = manifest;
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public void SetMachineClientType(CSGInfo.ClientType clientType)
        {
            Slot.ChangeClientType(clientType);
        }

        new public ValidateAvatarManifestResponse Execute()
        {
            ValidateAvatarManifestResponse resp = null;
            // Prepare request 
            MemoryStream reqStream = new MemoryStream(512);
            this.WriteStream(reqStream);

            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd), reqStream);
            // create a streem here and then read all data;

            if (xAct.ResponseContents.Length > 0)
                resp = (ValidateAvatarManifestResponse)new ValidateAvatarManifestResponse().ReadBytes(XErr, xAct.ResponseContents);

            return resp;
        }

        // Added for testing WinMo/WebGames platforms which use the OnBehalfOf headers
        public ValidateAvatarManifestResponse ExecuteInt(int iPlatform, int iOnBehalfOf)
        {
            ValidateAvatarManifestResponse resp = null;

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // HTTPAUTH
            IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd_int);
            ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
            byte[] addr = endpoint.Address.GetAddressBytes();
            uint ip = 0;
            for (int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

            HTTPAuthData authData = new HTTPAuthData((ushort)endpoint.Port, ip, requestId, UserId, XOn.DASH_TITLE_ID, (uint)XOService.Progress, 0);
            CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" + authData.GetBase64EncodedString() + "\r\n";

            // Pass in the XPLT platform and OnBehalfOf
            CustomHeader += "XPLT:" + iPlatform + "\r\n";
            CustomHeader += "XPLTOnBehalfOf:" + iOnBehalfOf + "\r\n";

            bool bRet = InternalExecute(endpoint, reqStream);

            if (xAct.ResponseContents.Length > 0)
                resp = (ValidateAvatarManifestResponse)new ValidateAvatarManifestResponse().ReadBytes(XErr, xAct.ResponseContents);

            return resp;
        }
    }

    /// <summary>
    /// ValidateAvatarManifestResponse
    /// </summary>  
    public class ValidateAvatarManifestResponse : WireData
    {
        public byte ValidationResult = 0;

        public ValidateAvatarManifestResponse ReadBytes(uint XErr, byte[] Respdata)
        {
            if (HResult.Succeeded(XErr))
            {
                base.ReadBytes(Respdata);
            }
            return this;
        }
    }


    public class UserSetting : WireData
    {
        public uint Source;
        public ulong userId;
        public uint SettingId;
        public ushort ValueLen;
        public byte[] Value;

        public UserSetting()
        {
        }

        public UserSetting(ulong user, uint id)
        {
            Source = (uint)SettingSource.XSOURCE_NO_VALUE;
            userId = user;
            SettingId = id;
            ValueLen = 0;
            Value = null;
        }

        public UserSetting(ulong user, TestUSetting id)
        {
            Source = (uint)SettingSource.XSOURCE_NO_VALUE;
            userId = user;
            SettingId = (uint)id;
            ValueLen = 0;
            Value = null;
        }

        public UserSetting(ulong user, uint id, byte[] val)
        {
            Source = (uint)SettingSource.XSOURCE_DEFAULT;
            userId = user;
            SettingId = id;
            Value = val;
        }

        public UserSetting(ulong user, TestUSetting id, byte[] val)
        {
            Source = (uint)SettingSource.XSOURCE_DEFAULT;
            userId = user;
            SettingId = (uint)id;
            Value = val;
        }

        public UserSetting(ulong user, TestUSetting id, byte[] val, uint vlen, SettingSource _source)
        {
            Source = (uint)_source;
            userId = user;
            SettingId = (uint)id;
            ValueLen = (ushort)vlen;
            Value = val;
            this.ManualArraySize = true;
        }

        public UserSetting(ulong user, TestUSetting id, byte[] val, SettingSource _source)
        {
            Source = (uint)_source;
            userId = user;
            SettingId = (uint)id;
            Value = val;
        }


        public UserSetting(ulong user, uint id, byte[] val, SettingSource _source)
        {
            Source = (uint)_source;
            userId = user;
            SettingId = id;
            Value = val;
        }


    }

    public enum Languageids
    {
        en = 1,
        ja = 2,
        de = 3,
        fr = 4,
        es = 5,
        it = 6,
        ko = 7,
        zh = 8,       //traditional chinese
        pt = 9,
        zh_chs = 10,  //simplified chinese
        pl = 11,
        ru = 12,

    }


    public enum AuthModify
    {
        None = 0,
        Change_User = 1,
        Change_Title = 2,
        Read_Activity_FriendOnly = 3,
        Read_Activity_None = 4,
        Change_Title_PUB = 5,
        AddLocale = 6,
        Read_Activity_All = 7,
        Read_UCC_All = 8,
        Read_UCC_None = 9,
        Read_UCC_Friends = 10
    }

    /// <summary>
    /// Summary description for XRLSyncSettings.
    /// </summary>
    public class SyncSettingsRequest : XRLPayload
    {
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserId;
        public DateTime Version;
        public ushort StartinIndex;
        public ushort SettingsLen;
        public UserSetting[] Settings;
        [WireInfo(Serialize = false)]
        public AuthModify Modifyflag = AuthModify.None;

        protected override string GetServiceName()
        {
            return "/xstats/syncsettings.ashx";
        }

        public override void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);

            if (Modifyflag == AuthModify.Change_Title)
            {
                Slot.titleId += 10;
            }
            else if (Modifyflag == AuthModify.Change_User)
            {
                Slot.userPuid0 += 10;
                Slot.userPuid1 += 10;
                Slot.userPuid2 += 10;
                Slot.userPuid3 += 10;

            }
            ManualSlotSetup = true;
        }


        public SyncSettingsRequest()
        {
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public SyncSettingsRequest(uint Title, ulong user, UserSetting[] usettings, DateTime ver)
        {
            TitleId = Title;
            UserId = user;
            Settings = usettings;
            Version = ver;
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public SyncSettingsRequest(uint Title, ulong user, UserSetting[] usettings, DateTime ver, ushort _StartinIndex)
        {
            TitleId = Title;
            UserId = user;
            Settings = usettings;
            Version = ver;
            StartinIndex = _StartinIndex;
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public SyncSettingsRequest(uint Title, ulong user, UserSetting[] usettings, ushort settingCount, DateTime ver)
        {
            TitleId = Title;
            UserId = user;
            Settings = usettings;
            SettingsLen = settingCount;
            this.ManualArraySize = true;
            Version = ver;
            SetMachineClientType(CSGInfo.ClientType.Xenon);
        }

        public void SetMachineClientType(CSGInfo.ClientType clientType)
        {
            Slot.ChangeClientType(clientType);
        }

        public new SyncSettingsResponse Execute()
        {

            SyncSettingsResponse resp = null;

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            if (Modifyflag != AuthModify.None)
                ManualPopulateSlot();


            bool bRet = InternalExecute(Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd), reqStream);

            if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
            {
                if (xAct.ResponseContents.Length > 0)
                    resp = (SyncSettingsResponse)new SyncSettingsResponse().ReadBytes(xAct.ResponseContents);

            }
            else
            {
                resp = (SyncSettingsResponse)new SyncSettingsResponse();
                resp.XError = xAct.XErr;
            }


            return resp;
        }

        public SyncSettingsResponse ExecuteToInt()
        {
            return ExecuteToInt(null);
        }

        public SyncSettingsResponse ExecuteToInt(int? iPlatform)
        {
            IPEndPoint endpoint = Global.XEnv.GetVirtualInterface(VirtualInterface.profilefd_int);
            SyncSettingsResponse resp = null;

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            uint title = this.TitleId;
            ulong user = UserId;
            ulong requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
            byte[] addr = endpoint.Address.GetAddressBytes();
            uint ip = 0;
            for (int i = 0; i < addr.Length; i++) ip = (ip << 8) + addr[i];

            if (Modifyflag == AuthModify.Change_Title)
            {
                title += 10;
            }
            else if (Modifyflag == AuthModify.Change_User)
            {
                user += 10;
            }

            HTTPAuthData authData = new HTTPAuthData((ushort)endpoint.Port, ip, requestId, user, title, (uint)XOService.Progress, 0);
            CustomHeader = HTTPAuthData.HTTP_HEADER_AUTH_DATA + ":" + authData.GetBase64EncodedString() + "\r\n";

            if (iPlatform.HasValue)
            {
                // Pass in the XPLT platform flag
                CustomHeader += "XPLT:" + iPlatform + "\r\n";
            }

            bool bRet = InternalExecute(endpoint, reqStream);

            if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
            {
                if (xAct.ResponseContents.Length > 0)
                    resp = (SyncSettingsResponse)new SyncSettingsResponse().ReadBytes(xAct.ResponseContents);

            }
            else
            {
                resp = (SyncSettingsResponse)new SyncSettingsResponse();
                resp.XError = xAct.XErr;
            }

            return resp;
        }
    }

    public class SyncSettingsResponse : WireData
    {
        [WireInfo(ArraySize = 8)]
        public DateTime Version;
        public ushort TotalSettings;
        public ushort SettingsLen = 0;
        public UserSetting[] Settings = null;
        [WireInfo(Serialize = false)]
        public uint XError;

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\UserSettings\AvatarAssetNames.cs ===
using System;
using System.Collections.Generic;

namespace ServerTestFramework.LiveService.UserSettings
{
    public class AvatarAssets
    {
        static public Dictionary<Guid, string> assetsById = new Dictionary<Guid, string>();
        static public Dictionary<string, Guid> assetsByName = new Dictionary<string, Guid>();

        static void AddAsset(Guid assetId, string assetName)
        {
            assetsById.Add(assetId, assetName);
            assetsByName.Add(assetName, assetId);
        }

        static AvatarAssets()
        {
            AddAsset(new Guid(0x00000002, 0x0000, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male body");
            AddAsset(new Guid(0x00000002, 0x0001, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female body");
            AddAsset(new Guid(0x00000001, 0x0002, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Head");
            AddAsset(new Guid(0x00400000, 0x0003, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 0");
            AddAsset(new Guid(0x00400000, 0x0004, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 1");
            AddAsset(new Guid(0x00400000, 0x0005, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 2");
            AddAsset(new Guid(0x00400000, 0x0006, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic clap");
            AddAsset(new Guid(0x00400000, 0x0007, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic wave");
            AddAsset(new Guid(0x00400000, 0x0008, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic celebration");
            AddAsset(new Guid(0x00400000, 0x0009, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female idle check nails");
            AddAsset(new Guid(0x00400000, 0x000A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female idle looks around");
            AddAsset(new Guid(0x00400000, 0x000B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female idle shifts weight");
            AddAsset(new Guid(0x00400000, 0x000C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female idle fixes shoe");
            AddAsset(new Guid(0x00400000, 0x000D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female angry");
            AddAsset(new Guid(0x00400000, 0x000E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female confused");
            AddAsset(new Guid(0x00400000, 0x000F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female laugh");
            AddAsset(new Guid(0x00400000, 0x0010, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female sad cry");
            AddAsset(new Guid(0x00400000, 0x0011, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female shocked surprised");
            AddAsset(new Guid(0x00400000, 0x0012, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation female yawn");
            AddAsset(new Guid(0x00400000, 0x0013, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male idle looks around");
            AddAsset(new Guid(0x00400000, 0x0014, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male idle stretch");
            AddAsset(new Guid(0x00400000, 0x0015, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male idle shifts weight");
            AddAsset(new Guid(0x00400000, 0x0016, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male angry");
            AddAsset(new Guid(0x00400000, 0x0017, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male confused");
            AddAsset(new Guid(0x00400000, 0x0018, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male laugh");
            AddAsset(new Guid(0x00400000, 0x0019, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male sad cry");
            AddAsset(new Guid(0x00400000, 0x001A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male shocked surprised");
            AddAsset(new Guid(0x00400000, 0x001B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male yawn");
            AddAsset(new Guid(0x00400000, 0x001C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look down");
            AddAsset(new Guid(0x00400000, 0x001D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look left");
            AddAsset(new Guid(0x00400000, 0x001E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look neutral");
            AddAsset(new Guid(0x00400000, 0x001F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look right");
            AddAsset(new Guid(0x00400000, 0x0020, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look up");
            AddAsset(new Guid(0x00400000, 0x0021, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look down left");
            AddAsset(new Guid(0x00400000, 0x0022, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look down right");
            AddAsset(new Guid(0x00400000, 0x0023, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look up left");
            AddAsset(new Guid(0x00400000, 0x0024, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation creator look up right");
            AddAsset(new Guid(0x00400000, 0x0025, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation closet sleep");
            AddAsset(new Guid(0x00400000, 0x0026, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation male idle checks hand");
            AddAsset(new Guid(0x00400000, 0x0027, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 3");
            AddAsset(new Guid(0x00400000, 0x0028, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 4");
            AddAsset(new Guid(0x00400000, 0x0029, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 5");
            AddAsset(new Guid(0x00400000, 0x002A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 6");
            AddAsset(new Guid(0x00400000, 0x002B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Animation generic stand 7");
            AddAsset(new Guid(0x00000020, 0x002C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Moccasins");
            AddAsset(new Guid(0x00000020, 0x002D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal shoes");
            AddAsset(new Guid(0x00000020, 0x002E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High top sneakers");
            AddAsset(new Guid(0x00000020, 0x002F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hiking shoes");
            AddAsset(new Guid(0x00000020, 0x0030, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk boots");
            AddAsset(new Guid(0x00000020, 0x0031, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge trainers");
            AddAsset(new Guid(0x00000020, 0x0032, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flip flops");
            AddAsset(new Guid(0x00000020, 0x0033, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male pixie boots");
            AddAsset(new Guid(0x00000020, 0x0034, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male boots");
            AddAsset(new Guid(0x00000020, 0x0035, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male green xbox sneakers");
            AddAsset(new Guid(0x00000020, 0x0036, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male white xbox sneakers");
            AddAsset(new Guid(0x00000020, 0x0037, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male plimsolls");
            AddAsset(new Guid(0x00000020, 0x0038, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Brown formal shoes");
            AddAsset(new Guid(0x00000020, 0x0039, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowboy boots");
            AddAsset(new Guid(0x00000020, 0x003A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Goth boots");
            AddAsset(new Guid(0x00000020, 0x003B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s leather platforms");
            AddAsset(new Guid(0x00000020, 0x003C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male snowboarding boots");
            AddAsset(new Guid(0x00000208, 0x003D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Presenter jacket");
            AddAsset(new Guid(0x00000008, 0x003E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male colorful polo shirt");
            AddAsset(new Guid(0x00000208, 0x003F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male bright sprite hoodie");
            AddAsset(new Guid(0x00000208, 0x0040, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gothic long sleeved top");
            AddAsset(new Guid(0x00000208, 0x0042, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High school sports hoodie");
            AddAsset(new Guid(0x00000008, 0x0044, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male punk tee");
            AddAsset(new Guid(0x00000208, 0x0045, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black hoodie");
            AddAsset(new Guid(0x00000208, 0x0046, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male crew neck sweater");
            AddAsset(new Guid(0x00000208, 0x0047, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Winter jacket");
            AddAsset(new Guid(0x00000008, 0x0048, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male power tee");
            AddAsset(new Guid(0x00000208, 0x0049, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rocker jacket");
            AddAsset(new Guid(0x00000208, 0x004A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue formal shirt");
            AddAsset(new Guid(0x00000008, 0x004B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Polo shirt1");
            AddAsset(new Guid(0x00000208, 0x004C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Full zip hoodie with chain");
            AddAsset(new Guid(0x00000208, 0x004D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rockabilly top");
            AddAsset(new Guid(0x00000208, 0x004E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Waistcoat and shirt");
            AddAsset(new Guid(0x00000008, 0x004F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tropical shirt");
            AddAsset(new Guid(0x00000008, 0x0050, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk jacket and tee");
            AddAsset(new Guid(0x00000208, 0x0051, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Striped sweater with chain");
            AddAsset(new Guid(0x00000008, 0x0052, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s checked shirt");
            AddAsset(new Guid(0x00000208, 0x0053, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Groovy shirt");
            AddAsset(new Guid(0x00000008, 0x0054, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skateboard tee");
            AddAsset(new Guid(0x00000208, 0x0055, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jacket with tee");
            AddAsset(new Guid(0x00000008, 0x0056, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male football top");
            AddAsset(new Guid(0x00000208, 0x0057, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pastel shirt with tee");
            AddAsset(new Guid(0x00000008, 0x0058, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Metal tee");
            AddAsset(new Guid(0x00000208, 0x0059, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Track jacket");
            AddAsset(new Guid(0x00000208, 0x005A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jacket with sweater");
            AddAsset(new Guid(0x00000208, 0x005B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Open neck cardigan");
            AddAsset(new Guid(0x00000008, 0x005C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male guest 1");
            AddAsset(new Guid(0x00000008, 0x005D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male guest 2");
            AddAsset(new Guid(0x00000008, 0x005E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male guest 3");
            AddAsset(new Guid(0x00000208, 0x005F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge tee");
            AddAsset(new Guid(0x00000008, 0x0060, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long sleeved tee");
            AddAsset(new Guid(0x00000008, 0x0061, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Work shirt");
            AddAsset(new Guid(0x00000008, 0x0062, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male soccer top");
            AddAsset(new Guid(0x00000008, 0x0063, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Quantum tee");
            AddAsset(new Guid(0x00000008, 0x0064, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Baseball jersey");
            AddAsset(new Guid(0x00000008, 0x0065, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male white vest");
            AddAsset(new Guid(0x00000208, 0x0066, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male snowboarding jacket");
            AddAsset(new Guid(0x00000008, 0x0067, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male bright print tee");
            AddAsset(new Guid(0x00000208, 0x0068, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male denim jacket with tee");
            AddAsset(new Guid(0x00000208, 0x0069, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male striped jacket with polo");
            AddAsset(new Guid(0x00000008, 0x006A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male school tie tee");
            AddAsset(new Guid(0x00000208, 0x006B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male checked jacket with polo");
            AddAsset(new Guid(0x00000208, 0x006C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male cschool jacket with polo");
            AddAsset(new Guid(0x00000208, 0x006D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male 70 s full zip jacket");
            AddAsset(new Guid(0x00000008, 0x006E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male dollar tee");
            AddAsset(new Guid(0x00000008, 0x006F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male tattoo sweater");
            AddAsset(new Guid(0x00000008, 0x0070, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male wales sport top");
            AddAsset(new Guid(0x00000008, 0x0071, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male france sport top");
            AddAsset(new Guid(0x00000008, 0x0072, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male switzerland sport top");
            AddAsset(new Guid(0x00000008, 0x0073, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male sweden sport top");
            AddAsset(new Guid(0x00000008, 0x0074, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male spain sport top");
            AddAsset(new Guid(0x00000008, 0x0076, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male scotland sport top");
            AddAsset(new Guid(0x00000008, 0x0077, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male republic of ireland sport top");
            AddAsset(new Guid(0x00000008, 0x0078, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male portugal sport top");
            AddAsset(new Guid(0x00000008, 0x0079, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male norway sport top");
            AddAsset(new Guid(0x00000008, 0x007A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male northern ireland sport top");
            AddAsset(new Guid(0x00000008, 0x007C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male netherlands sport top");
            AddAsset(new Guid(0x00000008, 0x0080, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male italy sport top");
            AddAsset(new Guid(0x00000008, 0x0083, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male germany sport top");
            AddAsset(new Guid(0x00000008, 0x0084, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male finland sport top");
            AddAsset(new Guid(0x00000008, 0x0085, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male england sport top");
            AddAsset(new Guid(0x00000008, 0x0086, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male denmark sport top");
            AddAsset(new Guid(0x00000008, 0x0088, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male belgium sport top");
            AddAsset(new Guid(0x00000008, 0x0089, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male austria sport top");
            AddAsset(new Guid(0x00000008, 0x008B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rashguard");
            AddAsset(new Guid(0x00000208, 0x008C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shirt with cummerbund");
            AddAsset(new Guid(0x00000208, 0x008D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Red formal shirt");
            AddAsset(new Guid(0x00000008, 0x008E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Monkey tee");
            AddAsset(new Guid(0x00000010, 0x008F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male cargo pants");
            AddAsset(new Guid(0x00000010, 0x0090, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jeans");
            AddAsset(new Guid(0x00000010, 0x0091, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Faded jeans with print");
            AddAsset(new Guid(0x00000010, 0x0092, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chinos");
            AddAsset(new Guid(0x00000010, 0x0093, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male surf shorts");
            AddAsset(new Guid(0x00000010, 0x0094, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Metal combats");
            AddAsset(new Guid(0x00000010, 0x0095, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk pants");
            AddAsset(new Guid(0x00000010, 0x0096, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s plaid flares");
            AddAsset(new Guid(0x00000010, 0x0097, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swim shorts");
            AddAsset(new Guid(0x00000010, 0x0098, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Moleskin pants");
            AddAsset(new Guid(0x00000010, 0x0099, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male grunge pants");
            AddAsset(new Guid(0x00000010, 0x009A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male chino shorts");
            AddAsset(new Guid(0x00000010, 0x009B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male flower print flares");
            AddAsset(new Guid(0x00000010, 0x009C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male camo pants");
            AddAsset(new Guid(0x00000010, 0x009D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pinstripe pants");
            AddAsset(new Guid(0x00000010, 0x009E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dark purple jeans");
            AddAsset(new Guid(0x00000010, 0x009F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim shorts");
            AddAsset(new Guid(0x00000010, 0x00A0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black skinny fit jeans");
            AddAsset(new Guid(0x00000010, 0x00A1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tracksuit pants");
            AddAsset(new Guid(0x00000010, 0x00A2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rodeo jeans");
            AddAsset(new Guid(0x00000010, 0x00A3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cargo shorts");
            AddAsset(new Guid(0x00000010, 0x00A4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male popper pants");
            AddAsset(new Guid(0x00000010, 0x00A6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green skinny fit jeans");
            AddAsset(new Guid(0x00000010, 0x00A7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Turn up jeans");
            AddAsset(new Guid(0x00000010, 0x00A8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Embroidered pants");
            AddAsset(new Guid(0x00000010, 0x00A9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Worn jeans");
            AddAsset(new Guid(0x00800218, 0x00AA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male suit and tie");
            AddAsset(new Guid(0x00800218, 0x00AB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male formal suit");
            AddAsset(new Guid(0x00800218, 0x00AC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male suspenders with high pants");
            AddAsset(new Guid(0x00800238, 0x00AD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black trench coat");
            AddAsset(new Guid(0x00800238, 0x00AE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue tuxedo");
            AddAsset(new Guid(0x00800238, 0x00AF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Western duster");
            AddAsset(new Guid(0x00800218, 0x00B0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tan formal suit");
            AddAsset(new Guid(0x00800218, 0x00B1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Morning suit");
            AddAsset(new Guid(0x00800238, 0x00B2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black tuxedo");
            AddAsset(new Guid(0x00000880, 0x00B3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge fingerless gloves");
            AddAsset(new Guid(0x00000880, 0x00B4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Woolly gloves");
            AddAsset(new Guid(0x00000400, 0x00B5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male diamond stud earrings");
            AddAsset(new Guid(0x00000400, 0x00B6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male gold stud earrings");
            AddAsset(new Guid(0x00000400, 0x00B7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male silver stud earrings");
            AddAsset(new Guid(0x00000400, 0x00B8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male left feather earring");
            AddAsset(new Guid(0x00000400, 0x00B9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male punk studs");
            AddAsset(new Guid(0x00000400, 0x00BA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male left beaded earring");
            AddAsset(new Guid(0x00000400, 0x00BB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male gold hoop earrings");
            AddAsset(new Guid(0x00000400, 0x00BC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male silver hoop earrings");
            AddAsset(new Guid(0x00000100, 0x00BD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Metallic carbon shades");
            AddAsset(new Guid(0x00000100, 0x00BE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer shades");
            AddAsset(new Guid(0x00000100, 0x00BF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male arthouse glasses");
            AddAsset(new Guid(0x00000100, 0x00C0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male jam jar glasses");
            AddAsset(new Guid(0x00000100, 0x00C1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male pilot shades");
            AddAsset(new Guid(0x00000100, 0x00C2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male tortoise shell glasses");
            AddAsset(new Guid(0x00000100, 0x00C3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Red shutter shades");
            AddAsset(new Guid(0x00000100, 0x00C4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Monacle");
            AddAsset(new Guid(0x00000100, 0x00C5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Retro shades");
            AddAsset(new Guid(0x00000100, 0x00C6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hippy shades");
            AddAsset(new Guid(0x00000100, 0x00C7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "White shutter shades");
            AddAsset(new Guid(0x00000100, 0x00C8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black shutter shades");
            AddAsset(new Guid(0x00000100, 0x00C9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Professional shades");
            AddAsset(new Guid(0x00000100, 0x00CA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious glasses");
            AddAsset(new Guid(0x00000100, 0x00CB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "50 s glasses");
            AddAsset(new Guid(0x00000100, 0x00CC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sports shades");
            AddAsset(new Guid(0x00000100, 0x00CD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female shades");
            AddAsset(new Guid(0x00000100, 0x00CE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female star glasses");
            AddAsset(new Guid(0x00000100, 0x00CF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pilot shades");
            AddAsset(new Guid(0x00000100, 0x00D0, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pink gem shades");
            AddAsset(new Guid(0x00000100, 0x00D1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slick shades");
            AddAsset(new Guid(0x00000100, 0x00D2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female yellow shutter shades");
            AddAsset(new Guid(0x00000100, 0x00D3, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue shutter shades");
            AddAsset(new Guid(0x00000100, 0x00D4, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female green shutter shades");
            AddAsset(new Guid(0x00000100, 0x00D5, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female oval glasses");
            AddAsset(new Guid(0x00000100, 0x00D6, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tortoiseshell star glasses");
            AddAsset(new Guid(0x00000100, 0x00D7, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female red heart shades");
            AddAsset(new Guid(0x00000100, 0x00D8, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female red gem glasses");
            AddAsset(new Guid(0x00000100, 0x00D9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female black 60 s shades");
            AddAsset(new Guid(0x00000100, 0x00DA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female studious glasses");
            AddAsset(new Guid(0x00000100, 0x00DB, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female white heart shades");
            AddAsset(new Guid(0x00000200, 0x00DC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slick watch");
            AddAsset(new Guid(0x00000200, 0x00DD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studded wrist strap");
            AddAsset(new Guid(0x00000200, 0x00DE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Leather strap watch");
            AddAsset(new Guid(0x00000200, 0x00DF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue solidarity band");
            AddAsset(new Guid(0x00000200, 0x00E0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Retro digital watch");
            AddAsset(new Guid(0x00000200, 0x00E1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Titanium sports watch");
            AddAsset(new Guid(0x00000200, 0x00E2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pink sweat bands");
            AddAsset(new Guid(0x00000200, 0x00E3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vibrant sweat bands");
            AddAsset(new Guid(0x00000040, 0x00E4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male baseball cap");
            AddAsset(new Guid(0x00000040, 0x00E5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Red visor beanie");
            AddAsset(new Guid(0x00000040, 0x00E6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flame beanie");
            AddAsset(new Guid(0x00000040, 0x00E7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vintage trilby");
            AddAsset(new Guid(0x00000040, 0x00E8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Camo baseball cap");
            AddAsset(new Guid(0x00000040, 0x00E9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male two tone beanie");
            AddAsset(new Guid(0x00000040, 0x00EA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male deer stalker");
            AddAsset(new Guid(0x00000040, 0x00EB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male cowboy hat");
            AddAsset(new Guid(0x00000040, 0x00EC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male bowler");
            AddAsset(new Guid(0x00000040, 0x00ED, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male stripped visor beanie");
            AddAsset(new Guid(0x00000040, 0x00EE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male black cowboy hat");
            AddAsset(new Guid(0x00000040, 0x00EF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male black trilby");
            AddAsset(new Guid(0x00000040, 0x00F0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male tweed trilby");
            AddAsset(new Guid(0x00000040, 0x00F1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male top hat");
            AddAsset(new Guid(0x00000040, 0x00F2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male rave baseball cap");
            AddAsset(new Guid(0x00000040, 0x00F3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer baseball cap");
            AddAsset(new Guid(0x00000800, 0x00F4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Silver ring");
            AddAsset(new Guid(0x00000800, 0x00F5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male gold wedding band");
            AddAsset(new Guid(0x00000800, 0x00F6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male silver wedding band");
            AddAsset(new Guid(0x00000800, 0x00F7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gold ring");
            AddAsset(new Guid(0x00000800, 0x00F8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sovereign ring");
            AddAsset(new Guid(0x00000800, 0x00F9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Square stones ring");
            AddAsset(new Guid(0x00000800, 0x00FA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skull ring");
            AddAsset(new Guid(0x00000800, 0x00FB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Celtic ring");
            AddAsset(new Guid(0x00000020, 0x00FC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sports trainers");
            AddAsset(new Guid(0x00000020, 0x00FD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Ballet flats");
            AddAsset(new Guid(0x00000020, 0x00FE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sandals");
            AddAsset(new Guid(0x00000020, 0x00FF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "White 60 s boots");
            AddAsset(new Guid(0x00000020, 0x0100, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Scarlet pumps");
            AddAsset(new Guid(0x00000020, 0x0101, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cork high heels");
            AddAsset(new Guid(0x00000020, 0x0102, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female goth boots");
            AddAsset(new Guid(0x00000020, 0x0103, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female neo rave pumps");
            AddAsset(new Guid(0x00000020, 0x0104, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female strappy high heels");
            AddAsset(new Guid(0x00000020, 0x0105, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female dayglo zebra print pumps");
            AddAsset(new Guid(0x00000020, 0x0106, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female rainy day boots");
            AddAsset(new Guid(0x00000020, 0x0107, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tiger print pumps");
            AddAsset(new Guid(0x00000020, 0x0108, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female black 60 s boots");
            AddAsset(new Guid(0x00000020, 0x0109, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female jelly clogs");
            AddAsset(new Guid(0x00000020, 0x010A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female platform shoes");
            AddAsset(new Guid(0x00000020, 0x010B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female snugg boots");
            AddAsset(new Guid(0x00000020, 0x010C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female snowboarding boots");
            AddAsset(new Guid(0x00000208, 0x010D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Snowboarding jacket");
            AddAsset(new Guid(0x00000008, 0x010F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green full zip hoodie");
            AddAsset(new Guid(0x00000208, 0x0110, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk tee");
            AddAsset(new Guid(0x00000008, 0x0111, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue full zip hoodie");
            AddAsset(new Guid(0x00000208, 0x0112, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gingham shirt");
            AddAsset(new Guid(0x00000008, 0x0113, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tight tee");
            AddAsset(new Guid(0x00000008, 0x0114, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tee with belt");
            AddAsset(new Guid(0x00000008, 0x0115, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cardigan with vest");
            AddAsset(new Guid(0x00000208, 0x0116, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Brown full zip hoodie");
            AddAsset(new Guid(0x00000008, 0x0117, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vest with straps");
            AddAsset(new Guid(0x00000208, 0x0118, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hacking jacket");
            AddAsset(new Guid(0x00000208, 0x0119, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal blouse");
            AddAsset(new Guid(0x00000208, 0x011A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Open neck sweater");
            AddAsset(new Guid(0x00000008, 0x011B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Two tone tee");
            AddAsset(new Guid(0x00000008, 0x011C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Waistcoat with vest");
            AddAsset(new Guid(0x00000208, 0x011D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crop top with sweat bands");
            AddAsset(new Guid(0x00000008, 0x011E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer vest");
            AddAsset(new Guid(0x00000008, 0x011F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crew neck tee");
            AddAsset(new Guid(0x00000008, 0x0120, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Star pattern shirt");
            AddAsset(new Guid(0x00000208, 0x0121, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "V neck top");
            AddAsset(new Guid(0x00000008, 0x0122, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hot pink vest");
            AddAsset(new Guid(0x00000008, 0x0123, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "V neck tee");
            AddAsset(new Guid(0x00000208, 0x0124, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female crew neck sweater");
            AddAsset(new Guid(0x00000208, 0x0125, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wrap shirt");
            AddAsset(new Guid(0x00000208, 0x0126, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Turtleneck sweater");
            AddAsset(new Guid(0x00000208, 0x0127, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sweater with shirt");
            AddAsset(new Guid(0x00000208, 0x0128, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Layered jacket");
            AddAsset(new Guid(0x00000008, 0x0129, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female polo shirt");
            AddAsset(new Guid(0x00000008, 0x012A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowgirl shirt");
            AddAsset(new Guid(0x00000208, 0x012B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Biker jacket");
            AddAsset(new Guid(0x00000008, 0x012C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female power tee");
            AddAsset(new Guid(0x00000008, 0x012D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female guest 1");
            AddAsset(new Guid(0x00000008, 0x012E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female guest 2");
            AddAsset(new Guid(0x00000008, 0x012F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female guest 3");
            AddAsset(new Guid(0x00000008, 0x0130, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female full zip tracksuit");
            AddAsset(new Guid(0x00000008, 0x0131, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female glass tee");
            AddAsset(new Guid(0x00000008, 0x0132, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female lips tee");
            AddAsset(new Guid(0x00000208, 0x0133, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female pinstripe blazer");
            AddAsset(new Guid(0x00000008, 0x0134, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female oversized jacket with chains");
            AddAsset(new Guid(0x00000208, 0x0135, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female rain coat");
            AddAsset(new Guid(0x00000008, 0x0136, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female denim jacket");
            AddAsset(new Guid(0x00000208, 0x0137, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female fitted blazer");
            AddAsset(new Guid(0x00000008, 0x0138, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flower vest");
            AddAsset(new Guid(0x00000008, 0x0139, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female boombox tee");
            AddAsset(new Guid(0x00000008, 0x013B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female austria sport top");
            AddAsset(new Guid(0x00000008, 0x013C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female belgium sport top");
            AddAsset(new Guid(0x00000008, 0x013E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female denmark sport top");
            AddAsset(new Guid(0x00000008, 0x013F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female england sport top");
            AddAsset(new Guid(0x00000008, 0x0140, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female finland sport top");
            AddAsset(new Guid(0x00000008, 0x0141, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female france sport top");
            AddAsset(new Guid(0x00000008, 0x0142, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female germany sport top");
            AddAsset(new Guid(0x00000008, 0x0145, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female italy sport top");
            AddAsset(new Guid(0x00000008, 0x0149, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female netherlands sport top");
            AddAsset(new Guid(0x00000008, 0x014B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female northern ireland sport top");
            AddAsset(new Guid(0x00000008, 0x014C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female norway sport top");
            AddAsset(new Guid(0x00000008, 0x014D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female portugal sport top");
            AddAsset(new Guid(0x00000008, 0x014E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female republic of ireland sport top");
            AddAsset(new Guid(0x00000008, 0x014F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female scotland sport top");
            AddAsset(new Guid(0x00000008, 0x0151, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female spain sport top");
            AddAsset(new Guid(0x00000008, 0x0152, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female sweden sport top");
            AddAsset(new Guid(0x00000008, 0x0153, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female switzerland sport top");
            AddAsset(new Guid(0x00000008, 0x0156, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female wales sport top");
            AddAsset(new Guid(0x00000208, 0x0157, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vintage snowdrop blouse");
            AddAsset(new Guid(0x00000010, 0x0158, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skinny fit jeans");
            AddAsset(new Guid(0x00000010, 0x0159, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chino shorts");
            AddAsset(new Guid(0x00000010, 0x015A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slacks");
            AddAsset(new Guid(0x00000010, 0x015B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Polkadot skirt");
            AddAsset(new Guid(0x00000010, 0x015C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thread skirt");
            AddAsset(new Guid(0x00000010, 0x015D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jogging pants");
            AddAsset(new Guid(0x00000010, 0x015E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chinos with belt");
            AddAsset(new Guid(0x00000010, 0x015F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female cargo pants");
            AddAsset(new Guid(0x00000010, 0x0160, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim surfer shorts");
            AddAsset(new Guid(0x00000010, 0x0161, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tracksuit pants");
            AddAsset(new Guid(0x00000010, 0x0162, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female surfer hotpants");
            AddAsset(new Guid(0x00000010, 0x0163, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female denim shorts with thread");
            AddAsset(new Guid(0x00000010, 0x0164, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tartan skirt");
            AddAsset(new Guid(0x00000010, 0x0165, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female surfer shorts");
            AddAsset(new Guid(0x00000010, 0x0166, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female short shorts");
            AddAsset(new Guid(0x00000010, 0x0167, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dogtooth pattern skirt");
            AddAsset(new Guid(0x00000010, 0x0168, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim skirt");
            AddAsset(new Guid(0x00000010, 0x0169, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer skirt");
            AddAsset(new Guid(0x00000010, 0x016A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pencil skirt");
            AddAsset(new Guid(0x00000010, 0x016B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tennis skirt");
            AddAsset(new Guid(0x00000010, 0x016C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tartan skirt re textured");
            AddAsset(new Guid(0x00000010, 0x016D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female baggy jeans");
            AddAsset(new Guid(0x00000010, 0x016E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female flares");
            AddAsset(new Guid(0x00000010, 0x016F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female leopard print leggings");
            AddAsset(new Guid(0x00000010, 0x0170, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Retro skirt");
            AddAsset(new Guid(0x00800018, 0x0171, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Strapless dress");
            AddAsset(new Guid(0x00800018, 0x0172, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Striped sundress");
            AddAsset(new Guid(0x00800018, 0x0173, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pleated dress");
            AddAsset(new Guid(0x00800018, 0x0174, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cheerleader dress");
            AddAsset(new Guid(0x00800018, 0x0175, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Babydoll dress");
            AddAsset(new Guid(0x00800018, 0x0176, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rockabilly dress");
            AddAsset(new Guid(0x00800018, 0x0177, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "60 s dress");
            AddAsset(new Guid(0x00800018, 0x0178, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dress with sash");
            AddAsset(new Guid(0x00800018, 0x0179, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mint sundress");
            AddAsset(new Guid(0x00800A98, 0x017A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female little black dress");
            AddAsset(new Guid(0x00800018, 0x017B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female two button babydoll dress");
            AddAsset(new Guid(0x00800018, 0x017C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Daisy print dress");
            AddAsset(new Guid(0x00800018, 0x017D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dungarees");
            AddAsset(new Guid(0x00800218, 0x017E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin set");
            AddAsset(new Guid(0x00800218, 0x017F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal trouser suit");
            AddAsset(new Guid(0x00800018, 0x0180, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Elegant ball gown");
            AddAsset(new Guid(0x00800018, 0x0182, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jogger");
            AddAsset(new Guid(0x00800018, 0x0183, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer dress");
            AddAsset(new Guid(0x00000880, 0x0184, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pink fingerless gloves");
            AddAsset(new Guid(0x00000880, 0x0185, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue fingerless gloves");
            AddAsset(new Guid(0x00000880, 0x0186, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Yellow fingerless gloves");
            AddAsset(new Guid(0x00000880, 0x0187, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Biker gloves");
            AddAsset(new Guid(0x00000880, 0x0188, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rainbow gloves");
            AddAsset(new Guid(0x00000880, 0x0189, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fingerless heart gloves");
            AddAsset(new Guid(0x00000400, 0x018A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female left gold hoop earring");
            AddAsset(new Guid(0x00000400, 0x018B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female left silver hoop earring");
            AddAsset(new Guid(0x00000400, 0x018C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female diamante earrings");
            AddAsset(new Guid(0x00000400, 0x018D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female 60 s earrings");
            AddAsset(new Guid(0x00000200, 0x018E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gold bracelet");
            AddAsset(new Guid(0x00000200, 0x018F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Digital watch");
            AddAsset(new Guid(0x00000200, 0x0190, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skull wrist band");
            AddAsset(new Guid(0x00000200, 0x0191, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sporty sweat bands");
            AddAsset(new Guid(0x00000200, 0x0192, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Orange solidarity band");
            AddAsset(new Guid(0x00000200, 0x0193, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Silver chain bracelet");
            AddAsset(new Guid(0x00000200, 0x0194, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Elegant watch");
            AddAsset(new Guid(0x00000200, 0x0195, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chunky beaded bracelet");
            AddAsset(new Guid(0x00000040, 0x0196, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Panama hat");
            AddAsset(new Guid(0x00000040, 0x0197, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female baseball cap");
            AddAsset(new Guid(0x00000040, 0x0198, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straw hat");
            AddAsset(new Guid(0x00000040, 0x0199, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Knit pull on");
            AddAsset(new Guid(0x00000040, 0x019A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tartan flat cap");
            AddAsset(new Guid(0x00000040, 0x019B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female rhinestone cowgirl hat");
            AddAsset(new Guid(0x00000040, 0x019C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female striped knit pull on");
            AddAsset(new Guid(0x00000040, 0x019D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female knit pull on with bobble");
            AddAsset(new Guid(0x00000040, 0x019E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female sailor hat");
            AddAsset(new Guid(0x00000040, 0x019F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Maroon knit pull on");
            AddAsset(new Guid(0x00000040, 0x01A0, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green bucket hat");
            AddAsset(new Guid(0x00000040, 0x01A1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "White cowgirl hat");
            AddAsset(new Guid(0x00000040, 0x01A2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue bucket hat");
            AddAsset(new Guid(0x00000040, 0x01A3, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flower bobble hat");
            AddAsset(new Guid(0x00000040, 0x01A4, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green floral baseball cap");
            AddAsset(new Guid(0x00000040, 0x01A5, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female rave baseball cap");
            AddAsset(new Guid(0x00000800, 0x01A6, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female gold wedding band");
            AddAsset(new Guid(0x00000800, 0x01A7, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female silver wedding band");
            AddAsset(new Guid(0x00000800, 0x01A8, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gold ring with emeralds");
            AddAsset(new Guid(0x00000800, 0x01A9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Silver sapphire ring");
            AddAsset(new Guid(0x00000800, 0x01AA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Large diamond ring");
            AddAsset(new Guid(0x00000800, 0x01AB, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Red chunky ring");
            AddAsset(new Guid(0x00000800, 0x01AC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green chunky ring");
            AddAsset(new Guid(0x00000800, 0x01AD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Split ring");
            AddAsset(new Guid(0x00000004, 0x01AE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bald");
            AddAsset(new Guid(0x00000004, 0x01AF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bald  hat ");
            AddAsset(new Guid(0x00000004, 0x01B0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Peak");
            AddAsset(new Guid(0x00000004, 0x01B1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Peak  hat ");
            AddAsset(new Guid(0x00000004, 0x01B2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fauxhawk");
            AddAsset(new Guid(0x00000004, 0x01B3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fauxhawk  hat ");
            AddAsset(new Guid(0x00000004, 0x01B4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flat top");
            AddAsset(new Guid(0x00000004, 0x01B5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flat top  hat ");
            AddAsset(new Guid(0x00000004, 0x01B6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "The captain cut");
            AddAsset(new Guid(0x00000004, 0x01B7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Old hair  hat ");
            AddAsset(new Guid(0x00000004, 0x01B8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High and tight");
            AddAsset(new Guid(0x00000004, 0x01B9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High and tight  hat ");
            AddAsset(new Guid(0x00000004, 0x01BA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left comb over");
            AddAsset(new Guid(0x00000004, 0x01BB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left comb over  hat ");
            AddAsset(new Guid(0x00000004, 0x01BC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right comb over");
            AddAsset(new Guid(0x00000004, 0x01BD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaped left");
            AddAsset(new Guid(0x00000004, 0x01BE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaped left  hat ");
            AddAsset(new Guid(0x00000004, 0x01BF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaped right");
            AddAsset(new Guid(0x00000004, 0x01C0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaped right  hat ");
            AddAsset(new Guid(0x00000004, 0x01C1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short and spikey");
            AddAsset(new Guid(0x00000004, 0x01C2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short and spikey  hat ");
            AddAsset(new Guid(0x00000004, 0x01C3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right parting");
            AddAsset(new Guid(0x00000004, 0x01C4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left parting");
            AddAsset(new Guid(0x00000004, 0x01C5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Parting  hat ");
            AddAsset(new Guid(0x00000004, 0x01C6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left curved parting");
            AddAsset(new Guid(0x00000004, 0x01C7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left curved parting  hat ");
            AddAsset(new Guid(0x00000004, 0x01C8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right curved parting");
            AddAsset(new Guid(0x00000004, 0x01C9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right curved parting  hat ");
            AddAsset(new Guid(0x00000004, 0x01CA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short with left curls");
            AddAsset(new Guid(0x00000004, 0x01CB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short with left curls  hat ");
            AddAsset(new Guid(0x00000004, 0x01CC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short with right curls");
            AddAsset(new Guid(0x00000004, 0x01CD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short with right curls  hat ");
            AddAsset(new Guid(0x00000004, 0x01CE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Number one");
            AddAsset(new Guid(0x00000004, 0x01CF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Number one  hat ");
            AddAsset(new Guid(0x00000004, 0x01D0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Raised left parting");
            AddAsset(new Guid(0x00000004, 0x01D1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Raised right parting");
            AddAsset(new Guid(0x00000004, 0x01D2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Raised right parting  hat ");
            AddAsset(new Guid(0x00000004, 0x01D3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Raised left parting  hat ");
            AddAsset(new Guid(0x00000004, 0x01D4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thin on top");
            AddAsset(new Guid(0x00000004, 0x01D5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thin on top  hat ");
            AddAsset(new Guid(0x00000004, 0x01D6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Parted left and slicked");
            AddAsset(new Guid(0x00000004, 0x01D7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Parted right and slicked");
            AddAsset(new Guid(0x00000004, 0x01D8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Parted right and slicked  hat ");
            AddAsset(new Guid(0x00000004, 0x01D9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Parted left and slicked  hat ");
            AddAsset(new Guid(0x00000004, 0x01DA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Spiky on top");
            AddAsset(new Guid(0x00000004, 0x01DB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Spiky on top  hat ");
            AddAsset(new Guid(0x00000004, 0x01DC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Buzz cut");
            AddAsset(new Guid(0x00000004, 0x01DD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Buzz cut  hat ");
            AddAsset(new Guid(0x00000004, 0x01DE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Raised front");
            AddAsset(new Guid(0x00000004, 0x01DF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Quiff  hat ");
            AddAsset(new Guid(0x00000004, 0x01E0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mohawk");
            AddAsset(new Guid(0x00000004, 0x01E1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mohawk  hat ");
            AddAsset(new Guid(0x00000004, 0x01E2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Perm with fringe");
            AddAsset(new Guid(0x00000004, 0x01E3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Perm with fringe  hat ");
            AddAsset(new Guid(0x00000004, 0x01E4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Afro");
            AddAsset(new Guid(0x00000004, 0x01E5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Afro  hat ");
            AddAsset(new Guid(0x00000004, 0x01E6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Curtains");
            AddAsset(new Guid(0x00000004, 0x01E7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Curtains  hat ");
            AddAsset(new Guid(0x00000004, 0x01E8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wild from the left");
            AddAsset(new Guid(0x00000004, 0x01E9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wild from the left  hat ");
            AddAsset(new Guid(0x00000004, 0x01EA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wild from the right");
            AddAsset(new Guid(0x00000004, 0x01EB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wild from the right  hat ");
            AddAsset(new Guid(0x00000004, 0x01EC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cornrows");
            AddAsset(new Guid(0x00000004, 0x01ED, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cornrows  hat ");
            AddAsset(new Guid(0x00000004, 0x01EE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Funky bumps");
            AddAsset(new Guid(0x00000004, 0x01EF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Funky bumps  hat ");
            AddAsset(new Guid(0x00000004, 0x01F0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer bob");
            AddAsset(new Guid(0x00000004, 0x01F1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer bob  hat ");
            AddAsset(new Guid(0x00000004, 0x01F2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Compact");
            AddAsset(new Guid(0x00000004, 0x01F3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Compact  hat ");
            AddAsset(new Guid(0x00000004, 0x01F4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bun");
            AddAsset(new Guid(0x00000004, 0x01F5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bun  hat ");
            AddAsset(new Guid(0x00000004, 0x01F6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Ponytail");
            AddAsset(new Guid(0x00000004, 0x01F7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Ponytail  hat ");
            AddAsset(new Guid(0x00000004, 0x01F8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept back");
            AddAsset(new Guid(0x00000004, 0x01F9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept back  hat ");
            AddAsset(new Guid(0x00000004, 0x01FA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pig tails with fringe");
            AddAsset(new Guid(0x00000004, 0x01FB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pig tails with fringe  hat ");
            AddAsset(new Guid(0x00000004, 0x01FC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dreadlocks");
            AddAsset(new Guid(0x00000004, 0x01FD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dreadlocks  hat ");
            AddAsset(new Guid(0x00000004, 0x01FE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crew cut");
            AddAsset(new Guid(0x00000004, 0x01FF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crew cut  hat ");
            AddAsset(new Guid(0x00000004, 0x0200, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept from left");
            AddAsset(new Guid(0x00000004, 0x0201, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept from right");
            AddAsset(new Guid(0x00000004, 0x0202, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept from right  hat ");
            AddAsset(new Guid(0x00000004, 0x0203, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept from left  hat ");
            AddAsset(new Guid(0x00000004, 0x0204, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight left parting");
            AddAsset(new Guid(0x00000004, 0x0205, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight left parting  hat ");
            AddAsset(new Guid(0x00000004, 0x0206, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight right parting");
            AddAsset(new Guid(0x00000004, 0x0207, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight right parting  hat ");
            AddAsset(new Guid(0x00000004, 0x0208, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Low ponytail");
            AddAsset(new Guid(0x00000004, 0x0209, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Low ponytail  hat ");
            AddAsset(new Guid(0x00000004, 0x020A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shoulder length");
            AddAsset(new Guid(0x00000004, 0x020B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shoulder length  hat ");
            AddAsset(new Guid(0x00000004, 0x020C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaved pattern");
            AddAsset(new Guid(0x00000004, 0x020D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaved pattern  hat ");
            AddAsset(new Guid(0x00000004, 0x020E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slicked");
            AddAsset(new Guid(0x00000004, 0x020F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slicked  hat ");
            AddAsset(new Guid(0x00000004, 0x0210, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pig tails");
            AddAsset(new Guid(0x00000004, 0x0211, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pig tails  hat ");
            AddAsset(new Guid(0x00000004, 0x0212, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Layered with fringe");
            AddAsset(new Guid(0x00000004, 0x0213, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Layered with fringe  hat ");
            AddAsset(new Guid(0x00000004, 0x0214, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chopsticks left parting");
            AddAsset(new Guid(0x00000004, 0x0215, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chopsticks parted left  hat ");
            AddAsset(new Guid(0x00000004, 0x0216, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chopsticks right parting");
            AddAsset(new Guid(0x00000004, 0x0217, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gentle waves");
            AddAsset(new Guid(0x00000004, 0x0218, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gentle waves  hat ");
            AddAsset(new Guid(0x00000004, 0x0219, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short ties");
            AddAsset(new Guid(0x00000004, 0x021A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short ties  hat ");
            AddAsset(new Guid(0x00000004, 0x021B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long flick");
            AddAsset(new Guid(0x00000004, 0x021C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long flick  hat ");
            AddAsset(new Guid(0x00000004, 0x021D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed right");
            AddAsset(new Guid(0x00000004, 0x021E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed right  hat ");
            AddAsset(new Guid(0x00000004, 0x021F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed left");
            AddAsset(new Guid(0x00000004, 0x0220, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed left  hat ");
            AddAsset(new Guid(0x00000004, 0x0221, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Even length");
            AddAsset(new Guid(0x00000004, 0x0222, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Even length  hat ");
            AddAsset(new Guid(0x00000004, 0x0223, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tied on top left");
            AddAsset(new Guid(0x00000004, 0x0224, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tied on top left  hat ");
            AddAsset(new Guid(0x00000004, 0x0225, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tied on top right");
            AddAsset(new Guid(0x00000004, 0x0226, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tied on top right  hat ");
            AddAsset(new Guid(0x00000004, 0x0227, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept back parting");
            AddAsset(new Guid(0x00000004, 0x0228, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swept back parting  hat ");
            AddAsset(new Guid(0x00000004, 0x0229, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaggy");
            AddAsset(new Guid(0x00000004, 0x022A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaggy  hat ");
            AddAsset(new Guid(0x00000004, 0x022B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pinup curls");
            AddAsset(new Guid(0x00000004, 0x022C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pinup curls  hat ");
            AddAsset(new Guid(0x00000004, 0x022D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Up and over");
            AddAsset(new Guid(0x00000004, 0x022E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Up and over  hat ");
            AddAsset(new Guid(0x00000004, 0x022F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bob with fringe");
            AddAsset(new Guid(0x00000004, 0x0230, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bob with fringe  hat ");
            AddAsset(new Guid(0x00000004, 0x0231, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin plaits left parting");
            AddAsset(new Guid(0x00000004, 0x0232, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin plaits parted left  hat ");
            AddAsset(new Guid(0x00000004, 0x0233, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin plaits right parting");
            AddAsset(new Guid(0x00000004, 0x0234, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin plaits parted right  hat ");
            AddAsset(new Guid(0x00000004, 0x0235, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bob with curls");
            AddAsset(new Guid(0x00000004, 0x0236, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bob with curls  hat ");
            AddAsset(new Guid(0x00000004, 0x0237, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mullet");
            AddAsset(new Guid(0x00000004, 0x0238, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mullet  hat ");
            AddAsset(new Guid(0x00000004, 0x0239, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short flick right");
            AddAsset(new Guid(0x00000004, 0x023A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short flick right  hat ");
            AddAsset(new Guid(0x00000004, 0x023B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short flick left");
            AddAsset(new Guid(0x00000004, 0x023C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short flick left  hat ");
            AddAsset(new Guid(0x00000004, 0x023D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "A line bob");
            AddAsset(new Guid(0x00000004, 0x023E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "A line bob  hat ");
            AddAsset(new Guid(0x00000004, 0x023F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Styled right");
            AddAsset(new Guid(0x00000004, 0x0240, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Styled right  hat ");
            AddAsset(new Guid(0x00000004, 0x0241, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Styled left");
            AddAsset(new Guid(0x00000004, 0x0242, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Styled left  hat ");
            AddAsset(new Guid(0x00000004, 0x0243, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crimped");
            AddAsset(new Guid(0x00000004, 0x0244, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crimped  hat ");
            AddAsset(new Guid(0x00000004, 0x0245, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Beehive with right curl");
            AddAsset(new Guid(0x00000004, 0x0246, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Beehive with right curl  hat ");
            AddAsset(new Guid(0x00000004, 0x0247, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Beehive with left curl");
            AddAsset(new Guid(0x00000004, 0x0248, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Beehive with left curl  hat ");
            AddAsset(new Guid(0x00000004, 0x0249, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Ringlet curls");
            AddAsset(new Guid(0x00000004, 0x024A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Ringlet curls  hat ");
            AddAsset(new Guid(0x00000004, 0x024B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Braided crown");
            AddAsset(new Guid(0x00000004, 0x024C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Braided crown  hat ");
            AddAsset(new Guid(0x00000004, 0x024D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bedhead");
            AddAsset(new Guid(0x00000004, 0x024E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bedhead  hat ");
            AddAsset(new Guid(0x00000004, 0x024F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pompadour");
            AddAsset(new Guid(0x00000004, 0x0250, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pompadour  hat ");
            AddAsset(new Guid(0x00000004, 0x0251, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bowl cut");
            AddAsset(new Guid(0x00000004, 0x0252, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Basin  hat ");
            AddAsset(new Guid(0x00000004, 0x0253, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Teased spikes");
            AddAsset(new Guid(0x00000004, 0x0254, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Teased spikes  hat ");
            AddAsset(new Guid(0x00000004, 0x0255, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious left");
            AddAsset(new Guid(0x00000004, 0x0256, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious left  hat ");
            AddAsset(new Guid(0x00000004, 0x0257, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious right");
            AddAsset(new Guid(0x00000004, 0x0258, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious right  hat ");
            AddAsset(new Guid(0x00000004, 0x0259, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin buns");
            AddAsset(new Guid(0x00000004, 0x025A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin buns  hat ");
            AddAsset(new Guid(0x00000004, 0x025B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed back");
            AddAsset(new Guid(0x00000004, 0x025C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Combed back  hat ");
            AddAsset(new Guid(0x00000004, 0x025D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Zigzag fringe");
            AddAsset(new Guid(0x00000004, 0x025E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Zigzag fringe  hat ");
            AddAsset(new Guid(0x00004000, 0x025F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight eyebrows");
            AddAsset(new Guid(0x00004000, 0x0260, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Arched eyebrows");
            AddAsset(new Guid(0x00004000, 0x0261, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious eyebrows");
            AddAsset(new Guid(0x00004000, 0x0262, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Curvy eyebrows");
            AddAsset(new Guid(0x00004000, 0x0263, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Large eyebrows");
            AddAsset(new Guid(0x00004000, 0x0264, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Familiar eyebrows");
            AddAsset(new Guid(0x00004000, 0x0265, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thick eyebrows");
            AddAsset(new Guid(0x00004000, 0x0266, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small eyebrows");
            AddAsset(new Guid(0x00004000, 0x0267, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Angled eyebrows");
            AddAsset(new Guid(0x00004000, 0x0268, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Big and flat eyebrows");
            AddAsset(new Guid(0x00004000, 0x0269, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Delicate eyebrows");
            AddAsset(new Guid(0x00004000, 0x026A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small and thin eyebrows");
            AddAsset(new Guid(0x00004000, 0x026B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Short and thick eyebrows");
            AddAsset(new Guid(0x00004000, 0x026C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight and thick eyebrows");
            AddAsset(new Guid(0x00004000, 0x026D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Half moon eyebrows");
            AddAsset(new Guid(0x00004000, 0x026E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Soft eyebrows");
            AddAsset(new Guid(0x00004000, 0x026F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Strong eyebrows");
            AddAsset(new Guid(0x00004000, 0x0270, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Monobrow");
            AddAsset(new Guid(0x00004000, 0x0271, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bendy eyebrows");
            AddAsset(new Guid(0x00004000, 0x0272, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pointed eyebrows");
            AddAsset(new Guid(0x00004000, 0x0273, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Squared eyebrows");
            AddAsset(new Guid(0x00004000, 0x0274, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaved eyebrows");
            AddAsset(new Guid(0x00004000, 0x0275, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "No eyebrows");
            AddAsset(new Guid(0x00004000, 0x0276, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wing eyebrows");
            AddAsset(new Guid(0x00004000, 0x0277, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Huge eyebrows");
            AddAsset(new Guid(0x00004000, 0x0278, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pointy eyebrows");
            AddAsset(new Guid(0x00004000, 0x0279, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Center eyebrows");
            AddAsset(new Guid(0x00002000, 0x027A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Happy eyes");
            AddAsset(new Guid(0x00040000, 0x027B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 001");
            AddAsset(new Guid(0x00002000, 0x027C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sharp eyes");
            AddAsset(new Guid(0x00040000, 0x027D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 002");
            AddAsset(new Guid(0x00002000, 0x027E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Half moon eyes");
            AddAsset(new Guid(0x00040000, 0x027F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 003");
            AddAsset(new Guid(0x00002000, 0x0280, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Focussed eyes");
            AddAsset(new Guid(0x00040000, 0x0281, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 004");
            AddAsset(new Guid(0x00002000, 0x0282, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Harmless eyes");
            AddAsset(new Guid(0x00040000, 0x0283, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 005");
            AddAsset(new Guid(0x00002000, 0x0284, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Passive eyes");
            AddAsset(new Guid(0x00040000, 0x0285, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 006");
            AddAsset(new Guid(0x00002000, 0x0286, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Relaxed eyes");
            AddAsset(new Guid(0x00040000, 0x0287, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 007");
            AddAsset(new Guid(0x00002000, 0x0288, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surprised eyes");
            AddAsset(new Guid(0x00040000, 0x0289, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 008");
            AddAsset(new Guid(0x00002000, 0x028A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Soft lashes");
            AddAsset(new Guid(0x00040000, 0x028B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 009");
            AddAsset(new Guid(0x00002000, 0x028C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Restful eyes");
            AddAsset(new Guid(0x00040000, 0x028D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 010");
            AddAsset(new Guid(0x00002000, 0x028E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Monday morning eyes");
            AddAsset(new Guid(0x00040000, 0x028F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 011");
            AddAsset(new Guid(0x00002000, 0x0290, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bold eyes");
            AddAsset(new Guid(0x00040000, 0x0291, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 012");
            AddAsset(new Guid(0x00002000, 0x0292, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Soft eyes");
            AddAsset(new Guid(0x00040000, 0x0293, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 013");
            AddAsset(new Guid(0x00002000, 0x0294, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Funky eyes");
            AddAsset(new Guid(0x00040000, 0x0295, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 014");
            AddAsset(new Guid(0x00002000, 0x0296, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wild eyes");
            AddAsset(new Guid(0x00040000, 0x0297, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 015");
            AddAsset(new Guid(0x00002000, 0x0298, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Comforting eyes");
            AddAsset(new Guid(0x00040000, 0x0299, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 016");
            AddAsset(new Guid(0x00002000, 0x029A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Droopy eyes");
            AddAsset(new Guid(0x00040000, 0x029B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 017");
            AddAsset(new Guid(0x00002000, 0x029C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Content eyes");
            AddAsset(new Guid(0x00040000, 0x029D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 018");
            AddAsset(new Guid(0x00002000, 0x029E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slim eyes");
            AddAsset(new Guid(0x00040000, 0x029F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 019");
            AddAsset(new Guid(0x00002000, 0x02A0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Excited eyes");
            AddAsset(new Guid(0x00040000, 0x02A1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 020");
            AddAsset(new Guid(0x00002000, 0x02A2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eagle eyes");
            AddAsset(new Guid(0x00040000, 0x02A3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 021");
            AddAsset(new Guid(0x00002000, 0x02A4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Polite eyes");
            AddAsset(new Guid(0x00040000, 0x02A5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 022");
            AddAsset(new Guid(0x00002000, 0x02A6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Soothing");
            AddAsset(new Guid(0x00040000, 0x02A7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 023");
            AddAsset(new Guid(0x00002000, 0x02A8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Puppy eyes");
            AddAsset(new Guid(0x00040000, 0x02A9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 024");
            AddAsset(new Guid(0x00002000, 0x02AA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rounded eyes");
            AddAsset(new Guid(0x00040000, 0x02AB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 025");
            AddAsset(new Guid(0x00002000, 0x02AC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Strong eyes");
            AddAsset(new Guid(0x00040000, 0x02AD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 026");
            AddAsset(new Guid(0x00002000, 0x02AE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Boxed eyes");
            AddAsset(new Guid(0x00040000, 0x02AF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 027");
            AddAsset(new Guid(0x00002000, 0x02B0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Arc eyes");
            AddAsset(new Guid(0x00040000, 0x02B1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 028");
            AddAsset(new Guid(0x00002000, 0x02B2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Studious eyes");
            AddAsset(new Guid(0x00040000, 0x02B3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 029");
            AddAsset(new Guid(0x00002000, 0x02B4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tranquil eyes");
            AddAsset(new Guid(0x00040000, 0x02B5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 030");
            AddAsset(new Guid(0x00002000, 0x02B6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dark eyes");
            AddAsset(new Guid(0x00040000, 0x02B7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 031");
            AddAsset(new Guid(0x00002000, 0x02B8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dot eyes");
            AddAsset(new Guid(0x00040000, 0x02B9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 032");
            AddAsset(new Guid(0x00002000, 0x02BA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tilted eyes");
            AddAsset(new Guid(0x00040000, 0x02BB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 033");
            AddAsset(new Guid(0x00002000, 0x02BC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Delicate eyes");
            AddAsset(new Guid(0x00040000, 0x02BD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 034");
            AddAsset(new Guid(0x00002000, 0x02BE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Almond eyes");
            AddAsset(new Guid(0x00040000, 0x02BF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 035");
            AddAsset(new Guid(0x00002000, 0x02C0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wavy eyes");
            AddAsset(new Guid(0x00040000, 0x02C1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 036");
            AddAsset(new Guid(0x00002000, 0x02C2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thick lashed eyes");
            AddAsset(new Guid(0x00040000, 0x02C3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 037");
            AddAsset(new Guid(0x00002000, 0x02C4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wide awake eyes");
            AddAsset(new Guid(0x00040000, 0x02C5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 038");
            AddAsset(new Guid(0x00002000, 0x02C6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Calm eyes");
            AddAsset(new Guid(0x00040000, 0x02C7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 039");
            AddAsset(new Guid(0x00002000, 0x02C8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Slender eyes");
            AddAsset(new Guid(0x00040000, 0x02C9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 040");
            AddAsset(new Guid(0x00002000, 0x02CA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Kind eyes");
            AddAsset(new Guid(0x00040000, 0x02CB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 041");
            AddAsset(new Guid(0x00002000, 0x02CC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Drowsy eyes");
            AddAsset(new Guid(0x00040000, 0x02CD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 042");
            AddAsset(new Guid(0x00002000, 0x02CE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Acorn eyes");
            AddAsset(new Guid(0x00040000, 0x02CF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 043");
            AddAsset(new Guid(0x00002000, 0x02D0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sunset eyes");
            AddAsset(new Guid(0x00040000, 0x02D1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 044");
            AddAsset(new Guid(0x00002000, 0x02D2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Genial eyes");
            AddAsset(new Guid(0x00040000, 0x02D3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Eye shadow 045");
            AddAsset(new Guid(0x00010000, 0x02D4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jaw stubble");
            AddAsset(new Guid(0x00010000, 0x02D5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Beard");
            AddAsset(new Guid(0x00010000, 0x02D6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Square goatee");
            AddAsset(new Guid(0x00010000, 0x02D7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Split goatee");
            AddAsset(new Guid(0x00010000, 0x02D8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chin spike");
            AddAsset(new Guid(0x00010000, 0x02D9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Round moustache");
            AddAsset(new Guid(0x00010000, 0x02DA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wide moustache");
            AddAsset(new Guid(0x00010000, 0x02DB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Comb moustache");
            AddAsset(new Guid(0x00010000, 0x02DC, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Regal moustache");
            AddAsset(new Guid(0x00010000, 0x02DD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Master moustache");
            AddAsset(new Guid(0x00010000, 0x02DE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Mountainous moustache");
            AddAsset(new Guid(0x00010000, 0x02DF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rich moustache");
            AddAsset(new Guid(0x00010000, 0x02E0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Handlebar moustache");
            AddAsset(new Guid(0x00010000, 0x02E1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sideburns");
            AddAsset(new Guid(0x00010000, 0x02E2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin moustache");
            AddAsset(new Guid(0x00010000, 0x02E3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Trimmed moustache");
            AddAsset(new Guid(0x00010000, 0x02E4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Squared moustache");
            AddAsset(new Guid(0x00008000, 0x02E5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Puzzled mouth");
            AddAsset(new Guid(0x00008000, 0x02E6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gentle mouth");
            AddAsset(new Guid(0x00008000, 0x02E7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small and rounded mouth");
            AddAsset(new Guid(0x00008000, 0x02E8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Curvy mouth");
            AddAsset(new Guid(0x00008000, 0x02E9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Deep lips mouth");
            AddAsset(new Guid(0x00008000, 0x02EA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Smirk mouth");
            AddAsset(new Guid(0x00008000, 0x02EB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grin mouth");
            AddAsset(new Guid(0x00008000, 0x02EC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vibrant mouth");
            AddAsset(new Guid(0x00008000, 0x02ED, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Unhappy mouth");
            AddAsset(new Guid(0x00008000, 0x02EE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cheeky mouth");
            AddAsset(new Guid(0x00008000, 0x02EF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Lined mouth");
            AddAsset(new Guid(0x00008000, 0x02F0, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cute mouth");
            AddAsset(new Guid(0x00008000, 0x02F1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fearsome mouth");
            AddAsset(new Guid(0x00008000, 0x02F2, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight line");
            AddAsset(new Guid(0x00008000, 0x02F3, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Teethy mouth");
            AddAsset(new Guid(0x00008000, 0x02F4, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Full mouth");
            AddAsset(new Guid(0x00008000, 0x02F5, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Happy mouth");
            AddAsset(new Guid(0x00008000, 0x02F6, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Open mouth");
            AddAsset(new Guid(0x00008000, 0x02F7, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bunny mouth");
            AddAsset(new Guid(0x00008000, 0x02F8, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vampire mouth");
            AddAsset(new Guid(0x00008000, 0x02F9, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wide mouth");
            AddAsset(new Guid(0x00008000, 0x02FA, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small mouth");
            AddAsset(new Guid(0x00008000, 0x02FB, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Locked teeth mouth");
            AddAsset(new Guid(0x00008000, 0x02FC, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Glamor mouth");
            AddAsset(new Guid(0x00008000, 0x02FD, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thin lipped mouth");
            AddAsset(new Guid(0x00008000, 0x02FE, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Square mouth");
            AddAsset(new Guid(0x00008000, 0x02FF, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thick lipped mouth");
            AddAsset(new Guid(0x00020000, 0x0300, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Camo facepaint");
            AddAsset(new Guid(0x00020000, 0x0301, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Butterfly facepaint");
            AddAsset(new Guid(0x00020000, 0x0302, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tiger facepaint");
            AddAsset(new Guid(0x00020000, 0x0303, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skull facepaint");
            AddAsset(new Guid(0x00020000, 0x0304, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Heart");
            AddAsset(new Guid(0x00020000, 0x0305, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rosy cheeks");
            AddAsset(new Guid(0x00020000, 0x0306, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vertical stripes");
            AddAsset(new Guid(0x00020000, 0x0307, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Horizontal stripe");
            AddAsset(new Guid(0x00020000, 0x0308, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Paired lines");
            AddAsset(new Guid(0x00020000, 0x0309, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Freckles");
            AddAsset(new Guid(0x00020000, 0x030A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right cheek mole");
            AddAsset(new Guid(0x00020000, 0x030B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right cheekbone mole");
            AddAsset(new Guid(0x00020000, 0x030C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right chin mole");
            AddAsset(new Guid(0x00020000, 0x030D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left cheek mole");
            AddAsset(new Guid(0x00020000, 0x030E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left cheekbone mole");
            AddAsset(new Guid(0x00020000, 0x030F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left chin mole");
            AddAsset(new Guid(0x00020000, 0x0310, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Warrior scar");
            AddAsset(new Guid(0x00020000, 0x0311, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Right eye scar");
            AddAsset(new Guid(0x00020000, 0x0312, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cheerful wrinkles");
            AddAsset(new Guid(0x00020000, 0x0313, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Harsh wrinkles");
            AddAsset(new Guid(0x00020000, 0x0314, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tired wrinkles");
            AddAsset(new Guid(0x00020000, 0x0315, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Concerned wrinkles");
            AddAsset(new Guid(0x00020000, 0x0316, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Stressed wrinkles");
            AddAsset(new Guid(0x00020000, 0x0317, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Forehead wrinkles");
            AddAsset(new Guid(0x00020000, 0x0318, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "More wrinkles");
            AddAsset(new Guid(0x00020000, 0x0319, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Most wrinkles");
            AddAsset(new Guid(0x00100000, 0x031A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Large chin");
            AddAsset(new Guid(0x00100000, 0x031B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thin chin");
            AddAsset(new Guid(0x00100000, 0x031C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long chin");
            AddAsset(new Guid(0x00100000, 0x031D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chiseled chin");
            AddAsset(new Guid(0x00100000, 0x031E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rounded chin");
            AddAsset(new Guid(0x00100000, 0x031F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sharp chin");
            AddAsset(new Guid(0x00100000, 0x0320, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Square chin");
            AddAsset(new Guid(0x00100000, 0x0321, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small chin");
            AddAsset(new Guid(0x00100000, 0x0322, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wide chin");
            AddAsset(new Guid(0x00080000, 0x0323, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Defined nose");
            AddAsset(new Guid(0x00080000, 0x0324, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Boxer s nose");
            AddAsset(new Guid(0x00080000, 0x0325, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Curved nose");
            AddAsset(new Guid(0x00080000, 0x0326, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Drooped nose");
            AddAsset(new Guid(0x00080000, 0x0327, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Angled nose");
            AddAsset(new Guid(0x00080000, 0x0328, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hooked nose");
            AddAsset(new Guid(0x00080000, 0x0329, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bulbous nose");
            AddAsset(new Guid(0x00080000, 0x032A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Large nose");
            AddAsset(new Guid(0x00080000, 0x032B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sharp nose");
            AddAsset(new Guid(0x00080000, 0x032C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Perked nose");
            AddAsset(new Guid(0x00080000, 0x032D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Smooth nose");
            AddAsset(new Guid(0x00080000, 0x032E, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rounded nose");
            AddAsset(new Guid(0x00080000, 0x032F, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small nose");
            AddAsset(new Guid(0x00080000, 0x0330, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Straight nose");
            AddAsset(new Guid(0x00080000, 0x0331, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long nose");
            AddAsset(new Guid(0x00080000, 0x0332, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tiny nose");
            AddAsset(new Guid(0x00080000, 0x0333, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wide nose");
            AddAsset(new Guid(0x00080000, 0x0334, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Soft nose");
            AddAsset(new Guid(0x00200000, 0x0335, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fantasy ears");
            AddAsset(new Guid(0x00200000, 0x0336, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Butterfly ears");
            AddAsset(new Guid(0x00200000, 0x0337, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Round ears");
            AddAsset(new Guid(0x00200000, 0x0338, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Elven ears");
            AddAsset(new Guid(0x00200000, 0x0339, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long ears");
            AddAsset(new Guid(0x00200000, 0x033A, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Prominent ears");
            AddAsset(new Guid(0x00200000, 0x033B, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shaped ears");
            AddAsset(new Guid(0x00200000, 0x033C, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Small ears");
            AddAsset(new Guid(0x00200000, 0x033D, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Spiked ears");
            AddAsset(new Guid(0x01000000, 0x033F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female boombox tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0340, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female tennis skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0341, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male goth boots hiding template");
            AddAsset(new Guid(0x01000000, 0x0342, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pinstripe pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0343, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gothic long sleeved top hiding template");
            AddAsset(new Guid(0x01000000, 0x0344, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowboy boots hiding template");
            AddAsset(new Guid(0x01000000, 0x0345, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Green hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x0346, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal suit hiding template");
            AddAsset(new Guid(0x01000000, 0x0347, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0348, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Leopard print leggings hiding template");
            AddAsset(new Guid(0x01000000, 0x0349, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue full zip hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x034A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Twin set hiding template");
            AddAsset(new Guid(0x01000000, 0x034B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Daisy print dress hiding template");
            AddAsset(new Guid(0x01000000, 0x034C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dungarees hiding template");
            AddAsset(new Guid(0x01000000, 0x034D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flares hiding template");
            AddAsset(new Guid(0x01000000, 0x034E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Baggy jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x034F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jogging pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0350, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x0351, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tracksuit pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0352, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pencil skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0353, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer vest hiding template");
            AddAsset(new Guid(0x01000000, 0x0354, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female sport top hiding template");
            AddAsset(new Guid(0x01000000, 0x0355, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male sport top hiding template");
            AddAsset(new Guid(0x01000000, 0x0356, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Boots hiding template");
            AddAsset(new Guid(0x01000000, 0x0357, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s full zip jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0358, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "White xbox sneakers hiding template");
            AddAsset(new Guid(0x01000000, 0x0359, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Geek pants hiding template");
            AddAsset(new Guid(0x01000000, 0x035A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Camo pants hiding template");
            AddAsset(new Guid(0x01000000, 0x035B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Full zip hoodie with chain hiding template");
            AddAsset(new Guid(0x01000000, 0x035C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skinny fit jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x035D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Little black dress hiding template");
            AddAsset(new Guid(0x01000000, 0x035E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Metal combats hiding template");
            AddAsset(new Guid(0x01000000, 0x035F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s checked shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0360, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fitted blazer hiding template");
            AddAsset(new Guid(0x01000000, 0x0361, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Two button babydoll dress hiding template");
            AddAsset(new Guid(0x01000000, 0x0362, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Swim shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x0363, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Checked jacket with polo hiding template");
            AddAsset(new Guid(0x01000000, 0x0364, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Striped jacket with polo hiding template");
            AddAsset(new Guid(0x01000000, 0x0365, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0366, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sundress hiding template");
            AddAsset(new Guid(0x01000000, 0x0367, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pixie boots hiding template");
            AddAsset(new Guid(0x01000000, 0x0368, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Snowboarding jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0369, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pinstripe blazer hiding template");
            AddAsset(new Guid(0x01000000, 0x036A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High heel body modification template");
            AddAsset(new Guid(0x01000000, 0x036B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female leggings bottom template");
            AddAsset(new Guid(0x01000000, 0x036C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female medium skirt bottom template");
            AddAsset(new Guid(0x01000000, 0x036D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female trousers bottom template");
            AddAsset(new Guid(0x01000000, 0x036E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female long sleeved top template");
            AddAsset(new Guid(0x01000000, 0x036F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female short sleeved top template");
            AddAsset(new Guid(0x01000000, 0x0370, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female short sleeved v top template");
            AddAsset(new Guid(0x01000000, 0x0371, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male shorts bottom template");
            AddAsset(new Guid(0x01000000, 0x0372, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male trousers bottom template");
            AddAsset(new Guid(0x01000000, 0x0373, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male long sleeved top template");
            AddAsset(new Guid(0x01000000, 0x0374, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male long sleeved v top template");
            AddAsset(new Guid(0x01000000, 0x0375, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male short sleeved top template");
            AddAsset(new Guid(0x01000000, 0x0376, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male polo shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0377, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Strapless dress hiding template");
            AddAsset(new Guid(0x01000000, 0x0378, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dress with sash hiding template");
            AddAsset(new Guid(0x01000000, 0x0379, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "60 s dress hiding template");
            AddAsset(new Guid(0x01000000, 0x037A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Striped sundress hiding template");
            AddAsset(new Guid(0x01000000, 0x037B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Babydoll dress hiding template");
            AddAsset(new Guid(0x01000000, 0x037C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "60 s boots hiding template");
            AddAsset(new Guid(0x01000000, 0x037D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female goth boots hiding template");
            AddAsset(new Guid(0x01000000, 0x037E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tight tee hiding template");
            AddAsset(new Guid(0x01000000, 0x037F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tee with belt hiding template");
            AddAsset(new Guid(0x01000000, 0x0380, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cardigan with vest hiding template");
            AddAsset(new Guid(0x01000000, 0x0381, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Full zip hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x0382, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hacking jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0383, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0384, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Groovy shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0385, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Football tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0386, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Track jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0387, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Geek shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0388, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Turtleneck sweater hiding template");
            AddAsset(new Guid(0x01000000, 0x0389, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female crew neck sweater hiding template");
            AddAsset(new Guid(0x01000000, 0x038A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vest hiding template");
            AddAsset(new Guid(0x01000000, 0x038B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female polo shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x038C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Waistcoat with vest hiding template");
            AddAsset(new Guid(0x01000000, 0x038D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Wrap shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x038E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rockabilly dress hiding template");
            AddAsset(new Guid(0x01000000, 0x038F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sweater with shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0390, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Biker jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0391, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Layered jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0392, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0393, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk boots hiding template");
            AddAsset(new Guid(0x01000000, 0x0394, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Grunge trainers hiding template");
            AddAsset(new Guid(0x01000000, 0x0395, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Open neck cardigan hiding template");
            AddAsset(new Guid(0x01000000, 0x0396, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tropical shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0397, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x0398, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Glass tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0399, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Long sleeved tee hiding template");
            AddAsset(new Guid(0x01000000, 0x039A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Full zip tracksuit hiding template");
            AddAsset(new Guid(0x01000000, 0x039B, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tartan skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x039C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim shorts with thread hiding template");
            AddAsset(new Guid(0x01000000, 0x039D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Oversized jacket with chains hiding template");
            AddAsset(new Guid(0x01000000, 0x039E, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bright print tee hiding template");
            AddAsset(new Guid(0x01000000, 0x039F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "School jacket with polo hiding template");
            AddAsset(new Guid(0x01000000, 0x03A0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim jacket with tee hiding template");
            AddAsset(new Guid(0x01000000, 0x03A1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rain coat hiding template");
            AddAsset(new Guid(0x01000000, 0x03A2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Open neck sweater hiding template");
            AddAsset(new Guid(0x01000000, 0x03A3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Suit and tie hiding template");
            AddAsset(new Guid(0x01000000, 0x03A4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "School tie tee hiding template");
            AddAsset(new Guid(0x01000000, 0x03A5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chino shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03A6, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x03A7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black tuxedo hiding template");
            AddAsset(new Guid(0x01000000, 0x03A8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Tan formal suit hiding template");
            AddAsset(new Guid(0x01000000, 0x03A9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jogger hiding template");
            AddAsset(new Guid(0x01000000, 0x03AA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sweat bands hiding template");
            AddAsset(new Guid(0x01000000, 0x03AB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Embroidered pants hiding template");
            AddAsset(new Guid(0x01000000, 0x03AC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Stripy fingerless gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03AD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Yellow fingerless gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03AE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rockabilly top hiding template");
            AddAsset(new Guid(0x01000000, 0x03AF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black skinny fit jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x03B0, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Thread skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03B1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gold bracelet hiding template");
            AddAsset(new Guid(0x01000000, 0x03B2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jelly clogs hiding template");
            AddAsset(new Guid(0x01000000, 0x03B3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black and blue fingerless gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03B4, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dogtooth pattern skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03B5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Plimsolls hiding template");
            AddAsset(new Guid(0x01000000, 0x03B6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cargo shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03B7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Retro digital watch hiding template");
            AddAsset(new Guid(0x01000000, 0x03B8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pink glow bands hiding template");
            AddAsset(new Guid(0x01000000, 0x03B9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Gingham shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03BA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cans tee hiding template");
            AddAsset(new Guid(0x01000000, 0x03BB, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Snug boots hiding template");
            AddAsset(new Guid(0x01000000, 0x03BC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03BD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal shoes hiding template");
            AddAsset(new Guid(0x01000000, 0x03BE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Dark denim jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x03BF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rodeo jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x03C0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Moccasins hiding template");
            AddAsset(new Guid(0x00000004, 0x03C1, 0x0003, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Left parting  hat ");
            AddAsset(new Guid(0x00000100, 0x03C2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male shades");
            AddAsset(new Guid(0x00000100, 0x03C3, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female rimless glasses");
            AddAsset(new Guid(0x00000100, 0x03C4, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female red 60 s glasses");
            AddAsset(new Guid(0x00000040, 0x03C5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Trucker cap");
            AddAsset(new Guid(0x00000020, 0x03C6, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowgirl boots");
            AddAsset(new Guid(0x00000400, 0x03C7, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female gold heart earrings");
            AddAsset(new Guid(0x00000880, 0x03C8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Leather biker gloves");
            AddAsset(new Guid(0x00000880, 0x03C9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Driving gloves");
            AddAsset(new Guid(0x00000880, 0x03CA, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black and blue fingerless gloves");
            AddAsset(new Guid(0x00000880, 0x03CB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male white dress gloves");
            AddAsset(new Guid(0x00000880, 0x03CC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female white dress gloves");
            AddAsset(new Guid(0x00000008, 0x03CD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cans tee");
            AddAsset(new Guid(0x00000010, 0x03CF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male chequered shorts");
            AddAsset(new Guid(0x00000040, 0x03D1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pattern knit pull on");
            AddAsset(new Guid(0x00000008, 0x03D2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female knitted vest");
            AddAsset(new Guid(0x00000010, 0x03D3, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Denim skirt with leggings");
            AddAsset(new Guid(0x00000880, 0x03D4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Motocross gloves");
            AddAsset(new Guid(0x00000400, 0x03D6, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female scarlet teardrop earrings");
            AddAsset(new Guid(0x00000880, 0x03D7, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pink ski gloves");
            AddAsset(new Guid(0x00000020, 0x03D8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Socks and sandals");
            AddAsset(new Guid(0x00000008, 0x03D9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sports vest");
            AddAsset(new Guid(0x01000000, 0x03DC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Star pattern shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03DD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Crop top with sweat bands hiding template");
            AddAsset(new Guid(0x01000000, 0x03DE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Fingerless gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03DF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female chino shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03E0, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female short shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03E1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female knitted vest hiding template");
            AddAsset(new Guid(0x01000000, 0x03E2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Worn jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x03E3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "High school sports hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x03E4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "70 s leather platforms hiding template");
            AddAsset(new Guid(0x01000000, 0x03E5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Chequered shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03E6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Shirt with cummerbund hiding template");
            AddAsset(new Guid(0x01000000, 0x03E7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male rashguard hiding template");
            AddAsset(new Guid(0x01000000, 0x03E8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male snowboarding boots hiding template");
            AddAsset(new Guid(0x01000000, 0x03E9, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Flower print flares hiding template");
            AddAsset(new Guid(0x01000000, 0x03EA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowgirl boots hiding template");
            AddAsset(new Guid(0x01000000, 0x03EB, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Braces with high pants hiding template");
            AddAsset(new Guid(0x01000000, 0x03EC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Formal trouser suit hiding template");
            AddAsset(new Guid(0x01000000, 0x03ED, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Driving gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03EE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rainy day boots hiding template");
            AddAsset(new Guid(0x01000000, 0x03EF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Leggings with denim skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03F0, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Red formal shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03F1, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Leather biker gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x03F2, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Retro skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03F3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Winter jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x03F4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Turn up jeans hiding template");
            AddAsset(new Guid(0x01000000, 0x03F5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Bright sprite hoodie hiding template");
            AddAsset(new Guid(0x01000000, 0x03F6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male punk tee hiding template");
            AddAsset(new Guid(0x01000000, 0x03F7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Socks and sandals hiding template");
            AddAsset(new Guid(0x01000000, 0x03F8, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cowgirl shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x03F9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Lips tee hiding template");
            AddAsset(new Guid(0x01000000, 0x03FA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer shorts hiding template");
            AddAsset(new Guid(0x01000000, 0x03FB, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer hotpants hiding template");
            AddAsset(new Guid(0x01000000, 0x03FC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Snowboarding boots hiding template");
            AddAsset(new Guid(0x01000000, 0x03FD, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Western duster hiding template");
            AddAsset(new Guid(0x01000000, 0x03FE, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Black trench coat hiding template");
            AddAsset(new Guid(0x01000000, 0x03FF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female white dress gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0400, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rocker jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x0401, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Cheerleader dress hiding template");
            AddAsset(new Guid(0x01000000, 0x0402, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Motocross gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0403, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Popper pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0404, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Pleated dress hiding template");
            AddAsset(new Guid(0x01000000, 0x0405, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Woolly gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0406, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vintage snowdrop blouse hiding template");
            AddAsset(new Guid(0x01000000, 0x0407, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male white dress gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0408, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female ski gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0409, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Colorful polo shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x040A, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Sports vest hiding template");
            AddAsset(new Guid(0x01000000, 0x040B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Blue formal shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x040C, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "V neck top hiding template");
            AddAsset(new Guid(0x01000000, 0x040D, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jacket with tee hiding template");
            AddAsset(new Guid(0x01000000, 0x040E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Elegant ball gown hiding template");
            AddAsset(new Guid(0x01000000, 0x040F, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Surfer dress hiding template");
            AddAsset(new Guid(0x01000000, 0x0410, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female camo pants hiding template");
            AddAsset(new Guid(0x01000000, 0x0411, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female power tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0412, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male ski gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0413, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Punk jacket and tee hiding template");
            AddAsset(new Guid(0x01000000, 0x0414, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Skull wrist band hiding template");
            AddAsset(new Guid(0x01000000, 0x0415, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Biker gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0416, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Vest with straps hiding template");
            AddAsset(new Guid(0x01000000, 0x0417, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Rainbow gloves hiding template");
            AddAsset(new Guid(0x01000000, 0x0418, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "American football jersey hiding template");
            AddAsset(new Guid(0x01000000, 0x0419, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Baseball jersey hiding template");
            AddAsset(new Guid(0x01000000, 0x041A, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male white vest hiding template");
            AddAsset(new Guid(0x01000000, 0x041B, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male presenter jacket hiding template");
            AddAsset(new Guid(0x01000000, 0x041C, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Striped sweater with chain hiding template");
            AddAsset(new Guid(0x01000000, 0x041D, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female platform shoes hiding template");
            AddAsset(new Guid(0x01000000, 0x041E, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "V neck tee hiding template");
            AddAsset(new Guid(0x01000000, 0x041F, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Jacket with sweater hiding template");
            AddAsset(new Guid(0x01000000, 0x0420, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Polkadot skirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0421, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Waistcoat and shirt hiding template");
            AddAsset(new Guid(0x01000000, 0x0422, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Hiking shoes hiding template");
            AddAsset(new Guid(0x00000400, 0x04EC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female large hoop earrings");
            AddAsset(new Guid(0x00000400, 0x04ED, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female gold hoop earrings");
            AddAsset(new Guid(0x00000010, 0x04EE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female camo pants");
            AddAsset(new Guid(0x00000880, 0x04EF, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male ski gloves");
            AddAsset(new Guid(0x00000400, 0x04F0, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female right gold hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F1, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female right silver hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F2, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male right feather earring");
            AddAsset(new Guid(0x00000400, 0x04F3, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male right beaded earring");
            AddAsset(new Guid(0x00000400, 0x04F4, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male left gold hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F5, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male left silver hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F6, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male gold heart earrings");
            AddAsset(new Guid(0x00000400, 0x04F7, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male right gold hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F8, 0x0001, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Male right silver hoop earring");
            AddAsset(new Guid(0x00000400, 0x04F9, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female diamond stud earrings");
            AddAsset(new Guid(0x00000400, 0x04FA, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female gold stud earrings");
            AddAsset(new Guid(0x00000400, 0x04FB, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female silver stud earrings");
            AddAsset(new Guid(0x00000400, 0x04FC, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female left feather earring");
            AddAsset(new Guid(0x00000400, 0x04FD, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female punk studs");
            AddAsset(new Guid(0x00000400, 0x04FE, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female left beaded earring");
            AddAsset(new Guid(0x00000400, 0x04FF, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female silver hoop earrings");
            AddAsset(new Guid(0x00000400, 0x0500, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female right feather earring");
            AddAsset(new Guid(0x00000400, 0x0501, 0x0002, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0), "Female right beaded earring");
        }

        static public string LookupAssetName(Guid assetId)
        {
            string name;
            if (!assetsById.TryGetValue(assetId, out name))
            {
                name = string.Format("Unknown asset [{0}]", assetId);
            }

            return name;
        }

        static public Guid LookupAssetByName(string assetName)
        {
            Guid id;
            if (!assetsByName.TryGetValue(assetName, out id))
            {
                throw new ArgumentException(string.Format("Unknown asset [{0}]", assetName));
            }

            return id;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\CertificateCheck.cs ===
using System;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;



public enum CertStoreName
{
    MY,
    ROOT,
    TRUST,
    CA
}
public class CertStoreUtil
{
    const uint X509_ASN_ENCODING = 0x00000001;
    const int CERT_STORE_ADD_REPLACE_EXISTING = 3;

    #region P/Invoke Interop
    private static int CERT_STORE_PROV_SYSTEM = 10;
    //private static int CERT_SYSTEM_STORE_CURRENT_USER = (1 << 16);
    private static int CERT_SYSTEM_STORE_LOCAL_MACHINE = (2 << 16);

    [DllImport("CRYPT32", EntryPoint = "CertOpenStore", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern IntPtr CertOpenStore(int storeProvider, int encodingType, int hcryptProv, int flags, string pvPara);

    [DllImport("CRYPT32", EntryPoint = "CertEnumCertificatesInStore", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern IntPtr CertEnumCertificatesInStore(IntPtr storeProvider, IntPtr prevCertContext);

    [DllImport("CRYPT32", EntryPoint = "CertCloseStore", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern bool CertCloseStore(IntPtr storeProvider, int flags);

    [DllImport("CRYPT32", EntryPoint = "CertCreateCertificateContext", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr CertCreateCertificateContext(
        [In] uint dwCertEncodingType,
        [In] byte[] pbCertEncoded,
        [In] uint cbCertEncoded);

    [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    internal static extern bool CertAddCertificateContextToStore(
        [In] IntPtr hCertStore, 
        [In] IntPtr pCertContext, 
        [In] uint dwAddDisposition, 
        [In, Out] IntPtr ppStoreContext);
                        
    #endregion


    public string ComputerName { get; set; }

    private readonly bool isLocalMachine;
    public CertStoreUtil(string machineName)
    {
        ComputerName = machineName;
        if (machineName == string.Empty)
        {
            isLocalMachine = true;
        }
        else
        {
            isLocalMachine = string.Compare(ComputerName, Environment.MachineName, true) == 0 ? true : false;
        }
    }    
    
    public X509Certificate2Collection GetCertificates(CertStoreName storeName)
    {
        X509Certificate2Collection collectionToReturn = null;
        string givenStoreName = GetStoreName(storeName);

        if (givenStoreName == string.Empty)
        {
            throw new Exception("Invalid Store Name");
        }

        if (isLocalMachine)
        {
            X509Store store = new X509Store(givenStoreName, StoreLocation.LocalMachine);
            try
            {
                store.Open(OpenFlags.ReadOnly);
            }
            catch (Exception ex)
            {
                throw new Exception("Error opening certificate store", ex);
            }
            collectionToReturn = store.Certificates;
        }
        else
        {
            try
            {
                IntPtr storeHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, string.Format(@"\\{0}\{1}", ComputerName, givenStoreName));
                if (storeHandle == IntPtr.Zero)
                {
                    throw new Exception(string.Format("Cannot connect to remote machine: {0}", ComputerName));
                }

                IntPtr currentCertContext = IntPtr.Zero;
                collectionToReturn = new X509Certificate2Collection();
                do
                {
                    currentCertContext = CertEnumCertificatesInStore(storeHandle, currentCertContext);
                    if (currentCertContext != IntPtr.Zero)
                    {
                        collectionToReturn.Add(new X509Certificate2(currentCertContext));
                    }
                }
                while (currentCertContext != (IntPtr)0);

                CertCloseStore(storeHandle, 0);
            }
            catch (Exception ex)
            {
                throw new Exception("Error opening Certificate Store", ex);
            }
        }

        return collectionToReturn;
    }

    public X509Certificate2Collection GetCertificate(CertStoreName storeName, string findValue, X509FindType findtype)
    {
        string givenStoreName = GetStoreName(storeName);
        X509Certificate2Collection certsCollection = null;

        if (givenStoreName == string.Empty)
        {
            throw new Exception("Invalid Store Name");
        }

        if (isLocalMachine)
        {
            X509Store store = new X509Store(givenStoreName, StoreLocation.LocalMachine);
            store.Open(OpenFlags.ReadOnly);
            certsCollection = store.Certificates.Find(findtype, findValue, false);

            store.Close();
        }

        return certsCollection;
    }

    public bool addCertFromFile(CertStoreName storeName, X509Certificate2 cert)
    {

        string givenStoreName = GetStoreName(storeName);

        if (givenStoreName == string.Empty)
        {
            throw new Exception("Invalid Store Name");
        }

        if (isLocalMachine)
        {
            X509Store store = new X509Store(givenStoreName, StoreLocation.LocalMachine);
            try
            {
                store.Open(OpenFlags.ReadWrite);
            }
            catch (Exception ex)
            {
                throw new Exception("Error opening certificate store", ex);
            }

            //store is open, now open the certificate            
            store.Add(cert);
            store.Close();
            return true;
        }
        else
        {
            throw new Exception("Can not use this function to install on a remote machine. Use the remote version of this function");
        }
    }
    
    public bool addCertFromFile(CertStoreName storeName, string certFileFullPath)
    {
        
        string givenStoreName = GetStoreName(storeName);

        if (givenStoreName == string.Empty)
        {
            throw new Exception("Invalid Store Name");
        }

        
        try
        {
            IntPtr storeHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, string.Format(@"\\{0}\{1}", ComputerName, givenStoreName));
            if (storeHandle == IntPtr.Zero)
            {
                throw new Exception(string.Format("Cannot connect to remote machine: {0}", ComputerName));
            }                        
            //the store is now open, so grab the certfile
            FileInfo fileinfo = new FileInfo(certFileFullPath);
            BinaryReader br = new BinaryReader(fileinfo.OpenRead());
            byte[] Bytes = new byte[fileinfo.Length];
            br.Read(Bytes, 0, (int)fileinfo.Length);
            br.Close();               

            //create the certificate context from the byte stream
            IntPtr contextHandle = CertCreateCertificateContext(X509_ASN_ENCODING, Bytes, Convert.ToUInt32(Bytes.Length));

            if (contextHandle == IntPtr.Zero)
            {
                throw new Exception("unable to open create certificate context");
            }

            //now install it
            CertAddCertificateContextToStore(storeHandle, contextHandle, Convert.ToUInt32(CERT_STORE_ADD_REPLACE_EXISTING), IntPtr.Zero);

            //close the store
            CertCloseStore(storeHandle, 0);

            return true;
        }
        catch (Exception ex)
        {
            throw new Exception("Failed to install remote certificate with message: " + ex.Message.ToString());
        }    
    }

    private static string GetStoreName(CertStoreName certStoreName)
    {
        string storeName = string.Empty;
        switch (certStoreName)
        {
            case CertStoreName.MY:
                storeName = "My";
                break;

            case CertStoreName.ROOT:
                storeName = "Root";
                break;

            case CertStoreName.CA:
                storeName = "CA";
                break;

            case CertStoreName.TRUST:
                storeName = "Trust";
                break;
        }
        return storeName;
    }  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\CreditCardGenerator.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// This class provides properties to generate random credit card numbers
    /// </summary>
    public class CreditCardRandomizer
    {
        // not thread safe :(
        private static Random randomNumber = new Random();

        /// <summary>
        /// Static constructor - empty
        /// </summary>
        static CreditCardRandomizer()
        {
        }

        static public String Discover {    get    { return getRandomCC(6011, 16);    } }
        static public String Visa { get { return getRandomCC(4, 16); } }
        static public String MasterCard { get { return getRandomCC(51, 16); } }


        static public CreditCardInfoData GenerateVisaCard()
        {
            CreditCardInfoData cc = new CreditCardInfoData();
            cc.CardType = (byte)CreditCardInfoData.CreditCardType.Visa;
            cc.AccountHolderName = "John Smith";
            cc.AccountNumber = GetRandomAccountNumber("visa");
            cc.CcvNumber = "123";
            cc.ExpirationDate = DateTime.UtcNow.AddYears(2);

            return cc;
        }
        
        static public String AmericanExpress
        {
            get
            {

                Int32 prefix = 0;

                randomNumber.Next(1, 3);

                switch (randomNumber.Next(1, 3))
                {
                    case 1:
                        prefix = 34;
                        break;
                    case 2:
                        prefix = 37;
                        break;
                    default:
                        prefix = 34;
                        break;
                }

                return getRandomCC(prefix, 15);
            }
        }

        
        static public String Diners
        {
            get
            {
                Int32 prefix = 0;

                randomNumber.Next(1, 5);

                switch (randomNumber.Next(1, 5))
                {
                    case 1:
                        prefix = 30;
                        break;
                    case 2:
                        prefix = 36;
                        break;
                    case 3:
                        prefix = 38;
                        break;
                    case 4:
                        prefix = 39;
                        break;
                    default:
                        prefix = 30;
                        break;
                }

                return getRandomCC(prefix, 14);
            }
        }


        static public String KLCC
        {
            get
            {
                Int32 prefix = 0;

                randomNumber.Next(1, 5);

                switch (randomNumber.Next(1, 5))
                {
                    case 1:
                        prefix = 2;
                        break;
                    case 2:
                        prefix = 4;
                        break;
                    case 3:
                        prefix = 5;
                        break;
                    case 4:
                        prefix = 9;
                        break;
                    default:
                        prefix = 9;
                        break;
                }

                return getRandomCC(prefix, 16);
            }
        }


        static public String JCB
        {
            get
            {
                Int32 prefix = 0;

                prefix = randomNumber.Next(3528, 3589);

                return getRandomCC(prefix, 16);
            }
        }


        /// <summary>
        /// Returns a random credit card number for the type of card provided
        /// </summary>
        /// <param name="creditCardType">The credit card type. Can be American Express, Discover, JCB, Mastercard, or Visa. Tries to handle abbreviations and name variations (eg: AMEX). Defaults to Visa.</param>
        /// <returns>A random credit card number in string format</returns>
        static public String GetRandomAccountNumber(String creditCardType)
        {
            String accountNumber;

            creditCardType = creditCardType.ToLower();

            switch (creditCardType)
            {
                case "amex":
                case "americanexpress":
                case "american express":
                    accountNumber = AmericanExpress;
                    break;
                case "discover":
                    accountNumber = Discover;
                    break;
                case "jcb":
                    accountNumber = JCB;
                    break;
                case "mc":
                case "mastercard":
                case "master card":
                    accountNumber = MasterCard;
                    break;
                case "visa":
                    accountNumber = Visa;
                    break;
                case "diners":
                    accountNumber = Diners;
                    break;
                case "klcc":
                    accountNumber = KLCC;
                    break;
                default:
                    accountNumber = Visa;
                    break;
            }

            return accountNumber;
        }

        /// <summary>
        /// Constructs the actual random credit card number. All credit cards follow the same checksum, the only difference being the prefix and length of the number
        /// </summary>
        /// <param name="prefix">The prefix of the credit card type. For example, Visa cards start with a 4</param>
        /// <param name="length">The length of the credit card type. For example, Visa cards are all 16 digits in length</param>
        /// <returns>A random credit card number in string format</returns>
        static public String getRandomCC(Int32 prefix, Int32 length)
        {
            String accountString;
            Int32 sumOfAllDigits = 0;

            // Use the prefix if provided
            if (prefix == 0)
                accountString = String.Empty;
            else
                accountString = prefix.ToString();

            // Create a random string until the last digit ( reserved for checksum )
            while (accountString.Length < (length - 1))
            {
                accountString = accountString + randomNumber.Next(0, 9).ToString();
            }


            // Count up the string, 
            for (Int32 stringPosition = 0; stringPosition < accountString.Length; stringPosition++)
            {
                Int32 digit = Convert.ToInt32(accountString.Substring(stringPosition, 1));

                // Take the odd positions in the string and perform a checksum on them
                // Odd positions are the 1st, 3rd, 5th, etc., starting from the right
                // Even positioned numbers are used as is
                if (((accountString.Length - stringPosition) % 2) != 0)
                {
                    digit = digit * 2;

                    if (digit >= 10)
                        digit = digit - 9;
                }

                // Take the resulting number and sum it to the others.
                sumOfAllDigits = sumOfAllDigits + digit;
            }

            // Perform the checksum on the sum.
            sumOfAllDigits = (10 - (sumOfAllDigits % 10));

            if (sumOfAllDigits == 10)
                sumOfAllDigits = 0;

            // Append the checksum digit to the end of the string
            accountString = accountString + sumOfAllDigits.ToString();

            // Return the random credit card number
            return accountString;
        }
    }





    // ***************************************************************************************************
    // *
    // * DIRECTDEBITRANDOMIZER 
    // * 

    /// <summary>
    /// This class provides properties to generate random debit card numbers
    /// </summary>
    public class DirectDebitRandomizer
    {

        private String algorithm;
        private String accountNumber;
        private String accountNumberLastFour;
        private String bankCode;
        private String branchCode;
        private String checkDigits;
        private String country;
        private static Random randomizer = new Random();

        /// <summary>
        /// Default constructor - assumes Germany for the direct debit country
        /// </summary>
        public DirectDebitRandomizer() : this( "DE" )
        {
        }

        /// <summary>
        /// Uses the country provided to randomize on
        /// </summary>
        public DirectDebitRandomizer(String countryCode) : this(countryCode, "MOD11")
        {
        }

        /// <summary>
        /// Uses the country provided to randomize on
        /// </summary>
        public DirectDebitRandomizer(String countryCode, String alg)
        {
            this.algorithm = alg;
            this.accountNumber = String.Empty;
            this.accountNumberLastFour = String.Empty;
            this.bankCode = String.Empty;
            this.branchCode = String.Empty;
            this.checkDigits = String.Empty;
            Country = countryCode;
        }


        /// <summary>
        /// The account number of the direct debit account
        /// </summary>
        public String AccountNumber { get { return accountNumber; } set { accountNumber = value; } }

        /// <summary>
        /// The last four digits of the account number
        /// </summary>
        public String AccountNumberLastFour { get { return accountNumberLastFour; } set { accountNumberLastFour = value; } }

        /// <summary>
        /// The bank code of the direct debit account
        /// </summary>
        public String BankCode { get { return bankCode; } set { bankCode = value; } }

        /// <summary>
        /// The branch code of the direct debit account
        /// </summary>
        public String BranchCode { get { return branchCode; } set { branchCode = value; } }

        /// <summary>
        /// The checksum of the direct debit account
        /// </summary>
        public String CheckDigits { get { return checkDigits; } set { checkDigits = value; } }

        /// <summary>
        /// The country of the direct debit account
        /// </summary>
        public String Country
        {
            get
            {
                return country;
            }
            set
            {
                country = value;
                RandomizeDirectDebitValues();
            }
        }
        /// <summary>
        /// Alogrithm used to generate acct number
        /// </summary>
        public String Algorithm { get { return algorithm; } set { algorithm = value; } }

        /// <summary>
        /// Generates a random direct debit account number, bank code, branch code, etc.
        /// These values are in the various properties of this class and are synched with each other to provide a valid direct debit account.
        /// </summary>
        public void Randomize()
        {
            RandomizeDirectDebitValues();
        }

        /// <summary>
        /// Generates a random direct debit account number, bank code, branch code, etc.
        /// These values are in the various properties of this class and are synched with each other to provide a valid direct debit account.
        /// </summary>
        private void RandomizeDirectDebitValues()
        {
            switch (Country.ToUpper())
            {
                // Germany
                case "DE":
                    // Generate and assign random values
                    this.bankCode = String.Empty;
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000000) + 10000000).ToString();
                    this.accountNumber = System.Math.Floor((randomizer.NextDouble() * 9999999990) + 10).ToString();
                    this.checkDigits = String.Empty;

                    // Break out
                    break;

                // France
                case "FR":
                    // Generate and assign random values
                    this.bankCode = System.Math.Floor((randomizer.NextDouble() * 90000) + 10000).ToString();
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000) + 10000).ToString();
                    this.accountNumber = String.Empty;
                    this.checkDigits = String.Empty;

                    // French accounts have 2 to 11 alphanumeric characters for account numbers. This constructs one
                    for (Int16 i = 1; i <= randomizer.Next(2, 11); i++)
                    {
                        Int32 randomNumber = randomizer.Next(48, 83);
                        if (randomNumber >= 58)
                        {
                            randomNumber += 7;
                        }

                        this.accountNumber += Convert.ToChar(randomNumber).ToString();
                    }

                    // Construct the checksum for a French account
                    this.checkDigits = GetCheckDigitsForFranceAccount();

                    // Break out
                    break;

                // The United Kingdom
                case "GB":              
                    // Generate and assign random values
                    // Currently only generate 8-digit acct number and 6-digit branch code
                    this.bankCode = String.Empty;
                    GetGBAccount();
                    this.checkDigits = String.Empty;
                    break;

                // The catch all
                default:
                    // Generate and assign random values using Germany (DE) as the default (it's the easiest)
                    this.bankCode = String.Empty;
                    this.branchCode = System.Math.Floor((randomizer.NextDouble() * 90000000) + 10000000).ToString();
                    this.accountNumber = System.Math.Floor((randomizer.NextDouble() * 9999999990) + 10).ToString();
                    this.checkDigits = String.Empty;

                    // Break out
                    break;
            }
        }

        /// <summary>
        /// Returns the Check Digits value based on the algorithm for a French direct debit account.
        /// </summary>
        /// <returns></returns>
        private String GetCheckDigitsForFranceAccount()
        {
            // Build in the first half of the full account number
            String fullBankAccountNumber = this.BankCode + this.BranchCode;

            // Pad the full account number with zeros
            fullBankAccountNumber = fullBankAccountNumber.PadRight((21 - this.accountNumber.Length), '0');

            // Add the account number to the end
            fullBankAccountNumber += this.AccountNumber;

            // A string that will be the full numeric string, after conversion
            String bigChecksumString = String.Empty;

            // Loop through the full account number and convert to a numeric string
            for (Int16 i = 0; i <= (fullBankAccountNumber.Length - 1); i++)
            {
                // A specific character in the Full Account Number, each time through the loop
                Char specificChar = Convert.ToChar(fullBankAccountNumber.Substring(i, 1));

                // If a numeric, add to the string straight out
                if (specificChar <= 57)
                {
                    bigChecksumString += specificChar - 48;
                }
                // Letters A through I are 1 through 9 in order. Add the number
                else if (specificChar <= 73)
                {
                    bigChecksumString += specificChar - 64;
                }
                // Letters J through R are 1 through 9 in order. Add the number
                else if (specificChar <= 82)
                {
                    bigChecksumString += specificChar - 73;
                }
                // Letters S through Z are 2 through 9 in order. Add the number
                else if (specificChar <= 90)
                {
                    bigChecksumString += specificChar - 81;
                }
            }

            // Finally add two zeroes to the end of the big long String
            bigChecksumString += "00";

            // leftOver is what is left after each modulus of 97 as we move down the big checksum string
            String leftOver = String.Empty;

            // Move down the big checksum string
            for (Int16 i = 0; i <= (bigChecksumString.Length - 1); i++)
            {
                // Append the next number to what was left from the last operation
                leftOver += bigChecksumString.Substring(i, 1);

                // Take leftOver, convert it to a number to modulus it against 97, then convert the result back to a string
                leftOver = Convert.ToString(Convert.ToInt16(leftOver) % 97);
            }

            // Now that we are done, subtract leftOver from 97
            Int32 checksum = 97 - Convert.ToInt32(leftOver);

            // This is the value to be returned
            String returnValue = String.Empty;

            // the return value must be 2 digits, so may need a leading zero
            if (checksum < 10)
            {
                returnValue = "0" + checksum.ToString();
            }
            else
            {
                returnValue = checksum.ToString();
            }

            return returnValue;
        }

        private void GetGBAccount()
        {
            throw new Exception("Generation of GB debit cards is not supported at this time.");
            /*
             * This is more complex than it looks. The SCG guys have more code for randomizing GB debit cards.
             * Since we're not supporting this for Xenon launch I won't include it in here.
             */
            /*
            GBRandomizer rand = new GBRandomizer();
            GBAcctNum gbAcct = rand.GetGBAcct(this.algorithm);
            this.branchCode = gbAcct.BranchCode;
            this.accountNumber = gbAcct.AcctNum;
            */
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\Certificates.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
//using System.Security.Cryptography.X509Certificates;
using X509Certificate2 = System.Security.Cryptography.X509Certificates.X509Certificate2;
using X509Certificate2Collection = System.Security.Cryptography.X509Certificates.X509Certificate2Collection;
using ServerTestFramework.Database;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService.Auth.Asn;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.X509;
using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Security;
using Org.BouncyCastle.Crypto.Prng;
using Org.BouncyCastle.Asn1.X509;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Pkcs;
using Org.BouncyCastle.Asn1;


namespace ServerTestFramework.Utilities
{
    public class Certificates
    {
        private static bool certificatesInitialized = false;
        private static object installLock = new object();

        // Installs some certificates on the system
        public static void InstallCertificates()
        {
            lock (installLock)
            {
                if (!certificatesInitialized)
                {
                    Global.RO.Info("Installing certificates...");
                    if (!File.Exists("certimp.exe"))
                    {
                        ConsoleX.WriteLine(CC.YELLOW, "Certimp.exe is not in your path and certificates can not be installed.");
                    }
                    else
                    {
                        XmlNodeList certs = Global.Config.SelectNodes("/stf/config/certificates/*[@install='yes']");
                        if (certs != null)
                        {
                            foreach (XmlNode cert in certs)
                            {
                                CertificateEntry.CertType type = cert.Value == "pkcs12" ? CertificateEntry.CertType.PKCS12 : CertificateEntry.CertType.X509;
                                byte[] data = null;
                                string pass = "test2";

                                try
                                {
                                    data = Convert.FromBase64String(cert.InnerText);
                                    if (cert.Attributes["password"] != null)
                                        pass = cert.Attributes["password"].Value;
                                }
                                catch (Exception)
                                {
                                    Global.RO.Warn("Invalid certificate element found in xml.");
                                    continue;
                                }

                                string tempFileName = type == CertificateEntry.CertType.PKCS12 ? "temp.pfx" : "temp.cer";
                                FileStream fs = File.OpenWrite(tempFileName);
                                fs.Write(data, 0, data.Length);
                                fs.Close();

                                string arg = "certificate:" + tempFileName + " password:" + pass + " site:2";
                                ProcessStartInfo psi = new ProcessStartInfo("certimp.exe", arg);
                                psi.RedirectStandardOutput = true;
                                psi.RedirectStandardError = true;
                                psi.UseShellExecute = false;
                                psi.CreateNoWindow = true;
                                Process p = Process.Start(psi);
                                p.WaitForExit();

                                File.Delete(tempFileName);
                            }
                        }
                    }

                    certificatesInitialized = true;
                }
            }
        }

        public static void InstallClientCertificate(string certFile, string password)
        {
            InstallClientCertificate(new X509Certificate2(certFile, password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags.Exportable));
        }

        public static void InstallClientCertificate(X509Certificate2 certificate)
        {
            System.Security.Cryptography.X509Certificates.X509Store store = null;

            try
            {
                store = new System.Security.Cryptography.X509Certificates.X509Store(
                    System.Security.Cryptography.X509Certificates.StoreName.My,
                    System.Security.Cryptography.X509Certificates.StoreLocation.LocalMachine);
                store.Open(System.Security.Cryptography.X509Certificates.OpenFlags.ReadWrite);

                store.Add(certificate);
            }
            finally
            {
                if (store != null)
                {
                    store.Close();
                }
            }
        }

        /// <summary>
        /// Creates a certificate collection from the certificates stored in a PKCS7 (P7B) blob.
        /// </summary>
        /// <param name="pkcs7">The bytes of a PKCS7 package.</param>
        /// <returns>An X509CertificateCollection containing the certificates from the PKCS7 blob.</returns>
        public static X509Certificate2Collection OpenPKCS7 (byte[] pkcs7)
        {
            X509Certificate2Collection ans = new X509Certificate2Collection();

            // load the bytes into an ASN tree
            long parsedLength;
            Compound.AsnValueParser.ThrowOnBadAsn = false;
            AsnValueBase value = Compound.AsnValueParser.Parse(pkcs7, 0, pkcs7.Length, out parsedLength);

            if (value == null)
            {
                throw new CertificateException("Could not parse the PKCS7 blob.");
            }

            // verify expected format, which is:
            // sequence [
            //   oid 1.2.840.113549.1.7.2
            //   sequence
            //     [2] oid 1.2.840.113549.1.7.1
            //     [3] certs
            // ]
            Compound.ExplicitTagLengthValue etlv = null;
            Compound.Sequence seq = null;
            Compound.Sequence seq2 = null;
            Raw.Oid oid = null;

            seq = GetNextValue<Compound.Sequence>(value);
            if (seq == null || seq.Values == null || seq.Values.Length < 2) goto bad_format;

            oid = GetNextValue<Raw.Oid>(seq.Values[0]);
            if (oid == null || oid.ToString() != "1.2.840.113549.1.7.2") goto bad_format;

            etlv = seq.Values[1] as Compound.ExplicitTagLengthValue;
            if (etlv == null) goto bad_format;

            seq = etlv.Value as Compound.Sequence;
            if (seq == null || seq.Values == null || seq.Values.Length < 4) goto bad_format;

            seq2 = GetNextValue<Compound.Sequence>(seq.Values[2]);
            if (seq2 == null || seq2.Values == null || seq2.Values.Length < 1) goto bad_format;

            oid = GetNextValue<Raw.Oid>(seq2.Values[0]);
            if (oid == null || oid.ToString() != "1.2.840.113549.1.7.1") goto bad_format;

            seq2 = GetNextValue<Compound.Sequence>(seq.Values[3]);
            if (seq2 == null || seq2.Values == null) goto bad_format;

            // now pull the certificates out of the sequence
            foreach (AsnValueBase cert in seq2.Values)
            {
                ans.Add(new X509Certificate2(cert.GetBytes()));
            }

            return ans;

        bad_format:
            throw new CertificateException("PKCS7 blob is not expected format.  This is probably because we are wrong.");
        }

        // Gets the next value from the current one
        private static T GetNextValue<T> (AsnValueBase value) where T : AsnValueBase
        {
            Compound.TagLengthValue tlv = value as Compound.TagLengthValue;
            if (tlv == null) return null;

            return (tlv.Value as T);
        }

        public class CertificateException : Exception
        {
            public CertificateException (string message) : base(message) { }
        }
    }

    public class CertificateGenerator
    {
        public AsymmetricCipherKeyPair KeyPair { get; set; }
        public X509V3CertificateGenerator Generator { get; set; }

        public CertificateGenerator(String subject) : this(subject, 1024) { }

        public CertificateGenerator(String subject, Int32 keySize) : this(subject, 1024, true) { }

        public CertificateGenerator(String subject, Boolean addDefaultKeyUsage) : this(subject, 1024, addDefaultKeyUsage) { }

        public CertificateGenerator(String subject, Int32 keySize, Boolean addDefaultKeyUsage)
        {
            KeyPair = CreateKeyPair(keySize);
            Generator = CreateGenerator(subject, KeyPair);

            if (addDefaultKeyUsage)
            {
                SetKeyUsage();
                SetExtendedKeyUsage();
            }
        }

        public void SetSubjectName(String subject)
        {
            Generator.SetSubjectDN(new X509Name(subject));
        }

        /// <summary>
        /// Sets the key usage to a default set:
        ///     Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
        /// </summary>
        public void SetKeyUsage()
        {
            SetKeyUsage(KeyUsage.DigitalSignature | KeyUsage.NonRepudiation | KeyUsage.KeyEncipherment | KeyUsage.DataEncipherment);
        }
        
        public void SetKeyUsage(Int32 keyUsage)
        {
            Generator.AddExtension(X509Extensions.KeyUsage, true, new KeyUsage(keyUsage));
        }

        /// <summary>
        /// Set the default extened key usage flags: 
        ///     Server Auth, Client Auth
        /// </summary>
        public void SetExtendedKeyUsage()
        {
            //SetExtendedKeyUsage(KeyPurposeID.IdKPServerAuth, KeyPurposeID.IdKPClientAuth);
            Generator.AddExtension(X509Extensions.ExtendedKeyUsage.Id, false,
                new ExtendedKeyUsage(KeyPurposeID.IdKPServerAuth, KeyPurposeID.IdKPClientAuth));
        }

        /// <summary>
        /// Set the extended key usage to a specific set of key purposes
        /// </summary>
        /// <param name="keyPurposeIds">A list of key purpose ids for the key usage</param>
        /// <remarks>
        /// This method is not exposed, because if you try to call one of the other signatures
        /// even though you're not using the KeyPurposeID it still requires you to have a ref
        /// to the BouncyCastle assembly at compile time (maybe to resolve the correct method
        /// to call or something).  I might add this in later.
        /// </remarks>
        public void SetExtendedKeyUsage(params KeyPurposeID[] keyPurposeIds)
        {
            Generator.AddExtension(X509Extensions.ExtendedKeyUsage.Id, false,
                new ExtendedKeyUsage(keyPurposeIds));
        }

        /// <summary>
        /// Sets the Extended Key Usage to a set of custom purposes
        /// </summary>
        /// <param name="keyUsages"></param>
        public void SetExtendedKeyUsage(params String[] keyUsages)
        {
            Generator.AddExtension(X509Extensions.ExtendedKeyUsage, false,
                new ExtendedKeyUsage(keyUsages.Select(ku => new DerObjectIdentifier(ku))));
        }

        public void AddExtension(String oid, Boolean critical, String extensionValue)
        {
            AddExtension(oid, critical, new DerObjectIdentifier(extensionValue).GetDerEncoded());
        }

        public void AddExtension(String oid, Boolean critical, Byte[] extensionValue)
        {
            Generator.AddExtension(oid, critical, extensionValue);
        }

        public X509Certificate2 Generate()
        {
            return Generate("XSig Test Certificate");
        }

        public X509Certificate2 Generate(String friendlyName)
        {
            return ConvertToWindows(Generator.Generate(KeyPair.Private), KeyPair, friendlyName);
        }

        public X509Certificate2 Generate(String friendlyName, String issuerPath)
        {
            return Generate(friendlyName, issuerPath, "");
        }

        public X509Certificate2 Generate(String friendlyName, String issuerPath, String password)
        {
            using (FileStream issuerStream = File.OpenRead(issuerPath))
            {
                return Generate(friendlyName, issuerStream, password);
            }
        }

        public X509Certificate2 Generate(String friendlyName, Stream issuerCertStream, String password)
        {
            Pkcs12Store store = new Pkcs12Store();
            store.Load(issuerCertStream, password.ToCharArray());

            // There should only be one that we care about for now
            var alias = store.Aliases.OfType<String>().First();
            var cert = store.GetCertificate(alias);
            var privateKey = store.GetKey(alias).Key;

            Generator.SetIssuerDN(cert.Certificate.SubjectDN);
            //Generator.SetIssuerUniqueID(cert.Certificate.SubjectUniqueID.);

            return ConvertToWindows(Generator.Generate(privateKey), KeyPair, friendlyName);
        }

        public static AsymmetricCipherKeyPair CreateKeyPair(Int32 keySize)
        {
            RsaKeyPairGenerator keyGen = new RsaKeyPairGenerator();
            keyGen.Init(
                new KeyGenerationParameters(
                    new SecureRandom(new CryptoApiRandomGenerator()),
                    2048));

            return keyGen.GenerateKeyPair();
        }

        public static X509V3CertificateGenerator CreateGenerator(String subject, AsymmetricCipherKeyPair keyPair)
        {
            X509Name name = new X509Name(subject);

            X509V3CertificateGenerator gen = new X509V3CertificateGenerator();

            gen.SetSubjectDN(name);
            gen.SetIssuerDN(name);
            gen.SetSerialNumber(BigInteger.ProbablePrime(120, new Random()));
            gen.SetNotBefore(DateTime.UtcNow.AddDays(-1));
            gen.SetNotAfter(DateTime.UtcNow.AddYears(1));
            gen.SetSignatureAlgorithm("SHA1WithRSA");
            gen.SetPublicKey(keyPair.Public);

            return gen;
        }

        public static X509Certificate2 ConvertToWindows(Org.BouncyCastle.X509.X509Certificate newCert, AsymmetricCipherKeyPair kp, String friendlyName)
        {
            var tempStorePwd = "XblRocks!";

            var tempStore = new Pkcs12Store();
            var certEntry = new X509CertificateEntry(newCert);

            // Store the certificate and key in the temp store
            tempStore.SetCertificateEntry(friendlyName, certEntry);
            tempStore.SetKeyEntry(friendlyName, new AsymmetricKeyEntry(kp.Private), new[] { certEntry });

            // Write out the cert store to a memory stream
            using (var s = new MemoryStream())
            {
                tempStore.Save(s, tempStorePwd.ToCharArray(), new SecureRandom(new CryptoApiRandomGenerator()));

                // Then read the memory stream back into a .NET X509Certificate2
                return new X509Certificate2(s.GetBuffer(), tempStorePwd, 
                    System.Security.Cryptography.X509Certificates.X509KeyStorageFlags.Exportable);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\IDCRLUtilities.cs ===
using System;

using Microsoft.Passport.Test.Ppcrl;
using xonline.common.config;
using xonline.common.diagnostics;


namespace ServerTestFramework.Utilities
{

    public class IDCRLUtilities
    {
        static IDCRLUtilities()
        {
            Guid appGuid = new Guid("28880461-ed9b-4911-b691-474503c690e7");
            const int PPCRL_VERSION = 1;

            ManagedIDCRL.Initialize_Options[] initOps = new ManagedIDCRL.Initialize_Options[1];
            initOps[0].optionType = ManagedIDCRL.IDCRL_OPTION_ID.IDCRL_OPTION_ENVIRONMENT;
            initOps[0].proxyUserInfo = "int";

            _msidcrl = new ManagedIDCRL();
            _msidcrl.InitializeEx(ref appGuid, PPCRL_VERSION, (uint)ManagedIDCRL.UpdateFlag.DEFAULT_UPDATE_POLICY, initOps);
        }

        public static string GetRpsTicketToken(string user, string password, string partner, string policy)
        {
            //ManagedIDCRL.LogonState logonState;
            ManagedIDCRL.AuthState authState;
            int identity;

            _msidcrl.CreateIdentityHandle(user, (uint)ManagedIDCRL.IdentityFlag.IDENTITY_SHARE_ALL, out identity);
            _msidcrl.SetCredential(identity, ManagedIDCRL.PPCRL_CREDTYPE_PASSWORD, password);
            _msidcrl.LogonIdentity(identity, null, (uint)ManagedIDCRL.LogonFlag.LOGONIDENTITY_DEFAULT);
            _msidcrl.AuthIdentityToService(identity, partner, policy, (uint)ManagedIDCRL.ServiceTokenFlags.SERVICE_TOKEN_REQUEST_TYPE_NONE, out authState);

            return authState.Token;
        }

        public static string GetArgoTicket(string user, string password) 
        {
            return GetRpsTicketToken(user, password, Config.GetSetting(Setting.crux_passportSiteAddress), "HBI");
        }
        

        private static ManagedIDCRL _msidcrl = null;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\UserSetup.cs ===
using System;
using System.Collections;
using System.Threading;

using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserSettings;

namespace ServerTestFramework.LiveService.UserAccount
{
    public class UserSetup
	{
		#region private user title/achievement setup methods

		private static ushort c_MaxTitleForAchievments = 100;
		private static ushort c_MaxAchievementsPerTitle = 150;

		/// <summary>
		/// Makes call to the service to add a title to the list of played games for the given user.  Ignores
		/// titles that have already been played.
		/// </summary>
		/// <param name="puid">puid of the user</param>
		/// <param name="titleId">title played</param>
		/// <param name="localeID"></param>
		/// <returns>true if request to the service succeeds or if title already in list of played games</returns>
		private static bool UserPlayedGame(ulong puid, uint titleId, uint localeID)
		{
			// get sequence number
			uint sequenceNumber = 0;
			EnumTitlesRequest enumRequest = new EnumTitlesRequest(puid, puid, 0, c_MaxTitleForAchievments); 
			EnumTitlesResponse enumResponse = enumRequest.Execute();
			if (enumResponse.XError == 0)
			{
				for (int i=0; i<enumResponse.Titles.Length; i++)
				{
					if (sequenceNumber < enumResponse.Titles[i].Sequence)
						sequenceNumber = enumResponse.Titles[i].Sequence;

					if (enumResponse.Titles[i].TitleId == titleId)
						return true;	// user already played this title so exit
				}
			}
			else
			{
				throw new ApplicationException("Error happened while enumerating title (" + enumResponse.XError.ToString() +")");
			}

			ServerTestFramework.LiveService.UserSettings.UserTitle[] titlePlayed = new ServerTestFramework.LiveService.UserSettings.UserTitle[]
				{
					new ServerTestFramework.LiveService.UserSettings.UserTitle (
					titleId, 
					System.DateTime.UtcNow, 
					0,		// the service now ignores cred and achievement totals passed in to SyncTitles
					0, 
					sequenceNumber+1)
				};
			SyncTitlesRequest syncRequest = new SyncTitlesRequest(puid, (ushort)localeID, System.DateTime.UtcNow, titlePlayed);
			SyncTitlesResponse syncResponse = syncRequest.Execute();
			return (syncResponse.XError == 0);
		}

		/// <summary>
		/// Makes call to the service to add an achievement to list of earned achievements for the given user.  Ignores
		/// achievements that have already been earned.
		/// </summary>
		/// <param name="puid">puid of the user</param>
		/// <param name="titleID">title played</param>
		/// <param name="achievementId">id of the achievement earned</param>
		/// <param name="localeID"></param>
		/// <returns>true if request to the service succeeds or if achievement already earned</returns>
		private static bool UserEarnedAchievement(ulong puid, uint titleID, uint achievementId, uint localeID)
		{
			// get sequence number and flags/type
			uint sequenceNumber = 0;
			int achievementType = 0;
			int achievementFlags = 0;
			XRLEnumAchievement achievementRequest = new XRLEnumAchievement(titleID, puid, puid, (ushort)localeID, 0, c_MaxAchievementsPerTitle);
			AchievementEnumResponse achievementResponse = achievementRequest.Execute();
			if (0 == achievementResponse.xResult && achievementResponse.AchievementsLen > 0)
			{
				for (int i=0; i<achievementResponse.AchievementsLen; i++)
				{
					if (sequenceNumber < achievementResponse.Achievements[i].SortIndex)
						sequenceNumber = achievementResponse.Achievements[i].SortIndex;

					if (achievementResponse.Achievements[i].AchievementId == achievementId)
					{
						achievementType = achievementResponse.Achievements[i].Type;
						if (achievementType > 7 || achievementType < 1)
							achievementType = 1;

						achievementFlags = achievementResponse.Achievements[i].Flags;

						if ((int)(achievementFlags & 0x00030000) != 0)
							return true;	// user already earned this achievement so exit
					}
				}
			}
			else
			{
				throw new ApplicationException("Error happened while enumerating achievement (" + achievementResponse.xResult.ToString() +")");
			}

			AchievementWD[] achievementData = new AchievementWD[1];
			achievementData[0] = new AchievementWD(achievementId, sequenceNumber+1, achievementType);
			achievementData[0].Achieved = DateTime.UtcNow;
			achievementData[0].Flags = (int)(achievementFlags | 0x00030000);
			XRLSyncAchievements syncRequest = new XRLSyncAchievements(titleID, puid, achievementData, System.DateTime.UtcNow);
			SyncAchievementsResponse syncResponse = syncRequest.Execute();
			return (syncResponse.xResult == 0);
		}

		#endregion	// private user title/achievement setup methods

		#region public user title/achievement setup methods

		/// <summary>
		/// Returns details about titles played by the given user.
		/// </summary>
		/// <param name="puid">puid of user</param>
		/// <returns>array containing details of titles played by given user</returns>
		public static UserTitle[] GetPlayedTitles(ulong puid)
		{
			EnumTitlesRequest enumRequest = new EnumTitlesRequest(puid, puid, 0, c_MaxTitleForAchievments); 
			EnumTitlesResponse enumResponse = enumRequest.Execute();
			if (enumResponse.XError == 0)
			{
				return enumResponse.Titles;
			}
			else
			{
				return null;
			}

		}

		/// <summary>
		/// Adds the specified titles to the user's list of played titles.
		/// </summary>
		/// <param name="user">existing user</param>
		/// <param name="titleIds">array of title Ids</param>
		public static void AddPlayedTitles(ulong puid, uint [] titleIds)
		{
			// we don't want to add titles that have already been played to minimize calls to the service
			UserTitle[] playedTitles = GetPlayedTitles(puid);
			ArrayList unplayedTitles = new ArrayList();
			for (int i=0; i<titleIds.Length; i++)
			{
				bool played = false;
				for (int j=0; j<playedTitles.Length; j++)
					if (playedTitles[j].TitleId == titleIds[i])
					{
						played = true;
						break;
					}
				if (!played)
					unplayedTitles.Add(titleIds[i]);
			}

			for (int i=0; i<unplayedTitles.Count; i++)
			{
				if (i > 0)
					// wait a moment to ensure titles played have unique timestamps in database
					Thread.Sleep(500);

				// make the call to the service
				UserPlayedGame(puid,(uint)unplayedTitles[i],1033);
			}
		}

		/// <summary>
		/// Use this method to retrieve information about achievements for the given title.  Note that this
		/// is user-specific, but can be used to get the list of all achievement Ids (non-user specific) for
		/// the title by setting puid to any valid user.
		/// </summary>
		/// <param name="puid">puid of user</param>
		/// <param name="titleID">titleId</param>
		/// <returns>array containing the achievement details for a given titleId and user</returns>
		public static AchievementWD[] GetAchievementDetails(ulong puid, uint titleID)
		{
			XRLEnumAchievement achievementRequest = new XRLEnumAchievement(titleID, puid, puid, 1033, 0, c_MaxAchievementsPerTitle);
			AchievementEnumResponse response = achievementRequest.Execute();
			if(0 == response.xResult)
			{
				return response.Achievements;
			}
			else
			{
                AchievementWD[] emptyArray = new AchievementWD[]{};
				return emptyArray;
			}
		}

		/// <summary>
		/// Updates the given user with earned achievements for the given title.  Use GetAchievementDetails() to
		/// obtain a list of achievementIds available for a title.
		/// </summary>
		/// <param name="puid">puid of user</param>
		/// <param name="titleId">titleId</param>
		/// <param name="achievementIds">array of achievement Ids</param>
		public static void AddEarnedAchievements(ulong puid, uint titleId, uint [] achievementIds)
		{
			// we don't want to make extra calls to the service, so weed out any achievements that have already been earned
			AchievementWD[] achList = GetAchievementDetails(puid,titleId);
			ArrayList unearned = new ArrayList();
			for (int i=0; i<achievementIds.Length; i++)
			{
				bool earned = false;
				for (int j=0; j<achList.Length; j++)
					if (achList[j].AchievementId == achievementIds[i] &&
						(int)(achList[j].Flags & 0x00030000) != 0)
					{
						earned = true;
						break;
					}
				if (!earned)
					unearned.Add(achievementIds[i]);
			}

			for (int i=0; i<unearned.Count; i++)
			{
				if (i > 0)
					// wait a moment to ensure earned achievements have unique timestamps in database
					Thread.Sleep(500);

				// make the call to the service
				UserEarnedAchievement(puid,titleId,(uint)unearned[i],1033);
			}
		}

		#endregion	// public user title/achievement setup methods

		#region private user management methods

		/// <summary>
		/// Send a request to the service to update a user's privileges
		/// </summary>
		/// <param name="userPuid">puid of the user</param>
		/// <param name="privs">privileges to set</param>
		/// <param name="restrictPrivs">privileges to restrict</param>
		private static void ExecutePrivilegeUpdate(ulong userPuid, ulong userPassportPuid, ulong ownerPassportPuid, byte[] ownerSessionToken, UserPrivileges privs, UserPrivileges restrictPrivs)
		{
			XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
			request.UserPuid = userPuid;
			request.Source = "xboxcomtest"; // this is the grantor of the priv (for auditing)
			request.UserGrantPrivileges = privs.ToArray();
			request.UserRestrictPrivileges = restrictPrivs.ToArray();
			request.ManualPopulateSlot();
			request.Slot.wBuildNumber = 5529; // a build number AFTER 2006 spring release
			request.Slot.wMajorVersion = 2;
			request.Slot.wMinorVersion = 0;

                        if (userPassportPuid != ownerPassportPuid)
                        {
                            PassportToken pst = new PassportToken();
                            pst.signedPuid = ownerSessionToken;
                            request.tokenLength = 1;
                            request.Tokens = new PassportToken[] { pst };
                        }

			if (!request.Execute())
				throw new Exception("Error updating permissions for child account: " + request.GetDumpString());
			if (request.XErr != HResult.S_OK)
				throw new Exception(String.Format("XeUpdateParentalControlsTests returned XErr=0x{0:x}", request.XErr));
		}

		#endregion	// private user management methods

		#region public user management methods

		/// <summary>
		/// Update the user with web activity to avoid redirection to account creation when signing in to xbox.com site
		/// </summary>
		/// <param name="user"></param>
		public static void UpdateWithWebActivity(XeUser user)
		{
			// this sets the dt_last_web_activity object so we're not redirected to account creation after signing in to passport
			XRLXeUpdateXboxComActivity request = new XRLXeUpdateXboxComActivity();
			request.UserPuid = user.UserPuid;
			request.Execute();
		}

		/// <summary>
		/// Update a child account with least restrictive permissions.
		/// </summary>
		/// <param name="user">child account</param>
		public static void GrantPermissionsForChildAcct(XeUser user)
		{
			// turn on all the bits
			UserPrivileges privs = new UserPrivileges(true);
			UserPrivileges restrictPrivs = new UserPrivileges(false);
			ExecutePrivilegeUpdate(user.UserPuid, user.PassportUserPuid, user.PassportOwnerPuid, user.PassportOwnerSessionToken, privs,restrictPrivs);
		}

		/// <summary>
		/// Updates a user's privacy settings only with the specified allow/restrict lists - all other privileges will remain at the current setting
		/// </summary>
		/// <param name="user">an existing account</param>
		/// <param name="privsToSet">list of privileges to set to true/allow (privileges are defined as: XONLINE_XPRIVILEGE_...)</param>
		/// <param name="privsToRestrict">list of privileges to set to false/restrict (privileges are defined as: XONLINE_XPRIVILEGE_...)</param>
		public static void UpdatePrivileges(XeUser user, ArrayList privsToSet, ArrayList privsToRestrict)
		{
            UpdatePrivileges(user.UserPuid, user.PassportUserPuid, user.PassportOwnerPuid, user.PassportOwnerSessionToken, privsToSet, privsToRestrict);
		}

		/// <summary>
		/// Updates a user's privacy settings only with the specified allow/restrict lists - all other privileges will remain at the current setting
		/// </summary>
		/// <param name="user">an existing account</param>
		/// <param name="privsToSet">list of privileges to set to true/allow (privileges are defined as: XONLINE_XPRIVILEGE_...)</param>
		/// <param name="privsToRestrict">list of privileges to set to false/restrict (privileges are defined as: XONLINE_XPRIVILEGE_...)</param>
		public static void UpdatePrivileges(Owner owner, ArrayList privsToSet, ArrayList privsToRestrict)
		{
            UpdatePrivileges(owner.UserPuid, 0, 0, null,  privsToSet, privsToRestrict);
		}

		internal static void UpdatePrivileges(UInt64 userPuid, UInt64 userPassportPuid, UInt64 ownerPassportPuid, byte[] ownerPassportSessionToken, ArrayList privsToSet, ArrayList privsToRestrict)
		{
			// get user's current privileges
			UserPrivileges privs = new UserPrivileges(false);
			UserPrivileges restrictPrivs = new UserPrivileges(false);

			// update the privileges
			foreach (int privToSet in privsToSet)
				privs.SetPrivilege(privToSet,true);
			foreach (int privToRestrict in privsToRestrict)
				restrictPrivs.SetPrivilege(privToRestrict,true);

			// make the request to the service
			ExecutePrivilegeUpdate(userPuid, userPassportPuid, ownerPassportPuid, ownerPassportSessionToken, privs,restrictPrivs);
		}

		#endregion	// public user management methods

		#region private user creation methods

		/// <summary>
		/// Create the user based on XeUser information
		/// </summary>
		/// <param name="user"></param>
		private static void Create(XeUser user, string PassportMemberNameOfParent, string PassportPasswordOfParent)
		{
			if (user.PassportMemberName != null && user.PassportMemberName != "")
			{
				// get session token
                byte[] sessionToken = UacsCommon.XePassportLogin(user.PassportMemberName, user.PassportPassword);
				user.PassportSessionToken = sessionToken;

				if (user.PassportOwnerPuid != user.PassportUserPuid)
				{
                    byte[] sessionToken2 = UacsCommon.XePassportLogin(PassportMemberNameOfParent, PassportPasswordOfParent);
					user.PassportOwnerSessionToken = sessionToken2;
				}
				else
					user.PassportOwnerSessionToken = sessionToken;
			}

			// create user
			ulong puid = user.Create();
			if (puid == 0)
			{
				// creating user failed
				throw new Exception("Error creating user account: "+user.Gamertag);					
			}
		}

		/// <summary>
		/// Set up XeUser object and make call to create the user based on params submitted from the public methods
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="PassportMemberName">username of this user's passport account</param>
		/// <param name="PassportPassword">password of this user's passport account</param>
		/// <param name="PassportPuid">puid of this user's passport account</param>
		/// <param name="PassportMemberNameOfParent">username of parent's passport account</param>
		/// <param name="PassportPasswordOfParent">password of parent's passport account</param>
		/// <param name="PassportPuidOfParent">if this is NOT a child account this should be equal to PassportPuid, otherwise this is the puid of the parent's passport account</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		private static XeUser CreateXbox360Account(string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, string PassportMemberNameOfParent, string PassportPasswordOfParent, ulong PassportPuidOfParent, bool MarkWithWebActivity, bool Gold, DateTime BirthDate)
		{
			XeUser user = new XeUser();

			// check to see if we need to autogenerate gamertag
			if (Gamertag == null)
			{
				// check to see if we need to create a passport account
				if (PassportMemberName == null)
				{
					user = new XeUser(true);
				}
				else
				{
					user = new XeUser(false);
					user.PassportMemberName = PassportMemberName;
					user.PassportPassword = PassportPassword;
					user.PassportUserPuid = PassportPuid;
					user.PassportOwnerPuid = PassportPuidOfParent;
				}
				user.UserPuid = 0;
			}
			else
			{
				// check to see if we need to create a passport account
				if (PassportMemberName == null)
				{
					user = new XeUser(true,Gamertag);
				}
				else
				{
					user = new XeUser(false,Gamertag);
					user.PassportMemberName = PassportMemberName;
					user.PassportPassword = PassportPassword;
					user.PassportUserPuid = PassportPuid;
					user.PassportOwnerPuid = PassportPuidOfParent;
				}
				user.UserPuid = UodbWS.GetUserIDFromGamerTag(user.Gamertag);
			}

			// set the user's age (important for child accounts)
			user.BirthDate = BirthDate;

			// upgrade to gold account if requested
			user.CreateAsGold = Gold;

			// only create user if gamertag does not exist in uodb already
			if (user.UserPuid == 0)
				Create(user,PassportMemberNameOfParent,PassportPasswordOfParent);

			// mark with web activity
			if (MarkWithWebActivity)
				UpdateWithWebActivity(user);

			return user;
        }

        /// <summary>
        /// Set up XeUser object and make call to create the user based on params submitted from the public methods
        /// </summary>
        /// <param name="Gamertag">the desired gamertag for this user</param>
        /// <param name="PassportMemberName">username of this user's passport account</param>
        /// <param name="PassportPassword">password of this user's passport account</param>
        /// <param name="PassportPuid">puid of this user's passport account</param>
        /// <param name="PassportMemberNameOfParent">username of parent's passport account</param>
        /// <param name="PassportPasswordOfParent">password of parent's passport account</param>
        /// <param name="PassportPuidOfParent">puid of the parent's passport account</param>
        /// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
        /// <param name="Gold">true if you want to upgrade this user to a gold account</param>
        /// <returns>null if failure, or XeUser with info filled out if success</returns>
        private static XeUser CreateXbox360ChildAccount (string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, string PassportMemberNameOfParent, string PassportPasswordOfParent, ulong PassportPuidOfParent, bool MarkWithWebActivity, bool Gold, DateTime BirthDate)
        {
            XeUser user;

            // If true one needs to be created, handled with first param of XeUser constructor
            if (PassportMemberName == null)
            {
                if (Gamertag == null) { user = new XeUser(true); }
                else { user = new XeUser(true, Gamertag); }
            }
            // We already have a passport, so just set the values we are given
            else
            {
                if (Gamertag == null) { user = new XeUser(false); }
                else { user = new XeUser(false, Gamertag); }

                user.PassportMemberName = PassportMemberName;
                user.PassportPassword = PassportPassword;
                user.PassportUserPuid = PassportPuid;
                user.PassportOwnerPuid = PassportPuidOfParent;
            }

            user.BirthDate = BirthDate;
            user.CreateAsGold = Gold;

            // Only create user if gamertag does not exist in uodb already
            if (user.UserPuid == 0)
            {
                XeUser parent = new XeUser();
                parent.PassportUserPuid = PassportPuidOfParent;

                ulong puid = user.CreateMinor(parent, true);

                // Check for a bad user creation
                if (puid == 0)
                {
                    throw new Exception("Error creating user account: "+user.Gamertag);
                }
            }

            if (MarkWithWebActivity)
                UpdateWithWebActivity(user);

            return user;
        }

		#endregion	// private user creation methods

		#region public ADULT user creation methods

		/// <summary>
		/// Create a brand new SILVER account marked with web activity
		/// </summary>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User()
		{
			return CreateXbox360Account(null,null,null,0,null,null,0,true,false,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Create a brand new SILVER account with specified web activity
		/// </summary>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(bool MarkWithWebActivity)
		{
			return CreateXbox360Account(null,null,null,0,null,null,0,MarkWithWebActivity,false,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Create a brand new account with specified web activity and gold/silver status
		/// </summary>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(bool MarkWithWebActivity, bool Gold)
		{
			return CreateXbox360Account(null,null,null,0,null,null,0,MarkWithWebActivity,Gold,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Create a brand new SILVER account with specified gamertag marked with web activity
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(string Gamertag)
		{
			return CreateXbox360Account(Gamertag,null,null,0,null,null,0,true,false,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Create a brand new SILVER account with specified gamertag and web activity
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(string Gamertag, bool MarkWithWebActivity)
		{
			return CreateXbox360Account(Gamertag,null,null,0,null,null,0,MarkWithWebActivity,false,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Create a brand new account with specified gamertag, web activity, and gold/silver status
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(string Gamertag, bool MarkWithWebActivity, bool Gold)
		{
			return CreateXbox360Account(Gamertag,null,null,0,null,null,0,MarkWithWebActivity,Gold,DateTime.UtcNow.AddYears(-30));
		}

		/// <summary>
		/// Creates an account with specified gamertag, passport, web activity, and gold/silver status
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="PassportMemberName">username of this user's passport account</param>
		/// <param name="PassportPassword">password of this user's passport account</param>
		/// <param name="PassportPuid">puid of this user's passport account</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360User(string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, bool MarkWithWebActivity, bool Gold)
		{
			return CreateXbox360Account(Gamertag,PassportMemberName,PassportPassword,PassportPuid,null,null,PassportPuid,MarkWithWebActivity,Gold,DateTime.UtcNow.AddYears(-30));
		}

		#endregion	// public ADULT user creation methods

		#region public CHILD user creation methods

		/// <summary>
		/// Creates a brand new SILVER child account (age 15) marked with web activity
		/// </summary>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child ()
		{
			return CreateXbox360Child(null, null, null, 0, null, null, 0, true, false, 15);
		}

		/// <summary>
		/// Creates a brand new SILVER child account marked with web activity and with the specified age
		/// </summary>
		/// <param name="Age">child's age</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (int Age)
		{
			return CreateXbox360Child(null, null, null, 0, null, null, 0, true, false, Age);
		}

		/// <summary>
		/// Creates a brand new child account (age 15) with specified web activity and gold/silver status
		/// </summary>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (bool MarkWithWebActivity, bool Gold)
		{
			return CreateXbox360Child(null, null, null, 0, null, null, 0, MarkWithWebActivity, Gold, 15);
		}

		/// <summary>
		/// Creates a brand new child account with specified web activity, gold/silver status, and age
		/// </summary>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <param name="Age">child's age</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (bool MarkWithWebActivity, bool Gold, int Age)
		{
			return CreateXbox360Child(null, null, null, 0, null, null, 0, MarkWithWebActivity, Gold, Age);
		}

		/// <summary>
		/// Creates a child account (age 15) with specified gamertag, passport, web activity, and gold/silver status
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="PassportMemberName">username of this user's passport account</param>
		/// <param name="PassportPassword">password of this user's passport account</param>
		/// <param name="PassportPuid">puid of this user's passport account</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, bool MarkWithWebActivity, bool Gold)
		{
			return CreateXbox360Child(Gamertag, PassportMemberName, PassportPassword, PassportPuid, null, null, 0, MarkWithWebActivity, Gold, 15);
		}

		/// <summary>
		/// Creates a child account with specified gamertag, passport, web activity, gold/silver status, and age
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="PassportMemberName">username of this user's passport account</param>
		/// <param name="PassportPassword">password of this user's passport account</param>
		/// <param name="PassportPuid">puid of this user's passport account</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Age">child's age</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, bool MarkWithWebActivity, bool Gold, int Age)
		{
			return CreateXbox360Child(Gamertag, PassportMemberName, PassportPassword, PassportPuid, null, null, 0, MarkWithWebActivity, Gold, Age);
		}

		/// <summary>
		/// Creates a child account with specified gamertag, passport, parent's passport, web activity, gold/silver status, and age
		/// </summary>
		/// <param name="Gamertag">the desired gamertag for this user</param>
		/// <param name="PassportMemberName">username of this user's passport account</param>
		/// <param name="PassportPassword">password of this user's passport account</param>
		/// <param name="PassportPuid">puid of this user's passport account</param>
		/// <param name="PassportMemberNameOfParent">username of the parent's passport account</param>
		/// <param name="PassportPasswordOfParent">password of the parent's passport account</param>
		/// <param name="PassportPuidOfParent">puid of the parent's passport account</param>
		/// <param name="MarkWithWebActivity">true if you want this user marked as having visited the site to avoid account creation</param>
		/// <param name="Gold">true if you want to upgrade this user to a gold account</param>
		/// <param name="Age">child's age</param>
		/// <returns>null if failure, or XeUser with info filled out if success</returns>
		public static XeUser CreateXbox360Child (string Gamertag, string PassportMemberName, string PassportPassword, ulong PassportPuid, string PassportMemberNameOfParent, string PassportPasswordOfParent, ulong PassportPuidOfParent, bool MarkWithWebActivity, bool Gold, int Age)
		{
			if (PassportPuidOfParent == 0)
			{
				// create parent's passport account
				UacsCommon uc = new UacsCommon();
				UacsCommon.PassportUser passportUser = uc.CreatePassportUser();
				PassportMemberNameOfParent = passportUser.MemberName;
				PassportPasswordOfParent = passportUser.Password;
				PassportPuidOfParent = passportUser.PassportPuid;
			}

			return CreateXbox360ChildAccount(Gamertag, PassportMemberName, PassportPassword, PassportPuid, PassportMemberNameOfParent, PassportPasswordOfParent, PassportPuidOfParent, MarkWithWebActivity, Gold, DateTime.UtcNow.AddYears(-Age));
		}

		#endregion	// public CHILD user creation methods

		#region public friends setup methods

		/// <summary>
		/// Makes friends of two users
		/// </summary>
		/// <param name="requestor">The user sending the friend request</param>
		/// <param name="friend">The user accepting the friend request</param>
		public static void MakeFriend (XeUser requestor, XeUser friend)
		{
            MakeFriend(requestor.Gamertag, requestor.UserPuid, friend.Gamertag, friend.UserPuid);
		}

		/// <summary>
		/// Makes friends of two users
		/// </summary>
		/// <param name="requestor">The user sending the friend request</param>
		/// <param name="friend">The user accepting the friend request</param>
		public static void MakeFriend (XeUser requestor, Owner friend)
		{
            MakeFriend(requestor.Gamertag, requestor.UserPuid, friend.gamertag, friend.UserPuid);
		}
        
		internal static void MakeFriend (string gamerTag1, UInt64 userPuid1, string gamerTag2, UInt64 userPuid2)
		{
			// Friends management is handled through FriendsCommon...
			FriendsCommon FC = new FriendsCommon ();

			// ... but only works with PNUsers
			PNUser pnRequestor = new PNUser (gamerTag1, userPuid1);
			PNUser pnFriend = new PNUser (gamerTag2, userPuid2);

			// Time for some magic...
			FC.MakeFriend (pnRequestor, pnFriend);
		}
        
		#endregion	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\drm.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.IO;
using System.Web;
using System.Data;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Threading;

//using xonline.common.billing;
//using xonline.common.config;
//using xonline.common.crypto;
//using xonline.common.diagnostics;
//using xonline.common.offer;
//using xonline.common.service;
//using xonline.common.sql.webstore;
//using xonline.common.user;
//using xonline.common.mgmt;
//using xonline.common.protocol;

//using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Utilities
{
    #region Older P/Invoke Crypto API Stuff
    // Handles the signing of signatures 
    public class SignatureUtil
    {
        private static volatile SignatureUtil _global = null;

        public static SignatureUtil Global
        {
            get
            {
                if (_global == null)
                {
                    lock (typeof(SignatureUtil))
                    {
                        if (_global == null)
                        {
                            SignatureUtil clu = new SignatureUtil();
                            clu.Init();
                            // Install test pub key, and NCipher assets pub key
                            clu.InstallDrmNCipherKeyPubSig();
                            clu.InstallTestDrmKeyPubSig();
                            clu.InstallAssetNCipherKeyPubSig();
                            // actually the OpenContainer (open Pub/Private key pair) will do nothing, but will leave them here for now
                            clu._rsaDrm.OpenContainer(CryptoKey.NCIPHER_PROV, CryptoKey.DrmKeyContainer, true); // nCipher for Drm container
                            clu._rsaAssets.OpenContainer(CryptoKey.NCIPHER_PROV, CryptoKey.AssetKeyContainer, true);  // nCipher for Assets container
                            clu._rsaDrmTest.OpenContainer(CryptoKey.MS_ENHANCED_PROV, CryptoKey.DrmTestKeyContainer, true); // test key for both Drm and Asset

                            _global = clu;
                        }
                    }
                }

                return _global;
            }
        }

        // Init, always use testKey, not NCipher
        public void Init()
        {
            _rsaDrm = new CryptoKey();
            _rsaAssets = new CryptoKey();
            _rsaDrmTest = new CryptoKey();
        }

        // Install the Test Key (Public and Private key pair)
        public void NotUse_InstallTestDrmKey()
        {
            /*
        
            This is the format of the key bytes below.
        
            KEY_HEADER:
                BYTE    bType;                  // PRIVATEKEYBLOB = 0x07
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PRIV_MAGIC = 0x52,0x53,0x41,0x32 (0x32415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x03,0x00,0x00,0x00
            MODULUS DATA FOLLOWS
        
            */

            // this key can be used for signing/verifying signatures
            byte[] testDrmKeyPrvSig = new byte[1172]
            {
                0x07,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
                0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
                0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
                0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
                0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
                0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
                0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
                0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
                0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
                0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
                0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
                0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
                0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
                0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
                0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
                0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
                0xeb,0x62,0xff,0xb5,0x7b,0xed,0x1b,0x19, 0xdf,0x3f,0x0e,0x5b,0xe2,0xba,0x0b,0x5a,
                0x9b,0x04,0x7e,0xae,0xe7,0x4f,0x8e,0xdb, 0x20,0x6e,0xac,0x03,0x49,0x83,0x54,0x23,
                0x18,0xdd,0xec,0xbc,0x3b,0x2f,0x39,0x7d, 0xa7,0x1e,0xdf,0x47,0xca,0x84,0xbf,0x2b,
                0x6a,0x11,0x51,0xa6,0x2d,0xf4,0xca,0x2b, 0x1e,0xf6,0x0c,0xcd,0x6c,0xa8,0x5c,0x84,
                0x45,0x0e,0x53,0x26,0xb0,0x85,0x01,0xb9, 0x9b,0x67,0x2f,0x4f,0x83,0x9d,0x1e,0xea,
                0xcc,0xff,0x66,0x77,0x27,0x9f,0x22,0x07, 0x1a,0xa8,0xff,0x0e,0x3d,0x3a,0x06,0x33,
                0xd2,0x81,0x91,0x9e,0x09,0x0f,0xe0,0x0d, 0xd3,0x1b,0x9a,0x76,0x17,0x04,0x6c,0x7c,
                0x5f,0x54,0xfc,0x4a,0x9c,0xa1,0x38,0x4e, 0x79,0xbb,0x9c,0xa9,0xd6,0xd7,0x20,0x35,
                0x6d,0x17,0xb7,0xea,0x5f,0x4b,0xb3,0x61, 0xed,0x8d,0xeb,0x8b,0xcf,0xf7,0x4f,0xb6,
                0xa5,0xc7,0x05,0x50,0xad,0x00,0x6d,0xb7, 0xf0,0xea,0xa6,0x9e,0xc5,0xa8,0xf2,0xae,
                0x19,0x3f,0xfd,0xbc,0xa9,0xf1,0x2f,0x8d, 0x18,0x3a,0xcf,0xfa,0x25,0xe0,0x04,0x47,
                0xf2,0xab,0xfd,0xb4,0x9b,0x0d,0x9b,0xa6, 0xb0,0x65,0x0d,0x4a,0xc0,0x2d,0xaa,0x29,
                0xce,0xe6,0x17,0xfd,0xdf,0xcc,0x87,0x38, 0xe9,0xd7,0xc7,0xf8,0x4b,0xbe,0xcb,0xe6,
                0x8e,0xc8,0xec,0x39,0xf1,0x4c,0x03,0xb2, 0xb6,0x06,0xd9,0x38,0x47,0xee,0x0d,0xac,
                0x51,0x5e,0xfe,0xc8,0xe7,0x5e,0xd2,0xb0, 0xcd,0x26,0x89,0xfb,0xd2,0x23,0xae,0xcb,
                0xfd,0xec,0x9a,0x16,0x4c,0x04,0xfe,0x8e, 0x7b,0xe1,0x50,0xf3,0x8e,0x4b,0xc5,0xb5,
                0xfb,0x74,0x80,0xc6,0xa7,0xf3,0x67,0xbb, 0x94,0x2a,0xb4,0x3c,0xec,0xd1,0x07,0x3c,
                0x12,0x03,0x54,0x74,0x9a,0x8a,0x09,0x3d, 0x6b,0x49,0xc8,0x57,0xdb,0xac,0x8d,0x17,
                0x10,0x3e,0xf3,0x7d,0xd2,0x74,0x7b,0x53, 0x1a,0xbf,0x94,0xda,0x86,0x58,0x2a,0x1d,
                0x9c,0x0b,0x36,0xc4,0x73,0x4d,0x87,0x72, 0x69,0xf9,0x5d,0x33,0xf3,0x1a,0x93,0xad,
                0x83,0x09,0xe2,0x6e,0x75,0xae,0xab,0xd0, 0x67,0x9a,0x1f,0x8a,0x57,0xbe,0x69,0xf1,
                0xdd,0xff,0x99,0x4f,0x1a,0x6a,0x6c,0xaf, 0x66,0xc5,0xff,0x09,0x7e,0xd1,0xae,0xcc,
                0x36,0x01,0x61,0x14,0xb1,0xb4,0xea,0xb3, 0x8c,0x12,0xbc,0xf9,0x64,0xad,0xf2,0x52,
                0xea,0xe2,0x52,0x87,0xbd,0x6b,0xd0,0xde, 0x50,0xd2,0xbd,0x1b,0x8f,0x3a,0x6b,0x23,
                0x9e,0x0f,0x7a,0x9c,0x3f,0x32,0x22,0x41, 0x9e,0x5e,0xf2,0x07,0x35,0xa5,0x8a,0x79,
                0x6e,0xda,0x03,0xe0,0xc8,0x55,0xf3,0x24, 0x4b,0x47,0x6f,0x14,0xd9,0xc5,0xa1,0x74,
                0x66,0x7f,0x53,0xd3,0x1b,0xa1,0xca,0x08, 0xbb,0x26,0x8a,0xfc,0xc3,0xea,0xad,0x84,
                0xa1,0x72,0xfe,0xcd,0x67,0x5e,0x67,0xc4, 0x75,0xee,0x08,0xdc,0x2a,0xc9,0xc6,0x1b,
                0x34,0xef,0x0f,0xfe,0x3f,0x33,0x05,0x7b, 0x9b,0x3a,0x85,0x50,0xdd,0x7e,0x32,0xef,
                0x09,0xdb,0x9d,0x26,0xf6,0xdd,0xac,0x76, 0x24,0xaf,0x90,0xd0,0x84,0x49,0x09,0xc8,
                0x8b,0xe9,0xfe,0x85,0x9a,0x94,0xe1,0x75, 0xde,0x19,0x06,0xfd,0xe1,0x17,0x74,0x32,
                0xa9,0x48,0x67,0x64,0xdd,0x02,0x54,0x5f, 0x52,0x96,0xe0,0x4c,0x5f,0x32,0x2e,0x79,
                0x52,0xa3,0x55,0x84,0x8d,0xd8,0xd0,0x92, 0x37,0xc7,0xa5,0xa5,0x24,0x47,0x8f,0x27,
                0x4e,0x3c,0xd0,0x2b,0x9e,0xfd,0xd8,0x4c, 0xfe,0x2c,0x31,0x6e,0x8e,0x33,0xd2,0x41,
                0xc4,0xe4,0xed,0xa3,0x35,0x09,0xff,0xb5, 0x47,0xad,0x83,0x5e,0x15,0x4e,0xd3,0x33,
                0xdc,0xb8,0x61,0x58,0x66,0xa8,0x10,0x21, 0x1c,0x66,0x8e,0x7a,0xf8,0xfb,0xa5,0x0b,
                0x82,0xda,0xc2,0x61,0xa8,0xa9,0x33,0xf5, 0xf8,0x1b,0x28,0x3b,0xef,0xd5,0xd9,0x04,
                0x86,0xe1,0xa7,0xe0,0x92,0xc7,0x78,0x1a, 0xc9,0x13,0xcb,0xea,0x15,0xe8,0xcc,0xb4,
                0xbb,0x2b,0xd5,0x3d,0x3d,0x54,0xbc,0x4c, 0xca,0x63,0xa3,0x72,0x49,0x7f,0x0c,0x05,
                0xb5,0xdd,0x12,0x2b,0x0a,0x83,0x5c,0x78, 0xc4,0x1a,0x96,0x0a,0x7f,0xa9,0x29,0x19,
                0xf4,0x79,0xfe,0x5b,0x33,0x4b,0xc1,0xc8, 0xd1,0xff,0x65,0xc7,0xb3,0xa3,0xfe,0x69,
                0xbd,0x03,0x7a,0x23,0xf1,0x3d,0x7b,0xd4, 0xc0,0x5b,0x93,0x2c,0x59,0xfe,0xd6,0x60,
                0xde,0x0c,0xf6,0x78,0x84,0x6c,0x47,0x3d, 0xe4,0x48,0x3d,0x54,0x70,0xff,0x19,0x5a,
                0xe4,0xfc,0x7a,0x68,0xbd,0x9c,0xe4,0x09, 0x47,0x48,0x08,0x1e,0x61,0xb7,0x44,0xb8,
                0x83,0x13,0xf7,0xd4,0xa2,0x13,0x6b,0x1a, 0xaa,0x2b,0x7a,0xac,0x31,0xbe,0x41,0xfa,
                0x36,0xd4,0x4b,0x28,0xf5,0xee,0x6e,0xa6, 0x57,0xac,0xcb,0x77,0xea,0x5b,0x70,0xed,
                0xbe,0x7a,0xb4,0x7e,0x12,0x99,0x5d,0x90, 0xac,0x74,0x6f,0x0e,0x39,0x8e,0xd0,0xe7,
                0x50,0x45,0x1e,0xf3,0x87,0x3a,0x3d,0x84, 0xfb,0x2b,0x73,0x67,0x75,0x35,0x0d,0x10,
                0x94,0xa5,0x7f,0xfa,0xdd,0x6d,0xb5,0x75, 0x3d,0xec,0x01,0xa5,0x4f,0x66,0x26,0xd4,
                0xdf,0x10,0xae,0xa8,0x93,0xe3,0xca,0x45, 0xf8,0x60,0x4a,0x57,0xc6,0xa3,0xb6,0x60,
                0x52,0xfc,0x33,0x1a,0x21,0xcb,0xf9,0xc0, 0x04,0xd5,0xc0,0x93,0xe4,0xe0,0x3d,0x29,
                0x0b,0x69,0xe4,0x53,0x22,0x50,0x3c,0xab, 0x9f,0x49,0xc5,0x3d,0x78,0x3e,0x27,0x21,
                0x92,0xeb,0x36,0xed,0xaa,0x9a,0x2e,0x65, 0x1c,0xa4,0xfd,0x09,0xff,0x71,0x22,0xbb,
                0x54,0xa7,0x7d,0x49,0xf4,0xec,0x1a,0xf5, 0xc5,0x65,0xf0,0xa5,0x4f,0xd3,0xdb,0x32,
                0x57,0xfa,0x01,0x64,0x84,0xb0,0xe5,0xde, 0x02,0x8f,0x90,0x4f,0x80,0xdc,0xc0,0x75,
                0xe3,0x23,0x2a,0x6a,0xad,0xbd,0x5e,0x04, 0x44,0x4f,0x6b,0x3e,0x29,0x82,0x52,0x48,
                0x9d,0xec,0x54,0x79 };

            // this key can be used for encrypting/decrypting
            byte[] testDrmKeyPrvEnc = new byte[1172]
            {
                0x07,0x02,0x00,0x00,0x00,0xA4,0x00,0x00, 0x52,0x53,0x41,0x32,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
                0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
                0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
                0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
                0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
                0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
                0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
                0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
                0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
                0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
                0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
                0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
                0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
                0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
                0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
                0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
                0xeb,0x62,0xff,0xb5,0x7b,0xed,0x1b,0x19, 0xdf,0x3f,0x0e,0x5b,0xe2,0xba,0x0b,0x5a,
                0x9b,0x04,0x7e,0xae,0xe7,0x4f,0x8e,0xdb, 0x20,0x6e,0xac,0x03,0x49,0x83,0x54,0x23,
                0x18,0xdd,0xec,0xbc,0x3b,0x2f,0x39,0x7d, 0xa7,0x1e,0xdf,0x47,0xca,0x84,0xbf,0x2b,
                0x6a,0x11,0x51,0xa6,0x2d,0xf4,0xca,0x2b, 0x1e,0xf6,0x0c,0xcd,0x6c,0xa8,0x5c,0x84,
                0x45,0x0e,0x53,0x26,0xb0,0x85,0x01,0xb9, 0x9b,0x67,0x2f,0x4f,0x83,0x9d,0x1e,0xea,
                0xcc,0xff,0x66,0x77,0x27,0x9f,0x22,0x07, 0x1a,0xa8,0xff,0x0e,0x3d,0x3a,0x06,0x33,
                0xd2,0x81,0x91,0x9e,0x09,0x0f,0xe0,0x0d, 0xd3,0x1b,0x9a,0x76,0x17,0x04,0x6c,0x7c,
                0x5f,0x54,0xfc,0x4a,0x9c,0xa1,0x38,0x4e, 0x79,0xbb,0x9c,0xa9,0xd6,0xd7,0x20,0x35,
                0x6d,0x17,0xb7,0xea,0x5f,0x4b,0xb3,0x61, 0xed,0x8d,0xeb,0x8b,0xcf,0xf7,0x4f,0xb6,
                0xa5,0xc7,0x05,0x50,0xad,0x00,0x6d,0xb7, 0xf0,0xea,0xa6,0x9e,0xc5,0xa8,0xf2,0xae,
                0x19,0x3f,0xfd,0xbc,0xa9,0xf1,0x2f,0x8d, 0x18,0x3a,0xcf,0xfa,0x25,0xe0,0x04,0x47,
                0xf2,0xab,0xfd,0xb4,0x9b,0x0d,0x9b,0xa6, 0xb0,0x65,0x0d,0x4a,0xc0,0x2d,0xaa,0x29,
                0xce,0xe6,0x17,0xfd,0xdf,0xcc,0x87,0x38, 0xe9,0xd7,0xc7,0xf8,0x4b,0xbe,0xcb,0xe6,
                0x8e,0xc8,0xec,0x39,0xf1,0x4c,0x03,0xb2, 0xb6,0x06,0xd9,0x38,0x47,0xee,0x0d,0xac,
                0x51,0x5e,0xfe,0xc8,0xe7,0x5e,0xd2,0xb0, 0xcd,0x26,0x89,0xfb,0xd2,0x23,0xae,0xcb,
                0xfd,0xec,0x9a,0x16,0x4c,0x04,0xfe,0x8e, 0x7b,0xe1,0x50,0xf3,0x8e,0x4b,0xc5,0xb5,
                0xfb,0x74,0x80,0xc6,0xa7,0xf3,0x67,0xbb, 0x94,0x2a,0xb4,0x3c,0xec,0xd1,0x07,0x3c,
                0x12,0x03,0x54,0x74,0x9a,0x8a,0x09,0x3d, 0x6b,0x49,0xc8,0x57,0xdb,0xac,0x8d,0x17,
                0x10,0x3e,0xf3,0x7d,0xd2,0x74,0x7b,0x53, 0x1a,0xbf,0x94,0xda,0x86,0x58,0x2a,0x1d,
                0x9c,0x0b,0x36,0xc4,0x73,0x4d,0x87,0x72, 0x69,0xf9,0x5d,0x33,0xf3,0x1a,0x93,0xad,
                0x83,0x09,0xe2,0x6e,0x75,0xae,0xab,0xd0, 0x67,0x9a,0x1f,0x8a,0x57,0xbe,0x69,0xf1,
                0xdd,0xff,0x99,0x4f,0x1a,0x6a,0x6c,0xaf, 0x66,0xc5,0xff,0x09,0x7e,0xd1,0xae,0xcc,
                0x36,0x01,0x61,0x14,0xb1,0xb4,0xea,0xb3, 0x8c,0x12,0xbc,0xf9,0x64,0xad,0xf2,0x52,
                0xea,0xe2,0x52,0x87,0xbd,0x6b,0xd0,0xde, 0x50,0xd2,0xbd,0x1b,0x8f,0x3a,0x6b,0x23,
                0x9e,0x0f,0x7a,0x9c,0x3f,0x32,0x22,0x41, 0x9e,0x5e,0xf2,0x07,0x35,0xa5,0x8a,0x79,
                0x6e,0xda,0x03,0xe0,0xc8,0x55,0xf3,0x24, 0x4b,0x47,0x6f,0x14,0xd9,0xc5,0xa1,0x74,
                0x66,0x7f,0x53,0xd3,0x1b,0xa1,0xca,0x08, 0xbb,0x26,0x8a,0xfc,0xc3,0xea,0xad,0x84,
                0xa1,0x72,0xfe,0xcd,0x67,0x5e,0x67,0xc4, 0x75,0xee,0x08,0xdc,0x2a,0xc9,0xc6,0x1b,
                0x34,0xef,0x0f,0xfe,0x3f,0x33,0x05,0x7b, 0x9b,0x3a,0x85,0x50,0xdd,0x7e,0x32,0xef,
                0x09,0xdb,0x9d,0x26,0xf6,0xdd,0xac,0x76, 0x24,0xaf,0x90,0xd0,0x84,0x49,0x09,0xc8,
                0x8b,0xe9,0xfe,0x85,0x9a,0x94,0xe1,0x75, 0xde,0x19,0x06,0xfd,0xe1,0x17,0x74,0x32,
                0xa9,0x48,0x67,0x64,0xdd,0x02,0x54,0x5f, 0x52,0x96,0xe0,0x4c,0x5f,0x32,0x2e,0x79,
                0x52,0xa3,0x55,0x84,0x8d,0xd8,0xd0,0x92, 0x37,0xc7,0xa5,0xa5,0x24,0x47,0x8f,0x27,
                0x4e,0x3c,0xd0,0x2b,0x9e,0xfd,0xd8,0x4c, 0xfe,0x2c,0x31,0x6e,0x8e,0x33,0xd2,0x41,
                0xc4,0xe4,0xed,0xa3,0x35,0x09,0xff,0xb5, 0x47,0xad,0x83,0x5e,0x15,0x4e,0xd3,0x33,
                0xdc,0xb8,0x61,0x58,0x66,0xa8,0x10,0x21, 0x1c,0x66,0x8e,0x7a,0xf8,0xfb,0xa5,0x0b,
                0x82,0xda,0xc2,0x61,0xa8,0xa9,0x33,0xf5, 0xf8,0x1b,0x28,0x3b,0xef,0xd5,0xd9,0x04,
                0x86,0xe1,0xa7,0xe0,0x92,0xc7,0x78,0x1a, 0xc9,0x13,0xcb,0xea,0x15,0xe8,0xcc,0xb4,
                0xbb,0x2b,0xd5,0x3d,0x3d,0x54,0xbc,0x4c, 0xca,0x63,0xa3,0x72,0x49,0x7f,0x0c,0x05,
                0xb5,0xdd,0x12,0x2b,0x0a,0x83,0x5c,0x78, 0xc4,0x1a,0x96,0x0a,0x7f,0xa9,0x29,0x19,
                0xf4,0x79,0xfe,0x5b,0x33,0x4b,0xc1,0xc8, 0xd1,0xff,0x65,0xc7,0xb3,0xa3,0xfe,0x69,
                0xbd,0x03,0x7a,0x23,0xf1,0x3d,0x7b,0xd4, 0xc0,0x5b,0x93,0x2c,0x59,0xfe,0xd6,0x60,
                0xde,0x0c,0xf6,0x78,0x84,0x6c,0x47,0x3d, 0xe4,0x48,0x3d,0x54,0x70,0xff,0x19,0x5a,
                0xe4,0xfc,0x7a,0x68,0xbd,0x9c,0xe4,0x09, 0x47,0x48,0x08,0x1e,0x61,0xb7,0x44,0xb8,
                0x83,0x13,0xf7,0xd4,0xa2,0x13,0x6b,0x1a, 0xaa,0x2b,0x7a,0xac,0x31,0xbe,0x41,0xfa,
                0x36,0xd4,0x4b,0x28,0xf5,0xee,0x6e,0xa6, 0x57,0xac,0xcb,0x77,0xea,0x5b,0x70,0xed,
                0xbe,0x7a,0xb4,0x7e,0x12,0x99,0x5d,0x90, 0xac,0x74,0x6f,0x0e,0x39,0x8e,0xd0,0xe7,
                0x50,0x45,0x1e,0xf3,0x87,0x3a,0x3d,0x84, 0xfb,0x2b,0x73,0x67,0x75,0x35,0x0d,0x10,
                0x94,0xa5,0x7f,0xfa,0xdd,0x6d,0xb5,0x75, 0x3d,0xec,0x01,0xa5,0x4f,0x66,0x26,0xd4,
                0xdf,0x10,0xae,0xa8,0x93,0xe3,0xca,0x45, 0xf8,0x60,0x4a,0x57,0xc6,0xa3,0xb6,0x60,
                0x52,0xfc,0x33,0x1a,0x21,0xcb,0xf9,0xc0, 0x04,0xd5,0xc0,0x93,0xe4,0xe0,0x3d,0x29,
                0x0b,0x69,0xe4,0x53,0x22,0x50,0x3c,0xab, 0x9f,0x49,0xc5,0x3d,0x78,0x3e,0x27,0x21,
                0x92,0xeb,0x36,0xed,0xaa,0x9a,0x2e,0x65, 0x1c,0xa4,0xfd,0x09,0xff,0x71,0x22,0xbb,
                0x54,0xa7,0x7d,0x49,0xf4,0xec,0x1a,0xf5, 0xc5,0x65,0xf0,0xa5,0x4f,0xd3,0xdb,0x32,
                0x57,0xfa,0x01,0x64,0x84,0xb0,0xe5,0xde, 0x02,0x8f,0x90,0x4f,0x80,0xdc,0xc0,0x75,
                0xe3,0x23,0x2a,0x6a,0xad,0xbd,0x5e,0x04, 0x44,0x4f,0x6b,0x3e,0x29,0x82,0x52,0x48,
                0x9d,0xec,0x54,0x79
            };

            byte[][] keysToInstall =
            {
               testDrmKeyPrvSig
              ,testDrmKeyPrvEnc
            };

            _rsaDrmTest.InstallKeys(CryptoKey.DrmTestKeyContainer, keysToInstall);
        }

        // the Test key for both Drm and Asset
        public void InstallTestDrmKeyPubSig()
        {
            /*

            This is the format of the key bytes below.

            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PRIV_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x03,0x00,0x00,0x00
            MODULUS DATA FOLLOWS

            */

            // this key can be used for signing/verifying signatures
            byte[] testDrmKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,
                
                                    0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
                0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
                0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
                0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
                0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
                0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
                0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
                0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
                0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
                0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
                0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
                0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
                0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
                0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
                0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
                0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
                0xeb,0x62,0xff,0xb5
            };

            byte[][] keysToInstall =
            {
               testDrmKeyPubSig              
            };

            _rsaDrmTest.InstallKeys(CryptoKey.DrmTestKeyContainer, keysToInstall);
        }

        // the Public Key for Assets container in nCipher
        public void InstallAssetNCipherKeyPubSig()
        {
            /*
        
            This is the format of the key bytes below.
        
            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PUB_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x01,0x00,0x01,0x00
            MODULUS DATA FOLLOWS
        
            */

            byte[] assetKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x01,0x00,0x01,0x00,      
                
                0xDF,0x04,0xB0,0x44,0xED,0xFB,0xAE,0xA7, 0x36,0xCE,0x52,0xAF,0x4C,0x66,0x76,0x44,
                0x59,0x6A,0x8D,0x34,0xB7,0x7C,0x5C,0x77, 0x93,0xC7,0xB1,0x93,0xD3,0x83,0xA3,0xBD,
                0x60,0x88,0xBC,0xDB,0xB0,0x61,0xAF,0x53, 0xE9,0x30,0x99,0xB3,0x13,0xC9,0xD1,0x29,
                0x70,0x20,0x12,0x06,0xFC,0xD7,0x2B,0x5D, 0x1E,0xAA,0xF2,0x74,0xCD,0x3C,0x8B,0x26,
                0xEC,0xD9,0x8B,0xF9,0xC1,0xD0,0x3D,0xDD, 0x5A,0x25,0x41,0x25,0x6F,0x25,0xD4,0x83,
                0xE0,0x44,0xCD,0x04,0xF3,0xFF,0x41,0xAE, 0x90,0x0B,0x44,0xCE,0x91,0x69,0x5F,0x09,
                0x4F,0x8E,0x40,0x10,0x7A,0x6A,0xA4,0xAA, 0x45,0xFB,0xC5,0x02,0x68,0x58,0xA8,0x42,
                0xB2,0x04,0x23,0x51,0x4C,0x61,0xEE,0xA2, 0x1A,0xC4,0xF0,0x71,0x2A,0x8F,0x04,0x2B,
                0xB2,0x64,0xB2,0xB2,0xC4,0xCD,0x2E,0x23, 0xB5,0xE3,0xCA,0xA9,0xC3,0x76,0x9C,0xDF,
                0xEC,0x64,0xA5,0xFD,0x4D,0x02,0xEA,0x5A, 0x74,0xCE,0x1C,0xDF,0x6F,0xC0,0xA9,0xB7,
                0x4F,0x94,0x3D,0x1E,0x6D,0xF9,0x21,0x1B, 0x5C,0x62,0xBA,0x2F,0x05,0x73,0xA4,0xEC,
                0xD2,0xE9,0xBD,0x1F,0x94,0x09,0x8A,0xF3, 0x91,0x53,0x33,0x63,0x62,0x84,0xAE,0x9D,
                0xEC,0x7E,0x6F,0x72,0x43,0x90,0xEF,0xA0, 0x80,0x48,0x2E,0xF5,0x7E,0xBD,0xAC,0xE3,
                0x79,0xA4,0xCA,0x17,0xFC,0x86,0xA3,0x01, 0x3F,0x52,0x6A,0x44,0x38,0x2F,0xD3,0x71,
                0x2D,0x85,0x62,0x00,0x41,0x5D,0xEB,0xDC, 0x6C,0x79,0x35,0x05,0x09,0xF8,0x87,0x8C,
                0xBA,0x7E,0x85,0xF8,0x70,0x57,0x43,0x35, 0x9F,0x26,0x7E,0x8F,0xAE,0xE8,0xF7,0xAE
            };

            byte[][] keysToInstall =
            {
               assetKeyPubSig              
            };

            _rsaAssets.InstallKeys(CryptoKey.AssetKeyContainer, keysToInstall);
        }

        // the Public Key for Drm container in nCipher
        public void InstallDrmNCipherKeyPubSig()
        {
            /*
        
            This is the format of the key bytes below.
        
            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PUB_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x01,0x00,0x01,0x00
            MODULUS DATA FOLLOWS
        
            */

            byte[] drmKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x01,0x00,0x01,0x00,
                
                0xb3,0xc2,0x75,0x03, 0x3f,0x3e,0xe5,0xf2,0xa1,0x9d,0x78,0x90,
                0x41,0xab,0xb6,0x20,0x1c,0x16,0xff,0xfc, 0x6d,0x58,0x4e,0x04,0x54,0x7e,0x16,0x5d,
                0xda,0x1d,0x01,0x9e,0xad,0xe8,0x83,0x02, 0xa7,0xf2,0x2a,0xcb,0x2d,0xad,0xc4,0x9c,
                0xf8,0x00,0xa1,0xcd,0xb1,0x38,0x9f,0x01, 0x18,0x2e,0xaf,0x4c,0x4e,0xa8,0x2a,0xcf,
                0xa6,0xc9,0xfa,0x3d,0x36,0xfd,0xfb,0x61, 0x23,0x17,0x7e,0xe0,0x74,0xa0,0x71,0x75,
                0xfa,0x17,0x22,0x2e,0x35,0x5c,0xec,0x7e, 0x85,0x10,0xf7,0xf9,0x1d,0x09,0x0b,0xc1,
                0xab,0xac,0xb0,0xf5,0x0a,0x78,0x91,0xb7, 0xb9,0xbe,0x7a,0x9a,0x15,0x68,0x4b,0x98,
                0xf9,0xcb,0xca,0x5d,0xa3,0x04,0xfa,0xcc, 0xb0,0x1c,0x77,0x75,0xaf,0x69,0xea,0x5f,
                0x68,0xdd,0x08,0xec,0xc0,0xfc,0x72,0xf3, 0xbf,0xb9,0x98,0x9d,0xdc,0x6a,0xaa,0x49,
                0x5b,0x15,0x5b,0x1e,0x57,0xc7,0xdc,0x8c, 0x3f,0x39,0x35,0x55,0x74,0x9b,0xbb,0x08,
                0x41,0x21,0x75,0xa7,0xd0,0xeb,0xb3,0xc4, 0x89,0xf6,0xfb,0x6c,0x70,0x41,0x25,0x27,
                0xa7,0xa7,0xaf,0x7e,0x6b,0xe9,0x0e,0x16, 0x18,0x96,0xac,0x59,0xc2,0xa4,0x72,0x52,
                0x35,0xee,0xc7,0x11,0x5d,0x9c,0xc0,0xc5, 0x05,0x20,0x1e,0xb3,0xaf,0xb3,0xb2,0xbe,
                0x81,0x5b,0xcf,0xc7,0xac,0x0e,0x7a,0x6e, 0x73,0xde,0x85,0x83,0x88,0x78,0x7b,0xfb,
                0x73,0x46,0x0d,0x59,0x86,0x7d,0x2e,0x7b, 0xe6,0x5a,0x87,0x29,0xb3,0x87,0xd9,0x12,
                0x12,0xbe,0x55,0x82,0x7d,0xf5,0x00,0xd0, 0xc8,0x41,0x3d,0xbd,0xef,0xdc,0x35,0xc7,
                0x8e,0x51,0x7b,0xc9
            };

            byte[][] keysToInstall =
            {
               drmKeyPubSig              
            };

            _rsaDrm.InstallKeys(CryptoKey.DrmKeyContainer, keysToInstall);
        }

        // This will sign the package with the private key
        // because we only install public key, it does not work any more
        public static byte[] NotUse_Sign(byte[] package, int size)
        {
            byte[] signature = new byte[size];
            UInt32 sigLen = 0;
            Global._rsaDrmTest.Sign((new SHA1Managed()).ComputeHash(package), signature, out sigLen);

            return signature;
        }

        // Drm container using nCipher
        public static bool VerifySignatureDrmNCipher(byte[] package, byte[] signature)
        {
            return Global._rsaDrm.VerifySignature((new SHA1Managed()).ComputeHash(package), signature);
        }

        // This will verify the package with a given signature to ensure they match, given the public key
        public static bool VerifySignature(byte[] package, byte[] signature)
        {
            return Global._rsaDrmTest.VerifySignature((new SHA1Managed()).ComputeHash(package), signature);
        }

        // only for Assets using nCipher
        public static bool VerifySignatureAssetNCipher(byte[] package, byte[] signature)
        {
            return Global._rsaAssets.VerifySignature((new SHA1Managed()).ComputeHash(package), signature);
        }

        public static void Dispose()
        {
            if (_global != null)
            {
                Global._rsaDrm.Close(CryptoKey.DrmKeyContainer);
                Global._rsaAssets.Close(CryptoKey.AssetKeyContainer);
                Global._rsaDrmTest.Close(CryptoKey.DrmTestKeyContainer);
                _global = null;
            }
        }

        protected CryptoKey _rsaDrmTest = null;
        protected CryptoKey _rsaAssets = null;
        protected CryptoKey _rsaDrm = null;
    }

    // CryptoKey
    // RSACryptoServiceProvider doesn't seem to work with nCipher so I decided
    // to use CAPI directly.
    public class CryptoKey : IDisposable
    {
        public    static string MS_ENHANCED_PROV        = "Microsoft Enhanced Cryptographic Provider v1.0";
        public    static string NCIPHER_PROV            = "nCipher Enhanced Cryptographic Provider";
        public    static string DrmKeyContainer         = "Drm";
        public    static string DrmTestKeyContainer     = "DrmTest";
        public    static string AssetKeyContainer       = "Assets";

        public void InstallKeys(string container, byte [][] cspImportBlobs)
        {
            IntPtr hProv = IntPtr.Zero;
            uint error;

            try
            {
                // Create container
                if(WinApiCryptAcquireContext(out hProv, container, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_SILENT | CRYPT_NEWKEYSET) == 0)
                {
                    error = (uint) Marshal.GetLastWin32Error();

                    if(error != NTE_EXISTS)
                        throw new Exception("WinApiCryptAcquireContext failed. error = " + error);

                    // Container already exists. Replace.
                    if(WinApiCryptAcquireContext(out hProv, container, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_SILENT | CRYPT_DELETEKEYSET) == 0)
                    {
                        throw new Exception("WinApiCryptAcquireContext failed. error = "+
                                Marshal.GetLastWin32Error());
                    }

                    if(WinApiCryptAcquireContext(out hProv, container, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_SILENT | CRYPT_NEWKEYSET) == 0)
                    {
                        throw new Exception("WinApiCryptAcquireContext failed. error = "+
                                Marshal.GetLastWin32Error());
                    }
                }

                // Import key
                foreach (byte [] cspImportBlob in cspImportBlobs)
                {
                    IntPtr hKey  = IntPtr.Zero;
                    
                    try
                    {
                        if(WinApiCryptImportKey(hProv, cspImportBlob, (uint)cspImportBlob.Length, IntPtr.Zero, 0, out hKey) == 0)
                        {
                            throw new Exception("WinApiCryptImportKey failed. error = "+
                                    Marshal.GetLastWin32Error());
                        }
                    }
                    finally
                    {
                        if(hKey != IntPtr.Zero) 
                            _hKey = hKey;
                    }
                }
            }
            finally
            {
                if(hProv != IntPtr.Zero) 
                    _hProv = hProv;
            }
        }

        public CryptoKey()
        {
            _hProv = IntPtr.Zero;
            _hKey = IntPtr.Zero;
        }

        public void Dispose()
        {
            Close(null);
        }

        public void OpenContainer(string provider, string container, bool openForSigning)
        {
            try
            {
                uint status;

                if (_hProv == IntPtr.Zero)
                {
                    status = WinApiCryptAcquireContext(out this._hProv,
                                                           container,
                                                           provider,
                                                           PROV_RSA_FULL,
                                                           CRYPT_MACHINE_KEYSET | CRYPT_SILENT);
                    if (status == 0)
                    {
                        throw new Exception("WinApiCryptAcquireContext failed. error = 0x" +
                                Marshal.GetLastWin32Error().ToString("X"));
                    }
                }

                if (_hKey == IntPtr.Zero)
                {
                    // Note that this will not work on public keys if
                    //  the imported key has been destroyed via 
                    //  CryptDestroyKey. The key will have to be 
                    //  recreated via CryptImportKey to be opened. 

                    status = WinApiCryptGetUserKey(
                        this._hProv,
                        openForSigning ? AT_SIGNATURE : AT_KEYEXCHANGE,
                        out _hKey
                        );

                    if (status == 0)
                    {
                        throw new Exception("WinApiCryptGetUserKey failed. error = 0x" +
                               Marshal.GetLastWin32Error().ToString("X"));
                    }
                }
            }
            catch (Exception)
            {
                Dispose();
                throw;
            }
        }

        public void Close(string container)
        {
            if (_hKey != IntPtr.Zero)
            {
                WinApiCryptDestroyKey(_hKey);
                _hKey = IntPtr.Zero;
            }
            if (_hProv != IntPtr.Zero)
            {
                WinApiCryptReleaseContext(_hProv, 0);
                _hProv = IntPtr.Zero;
            }

            if (container != null)
            {
                // Delete the container
                if (WinApiCryptAcquireContext(out _hProv, container, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET | CRYPT_SILENT | CRYPT_DELETEKEYSET) == 0)
                {
                    throw new Exception("WinApiCryptAcquireContext failed. error = 0x" +
                            Marshal.GetLastWin32Error().ToString("X"));
                }

                if (_hProv != IntPtr.Zero)
                {
                    WinApiCryptReleaseContext(_hProv, 0);
                    _hProv = IntPtr.Zero;
                }
            }
        }


        public void Sign(byte[] sha1, byte[] sig, out UInt32 sigLen)
        {
            IntPtr hHash = IntPtr.Zero;
            uint status;

            if(sha1.Length != 20)
                throw new Exception("Invalid sha1 size");

            try
            {
                status = WinApiCryptCreateHash(_hProv, CALG_SHA1, IntPtr.Zero, 0, out hHash);

                if(status == 0)
                {
                    throw new Exception("WinApiCreateHash failed. error = "+
                           Marshal.GetLastWin32Error());
                }

                status = WinApiCryptSetHashParam(hHash, HP_HASHVAL, sha1, 0);

                if(status == 0)
                {
                    throw new Exception("WinApiCryptSetHashParam failed. error = "+
                           Marshal.GetLastWin32Error());
                }

                sigLen = (uint)sig.Length;
                status = WinApiCryptSignHash(hHash,
                                             AT_SIGNATURE,
                                             null,
                                             0,
                                             sig,
                                             ref sigLen);

                if(status == 0)
                {
                    throw new Exception("WinApiCryptSignHash failed. error = "+
                           Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                if(hHash != IntPtr.Zero)
                {
                    WinApiCryptDestroyHash(hHash);
                }
            }
        }

        public bool VerifySignature(byte[] sha1, byte[] sig)
        {
            IntPtr hHash = IntPtr.Zero;
            uint status;

            if(sha1.Length != 20)
                throw new Exception("Invalid sha1 size");

            try
            {
                status = WinApiCryptCreateHash(_hProv, CALG_SHA1, IntPtr.Zero, 0, out hHash);

                if(status == 0)
                {
                    throw new Exception("WinApiCreateHash failed. error = "+
                           Marshal.GetLastWin32Error());
                }

                status = WinApiCryptSetHashParam(hHash, HP_HASHVAL, sha1, 0);

                if(status == 0)
                {
                    throw new Exception("WinApiCryptSetHashParam failed. error = "+
                           Marshal.GetLastWin32Error());
                }

                status = WinApiCryptVerifySignature(hHash,
                                                    sig,
                                                    (uint)sig.Length,
                                                    _hKey,
                                                    null,
                                                    0);

                if(status == 0)
                {
                    uint win32err = (uint)Marshal.GetLastWin32Error();

                    if(win32err == NTE_BAD_SIGNATURE)
                        return false;

                    throw new Exception("WinApiCryptVerifySignature failed. error = "+
                           Marshal.GetLastWin32Error());
                }
            }
            finally
            {
                if(hHash != IntPtr.Zero)
                {
                    WinApiCryptDestroyHash(hHash);
                }
            }

            return true;
        }

        public bool Encrypt(byte [] data, uint dataLen)
        {
            uint status;

            UInt32 bufLen = (uint) data.Length;

            status = WinApiCryptEncrypt(
                _hKey,
                IntPtr.Zero,            // hHash
                1,                      // final = true
                CRYPT_OAEP,             // dwFlags
                data,
                ref dataLen,
                bufLen
                );

            if(status == 0)
            {
                throw new Exception("WinApiCryptEncrypt failed. error = "+
                       Marshal.GetLastWin32Error());
            }

            return true;
        }

        public bool Decrypt(byte [] data)
        {
            uint status;

            UInt32 dataLen = (uint) data.Length;

            status = WinApiCryptDecrypt(
                _hKey,
                IntPtr.Zero,            // hHash
                1,                      // final = true
                CRYPT_OAEP,             // dwFlags
                data,
                ref dataLen
                );

            if(status == 0)
            {
                throw new Exception("WinApiCryptDecrypt failed. error = "+
                       Marshal.GetLastWin32Error());
            }

            return true;
        }

        protected const uint    PROV_RSA_FULL           = 1;
        protected const uint    AT_KEYEXCHANGE          = 1;
        protected const uint    AT_SIGNATURE            = 2;
        protected const uint    HP_HASHVAL              = 0x0002;
        protected const uint    CALG_SHA1               = 0x8000 + 0 + 4;
        protected const uint    CRYPT_NEWKEYSET         = 0x00000008;
        protected const uint    CRYPT_DELETEKEYSET      = 0x00000010;
        protected const uint    CRYPT_MACHINE_KEYSET    = 0x00000020;
        protected const uint    CRYPT_SILENT            = 0x00000040;
        protected const uint    NTE_BAD_SIGNATURE       = 0x80090006;
        protected const uint    NTE_EXISTS              = 0x8009000F;

        protected const uint    CRYPT_OAEP              = 0x00000040;       // flag used with Encrypt/Decrypt


        [DllImport("advapi32.dll",
         EntryPoint="CryptAcquireContextW",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptAcquireContext(
            out IntPtr      hProv,
            string          container,
            string          provider,
            UInt32          provType,
            UInt32          flags);

        [DllImport("advapi32.dll",
         EntryPoint="CryptGetUserKey",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptGetUserKey(
            IntPtr          hProv,
            UInt32          dwKeySpec,
            out IntPtr      hUserKey);

        [DllImport("advapi32.dll",
         EntryPoint="CryptCreateHash",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptCreateHash(
            IntPtr          hProv,
            UInt32          algId,
            IntPtr          hKey,
            UInt32          flags,
            out IntPtr      hHash);

        [DllImport("advapi32.dll",
         EntryPoint="CryptSetHashParam",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptSetHashParam(
            IntPtr          hHash,
            UInt32          param,
            byte[]          data,
            UInt32          flags);

        [DllImport("advapi32.dll",
         EntryPoint="CryptSignHashW",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptSignHash(
            IntPtr          hHash,
            UInt32          keySpec,
            string          description,
            UInt32          flags,
            byte[]          signature,
            ref UInt32      sigLen);

        [DllImport("advapi32.dll",
         EntryPoint="CryptVerifySignatureW",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptVerifySignature(
            IntPtr          hHash,
            byte[]          signature,
            UInt32          sigLen,
            IntPtr          hPubKey,
            string          description,
            UInt32          flags);

        [DllImport("advapi32.dll",
         EntryPoint="CryptDestroyKey",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptDestroyKey(
            IntPtr          hKey);

        [DllImport("advapi32.dll",
         EntryPoint="CryptDestroyHash",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptDestroyHash(
            IntPtr          hHash);

        [DllImport("advapi32.dll",
         EntryPoint="CryptReleaseContext",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptReleaseContext(
            IntPtr          hProc,
            UInt32          flags);

        [DllImport("advapi32.dll",
         EntryPoint="CryptImportKey",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptImportKey(
            IntPtr          hProv,
            byte[]          data,
            UInt32          dataLen,
            IntPtr          hPubKey,
            UInt32          flags,
            out IntPtr      hKey);

        [DllImport("advapi32.dll",
         EntryPoint="CryptEncrypt",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptEncrypt(
            IntPtr hKey,
            IntPtr hHash,
            UInt32 final,
            UInt32 dwFlags,
            Byte[] pbData,
            ref UInt32 pdwDataLen,
            UInt32 dwBufLen);

        [DllImport("advapi32.dll",
         EntryPoint="CryptDecrypt",
         ExactSpelling=true,
         SetLastError=true,
         CharSet=CharSet.Unicode,
         CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCryptDecrypt(
            IntPtr hKey,
            IntPtr hHash,
            UInt32 final,
            UInt32 dwFlags,
            Byte[] pbData,
            ref UInt32 pdwDataLen);

        private IntPtr _hProv;
        private IntPtr _hKey;
    }
    #endregion

    /// <summary>
    /// Provides an easy way to reference the various available cryptographic service providers
    /// </summary>
    public class CryptoProvider
    {
        public static readonly String MsBase = "Microsoft Base Cryptographic Provider v1.0";
        public static readonly String MsEnhanced = "Microsoft Enhanced Cryptographic Provider v1.0";
        public static readonly String MsStrong = "Microsoft Strong Cryptographic Provider";
        public static readonly String MsRsaSig = "Microsoft RSA Signature Cryptographic Provider";
        public static readonly String MsSChannel = "Microsoft RSA SChannel Cryptographic Provider";
        public static readonly String MsEnhancedRsaAes = "Microsoft Enhanced RSA and AES Cryptographic Provider";
        public static readonly String NCipherEnhanced = "nCipher Enhanced Cryptographic Provider";
    }

    /// <summary>
    /// Defines the various available typs of CSP
    /// </summary>
    public enum ProviderType
    {
        RsaFull = 1, // PROV_RSA_FULL
        RsaSig = 2, // PROV_RSA_SIG
        Dss = 3, // PROV_DSS
        Fortezza = 4, // PROV_FORTEZZA
        MsExchange = 5, // PROV_MS_EXCHANGE
        Ssl = 6, // PROV_SSL
        RsaSChannel = 12, // PROV_RSA_SCHANNEL
        DssDh = 13, // PROV_DSS_DH
        EcEcdsaSig = 14, // PROV_EC_ECDSA_SIG
        EcEcnraSig = 15, // PROV_EC_ECNRA_SIG
        EcEcdsaFull = 16, // PROV_EC_ECDSA_FULL
        EcEcnraFull = 17, // PROV_EC_ECNRA_FULL
        DhSChannel = 18, // PROV_DH_SCHANNEL
        SpyrusLynks = 20, // PROV_SPYRUS_LYNKS
        Rng = 21, // PROV_RNG
        IntelSec = 22, // PROV_INTEL_SEC
        ReplaceOwf = 23, // PROV_REPLACE_OWF
        RsaAes = 24, // PROV_RSA_AES
    }

    /// <summary>
    /// Provides an easy way to verify signatures against a variety of public keys that a used by 
    /// various live components.
    /// </summary>
    public class ManagedSigUtil : IDisposable
    {
        public static string DrmKeyContainer = "Drm";
        public static string DrmTestKeyContainer = "DrmTest";
        public static string AssetKeyContainer = "Assets";

        protected ManagedCryptoKey _rsaDrmTest = null;
        protected ManagedCryptoKey _rsaAssets = null;
        protected ManagedCryptoKey _rsaDrm = null;

        private static volatile ManagedSigUtil _global;

        public static ManagedSigUtil Global
        {
            get
            {
                if (_global == null)
                {
                    lock (typeof(SignatureUtil))
                    {
                        if (_global == null)
                        {
                            ManagedSigUtil temp = new ManagedSigUtil();

                            // Install test pub key, and NCipher assets pub key
                            temp.InstallTestDrmKeyPubSig();
                            temp.InstallDrmNCipherKeyPubSig();
                            temp.InstallAssetNCipherKeyPubSig();

                            _global = temp;
                        }
                    }
                }

                return _global;
            }
        }

        /// <summary>
        /// The Test key for both Drm and Asset
        /// </summary>
        public void InstallTestDrmKeyPubSig()
        {
            /*

            This is the format of the key bytes below.

            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PRIV_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x03,0x00,0x00,0x00
            MODULUS DATA FOLLOWS

            */

            // this key can be used for signing/verifying signatures
            byte[] testDrmKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x03,0x00,0x00,0x00,
                
                                    0xa5,0x29,0xf1,0x27, 0x87,0xcd,0x12,0x92,0x3f,0xa8,0x59,0x2f,
                0xdd,0xd1,0xba,0xb3,0x7e,0x2d,0xb4,0xd1, 0xb2,0x62,0x30,0x65,0x94,0xa9,0x89,0x63,
                0x7f,0x2f,0x5b,0x2f,0xac,0x43,0x54,0x66, 0x16,0x46,0x0a,0xc1,0x18,0x64,0xeb,0xf9,
                0xb2,0x38,0x07,0x78,0xe5,0xec,0x3c,0x61, 0x39,0xc8,0x26,0xc4,0x3e,0xe9,0x6d,0x42,
                0x59,0x92,0xdd,0x62,0x04,0xf0,0x29,0x19, 0x04,0x81,0xae,0xca,0x19,0xf9,0x4c,0x48,
                0xae,0x86,0xc5,0x6d,0x88,0x52,0xcc,0x32, 0x54,0x31,0x8a,0xfb,0x63,0xb2,0x3c,0x43,
                0x42,0x98,0x9e,0x25,0x8d,0xd3,0x3e,0x97, 0xa3,0x71,0xca,0x07,0x40,0xfd,0xd2,0xa3,
                0x56,0xa9,0x44,0x4e,0xb4,0x7d,0x92,0x23, 0xee,0x5e,0x1a,0xb8,0x95,0xf3,0xf9,0x02,
                0xc7,0x04,0xf7,0xa8,0xce,0x24,0x90,0x30, 0x5c,0xe2,0x82,0x77,0x77,0x99,0x39,0xbe,
                0x4f,0x19,0x05,0x7d,0x5d,0x55,0xb0,0x68, 0x74,0x91,0xef,0x82,0xa9,0xf5,0x11,0x91,
                0x7b,0xfa,0x4d,0xa7,0xb1,0xb0,0x76,0x21, 0x87,0x3f,0xa1,0xdd,0x56,0xd1,0xdc,0xbd,
                0x90,0x9d,0xd6,0x7d,0x33,0x78,0xda,0x80, 0x6f,0xee,0xa7,0x5c,0xb4,0xdd,0xba,0x31,
                0x5b,0x61,0xd2,0x63,0x00,0xe8,0xc5,0x97, 0x2a,0x76,0xfc,0x8e,0xfe,0xaa,0xb3,0x18,
                0xff,0x7a,0x3c,0x6e,0x6e,0x63,0xa8,0xef, 0xa8,0x98,0xe8,0x78,0xf7,0xbc,0x49,0xcc,
                0x82,0xf7,0x02,0x96,0xc6,0x88,0x58,0x4e, 0x84,0xd6,0x58,0x77,0xc0,0x4a,0xa1,0x30,
                0xd5,0x35,0x3f,0x1f,0x84,0x1c,0x8e,0x06, 0xe6,0xf6,0xa0,0xdd,0x3d,0xc3,0x7b,0xec,
                0xeb,0x62,0xff,0xb5
            };

            _rsaDrmTest = new ManagedCryptoKey();
            _rsaDrmTest.InstallKeys(DrmTestKeyContainer, testDrmKeyPubSig);
        }

        /// <summary>
        /// The Public Key for Assets container in nCipher
        /// </summary>
        public void InstallAssetNCipherKeyPubSig()
        {
            /*
        
            This is the format of the key bytes below.
        
            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PUB_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x01,0x00,0x01,0x00
            MODULUS DATA FOLLOWS
        
            */

            byte[] assetKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x01,0x00,0x01,0x00,      
                
                0xDF,0x04,0xB0,0x44,0xED,0xFB,0xAE,0xA7, 0x36,0xCE,0x52,0xAF,0x4C,0x66,0x76,0x44,
                0x59,0x6A,0x8D,0x34,0xB7,0x7C,0x5C,0x77, 0x93,0xC7,0xB1,0x93,0xD3,0x83,0xA3,0xBD,
                0x60,0x88,0xBC,0xDB,0xB0,0x61,0xAF,0x53, 0xE9,0x30,0x99,0xB3,0x13,0xC9,0xD1,0x29,
                0x70,0x20,0x12,0x06,0xFC,0xD7,0x2B,0x5D, 0x1E,0xAA,0xF2,0x74,0xCD,0x3C,0x8B,0x26,
                0xEC,0xD9,0x8B,0xF9,0xC1,0xD0,0x3D,0xDD, 0x5A,0x25,0x41,0x25,0x6F,0x25,0xD4,0x83,
                0xE0,0x44,0xCD,0x04,0xF3,0xFF,0x41,0xAE, 0x90,0x0B,0x44,0xCE,0x91,0x69,0x5F,0x09,
                0x4F,0x8E,0x40,0x10,0x7A,0x6A,0xA4,0xAA, 0x45,0xFB,0xC5,0x02,0x68,0x58,0xA8,0x42,
                0xB2,0x04,0x23,0x51,0x4C,0x61,0xEE,0xA2, 0x1A,0xC4,0xF0,0x71,0x2A,0x8F,0x04,0x2B,
                0xB2,0x64,0xB2,0xB2,0xC4,0xCD,0x2E,0x23, 0xB5,0xE3,0xCA,0xA9,0xC3,0x76,0x9C,0xDF,
                0xEC,0x64,0xA5,0xFD,0x4D,0x02,0xEA,0x5A, 0x74,0xCE,0x1C,0xDF,0x6F,0xC0,0xA9,0xB7,
                0x4F,0x94,0x3D,0x1E,0x6D,0xF9,0x21,0x1B, 0x5C,0x62,0xBA,0x2F,0x05,0x73,0xA4,0xEC,
                0xD2,0xE9,0xBD,0x1F,0x94,0x09,0x8A,0xF3, 0x91,0x53,0x33,0x63,0x62,0x84,0xAE,0x9D,
                0xEC,0x7E,0x6F,0x72,0x43,0x90,0xEF,0xA0, 0x80,0x48,0x2E,0xF5,0x7E,0xBD,0xAC,0xE3,
                0x79,0xA4,0xCA,0x17,0xFC,0x86,0xA3,0x01, 0x3F,0x52,0x6A,0x44,0x38,0x2F,0xD3,0x71,
                0x2D,0x85,0x62,0x00,0x41,0x5D,0xEB,0xDC, 0x6C,0x79,0x35,0x05,0x09,0xF8,0x87,0x8C,
                0xBA,0x7E,0x85,0xF8,0x70,0x57,0x43,0x35, 0x9F,0x26,0x7E,0x8F,0xAE,0xE8,0xF7,0xAE
            };

            _rsaAssets = new ManagedCryptoKey();
            _rsaAssets.InstallKeys(CryptoKey.AssetKeyContainer, assetKeyPubSig);
        }

        /// <summary>
        /// The Public Key for Drm container in nCipher
        /// </summary>
        public void InstallDrmNCipherKeyPubSig()
        {
            /*
        
            This is the format of the key bytes below.
        
            KEY_HEADER:
                BYTE    bType;                  // PUBLICKEYBLOB = 0x06
                BYTE    bVersion;               // 0x02
                WORD    reserved;               // 0x00,0x00
                DWORD   aiKeyAlg;               // can be either of the following:
                    CALG_RSA_SIGN = (ALG_CLASS_SIGNATURE   |ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0x24,0x00,0x00
                    CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY) = 0x00,0xA4,0x00,0x00
                DWORD   magic;                  // RSA_PUB_MAGIC = 0x52,0x53,0x41,0x31 (0x31415352)
                DWORD   bitlen;                 // # of bits in modulus = 0x00,0x08,0x00,0x00
                DWORD   pubexp;                 // public exponent = 0x01,0x00,0x01,0x00
            MODULUS DATA FOLLOWS
        
            */

            byte[] drmKeyPubSig = new byte[276]
            {
                0x06,0x02,0x00,0x00,0x00,0x24,0x00,0x00, 0x52,0x53,0x41,0x31,0x00,0x08,0x00,0x00,
                0x01,0x00,0x01,0x00,
                
                0xb3,0xc2,0x75,0x03, 0x3f,0x3e,0xe5,0xf2,0xa1,0x9d,0x78,0x90,
                0x41,0xab,0xb6,0x20,0x1c,0x16,0xff,0xfc, 0x6d,0x58,0x4e,0x04,0x54,0x7e,0x16,0x5d,
                0xda,0x1d,0x01,0x9e,0xad,0xe8,0x83,0x02, 0xa7,0xf2,0x2a,0xcb,0x2d,0xad,0xc4,0x9c,
                0xf8,0x00,0xa1,0xcd,0xb1,0x38,0x9f,0x01, 0x18,0x2e,0xaf,0x4c,0x4e,0xa8,0x2a,0xcf,
                0xa6,0xc9,0xfa,0x3d,0x36,0xfd,0xfb,0x61, 0x23,0x17,0x7e,0xe0,0x74,0xa0,0x71,0x75,
                0xfa,0x17,0x22,0x2e,0x35,0x5c,0xec,0x7e, 0x85,0x10,0xf7,0xf9,0x1d,0x09,0x0b,0xc1,
                0xab,0xac,0xb0,0xf5,0x0a,0x78,0x91,0xb7, 0xb9,0xbe,0x7a,0x9a,0x15,0x68,0x4b,0x98,
                0xf9,0xcb,0xca,0x5d,0xa3,0x04,0xfa,0xcc, 0xb0,0x1c,0x77,0x75,0xaf,0x69,0xea,0x5f,
                0x68,0xdd,0x08,0xec,0xc0,0xfc,0x72,0xf3, 0xbf,0xb9,0x98,0x9d,0xdc,0x6a,0xaa,0x49,
                0x5b,0x15,0x5b,0x1e,0x57,0xc7,0xdc,0x8c, 0x3f,0x39,0x35,0x55,0x74,0x9b,0xbb,0x08,
                0x41,0x21,0x75,0xa7,0xd0,0xeb,0xb3,0xc4, 0x89,0xf6,0xfb,0x6c,0x70,0x41,0x25,0x27,
                0xa7,0xa7,0xaf,0x7e,0x6b,0xe9,0x0e,0x16, 0x18,0x96,0xac,0x59,0xc2,0xa4,0x72,0x52,
                0x35,0xee,0xc7,0x11,0x5d,0x9c,0xc0,0xc5, 0x05,0x20,0x1e,0xb3,0xaf,0xb3,0xb2,0xbe,
                0x81,0x5b,0xcf,0xc7,0xac,0x0e,0x7a,0x6e, 0x73,0xde,0x85,0x83,0x88,0x78,0x7b,0xfb,
                0x73,0x46,0x0d,0x59,0x86,0x7d,0x2e,0x7b, 0xe6,0x5a,0x87,0x29,0xb3,0x87,0xd9,0x12,
                0x12,0xbe,0x55,0x82,0x7d,0xf5,0x00,0xd0, 0xc8,0x41,0x3d,0xbd,0xef,0xdc,0x35,0xc7,
                0x8e,0x51,0x7b,0xc9
            };

            _rsaDrm = new ManagedCryptoKey();
            _rsaDrm.InstallKeys(CryptoKey.DrmKeyContainer, drmKeyPubSig);
        }

        // Drm container using nCipher
        public static bool VerifySignatureDrmNCipher(byte[] package, byte[] signature)
        {
            return Global._rsaDrm.VerifyData(package, signature);
        }

        // This will verify the package with a given signature to ensure they match, given the public key
        public static bool VerifySignature(byte[] package, byte[] signature)
        {
            //return Global._rsaDrmTest.VerifySignature(package, new SHA1Managed(), signature);
            return Global._rsaDrmTest.VerifyData(package, signature);
        }

        // only for Assets using nCipher
        public static bool VerifySignatureAssetNCipher(byte[] package, byte[] signature)
        {
            return Global._rsaAssets.VerifyData(package, signature);
        }

        #region IDisposable Members

        public void Dispose()
        {
            if (_rsaDrm != null)
            {
                _rsaDrm.Dispose();
            }
            if (_rsaDrmTest != null)
            {
                _rsaDrmTest.Dispose();
            }
            if (_rsaAssets != null)
            {
                _rsaAssets.Dispose();
            }
        }

        #endregion
    }

    /// <summary>
    /// A wrapper around the .NET RSACryptoServiceProvider class which handles creating/opening the container
    /// and maintains the key state and handles interop between the CAPI and the managed crypto classes
    /// </summary>
    public class ManagedCryptoKey : IDisposable
    {
        public static readonly ProviderType DefaultProviderType = ProviderType.RsaFull;
        public static readonly String DefaultCryptoProvider = CryptoProvider.MsEnhanced;
        private static readonly String ShaHashOID = CryptoConfig.MapNameToOID("SHA1");

        public RSACryptoServiceProvider provider = null;
        private SHA1Managed sha1Managed = new SHA1Managed();

        public ManagedCryptoKey()
        {
        }

        /// <summary>
        /// Install a set of keys into the named container with a deault CSP name and type
        /// </summary>
        /// <param name="container">The container to install the csp blobs into</param>
        /// <param name="cspImportBlobs">The csp blobs to install</param>
        public void InstallKeys(string container, params byte[][] cspImportBlobs)
        {
            InstallKeys(DefaultProviderType, DefaultCryptoProvider, container, cspImportBlobs);
        }

        /// <summary>
        /// Install a set of keys into the named container with a given CSP name and type
        /// </summary>
        /// <param name="providerType">The type of CSP container to create</param>
        /// <param name="providerName">The name of the CSP to use</param>
        /// <param name="container">The container to install the csp blobs into</param>
        /// <param name="cspImportBlobs">The csp blobs to install</param>
        public void InstallKeys(ProviderType providerType, string providerName, string container, params byte[][] cspImportBlobs)
        {
            // This will throw and exception if it fails
            OpenContainer(providerType, providerName, container);

            // Import each CSP.  With managed code, this might just overwrite the last imported blob,
            // but we'll keep it this way for compatibility.
            foreach (byte[] cspBlob in cspImportBlobs)
            {
                provider.ImportCspBlob(cspBlob);
            }

        }

        /// <summary>
        /// Create or Open a named crypto container with the default container type and provider
        /// </summary>
        /// <param name="container">The name of the container to open</param>
        public void OpenContainer(String container)
        {
            OpenContainer(container, false);
        }

        /// <summary>
        /// Create or Open a named crypto container with the default container type and provider
        /// </summary>
        /// <param name="container">The name of the container to open</param>
        /// <param name="forSigning">Indicates whether the Signature of Exchange key should be used</param>
        public void OpenContainer(String container, bool forSigning)
        {
            OpenContainer(DefaultProviderType, DefaultCryptoProvider, container, forSigning);
        }

        /// <summary>
        /// Create or Open a named crypto container of the given type
        /// </summary>
        /// <param name="providerType">The type of CSP container to use</param>
        /// <param name="providerName">The name of the CSP to use</param>
        /// <param name="container">The name of the container to open</param>
        public void OpenContainer(ProviderType providerType, String providerName, String container)
        {
            OpenContainer(providerType, providerName, container, false);
        }

        /// <summary>
        /// Create or Open a named crypto container of the given type
        /// </summary>
        /// <param name="providerType">The type of crypto provider to create the container with</param>
        /// <param name="providerName">The name of the provider to use</param>
        /// <param name="container">The name of the container to open</param>
        /// <param name="forSigning">Indicates whether the Signature of Exchange key should be used</param>
        public void OpenContainer(ProviderType providerType, String providerName, String container, bool forSigning)
        {
            if (provider == null)
            {
                try
                {
                    CspParameters cspParams = new CspParameters((int)providerType, providerName, container);
                    cspParams.Flags = CspProviderFlags.NoPrompt;
                    //cspParams.Flags = CspProviderFlags.UseMachineKeyStore | CspProviderFlags.NoPrompt;
                    cspParams.KeyNumber = (int)(forSigning ? KeyNumber.Signature : KeyNumber.Exchange);

                    provider = new RSACryptoServiceProvider(cspParams);
                }
                catch (CryptographicException e)
                {
                    provider = null;
                    throw new Exception("Unable to load container " + container, e);
                }
            }
        }

        /// <summary>
        /// The private key is not imported for this method so it is currently not supported.
        /// </summary>
        /// <param name="sha1hash"></param>
        /// <returns></returns>
        private byte[] Sign(byte[] sha1hash)
        {
            throw new NotSupportedException("This method is not currently supported due to the lack of a private key");

            //Array.Reverse(sha1hash);
            //return provider.SignHash(sha1hash, ShaHashOID);
        }


        /// <summary>
        /// Verifies the signature of a given blob of data
        /// </summary>
        /// <param name="data">The data the verify against</param>
        /// <param name="sig">The signature to verify</param>
        /// <returns>True if the signature is valid, false otherwise</returns>
        /// <remarks>The signature is checked against the SHA1 hash of the data</remarks>
        /// <exception cref="InvalidOperationException">Thrown if the CSP is not yet properly initialized</exception>
        /// <exception cref="ArgumentNullException">Thrown if hash or sig is null</exception>
        public bool VerifyData(byte[] data, byte[] sig)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            return VerifyHash(sha1Managed.ComputeHash(data), ShaHashOID, sig);
        }

        /// <summary>
        /// Verifies the signature of the SHA1 hash of some data
        /// </summary>
        /// <param name="hash">The SHA1 hash of the data who's signature you want to verify</param>
        /// <param name="sig">The signature of the hash of the data</param>
        /// <returns>True if the signature is valid, false otherwise</returns>
        /// <exception cref="InvalidOperationException">Thrown if the CSP is not yet properly initialized</exception>
        /// <exception cref="ArgumentNullException">Thrown if hash or sig is null</exception>
        public bool VerifyHash(byte[] hash, byte[] sig)
        {
            // Pass in the default hash algorithm
            return VerifyHash(hash, ShaHashOID, sig);
        }

        /// <summary>
        /// Verifies the signature of the given hash
        /// </summary>
        /// <param name="hash">The hashed data</param>
        /// <param name="hashAlg">The OID of the hash algorithm used to generate the hash</param>
        /// <param name="sig">The signature to verify against</param>
        /// <returns>True if the hash is valid, false otherwise</returns>
        /// <exception cref="InvalidOperationException">Thrown if the CSP is not yet properly initialized</exception>
        /// <exception cref="ArgumentNullException">Thrown if hash or sig is null</exception>
        public bool VerifyHash(byte[] hash, string hashAlg, byte[] sig)
        {
            if (provider == null)
            {
                throw new InvalidOperationException("The CSP has not been properly initialized yet");
            }

            if (hash == null)
            {
                throw new ArgumentNullException("hash");
            }

            if (sig == null)
            {
                throw new ArgumentNullException("sig");
            }

            Byte[] sigCopy = new Byte[sig.Length];
            Array.Copy(sig, sigCopy, sig.Length);
            Array.Reverse(sigCopy);

            return provider.VerifyHash(hash, hashAlg, sigCopy);
        }

        #region IDisposable Members

        /// <summary>
        /// We want to delete the keyset and remove it all from memory, so we do that here.
        /// </summary>
        public void Dispose()
        {
            if (provider != null)
            {
                provider.PersistKeyInCsp = false;
                provider.Clear();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\PassportUtilities.cs ===
using System;
using System.IO;
using System.Security.Cryptography;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// This class provides properties to generate random credit card numbers
    /// </summary>
    public class PassportUtilities
    {
        public static ulong GetPuidFromSessionToken(byte[] sessionToken)
        {
            if (sessionToken.Length != XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)
                throw new Exception("Session token is not the expected length.");

            return BitConverter.ToUInt64(sessionToken, 0);
        }

        public static ulong GenerateRandomULong()
        {
            // generate a fake puid
            Random rnd = new Random((int)DateTime.Now.Ticks);

            return (((ulong)rnd.Next()) << 32) + ((ulong)rnd.Next());
        }

        public static byte[] GenerateSessionToken(byte[] key)
        {
            // generate a fake puid
            Random rnd = new Random((int)DateTime.Now.Ticks);

            // Removed the following line because bug #48041 caused dummpy passport puids to fail user account creation
            //ulong dummyPuid = (((ulong)rnd.Next()) << 32) + ((ulong)rnd.Next());

            UacsCommon UACS = new UacsCommon();
            UacsCommon.PassportUser ppu = UACS.CreatePassportUser();
            ulong dummyPuid = ppu.PassportPuid;

            return GenerateSessionToken(dummyPuid, key);
        }


        public static byte[] GenerateSessionToken(ulong puid, byte[] key)
        {
            // Generate signed puid using the following format:
            // puid       (8 bytes)
            // signature  (20 bytes)
            
            byte[] signature;
            MemoryStream ms = new MemoryStream(XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN);
            BinaryWriter bw = new BinaryWriter(ms);
            bw.Write(puid);
            
            HMACSHA1 shaM = new HMACSHA1(key);
            shaM.ComputeHash(ms.GetBuffer(), 0, (int)ms.Length);
            signature = shaM.Hash;
            
            if(signature.Length != 20)
                throw new Exception(string.Format("Unexpected: invalid signature size:{0}", signature.Length.ToString()));
            
            bw.Write(signature);
            
            return ms.ToArray();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\RandomEx.cs ===
//The core RandomEx + some live-specific functions.

using ServerTestFramework.LiveService.FakeSG;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// Summary description for Random.  --(who the heck writes a comment like this?)
	/// </summary>
	unsafe public class RandomEx: ServerTestFramework.Core.Utilities.RandomEx
	{
        public ulong GenerateRandomMachineId(CSGInfo.ClientType clientType)
        {
            return (NextUlong() & (~CSGInfo.ClientInfo.Mask)) | CSGInfo.ClientInfo.ToMachineBase(clientType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\PassportFuzzer.cs ===
using System;
using System.Threading;
using System.Net;
using System.IO;
using System.Text;
using System.Security.Cryptography;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Summary description for PassportFuzzer.
    /// </summary>
        public class PassportFuzzer
        {
            public static int PortNumer = 25130;

            internal static string _myurl;
            private HttpListener _listener;
            private Object _delock = new object();
            private bool _hasConnection;
            private object _connectionLock = new object();
            private Thread _thread;
            
            private WebExceptionStatus _desiredException;
            public WebExceptionStatus DesiredException
            {
                get { lock (_delock) return _desiredException; }
                set { lock (_delock) _desiredException = value; }
            }

            //Constructor
            public PassportFuzzer(string url)
            {
                _myurl = url;

                if (_listener != null)
                {
                    _listener.Prefixes.Clear();
                    _listener.Abort();
                    ((IDisposable)_listener).Dispose();
                    _listener = null;
                }
                _listener = new HttpListener();
                _listener.Prefixes.Add(_myurl + "/");

            }

            public  void StartFuzzer()
            {
                _thread = ThreadMaker.CreateThread(this.Bind);
                _thread.Start();
            }

            public  void StopFuzzer()
            {
                // Stop listening
                lock (_delock)
                {
                    try
                    {
                        _listener.Stop();
                        _listener.Close();
                    }
                    catch { }
                }

                _thread.Abort();
                System.Threading.Thread.Sleep(10*1000);
            }

            public void Bind()
            {
                Global.RO.Info("Starting httplistener on " + _myurl);
                _listener.Start();
                while (_listener.IsListening)
                {
                    HttpListenerContext context = _listener.GetContext();
                    SetConnection();
                    RequestProcessor rp = new RequestProcessor(context, _desiredException);
                    Thread request = ThreadMaker.CreateThread(rp.Process);
                    request.Start();
                }
            }

            private void SetConnection()
            {
                lock (_connectionLock)
                {
                    _hasConnection = true;
                }
            }

            public bool GotConnection()
            {
                bool res;
                lock (_connectionLock)
                {
                    res = _hasConnection;
                    _hasConnection = false;
                }
                return res;
            }

            public class RequestProcessor
            {
                private HttpListenerContext _context;
                private WebExceptionStatus _desiredException;

                public RequestProcessor(HttpListenerContext context, WebExceptionStatus desiredException)
                {
                    _desiredException = desiredException;
                    _context = context;
                }

                public void Process()
                {
                    Thread.Sleep(100);
                    _context.Response.ContentType = "text/xml";
                    Global.RO.Debug("Got listener from: {0} RawURL: [{1}]", _context.Request.RemoteEndPoint, _context.Request.RawUrl);
                    try
                    {
                        if(_desiredException == WebExceptionStatus.ReceiveFailure)
                        {
                            _context.Response.Abort();
                        }
                        else if(_desiredException == WebExceptionStatus.Timeout)
                        {
                            Thread.Sleep(60000);
                        }
                        else if(_desiredException == WebExceptionStatus.Success)
                        {
                            string baseXML = GetBaseXML(_context.Request.RawUrl);
                            _context.Response.ContentType = "text/xml";
                            string xml = string.Format(baseXML, _myurl);
                            _context.Response.ContentEncoding = Encoding.ASCII;
                            _context.Response.ContentLength64 = xml.Length;
                            BinaryWriter writer = new BinaryWriter(_context.Response.OutputStream);
                            writer.Write(Encoding.ASCII.GetBytes(xml));
                        }
                        else
                        {
                            string baseXML = GetBaseXML(_context.Request.RawUrl);
                            _context.Response.ContentType = "text/xml";
                            string xml = string.Format(baseXML, _myurl);
                            _context.Response.ContentEncoding = Encoding.ASCII;
                            _context.Response.ContentLength64 = xml.Length;
                            BinaryWriter writer = new BinaryWriter(_context.Response.OutputStream);
                            writer.Write(Encoding.ASCII.GetBytes(xml));
                        }
                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("unhandled exception:\r\n" + e.ToString());
                    }
                    try
                    {
                        _context.Response.Close();
                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("unhandled exception:\r\n" + e.ToString());
                    }

                }

                private  string GetBaseXML(string rawUrl)
                {
                    string baseXML=null;
                    string siteAddress = Global.XEnv.GetSetting("passport_siteAddress");
                    
                    switch(rawUrl)
                    {
                        case "/Login":
                            baseXML = "<Envelope xmlns='http://schemas.xmlsoap.org/soap/envelope/' xmlns:ps='http://schemas.microsoft.com/Passport/SoapServices/EncProxyV1'>"+
                                                "<Header><psf:pp xmlns:psf='http://schemas.microsoft.com/Passport/SoapServices/SOAPFault'>"+
                                                "<ps:TokenResponse id='" + siteAddress + "'><psf:reqstatus>0x00000000</psf:reqstatus><psf:reqdetail></psf:reqdetail></ps:TokenResponse></psf:pp><ps:PUID>00030000836B01CA</ps:PUID>" +
                                                "<wsse:Security xmlns:wsse=\"http://schemas.xmlsoap.org/ws/2003/06/secext\" xmlns:wssc=\"http://schemas.xmlsoap.org/ws/2004/04/sc\">"+
                                                "<Timestamp xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" Id=\"TS\"><Created>2008-12-11T18:13:00Z</Created><Expires>2008-12-11T18:18:00Z</Expires></Timestamp>"+
                                                "<wssc:DerivedKeyToken Id=\"SignKey\"><wsse:SecurityTokenReference><wsse:Reference URI=\"#SymToken\"></wsse:Reference></wsse:SecurityTokenReference>"+
                                                "<wssc:Nonce>yBsep31TifZASCB8nM6+RfEilOKIIE9r/EpuGijl63A=</wssc:Nonce></wssc:DerivedKeyToken><wssc:DerivedKeyToken Id=\"EncKey\"><wsse:SecurityTokenReference><wsse:Reference URI=\"#SymToken\"></wsse:Reference></wsse:SecurityTokenReference><wssc:Nonce>zKjgJhME0MWbpwoETB0zkePk349C3VSNtBjky4qs88g=</wssc:Nonce></wssc:DerivedKeyToken><Signature xmlns=\"http://www.w3.org/2000/09/xmldsig#\"><SignedInfo><CanonicalizationMethod Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"></CanonicalizationMethod><SignatureMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#hmac-sha1\"></SignatureMethod><Reference URI=\"#RSTR\"><Transforms><Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"></Transform></Transforms><DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"></DigestMethod><DigestValue>/1VV9dyKbaBrU/Zl2QUOPFL6mCA=</DigestValue></Reference><Reference URI=\"#TS\"><Transforms><Transform Algorithm=\"http://www.w3.org/2001/10/xml-exc-c14n#\"></Transform></Transforms><DigestMethod Algorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"></DigestMethod><DigestValue>AhIIeblWuZ5eJYp2cqany8kB0xo=</DigestValue></Reference></SignedInfo><SignatureValue>c036Qaq/rYC9ekvo8oTrGjOgkgE=</SignatureValue><KeyInfo><wsse:SecurityTokenReference><wsse:Reference URI=\"#SignKey\"></wsse:Reference></wsse:SecurityTokenReference></KeyInfo></Signature></wsse:Security></Header><Body><EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Id=\"RSTR\" Type=\"http://www.w3.org/2001/04/xmlenc#Element\"><EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#tripledes-cbc\"></EncryptionMethod><KeyInfo><wsse:SecurityTokenReference xmlns:wsse=\"http://schemas.xmlsoap.org/ws/2003/06/secext\"><wsse:Reference URI=\"#EncKey\"></wsse:Reference></wsse:SecurityTokenReference></KeyInfo>"+
                                                "<CipherData><CipherValue>eqxsjA+hKSChlaf9BR1d5Y6H4Qm1Z970AVlq7kyZkJdzC8O1uNa4maY4vvw4oMLrx9ezB2qGfz3MAjawqeTyjjg3cebEapbtWtnEgz0jRag0cD5jX+8toBBjXol/FN3vg5hD8/SehNU3bM6pwOqv8VhKP5eZfiXhv7yZNJRPxwwrj7v8TIstHwR0SIjIkQUO1/L9aj+YkeSibfU3olzo10bm041ebZ2zMwTDplrmBOituU68i26wwIQSHakXXsqYLXIjg7Gcs4w2RXPWRKEGJArVsPR5dthZiXS2yAWO8OwP32rMX2nDleYdbhqosTNL/3HPdxxh43dLKxQ5Sc27tOs3BkWq5/Vs1TMZM6gk7Ih72WTjHaSCa1rt9/378M0LL9qSmjaSLhCbiN1nqwBYVEQQ7NPOofE7hRQbb0Rh8h9/yrpgOXy7NESl/TBdjQZxQ1VGwaOXFlD9o1M91RQNXeaZK5iBSAEF1w6rmaXgDQrMcNxlU2OOphRPO4+d/5Ab2QrSYf3FRJWEgt0HID2di8Sikz6BHphHbVunKgnhj47jwb7uUIlE4ywnL4JpJKnBlI/+MqJxpnBt8wv9YdwLMVgDWgzo2UQFr+2epyx4WqRYdDYHY3lMt3KlP7Huxlh6bjVopkqpUwLSWmczjHACUkr5GGvmbvaL+Mv9kTsGvoGzvUmt8DR4pfS8VNxQShzGMG3dputQKO/MkKbXJlHuzXvtwrgCwvB521LQs3KzqnTvINQ9qpSFON5owRaNdcmUDzG/lxnz7n06L8cAxQM9Jxa9PI9Lmul+MFb594tMZudmcMgMqFOOkXlt9zaH86Of0NFONYfyDNPfj/5z4wUhNIdrjjasKKJvMd2+Gowsf9OpHkvjx2eSCwrxKgHloAoYgV4HoLByiFd244uoflaWRfrY4vOXkCvrOqj1H1MYqTYiBboDcTgYNbdIKDLIQN3QiCLHWURFNveh+CEBGOvdBXvuO/+3xKlukWUP5ijNtiHYV8kVBJo/xo6zBEH7MukRcJeF3zSmjCwQ/upog1ucbYajguWx2LWuLhEfISWYhdTURBT+D803Uu073ggYRpZLKSr7UUMsPVIUiTqCI1hur3BzPhuLnJmMhYn7yt2Z5r5j+QKJUfo19KmSDiDPpQBhxDWvz7PZLwZNq7hi3JBW9MoIcg3YVjOEciAgGbbQ5Oh4tCClt3WmEHSB4FYyiIVA/zxZKMD/JkJC5aLV7U+NQoCnDXGLjPW3jToNnnELmgwYQWnpApq7A2H4r0386DOp4eFPNEisihaoemdrS3RDsTLT1Fef3xXqYExcylOA+kWY0WlyCVfFMA9eV0/ClxN4EejB8QvVZBIYcref9sKMoXJg5BtLF3oi9WObTG9paUoP2vWvl9uJePWClgaiTGZz84q/32lgwXh0X7Pkxp48Z/oVt9kSGcEJTjGjvBPeEZ0wS20gWzWBLUlTMDP8s6C/Y5NYN9/S6vCiYAF+pXRUpNM/VcfTqcvq</CipherValue></CipherData></EncryptedData></Body></Envelope>\r\n";
                            break;

                            case "/fakedpartner.xml":
                            baseXML = "<Partner ValidUntil=\"12/12/2010\" Version=\"2007.07.10.00.05.31\">  <PassportNetwork>  <Domain Name=\"default\" DomainSuffix=\"default\">  <Id>1</Id>  <DefaultLCID>0409</DefaultLCID>  <AcceptanceMarkHorzGIF LCID=\"lang_replace\">{0}/%L/mppnacceptancemarkhorz.gif</AcceptanceMarkHorzGIF>  <AcceptanceMarkVertGIF LCID=\"lang_replace\">{0}/%L/mppnacceptancemarkvert.gif</AcceptanceMarkVertGIF>  <AccountInfo LCID=\"lang_replace\">{0}/editprof.srf?lc=%L</AccountInfo>  <AccountServicesCred LCID=\"lang_replace\">{0}/credentials.srf?lc=%L</AccountServicesCred>  <AccountServicesMSN LCID=\"lang_replace\">{0}/?lc=%L</AccountServicesMSN>  <AccountServicesMSNCustomerSupport LCID=\"lang_replace\">{0}/customersupport.srf?lc=%L</AccountServicesMSNCustomerSupport>  <AccountServicesMSNPrivacySecurity LCID=\"lang_replace\">{0}/privacysecurity.srf?lc=%L</AccountServicesMSNPrivacySecurity>  <AccountServicesMSNXDA LCID=\"lang_replace\">{0}/loginmsn.srf?lc=%L</AccountServicesMSNXDA>  <AccountServicesMyKids LCID=\"lang_replace\">{0}/mykids.srf?lc=%L</AccountServicesMyKids>  <AccountServicesPP LCID=\"lang_replace\">{0}/?lc=%L</AccountServicesPP>  <AccountServicesPPCustomerSupport LCID=\"lang_replace\">{0}/customersupport.srf?lc=%L</AccountServicesPPCustomerSupport>  <AccountServicesPPPrivacySecurity LCID=\"lang_replace\">{0}/privacysecurity.srf?lc=%L</AccountServicesPPPrivacySecurity>  <AccountServicesProfile LCID=\"lang_replace\">{0}/profile.srf?lc=%L</AccountServicesProfile>  <Accrual LCID=\"lang_replace\">{0}/regprofileaccrual.srf?lc=%L</Accrual>  <MarketingOptOut LCID=\"lang_replace\">{0}/MarketingPreference.srf?lc=%L</MarketingOptOut>"+  
                                            "<AddAltEmail LCID=\"lang_replace\">{0}/AddAltEmail.srf?lc=%L</AddAltEmail>  <AgeBasedSiteConsent LCID=\"lang_replace\">{0}/ParentsIntro.srf?lc=%L</AgeBasedSiteConsent>  <Association LCID=\"lang_replace\">{0}</Association>  <AssociationServer LCID=\"lang_replace\">{0}/AssociationServer.srf</AssociationServer>  <AssociationServerPK LCID=\"lang_replace\">{0}/pksecure/AssociationServerPK.srf</AssociationServerPK>  <AssociationServerWSDL LCID=\"lang_replace\">{0}/AssociationServerWSDL.srf</AssociationServerWSDL>  <Auth LCID=\"lang_replace\">{0}/login.srf?lc=%L</Auth>  <PPAuth LCID=\"lang_replace\">{0}/login.srf?lc=%L</PPAuth>  <Auth1dot4 LCID=\"lang_replace\">{0}/login2.srf?lc=%L</Auth1dot4>  <AuthSecure LCID=\"lang_replace\">{0}/ppsecure/secure.srf?lc=%L</AuthSecure>  <PPAuthSecure LCID=\"lang_replace\">{0}/ppsecure/secure.srf?lc=%L</PPAuthSecure>  <AuthZ LCID=\"lang_replace\">{0}</AuthZ>  <AuthZServer LCID=\"lang_replace\">{0}/AuthorizationServer.srf</AuthZServer>  <AuthZServerPK LCID=\"lang_replace\">{0}/pksecure/AuthorizationServerPK.srf</AuthZServerPK>  <AuthZServerWSDL LCID=\"lang_replace\">{0}/AuthorizationServerWSDL.srf</AuthZServerWSDL>  <BrandName LCID=\"lang_replace\">Windows Live ID</BrandName>  <CertAuth LCID=\"lang_replace\">{0}/pksecure/certlogin.srf</CertAuth>  <ChangeAltEmail LCID=\"lang_replace\">{0}/ChangeAltEmail.srf?lc=%L</ChangeAltEmail>  <ChangeMemName LCID=\"lang_replace\">{0}/ChangeName.srf?lc=%L</ChangeMemName>  <ChangePassword LCID=\"lang_replace\">{0}/ChangePW.srf?lc=%L</ChangePassword>  <ChangeSecretQ LCID=\"lang_replace\">{0}/ChangeSQ.srf?lc=%L</ChangeSecretQ>  <CollectTOU LCID=\"lang_replace\">{0}/regprofileaccrual.srf?lc=%L</CollectTOU>  <Consent LCID=\"lang_replace\">{0}</Consent>  <ConsentServer LCID=\"lang_replace\">{0}/ConsentServer.srf</ConsentServer>  <ConsentServerPK LCID=\"lang_replace\">{0}/pksecure/ConsentServerPK.srf</ConsentServerPK>  <ConsentServerWSDL LCID=\"lang_replace\">{0}/ConsentServerWSDL.srf</ConsentServerWSDL>  <CookieDomain LCID=\"lang_replace\"></CookieDomain>  <COPPAPOLICY LCID=\"lang_replace\">{0}/ppnetworkhome.srf?lc=%L</COPPAPOLICY>  <COPPARelRequestResponse LCID=\"lang_replace\">{0}/ParentsIntro.srf?lc=%L</COPPARelRequestResponse>  <CustomerService LCID=\"lang_replace\">{0}/gls.srf?lc=%L&amp;urlID=ContactUs</CustomerService>  <DAExpireCookie LCID=\"lang_replace\">{0}/expirecookie.srf</DAExpireCookie>"+
                                            "<DefaultReturn LCID=\"lang_replace\">{0}/?lc=%L</DefaultReturn>  <DefaultLogoutReturn LCID=\"lang_replace\">{0}/gls.srf?urlID=msnhome&amp;lc=%L</DefaultLogoutReturn>  <DefaultSiteId LCID=\"lang_replace\">3</DefaultSiteId>  <DelegatedAdmin LCID=\"lang_replace\">{0}/DelegatedAdmin.wsdl</DelegatedAdmin>  <DigestLogin LCID=\"lang_replace\">{0}/digest.srf</DigestLogin>  <EditProfile LCID=\"lang_replace\">{0}/editprof.srf?lc=%L</EditProfile> 	<EmailPwdReset LCID=\"lang_replace\">{0}/resetpw.srf?lc=%L</EmailPwdReset> 	<EmailValidation LCID=\"lang_replace\">{0}/emailverify.srf?lc=%L</EmailValidation> 	<EmailValidationUI LCID=\"lang_replace\">{0}/emailval.srf?lc=%L</EmailValidationUI> 	<EncryptedProxiedAuth LCID=\"lang_replace\">{0}/proxyrst.srf?lc=%L</EncryptedProxiedAuth> 	<RSAPublicKey LCID=\"lang_replace\">{0}/ppsecure/JSPublicKey.srf</RSAPublicKey> 	<RSAJscript LCID=\"lang_replace\">{0}/ppsecure/js/PPRSAEnc.js</RSAJscript> 	<ForceHIP LCID=\"lang_replace\">{0}/forcehip.srf?lc=%L</ForceHIP> 	<HIPAudio LCID=\"lang_replace\">{0}/hipaudio.srf?lc=%L</HIPAudio> 	<HotmailCloseAccount LCID=\"lang_replace\">{0}/cgi-bin/sbox?rru=Accountclose</HotmailCloseAccount> 	<HotmailSupport LCID=\"lang_replace\">{0}/gls.srf?urlID=contactUs&amp;lc=%L</HotmailSupport> 	<KidsPassport LCID=\"lang_replace\">{0}/?lc=%L</KidsPassport> 	<LogoUrl LCID=\"lang_replace\">{0}/clientlogo.bmp</LogoUrl> 	<Logout LCID=\"lang_replace\">{0}/logout.srf?lc=%L</Logout> 	<PPLogout LCID=\"lang_replace\">{0}/logout.srf?lc=%L</PPLogout> 	<Mail LCID=\"lang_replace\">2</Mail> 	<ManageConsent LCID=\"lang_replace\">{0}/?lc=%L</ManageConsent> 	<MD5Auth LCID=\"lang_replace\">{0}/ppsecure/md5auth.srf?lc=%L</MD5Auth>"+ 	
                                            "<MD5Silent LCID=\"lang_replace\">{0}/md5silent.srf?lc=%L</MD5Silent> 	<MemSvc LCID=\"lang_replace\">702</MemSvc> 	<MessengerSupport LCID=\"lang_replace\">False</MessengerSupport> 	<MExists LCID=\"lang_replace\">{0}/md5silent.srf?lc=%L</MExists> 	<MobilePin LCID=\"lang_replace\">{0}/mobilecreds.srf?lc=%L</MobilePin> 	<MPP LCID=\"lang_replace\">{0}/</MPP> 	<MPPEdit LCID=\"lang_replace\">{0}/Edit.asp?lc=%L</MPPEdit> 	<NexusRedir LCID=\"lang_replace\">{0}/redir.asp</NexusRedir> 	<PaneHelpBase LCID=\"lang_replace\">{0}/</PaneHelpBase> 	<PaneHelpWLBase LCID=\"lang_replace\">{0}/</PaneHelpWLBase> 	<PassportHome LCID=\"lang_replace\">{0}/?lc=%L</PassportHome> 	<PassportImages LCID=\"lang_replace\">{0}/%L</PassportImages> 	<PassportInformationCenter LCID=\"lang_replace\">{0}/?lc=%L</PassportInformationCenter> 	<PassportNetworkHome LCID=\"lang_replace\">{0}/ppnetworkhome.srf?lc=%L</PassportNetworkHome> 	<PassportSettings LCID=\"lang_replace\">{0}</PassportSettings> 	<PassportSettingsServer LCID=\"lang_replace\">{0}/PPSettingsServer.srf</PassportSettingsServer> 	<PassportSettingsServerPK LCID=\"lang_replace\">{0}/pksecure/PPSettingsServerPK.srf</PassportSettingsServerPK> 	<PassportSettingsServerWSDL LCID=\"lang_replace\">{0}/PPSettingsServerWSDL.srf</PassportSettingsServerWSDL> 	<PassportSupport LCID=\"lang_replace\">{0}/gls.srf?urlID=contactUsPPN&amp;lc=%L</PassportSupport> 	<PasswordReset LCID=\"lang_replace\">{0}/resetpw.srf?lc=%L</PasswordReset> 	<PinPost LCID=\"lang_replace\">{0}/ppsecure/pinpost.srf?lc=%L</PinPost> 	<PinReg LCID=\"lang_replace\">{0}/pinreset.srf?lc=%L</PinReg> 	<PinReset LCID=\"lang_replace\">{0}/pinreset.srf?lc=%L</PinReset> 	<Post LCID=\"lang_replace\">{0}/ppsecure/post.srf?lc=%L</Post> 	<PPPost LCID=\"lang_replace\">{0}/ppsecure/post.srf?lc=%L</PPPost> 	<PostUpdate LCID=\"lang_replace\">{0}/ppsecure/silent.srf?lc=%L</PostUpdate> 	<PPDelete LCID=\"lang_replace\">{0}/closepassport.srf?lc=%L</PPDelete> 	<PrivacyPolicy LCID=\"lang_replace\">{0}/PPPrivacyStatement.srf?lc=%L</PrivacyPolicy> 	<PrivacyText LCID=\"lang_replace\">{0}/privacytext.srf?lc=%L</PrivacyText> 	<ProxyAuth LCID=\"lang_replace\">{0}/ppsecure/ClientProxy.srf?lc=%L</ProxyAuth> 	<Reauth LCID=\"lang_replace\">{0}/ppsecure/silent.srf?lc=%L</Reauth> 	<Registration LCID=\"lang_replace\">{0}/reg.srf?lc=%L</Registration> 	<RemoveAltEmail LCID=\"lang_replace\">{0}/RemoveAltEmail.srf?lc=%L</RemoveAltEmail>"+
                                            "<RemPassport LCID=\"lang_replace\"></RemPassport> 	<RevalidateEmailUrl LCID=\"lang_replace\">{0}/reval.srf?lc=%L</RevalidateEmailUrl> 	<SecureSigninGIF LCID=\"lang_replace\">{0}/%L/signin.gif</SecureSigninGIF> 	<SecureSigninLogo><![CDATA[<IMG SRC=\"{0}/1033/signin.gif\" CLASS=\"PassportSignIn\" BORDER=\"0\" ALT=\"Sign in to Windows Live ID\" ID=\"idSI\"/>]]></SecureSigninLogo> 	<SecureSigninLogoDefault LCID=\"lang_replace\"><![CDATA[<IMG SRC=\"{0}/%L/signin.gif\" CLASS=\"PassportSignIn\" BORDER=\"0\" ALT=\"Windows Live ID\" ID=\"idSI\"/>]]></SecureSigninLogoDefault> 	<SecureSignoutGIF LCID=\"lang_replace\">{0}/%L/signout.gif</SecureSignoutGIF> 	<SecureSignoutLogo><![CDATA[<IMG SRC=\"{0}/1033/signout.gif\" CLASS=\"PassportSignOut\" BORDER=\"0\" ALT=\"Sign out of Windows Live ID\" ID=\"idSO\"/>]]></SecureSignoutLogo> 	<SecureSignoutLogoDefault LCID=\"lang_replace\"><![CDATA[<IMG SRC=\"{0}/%L/signout.gif\" CLASS=\"PassportSignOut\" BORDER=\"0\" ALT=\"Windows Live ID\" ID=\"idSO\"/>]]></SecureSignoutLogoDefault> 	<SAPIAuthZ LCID=\"lang_replace\">{0}</SAPIAuthZ> 	<ServiceAPIAuthZServer LCID=\"lang_replace\">{0}/PPSAAuthz.srf</ServiceAPIAuthZServer> 	<ServiceAPIAuthZServerPK LCID=\"lang_replace\">{0}/pksecure/PPSAAuthzPK.srf</ServiceAPIAuthZServerPK> 	<ServiceAPIAuthZServerWSDL LCID=\"lang_replace\">{0}/PPSAAuthzWSDL.srf</ServiceAPIAuthZServerWSDL> 	<SAPICred LCID=\"lang_replace\">{0}</SAPICred> 	<ServiceAPICredentialServer LCID=\"lang_replace\">{0}/PPSACredential.srf</ServiceAPICredentialServer> 	<ServiceAPICredentialServerPK LCID=\"lang_replace\">{0}/pksecure/PPSACredentialPK.srf</ServiceAPICredentialServerPK> 	<ServiceAPICredentialServerWSDL LCID=\"lang_replace\">{0}/PPSACredentialWSDL.srf</ServiceAPICredentialServerWSDL> 	<SAPICSRExtProf LCID=\"lang_replace\">{0}</SAPICSRExtProf> 	<ServiceAPICSRExtProfileServer LCID=\"lang_replace\">{0}/PPSACSRExtProf.srf</ServiceAPICSRExtProfileServer> 	<ServiceAPICSRExtProfileServerPK LCID=\"lang_replace\">{0}/pksecure/PPSACSRExtProfPK.srf</ServiceAPICSRExtProfileServerPK> 	<ServiceAPICSRExtProfileServerWSDL LCID=\"lang_replace\">{0}/PPSACSRExtProfWSDL.srf</ServiceAPICSRExtProfileServerWSDL> 	<SAPINS LCID=\"lang_replace\">{0}</SAPINS> 	<ServiceAPINameSpaceServer LCID=\"lang_replace\">{0}/PPSANamespace.srf</ServiceAPINameSpaceServer> 	<ServiceAPINameSpaceServerPK LCID=\"lang_replace\">{0}/pksecure/PPSANamespacePK.srf</ServiceAPINameSpaceServerPK> 	<ServiceAPINameSpaceServerWSDL LCID=\"lang_replace\">{0}/PPSANamespaceWSDL.srf</ServiceAPINameSpaceServerWSDL>"+ 	
                                            "<AppIDServiceAPIServer LCID=\"lang_replace\">{0}/AppIDService.srf</AppIDServiceAPIServer> 	<AppIDServiceAPIServerPK LCID=\"lang_replace\">{0}/pksecure/AppIDServicePK.srf</AppIDServiceAPIServerPK> 	<AppIDServiceAPIServerWSDL LCID=\"lang_replace\">{0}/AppIDServiceWSDL.srf</AppIDServiceAPIServerWSDL> 	<SAPIProf LCID=\"lang_replace\">{0}</SAPIProf> 	<ServiceAPIProfileServer LCID=\"lang_replace\">{0}/PPSAProfile.srf</ServiceAPIProfileServer> 	<ServiceAPIProfileServerPK LCID=\"lang_replace\">{0}/pksecure/PPSAProfilePK.srf</ServiceAPIProfileServerPK> 	<ServiceAPIProfileServerWSDL LCID=\"lang_replace\">{0}/PPSAProfileWSDL.srf</ServiceAPIProfileServerWSDL> 	<SAPIRep LCID=\"lang_replace\">{0}</SAPIRep> 	<ServiceAPIReportServer LCID=\"lang_replace\">{0}/PPSACSR.srf</ServiceAPIReportServer> 	<ServiceAPIReportServerPK LCID=\"lang_replace\">{0}/pksecure/PPSACSRPK.srf</ServiceAPIReportServerPK> 	<ServiceAPIReportServerWSDL LCID=\"lang_replace\">{0}/PPSACSRWSDL.srf</ServiceAPIReportServerWSDL> 	<SAPISite LCID=\"lang_replace\">{0}</SAPISite> 	<ServiceAPISiteServer LCID=\"lang_replace\">{0}/PPSASite.srf</ServiceAPISiteServer> 	<ServiceAPISiteServerPK LCID=\"lang_replace\">{0}/pksecure/PPSASitePK.srf</ServiceAPISiteServerPK> 	<ServiceAPISiteServerWSDL LCID=\"lang_replace\">{0}/PPSASiteWSDL.srf</ServiceAPISiteServerWSDL> 	<HIPSOAPServer LCID=\"lang_replace\">{0}</HIPSOAPServer> 	<HIPSOAPServerPK LCID=\"lang_replace\">{0}/pksecure/HIPServerPK.srf</HIPSOAPServerPK> 	<HIPSOAPServerWSDL LCID=\"lang_replace\">{0}/HIPServerWSDL.srf</HIPSOAPServerWSDL>"+ 	
                                            "<ServiceClass1RegistrationAuthority LCID=\"lang_replace\">{0}</ServiceClass1RegistrationAuthority> 	<ServiceClass1RegistrationAuthorityApprove LCID=\"lang_replace\">{0}/pksecure/Cls1RA.srf</ServiceClass1RegistrationAuthorityApprove> 	<ServiceClass1RegistrationAuthorityProvision LCID=\"lang_replace\">{0}/ppsecure/Cls1RA.srf</ServiceClass1RegistrationAuthorityProvision> 	<ServiceClass1RegistrationAuthorityWSDL LCID=\"lang_replace\">{0}/Cls1RAWSDL.srf</ServiceClass1RegistrationAuthorityWSDL> 	<SigninGIF LCID=\"lang_replace\">{0}/%L/signin.gif</SigninGIF> 	<SigninLogo><![CDATA[<IMG SRC=\"{0}/1033/signin.gif\" CLASS=\"PassportSignIn\" BORDER=\"0\" ALT=\"Sign in to Windows Live ID\" ID=\"idSI\"/>]]></SigninLogo> 	<SigninLogoDefault LCID=\"lang_replace\"><![CDATA[<IMG SRC=\"{0}/%L/signin.gif\" CLASS=\"PassportSignIn\" BORDER=\"0\" ALT=\"Windows Live ID\" ID=\"idSI\"/>]]></SigninLogoDefault> 	<SignoutGIF LCID=\"lang_replace\">{0}/%L/signout.gif</SignoutGIF> 	<SignoutIconUrl LCID=\"lang_replace\">{0}/signouticon.bmp</SignoutIconUrl> 	<SignoutLogo><![CDATA[<IMG SRC=\"{0}/1033/signout.gif\" CLASS=\"PassportSignOut\" BORDER=\"0\" ALT=\"Sign out of Windows Live ID\" ID=\"idSO\"/>]]></SignoutLogo> 	<SignoutLogoDefault LCID=\"lang_replace\"><![CDATA[<IMG SRC=\"{0}/%L/signout.gif\" CLASS=\"PassportSignOut\" BORDER=\"0\" ALT=\"Windows Live ID\" ID=\"idSO\"/>]]></SignoutLogoDefault> 	<SupplementalAuthUrl LCID=\"lang_replace\"></SupplementalAuthUrl> 	<TermsOfUse LCID=\"lang_replace\">{0}/PPTOU.srf?lc=%L</TermsOfUse> 	<TermsOfUseText LCID=\"lang_replace\">{0}/termsofusetext.srf?lc=%L</TermsOfUseText>"+ 	
                                            "<TexasConsentResponse LCID=\"lang_replace\">{0}/fwlink/?linkid=8698</TexasConsentResponse> 	<TexasPCPage LCID=\"lang_replace\">{0}/fwlink/?linkid=8710</TexasPCPage> 	<Update LCID=\"lang_replace\"><![CDATA[<IMG SRC=\"{0}/update.srf$1&lc=%L\" BORDER=\"0\" ALT=\"Windows Live ID\"/>]]></Update> 	<UpdateSecure LCID=\"lang_replace\">{0}/update.srf</UpdateSecure> 	<WirelessAuth LCID=\"lang_replace\">{0}/login.srf?lc=%L</WirelessAuth> 	<WirelessPost LCID=\"lang_replace\"></WirelessPost> 	<WirelessReauth LCID=\"lang_replace\">{0}/ppsecure/silent.srf?lc=%L</WirelessReauth> 	<WirelessRegistration LCID=\"lang_replace\">{0}/reg.srf?lc=%L</WirelessRegistration> 	<XMLEditPassword LCID=\"lang_replace\">{0}/ppsecure/MSRV_ChangePW_ClientPost.srf</XMLEditPassword> 	<XMLLogin LCID=\"lang_replace\">{0}/ppsecure/clientpost.srf</XMLLogin> 	<XMLLogout LCID=\"lang_replace\">{0}/logoutxml.srf</XMLLogout> 	<MobileXMLLogin LCID=\"lang_replace\">{0}/mobilelogin.srf</MobileXMLLogin> 	<MobileXMLLogout LCID=\"lang_replace\">{0}/mobilelogout.srf</MobileXMLLogout> 	<XMLProfileRequest LCID=\"lang_replace\">{0}/ppsecure/ClientProfileRequest.srf</XMLProfileRequest> 	<XMLRegistration LCID=\"lang_replace\">{0}/clientreg.srf</XMLRegistration> 	<XMLResetPassword LCID=\"lang_replace\">{0}/ppsecure/MSRV_ResetPW_ClientPost.srf</XMLResetPassword> 	<XMLUpdate LCID=\"lang_replace\">{0}/ClientEditProf.srf</XMLUpdate> 	<LWAAuth LCID=\"lang_replace\">{0}/wlogin.srf</LWAAuth> 	<MobileServerAuth LCID=\"lang_replace\">{0}/login.srf?lc=%L</MobileServerAuth> 	<MobileServerLogout LCID=\"lang_replace\">{0}/logout.srf?lc=%L</MobileServerLogout> 	<MobileServerReg LCID=\"lang_replace\">{0}/ac?lc=%L</MobileServerReg> 	<MobilePost LCID=\"lang_replace\">{0}/ppsecure/post.srf?lc=%L</MobilePost> 	<MobileReg LCID=\"lang_replace\">{0}/MobileReg.srf?lc=%L</MobileReg> 	</Domain> 	</PassportNetwork> 	<Schemata> 	<Schema Name=\"core\" Version=\"1\"> 	<Attribute Name=\"memberName\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"memberIdLow\" Type=\"long\" Access=\"ro\"/> 	<Attribute Name=\"memberIdHigh\" Type=\"long\" Access=\"ro\"/> 	<Attribute Name=\"profileVersion\" Type=\"long\" Access=\"ro\"/> 	<Attribute Name=\"country\" Type=\"char\" Access=\"ro\" Size=\"2\"/> 	<Attribute Name=\"postalCode\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"region\" Type=\"long\" Access=\"ro\"/> 	<Attribute Name=\"city\" Type=\"long\" Access=\"ro\"/> 	<Attribute Name=\"lang_preference\" Type=\"word\" Access=\"ro\"/>"+
                                            "<Attribute Name=\"bday_precision\" Type=\"byte\" Access=\"ro\"/> 	<Attribute Name=\"birthdate\" Type=\"date\" Access=\"ro\"/> 	<Attribute Name=\"gender\" Type=\"char\" Access=\"ro\" Size=\"1\"/> 	<Attribute Name=\"preferredEmail\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"nickname\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"accessibility\" Type=\"byte\" Access=\"ro\"/> 	<Attribute Name=\"wallet\" Type=\"long\"/> 	<Attribute Name=\"directory\" Type=\"long\"/> 	<Attribute Name=\"\" Type=\"byte\"/> 	<Attribute Name=\"flags\" Type=\"long\"/> 	<Attribute Name=\"Firstname\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"Lastname\" Type=\"text\" Access=\"ro\"/> 	<Attribute Name=\"timezone\" Type=\"word\" Access=\"ro\"/> 	<Attribute Name=\"occupation\" Type=\"text\" Access=\"ro\"/> 	</Schema> 	</Schemata> 	<TicketSchemata> 	<Schema Name=\"core\" Version=\"3\"> 	<Attribute Name=\"DA-Skew\" Type=\"long\"/> 	<Attribute Name=\"CredInfo\" Type=\"long\"/> 	<Attribute Name=\"PassportFlags\" Type=\"long\"/> 	<Attribute Name=\"PinTime\" Type=\"long\"/> 	<Attribute Name=\"SiteCtxt\" Type=\"text\"/> 	<Attribute Name=\"CertIssuer\" Type=\"text\"/> 	<Attribute Name=\"MemberName\" Type=\"text\"/> 	<Attribute Name=\"CIDL\" Type=\"long\"/> 	<Attribute Name=\"CIDH\" Type=\"long\"/> 	</Schema> 	</TicketSchemata> 	<GenInfo> 	<DateTime>YYYY/MM/DD HH:MM:SS of run: 2007/07/10 00:05:31</DateTime> 	<InputFile>Input file run: file:///F:/pp50/Output/RELEASE/i386/setup/msi/Config/ClusterSpecific/int/PartnerXML/PartnerTemplate.xml</InputFile> 	<Server>Run on Server: PASSBLD08</Server> 	<EXEPath>Path to EXE: F:\\pp50\\passport\\Config\\Tools\\XMLGen\\XMLGen.wsf</EXEPath> 	<EnvOutput>Environments made in the run: int</EnvOutput> 	<Who>Who made the run: REDMOND\\ppbuild</Who> 	</GenInfo> </Partner>";
                            break;

                            default:
                            baseXML = "<SOAP:Envelope xmlns:SOAP=\"http://schemas.xmlsoap.org/soap/envelope/\"><SOAP:Body><GetSigninNamesAndCIDsForNetIDsResponse><pbstrCredXML><NETID2Name><SigninName NetID=\"0003000080091C04\" CID=\"5d0f2e073583de53\">someone@microsoft.com</SigninName></NETID2Name></pbstrCredXML></GetSigninNamesAndCIDsForNetIDsResponse></SOAP:Body></SOAP:Envelope>";
                            break;
                    }

                    return baseXML;
                }
            
            }


            private static string RequestToString(HttpListenerRequest request)
            {
                Stream stream = request.InputStream;
                long length = request.ContentLength64;
                return OutStreamToString(stream, length);

            }

            private static string OutStreamToString(Stream stream, long length)
            {
                Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                // Pipes the stream to a higher level stream reader with the required encoding format. 
                StreamReader readStream = new StreamReader(stream, encode);
                char[] read = new char[length];
                int count = readStream.Read(read, 0, read.Length);
                //respData = Encoding.UTF8.GetString(read);
                return new String(read, 0, count);
            }



        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\WireDataFuzzer.cs ===
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.IO;

using DeterministicRandom = ServerTestFramework.STFLive.Utilities.DeterministicRandom;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// An exception in the FuzzDataAttribute space.
    /// </summary>
    public class FuzzDataAttributeException : Exception
    {
        /// <summary>
        /// Creates a new exception with the given message.
        /// </summary>
        /// <param name="message">A message which describes the error.</param>
        public FuzzDataAttributeException (string message) : base(message) { }

        /// <summary>
        /// Creates a new exception with the given message and type.
        /// </summary>
        /// <param name="message">A message which describes the error.</param>
        /// <param name="t">The type that caused the error.</param>
        public FuzzDataAttributeException (string message, Type t) : base(t.ToString() + " :: " + message) { }

        /// <summary>
        /// Creates a new exception with the given message and type.
        /// </summary>
        /// <param name="message">A message which describes the error.</param>
        /// <param name="t">The type that caused the error.</param>
        /// <param name="e">The inner exception.</param>
        public FuzzDataAttributeException (string message, Type t, Exception e) : 
            base(t.ToString() + " :: " + message, e) { }
    }

    /// <summary>
    /// Attribute for marking fields and classes for fuzzing.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple=false, Inherited=true)]
    public class FuzzDataAttribute : Attribute
    {
        #region Attribute Fields

        /// <summary>Used to turn fuzzing on and off.</summary>
        public bool Fuzz = true;

        /// <summary>The chance that a given field will be fuzzed.</summary>
        public double Probability = 1.0;

        /// <summary>
        /// If true, this field will be fuzzed using a recorded or given seed value, and the iterations tracked.
        /// Useful for recreating past events.  See RandomSeed.
        /// </summary>
        public bool Deterministic = false;

        /// <summary>
        /// If Deterministic is true and RandomSeed is non-negative, this value will be used as the seed for the 
        /// random number generator.
        /// </summary>
        public int RandomSeed = -1;

        /// <summary>
        /// If true, the field will simply be filled with random bytes.
        /// </summary>
        public bool RandomBytes = false;

        #region Field Update Functions

        /// <summary>
        /// Sets up the deterministic random as requested.
        /// </summary>
        /// <param name="isDeterministic">The value to change Deterministic to.</param>
        /// <param name="seed">The value to change RandomSeed to.</param>
        /// <remarks>
        /// Would have done it in a property, but Attributes need fields.
        /// </remarks>
        public void SetDeterminism (bool isDeterministic, int seed)
        {
            if (Deterministic != isDeterministic)
            {
                Deterministic = isDeterministic;
                DetRandom = (Deterministic ? new DeterministicRandom(seed) : null);
            }

            if (RandomSeed != seed)
            {
                RandomSeed = seed;
                DetRandom.Seed = seed;
            }
        }

        #endregion

        #endregion

        #region Properties

        #region NonPublic

        /// <summary>
        /// Contains the name/value pairs passed in to the attribute.
        /// </summary>
        protected Dictionary<string, object> _Properties = null;

        /// <summary>
        /// Gets the name/value pairs passed in to the attribute.
        /// </summary>
        internal Dictionary<string, object> Properties
        {
            get
            {
                return _Properties;
            }
        }

        /// <summary>
        /// The deterministic random number generator, if one is requested.
        /// </summary>
        protected DeterministicRandom DetRandom = null;

        /// <summary>
        /// A custom serializer writes an object to a stream using the provided writer.
        /// </summary>
        /// <param name="writer">The writer to write with.</param>
        /// <param name="obj">The object to write.</param>
        protected delegate void CustomSerializer (BinaryWriter writer, object obj);

        /// <summary>
        /// Serialization function used to write objects in the standard method.
        /// Change it if custom serialization is needed, otherwise the default is WireData.BinaryWriteValue.
        /// </summary>
        protected CustomSerializer StandardSerializer = new CustomSerializer(WireData.BinaryWriteValue);

        /// <summary>
        /// Serialization function used to write random bytes.
        /// The default is InefficientRandomBytesWriter;
        /// </summary>
        protected CustomSerializer RandomByteSerializer = null;

        #endregion

        #region Public

        /// <summary>
        /// If not null, contains the fully typed attribute.
        /// </summary>
        private FuzzDataAttribute _actual = null;

        /// <summary>
        /// The fully typed <c>FuzzDataAttribute</c>.
        /// </summary>
        public FuzzDataAttribute Actual
        {
            get
            {
                return (_actual == null ? this : _actual);
            }
        }

        /// <summary>
        /// Cache for holding the list of fields for each type derived from FuzzFieldAttribute.
        /// </summary>
        private static Dictionary<Type, FieldInfo[]> FuzzFieldCache = new Dictionary<Type, FieldInfo[]>();

        /// <summary>
        /// Returns the FieldInfo from the fuzzFieldCache. If
        /// it doesn't exist, it will add it and then return it.
        /// </summary>
        public FieldInfo[] Fields
        {
            get
            {
                lock (FuzzFieldCache)
                {
                    Type fieldType = this.GetType();
                    if (FuzzFieldCache.ContainsKey(fieldType))
                    {
                        return FuzzFieldCache[fieldType];
                    }
                    else // Add the new FieldInfo[] and return that.
                    {
                        FieldInfo[] fields = fieldType.GetFields();
                        FuzzFieldCache[fieldType] = fields;
                        return fields;
                    }
                }
            }
        }
        

        #endregion

        #endregion

        #region Constructors

        /// <summary>
        /// Static constructor loads type associations.  Still safe to call SearchAllAssemblies again.
        /// </summary>
        static FuzzDataAttribute ()
        {
            SearchAllAssemblies();
        }

        /// <summary>
        /// Creates a new instance of the class using the defaults.
        /// </summary>
        public FuzzDataAttribute ()
        {
            ConstructorCommon();
        }

        /// <summary>
        /// Creates a new instance of the class using the given value for Fuzz.
        /// </summary>
        /// <param name="fuzz">The value to set Fuzz to initially.</param>
        public FuzzDataAttribute (bool fuzz)
        {
            Fuzz = fuzz;
            ConstructorCommon();
        }

        /// <summary>
        /// Creates a new instance, using the list of name/value pairs.
        /// </summary>
        /// <param name="objs">A list of name/value pairs that will be propagated to the appropriate class.</param>
        public FuzzDataAttribute (params object[] objs)
        {
            if (objs.Length % 2 != 0)
            {
                throw new ArgumentException("The properties passed in must be name/value pairs.", "objs");
            }

            if (objs.Length > 0)
            {
                _Properties = new Dictionary<string, object>(objs.Length / 2);
            }

            // we have pairs, and at least one
            for (int i = 0; i < objs.Length; i += 2)
            {
                string name = objs[i] as string;
                if (name == null)
                {
                    throw new ArgumentException("The names of the properties must be strings.", "objs");
                }

                if (_Properties.ContainsKey(name))
                {
                    throw new ArgumentException("The names of the properties must be unique ('" + name + 
                        "' was repeated).", "objs");
                }

                _Properties.Add(name, objs[i + 1]);
            }

            ConstructorCommon();
        }

        /// <summary>
        /// All constructors should call this.
        /// </summary>
        private void ConstructorCommon ()
        {
            if (Deterministic)
            {
                if (RandomSeed >= 0)
                {
                    DetRandom = new DeterministicRandom(RandomSeed);
                }
                else
                {
                    DetRandom = new DeterministicRandom();
                }
            }

            RandomByteSerializer = new CustomSerializer(InefficientRandomBytesWriter);
        }

        #endregion

        #region Fuzz Type Registration

        #region NonPublic

        /// <summary>
        /// The mapping from field types to FuzzDataAttribute derived classes.
        /// </summary>
        private static Dictionary<Type, Type> _factory_map = null;
        private static ReaderWriterLock _factory_map_lock = new ReaderWriterLock();

        /// <summary>
        /// Maps a field type to a FuzzDataAttribute type.
        /// </summary>
        /// <param name="t">The field type to map.</param>
        /// <returns>The FuzzDataAttribute type</returns>
        protected static Type MapFieldType (Type t)
        {
            // special case for arrays and strings
            if (t.IsArray || t == typeof(string))
            {
                return typeof(FuzzArrayAttribute);
            }

            try
            {
                _factory_map_lock.AcquireReaderLock(10);

                if (_factory_map == null)
                {
                    return typeof(FuzzDataAttribute);
                }

                if (_factory_map.ContainsKey(t))
                {
                    return _factory_map[t];
                }
                else
                {
                    // this method only gives the first ancestor match, may need to consider getting the closest
                    // ancestor as C# will always have exactly 1 closest
                    foreach (Type keyType in _factory_map.Keys)
                    {
                        if (t.IsSubclassOf(keyType))
                        {
                            return _factory_map[keyType];
                        }
                    }
                }

                // default
                return typeof(FuzzDataAttribute);
            }
            finally
            {
                // making it here means we acquired the lock
                _factory_map_lock.ReleaseReaderLock();
            }
        }

        /// <summary>
        /// Specializes a generic type with the param type.
        /// </summary>
        /// <param name="generic">The generic type to specialize.</param>
        /// <param name="param">The type to specialize by.</param>
        /// <returns>The type specialized with the param.</returns>
        private static Type SpecializeGenericType (Type generic, Type param)
        {
            if (generic.GetGenericArguments().Length > 1)
            {
                throw new FuzzDataAttributeException("Cannot have more than one generic parameter.", generic);
            }

            Type[] arr = new Type[1] { param };

            return generic.MakeGenericType(arr);
        }

        /// <summary>
        /// Invokes the default constructor on the given type.
        /// </summary>
        /// <param name="t">The type to construct.</param>
        /// <returns>An object of the given type.</returns>
        private static object InvokeDefaultConstructor (Type t)
        {
            return t.InvokeMember(null, BindingFlags.CreateInstance | BindingFlags.DeclaredOnly |
                BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public, null, null,
                new object[] { });
        }

        /// <summary>
        /// Associates an array of types with an attribute type.
        /// </summary>
        /// <param name="associates">The types that can be fuzzed by the attribute.</param>
        /// <param name="t">The attribute type to associate.</param>
        private static void AssociateTypesToAttribute (Type[] associates, Type t)
        {
            if (associates == null)
            {
                return;
            }

            try
            {
                _factory_map_lock.AcquireWriterLock(10);

                if (_factory_map == null)
                {
                    _factory_map = new Dictionary<Type, Type>();
                }

                foreach (Type assoc in associates)
                {
                    if (_factory_map.ContainsKey(assoc))
                    {
                        // allow a subclass of the one that is there to override
                        if (t.IsSubclassOf(_factory_map[assoc]))
                        {
                            _factory_map[assoc] = t;
                        }
                        // if a superclass (or repeat) of the one that is there comes later, don't throw
                        else if (! t.IsAssignableFrom(_factory_map[assoc]))
                        {
                            throw new FuzzDataAttributeException("Fuzz types collision: Type '" +
                                _factory_map[assoc].ToString() + "' already claimed '" + assoc.ToString() + "'.", t);
                        }
                    }
                    else
                    {
                        _factory_map.Add(assoc, t);
                    }
                }
            }
            finally
            {
                _factory_map_lock.ReleaseWriterLock();
            }
        }

        #endregion

        #region Public

        /// <summary>
        /// Searches all loaded assemblies for classes derived from <c>FuzzDataAttribute</c>.
        /// </summary>
        public static void SearchAllAssemblies ()
        {
            Assembly[] asms = AppDomain.CurrentDomain.GetAssemblies();

            foreach (Assembly asm in asms)
            {
                SearchAssembly(asm);
            }
        }

        /// <summary>
        /// Searches a specific assembly for classes derived from <c>FuzzDataAttribute</c>.
        /// </summary>
        /// <param name="asm">The assembly to search.</param>
        public static void SearchAssembly (Assembly asm)
        {
            List<Type> types = ReflectionUtils.GetDerivedTypes(asm, typeof(FuzzDataAttribute));

            foreach (Type t in types)
            {
                Type[] associates = null;

                // create an instance of the object, uses the default constructor
                object inst = null;

                try
                {
                    inst = InvokeDefaultConstructor(t);
                }
                catch (Exception e)
                {
                    throw new FuzzDataAttributeException("Error creating instance of type.", t, e);
                }

                try
                {
                    associates = ((FuzzDataAttribute) inst).GetFuzzTypes();
                }
                catch (Exception e)
                {
                    throw new FuzzDataAttributeException("Error calling GetFuzzTypes on instance.", t, e);
                }

                AssociateTypesToAttribute(associates, t);
            }
        }

        /// <summary>
        /// Attempts to create an attribute that is specialized for the given type.
        /// </summary>
        /// <param name="t">The type to specialize for.</param>
        public void BindType (Type t)
        {
            Type this_type = this.GetType();
            Type attr_type = MapFieldType(t);

            // if we aren't IsAssignableFrom, we need to change the bound type
            if (! attr_type.IsAssignableFrom(this_type))
            {
                try
                {
                    _actual = (FuzzDataAttribute) InvokeDefaultConstructor(attr_type);
                }
                catch (Exception e)
                {
                    throw new FuzzDataAttributeException("Error creating instance of type.", attr_type, e);
                }

                _actual.InheritProperties(this);
            }

            // for arrays and strings, we need to set up the element fuzzer
            if (typeof(FuzzArrayAttribute).IsAssignableFrom(attr_type))
            {
                Type elem_type = MapFieldType(t.IsArray ? t.GetElementType() : typeof(char));

                FuzzDataAttribute elem_attr = null;

                try
                {
                    elem_attr = (FuzzDataAttribute) InvokeDefaultConstructor(elem_type);
                }
                catch (Exception e)
                {
                    throw new FuzzDataAttributeException("Error creating instance of type.", elem_type, e);
                }

                (Actual as FuzzArrayAttribute).SetElementFuzz(elem_attr);
            }
        }

        #endregion

        #endregion

        #region Public Virtual (for override)

        /// <summary>
        /// Gets an array of types that this attribute can fuzz.
        /// </summary>
        /// <returns>An array of types that this attribute can fuzz.</returns>
        /// <remarks>
        /// This function should be static for the type, but C# does not support static functions in an interface.
        /// 
        /// For a generic type, this function will be called by specializing the generic using object and 
        /// calling through that type. Thus, GetFuzzTypes should be invariant by specialization.
        /// </remarks>
        public virtual Type[] GetFuzzTypes () { return Type.EmptyTypes; }

        /// <summary>
        /// Called when creating a more specific instance of a <c>FuzzDataAttribute</c>.
        /// </summary>
        /// <param name="fuzzAttr">The attribute to inherit properties from.</param>
        /// <example>
        /// Below is an example of how to implement the function properly:
        /// <code>
        /// class FooFuzzAttribute : FuzzDataAttribute
        /// {
        /// ...
        /// public override void InheritProperties (FuzzDataAttribute fuzzAttr)
        /// {
        ///     base.InheritProperties(fuzzAttr);
        /// 
        ///     FooFuzzAttribute fooFuzzAttr = fuzzAttr as FooFuzzAttribute;
        ///     if (fooFuzzAttr != null)
        ///     {
        ///         this.FooProperty = fooFuzzAttr.FooProperty;
        ///         ...
        ///     }
        /// 
        ///     if (fuzzAttr.Properties != null)
        ///     {
        ///         if (fuzzAttr.Properties.ContainsKey("FooProperty"))
        ///         {
        ///             this.FooProperty = (FooType) fuzzAttr.Properties["FooProperty"];
        ///         }
        ///         ...
        ///     }
        /// }
        /// ...
        /// }
        /// </code>
        /// </example>
        public virtual void InheritProperties (FuzzDataAttribute fuzzAttr)
        {
            this.Fuzz = fuzzAttr.Fuzz;
            this.Probability = fuzzAttr.Probability;
            this.Deterministic = fuzzAttr.Deterministic;
            this.RandomSeed = fuzzAttr.RandomSeed;
            this.RandomBytes = fuzzAttr.RandomBytes;

            ConstructorCommon();
        }

        /// <summary>
        /// Writes the object to the writer, possibly fuzzes the written value, but does not change it.
        /// </summary>
        /// <param name="bw">The destination to write to.</param>
        /// <param name="obj">The object to fuzz.</param>
        /// <returns>
        /// True if the object was fuzzed when writing; false if not.
        /// </returns>
        /// <remarks>
        /// This is the public face of fuzzing, it guarantees that the base class is respected and takes the
        /// burden of always checking it off of derived classes.
        /// </remarks>
        public bool FuzzWrite (BinaryWriter bw, object obj)
        {
            if (! FuzzCheck())
            {
                StandardSerializer(bw, obj);
                return false;
            }

            if (RandomBytes)
            {
                RandomByteSerializer(bw, obj);
            }
            else
            {
                FuzzWriteInternal(bw, obj);
            }

            return true;
        }

        /// <summary>
        /// Writes the object to the writer, possibly fuzzes the written value, but does not change it.
        /// The default implementation simply writes with no fuzzing.
        /// </summary>
        /// <param name="bw">The destination to write to.</param>
        /// <param name="obj">The object to fuzz.</param>
        protected virtual void FuzzWriteInternal (BinaryWriter bw, object obj)
        {
            StandardSerializer(bw, obj);
        }

        #endregion

        #region Helpful

        /// <summary>
        /// A thread static random number generator, we will assume that it is thread safe due to this.
        /// </summary>
        [ThreadStatic]
        private static Random _staRandom;

        /// <summary>
        /// Gets the thread static random number generator.
        /// </summary>
        protected static Random StaRandom
        {
            get
            {
                if (_staRandom == null)
                {
                    _staRandom = new Random((int) DateTime.Now.Ticks);
                }

                return _staRandom;
            }
        }

        /// <summary>
        /// Gets a random double from the correct source.
        /// </summary>
        /// <returns>A random double.</returns>
        protected double NextDouble ()
        {
            return (DetRandom != null ? DetRandom.NextDouble() : StaRandom.NextDouble());
        }

        /// <summary>
        /// Fills the given array with random bytes.
        /// </summary>
        /// <param name="bytes">The array to fill with random bytes.</param>
        protected void NextBytes (byte[] bytes)
        {
            if (DetRandom != null)
            {
                DetRandom.NextBytes(bytes);
            }
            else
            {
                StaRandom.NextBytes(bytes);
            }
        }

        /// <summary>
        /// Uses NextDouble to get a boolean value based on the probability given.
        /// </summary>
        /// <param name="prob">The probability that a value of true will be returned.</param>
        /// <returns>
        /// True if the value of NextDouble is less than the value given; false if not.
        /// Thus a given probability of 1 will always generate true, and 0 will always generate false.
        /// </returns>
        protected bool NextBool (double prob)
        {
            return (NextDouble() < prob);
        }

        /// <summary>
        /// Gets a value indicating whether fuzzing should be performed.
        /// </summary>
        /// <returns>True if fuzzing should occur; false if not.</returns>
        protected bool FuzzCheck ()
        {
            return (Fuzz && NextBool(Probability));
        }

        /// <summary>
        /// Determines the size of the object by serializing it.
        /// </summary>
        /// <param name="obj">The object to size.</param>
        /// <returns>The length of the byte stream after serializing.</returns>
        protected long InefficientSizeOf (object obj)
        {
            MemoryStream stream = new MemoryStream();
            BinaryWriter membw = new BinaryWriter(stream);

            StandardSerializer(membw, obj);

            return stream.Length;
        }

        /// <summary>
        /// Writes random bytes to the given writer based on the size of the given object.
        /// The size is determined by serializing the object, so if you determine it faster, use that size.
        /// </summary>
        /// <param name="bw">The writer to write with.</param>
        /// <param name="obj">The object to write.</param>
        protected void InefficientRandomBytesWriter (BinaryWriter bw, object obj)
        {
            byte[] bytes = new byte[InefficientSizeOf(obj)];
            NextBytes(bytes);
            bw.Write(bytes);
        }

        public FieldInfo GetFieldInfoByName (string Name )
        {
            FieldInfo[] fields = this.Fields;

            foreach (FieldInfo field in fields)
            {
                if (field.Name == Name)
                    return field;
            }
            return null;
        }

        #endregion
    }

    /// <summary>
    /// Extends the <c>FuzzDataAttribute</c> class to give more specific options for arrays and strings.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
    public class FuzzArrayAttribute : FuzzDataAttribute
    {
        #region Attribute Fields

        /// <summary>
        /// The chance that the null terminator status will be changed.
        /// </summary>
        public double NullTermProbability = 1.0;

        /// <summary>
        /// The chance that the number of elements written will be changed.
        /// </summary>
        public double LengthProbability = 1.0;

        /// <summary>
        /// The probability that an individual element will be fuzzed when written.
        /// </summary>
        public double ElementProbability = 1.0;

        #endregion

        #region Properties

        /// <summary>
        /// The fuzzer for individual elements of the array.
        /// </summary>
        protected FuzzDataAttribute ElementFuzz = null;

        #endregion

        /// <summary>
        /// Writes an array or string to the given destination.
        /// </summary>
        /// <param name="bw">The destination to write to.</param>
        /// <param name="obj">The object to write.</param>
        /// <param name="fi">The FieldInfo for the field that the object came from.</param>
        /// <param name="encoding">The encoding for string-like objects.</param>
        /// <param name="isNullTerm">If true and this is a string-like object, it will be null-terminated.</param>
        /// <param name="totalSize">If positive, the minimum number of elements to write.</param>
        /// <returns>
        /// True if the object was fuzzed when writing; false if not.
        /// </returns>
        /// <remarks>
        /// The base of this class is used to determine whether the entire array is fuzzed.  For individual element
        /// fuzzing probability, see ElementProbability.
        /// </remarks>
        public bool FuzzWriteArray (BinaryWriter bw, object obj, FieldInfo fi, Encoding encoding, 
            bool isNullTerm, int totalSize)
        {
            // check to see if we should be fuzzing
            if (FuzzCheck())
            {
                // sync with subclass
                ElementFuzz.Fuzz = true;
                ElementFuzz.Probability = ElementProbability;

                isNullTerm = (isNullTerm != NextBool(NullTermProbability));
                if (NextBool(LengthProbability))
                {
                    // for now we will change the length to between 0 and twice its size
                    totalSize = (int) (2 * totalSize * NextDouble() + 0.5);
                }
            }
            else
            {
                // sync with subclass
                ElementFuzz.Fuzz = false;
            }

            bool isUnicode = (encoding is UnicodeEncoding);
            int elementCount = 0;

            Array objArray = obj as Array;
            string objString = obj as string;

            if (obj != null)
            {
                if (fi.FieldType.IsArray)
                {
                    elementCount = objArray.Length;
                    elementCount = Math.Min(elementCount, totalSize);

                    // its just a string...
                    if (fi.FieldType.GetElementType() == typeof(char))
                    {
                        char[] objCharArray = (char[]) objArray;
                        byte[] bytes = new byte[(isUnicode ? 2 : 1)];

                        for (int j = 0; j < elementCount; ++j)
                        {
                            encoding.GetBytes(objCharArray, j, 1, bytes, 0);
                            ElementFuzz.FuzzWrite(bw, bytes);
                        }

                        if (isNullTerm)
                        {
                            ++elementCount;
                            encoding.GetBytes(new char[] { '\0' }, 0, 1, bytes, 0);
                            // direct write as we have already fuzzed the null terminator
                            bw.Write(bytes);
                        }
                    }
                    else
                    {
                        for (int j = 0; j < elementCount; ++j)
                        {
                            ElementFuzz.FuzzWrite(bw, objArray.GetValue(j));
                        }
                    }
                }
                // not an array, so it better be a string
                else
                {
                    elementCount = objString.Length;
                    elementCount = Math.Min(elementCount, totalSize);

                    byte[] bytes = new byte[(isUnicode ? 2 : 1)];

                    for (int j = 0; j < elementCount; ++j)
                    {
                        encoding.GetBytes(objString, j, 1, bytes, 0);
                        ElementFuzz.FuzzWrite(bw, bytes);
                    }

                    if (isNullTerm)
                    {
                        objString += '\0';
                        ++elementCount;
                        encoding.GetBytes(new char[] { '\0' }, 0, 1, bytes, 0);
                        // direct write as we have already fuzzed the null terminator
                        bw.Write(bytes);
                    }
                }
            }

            // Pad the end of the array/string with 0's if nescessary
            if (totalSize > 0 && totalSize > elementCount)
            {
                if (fi.FieldType.IsArray)
                {
                    Type elemType = fi.FieldType.GetElementType();

                    ConstructorInfo ci = elemType.GetConstructor(Type.EmptyTypes);
                    int elemSize = 1;

                    if (ci != null)
                    {
                        elemSize = (int) InefficientSizeOf(ci.Invoke(null));
                    }

                    // instead of using the real fuzz class here, we will just do a simple random bytes fuzz
                    // these are just empty slots anyway, so its ok
                    for (int j = elementCount; j < totalSize; ++j)
                    {
                        byte[] arr = new byte[elemSize];

                        if (NextBool(ElementProbability))
                        {
                            NextBytes(arr);
                        }

                        bw.Write(arr);
                    }
                }
                else
                {
                    int remaining_chars = (totalSize - encoding.GetByteCount(objString)) / (isUnicode ? 2 : 1);

                    for (int i = 0; i < remaining_chars; ++i)
                    {
                        byte[] arr = new byte[(isUnicode ? 2 : 1)];

                        if (NextBool(ElementProbability))
                        {
                            NextBytes(arr);
                        }

                        bw.Write(arr);
                    }
                }
            }

            return ElementFuzz.Fuzz;
        }

        /// <summary>
        /// Sets the element fuzzer to a given value.
        /// </summary>
        /// <param name="elem_attr">The element fuzzer to use.</param>
        internal void SetElementFuzz (FuzzDataAttribute elem_attr)
        {
            ElementFuzz = elem_attr;
            ElementFuzz.InheritProperties(this);
            ElementFuzz.Probability = ElementProbability;
        }

        #region Overrides

        /// <summary>
        /// Inherits properties from its parent.
        /// </summary>
        /// <param name="fuzzAttr">The attribute to inherit from.</param>
        public override void InheritProperties (FuzzDataAttribute fuzzAttr)
        {
            base.InheritProperties(fuzzAttr);

            FuzzArrayAttribute faa = fuzzAttr as FuzzArrayAttribute;
            if (faa != null)
            {
                this.NullTermProbability = faa.NullTermProbability;
                this.LengthProbability = faa.LengthProbability;
                this.ElementProbability = faa.ElementProbability;
            }

            if (fuzzAttr.Properties != null)
            {
                if (fuzzAttr.Properties.ContainsKey("NullTermProbability"))
                {
                    this.NullTermProbability = (double) fuzzAttr.Properties["NullTermProbability"];
                }

                if (fuzzAttr.Properties.ContainsKey("LengthProbability"))
                {
                    this.LengthProbability = (double) fuzzAttr.Properties["LengthProbability"];
                }

                if (fuzzAttr.Properties.ContainsKey("ElementProbability"))
                {
                    this.ElementProbability = (double) fuzzAttr.Properties["ElementProbability"];
                }
            }
        }

        #endregion
    }

    /// <summary>
    /// Extends the <c>FuzzDataAttribute</c> class to give more specific options for chars.
    /// </summary>
    public class FuzzCharAttribute : FuzzDataAttribute
    {
        #region Attribute Fields

        /// <summary>
        /// The name of the character encoding to use.
        /// </summary>
        public string CharacterEncoding = "utf-8";

        /// <summary>
        /// Sets the character encoding to the specified type.
        /// </summary>
        /// <param name="encoding">The name of the encoding to use.</param>
        public void SetEncodingByName (string encoding)
        {
            if (CharacterEncoding != encoding)
            {
                CharacterEncoding = encoding;
                CharEnc = Encoding.GetEncoding(CharacterEncoding);
            }
        }

        /// <summary>
        /// Sets the character encoding to the specified type.
        /// </summary>
        /// <param name="encoding">The encoding to use.</param>
        public void SetEncodingByObject (Encoding encoding)
        {
            if (CharEnc != encoding)
            {
                CharEnc = encoding;
                CharacterEncoding = CharEnc.WebName;
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// The character encoding to use.
        /// </summary>
        protected Encoding CharEnc = Encoding.UTF8;

        #endregion

        #region Constructors

        /// <summary>
        /// Creates a default char fuzzer.
        /// </summary>
        public FuzzCharAttribute ()
        {
            ConstructorCommon();
        }

        /// <summary>
        /// Creates a char fuzzer using the specified encoding.
        /// </summary>
        public FuzzCharAttribute (string enc)
        {
            ConstructorCommon();
            SetEncodingByName(enc);
        }

        /// <summary>
        /// Creates a char fuzzer using the specified encoding.
        /// </summary>
        public FuzzCharAttribute (Encoding enc)
        {
            ConstructorCommon();
            SetEncodingByObject(enc);
        }

        /// <summary>
        /// Every constructor should call this.
        /// </summary>
        private void ConstructorCommon ()
        {
            StandardSerializer = new CustomSerializer(this.StandardWrite);
            RandomByteSerializer = new CustomSerializer(this.RandomByteWrite);
        }

        #endregion

        #region Custom Serializers

        /// <summary>
        /// Intercepts byte arrays and writes them, as the WireData writer does not handle them.
        /// Also properly encodes the char for writing.
        /// </summary>
        /// <param name="bw">The writer to write to.</param>
        /// <param name="obj">The object to write.</param>
        protected void StandardWrite (BinaryWriter bw, object obj)
        {
            // byte[]
            if (typeof(byte[]).IsAssignableFrom(obj.GetType()))
            {
                bw.Write((byte[]) obj);
            }
            // char
            else
            {
                bw.Write(CharEnc.GetBytes(new char[] { (char) obj }));
            }
        }

        /// <summary>
        /// Intercepts byte arrays and writes them, as the WireData writer does not handle them.
        /// </summary>
        /// <param name="bw">The writer to write to.</param>
        /// <param name="obj">The object to write.</param>
        protected void RandomByteWrite (BinaryWriter bw, object obj)
        {
            byte[] rand_bytes = null;

            // byte[]
            if (typeof(byte[]).IsAssignableFrom(obj.GetType()))
            {
                rand_bytes = new byte[((byte[]) obj).Length];
            }
            // char
            else
            {
                rand_bytes = new byte[CharEnc.GetByteCount(new char[] { (char) obj })];
            }

            NextBytes(rand_bytes);
            bw.Write(rand_bytes);
        }

        #endregion

        #region Overrides

        /// <summary>
        /// Returns an array containing the char type.
        /// </summary>
        /// <returns>An array containing the char type.</returns>
        public override Type[] GetFuzzTypes ()
        {
            return new Type[] { typeof(char) };
        }

        #endregion
    }

    /// <summary>
    /// Utility class to allow WireData classes that override WriteStream to fuzz more easily.
    /// </summary>
    public class WireDataFuzzHelper
    {
        /// <summary>
        /// The FieldCache of the given type.
        /// </summary>
        protected ServerTestFramework.WireData.FieldCache _fc = null;

        /// <summary>
        /// Creates a WireDataFuzzHelper with the given type.
        /// </summary>
        /// <param name="type">The type to help with.</param>
        public WireDataFuzzHelper (Type type)
        {
            _fc = WireData.GetFieldCacheLine(type);
        }

        /// <summary>
        /// Checks whether the given type has fuzzing turned on.
        /// If not you can follow the normal code path.
        /// </summary>
        public bool Fuzz
        {
            get
            {
                return (WireData.Fuzz && _fc != null && _fc.FuzzClass);
            }
        }

        /// <summary>
        /// Checks whether the field of the type has fuzzing turned on.
        /// This function assumes that Fuzz returns true, otherwise there would be no reason
        /// to have gotten this far.
        /// </summary>
        /// <param name="fieldName">The name of the field to check for fuzzing.</param>
        /// <returns>True if the field has fuzzing turned on; false if it does not.</returns>
        public bool this[string fieldName]
        {
            get
            {
                uint i = _fc.GetFieldIndex(fieldName);
                return (_fc.FuzzInfo[i] != null && _fc.FuzzInfo[i].Fuzz);
            }
        }

        /// <summary>
        /// Writes the object using the FuzzDataAttribute associated with the field.
        /// This function assumes that [fieldName] returns true.
        /// </summary>
        /// <param name="fieldName">The field to write.</param>
        /// <param name="bw">The writer to write to.</param>
        /// <param name="obj">The object to write.</param>
        public void Write (string fieldName, BinaryWriter bw, object obj)
        {
            uint i = _fc.GetFieldIndex(fieldName);
            _fc.FuzzInfo[i].FuzzWrite(bw, obj);
        }

        /// <summary>
        /// Writes the object using the FuzzDataAttribute associated with the field.
        /// This function first checks that [fieldName] returns true.
        /// </summary>
        /// <param name="fieldName">The field to write.</param>
        /// <param name="bw">The writer to write to.</param>
        /// <param name="obj">The object to write.</param>
        /// <returns>True if [fieldName] is true, which also means that the field was written; false otherwise.</returns>
        public bool CheckWrite (string fieldName, BinaryWriter bw, object obj)
        {
            if (this[fieldName])
            {
                uint i = _fc.GetFieldIndex(fieldName);

                Type obj_type = obj.GetType();

                if (obj_type.IsArray || obj_type == typeof(string))
                {
                    FuzzArrayAttribute faa = _fc.FuzzInfo[i] as FuzzArrayAttribute;

                    if (faa == null)
                    {
                        throw new FuzzDataAttributeException("Attempt to fuzz an array not using a " +
                            "FuzzArrayAttribute.");
                    }

                    // This is not exactly correct for char[] and string, they will need some work
                    // Basically its not using the standard WireData encoders (make them internal, not protected)
                    // and it doesn't use NullTermOverride, which is an instance field of WireData
                    faa.FuzzWriteArray(bw, obj, _fc.Fields[i],
                        (_fc.WireInfo[i].UnicodeEncoded ? Encoding.Unicode : Encoding.UTF8),
                        _fc.WireInfo[i].NullTerminated, 
                        (obj_type.IsArray ? ((Array) obj).Length : ((string) obj).Length ));
                }
                else
                {
                    _fc.FuzzInfo[i].FuzzWrite(bw, obj);
                }

                return true;
            }

            return false;
        }
    }

#if false
    /// <summary>
    /// Contains more specific properties for fuzzing numeric data.
    /// </summary>
    /// <typeparam name="T">A numeric data type, see GetFuzzTypes for a list of possibilities.</typeparam>
    [AttributeUsage(AttributeTargets.Field)]
    public class NumericFuzzData<T> : FuzzDataAttribute
    {
        /// <summary>A static storage for the minimum value of the type.</summary>
        protected static T TypeMin;
        /// <summary>A static storage for the maximum value of the type.</summary>
        protected static T TypeMax;

        /// <summary>
        /// Static constructor to get the min and max values for the type.
        /// </summary>
        static NumericFuzzData ()
        {
            try
            {
                TypeMin = (T) typeof(T).InvokeMember("MinValue", BindingFlags.Public | BindingFlags.Static |
                    BindingFlags.GetField, null, null, new object[] { });
                TypeMin = (T) typeof(T).InvokeMember("MaxValue", BindingFlags.Public | BindingFlags.Static |
                    BindingFlags.GetField, null, null, new object[] { });
            }
            finally
            {
                TypeMin = (T) 0;
                TypeMax = (T) 0;
            }
        }

        /// <summary>The minimum value to generate when fuzzing: the range [Min, Max).</summary>
        public T Min = TypeMin;

        /// <summary>The maximum value to generate when fuzzing: the range [Min, Max).</summary>
        public T Max = TypeMax;

        /// <summary>
        /// Creates a new numeric fuzzing attribute with the default values.
        /// </summary>
        public NumericFuzzData () { }

        /// <summary>
        /// Creates a new numeric fuzzing attribute with the given properties.
        /// </summary>
        /// <param name="objs"></param>
        public NumericFuzzData (params object[] objs) : base(objs) { }

        /// <summary>The types that we can fuzz.</summary>
        private readonly Type[] _fuzzTypes = new Type[] { 
            typeof(SByte), typeof(Byte),                    // 8 bit integers
            typeof(Int16), typeof(UInt16), typeof(Char),    // 16 bit integers
            typeof(Int32), typeof(UInt32),                  // 32 bit integers
            typeof(Int64), typeof(UInt64),                  // 64 bit integers
            typeof(Single), typeof(Double),                 // floating point
            typeof(Decimal)                                 // decimal
        };

        /// <summary>
        /// Gets the numeric types that we can fuzz.
        /// </summary>
        /// <returns>The numeric types that we can fuzz.</returns>
        public override Type[] GetFuzzTypes ()
        {
            return _fuzzTypes;
        }

        /// <summary>
        /// Attempts to get the properties that we  from the d
        /// </summary>
        /// <param name="fuzzAttr">The attribute to inherit from.</param>
        public override void InheritProperties (FuzzDataAttribute fuzzAttr)
        {
            base.InheritProperties(fuzzAttr);

            NumericFuzzData<T> numFuzz = fuzzAttr as NumericFuzzData<T>;
            if (numFuzz != null)
            {
                this.Min = numFuzz.Min;
                this.Max = numFuzz.Max;
            }

            if (fuzzAttr.Properties != null)
            {
                if (fuzzAttr.Properties.ContainsKey("Min"))
                {
                    this.Min = (T) fuzzAttr.Properties["Min"];
                }

                if (fuzzAttr.Properties.ContainsKey("Max"))
                {
                    this.Max = (T) fuzzAttr.Properties["Max"];
                }
            }
        }

        /// <summary>
        /// Writes the object to the writer, possibly fuzzes the written value, but does not change it.
        /// </summary>
        /// <param name="bw">The destination to write to.</param>
        /// <param name="obj">The object to fuzz.</param>
        protected virtual void FuzzWriteInternal (BinaryWriter bw, object obj)
        {
            //T diff = Max - Min;
            //StandardWrite(Min + (T) (diff * NextDouble()));
        }
    }
    
    static class Fuzzer
    {
        /// <summary>
        /// Random number generator used to... umm.. generate random numbers
        /// </summary>
        private static Random rand = new Random();

        /// <summary>
        /// Reseeds the random number generator, this should only really be done when you start out
        /// it's useful if you need to repro an exact refuzz to verify fixes.
        /// </summary>
        /// <param name="seed"></param>
        public static void SeedRandom(int seed)
        {
            rand = new Random(seed);
        }

        /// <summary>
        /// This will take in an object and it's fuzz attributes and then make the correct call for the data type
        /// that the object is.
        /// 
        /// I had to do it this way, because you need to get the attributes from the class, and there was no way
        /// to pull the attribute directly from the object passed in, that I knew of.
        /// </summary>
        /// <param name="o"></param>
        /// <param name="dataAttribute"></param>
        public static object FuzzObject(object o)
        {
            FuzzDataAttribute temp = new FuzzDataAttribute();
            return FuzzObject( o, temp);

        }
        public static object FuzzObject(object o, FuzzDataAttribute dataAttribute)
        {
            // Make sure it's a fuzzable variable before doing any more work.
            if (dataAttribute.doNotFuzz == true)
                return o;

            // Validate that min and max are correct, min < max
            if (dataAttribute.min > dataAttribute.max)
            {
                int temp = (int)dataAttribute.max;
                dataAttribute.max = dataAttribute.min;
                dataAttribute.min = temp;
            }

            Type type = o.GetType();
            if (type == typeof(bool))
            {
                return FuzzBoolean(o, dataAttribute);
            }
            else if (type == typeof(byte))
            {
                return FuzzByte(o, dataAttribute);
            }
            else if (type == typeof(char))
            {
                return FuzzChar(o, dataAttribute);
            }
            else if (type == typeof(decimal))
            {
                return FuzzDecimal(o, dataAttribute);
            }
            else if (type == typeof(double))
            {
                return FuzzDouble(o, dataAttribute);
            }
            else if (type == typeof(float))
            {
                return FuzzFloat(o, dataAttribute);
            }
            else if (type == typeof(short))
            {
                return FuzzShort(o, dataAttribute);
            }
            else if (type == typeof(int))
            {
                return FuzzInt(o, dataAttribute);
            }
            else if (type == typeof(long))
            {
                return FuzzLong(o, dataAttribute);
            }
            else if (type == typeof(sbyte))
            {
                return FuzzSByte(o, dataAttribute);
            }
            else if (type == typeof(ushort))
            {
                return FuzzUShort(o, dataAttribute);
            }
            else if (type == typeof(uint))
            {
                return FuzzUInt(o, dataAttribute);
            }
            else if (type == typeof(ulong))
            {
                return FuzzULong(o, dataAttribute);
            }
            return o;
        }

        //*************************************
        // Fuzz methods based on data type.
        //*************************************
        public static object FuzzBoolean(object data, FuzzDataAttribute dataAttrib)
        {
            int temp = rand.Next(0, 2);
            if (temp == 0)
                data = false;
            else
                data = true;
            return data;
        }

        public static object FuzzByte(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (byte)rand.Next(byte.MaxValue + 1);
            }
            else
            {
                data = (byte)rand.Next((int)dataAttrib.min, (int)dataAttrib.max % (byte.MaxValue + 1));
            }
            return data;
        }

        public static object FuzzChar(object data, FuzzDataAttribute dataAttrib)
        {
            //data = (char)rand.Next(char.MaxValue);
            if (dataAttrib.min == dataAttrib.max)
            {
                // Limit to ascii for now.
                data = (char)rand.Next(128);
            }
            else
            {
                data = (char)rand.Next((int)dataAttrib.min, (int)dataAttrib.max);
            }
            return data;
        }

        public static object FuzzDecimal(object data, FuzzDataAttribute dataAttrib)
        {
            int[] hiMidLo = new int[3];
            byte powerOfTen = 0;
            decimal tempDecimal = 0;
            // Create the high middle and low part of the decimal number
            for (int i = 0; i < 3; i++)
            {
                hiMidLo[i] = rand.Next(int.MinValue, int.MaxValue);
            }

            // Randomize the power value
            if (dataAttrib.min == dataAttrib.max)
            {
                // Get a random power of ten within the acceptable range
                powerOfTen = (byte)rand.Next(0, 28 + 1);
            }
            else
            {
                powerOfTen = (byte)rand.Next((int)dataAttrib.min % (28 + 1), (int)dataAttrib.max % (28 + 1));
            }

            // Randomize if it is positive or negative
            if (dataAttrib.positiveOnly == dataAttrib.negativeOnly)
            {
                bool randPosNeg = Convert.ToBoolean(rand.Next(0, 2));
                tempDecimal = new decimal(hiMidLo[0], hiMidLo[1], hiMidLo[2], randPosNeg, powerOfTen);
            }
            else if (dataAttrib.positiveOnly == true)
            {
                tempDecimal = new decimal(hiMidLo[0], hiMidLo[1], hiMidLo[2], false, powerOfTen);
            }
            else if (dataAttrib.negativeOnly == true)
            {
                tempDecimal = new decimal(hiMidLo[0], hiMidLo[1], hiMidLo[2], true, powerOfTen);
            }

            data = tempDecimal;
            return data;
        }

        public static object FuzzDouble(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = rand.NextDouble() * double.MaxValue;
            }
            else
            {
                double maxMinusMin = dataAttrib.max - dataAttrib.min;
                data = rand.NextDouble() * Math.Abs(maxMinusMin) + dataAttrib.min;
            }
            return data;
        }

        public static object FuzzShort(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (short)rand.Next(short.MinValue, short.MaxValue + 1);
            }
            else
            {
                data = (short)rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }

        public static object FuzzInt(object data, FuzzDataAttribute dataAttrib)
        {
            // If a min and max have been set, then use them.
            if (dataAttrib.min == dataAttrib.max)
            {
                data = rand.Next(int.MinValue, int.MaxValue);
            }
            else
            {
                data = rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }

        public static object FuzzLong(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (long)(rand.NextDouble() * long.MaxValue * 2 - long.MaxValue);
            }
            else
            {
                long maxMinusMin = (long)(dataAttrib.max - dataAttrib.min);
                data = (long)(rand.NextDouble() * Math.Abs(maxMinusMin) + dataAttrib.min);
            }
            return data;
        }

        public static object FuzzSByte(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (sbyte)rand.Next(sbyte.MinValue, sbyte.MaxValue + 1);
            }
            else
            {
                data = (sbyte)rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }

        public static object FuzzFloat(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (float)(rand.NextDouble() * float.MaxValue);
            }
            else
            {
                float maxMinusMin = (float)dataAttrib.max - (float)dataAttrib.min;
                data = (rand.NextDouble() * Math.Abs(maxMinusMin) + (float)dataAttrib.min);
            }
            return data;
        }

        public static object FuzzUShort(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (ushort)rand.Next(ushort.MinValue, ushort.MaxValue + 1);
            }
            else
            {
                data = (ushort)rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }

        public static object FuzzUInt(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (uint)(rand.NextDouble() * uint.MaxValue);
            }
            else
            {
                data = (uint)rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }

        public static object FuzzULong(object data, FuzzDataAttribute dataAttrib)
        {
            if (dataAttrib.min == dataAttrib.max)
            {
                data = (ulong)(rand.NextDouble() * ulong.MaxValue);
            }
            else
            {
                data = (ulong)rand.Next((int)dataAttrib.min, (int)dataAttrib.max + 1);
            }
            return data;
        }
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\XHttpListener.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Utilities
{
    /// <summary>
    /// Summary description for XHttpListener.
    /// </summary>
    public class XHttpListener : ThreadBase
    {
        /// <summary>
        /// random number generator.
        /// </summary>
        protected RandomEx randGen= new RandomEx();

        /// <summary>
        /// PercentError is the percentage time 500 bad request is returned with the proper xErrror 
        /// you can call SetXerror to change the default xerror returned.
        /// </summary>
        public  int PercentError=0;


        /// <summary>
        /// delay is the minumun time the request will take before it returns 200 ok
        /// </summary>
        public  int delay=-1;
		
        /// <summary>
        /// MAxcimun connection the listner can open. by default its infinity.
        /// </summary>
        public  int maxCon=-1;

        /// <summary>
        /// Flag that indicates in which state is the listner 
        /// </summary>
        public bool IsRunning= false;

        /// <summary>
        /// Port that listener accepts on
        /// </summary>
        protected int port=-1;

        /// <summary>
        /// Listener socket
        /// </summary>
        protected Socket sock = null;

        /// <summary>
        /// Number of handlers
        /// </summary>
        public int Handlers=0;

        /// <summary>
        /// Keep TCP connection open (thread will never return)?
        /// </summary>
        public bool MaintainConnection = true;

        protected AutoResetEvent ShutDownEvent = new System.Threading.AutoResetEvent(false);
		
        /// <summary>
        /// String constants
        /// </summary>
        const string Continue = "HTTP/1.1 100 Continue\r\n\r\n";
        const string ReqOk ="HTTP/1.1 200 OK\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nContent-Length: 0\r\n\r\n";
        string badreq= "HTTP/1.1 500 Bad Request\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nX-Err:"+HResult.XONLINE_E_SERVER_ERROR.ToString("x")+" \r\nContent-Length: 0\r\n\r\n";
        const int InitialBufSize = 4096;
		
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="listenPort"></param>
        public XHttpListener (int listenPort)
        {
            port= listenPort;
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="listenPort"></param>
        /// <param name="delay"></param>
        public XHttpListener (int listenPort,int delay)
        {
            port= listenPort;
            this.delay= delay;
        }


        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="listenPort"></param>
        /// <param name="delay"></param>
        /// <param name="maxConn"></param>
        public XHttpListener (int listenPort,int delay,int maxConn)
        {
            port= listenPort;
            this.delay= delay;
            this.maxCon=maxConn;
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="listenPort"></param>
        /// <param name="delay"></param>
        /// <param name="maxConn"></param>
        public XHttpListener (int listenPort,int delay,int maxConn,bool bMaintainConnection)
        {
            port= listenPort;
            this.delay= delay;
            this.maxCon=maxConn;
            this.MaintainConnection = bMaintainConnection;
        }

        public void SetXError(uint error)
        {
            badreq="HTTP/1.1 500 Bad Request\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nX-Err:"+error.ToString("X")+" \r\nContent-Length: 0\r\n\r\n";
        }


        /// <summary>
        /// Helper function to get ContentLength and other headers
        /// </summary>
        /// <param name="bytes"></param>
        /// <param name="endofheader"></param>
        /// <returns></returns>
        private void ParseHeaders(byte[] bytes, ref int Endofheader, ref int Contentlen, ref string Httpversion)
        {
            Contentlen = -1;
            //Httpversion = "";
            Endofheader= -1;

            StringBuilder Reqhead = new StringBuilder();
            int i=0;
            for(;i<bytes.Length;i++)
            {		
                char t = (char)bytes[i];
                Reqhead.Append(t);	
                if( t =='\r' && ((char)bytes[i+1]=='\n'))
                {
                    // Check for header elements
                    string header = Reqhead.ToString();

                    if(header.IndexOf("Content-Length")>0)
                    {
                        //we found content length 
                        Reqhead.Remove(0,(header.IndexOf(":")+1));
                        string tempstr = Reqhead.ToString();
                        Contentlen = Convert.ToInt32(tempstr);
                    }
                    else if (header.IndexOf("HTTP/") > 0)
                    {
                        char[] seps = { ' ', '\r', '\n' };
                        int start = header.IndexOf("HTTP/") + 5;
                        int end = header.IndexOfAny(seps, start);
                        Httpversion = header.Substring(start, end-start).Trim();
                    }

                    // End of header?  Break out and return.
                    if( (char)bytes[i+2] =='\r' && (char)bytes[i+3]=='\n')
                    {
                        // reached  the end of HTTP headers
                        //System.Console.Write("Head isolated");
                        Endofheader=i+3;
                        break;
                    }
                    Reqhead = new StringBuilder();
                }			
            }
        }

        /// <summary>
        /// Call back method that parses http request and passes it to ProcessData
        /// </summary>
        /// <param name="stateInfo"></param>
        private void IncomingReqHandler(Object stateInfo) 
        {
            Socket request = (Socket)stateInfo;
            int contentLength=0;
            int CurrentBufferSize=InitialBufSize;
            Byte[] receiveBytes=null;
            int got=0;
            int cum=0;
            bool gotHeader=false;
            int endofheader=0;
            int WaitCount=0;
            int SpinCount=0;
            string httpversion;

            request.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReceiveTimeout,120000);
					
            try
            {
                while(true)
                {
                    WaitCount=0;
                    contentLength=0;
                    CurrentBufferSize=InitialBufSize;
                    receiveBytes=new Byte[InitialBufSize+1];
                    got=0;
                    cum=0;
                    gotHeader=false;
                    endofheader= -1;
                    httpversion="1.1";

                    //Read until we at least get a complete header or the other end times out trying
                    while(!gotHeader)
                    {
                        // check if datat is Available before reading 
						
                        SpinCount=0;
                        while ((request.Available==0) && (SpinCount<10))
                        {
                            SpinCount++;
                            WaitCount++;
                            if(ShutDownEvent.WaitOne(1,false))
                            {
                                ShutDownEvent.Set();
                                return ;
                            }
                        }

                        if(request.Available>0)
                        {
                            got=request.Receive(receiveBytes,cum,CurrentBufferSize-cum,SocketFlags.None);

                            if(got==0)
                            {
                                // the remote host have shout down the socket. close the socket and exit from the thread.
                                request.Close();
                                Interlocked.Decrement(ref Handlers);
                                request= null;
                                return;
                            }
                            cum+=got;
                            // check if we received complete headers.
                            ParseHeaders(receiveBytes, ref endofheader, ref contentLength, ref httpversion);
                            if(endofheader>0)
                                gotHeader= true;
                            // if the header is not read yet double the buffer.
                            if(cum>=CurrentBufferSize)
                            {
                                byte[] temp =receiveBytes;
                                receiveBytes = new byte[(CurrentBufferSize*2)+1];
                                Array.Copy(temp,0,receiveBytes,0,cum);
                                CurrentBufferSize =CurrentBufferSize*2;
                                temp=null;
                            }
                        }
                        else 
                        {
                            if(WaitCount > 60000)
                            {
                                //System.Console.WriteLine("Current Connections = "+Handlers);
                                request.Close();
                                Interlocked.Decrement(ref Handlers);
                                request= null;
                                return;
                            }
                            if(ShutDownEvent.WaitOne(10,false))
                            {
                                // the Application is Shutting down Just Quit.
                                //System.Console.WriteLine("time out");
                                ShutDownEvent.Set();
                                return ;
                            }
                            WaitCount+=10;

                        }
                    }
							
                    //Something went wrong, get out!
                    if(contentLength <=0  || endofheader<=0)
                    {
                        request.Shutdown(SocketShutdown.Both);
                        request.Close();
                        Interlocked.Decrement(ref Handlers);
                        request= null;
                        return;
                    }

                    //If we only got the header and there is content left; send a continue
                    //Don't do this for HTTP/1.0
                    if ((contentLength!=0) && (cum-(endofheader+1) < contentLength) && httpversion != "1.0")
                    {
                        request.Send(Encoding.ASCII.GetBytes(Continue));
                    }
						
                    // Check if buffer we have is enough for data else increase the buffer
                    if((contentLength+endofheader+1) >InitialBufSize)
                    {
                        byte[] temp =receiveBytes;
                        receiveBytes = new byte[contentLength+endofheader+1];
                        Array.Copy(temp,0,receiveBytes,0,cum);
                        CurrentBufferSize =contentLength+endofheader+1;
                        temp=null;
						
                    }

                    //Get all the content or what is left of the content 
                    int Retrycount=0;
					
                    while (cum!=endofheader+1+contentLength)
                    {
                        got=request.Receive(receiveBytes,cum,CurrentBufferSize-cum,SocketFlags.None);
                        if(got==0)
                        {
                            Retrycount++;
                            Thread.Sleep(100);
                            if(Retrycount >3)
                            {
                                // Some thing went wrong we did not recive complete data .send 500 bad request and close the socket.
                                request.Send(Encoding.ASCII.GetBytes(badreq));
                                return;
                            }
                        }
						
                        cum+=got;
                    }
                    // sleep if delay is set.
                    if(delay>0)
                    {
                        //System.Console.WriteLine("Delaying Response by "+delay+"ms");
                        Thread.Sleep(delay);
                    }

                    if(PercentError >0)
                    {
                        if(randGen.Next(0,100)<PercentError)
                        {
                            request.Send(Encoding.ASCII.GetBytes(badreq));
                            return ;
                        }
                    }

                    byte []	respBody;	// http body
                    bool retval =ProcessData(receiveBytes,endofheader+1,contentLength, out respBody);

                    //Send final code

                    if(retval)
                    {
                        if(respBody == null)	// response for the http request only contains header, no body
                        {
                            request.Send(Encoding.ASCII.GetBytes(ReqOk));
                        }
                        else
                        {
                            int			headerLen = 0, bodyLen = respBody.Length;
                            string		headerStr ="HTTP/1.1 200 OK\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version:"+
                                " 1.1.0000\r\nCache-Control: private\r\nContent-Length: "+bodyLen+"\r\n\r\n";
                            headerLen = headerStr.Length;

                            byte	[]	header = Encoding.ASCII.GetBytes(headerStr);
                            byte	[]	completeResp = new byte[headerLen+bodyLen];

                            Array.Copy(header,completeResp,headerLen);
                            Array.Copy(respBody,0,completeResp,headerLen,bodyLen);

                            request.Send(completeResp);
                        }
                    }
                    else
                        request.Send(Encoding.ASCII.GetBytes(badreq));
										
                    receiveBytes= null;

                    // We've processed 1 full request now. If we're maintaining this connection,
                    // we want to keep looping.  Otherwise let's return and free up the thread.
                    if (!MaintainConnection)
                        return;
					
                }
            }
            catch(System.Threading.ThreadAbortException)
            {
                //thread told to shutdown; goto finally block
            }
            catch (SocketException)
            {
                //Console.WriteLine("socket exception 0x"+e.NativeErrorCode.ToString("X")+" Handler count ="+Handlers);
            }
            catch (ObjectDisposedException) 
            {
                // Ignore the Exception sinc the Opposite party may have  closed the connection.
                request= null;
            }
            catch (Exception e )
            {
                Console.WriteLine("unexpected exception:");
                Console.WriteLine(e.ToString()); 
            }
            finally
            {
				
                if(request != null)
                {
                    request.Shutdown(SocketShutdown.Both);
                    request.Close();
                    Interlocked.Decrement(ref Handlers);
					
                }
            }
			
        }

        /// <summary>
        /// Virtual function for processing content data
        /// </summary>
        /// <param name="ReqData"></param>
        /// <param name="ConIndex"></param>
        /// <param name="conLen"></param>
        /// <returns></returns>
        public virtual bool ProcessData(byte[] ReqData, int ConIndex, int conLen)
        {
            // if true the Listner response with 200 ok else with 500 bad request. 
            // ConIndex is the index in the buffere where the content starts
            // and conLen is the lendth of the data
            return true;
        }

        /// <summary>
        /// This is for processing requests whose reponse contains both header and body.
        /// </summary>
        /// <param name="ReqData"></param>
        /// <param name="ConIndex">the index in the buffere where the content starts</param>
        /// <param name="conLen">the lendth of the data</param>
        /// <param name="respBuff"></param>
        /// <returns></returns>
        public virtual bool ProcessData(byte[] ReqData, int ConIndex, int conLen,out byte[] resp)
        {
            resp = null;
            return ProcessData(ReqData,ConIndex,conLen);
        }

        /// <summary>
        /// The main listner threasd
        /// </summary>
        protected override void ThreadBody()
        {
            Console.WriteLine("Initializing listener.");
            int maxWorkerThreads, maxCompletionPortThreads;
            ThreadPool.GetMaxThreads(out maxWorkerThreads,
                out maxCompletionPortThreads);
            if (Global.RO != null) Global.RO.Info("Worker Thread Pool Size is " + maxWorkerThreads);
            try
            {
                sock=new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
                IPEndPoint localEP=new IPEndPoint(IPAddress.Any,port);
                try
                {
                    sock.Bind(localEP);
                }
                catch(SocketException e)
                {
                    throw new Exception("listener failed to bind to port 0x"+port.ToString("X"), e);
                }
				
                while (true)
                {
                    try
                    {
                        Socket request = null;
                        //Put socket in listen mode
                        sock.Listen(254);
                        //Accept incoming connections
                        request = sock.Accept();
						

                        if(maxCon <0 )
                        {
                            Interlocked.Increment(ref Handlers);
                            // Queue the Request, the Next available thread form the pool will handle it.
                            ThreadPool.QueueUserWorkItem(new WaitCallback(IncomingReqHandler),request);
                        }
                        else if(maxCon >=0 && Handlers<=maxCon)
                        {
                            Interlocked.Increment(ref Handlers);
                            // Queue the Request, the Next available thread form the pool will handle it.
                            ThreadPool.QueueUserWorkItem(new WaitCallback(IncomingReqHandler),request);
                        }
                        else
                        {
                            // ShutDown the Connection which will force the socket to Reset.
                            request.Shutdown(SocketShutdown.Both);
                        }
                        if (Global.RO != null) Global.RO.Info("Number of incomingRequestHanders is:" + Handlers);
                        int availWorkerThreads, availCompletionPortThreads;
                        ThreadPool.GetAvailableThreads(out availWorkerThreads,
                            out availCompletionPortThreads);
                        if (Global.RO != null) Global.RO.Info("Available Worker Threads is :" + availWorkerThreads);
                        if (availWorkerThreads == 0)
                        {
                            if (Global.RO != null) Global.RO.Error("Error - No Available Worker Threads left in Thread Pool!");
                        }
                    }
                    catch(System.Threading.ThreadAbortException)
                    {
                        //thread told to shutdown; goto finally block
                        break;
                    }
                    catch (SocketException e)
                    {
                        Console.WriteLine("socket exception 0x"+e.NativeErrorCode.ToString("X"));
                        break;
                    }
                    catch (Exception e )
                    {
                        Console.WriteLine("unexpected exception:");
                        Console.WriteLine(e.ToString()); 
                        break;
                    }

						
                }
            }
            finally
            {
				
                if (sock != null)
                    sock.Close();
                Console.WriteLine("Terminated listener.");
            }
        }

        public override void Stop()
        {
            IsRunning = false;
            ShutDownEvent.Set();
            base.Stop();
	
            try
            {
                //we are suppose to try this first before we close
                if (sock!=null)
                {
                    sock.Shutdown(SocketShutdown.Both);
                }
				

            }
            catch(System.ObjectDisposedException)
            {
                //in case sock goes out of scope when trying to shutdown which could happend if accept is released and abort is being process from the base call
            }
            catch(System.Net.Sockets.SocketException)
            {
                //expected if socket operations are taking place
            }
            finally
            {
				
                if (sock!=null)
                {
                    //this actually releases the accept blocking call
                    sock.Close();
                }
            }
        }

        public override void Go()
        {
            IsRunning = true;
            ShutDownEvent.Reset();

            base.Go();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\XHttpListenerIOCP.cs ===
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using System.Threading;
using System.Text;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Utilities
{
	/// <summary>
	/// Summary description for Server.
	/// </summary>
	public class XHttpListenerIOCP : ThreadBase
	{
		/// <summary>
		/// String constants
		/// </summary>
		const string Continue = "HTTP/1.1 100 Continue\r\n\r\n";
		const string ReqOk ="HTTP/1.1 200 OK\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nContent-Length: 0\r\n\r\n";
		string badreq= "HTTP/1.1 500 Bad Request\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nX-Err:"+HResult.XONLINE_E_SERVER_ERROR.ToString("x")+" \r\nContent-Length: 0\r\n\r\n";

		/// <summary>
		/// random number generator.
		/// </summary>
		protected RandomEx randGen = new RandomEx();

		/// <summary>
		/// PercentError is the percentage time 500 bad request is returned with the proper xErrror 
		/// you can call SetXerror to change the default xerror returned.
		/// </summary>
		public int PercentError = 0;

		/// <summary>
		/// delay is the minumun time the request will take before it returns 200 ok
		/// </summary>
		public int delay = -1;

		/// <summary>
		/// Maximum connections the listener can open. By default its infinity.
		/// </summary>
		public int maxCon = -1;

		/// <summary>
		/// Flag that indicates in which state is the listner 
		/// </summary>
		public bool IsRunning = false;

		/// <summary>
		/// Port that listener accepts on
		/// </summary>
		protected int port = -1;

		/// <summary>
		/// Listener socket
		/// </summary>
		protected IOCPSocket sock = null;

		/// <summary>
		/// Number of handlers
		/// </summary>
		//[Obsolete("Discrete handlers don't exist in the IOCP version")]
		public int Handlers = 0;

		/// <summary>
		/// Signaled when it's time to shut down
		/// </summary>
		protected AutoResetEvent ShutDownEvent = new AutoResetEvent(false);

		/// <summary>
		/// Let's the listener thread know it's time to call BeginAccept again
		/// </summary>
		protected AutoResetEvent ConnectionAccepted = new AutoResetEvent(false);

        private static BooleanSwitch ShowDebugSpew = new BooleanSwitch("XHttpListenerIOCP_ShowDebugSpew", "Show debug spew");

		public XHttpListenerIOCP(int listenPort)
		{
			port = listenPort;
		}

		public XHttpListenerIOCP(int listenPort, int delay)
		{
			port= listenPort;
			this.delay= delay;
		}

		public XHttpListenerIOCP(int listenPort, int delay, int maxConn)
		{
			port = listenPort;
			this.delay = delay;
			this.maxCon = maxConn;
		}

		public void SetXError(uint error)
		{
			badreq="HTTP/1.1 500 Bad Request\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: SEANWO.NET\r\nX-SeanwoNet-Version: 1.1.0000\r\nCache-Control: private\r\nX-Err:"+error.ToString("X")+" \r\nContent-Length: 0\r\n\r\n";
		}

		private void DbgW(string output)
		{
            if (ShowDebugSpew.Enabled)
            {
                Debug.WriteLine("     XHLIO[Inst:" + this.GetHashCode().ToString().PadLeft(4, '0') + 
                    "; TID:" + Thread.CurrentThread.ManagedThreadId.ToString().PadLeft(4, '0') +
                    "; Sock:" + (sock != null ? sock.GetHashCode().ToString().PadLeft(4, '0') : "0000") +
                    "]: " + output);
            }
		}

		private void DbgShowThreadStatus()
		{
			int maxWorkerThreads, maxCompletionPortThreads;
			ThreadPool.GetMaxThreads(out maxWorkerThreads, out maxCompletionPortThreads);
			DbgW("Worker Thread Pool Size is " + maxWorkerThreads);
			DbgW("Completion Port Thread Pool Size is " + maxCompletionPortThreads);
		}

		private void OnAccept(IOCPSocket acceptedSocket, object extraContext)
		{
			DbgW("Entered OnAccept given IOCPSocket " + acceptedSocket.GetHashCode() + " using socket " + acceptedSocket.Socket.GetHashCode());

			ConnectionAccepted.Set();
			HttpReceiveContext httpContext = new HttpReceiveContext();
			acceptedSocket.Receive(httpContext, new IOCPSocket.ReceiveHandler(OnReceive), null);

			DbgW("Exiting OnAccept");
		}

		private int GetEndOfHeaderIndex(byte[] bytes)
		{
			// There may or may not be a complete header at this point
			int endOfHeader = -1;
			for (int i = 3; i < bytes.Length; i++)
			{
				if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
				{
					endOfHeader = i;
					break;
				}
			}
			return(endOfHeader);
		}

		private string GetHeader(byte[] bytes)
		{
			string header = "";
			int eohIdx = GetEndOfHeaderIndex(bytes);
			if (0 != eohIdx)
			{
				// We have header
				header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
			}
			return(header);
		}

		private int GetContentLength(string header)
		{
			int index = header.IndexOf("\r\nContent-Length: ");
			if (index == -1)
			{
				throw new Exception("Content-Length missing from header");
			}
			index += 18;	// Skip past the "\r\nContent-Length: " part and point to the left-most digit
			int endIndex = header.IndexOf("\r\n", index);
			string length = header.Substring(index, endIndex - index);
			return(int.Parse(length));
		}

		private bool GetExpectContinue(string header)
		{
			int index = header.IndexOf("\r\nExpect: 100-continue\r\n");
			return(index != -1);
		}

		private bool IsContinueRequired(HttpReceiveContext httpContext)
		{
			//BUGBUG: Need to revise to correspond with RFC 2616 8.2.3 Use of the 100 (Continue) Status
			bool required = false;
			if (httpContext.Header.IndexOf("HTTP/1.1") != -1)
			{
				//BUGBUG: Should check to confirm it's a PUT or POST request
				int contentLength = GetContentLength(httpContext.Header);
				if (contentLength > 0)
				{
					if (httpContext.Header.Length + contentLength > httpContext.Offset)
					{
						required = true;
					}
				}
			}
			return(required);
		}

		private class HttpReceiveContext : IOCPSocket.ReceiveContext
		{
			public bool HeaderReceived = false;
			public string Header = null;
			public int ContentLength = -1;

			public void DbgDumpContents()
			{
				string dbgDump = "Buffer.Length == " + Buffer.Length;
				dbgDump += "; HeaderReceived == " + HeaderReceived;
				if (HeaderReceived)
				{
					dbgDump += "; Header: \r\n" + Header;
				}
				dbgDump += "; LastRead == " + LastRead;
				dbgDump += "; Offset == " + Offset;
				Debug.WriteLine("HttpReceiveContext: " + dbgDump);
			}
		}

		private void RecycleSocket(IOCPSocket socket, int sentSize, object extraContext)
		{
			DbgW("RecycleSocket called");
			socket.Receive(new HttpReceiveContext(), new IOCPSocket.ReceiveHandler(OnReceive), null);
		}

		private void RespondAndRecycle(IOCPSocket socket, HttpReceiveContext httpContext, byte[] response)
		{
			DbgW("RespondAndRecycle called");
			object context = (object)httpContext;
			socket.Send(response, new IOCPSocket.SendHandler(RecycleSocket), context);
		}

		private void RespondAndRecycle(IOCPSocket socket, HttpReceiveContext httpContext, string response)
		{
			RespondAndRecycle(socket, httpContext, Encoding.ASCII.GetBytes(response));
		}

		private void ContinueReceiving(IOCPSocket socket, int sentSize, object extraContext)
		{
			DbgW("ContinueReceiving called");
			HttpReceiveContext httpContext = (HttpReceiveContext)extraContext;
			socket.Receive(httpContext, new IOCPSocket.ReceiveHandler(OnReceive), null);
		}

		private void RespondAndReceiveMore(IOCPSocket socket, HttpReceiveContext httpContext, string response)
		{
			DbgW("RespondAndReceiveMore called");
			object context = (object)httpContext;
			socket.Send(Encoding.ASCII.GetBytes(response), new IOCPSocket.SendHandler(ContinueReceiving), context);
		}

		private void GrowBufferToFinalSize(ref HttpReceiveContext httpContext)
		{
			int expectedBytes = httpContext.Header.Length + httpContext.ContentLength;
			if (expectedBytes <= httpContext.Buffer.Length)
			{
				return;
			}
			// How much we expect total minus the buffer's current size
			int growthDelta = expectedBytes - httpContext.Buffer.Length;
			Debug.Assert(growthDelta > 0);
			httpContext.GrowBuffer((uint)growthDelta);
		}

		private void OnReceive(IOCPSocket socket, IOCPSocket.ReceiveContext recvContext, object extraContext)
		{
			DbgW("Entered OnReceive with IOCPSocket " + socket.GetHashCode() + " using socket " + socket.Socket.GetHashCode());
			HttpReceiveContext httpContext = (HttpReceiveContext)recvContext;

			// Did we get anything?
			if (httpContext.LastRead <= 0)
			{
				DbgW("httpContext.LastRead <= 0; LastRead == " + httpContext.LastRead + 
					 "httpContext.Offset == " + httpContext.Offset + "; disconnecting socket");
				socket.CleanDisconnect();
				DbgW("Exiting OnReceive(1)");
				return;
			}

			// Have we received a complete header from this socket yet?
			if (!httpContext.HeaderReceived)
			{
				// Did we get a complete header this time around?
				int eohIdx = GetEndOfHeaderIndex(httpContext.Buffer);
				if (eohIdx == -1)
				{
					// More header goodness to read; buffer was too small - double the buffer size
					httpContext.GrowBuffer((uint)httpContext.Buffer.Length);
					socket.Receive(httpContext, new IOCPSocket.ReceiveHandler(OnReceive), null);
					DbgW("Exiting OnReceive(2)");
					return;
				}

				// We have the header
				httpContext.HeaderReceived = true;
				httpContext.Header = Encoding.ASCII.GetString(httpContext.Buffer, 0, eohIdx + 1);
				httpContext.ContentLength = GetContentLength(httpContext.Header);
				DbgW("Received Header: " + httpContext.Header);
				GrowBufferToFinalSize(ref httpContext);

				// Are they expecting a 100-Continue?
				if (GetExpectContinue(httpContext.Header) || IsContinueRequired(httpContext))
				{
					// Ask nicely for the body
					httpContext.DbgDumpContents();
					RespondAndReceiveMore(socket, httpContext, Continue);
					DbgW("Exiting OnReceive(3)");
					return;
				}
			}
			if (httpContext.HeaderReceived)
			{
				// At least part of the body (if any) is here
				string header = httpContext.Header;

				// Did we receive the entire body?
				if (httpContext.Header.Length + httpContext.ContentLength != httpContext.Offset)
				{
					// Go back to the well for more water
					ContinueReceiving(socket, 0, httpContext);
                    DbgW("Exiting OnReceive(4)");
					return;
				}

				int eohIdx = GetEndOfHeaderIndex(httpContext.Buffer);
				string bodyData = Encoding.ASCII.GetString(httpContext.Buffer, eohIdx + 1, httpContext.ContentLength);
				DbgW("Received Body");

				// Sleep if delay is set.
				if (delay > 0)
				{
					Thread.Sleep(delay);
				}

				// Mock the server ruthlessly?
				if (PercentError > 0 && randGen.Next(0,100) < PercentError)
				{
					RespondAndRecycle(socket, httpContext, badreq);
				}
				else
				{
					byte []	respBody;	// http body
					bool retval = ProcessData(httpContext.Buffer, eohIdx + 1, httpContext.ContentLength, out respBody);

					//Send final code
					if (retval)
					{
						if (respBody == null)	// response for the http request only contains header, no body
						{
							RespondAndRecycle(socket, httpContext, ReqOk);
						}
						else
						{
							int			respBodyLen = respBody.Length;
							string		respHeaderStr = "HTTP/1.1 200 OK\r\nServer: NotMicrosoft-IIS/5.0\r\nX-Powered-By: Seanwo.NET\r\nX-SeanwoNet-Version:" +
								" 1.1.0000\r\nCache-Control: private\r\nContent-Length: "+ respBodyLen +"\r\n\r\n";
							int			respHeaderLen = respHeaderStr.Length;

							byte[]		respHeader = Encoding.ASCII.GetBytes(respHeaderStr);
							byte[]		completeResp = new byte[respHeaderLen + respBodyLen];

							Array.Copy(respHeader, completeResp, respHeaderLen);
							Array.Copy(respBody, 0, completeResp, respHeaderLen, respBodyLen);

							RespondAndRecycle(socket, httpContext, completeResp);
						}
					}
					else
					{
						RespondAndRecycle(socket, httpContext, badreq);
					}
				}
			}
			DbgW("Exiting OnReceive(5)");
		}

		/// <summary>
		/// Virtual function for processing content data
		/// </summary>
		/// <param name="ReqData"></param>
		/// <param name="ConIndex"></param>
		/// <param name="conLen"></param>
		/// <returns></returns>
		public virtual bool ProcessData(byte[] ReqData, int ConIndex, int conLen)
		{
			// if true the Listner response with 200 ok else with 500 bad request. 
			// ConIndex is the index in the buffere where the content starts
			// and conLen is the lendth of the data
			return true;
		}

		/// <summary>
		/// This is for processing requests whose reponse contains both header and body.
		/// </summary>
		/// <param name="ReqData"></param>
		/// <param name="ConIndex">the index in the buffere where the content starts</param>
		/// <param name="conLen">the lendth of the data</param>
		/// <param name="respBuff"></param>
		/// <returns></returns>
		public virtual bool ProcessData(byte[] ReqData, int ConIndex, int conLen,out byte[] resp)
		{
			resp = null;
			return ProcessData(ReqData,ConIndex,conLen);
		}

		/// <summary>
		/// The main listener thread
		/// </summary>
		protected override void ThreadBody()
		{
			DbgW("Entered ThreadBody()");

			try
			{
				sock = new IOCPSocket();
				IPEndPoint localEP = new IPEndPoint(IPAddress.Any, port);
				try
				{
					sock.Bind(localEP);
					sock.Listen(254);
				}
				catch(SocketException e)
				{
					throw new Exception("Listener failed to Bind or Listen to port 0x" + port.ToString("X"), e);
				}

				bool ShuttingDown = false;
				while (!ShuttingDown)
				{
					try
					{
						// Begin accepting incoming connections
						sock.Accept(new IOCPSocket.AcceptHandler(OnAccept), null);

						bool cont;
						do
						{
							// Wait for AcceptCallback to potentially get called and then finish with our main socket
							// Also wake up and check to see if it's shutdown time every 250 ms
							cont = ConnectionAccepted.WaitOne(250, false);
							ShuttingDown = ShutDownEvent.WaitOne(0, false);
						} while (!cont && !ShuttingDown);
					}
					catch(System.Threading.ThreadAbortException)
					{
						// Thread told to shutdown; goto finally block
						break;
					}
					catch (SocketException e)
					{
						Console.WriteLine("socket exception 0x" + e.NativeErrorCode.ToString("X"));
						break;
					}
					catch (Exception e )
					{
						Console.WriteLine("unexpected exception:");
						Console.WriteLine(e.ToString()); 
						break;
					}
				} // << end while true >>
			}
			finally
			{
				sock.CleanDisconnect();
				Console.WriteLine("Terminated listener.");
			}
			DbgW("Exiting ThreadBody()");
		}

		public override void Stop()
		{
			IsRunning = false;
			ShutDownEvent.Set();
			//base.Stop();
			base.Join();
		}

		public override void Go()
		{
			IsRunning = true;
			ShutDownEvent.Reset();

			base.Go();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\dbposter\dbposter.cs ===
//DBPoster was moved from an old SQL tool that several tests required as a manual pre-step to use.
//It was then converted to webstore.  There is likely a good amount of old unused code floating around all of this.

using System;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Diagnostics;
using System.Text.RegularExpressions;

using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Utilities.DBPoster
{
    public enum DBPMode
    {
        DBP_NONE,
        DBP_ADD,
        DBP_UPDATE
    };

    public class ImportFileException : System.Exception
    {
        public ImportFileException() : base() {}
        public ImportFileException(string s) : base(s) {}
        public ImportFileException(string s, System.Exception e) : base(s, e) {}
    }

    public struct RowCommand
    {
        public string databasename;
        public DBTable table;
        public string[] rowvalues;
        public uint []rowPartitions;
    }

    public class DBPoster
    {
        private bool info = false;
        private DBPMode mode = DBPMode.DBP_ADD;
        private ArrayList tables = new ArrayList();
        WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
        //WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        bool wasFailure=false;

        public string stringKEK = null;

        static bool IsParam(string s, string param)
        {
            if (s.Length > 0 && (s[0] == '-' || s[0] == '/') && s.Substring(1) == param)
            {
                return true;
            }
            return false;
        }

        // Main DBPoster Interface
        public static bool Post(DBPMode mode, string layoutFilename, string dataFilename)
        {
            return Post(mode, layoutFilename, dataFilename, null, false);
        }
        public static bool Post(DBPMode mode, string layoutFilename, string dataFilename, string kek, bool showCommandOnly)
        {
            //make the poster object and set it up
            DBPoster dbposter = new DBPoster();

            dbposter.mode=mode;

            if (kek!=null)
            {
                dbposter.stringKEK=kek;
            }

            if (showCommandOnly!=false)
            {
                dbposter.info=true;
            }

            //do the post
            dbposter.Run(dataFilename, layoutFilename);

            return !dbposter.wasFailure;
        }

        //
        void LoadTables(string filename)
        {
            FileStream fs = File.OpenRead(filename);
            StreamReader sr = new StreamReader(fs);

            string tablename = null;
            bool partitioned = false;
            ArrayList tableentries = new ArrayList();

            String s = sr.ReadLine().Trim();
            while (s != null)
            {
                if (s == "")
                {
                    s = sr.ReadLine();
                    continue;
                }

                if (s.StartsWith("["))
                {
                    if (tablename != null)
                    {
                        tables.Add(new DBTable(tablename, partitioned, (string[])tableentries.ToArray(typeof(System.String))));
                        tableentries.Clear();
                    }

                    char[] separators = {','};
                    string[] tableline = s.Remove(s.Length-1, 1).Remove(0, 1).Split(separators);
                    TrimStrArray(tableline);
                    tablename = tableline[0];
                    partitioned = tableline[1] == "partitioned";

                    s = sr.ReadLine();
                    continue;
                }

                if (tablename == null)
                {
                    throw new ImportFileException("Table name must be the first line in file.");
                }

                tableentries.Add(s);

                s = sr.ReadLine();
            }

            tables.Add(new DBTable(tablename, partitioned, (string[])tableentries.ToArray(typeof(System.String))));
        }

        long HexStrToInt(string s)
        {
            if (s.ToLower().StartsWith("0x"))
            {
                s = s.Remove(0, 2);
            }

            long val = 0;
            for (int i = 0; i < s.Length; i++)
            {
                byte nibble = DbpScriptEngine.unhex(s[i]);
                val = (val << 4) | nibble;
            }

            return val;
        }

        string DBFormat(DBTable table, int index, string s)
        {
            if (s.StartsWith("$") && !s.StartsWith("$$"))
                return s.Substring(1);
            else if (s.StartsWith("$$"))
                s = s.Substring(1);

            switch(table.getColumnType(index))
            {
                case SQLDataType.SDT_TINYINT: return s.ToLower().StartsWith("0x") ? ((byte)HexStrToInt(s)).ToString() : s;
                case SQLDataType.SDT_SMALLINT: return s.ToLower().StartsWith("0x") ? ((short)HexStrToInt(s)).ToString() : s;
                case SQLDataType.SDT_INT: return s.ToLower().StartsWith("0x") ? ((int)HexStrToInt(s)).ToString() : s;
                case SQLDataType.SDT_BIGINT: return s.ToLower().StartsWith("0x") ? HexStrToInt(s).ToString() : s;
                case SQLDataType.SDT_SMALLDATETIME:
                case SQLDataType.SDT_DATETIME: return "'" + s + "'";
                case SQLDataType.SDT_NVARCHAR: return "'" + s + "'";
                case SQLDataType.SDT_VARCHAR: return "'" + s + "'";
                case SQLDataType.SDT_BINARY: return s;
                case SQLDataType.SDT_VARBINARY: return s;
                case SQLDataType.SDT_REAL: return s;
                case SQLDataType.SDT_FLOAT: return s;
                default: Debug.Assert(false); break;
            }

            return s;
        }

        void ExecuteCommand(string databasename, DBTable table, string[] row, uint []hashvals)
        {
            bool isPart = hashvals!=null;
            uint []vals=hashvals;
            if (!isPart) //do on all (physical)
            {
                ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Physical;

                vals=new uint[ws.PhysicalPartitions];
                for (uint i=0;i<ws.PhysicalPartitions;++i)
                {
                    vals[i]=i;
                }
            }
            else //use logical partitioning (hash)
            {
                ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Logical;
                ws.Partition = 1;
            }

            foreach (uint val in vals)
            {
                if (isPart)
                {
                    //ws.SetHashVal(val);
                    ws.Partition=(int)val;
                    if (info)
                    {
                        Console.WriteLine("set hash to: "+val+" (should be partition "+ws.GetPhysicalPartition((int)val)+")");
                    }
                }
                else
                {
                    ws.PhysicalPartition=(int)val;
                    if (info)
                    {
                        Console.WriteLine("set partition to: "+val);
                    }
                }

                if (mode == DBPMode.DBP_ADD)
                {
                    ExecuteInsert(databasename, table, row);
                }
                //else if (mode == DBPMode.DBP_COMPARE)
                //{
                //    bool itemfound = ExecuteCompare(databasename, table, row, false);
                //}
                //else if (mode == DBPMode.DBP_REMOVE)
                //{
                //    ExecuteRemove(databasename, table, row);
                //}
                else if (mode == DBPMode.DBP_UPDATE)
                {
                    ExecuteUpdateOrInsert(databasename, table, row);
                }
            }
        }

        void ExecuteInsert(string databasename, DBTable table, string[] rowvalues)
        {
            string command = "INSERT INTO " + table.getTableName() + " VALUES (";

            for (int i = 0; i < rowvalues.Length; i++)
            {
                command += DBFormat(table, i, rowvalues[i]) + ", ";
            }

            //remove the last ", " from the end of command
            command = command.Remove(command.LastIndexOf(", "), 2);

            command += ")";

            if (!info)
            {
                ws.CommandSql=command;
                try
                {
                    ws.ExecuteNonQuery();
                }
                catch(Exception sqle)
                {
                    wasFailure=true;
                    // 2627 = Violation of primary key constraint, i.e. already exists
                    //if (sqle.Number != 2627)
                    //{
                    Console.Out.WriteLine("Command: " + command);
                    Console.WriteLine("  Failed -- \"{0}\"", sqle.Message);
                    //}
                }
            }
            else
            {
                Console.Out.WriteLine(command);
            }
        }


        void ExecuteUpdateOrInsert(string databasename, DBTable table, string[] rowvalues)
        {
            //TODO: change this to use a single sql query with an if statement, so we don't have to hit the server 2x per entry

            // Check for existence of record
            string command = "SELECT COUNT(*) FROM " + table.getTableName();
            string keys = "";
            for (int i = 0; i < rowvalues.Length; i++)
            {
                // Is this a key column?
                if (table.getColumnMark(i) > 0)
                {
                    keys += table.getColumnName(i) + "=" + DBFormat(table, i, rowvalues[i]) + " AND ";
                }
            }

            //remove the last ", " from the end of command
            keys = keys.Remove(keys.LastIndexOf(" AND "), 5);

            // finish building commmand
            command += " WHERE " + keys;

            ws.CommandSql=command;
            try
            {
                if ((int)ws.ExecuteScalar() == 0)
                {
                    // Not in database
                    ExecuteInsert(databasename, table, rowvalues);
                }
                else
                {
                    // Already exists
                    ExecuteUpdate(databasename, table, rowvalues);
                }
            }
            catch(SqlException sqle)
            {
                wasFailure=true;
                Console.Out.WriteLine("Command: " + command);
                Console.WriteLine("  Failed -- \"{0}\"", sqle.Message);
            }
        }

        void ExecuteUpdate(string databasename, DBTable table, string[] rowvalues)
        {
            string command = "UPDATE " + table.getTableName();

            // Build list of key constraints and values at same time
            string values = "";
            string keys = "";
            for (int i = 0; i < rowvalues.Length; i++)
            {
                // If a key, we can't update the value, so it's a constraint
                if (table.getColumnMark(i) > 0)
                {
                    keys += table.getColumnName(i) + "=" + DBFormat(table, i, rowvalues[i]) + " AND ";
                }
                else
                {
                    values += table.getColumnName(i) + "=" + DBFormat(table, i, rowvalues[i]) + ", ";
                }
            }

            //remove the last ", " from the end of command
            keys = keys.Remove(keys.LastIndexOf(" AND "), 5);
            values = values.Remove(values.LastIndexOf(", "), 2);

            // finish building commmand
            command += " SET " + values;
            command += " WHERE " + keys;

            if (!info)
            {
                ws.CommandSql=command;
                try
                {
                    ws.ExecuteNonQuery();
                }
                catch(Exception sqle)
                {
                    wasFailure=true;
                    // 2627 = Violation of primary key constraint, i.e. already exists
                    //if (sqle.Number != 2627)
                    //{
                    Console.Out.WriteLine("Command: " + command);
                    Console.WriteLine("  Failed -- \"{0}\"", sqle.Message);
                    //}
                }
            }
            else
            {
                Console.Out.WriteLine(command);
            }
        }

        //gets... a block of 256 puids?  from npdb?
        private ulong GetPuidBlock(string dbName, bool bXenon)
        {
            uint bucket = (uint)(new Random().Next(420));

            if (info)
            {
                Console.Out.WriteLine("Would retrieve puids here.");
                return 0;
            }
            else
            {
                Database.Npdb npdb=new Database.Npdb();
                npdb.ConnectToServer();
                ulong puids=npdb.AllocatePuids(bucket, 256, null, (bXenon?0xFA00000000000000:0));
                npdb.Close();

                return puids;
            }
        }

        void Run(string filename, string tablesfilename)
        {
            string dbusername = null;
            string dbpassword = null;
            //string[] dbcluster = null;
            //string[] dbpuid = null;
            bool ingeneralsection = false;
            string databasename = null;
            int deletecolumn = 0;
            int testcolumn = 0;

            DBTable table = null;
            RowCommand testalreadycommand;
            testalreadycommand.databasename = null; testalreadycommand.table = null; testalreadycommand.rowvalues = null;

            DbpScriptEngine dbpscript = new DbpScriptEngine();

            dbpscript.stringKEK=stringKEK;

            try
            {
                try
                {
                    LoadTables(tablesfilename);
                }
                catch(Exception e)
                {
                    throw new ImportFileException("Error loading tables file", e);
                }

                // rows is an arraylist of RowCommands
                ArrayList rows = new ArrayList();

                FileStream fs = File.OpenRead(filename);
                StreamReader sr = new StreamReader(fs);

                string s = sr.ReadLine().Trim();
                while (s != null)
                {
                    if (s == "")
                    {
                        s = sr.ReadLine();
                        continue;
                    }

                    if (s.StartsWith("["))
                    {
                        if (s == "[general]")
                        {
                            ingeneralsection = true;
                            s = sr.ReadLine();
                            continue;
                        }

                        if (dbusername == null)
                        {
                            throw new ImportFileException("File must start with a [general] section.");
                        }

                        // We are leaving the general section
                        if (ingeneralsection)
                        {
                            ingeneralsection = false;
                        }

                        char[] separators = {' '};
                        string[] tableheader = s.Split(separators);
                        TrimStrArray(tableheader);

                        if (tableheader.Length < 3 || tableheader[1] != "in")
                        {
                            throw new ImportFileException("Table header should be in the format \"[<tablename> in <databasename>]\".");
                        }

                        string tablename = TrimBrackets(tableheader[0]);
                        databasename = TrimBrackets(tableheader[2]);
                        
                        // Parse newly added key/value pairs. Currently supports the following:
                        //   deletecolumn=<0-based column number>, default is 0
                        //   testcolumn=<0-based column number>, default is 0
                        // Both are optional.
                        deletecolumn = 0;
                        testcolumn = 0;
                        if (tableheader.Length >= 4) 
                        {
                            for (int pairidx = 3; pairidx < tableheader.Length; pairidx++)
                            {
                                char[] separators2 = {'='};
                                string[] s2 = tableheader[pairidx].Split(separators2);
                                TrimStrArray(s2);
                                if (s2.Length != 2)
                                {
                                    throw new ImportFileException("Table header should be in the format \"[<tablename> in <databasename> [deletecolumn=<columnnumber>] [testcolumn=<columnnumber>]]\".");
                                }
                                else if (s2[0] == "deletecolumn")
                                {
                                    deletecolumn = int.Parse(TrimBrackets(s2[1]));
                                }
                                else if (s2[0] == "testcolumn")
                                {
                                    testcolumn = int.Parse(TrimBrackets(s2[1]));
                                }
                                else
                                {
                                    throw new ImportFileException("Table header should be in the format \"[<tablename> in <databasename> [deletecolumn=<columnnumber>] [testcolumn=<columnnumber>]]\".");
                                }
                            }
                        }

                        table = FindTable(tables, tablename);

                        if (table == null)
                        {
                            throw new ImportFileException("Table \"" + tablename + "\" not found in table definition file.");
                        }
                        
                        s = sr.ReadLine();
                        continue;
                    }

                    if (ingeneralsection)
                    {
                        Debug.Assert(table == null);
                        char [] c = {'='};
                        string[] keyvalue = s.Split(c);

                        if (keyvalue[0] == "name")
                        {
                            dbusername = keyvalue[1];
                        }
                        else if (keyvalue[0] == "password")
                        {
                            dbpassword = keyvalue[1];
                        }
                        else if (keyvalue[0] == "test")
                        {
                            Regex regex = new Regex(@"^.+?=(?<username>.+) in (?<tablename>\w+) in (?<databasename>\w+)$");
                            Match match = regex.Match(s);

                            if (match.Success)
                            {
                                testalreadycommand.databasename = match.Groups["databasename"].Value;
                                testalreadycommand.table = FindTable(tables, match.Groups["tablename"].Value);
                                testalreadycommand.rowvalues = new string[1];
                                testalreadycommand.rowvalues[0] = match.Groups["username"].Value;
                            }
                        }
                        else
                        {
                            throw new ImportFileException("\"" + s + "\" not recognized.");
                        }

                        s = sr.ReadLine();
                        continue;
                    }

                    RowCommand row;

                    char[] delim = {'\t'};
                    row.rowvalues = s.Split(delim);

                    row.databasename = databasename;
                    row.table = table;

                    for (int i = 0; i < 2; i++)
                    {
                        try
                        {
                            dbpscript.Run(row.rowvalues, row.table);
                            break;
                        }
                        catch(OutOfPuidsException e)
                        {
                            int puidblocksize = 256;
                            ulong puidblockstart = GetPuidBlock("npdb", e.IsXenon);
                            dbpscript.AddPuidBlock((long)puidblockstart, puidblocksize, e.IsXenon);
                        }
                    }

                    row.rowPartitions = FindPartitions(ws, table, row.rowvalues[0]);
                    rows.Add(row);

                    s = sr.ReadLine();
                }

                /*if (mode == DBPMode.DBP_REMOVE)
                {
                    for (int i = rows.Count-1; i >= 0; i--)
                    {
                        RowCommand row = (RowCommand)rows[i];
                        ExecuteCommand(row.databasename, row.table, row.rowvalues, row.rowPartitions);
                    }
                }
                else*/
                {
                    for (int i = 0; i < rows.Count; i++)
                    {
                        RowCommand row = (RowCommand)rows[i];
                        ExecuteCommand(row.databasename, row.table, row.rowvalues, row.rowPartitions);
                    }
                }

                Console.WriteLine("Done.");

                // Dump users to file, so we can map gamertags <-> puids
                string dumpfile = Path.GetFileNameWithoutExtension(filename) + ".log";
                if (this.mode == DBPMode.DBP_ADD || this.mode == DBPMode.DBP_UPDATE)
                {
                    dbpscript.DumpUsers(dumpfile, false);
                }

                // Dump machines to file, so we can map machine ids <-> onlinekey
                if (this.mode == DBPMode.DBP_ADD || this.mode == DBPMode.DBP_UPDATE)
                {
                    dbpscript.DumpMachines(dumpfile, true);
                }

            }
            catch (Exception e) 
            {
                Console.WriteLine("PBPoster failed: " + e);
            }
            finally
            {
            }
        }

        private static void TrimStrArray(string[] sa)
        {
            for (int i = 0; i < sa.Length; i++)
            {
                sa[i] = sa[i].Trim();
            }
        }

        private static string TrimBrackets(string s)
        {
            if (s.Length <= 0)
                return s;

            if (s[0] == '[' || s[0] == ']')
            {
                s = s.Remove(0, 1);
            }
            if (s[s.Length-1] == '[' || s[s.Length-1] == ']')
            {
                s = s.Remove(s.Length-1, 1);
            }
            return s;
        }

        private static DBTable FindTable(ArrayList tables, string tablename)
        {
            DBTable table = null;

            for (int i = 0; i < tables.Count; i++)
            {
                if (((DBTable)tables[i]).getTableName() == tablename)
                {
                    table = (DBTable)tables[i];
                    break;
                }
            }

            return table;
        }

        //gets a list of partition hashes (null means all partitions)
        private static uint[] FindPartitions(WSClient ws, DBTable table, string rowvalue)
        {
            uint[] returnedconnections=null; //null means do all partitions

            if (table.getPartitioned())
            {
                returnedconnections = new uint[1];
                returnedconnections[0] = (uint)DbpScriptEngine.GetWSHashValue(ws,table,0,rowvalue);
            }

            return returnedconnections;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\dbposter\DbpScriptEngine.cs ===
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Collections;
using System.Security.Cryptography;
using System.Text;
using System.IO;

using xonline.common.sql.webstore;

namespace ServerTestFramework.Utilities.DBPoster
{
    internal class OutOfPuidsException : Exception
    {
        public bool IsXenon = false;
        public OutOfPuidsException() : base() {}
        public OutOfPuidsException(bool isXenon) : base() 
        {
            IsXenon = isXenon;
        }
    }

    internal struct UserRow
    {
        public string name;
        public long puid;

        public byte[] enckey;
        public byte[] rawkey;
        public byte[] iv;
        public byte[] ppa2;
        public byte[] sppa1;
    }

    internal struct MachineRow
    {
        public string name;
        public byte[] key;
        public string onlinekey; // base64'd publicly encrypted version of rawkey
        public byte[] ppa2;
        public byte[] sppa1;
    }

    internal class DbpScriptEngine
    {
        private Queue puids = new Queue();
        private Queue puidsXenon = new Queue();
        private Hashtable puidhash = new Hashtable();
        private Hashtable userhash = new Hashtable();
        private Hashtable machinehash = new Hashtable();

        public string stringKEK = null;

        public DbpScriptEngine()
        {
        }

        public void AddPuidBlock(long start, int size, bool isXenon)
        {
            Queue p = isXenon ? puidsXenon : puids;
            for (long i = start; i < start + size; i++)
            {
                p.Enqueue(i);
            }
        }

        //TODO: This GenOnlineKey.exe (for which we don't have the source) hasn't been binplaced ever with STF... do we actually need to call this?
        public string GenOnlineKeyImmediate(string serial, byte[] key)
        {
            ProcessStartInfo si = new ProcessStartInfo("GenOnlineKey.exe", tohex(key) + " " + serial);
            si.RedirectStandardOutput = true;
            si.CreateNoWindow = false;
            si.UseShellExecute = false;
            Process p = Process.Start(si);
            string output = p.StandardOutput.ReadToEnd();
            p.WaitForExit();
            char[] trimchars = {'\n', '\r', ' ', '\t'};
            return output.TrimEnd(trimchars);
        }

        // Returns a marker that can later be post-processed to get the key
        public string GenOnlineKey(string serial, byte[] key)
        {
            //return "$$onlinekey(" + tohex(key) + " " + serial + ")";
            return GenOnlineKeyImmediate(serial, key);
        }

        public UserRow GetUser(string name, string keyparam)
        {
            // Check hash for full user name
            string fullname = name + "_key_" + keyparam;
            if (userhash.Contains(fullname))
            {
                return (UserRow)userhash[fullname];
            }

            // Create new user. First get puid, and check short user name to see if we allocated
            // one already.
            long puid = GetPuid(name);

            // Build and store user
            UserRow userrow = BuildUser(name, puid, keyparam);
            userhash.Add(fullname, userrow);
            return userrow;        
        }

        public long GetPuid(string name)
        {
            // Check hash for existing user & puid
            if (puidhash.Contains(name))
            {
                return (long)puidhash[name];
            }

            bool isXenon = false;
            if (name.ToUpper().StartsWith("XE."))
            {
                isXenon = true;
            }
            Queue p = isXenon ? puidsXenon : puids;

            // Allocate new puid if user not found
            try
            {
                long puid = (long)p.Dequeue();
                puidhash.Add(name, puid);
                return puid;
            }
            catch(InvalidOperationException)
            {
                throw new OutOfPuidsException(isXenon);
            }
        }

        public UserRow BuildUser(string name, long puid, string rawkey)
        {
            UserRow userrow = new UserRow();
            userrow.name = name;
            userrow.puid = puid;

            byte[] kek;
            if (stringKEK == null)
            {
                // This is the un-encrypted version of the Key Encryption Key stored as key_id 5
                // in t_service_keys.  It's encrypted in the database.  The default one (this one)
                // is for Testnet.
                kek = ServerTestFramework.LiveService.Auth.ServiceKeys.GetServiceKey(ServerTestFramework.LiveService.Auth.ServiceKeys.Key_KEK);
            }
            else
            {
                kek = unhex(stringKEK);
            }

            // Store rawkey, should be 32 characters or 34 with "0x" on front
            if (rawkey == null)
                rawkey = Hexer.tohex(ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(name, true));
            else if (rawkey.Length < 32)
                rawkey = rawkey.PadLeft(32, '0');
            userrow.rawkey = unhex(rawkey);

            Ppa.GenerateKey(kek, userrow.rawkey, out userrow.iv, out userrow.enckey);
            userrow.sppa1 = Ppa.GenSppa1(name, userrow.rawkey);
            userrow.ppa2 = Ppa.GenPpa2(name, userrow.rawkey);

            return userrow;
        }

        public MachineRow GetMachine(string name)
        {
            if (machinehash.Contains(name))
            {
                return (MachineRow)machinehash[name];
            }
            else
            {
                MachineRow machinerow = new MachineRow();

                string serial = name.Substring(0, 12);
                int sequence = Int32.Parse(name.Substring(name.IndexOf("-") + 1));

                machinerow.name = serial;

                // the key is 12 0's followed by the serial number followed by c0ffee followed by the sequence number
                // example: 0x000000000000020000007800c0ffee05 is the fifth key for serial 020000007700
                machinerow.key = unhex("000000000000" + serial + "c0ffee" + sequence.ToString("d2"));

                machinerow.sppa1 = Ppa.GenSppa1(serial, machinerow.key);
                machinerow.ppa2 = Ppa.GenPpa2(serial, machinerow.key);

                machinerow.onlinekey = GenOnlineKey(serial, machinerow.key);

                machinehash.Add(name, machinerow);
                return machinerow;
            }
        }

        public void DumpUsers(string filename, bool append)
        {
            // Format is:
            // DBPOSTUSER|username|puid|rawkey|enckey|iv|ppa2|sppa1

            if (userhash.Count <= 0)
                return;

            // The using statement also closes the file
            using (StreamWriter sw = new StreamWriter(filename, append))
            {
                foreach (object o in userhash.Values)
                {
                    UserRow u = (UserRow)o;
                    sw.WriteLine("DBPOSTUSER|{0}|{1}|{2}|{3}|{4}|{5}",
                        u.name,
                        u.puid,
                        tohex(u.rawkey),
                        tohex(u.enckey),
                        tohex(u.iv),
                        tohex(u.ppa2),
                        tohex(u.sppa1));
                }
            }
        }

        public void DumpMachines(string filename, bool append)
        {
            // Format is:
            // DBPOSTMACH|name|key|onlinekey|ppa2|sppa1

            if (machinehash.Count <= 0)
                return;

            // The using statement also closes the file
            using (StreamWriter sw = new StreamWriter(filename, append))
            {
                foreach (object o in machinehash.Values)
                {
                    MachineRow m = (MachineRow)o;
                    sw.WriteLine("DBPOSTMACH|{0}|{1}|{2}|{3}|{4}",
                        m.name,
                        tohex(m.key),
                        m.onlinekey,
                        tohex(m.ppa2),
                        tohex(m.sppa1));
                }
            }
        }

        public void Run(string[] row, DBTable table)
        {
            for (int i = 0; i < row.Length; i++)
            {
                if (row[i].StartsWith("$"))
                {
                    string param = null;
                    string param2 = null;

                    int parenopen = row[i].IndexOf('(', 2);
                    int parenclose = row[i].IndexOf(')', parenopen + 1);

                    string command = row[i].Substring(1);
                    if (parenopen != -1)
                        command = row[i].Substring(1, parenopen - 1);

                    if (parenclose != -1)
                        param = row[i].Substring(parenopen + 1, parenclose - parenopen - 1);

                    if (param != null)
                    {
                        int comma = param.IndexOf(',');
                        if (comma != -1)
                        {
                            param2 = param.Substring(comma + 1);
                            param = param.Substring(0, comma);
                        }
                    }

                    row[i] = Execute(row, table, i, command, param, param2);
                }
            }
        }

        public string Execute(string[] row, DBTable table, int commandindex, string command, string param, string param2)
        {
            switch(command)
            {
                case "now":
                    return "$getutcdate()";
                case "yesterday":
                    return "$dateadd(d, -1, getutcdate())";
                case "tomorrow":
                    return "$dateadd(d, +1, getutcdate())";
                case "bucket":
                    return HashOnColumn(table, 0, row[0]).ToString();
                case "null":
                    return "$null";
                
                // User info, parameter is user name
                case "puid":
                    return GetUser(param, param2).puid.ToString();
                case "ppa2":
                    return "0x" + tohex(GetUser(param, param2).ppa2);
                case "sppa1":
                    return "0x" + tohex(GetUser(param, param2).sppa1);
                case "key":
                    return "0x" + tohex(GetUser(param, param2).enckey);
                case "iv":
                    return "0x" + tohex(GetUser(param, param2).iv);

                // Genealogy info, parameter is machine name
                case "macppa2":
                    return "0x" + tohex(GetMachine(param).ppa2);
                case "macsppa1":
                    return "0x" + tohex(GetMachine(param).sppa1);
                case "maconlinekey":
                    return GetMachine(param).onlinekey;
                
                // User info, parameter is index of column containing user name
                case "puidcol":
                    return GetUser(row[int.Parse(param)], param2).puid.ToString();
                case "ppa2col":
                    return "0x" + tohex(GetUser(row[int.Parse(param)], param2).ppa2);
                case "sppa1col":
                    return "0x" + tohex(GetUser(row[int.Parse(param)], param2).sppa1);
                case "keycol":
                    return "0x" + tohex(GetUser(row[int.Parse(param)], param2).enckey);
                case "ivcol":
                    return "0x" + tohex(GetUser(row[int.Parse(param)], param2).iv);

                // Misc
                case "voucher":
                    return "0x" + tohex(Ppa.CalculateVoucherSha(param));
                
                default:
                    throw new ImportFileException("Command \"" + command + "\"doesn't exist");
            }                    
        }

        public static uint GetBucket(DBTable table, string rowvalue)
        {
            return HashOnColumn(table, 0, rowvalue);
        }

        static uint HashOnColumn(DBTable table, int index, string s)
        {
            switch(table.getColumnType(index))
            {
                case SQLDataType.SDT_TINYINT:
                case SQLDataType.SDT_SMALLINT:
                case SQLDataType.SDT_INT:
                case SQLDataType.SDT_BIGINT: return HashBucket((long)TypeDescriptor.GetConverter(typeof(long)).ConvertFromString(s));
                case SQLDataType.SDT_SMALLDATETIME:
                case SQLDataType.SDT_DATETIME:
                case SQLDataType.SDT_BINARY: return HashBucket(BitConverter.ToUInt64(unhex(s), 0));  // first 8 bytes.. works for t_vouchers, at least
                case SQLDataType.SDT_NVARCHAR: return HashBucket(s.ToLower());
                case SQLDataType.SDT_VARCHAR: return HashBucket(s.ToLower());
                default: Debug.Assert(false); return 0;
            }
        }

        public static uint GetWSHashValue(WSClient ws, DBTable table, int index, string s)
        {
            switch(table.getColumnType(index))
            {
                case SQLDataType.SDT_TINYINT:
                case SQLDataType.SDT_SMALLINT:
                case SQLDataType.SDT_INT:
                case SQLDataType.SDT_BIGINT: return (uint)ws.CalcPartition((long)TypeDescriptor.GetConverter(typeof(long)).ConvertFromString(s));
                case SQLDataType.SDT_SMALLDATETIME:
                case SQLDataType.SDT_DATETIME:
                case SQLDataType.SDT_BINARY: return (uint)ws.CalcPartition((ulong)BitConverter.ToUInt64(unhex(s), 0));  // first 8 bytes.. works for t_vouchers, at least
                case SQLDataType.SDT_NVARCHAR: return (uint)ws.CalcPartition(s.ToLower());
                case SQLDataType.SDT_VARCHAR: return (uint)ws.CalcPartition(s.ToLower());
                default: Debug.Assert(false); return 0;
            }
        }

        private const uint PRIME_A = 31415;
        private const uint PRIME_B = 27183;
        private const uint PRIME_K = 16381;

        private static uint HashBucket(string s)
        {
            uint h = 0;
            uint a = PRIME_A;
            int i = 0;

            while (i < s.Length)
            {
                h = (a*h + s[i]) % PRIME_K;
                a = a*PRIME_B % (PRIME_K-1);
                i++;
            }

            return h % 420;
        }
        
        private static uint HashBucket(long v)
        {
            unchecked
            {
                ulong uv = (ulong)v;
                return HashBucket(uv);
            }
        }

        private static uint HashBucket(ulong v)
        {
            uint h = 0;
            uint a = PRIME_A;
            uint vLow = (uint)(v >> 32);
            uint vHigh = (uint)v;

            for(int i = 0; i < 4; i++)
            {
                h = (a * h + (byte)vLow) % PRIME_K;
                a = a * PRIME_B % (PRIME_K-1);
                vLow = vLow >> 8;
            }

            for(int i = 0; i < 4; i++)
            {
                h = (a * h + (byte)vHigh) % PRIME_K;
                a = a * PRIME_B % (PRIME_K-1);
                vHigh = vHigh >> 8;
            }

            return h % 420;
        }

        public static byte[] unhex(string s)
        {
            if (s.StartsWith("0x"))
                s = s.Substring(2);

            if (s.Length % 2 == 1)
                s = "0" + s;

            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }
            return hex;
        }

        public static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }

        private static char hex(byte b)
        {
            if (b < 10)
                return (char)('0' + b);
            else
                return (char)('a' + (b - 10));
        }

        private static char hexchar(byte b)
        {
            if (b < 10)
                return (char)('0' + b);
            else
                return (char)('a' + (b - 10));
        }

        private static string tohex(byte[] b)
        {
            string s = "";
            for (int i = 0; i < b.Length; i++)
                s += hexchar((byte)(b[i] >> 4)).ToString() + hexchar((byte)(b[i] & 15)).ToString();
            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\dbposter\Ppa.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

namespace ServerTestFramework.Utilities.DBPoster
{
    public class Ppa
    {
        public const int XONLINE_GAMERTAG_SIZE = 16;
        public static SHA1 sha = new SHA1Managed();

        private static byte[] MakeHashableName(string s)
        {
            byte[] tempbytes = new ASCIIEncoding().GetBytes(s.ToUpper());

            byte[] data = new byte[16];
            tempbytes.CopyTo(data, 0);

            return data;
        }

        public static byte[] CalculateNameSha(string s)
        {
            return sha.ComputeHash(MakeHashableName(s));
        }

        public static byte[] CalculateVoucherSha(string s)
        {
            // Format:  nnnnn-nnnnn-nnnnn-nnnnn-nnnnn\0
            // Must be unicode, not ascii
            // Don't forget the null terminator
            // Must be uppercase
            // Must have "-" every 5 characters
            byte[] data = new UnicodeEncoding().GetBytes(s.ToUpper() + "\0");
            return sha.ComputeHash(data);
        }

        public static byte[] GenSppa1(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);

            // Compute SPPA1
            HMACSHA1 hmac = new HMACSHA1(key);
            CryptoStream cs = new CryptoStream(Stream.Null, hmac, CryptoStreamMode.Write);
            cs.Write(hashablename, 0, hashablename.Length);
            cs.Close();

            SHA1 sha = new SHA1Managed();
            byte[] shahmac = sha.ComputeHash(hmac.Hash);
            hmac.Clear();
            sha.Clear();
            return shahmac;
        }

        public static byte[] GenPpa2(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);
            byte[] doublename = new byte[32];
            hashablename.CopyTo(doublename, 0);
            hashablename.CopyTo(doublename, 16);

            HMACSHA1 hmac = new HMACSHA1(key);
            byte[] longppa2 = hmac.ComputeHash(doublename);
            hmac.Clear();

            byte[] ppa2 = new byte[8];
            for (int i = 0; i < 8; i++)
                ppa2[i] = longppa2[i];

            return ppa2;
        }

        private static byte[] TruncateBytes(byte[] b, int length)
        {
            byte[] t = new byte[length];
            for (int i = 0; i < t.Length; i++)
            {
                t[i] = b[i];
            }
            return t;
        }

        public static void GenerateKey(byte[] kek, byte[] rawkey, out byte[] iv, out byte[] enckey)
        {
            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;
            //iv = unhex("00000000000000000000000000000000");

            enckey = new byte[16];
            MemoryStream keystream = new MemoryStream(enckey);
            CryptoStream cs = new CryptoStream(keystream, aes.CreateEncryptor(kek, iv), CryptoStreamMode.Write);
            cs.Write(rawkey, 0, 16);
            cs.Close();
        }

        private static byte[] unhex(string s)
        {
            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }
            return hex;
        }

        private static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\FclFuzzer\FclAnalyzer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

using ServerTestFramework.Utilities;

// Using FCL libraries
using MS.Swi.Mitm;
using MS.Swi.Mitm.Services;
using MS.Swi.Data;
using MS.Swi.Data.Generic;
using MS.Swi.FuzzerCommonLibrary.Manipulations;
using MS.Swi.FuzzerCommonLibrary.Analysis;

namespace ServerTestFramework.Utilities.FclFuzzer.Analyzer
{
    /// <summary>
    /// This is only an example analyzer.
    /// You can add your own analyzer if needed
    /// </summary>
    public class EmailAnalyzer : IDataAnalyzer
    {
        private static Regex _emailMatchExpression = new Regex(@"\w+@\w+\.\w+");

        #region IDataAnalyzer Members

        bool IDataAnalyzer.Analyze(Random prnGenerator, string dataContext, DataMap dataMap)
        {
            bool foundEmail = false;
            List<IConstToken> toBeRefined = new List<IConstToken>();
            foreach (IConstToken token in dataMap.Tokens)
            {
                if (token.Definition.CanBeTreatedAs("String"))
                {
                    string source = token.Contents as string;
                    if (_emailMatchExpression.Match(source).Success)
                    {
                        dataMap.Refine(token, "Email");
                        foundEmail = true;
                    }
                }
            }
            return foundEmail;
        }

        DataMap IDataAnalyzer.Analyze(Random prnGenerator, string dataContext, IConstDataTransformations transformations, IConstElementDefinitions definitions, ConstList<IConstDataBuffer, DataBuffer> buffers)
        {
            return new DataMap(transformations, definitions, buffers);
        }

        bool IDataAnalyzer.CanBeAdditionalAnalyzer()
        {
            return true;
        }

        void IDataAnalyzer.Configure(params string[] options)
        {
            if (options.Length != 0)
            {
                throw new ArgumentException("Email does not have any valid configuration options");
            }
        }

        bool IDataAnalyzer.IsValidContext(string dataContext)
        {
            return true;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\dbposter\DBTable.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.ComponentModel;
using System.Collections;

namespace ServerTestFramework.Utilities.DBPoster
{
    public enum SQLDataType {SDT_TINYINT, SDT_SMALLINT, SDT_INT, SDT_BIGINT, SDT_SMALLDATETIME, SDT_DATETIME, SDT_NVARCHAR, SDT_VARCHAR, SDT_BINARY, SDT_VARBINARY, SDT_REAL, SDT_FLOAT};

    /// <summary>
    /// Summary description for DBTable.
    /// </summary>
    public class DBTable
    {
        class column {public int mark; public string name; public SQLDataType type; public int size;};
        
        private string tablename = null;
        private bool partitioned = false;
        private column[] columns;

        private int atoi(string s)
        {
            return (int)new Int32Converter().ConvertFromString(s);
        }

        public string getTableName() {return tablename;}
        public bool getPartitioned() {return partitioned;}
        public int getColumnMark(int i) {return columns[i].mark;}
        public string getColumnName(int i) {return columns[i].name;}
        public SQLDataType getColumnType(int i) {return columns[i].type;}
        public int getColumnSize(int i) {return columns[i].size;}

        public DBTable(string tablename, bool partitioned, string[] entries)
        {
            this.tablename = tablename;
            this.partitioned = partitioned;

            ArrayList al = new ArrayList();

            for (int i = 0; i < entries.Length; i++)
            {
                char[] delim = {'\t'};
                string[] entry = entries[i].Split(delim);
                
                column c = new column();
                c.mark = atoi(entry[0]);
                c.name = entry[1];
                c.size = atoi(entry[3]);
                switch(entry[2])
                {
                    case "tinyint": c.type = SQLDataType.SDT_TINYINT; break;
                    case "bit": c.type = SQLDataType.SDT_TINYINT; break;
                    case "smallint": c.type = SQLDataType.SDT_SMALLINT; break;
                    case "int": c.type = SQLDataType.SDT_INT; break;
                    case "bigint": c.type = SQLDataType.SDT_BIGINT; break;
                    case "smalldatetime": c.type = SQLDataType.SDT_SMALLDATETIME; break;
                    case "datetime": c.type = SQLDataType.SDT_DATETIME; break;
                    case "nvarchar": c.type = SQLDataType.SDT_NVARCHAR; break;
                    case "varchar": c.type = SQLDataType.SDT_VARCHAR; break;
                    case "binary": c.type = SQLDataType.SDT_BINARY; break;
                    case "varbinary": c.type = SQLDataType.SDT_VARBINARY; break;
                    case "float": c.type = SQLDataType.SDT_FLOAT; break;
                    case "real": c.type = SQLDataType.SDT_REAL; break;
                    default: Debug.Assert(false); break;
                }

                al.Add(c);
            }

            columns = new column[al.Count];
            object[] o = al.ToArray();
            for (int i = 0; i < o.Length; i++)
            {
                columns[i] = (column)o[i];
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\FclFuzzer\FclManipulation.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using MS.Swi.Data;
using MS.Swi.FuzzerCommonLibrary.Manipulations;

namespace ServerTestFramework.Utilities.FclFuzzer.Manipulations
{
    /// <summary>
    /// This is only an example.
    /// You can add your own manipulation class if needed
    /// </summary>
    [FuzzerManipulation("Email", Characteristics =
                                        ManipulationCharacteristics.Dumb |
                                        ManipulationCharacteristics.Mutation)]
    public class EmailManipulation : DataManipulation
    {
        public override ManipulationResult Manipulate(MS.Swi.Data.IConstDataContents targetContents, ref object targetObject, Random prnGenerator, ref object manipulationState, string[] manipulationParameters)
        {
            Char[] emailAddress = targetObject as Char[];

            // For example, randomly fuzz the email address
            int charsToMutate = prnGenerator.Next(100);
            for (int i = 0; i < charsToMutate; i++)
            {
                emailAddress[prnGenerator.Next(0, emailAddress.Length - 1)] = (Char) prnGenerator.Next((int)Char.MinValue, (int)Char.MaxValue);
            }

            return ManipulationResult.ContentsChanged;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Utilities\FclFuzzer\FclFuzzer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserSettings;

using ServerTestFramework.LiveService.UserAccount;

// Using FCL libraries
using MS.Swi.Mitm;
using MS.Swi.Mitm.Services;
using MS.Swi.Data;
using MS.Swi.Data.Generic;
using MS.Swi.FuzzerCommonLibrary.Manipulations;
using MS.Swi.FuzzerCommonLibrary.Analysis;


using ServerTestFramework.Utilities.FclFuzzer.Analyzer;
using ServerTestFramework.Utilities.FclFuzzer.Manipulations;

[assembly: MS.Swi.InstallationManagement]

namespace ServerTestFramework.Utilities.FclFuzzer
{
    /// <summary>
    /// Helper class that providing fuzz methods with FCL
    /// </summary>
    public class FclFuzzer
    {
        #region Protected/Private Fields

        /// <summary>
        /// Common lock object
        /// </summary>
        private static object _lock = new object();

        /// <summary>
        /// LocalServer object
        /// </summary>
        protected static LocalServer fclServer = new LocalServer();

        /// <summary>
        /// FCL Session ID
        /// </summary>
        protected static uint sessionId;

        #endregion

        /// <summary>
        /// Private constructor
        /// </summary>
        private FclFuzzer()
        {
        }

        #region Initialization methods

        public static void Initialize()
        {
            DataAnalyzerDefinitionSet analyzerDefinitions = new DataAnalyzerDefinitionSet();
            // We don't append any customized analyzers here, until it's really needed.
            analyzerDefinitions.AppendAnalyzers(true, new RemoteClassDefinition("MS.Swi.FuzzerCommonLibrary.Analysis.FCLExtensibleDataAnalyzer"));
            analyzerDefinitions.AppendAnalyzers(true, new RemoteClassDefinition("MS.Swi.FuzzerCommonLibrary.Analysis.FCLArgumentAnalyzer"));

            // Initialize a GenericSmartFuzzer by default
            RemoteClassDefinition processorDefinition = new RemoteClassDefinition("MS.Swi.Mitm.Processors.GenericSmartFuzzer",
                                                                                  "DefinitionFiles", "SWIGeneralDefinitions.xml,FclDefinitions.xml",
                                                                                  "TransformationFiles", "SWIGeneralTransformations.xml",
                                                                                  "Analyzers", analyzerDefinitions.ToString(),
                                                                                  "Odds", "1000000"
                                                                                  );
             
            Initialize(processorDefinition);
        }

        public static void Initialize(RemoteClassDefinition processorDefinition)
        {
            lock (_lock)
            {
                //
                // Session should be created only once per process.
                // And can be shared by multiple threads
                //
                if (fclServer.GetSession(sessionId) != null)
                {
                    // Session already exists, no need to initialize
                    return;
                }

                MS.Swi.Utilities.AddFclPaths();
                MS.Swi.InstallationManagement.LoadAssembliesFromFclDirectories();

                ErrorCode errorCode;
                bool sessionCreated = fclServer.StartSession(processorDefinition, null, out sessionId, out errorCode);
                if (!sessionCreated)
                {
                    Global.RO.Fatal("Unable to create FCL Session - {0}", errorCode);
                    return;
                }

                bool pluginLoaded = fclServer.LoadPlugIn("SWITRACK", new RemoteClassDefinition("MS.Swi.Mitm.PlugIns.SwiTrackPlugIn"), out errorCode);

                if (!pluginLoaded)
                {
                    Global.RO.Warn("Unable to load the SwiTrack PlugIn - {0}", errorCode);
                    return;
                }
            }
        }

        #endregion

        #region Fuzzing methods

        /// <summary>
        /// Fuzz a string
        /// </summary>
        /// <param name="identifier">The symbolic identifier for the string</param>
        /// <param name="data">The string to be fuzzed</param>
        public static void Fuzz(string identifier, ref string data)
        {
            // Convert parameters to FCL DataBuffer type
            byte[] stringData = System.Text.Encoding.Unicode.GetBytes(data);
            DataBuffer stringBuffer = new DataBuffer(stringData, (uint)stringData.Length, (uint)stringData.Length * 10);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(
                                            sessionId,
                                            "String Fuzzing Helper Function",
                                            String.Format("ARGUMENTS:String,UnicodeStringTransformation//{0}", identifier),
                                            stringBuffer,
                                            out errorCode);

            // Report any error as warning, and otherwise, return the fuzzed string if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing string: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = new String(System.Text.Encoding.Unicode.GetChars(stringBuffer.Contents.ToArray()));
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed string: {0}", ex);
                }
            }
        }



        /// <summary>
        /// Fuzz a raw byte array
        /// </summary>
        /// <param name="identifier">The symbolic identifier for the byte array</param>
        /// <param name="data">The byte array to be fuzzed</param>
        public static void Fuzz(string identifier, ref byte[] data)
        {
            // Convert the parmater into an FCL DataBuffer
            DataBuffer dataBuffer = new DataBuffer(data, (uint)data.Length, (uint)data.Length * 10);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer Byte Array Helper Function",
                                            String.Format("ARGUMENTS:ByteArray//{0}", identifier),
                                            dataBuffer,
                                            out errorCode);

            // report any error as warning, and otherwise, return the fuzzed value
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing byte array: {0}", errorCode);
            }
            else
            {
                data = dataBuffer.Contents.ToArray();
            }
        }

        /// <summary>
        /// Fuzz a raw byte
        /// </summary>
        /// <param name="identifier">The symbolic identifier for the byte</param>
        /// <param name="data">The byte to be fuzzed</param>
        public static void Fuzz(string identifier, ref byte data)
        {

            byte[] tempArray = { data };
            // Convert the parmater into an FCL DataBuffer
            DataBuffer dataBuffer = new DataBuffer(tempArray, (uint)tempArray.Length, (uint)tempArray.Length * 10);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer Byte Array Helper Function",
                                            String.Format("ARGUMENTS:ByteArray//{0}", identifier),
                                            dataBuffer,
                                            out errorCode);

            // report any error as warning, and otherwise, return the fuzzed value
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing byte array: {0}", errorCode);
            }
            else
            {
                tempArray = dataBuffer.Contents.ToArray();
                data = tempArray[0];
            }
        }

        public static void FuzzEmail(string identifier, ref string data)
        {
            // Convert parameters to FCL DataBuffer type
            byte[] stringData = System.Text.Encoding.Unicode.GetBytes(data);
            DataBuffer stringBuffer = new DataBuffer(stringData, (uint)stringData.Length, (uint)stringData.Length * 10);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(
                                            sessionId,
                                            "String Fuzzing Helper Function",
                                            String.Format("ARGUMENTS:Email//{0}", identifier),
                                            stringBuffer,
                                            out errorCode);

            // Report any error as warning, and otherwise, return the fuzzed string if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing string: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = new String(System.Text.Encoding.Unicode.GetChars(stringBuffer.Contents.ToArray()));
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed string: {0}", ex);
                }
            }
        }
        #region Fuzz different types
        #region Fuzz byte type
        /// <summary>
        /// Fuzz an char using the FCL
        ///</summary>
        public static void Fuzz(string restrictions, string identifier, ref byte data)
        {
            // Convert the parameter to FCL DataBuffer
            byte[] charData = BitConverter.GetBytes(data);
            DataBuffer charBuffer = new DataBuffer(charData, (uint)charData.Length);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer char Helper Function",
                                            String.Format("ARGUMENTS:Character,AnsiCharacterTransformation/{0}/{1}", restrictions, identifier),
                                            charBuffer,
                                            out errorCode);

            // Report any error as warning, and otherwise, return the fuzzed integer if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing unsigned Short: {0}", errorCode);
            }
            else
            {
                try
                {
                    char tempchar;
                    tempchar = BitConverter.ToChar(charBuffer.Contents.ToArray(), 0);
                    byte[] temp_byte = BitConverter.GetBytes(data);
                    data = temp_byte[0];
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed unsigned short: {0}", ex);
                }
            }
        }      
        #endregion 
        #region Short Fuzz
        /// <summary>
        /// Fuzz an short using the FCL
        ///</summary>
        public static void Fuzz(string restrictions, string identifier, ref Int16 data)
        {
            byte[] integerData = BitConverter.GetBytes(data);
            DataBuffer integerBuffer = new DataBuffer(integerData, (uint)integerData.Length);

            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer Short Helper Function",
                                            String.Format("ARGUMENTS:Integer,IntegerLeInt16Transformation/{0}/{1}", restrictions, identifier),
                                            integerBuffer,
                                            out errorCode);
            if (!resultsFuzzed)
            {
                Console.WriteLine("Failure fuzzing short: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToInt16(integerBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Exception detected in parsing the fuzzed Short: {0}", ex);
                }
            }
        }
        /// <summary>
        /// Fuzz an unsigned short using the FCL
        ///</summary>
        public static void Fuzz(string restrictions, string identifier, ref UInt16 data)
        {
            // Convert the parameter to FCL DataBuffer
            byte[] integerData = BitConverter.GetBytes(data);
            DataBuffer integerBuffer = new DataBuffer(integerData, (uint)integerData.Length);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer UShort Helper Function",
                                            String.Format("ARGUMENTS:UnsignedInteger,UnsignedIntegerLeUInt16Transformation/{0}/{1}", restrictions, identifier),
                                            integerBuffer,
                                            out errorCode);

            // Report any error as warning, and otherwise, return the fuzzed integer if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing unsigned Short: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToUInt16(integerBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed unsigned short: {0}", ex);
                }
            }
        }
        #endregion
        #region Long Fuzz
        /// <summary>
        /// Fuzz an unsigned long using the FCL
        ///</summary>
        public static void Fuzz(string restrictions,string identifier, ref UInt64 data )
        {
            byte[] UlongData = BitConverter.GetBytes(data);
            DataBuffer UlongBuffer = new DataBuffer(UlongData, (uint)UlongData.Length);

            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer ULong Helper Function",
                                            String.Format("ARGUMENTS:UnsignedInteger,UnsignedIntegerLeUInt64Transformation/{0}/{1}", restrictions, identifier),
                                            UlongBuffer,
                                            out errorCode);
            if (!resultsFuzzed)
            {
                Console.WriteLine("Failure fuzzing Unsigned Long: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToUInt64(UlongBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Exception detected in parsing the fuzzed Ulong: {0}", ex);
                }
            }
        }
        /// <summary>
        /// Fuzz an  long using the FCL
        ///</summary>
        public static void Fuzz(string restrictions,string identifier, ref Int64 data)
        {
            byte[] longData = BitConverter.GetBytes(data);
            DataBuffer LongBuffer = new DataBuffer(longData, (uint)longData.Length);

            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer long Helper Function",
                                            String.Format("ARGUMENTS:Integer,IntegerLeInt64Transformation/{0}/{1}", restrictions, identifier),
                                            LongBuffer,
                                            out errorCode);
            if (!resultsFuzzed)
            {
                Console.WriteLine("Failure fuzzing integer: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToInt64(LongBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Exception detected in parsing the fuzzed Long: {0}", ex);
                }
            }
        }

        /// <summary>
        /// Fuzz an array of unsigned Long integer
        /// </summary>
        /// <param name="restrictions">The restrictions string for the integer (see the Context Strings documentation for details)</param>
        /// <param name="identifier">The symbolic identifier for the integer array</param>
        /// <param name="data">The integer array to be fuzzed</param>
        public static void FuzzArray(string restrictions, string identifier, ref UInt64[] data)
        {
            for (int i = 0; i < data.Length; i++)
            {
                Fuzz(restrictions, identifier, ref data[i]);
            }
        }

        #endregion
        #region fuzz Integer
        /// <summary>
        /// Fuzz a signed integer using the FCL
        /// </summary>
        /// <param name="restrictions">The restrictions string for the integer (see the Context Strings documentation for details)</param>
        /// <param name="identifier">The symbolic identifier for the integer</param>
        /// <param name="data">The integer to be fuzzed</param>
        public static void Fuzz(string restrictions, string identifier, ref Int32 data)
        {
            // Convert parameters to FCL DataBuffers
            byte[] integerData = BitConverter.GetBytes(data);
            DataBuffer integerBuffer = new DataBuffer(integerData, (uint)integerData.Length);

            // Process the fuzzing request.
            // Inform the Fuzzer that we are using LittleEndian format for integer
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "Integer Fuzzing Helper Function",
                                            String.Format("ARGUMENTS:Integer,IntegerLeInt32Transformation/{0}/{1}", restrictions, identifier),
                                            integerBuffer,
                                            out errorCode);

            // Report any error as warning, and otherwise, return the fuzzed integer if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing integer: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToInt32(integerBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed integer: {0}", ex);
                }
            }
        }

        /// <summary>
        /// Fuzz an unsigned integer using the FCL
        /// </summary>
        /// <param name="restrictions">The restrictions string for the integer (see the Context Strings documentation for details)</param>
        /// <param name="identifier">The symbolic identifier for the integer</param>
        /// <param name="data">The integer to be fuzzed</param>
        public static void Fuzz(string restrictions, string identifier, ref UInt32 data)
        {
            // Convert the parameter to DataBuffer
            byte[] integerData = BitConverter.GetBytes(data);
            DataBuffer integerBuffer = new DataBuffer(integerData, (uint)integerData.Length);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer Integer Helper Function",
                                            String.Format("ARGUMENTS:UnsignedInteger,UnsignedIntegerLeUInt32Transformation/{0}/{1}", restrictions, identifier),
                                            integerBuffer,
                                            out errorCode);

            // Report any errors as warning, and otherwise, return the fuzzed integer if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing unsigned integer: {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToUInt32(integerBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed unsigned integer: {0}", ex);
                }
            }
        }
        #endregion
        
        #region fuzz double  



        /// <summary>
        /// Fuzz an unsigned double using the FCL
        /// </summary>
        /// <param name="restrictions">The restrictions string for the integer (see the Context Strings documentation for details)</param>
        /// <param name="identifier">The symbolic identifier for the integer</param>
        /// <param name="data">The integer to be fuzzed</param>
        public static void Fuzz(string restrictions, string identifier, ref double data)
        {
            // Convert the parameter to DataBuffer
            byte[] DoubleData = BitConverter.GetBytes(data);
            DataBuffer DoubleBuffer = new DataBuffer(DoubleData, (uint)DoubleData.Length);

            // Process the fuzzing request
            ErrorCode errorCode;
            bool resultsFuzzed = fclServer.Process(sessionId,
                                            "UsingGenericSmartFuzzer Double Helper Function",
                                            String.Format("ARGUMENTS:Double,DoubleByteTransformation/{0}/{1}", restrictions, identifier),
                                            DoubleBuffer,
                                            out errorCode);

            // Report any errors as warning, and otherwise, return the fuzzed integer if we can
            if (!resultsFuzzed)
            {
                Global.RO.Warn("Failure fuzzing Double : {0}", errorCode);
            }
            else
            {
                try
                {
                    data = BitConverter.ToDouble(DoubleBuffer.Contents.ToArray(), 0);
                }
                catch (Exception ex)
                {
                    Global.RO.Warn("Exception detected in parsing the fuzzed Double Value: {0}", ex);
                }
            }
        }
        #endregion

        #endregion
        public static void Fuzz(string identifier, ref UserTitle data)
        {

            Fuzz("", "TitleId", ref data.TitleId);
            Fuzz(data.TitleName, ref data.TitleName);
            Fuzz("", "NumCreds", ref data.NumCreds);
            Fuzz("", "NumAchievements", ref data.NumAchievements);
            Fuzz("", "TotalAchievements", ref data.TotalAchievements);
            Fuzz("", "TotalCred", ref data.TotalCred);
            Fuzz("", "Sequence", ref data.Sequence);
            Fuzz("", "HasExtendedData", ref data.HasExtendedData);
            Fuzz("", "TitleType", ref data.TitleType);
            Fuzz("", "PlatformFlags", ref data.PlatformFlags);
            Fuzz("DateTime", ref data.LastPlayed);

        }
        public static void Fuzz(string identifier, ref DateTime data)
        {
            int year = data.Year;
            int month = data.Month;
            int day = data.Day;
            int hour = data.Hour;
            int minute = data.Minute;
            int second = data.Second;
            int mill = data.Millisecond;
            Fuzz("1+10000","year", ref year);
            Fuzz("1+12","month", ref month);
            Fuzz("1+31","day", ref day);
            Fuzz("0+24","hour", ref hour);
            Fuzz("0+60","minute", ref minute);
            Fuzz("0+60","second", ref second);
            Fuzz("0+1000","millisecond", ref mill);
            DateTime dt = new DateTime(year, month, day, hour, minute, second, mill);
            data = dt;
        }

        public static void Fuzz(string identifier, ref XeUser data)
        {


	        Fuzz("PassportPassWord",ref data.PassportPassword);
	        Fuzz("","PassportPuid",ref data.PassportPuid);
	        Fuzz("FirstName", ref data.FirstName);
	        Fuzz("LastName",ref data.LastName);
	        Fuzz("Gamertag",ref data.Gamertag);
	        Fuzz("PassportMemberName", ref data.PassportMemberName);
	        Fuzz("","offerID", ref data.OfferId);
	        Fuzz("Billing Token", ref data.BillingToken);
	        Fuzz("BirthDate", ref data.BirthDate);
	        FuzzEmail("email", ref data.Email);
	        Fuzz("","LanguageID",ref data.LanguageId);
	        Fuzz("","ParentalControlGroup",ref data.ParentalControlGroup);
            Fuzz("AddressInfoData ", ref data.AddressInfo, false);
            Fuzz("PhoneInfoData ", ref data.PhoneInfo, false);
            Fuzz("CreditCardInfoData ", ref data.CreditCardInfo, false);
            Fuzz("DirectDebitInfoData ", ref data.DirectDebitInfo, false);
            
        }

        public static void Fuzz(string identifier, ref AddressInfoData data, bool bCreate )
        {
            AddressInfoData temp_data = new AddressInfoData();
            if (bCreate)
            {
                //initalized the AdrressinforData
                temp_data.Street1 = "9931 Lovely Lane NE";
                temp_data.Street2 = "/.IUnknown";
                temp_data.City = "BERLIN";
                temp_data.PostalCode = "22767";
                temp_data.State = "";
            }
            else
            {
                temp_data = data;
 
            }

            Fuzz("Stree1", ref temp_data.Street1);
            Fuzz("Street2", ref temp_data.Street2);
            Fuzz("City", ref temp_data.City);
            Fuzz("PostalCode", ref temp_data.PostalCode);
            Fuzz("State", ref temp_data.State);
            
            // Assign back
            data = temp_data;
        }

        public static void Fuzz(string identifier, ref PhoneInfoData data, bool bCreate)
        {
            PhoneInfoData temp_data = new PhoneInfoData();
            if (bCreate)
            {
                //initalized the AdrressinforData
                temp_data.PhonePrefix = "+8610";
                temp_data.PhoneNumber = "58965654";
                temp_data.PhoneExtension = "1234";
            }
            else
            {
                temp_data = data;

            }

            Fuzz("PhonePrefix", ref temp_data.PhonePrefix);
            Fuzz("PhoneNumber", ref temp_data.PhoneNumber);
            Fuzz("PhoneExtension", ref temp_data.PhoneExtension);

            // Assign back
            data = temp_data;
        }

        public static void Fuzz(string identifier, ref CreditCardInfoData data, bool bCreate)
        {
            CreditCardInfoData temp_data = new CreditCardInfoData();
            if (bCreate)
            {
                string ccn = ServerTestFramework.Utilities.CreditCardRandomizer.GetRandomAccountNumber("visa");
                temp_data.CardType = 0;
                temp_data.AccountHolderName = "MrDad OfMinor";
                temp_data.AccountNumber = ccn;
                temp_data.CcvNumber = "123";
                temp_data.ExpirationDate = DateTime.UtcNow.AddYears(2); 
            }

            else
            {
                temp_data = data;
            }

            Fuzz("AccountHolderName", ref temp_data.AccountHolderName);
            Fuzz("AccountNumber", ref temp_data.AccountNumber);
            Fuzz("CcvNumber", ref temp_data.CcvNumber);
            Fuzz("ExpirationDate", ref temp_data.ExpirationDate);

            // Assign back
            data = temp_data;
        }

        public static void Fuzz(string identifier, ref DirectDebitInfoData data, bool bCreate)
        {

            DirectDebitInfoData temp_data = new DirectDebitInfoData();
            if (bCreate)
            {
                DirectDebitRandomizer ddr = new DirectDebitRandomizer();

                temp_data.AccountHolderName = "demo";
                temp_data.AccountNumber = ddr.AccountNumber;
                temp_data.BankCode = ddr.BankCode;
                temp_data.BranchCode = ddr.BranchCode;
                temp_data.CheckDigits = ddr.CheckDigits;
            }
            else
            {
                temp_data = data;
            }

            Fuzz("AccountHolderName", ref temp_data.AccountHolderName);
            Fuzz("AccountNumber", ref temp_data.AccountNumber);
            Fuzz("BankCode", ref temp_data.BankCode);
            Fuzz("BranchCode", ref temp_data.BranchCode);
            Fuzz("CheckDigits", ref temp_data.CheckDigits);

            // Assign back
            data = temp_data;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\MyWebTransaction.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Globalization;
using System.Diagnostics;

namespace ServerTestFramework.LiveService.Vortex
{
    public class MyWebTransaction
    {
        /// <summary>
        /// IP or DNS name of server
        /// </summary>
        public IPEndPoint endPoint = null;

        /// <summary>
        /// FD transactions can be UDP or TCP now
        /// </summary>
        public enum Transports
        {
            TCP,
            UDP
        }

        /// <summary>
        /// Use the UDP protocol transport for delivery
        /// </summary>
        public Transports transport = Transports.TCP;

        public static int sReceiveTimeOut = 35000;
        public static int sSendTimeOut = 35000;

        public int ReceiveTimeOut = sReceiveTimeOut;
        public int SendTimeOut = sSendTimeOut;

        // if this flag is set to true then we will not wait for any UDP response.
        public bool IgnoreUDPReceive = false;

        /// <summary>
        /// http status in response
        /// </summary>
        public HttpStatusCode httpStatus
        {
            get { return _httpStatus; }
        }
        private HttpStatusCode _httpStatus = HttpStatusCode.NotFound;

        /// <summary>
        /// Buffer sized to contain raw contents of response
        /// </summary>
        public byte[] ResponseContents
        {
            get { return _respBuff; }
        }
        private byte[] _respBuff = null;

        [ThreadStatic]
        static byte[] responseData;

        /// <summary>
        /// Value returned in XErr header field when http response status is 500.
        /// </summary>
        public uint XErr
        {
            get { return _XErr; }
        }
        private uint _XErr = HResult.E_FAIL;

        public bool AppendSGIPPort = false;


        /// <summary>
        /// HTTP response header for client-side throttling
        /// </summary>
        public uint XDelay
        {
            get { return _XDelay; }
        }
        private uint _XDelay = 0;

        private int GetEndOfHeaderIndex(byte[] bytes)
        {
            // There may or may not be a complete header at this point
            int endOfHeader = -1;
            for (int i = 3; i < bytes.Length; i++)
            {
                if (bytes[i - 3] == '\r' && bytes[i - 2] == '\n' && bytes[i - 1] == '\r' && bytes[i] == '\n')
                {
                    endOfHeader = i;
                    break;
                }
            }
            return (endOfHeader);
        }

        private string GetHeaderString(byte[] bytes)
        {
            string header = null;
            int eohIdx = GetEndOfHeaderIndex(bytes);
            if (0 != eohIdx)
            {
                // We have header
                header = Encoding.ASCII.GetString(bytes, 0, eohIdx + 1);
            }
            return (header);
        }

        public Dictionary<string, string> GetHeader()
        {
            if (responseData == null)
            {
                return null;
            }

            string headerString = GetHeaderString(responseData);
            if (headerString == null)
            {
                return null;
            }
            Dictionary<string, string> headerDict = new Dictionary<string, string>();
            string[] fields = headerString.Split('\n');
            foreach (string field in fields)
            {
                string[] parts = field.Split(new char[] { ':' }, 2);
                if (parts.Length == 2)
                {
                    headerDict.Add(parts[0].Trim(), parts[1].Trim());
                }
            }
            return headerDict;
        }


        private uint HexToInt(byte b)
        {
            if (b >= 'a')
                return (uint)b - 'a' + 10;
            if (b >= 'A')
                return (uint)b - 'A' + 10;
            return (uint)b - '0';
        }

        private void ParseReturn(byte[] data, out HttpStatusCode StatusCode, out uint ixErr, out uint ixDelay, out int contentLen)
        {
            // FAKE!
            StatusCode = HttpStatusCode.OK;
            ixErr = 0;
            ixDelay = 0;
            contentLen = 0;
            return;

#if false
            int iError = 0;
            int i;
            int len = data.Length;
            contentLen = 0;

            /*
             *  This code will dump []data to the console. Every now and then this will come in handy
             * to diagnose things. I recommend we keep this here.
                        ASCIIEncoding AE=new ASCIIEncoding();
                        char []buf=new Char[data.Length];
                        int len2=AE.GetDecoder().GetChars(data,0,data.Length,buf,0);
                        for (i=0; i<len2; i++)
                            Console.Write(buf[i]);
                        Console.WriteLine("\n");
             */

            fixed (byte* pData = data)
            {
                // find HTTP error code
                byte* p = pData + 9;
                iError = (*(p) - '0') * 100;
                iError += (*(p + 1) - '0') * 10;
                iError += (*(p + 2) - '0');

                // find XError code
                ixErr = 0;
                ixDelay = 0;
                for (i = 5; i < len; i += 2)
                {
                    if (p[i] <= 0x0D)
                    {
                        // this is a part of a CRLF. Let's see which
                        if (p[i] == 0x0D)
                            i += 2;
                        else
                            i++;

                        if (p[i] == 0x0D && p[i + 1] == 0x0A)
                            break;

                        if (p[i] == 'X')
                        {
                            if (p[i + 1] != '-' || (p[i + 2] != 'E' && p[i + 2] != 'D'))
                                continue;
                            // this may be X-Err or X-Delay (but don't be fooled by X-Event)
                            if (p[i + 2] == 'E' && p[i + 3] == 'r' && p[i + 4] == 'r')
                            {
                                i += 7;
                                int j = i;
                                ixErr = 0;
                                int digits = 0;
                                while (p[j] >= '0' && digits < 8)
                                {
                                    ixErr <<= 4;
                                    ixErr += HexToInt(p[j]);
                                    j++;
                                    digits++;
                                }
                            }
                            else    //'D'
                            {
                                i += 9;
                                int j = i;
                                ixDelay = 0;
                                while (p[j] >= '0' && p[j] <= '9')
                                {
                                    ixDelay *= 10;
                                    ixDelay += (uint)(p[j] - '0');
                                    j++;
                                }
                            }
                        }
                        else if ((p[i] == 'C') && (p[i + 1] == 'o') && (p[i + 2] == 'n') && (p[i + 3] == 't'))
                        {
                            if ((p[i + 7] == '-') && (p[i + 8] == 'L'))
                            {
                                int j = i + 16; // j is the beginning of contentLen
                                contentLen = 0;
                                while (p[j] > 0x0D)
                                {
                                    contentLen = contentLen * 10 + (p[j] - '0');
                                    j++;
                                }
                            }
                        }
                    }
                }
            }
            StatusCode = HttpStatusCode.InternalServerError;

            switch (iError)
            {
                case 200:
                    StatusCode = HttpStatusCode.OK;
                    break;
                case 100:
                    StatusCode = HttpStatusCode.Continue;
                    break;
                case 400:
                    StatusCode = HttpStatusCode.BadRequest;
                    break;
                case 401:
                    StatusCode = HttpStatusCode.Unauthorized;
                    break;
                case 403:
                    StatusCode = HttpStatusCode.Forbidden;
                    break;
                case 404:
                    StatusCode = HttpStatusCode.NotFound;
                    break;
                case 405:
                    StatusCode = HttpStatusCode.MethodNotAllowed;
                    break;
                case 500:
                    StatusCode = HttpStatusCode.InternalServerError;
                    break;
                case 503:
                    StatusCode = HttpStatusCode.ServiceUnavailable;
                    break;
                default:
                    throw new Exception("Unknown http status code " + iError);
            }
#endif

        }

        // ----------------------------------------
        // Method: Execute
        //  Does http POST to url built from server and service and loads results into
        //  ResponseContents and XErr when appropriate.
        //  Params:
        //      reqStream - XRL data packed and ready for request contents.
        //  Returns
        //      true -  http rstatus is 200 or 500, the only possible values returned by a FD code.
        //                  XErr and ResponseContents are worth checking out.
        //      false - http status is something else.  XErr isn't set, but ResponseContents might not be empty.
        //
        //  This version also accepts a port number. The request will be sent out from that port
        //
        static int counter = 0;

        public class MyTcpClient : System.Net.Sockets.TcpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            public new Socket Client
            {
                get
                {
                    return base.Client;
                }
            }
        }

        public class MyUdpClient : System.Net.Sockets.UdpClient
        {
            public ushort Bind()
            {
                Client.Bind(new IPEndPoint(IPAddress.Any, 0));
                return (ushort)((IPEndPoint)Client.LocalEndPoint).Port;
            }
            public new Socket Client
            {
                get
                {
                    return base.Client;
                }
            }
        }

        public bool ExecuteTCP(byte[] httpHeader, byte[] content, bool noContinue, bool fReadResponse)
        {
            MyTcpClient localClient = null;
            System.Net.Sockets.NetworkStream outStream = null;

            try
            {
                try
                {
                    int retries = 0;
                    while (true)
                    {
                        localClient = new MyTcpClient();
                        localClient.ReceiveTimeout = ReceiveTimeOut;
                        localClient.SendTimeout = SendTimeOut;

                        try
                        {
                            localClient.Connect(endPoint);
                            break;
                        }
                        catch (System.Net.Sockets.SocketException)
                        {
                            retries++;
                            if (retries == 5)
                            {
                                throw;
                            }
                        }
                    }
                }
                catch (Exception)
                {
                    Interlocked.Increment(ref counter);
                    throw;
                }

                outStream = localClient.GetStream();

                if (responseData == null)
                {
                    responseData = new byte[localClient.ReceiveBufferSize];
                }
                int contentLen;
                if (noContinue)
                {
                    //local memory stream should be disposed via using
                    using (MemoryStream fullReq = new MemoryStream())
                    {
                        fullReq.Write(httpHeader, 0, httpHeader.Length);
                        //only write out the body (POST) if one was provided
                        if (content != null && content.Length > 0)
                            fullReq.Write(content, 0, content.Length);

                        byte[] data = fullReq.GetBuffer();
                        if (data.Length > 0)    //only write to the stream if we have any data
                            outStream.Write(data, 0, (int)fullReq.Length);
                    }
                }
                else
                {
                    outStream.Write(httpHeader, 0, httpHeader.Length);

                    // This is where we get our Continue (100)
                    outStream.Read(responseData, 0, responseData.Length);
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus != HttpStatusCode.Continue)
                    {
                        // We didn't get a continue... just exit
                        _XErr = 1;
                        return false;
                    }

                    // This is where we write out request
                    // only write out the body (POST) if one was provided
                    if (content != null && content.Length > 0)
                    {
                        outStream.Write(content, 0, (int)content.Length);
                    }
                }

                if (!fReadResponse)
                {
                    return true;
                }

                int bytesRead = outStream.Read(responseData, 0, responseData.Length);

                ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);

                //The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
                // if the request type is head do not read data.
                if (_httpStatus == HttpStatusCode.OK && !IsHeadRequest(httpHeader))
                {
                    int dataIndex = 0;
                    for (int i = 0; i < bytesRead - 3; i++)
                    {
                        if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                            responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                        {
                            dataIndex = i + 4;
                            break;
                        }
                    }

                    _respBuff = new byte[contentLen];
                    if (contentLen + dataIndex > bytesRead)
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, bytesRead - dataIndex);

                        int index = bytesRead - dataIndex;
                        while (index < contentLen)
                        {
                            if (contentLen - index > 1024)
                                index += outStream.Read(_respBuff, index, 1024);
                            else
                                index += outStream.Read(_respBuff, index, contentLen - index);
                        }
                    }
                    else
                    {
                        Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                    }
                }

                // Send and receive should be shutdown independently of each other
                // Do a half-close on the underlying socket
                Socket s = localClient.Client;
                s.Shutdown(SocketShutdown.Send);

                // Give the other side time to close its part (our "receive" half) of the connection
                while (s.Receive(responseData) > 0)
                {
                }

                s.Close();
            }
            finally
            {
                if (outStream != null)
                    outStream.Close();
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }
        /*
         * Panaroma is making head request and XRlScan test uses this.
         * The HEAD method is identical to GET except that the server DOES NOT return a message-body in the response.
         * this code comparesthe first 4 Chars to "HEAD"
         */
        public bool IsHeadRequest(byte[] httpHeader)
        {
            if (httpHeader[0] == 72 && httpHeader[1] == 69 && httpHeader[2] == 65 && httpHeader[3] == 68)
                return true;

            return false;
        }

        public bool ExecuteUDP(byte[] httpHeader, MemoryStream reqStream)
        {
            MyUdpClient localClient = new MyUdpClient();
            localClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, ReceiveTimeOut);
            localClient.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, SendTimeOut);

            try
            {
                try
                {
                    localClient.Connect(endPoint);
                }
                catch (Exception e)
                {
                    Interlocked.Increment(ref counter);
                    throw e;
                }

                int contentLen;

                MemoryStream fullReq = new MemoryStream((int)(httpHeader.Length + reqStream.Length));

                fullReq.Write(httpHeader, 0, httpHeader.Length);
                fullReq.Write(reqStream.GetBuffer(), 0, (int)reqStream.Length);

                byte[] data = fullReq.GetBuffer();

                localClient.Send(data, data.Length);

                if (!IgnoreUDPReceive)
                {
                    byte[] responseData = localClient.Receive(ref endPoint);
                    int bytesRead = responseData.Length;
                    ParseReturn(responseData, out _httpStatus, out _XErr, out _XDelay, out contentLen);
                    if (_httpStatus == HttpStatusCode.OK)
                    {
                        int dataIndex = 0;
                        for (int i = 0; i < bytesRead - 3; i++)
                        {
                            if (responseData[i] == 0x0D && responseData[i + 1] == 0x0A &&
                                responseData[i + 2] == 0x0D && responseData[i + 3] == 0x0A)
                            {
                                dataIndex = i + 4;
                                break;
                            }
                        }

                        _respBuff = new byte[contentLen];
                        if (contentLen + dataIndex > bytesRead)
                        {
                            throw new Exception("FDTransaction: corrupt UDP response");
                        }
                        else
                        {
                            Array.Copy(responseData, dataIndex, _respBuff, 0, contentLen);
                        }
                    }
                }
                else
                {
                    _respBuff = new byte[0];
                    _httpStatus = HttpStatusCode.OK;
                    this._XErr = HResult.S_OK;
                }
            }
            finally
            {
                localClient.Close();
            }

            if (_httpStatus != HttpStatusCode.OK)
            {
                // We didn't get a continue... just ext
                if (_httpStatus == HttpStatusCode.Continue)
                {
                    //  This should never happen - we don't support multiple Continues
                    _XErr = 2;
                    return false;
                }
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\VortexWeb.cs ===
using System;
using System.Collections.Specialized;
using System.Text;
using System.Web;

namespace ServerTestFramework.LiveService.Vortex
{
    public class VortexWeb : VortexHTTPString
    {
        NameValueCollection _headers = new NameValueCollection();

        /// <summary>
        /// The cookie string that will be added to the request headers
        /// </summary>
        public string Cookie
        {
            set;
            get;
        }

        /// <summary>
        /// This is the expected string the system will check for validation
        /// </summary>
        public string ExpectedString
        {
            get;
            set;
        }

        /// <summary>
        /// Collection of Headers to add to request
        /// </summary>
        public NameValueCollection Headers
        {
            get
            {
                return _headers;
            }
            set
            {
                _headers = value;
            }
        }

        public VortexWeb(string url)
            : base(url)
        {
        }

        public bool  CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {   
            return serverPayload == generatedPayload;
        }

        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }

        /// <summary>
        /// Generates the query string from the parameters added with AddUpdateParameter or returns the
        /// custom querystring if set.
        /// </summary>
        /// <returns>QueryString that was built</returns>
        public override string BuildQueryString()
        {
            if (!String.IsNullOrEmpty(CustomQS))
                return CustomQS;
            
            StringBuilder queryString = new StringBuilder("?");

            foreach (string index in parameters.Keys)
            {
                if (!filteredParams.ContainsKey(index) || filteredParams[index] == false)
                    queryString.AppendFormat("&{0}={1}", index, HttpUtility.UrlEncode(parameters[index]));
            }

            if (queryString.Length != 1)
                queryString.Remove(1, 1); //Remove the first & at index 1        

            return queryString.ToString();
        }
        
        /// <summary>
        /// For now, we aren't going to parse the whole thing.  Perhaps never.
        /// This is just going to return the ExpectedString Property
        /// </summary>
        /// <returns></returns>
        public override string GenerateExpectedResult()
        {
            return ExpectedString;
        }

        /// <summary>
        /// Override to send a request with the cookie header
        /// </summary>
        protected override void SendRequestInternal()
        {
            String reqUrl = GetRequestURL();
            reqTime = DateTime.Now;

            string content = BuildContent();

            _headers.Add("Cookie", Cookie);

            VortexUtil.PostRequest(reqUrl, method, VortexUtil.StringToBytes(content), fKeepAlive, _headers);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\VortexUtil.cs ===
using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using System.Net;
using System.IO;
using System.Web;
using System.Net.Cache;
using System.Net.Sockets;
using System.Xml.Serialization;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using xonline.common.config;
using xonline.common.core.etx;
using xonline.common.protocol;
using xonline.common.utilities2;
using xonline.common.service;
using xonline.common.core.etx.extensions;
using System.Security.Cryptography;

namespace ServerTestFramework.LiveService.Vortex
{
    /// <summary>
    /// Generic helper methods.
    /// </summary>
    public static class VortexUtil
    {
        private static Report ro = new Report("VortexUtil");
        public static readonly string vortex_Component = "vortexfd";
        public static readonly string vortex_Interface = "vortexfd";
        public static readonly string vortex_VirtualInterface = "vortexfd";
        public static readonly ulong nonceMagicNumber = 7401667;
        

        static VortexUtil()
        {
            System.Net.ServicePointManager.Expect100Continue = false;
        }

        public static byte[] StringToBytes(string content)
        {
            if (content == null)
                return null;

            MemoryStream ms = new MemoryStream();
            StreamWriter sw = new StreamWriter(ms, System.Text.UTF8Encoding.UTF8);
            sw.Write(content);
            sw.Close();
            return ms.ToArray();
        }

        public static UInt32 ConvertIPToNetwork(System.Net.IPAddress ip)
        {
            byte[] bytes = ip.GetAddressBytes();

            return (UInt32)((bytes[0] << 24) | (bytes[1] << 16) |
                (bytes[2] << 8) | bytes[3]);
        }

        public static byte[] EndianFlipGuid(byte[] bytes)
        {
            byte[] copy = new byte[bytes.Length];
            Array.Copy(bytes, copy, bytes.Length);
            Array.Reverse(copy, 0, 4);
            Array.Reverse(copy, 4, 2);
            Array.Reverse(copy, 6, 2);

            return copy;
        }

        public static Guid EndianFlipGuid(Guid guid)
        {
            return new Guid(EndianFlipGuid(guid.ToByteArray()));
        }

        public class RandomUnicodeString
        {
            private Random _r;

            public RandomUnicodeString()
            {
                _r = new Random();
            }

            public string GetString(int length)
            {
                byte[] str = new byte[length * 2];

                for (int i = 0; i < length * 2; i += 2)
                {
                    int chr = _r.Next(0xD7FF);
                    str[i + 1] = (byte)((chr & 0xFF00) >> 8);
                    str[i] = (byte)(chr & 0xFF);
                }

                return Encoding.Unicode.GetString(str);
            }
        }

        private static Random rand = new Random();

        public static byte[] GenerateRandomBlob(int length)
        {
            List<byte> randomBlob = new List<byte>();
            for (int k = 0; k < length; k++)
            {
                randomBlob.Add((byte)rand.Next(255));
            }
            return randomBlob.ToArray();
        }

        public static byte[] GenerateRepeatedBlob(int length, byte repeatByte)
        {
            List<byte> randomBlob = new List<byte>();
            for (int k = 0; k < length; k++)
            {
                randomBlob.Add(repeatByte);
            }
            return randomBlob.ToArray();
        }        

        /// <summary>
        /// Posts an HTTP request to a given endpoint.
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="content"></param>
        /// <param name="fKeepAlive"></param>
        /// <returns></returns>
        public static string PostRequest(string url, string method, byte[] content, bool fKeepAlive, NameValueCollection headers)
        {
            try
            {
                ro.Debug("HTTP Request: {0}", url);

                HttpWebRequest webreq = (HttpWebRequest)WebRequest.Create(url);
                webreq.CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);
                webreq.UserAgent = "VortexDVT/0.1";

                webreq.KeepAlive = fKeepAlive;
                webreq.Method = method;
                webreq.Timeout = 20000;
                if (content == null)
                    webreq.ContentType = "text/xml"; // @@@?                
                else
                    webreq.ContentType = "xon/2"; // 2 is stringserver


                webreq.ContentLength = content == null ? 0 : content.Length;

                if (headers != null)
                    webreq.Headers.Add(headers);

                // @@@ Floken header?
                webreq.Headers.Add("X-Floken", "0");

                //IFLC header                
                if (!String.IsNullOrEmpty(webreq.Address.Query))
                {
                    byte[] queryStringBytes = System.Text.Encoding.UTF8.GetBytes(webreq.Address.Query.Substring(1));
                    MemoryStream streamQuery = new MemoryStream(queryStringBytes);
                    string sig = LogCollectorCrypto.CreateSignature(streamQuery);
                    webreq.Headers.Add("X-IFLCDIGEST", sig);
                }


                // Set all headers prior to this!
                if (content != null)
                {
                    // This initiates the send, btw                    
                    webreq.GetRequestStream().Write(content, 0, content.Length);
                }

                // Finish and get response
                HttpWebResponse webresp = (HttpWebResponse)webreq.GetResponse();

                // Read body
                StreamReader sr = new StreamReader(webresp.GetResponseStream());
                string contentResponse = sr.ReadToEnd();

                webresp.Close();
                sr.Close();

                return contentResponse;
            }
            catch (WebException we)
            {
                // We throw, so no need to print this
                // ro.Error("Got WebException:\n{0}", we.ToString());
                ro.Warn("WebException: {0}, Status {1}", we.Message, we.Status);

                if (we.Response != null)
                {
                    StreamReader sr = null;
                    try
                    {
                        ro.Debug("WebException Response headers:\n{0}", we.Response.Headers);

                        //                     sr = new StreamReader(we.Response.GetResponseStream());
                        //                     String s = sr.ReadToEnd();

                    }
                    finally
                    {
                        we.Response.Close();
                        if (sr != null)
                            sr.Close();
                    }
                }

                throw;
            }
        }

        /// <summary>
        /// Sends no special headers.
        /// </summary>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="content"></param>
        /// <param name="fKeepAlive"></param>
        /// <returns></returns>
        public static string PostRequest(string url, string method, byte[] content, bool fKeepAlive)
        {
            return PostRequest(url, method, content, fKeepAlive, null);
        }

        /// <summary>
        /// Generates an HTTP header used by the "PostRequestFast" method which skips HTTPWebRequest 
        /// and does the TCP dirty work itself.
        /// </summary>
        /// <param name="endPoint"></param>
        /// <param name="httpMethod"></param>
        /// <param name="httpPath"></param>
        /// <param name="contentLength"></param>
        /// <returns></returns>
        private static byte[] GenerateHttpHeader(IPEndPoint endPoint, string httpMethod, string httpPath, int contentLength)
        {
            StringBuilder sbURL;

            sbURL = new StringBuilder();
            sbURL.Append(httpMethod + " " + httpPath);
            sbURL.Append(" HTTP/1.0\r\n");
            sbURL.Append("Host: " + endPoint.ToString() + "\r\n");
            sbURL.Append("Content-Type: text/xml\r\n");
            sbURL.Append("User-Agent: Vortex/0\r\n");
            sbURL.Append("Content-Length: " + contentLength + "\r\n\r\n");

            System.Text.ASCIIEncoding AE = new System.Text.ASCIIEncoding();
            return AE.GetBytes(sbURL.ToString());
        }

        /// <summary>
        /// Similar to post request, but skips HTTPWebRequest and does the dirty work itself.
        /// </summary>
        /// <param name="endPoint"></param>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="content"></param>
        /// <param name="fReadResponse"></param>
        public static void PostRequestFast(IPEndPoint endPoint, string url, string method, byte[] content, bool fReadResponse)
        {
            byte[] httpHeader = GenerateHttpHeader(endPoint, method, url, (content == null) ? 0 : content.Length);

            MyWebTransaction xAct = new MyWebTransaction();
            xAct.endPoint = endPoint;

            xAct.ExecuteTCP(httpHeader, content, true, fReadResponse);
        }

        public static IPAddress LocalIPAddress()
        {
            return IpHelper.GetBestInterface(Global.XEnv.GetVirtualInterface("vortexfd").Address);            
        }

        public static EtxManifest CloneManifest(EtxManifest man)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));
            MemoryStream ms = new MemoryStream();
            serializer.Serialize(ms, man);
            ms.Position = 0;
            XmlReader reader = XmlReader.Create(ms);
            return new EtxManifest(reader);
        }
    }

    /// <summary>
    /// Sends packets directly to Vortex via http LogBinary.
    /// </summary>
    public class LogBinaryTransport : IVxTransport
    {
        public LogBinaryTransport(string virtualInterface)
        {
            Init(virtualInterface);
        }

        public void Init(string virtualInterface)
        {
            IPEndPoint viIP = Global.XEnv.GetVirtualInterface(virtualInterface);
            _apiName = "http://" + viIP.ToString() + "/vortex/logbinary.ashx";
        }

        public void Send(byte[] message)
        {
            VortexUtil.PostRequest(_apiName, "POST", message, false);
        }

        public void Send(string message)
        {
            throw new NotSupportedException("LogBinary requires a byte[] for input");
        }

        public void SetAuthdata(Authdata_Base ad)
        {
            // @@@ TODO: fire up FakeSG, put this authdata into the slot
        }

        protected string _apiName;
    }

    /// <summary>
    /// Sends packets directly.
    /// </summary>
    public class DirectUdpTransport : IVxTransport
    {
        public DirectUdpTransport(string virtualInterface)
        {
            Init(virtualInterface);
        }

        public void Init(string virtualInterface)
        {
            _udp = new UdpClient();
            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(virtualInterface);
#pragma warning disable 618 // disable IPAddress warning
            _remoteEP = new IPEndPoint(vii.IPAddress, vii.Port);
#pragma warning restore 618 // enable Obsolete warning
        }

        public void Send(byte[] dgram)
        {
            _udp.Send(dgram, dgram.Length, _remoteEP);
        }

        public void Send(string message)
        {
            byte[] dgram = UTF8Encoding.UTF8.GetBytes(message);
            Send(dgram);
        }

        public void SetAuthdata(Authdata_Base ad)
        {
            // @@@ TODO: fire up FakeSG, put this authdata into the slot
        }

        private UdpClient _udp;
        private IPEndPoint _remoteEP;
    }

    /// <summary>
    /// Sends packets through the SG.
    /// </summary>
    public class SgUdpTransport : IVxTransport
    {
        public SgUdpTransport(string virtualInterface)
        {
            Init(virtualInterface);
        }

        public void Init(string virtualInterface)
        {
            _lastUsed = DateTime.Now;
            IVirtualInterfaceInfo vii = Config.GetVirtualInterface(virtualInterface);
            _internetPort = vii.InternetPort;
        }

        public void Send(byte[] dgram)
        {
            if (_sg == null ||
                _sg.Context == null ||
                _sg.Context.SecKeys == null ||
                (DateTime.Now - _lastUsed) > _idleTimeout)
            {
                Global.RO.Debug("Send(): need to sign in, elapsed time {0}", (DateTime.Now - _lastUsed).ToString());
                SignIn();
            }

            // We're going to use the "new-ish" XSP code. FuncPacketXsp.cs is the primary 
            // user of this stuff. The rest of the STF code does not use this.

            XspBuffer xsp;
            XspSession xspSession = new XspSession(_sg.Context.SecKeys);

            // bit of an uberhack
            _sg.SequenceXmit++;

            // bit of a hack
            xspSession.SyncSequenceNumbers(_sg);

            xsp = xspSession.EncodeUdp(
                666,                    // source port, doesn't really matter
                (uint)_internetPort,    // dest port, talk to Vortex
                dgram,
                (uint)dgram.Length);

            _sg.Context.Udp.SendFast(
                xsp.RawBuffer,
                (int)xsp.RawBufferLength,
                _sg.IpServer);

            _lastUsed = DateTime.Now;

            // we ignore responses, if any
        }

        public void Send(string message)
        {
            byte[] dgram = UTF8Encoding.UTF8.GetBytes(message);
            Send(dgram);
        }

        public void SetAuthdata(Authdata_Base ad)
        {
            _authdata = ad;
            SignIn();
        }

        private void SignIn()
        {
            _sg = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
            _sg.Context.Authdata = _authdata;
            _sg.TimeoutInMs = 1000;
            _sg.FakeSignInXkdc();
            //            _sg.KeyexResult.keyexResp.NonceInit
            try
            {
                // could set custom authdata properties here if we wanted to
                _sg.SignInSG();
            }
            catch (ServerTestFramework.Utilities.TimeoutException)
            {
                // Often times out the first time. ?? Try again once.
                Global.RO.Debug("SignIn(): timed out on first keyex, trying again");

                // @@@ why does calling SignInSG() again not work?
                //_sg.SignInSG();

                _sg = new SgClient(new AuthContext(AuthContext.ClientTypes.Xenon));
                _sg.Context.Authdata = _authdata;
                _sg.TimeoutInMs = 1000;
                _sg.FakeSignInXkdc();
                _sg.SignInSG();
            }

            // Verify we are actually connected and can send & receive encrypted data
            QOS q = new QOS();
            if (!q.SendRecv(_sg))
            {
                throw new ServerTestFramework.Utilities.TimeoutException("QOS exchange timed out");
            }

            Global.RO.Debug("SignIn(): All clear");
            NonceValue = BitConverter.ToUInt64(_sg.KeyexResult.keyexResp.NonceResp, 0);
            _lastUsed = DateTime.Now;
        }

        private SgClient _sg;
        private int _internetPort;
        private DateTime _lastUsed;
        private TimeSpan _idleTimeout = TimeSpan.FromSeconds(60); // SG has a 2 minute timeout. We'll play it safe.
        private Authdata_Base _authdata;
        public ulong NonceValue = 0;
    }

    public interface IVxTransport
    {
        void Init(string virtualInterface);
        void Send(byte[] message);
        void Send(string message);
        void SetAuthdata(Authdata_Base ad);
    }

    #region Vortex Binary protocol helpers

    /// <summary>
    /// Represents one of the defined vortex protocol types.
    /// </summary>
    public enum VortexProtocolType
    {
        Unused = 0,
        DistMon = 1,
        Invalid = 255
    }

    /// <summary>
    /// Represents one of the defined vortex field types.
    /// </summary>
    public enum EtxFieldType
    {
        Terminator = 0,
        VarInt = 1,
        Blob = 2,
        Single = 3,
        Double = 4,
        String = 5,
        SVarInt = 6,
        Special = 7,
        //From now on these are special cases, not real ids
        Guid = 401, //Special case of blob
        DateTime = 402, //Special case of Varint
        AutovalueWrapper = 403 //Special case of Varint

    }

    /// <summary>
    /// A vortex etx message. Does all the hard work of writing and validating.
    /// </summary>
    public class VortexEtxMessage
    {
        public VortexProtocolType ProtocolType { get; set; }
        public VortexEtxEventBatch Batch { get; set; }

        public VortexEtxMessage(VortexEtxEventBatch messages, VortexProtocolType protocolType)
        {
            this.Batch = messages;
            this.ProtocolType = protocolType;
        }

        public void Write(System.IO.Stream stream)
        {
            VortexProtocolWriter writer = new VortexProtocolWriter(stream);
            writer.Write(this);
        }

        public void ReadAndValidateEtxMessages(MemoryStream rawData)
        {
            ReadAndValidateEtxMessages(rawData, null);
        }
        public void ReadAndValidateEtxMessages(MemoryStream rawData, string expectedError)
        {
            if (!String.IsNullOrEmpty(expectedError))
                Global.RO.Debug("Looking for exception: " + expectedError);

            try
            {
                List<VxEvent> result = VxProtocol.ReadStream(rawData);
                if (result.Count != this.Batch.Events.Count)
                    throw new Exception("The number of events read by VxProtocol reader did not match the number of events written.");


                ValidateEtxEvents(result, expectedError);


                if (!String.IsNullOrEmpty(expectedError))
                    throw new Exception("Succeded when expecting an exception.");
            }
            catch (Exception ex)
            {
                if (!String.IsNullOrEmpty(expectedError))
                {
                    if (ex.Message.Contains(expectedError))
                        Global.RO.Debug("Found the proper exception: " + ex.Message);
                    else
                        throw;
                }
                else
                    throw;
            }
        }

        public void ValidateEtxFields(VxEvent.VortexFieldCollection result, List<VortexEtxField> expected, string expectedError)
        {
            foreach (VortexEtxField expectedField in expected)
            {
                switch (expectedField.FieldType)
                {
                    case EtxFieldType.Guid:
                    case EtxFieldType.Blob:
                        byte[] expectedBlob;

                        if (expectedField.FieldValue is BlobTestHelper)
                            expectedBlob = (byte[])(BlobTestHelper)expectedField.FieldValue;
                        else if (expectedField.FieldValue is Guid)
                            expectedBlob = ((Guid)expectedField.FieldValue).ToByteArray();
                        else
                            expectedBlob = (byte[])expectedField.FieldValue;

                        byte[] resultBlob = result.GetBytes(expectedField.FieldId);
                        if (expectedBlob.Length != resultBlob.Length)
                            throw new Exception(String.Format("Length did not match. Expected {0} obtained {1}", expectedBlob.Length, resultBlob.Length));
                        for (int k = 0; k < expectedBlob.Length; k++)
                        {
                            if (expectedBlob[k] != resultBlob[k])
                                throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}", expectedBlob[k], resultBlob[k]));
                        }
                        break;
                    case EtxFieldType.Single:
                        {
                            float expectedResult = Convert.ToSingle(expectedField.FieldValue);
                            float obtainedResult = result.GetSingle(expectedField.FieldId);

                            if (expectedResult != obtainedResult)
                                throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}", expectedResult, obtainedResult));
                        }
                        break;
                    case EtxFieldType.Double:
                        {
                            double expectedResult = Convert.ToDouble(expectedField.FieldValue);
                            double obtainedResult = result.GetDouble(expectedField.FieldId);
                            if (expectedResult != obtainedResult)
                                throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}", expectedResult, obtainedResult));
                        }
                        break;
                    case EtxFieldType.VarInt:
                        {
                            ValidateVarInt(expectedField.FieldValue, result, expectedField.FieldId);
                        }
                        break;
                    case EtxFieldType.DateTime:
                    case EtxFieldType.SVarInt:
                        {
                            long val;
                            if (expectedField.FieldValue is DateTime)
                            {
                                val = (long)((DateTime)expectedField.FieldValue).ToFileTimeUtc();
                                ValidateSVarInt(val, result, expectedField.FieldId);
                            }
                            else
                                ValidateSVarInt(expectedField.FieldValue, result, expectedField.FieldId);
                        }
                        break;
                    case EtxFieldType.String:
                        {
                            string expectedResult = Convert.ToString(expectedField.FieldValue);
                            string obtainedResult = result.GetString(expectedField.FieldId);
                            if (expectedResult != obtainedResult)
                                throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}", expectedResult, obtainedResult));
                        }
                        break;
                    case EtxFieldType.AutovalueWrapper:
                        string expectedVal = ((AutoValueTestHelper)(expectedField.FieldValue)).ExpectedValue.ToString();
                        SpecialField sField = result.GetSpecialField(expectedField.FieldId);

                        if (sField.Value.ToString() != expectedVal)
                            throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}", expectedVal, sField.Value.ToString()));
                        break;
                    case EtxFieldType.Special:
                        SpecialField spField = result.GetSpecialField(expectedField.FieldId);
                        VortexEtxField innerField = (VortexEtxField)expectedField.FieldValue;

                        //@@@@TODO:GHETTO FIX ME
                        if (spField.Id != innerField.FieldId || spField.Value.ToString() != innerField.FieldValue.ToString())
                            throw new Exception(String.Format("Special Field {0}:{1} was not found, instead obtained {2}:{3}", innerField.FieldId, innerField.FieldValue, spField.Id, spField.Value));
                        break;
                    default:
                        break;
                }
            }
        }

        public void ValidateEtxEvents(List<VxEvent> result, string expectedError)
        {
            int messageOrdinal = 0;
            foreach (VortexEtxEvent etxEvent in this.Batch.Events)
            {
                if (result[messageOrdinal].Timestamp != DateTime.FromFileTimeUtc(this.Batch.BaseTimestamp + etxEvent.DeltaTimestamp))
                    throw new Exception("Timestamps did not match in event " + etxEvent.EventId);

                if (etxEvent.EventId != result[messageOrdinal].EventId)
                    throw new Exception(String.Format("Event IDs did not match. Expected {0} obtained {1}", etxEvent.EventId, result[messageOrdinal].EventId));

                if (!(((Blob)(etxEvent.ExpectedProducerId)).Equals(result[messageOrdinal].ProducerId)))
                    throw new Exception("Producer id mismatch!");


                if (result[messageOrdinal].ToString() != etxEvent.ToWireString(this.Batch.BaseTimestamp, true))
                {
                    Global.RO.Debug("The following ToStrings() did not match:");
                    Global.RO.Debug("Server:" + result[messageOrdinal].ToString());
                    Global.RO.Debug("Expected:" + etxEvent.ToWireString(this.Batch.BaseTimestamp, true));
                    throw new Exception("VxEvent and local tostrings did not match!");
                }

                if (result[messageOrdinal].ToString(false) != etxEvent.ToWireString(0, false))
                {
                    Global.RO.Debug("The following ToStrings() did not match:");
                    Global.RO.Debug("Server:" + result[messageOrdinal].ToString(false));
                    Global.RO.Debug("Expected:" + etxEvent.ToWireString(0, false));

                    throw new Exception("VxEvent and local tostrings did not match!");
                }

                ValidateEtxFields(result[messageOrdinal].EventFields, etxEvent.Fields, expectedError);

                messageOrdinal++;
            }
        }

        public void ValidateSVarInt(object expectedValueObj, VxEvent.VortexFieldCollection result, uint ordinal)
        {
            Func<Int64, object, bool> validateSigned = (e, o) =>
            {
                Int64 min = Convert.ToInt64(o.GetType().GetField("MinValue").GetValue(this));
                Int64 max;
                try
                {
                    max = Convert.ToInt64(o.GetType().GetField("MaxValue").GetValue(this));
                }
                catch (OverflowException)
                {
                    return true; //Not going to be a valid validation.
                }
                Int64 co = Convert.ToInt64(o);

                if (e < min || e > max)
                    return true; //Stuff will be wrong.

                if (e != co)
                    throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}. Type under test: {2} ", e, co, co.GetType().Name));
                else
                    return false;
            };

            Int64 expectedValue = Convert.ToInt64(expectedValueObj);

            //These might go away, and are troublesome, for now check the top level one only.
            //validateSigned(expectedValue, result.GetSByte(ordinal));                
            //validateSigned(expectedValue, result.GetInt16(ordinal));
            //validateSigned(expectedValue, result.GetInt32(ordinal));
            validateSigned(expectedValue, result.GetInt64(ordinal));
            //validateSigned(expectedValue, result.GetByte(ordinal));
            //validateSigned(expectedValue, result.GetUInt16(ordinal));
            //validateSigned(expectedValue, result.GetUInt32(ordinal));
            //validateSigned(expectedValue, result.GetUInt64(ordinal));                
        }
        public void ValidateVarInt(object expectedValueObj, VxEvent.VortexFieldCollection result, uint ordinal)
        {
            Func<UInt64, object, bool> validateUnsigned = (e, o) =>
            {
                UInt64 max = Convert.ToUInt64(o.GetType().GetField("MaxValue").GetValue(this));
                UInt64 min;
                try
                {
                    min = Convert.ToUInt64(o.GetType().GetField("MinValue").GetValue(this));
                }
                catch (OverflowException)
                {
                    return true; //Not going to be a valid validation.
                }

                if (e < min || e > max)
                    return true; //Stuff will be wrong.

                UInt64 co = Convert.ToUInt64(o);
                if (e != co)
                    throw new Exception(String.Format("Values did not match. Expected {0} obtained {1}. Type under test: {2} ", e, co, o.GetType().Name));
                else
                    return false;
            };


            UInt64 expectedValue = Convert.ToUInt64(expectedValueObj);


            //These might go away, and are troublesome, for now check the top level one only.
            //validateUnsigned(expectedValue, result.GetInt16(ordinal));
            //validateUnsigned(expectedValue, result.GetInt32(ordinal));
            //validateUnsigned(expectedValue, result.GetInt64(ordinal));
            //validateUnsigned(expectedValue, result.GetSByte(ordinal));
            //validateUnsigned(expectedValue, result.GetByte(ordinal));
            //validateUnsigned(expectedValue, result.GetUInt16(ordinal));
            //validateUnsigned(expectedValue, result.GetUInt32(ordinal));
            validateUnsigned(expectedValue, result.GetUInt64(ordinal));
        }

        public byte[] ToArray()
        {
            MemoryStream ms = new MemoryStream();
            this.Write(ms);
            ms.Position = 0;
            return ms.ToArray();
        }
    }

    /// <summary>
    /// A batch of events.
    /// </summary>
    public class VortexEtxEventBatch
    {
        public Int64 BaseTimestamp { get; set; }
        public List<VortexEtxEvent> Events { get; set; }

        public void AddEvent(VortexEtxEvent etxEvent)
        {
            this.Events.Add(etxEvent);
        }
        public VortexEtxEventBatch(IEnumerable<VortexEtxEvent> events)
        {
            BaseTimestamp = DateTime.Now.ToFileTimeUtc();
            this.Events = new List<VortexEtxEvent>();

            if (events != null)
                this.Events.AddRange(events);
        }
        public VortexEtxEventBatch(VortexEtxEvent etxEvent)
            : this(new VortexEtxEvent[] { etxEvent })
        {
        }
        public VortexEtxEventBatch()
            : this(new VortexEtxEvent[] { })
        {
        }
    }

    /// <summary>
    /// A specific etx event. Contains a group of fields.
    /// </summary>
    public class VortexEtxEvent
    {
        public const int LOGSTRINGID_ORDINAL = 1;
        public const int MAX_FIELDID = 256;

        internal static readonly byte[] PXUIDKey = new byte[] { 0x58, 0x62, 0x6F, 0x78, 0x33, 0x36, 0x30, 0x20, 0x52, 0x75, 0x6C, 0x65, 0x7A, 0x21 };

        public ulong nonce = VortexUtil.nonceMagicNumber;
        public byte[] ProducerId { get; set; }
        private byte[] expectedProducerId;
        public byte[] ExpectedProducerId
        {
            get
            {
                if (expectedProducerId == null)
                    return ProducerId;
                else
                    return expectedProducerId;
            }
            set
            {
                expectedProducerId = value;
            }
        }

        public uint EventId { get; set; } //???
        public Int64 DeltaTimestamp { get; set; } //???        

        public List<VortexEtxField> Fields { get; set; }
        public List<VortexEtxField> HeaderFields { get; set; }

        public VortexEtxEvent(IEnumerable<VortexEtxField> fields, uint messageId)
            : this(fields, new byte[] { 0 }, messageId)
        {
        }

        public VortexEtxEvent(IEnumerable<VortexEtxField> fields, byte[] producerId, uint messageId)
        {
            if (fields != null)
                this.Fields = new List<VortexEtxField>(fields);
            else
                this.Fields = new List<VortexEtxField>();

            HeaderFields = new List<VortexEtxField>();

            this.ProducerId = producerId;
            this.EventId = messageId;
        }

        public VortexEtxField GetFieldByOrdinal(uint fieldId)
        {
            int count = Fields.Count;
            for (int k = 0; k < count; k++)
            {
                if (Fields[k].FieldId == fieldId)
                    return Fields[k];
            }
            return null;
        }

        public uint GetMaxFieldId()
        {
            uint maxId = 0;

            int count = Fields.Count;
            for (int k = 0; k < count; k++)
            {
                if (Fields[k].FieldId > maxId)
                    maxId = Fields[k].FieldId;
            }

            return (maxId > MAX_FIELDID) ? MAX_FIELDID : maxId;
        }

        public DataField GetFieldDefinition(uint fieldId)
        {
            if (this.EventManifest != null)
            {
                Event evt = GetEventDefinition();
                if (evt != null)
                    return evt.DataFields.Ordinals[fieldId];
            }
            return null;
        }

        public DataField GetHeaderDefinition(uint fieldId)
        {
            if (this.EventManifest != null)
            {
                Event evt = GetEventDefinition();
                if (evt != null)
                {
                    if (evt.HeaderFields.Ordinals.ContainsKey(fieldId))
                        return evt.HeaderFields.Ordinals[fieldId];
                    else
                        return null;
                }
                else
                    return VortexProtocolInputBase.HeaderDefinitions[3].DataFields.Ordinals[fieldId];
            }
            return null;
        }

        public Event GetEventDefinition()
        {
            if (this.EventManifest != null)
            {
                if (this.EventManifest.Producers.Fingerprints.ContainsKey(this.ProducerId))
                    return this.EventManifest.GetEventByOrdinal(this.ProducerId, this.EventId);
            }
            
            return null;
        }

        public string GetLogstringId()
        {
            if (this.EventManifest != null)
            {
                Event evt = GetEventDefinition();
                if (evt != null && !String.IsNullOrEmpty(evt.LogStringId))
                    return evt.LogStringId;
                else if (evt != null && !String.IsNullOrEmpty(evt.Symbol))
                    return evt.Symbol;
                else
                    return ((Blob)this.ExpectedProducerId) + "@" + EventId;
            }
            return null;
        }        
        
        //Simpler rules for just raw object tostring
        public string ToWireString(Int64 baseTimeStamp, bool includeTimestamp)
        {
            StringBuilder buf = new StringBuilder("");
            Blob b = (Blob)ExpectedProducerId;

            CreateRawHeader(buf, baseTimeStamp, includeTimestamp);
            uint maxId = GetMaxFieldId();


            for (uint k = 1; k <= maxId; k++)
            {
                VortexEtxField field = GetFieldByOrdinal(k);
                if (field != null)
                {
                    object fv = field.FieldValue;
                
                    if (fv is VortexEtxField)
                        fv = ((VortexEtxField)fv).FieldValue;

                    if (fv is AutoValueTestHelper)
                    {
                        AutoValueTestHelper avh = (AutoValueTestHelper)fv;
                        fv = avh.ExpectedValue;
                    }

                    if (fv is BlobTestHelper)
                    {
                        fv = ((Blob)((BlobTestHelper)fv).arr).ToString();
                    }

                    if (fv is Guid)
                    {
                        fv = ((Guid)fv).ToByteArray();
                    }

                    if (fv == null)
                        continue;
                    else if (fv is ulong)
                        buf.Append(((ulong)fv).ToString("X"));
                    else if (fv is uint)
                        buf.Append(((uint)fv).ToString("X"));
                    else if (fv is ushort)
                        buf.Append(((ushort)fv).ToString("X"));
                    else if (fv is byte)
                        buf.Append(((byte)fv).ToString("X"));
                    else if (fv is byte[])
                        buf.Append(((Blob)(byte[])fv).ToString());
                    else if (fv is DateTime)
                        buf.Append(((DateTime)fv).ToFileTimeUtc());
                    else
                        buf.Append(fv.ToString());
                }
                buf.Append("|");
            }

            if (buf.Length != 0)
                buf.Remove(buf.Length - 1, 1);

            return buf.ToString();
        }

        public void CreateVortexHeader(StringBuilder buf)
        {
            CreateVortexHeader(buf, PrivacyTreatments.PassThrough);
        }

        public void CreateVortexHeader(StringBuilder buf, PrivacyTreatments treatment)
        {
            Blob b = (Blob)ExpectedProducerId;
            Event ev = GetEventDefinition();

            if (ev != null && ev.HeaderVersion != 0 && !VortexProtocolInputBase.HeaderDefinitions.ContainsKey(ev.HeaderVersion))
                return;

            var sortedHeaders = from hf in HeaderFields
                                orderby hf.FieldId ascending
                                select hf;
            //Output headers except the first cleanser timestamp that's always there.
            foreach (VortexEtxField f in sortedHeaders)
            {
                object fv = f.FieldValue;

                if (fv is VortexEtxField)
                    fv = ((VortexEtxField)fv).FieldValue;

                if (fv is AutoValueTestHelper)
                {
                    AutoValueTestHelper avh = (AutoValueTestHelper)fv;
                    fv = avh.ExpectedValue;
                }

                if (f.FieldId != 1 && ev != null && !ev.HeaderFields.Ordinals.ContainsKey(f.FieldId))
                {
                    continue;
                }

                if (ev != null)
                {
                    if (!(f.FieldId == 1 && ev.HeaderFields.Ordinals[f.FieldId].AutoValue == AutoValues.Timestamp))
                    {
                        TransformOutput(ev.HeaderFields.Ordinals[f.FieldId], fv, ref buf, treatment);
                        buf.Append("|");
                    }
                }
                else
                {
                    if (!(f.FieldId == 1))
                    {
                        TransformOutput(VortexProtocolInputBase.HeaderDefinitions[3].DataFields.Ordinals[f.FieldId], fv, ref buf, treatment);
                        buf.Append("|");
                    }
                }
            }            
        }

        public void CreateRawHeader(StringBuilder buf, Int64 baseTimeStamp, bool includeTimestamp)
        {            
            //I've got NOTHING. I'm some kinda raw object. Let's do the ghetto header.            
            DateTime dt = DateTime.MinValue;
            try
            {
                dt = DateTime.FromFileTimeUtc(baseTimeStamp + this.DeltaTimestamp);
            }
            catch (Exception)
            {
            }

            if (includeTimestamp && dt != DateTime.MinValue)
            buf.Append(dt.ToString("yyyy/MM/dd HH:mm:ss.fff") + "|");

            string logstringId = GetLogstringId();
            if (String.IsNullOrEmpty(logstringId))
                buf.Append(String.Format("{0}@{1}|", ((Blob)this.ExpectedProducerId).ToString(), EventId));
            else
                buf.Append(logstringId + "|");            
        }        

        public override string ToString()
        {
            return ToString(PrivacyTreatments.PassThrough);
        }

        public string ToString(PrivacyTreatments treatment)
        {
            StringBuilder buf = new StringBuilder("");
            Blob b = (Blob)ExpectedProducerId;            

            CreateVortexHeader(buf, treatment);
            uint maxId = GetMaxFieldId();


            for (uint k = 1; k <= maxId; k++)
            {
                VortexEtxField field = GetFieldByOrdinal(k);
                
                DataField fieldDef = null;
                if (field != null)
                    fieldDef = this.GetFieldDefinition(field.FieldId);

                if (fieldDef != null && fieldDef.Name.Contains("SPECIALFIELD"))
                    continue; //We don't expect this to be a real thing, it'll get eradicated. Skip it.

                //If we have a field AND either the field definition is null or we don't have a deprecated liveservice autovalue then we have something to mess with.
                if (field != null &&
                    (fieldDef == null || !(fieldDef.Deprecated == true && fieldDef.AutoValueCreator == AutoValueCreators.LiveService)))
                {
                    object fv = field.FieldValue;

                    if (fv is VortexEtxField)
                    {
                        VortexEtxField vef = (VortexEtxField)fv;
                        fv = ((VortexEtxField)fv).FieldValue;
                        if (vef.FieldId == VortexEtxEvent.LOGSTRINGID_ORDINAL && field.FieldType == EtxFieldType.Special)
                            continue;                        
                    }

                    if (fv is AutoValueTestHelper)
                    {
                        AutoValueTestHelper avh = (AutoValueTestHelper)fv;
                        fv = avh.ExpectedValue;
                    }

                    TransformOutput(fieldDef, fv, ref buf, treatment);
                }
                buf.Append("|");
            }

            if (buf.Length != 0)
                buf.Remove(buf.Length - 1, 1);

            return buf.ToString();
        }

        private bool IsValidInOutCombo(DataField fieldDef)
        {
            DataFieldType dfType = fieldDef.InType;
            AutoValues? av = fieldDef.AutoValue;
            bool res = false;
            switch (fieldDef.OutType)
            {
                case OutputType.String:
                    res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.Binary) || (dfType == DataFieldType.UnicodeString);
                    break;
                case OutputType.Number:
                    res = (dfType == DataFieldType.UInt16) || (dfType == DataFieldType.UInt32) || (dfType == DataFieldType.UInt8) || (dfType == DataFieldType.UInt64) || (dfType == DataFieldType.Int8) || (dfType == DataFieldType.Int16) || (dfType == DataFieldType.Int32) || (dfType == DataFieldType.Int64);
                    break;
                case OutputType.HexNumber:
                    res = (dfType == DataFieldType.UInt16) || (dfType == DataFieldType.UInt32) || (dfType == DataFieldType.UInt8) || (dfType == DataFieldType.UInt64) || (dfType == DataFieldType.Int8) || (dfType == DataFieldType.Int16) || (dfType == DataFieldType.Int32) || (dfType == DataFieldType.Int64);
                    break;
                case OutputType.Float:
                    res = (dfType == DataFieldType.Float) || (dfType == DataFieldType.Double);
                    break;
                case OutputType.DateTime:
                    res = (dfType == DataFieldType.UInt64) || (dfType == DataFieldType.Int64);
                    break;
                case OutputType.Ipv4Address:
                    res = (dfType == DataFieldType.UInt32) || (dfType == DataFieldType.Binary);
                    break;
                case OutputType.GUID:
                case OutputType.LBIOnlyGUID:
                    res = (dfType == DataFieldType.GUID) || (dfType == DataFieldType.Binary);
                    break;
                case OutputType.SgNonce:
                case OutputType.Xuid:
                case OutputType.FlowToken:
                    res = (dfType == DataFieldType.UInt64);
                    break;
                case OutputType.HResult:
                    res = (dfType == DataFieldType.UInt32) || (dfType == DataFieldType.Int32);
                    break;
                case OutputType.XexVersion:
                    res = (dfType == DataFieldType.UInt32);
                    break;
                case OutputType.TitleName:
                    res = (dfType == DataFieldType.UInt32);
                    break;
                case OutputType.ConsoleId:
                    res = (dfType == DataFieldType.UInt64) || (dfType == DataFieldType.Binary);
                    break;
                default:
                    break;
            }
            if (av != null)
            {
                switch (av)
                {
                    case AutoValues.CountryId:
                        res = (dfType == DataFieldType.UInt8) || (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString);
                        break;
                    case AutoValues.CultureId:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString);
                        break;
                    case AutoValues.FlowToken:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt64);
                        break;
                    case AutoValues.Ipv4Address:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt32);
                        break;
                    case AutoValues.LanguageId:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt8);
                        break;
                    case AutoValues.MembershipType:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt8);
                        break;
                    case AutoValues.Timestamp:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt64) || (dfType == DataFieldType.Int64);
                        break;
                    case AutoValues.TitleId:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString) || (dfType == DataFieldType.UInt32);
                        break;
                    case AutoValues.PrimarySgNonce:
                        res = (dfType == DataFieldType.UInt64);
                        break;
                    case AutoValues.MachineId:
                        res = (dfType == DataFieldType.UInt64);
                        break;
                    case AutoValues.LogStringId:
                        res = (dfType == DataFieldType.AnsiString) || (dfType == DataFieldType.UnicodeString);
                        break;
                    default:
                        break;
                }
            }
            
            return res;
        }

        /// <summary>
        /// Creates the PXUID from the XUID
        /// </summary>
        /// <param name="xuid">Xuid that we are transforming</param>
        /// <returns>The pXuid hash to check against</returns>
        private string GenPXuid(ulong xuid)
        {
            using (HMACSHA256 hash = new HMACSHA256(PXUIDKey))
            {
                byte[] hashXuid;
                byte[] result = new byte[16];
               
                // compute the stable sha256 hash of the xuid
                hashXuid = hash.ComputeHash(BitConverter.GetBytes(xuid));
                
                // take the top 128 bits of the hash as result
                Buffer.BlockCopy(hashXuid, 16, result, 0, result.Length);
                return BitConverter.ToString(result).Replace("-","");
            }

            
        }

        private void TransformOutput(DataField fieldDef, object fv, ref StringBuilder buf)
        {
            TransformOutput(fieldDef, fv, ref buf, PrivacyTreatments.PassThrough);
        }

        private void TransformOutput(DataField fieldDef, object fv, ref StringBuilder buf, PrivacyTreatments privacyType)
        {
            try
            {
                if (fv == null) return;

                bool defAvailable = fieldDef != null;

                // For LBI output, all data should be LBI so filter out all PII info.  XUID needs to be anon.
                // For MBI output, the LBI Only GUID needs to be filtered
                if (privacyType != PrivacyTreatments.PassThrough)
                {
                    switch (fieldDef.OutType)
                    {
                        case OutputType.FlowToken:
                        case OutputType.Ipv4Address:
                        case OutputType.SgNonce:
                            if (privacyType == PrivacyTreatments.LBI)
                            {
                                // return without putting anything on the stream
                                return;
                            }
                            break;
                        case OutputType.LBIOnlyGUID:
                            if (privacyType == PrivacyTreatments.MBI)
                            {
                                // return without putting anything on the stream
                                return;
                            }
                            break;
                        case OutputType.Xuid:
                            if (privacyType == PrivacyTreatments.LBI)
                            {
                                // call xuid transform stuff
                                string privacyXuid = GenPXuid((ulong)fv);
                                
                                // then make sure it isn't the same
                                if (privacyXuid == ((ulong)fv).ToString("X"))
                                {
                                    throw new Exception("PXUID and XUID are equal.  PXUID conversion failed.");
                                }
                                buf.Append(privacyXuid);
                                return;
                            }
                            break;
                        default: // Let it fall through out of the bing DCR stuff
                            break;
                    }
                }

                if (defAvailable && !IsValidInOutCombo(fieldDef))
                    return;

                if (!defAvailable)
                {
                    if (fv is byte[])
                    {
                        Blob fieldBlob = (Blob)(byte[])fv;
                        fv = fieldBlob;
                    }

                    if (fv is UInt64 || fv is UInt32 || fv is UInt16 || fv is byte)
                        fv = Convert.ToUInt64(fv).ToString("X"); //Just upconvert

                    if (fv is Guid)
                        fv = ((Blob)((Guid)fv).ToByteArray()).ToString();
                    buf.Append(fv.ToString());
                }
                else
                {
                    if (fv is Guid)
                    {
                        if (fieldDef.InType == DataFieldType.GUID || fieldDef.OutType == OutputType.GUID || fieldDef.OutType == OutputType.LBIOnlyGUID)
                            fv = VortexUtil.EndianFlipGuid(((Guid)fv)).ToString();

                        if (!(fv is string)) //Didn't succeed above.
                        {
                            fv = VortexUtil.EndianFlipGuid(((Guid)fv).ToByteArray());                            
                        }
                    }
                    else if (fv is DateTime)
                    {
                        if (fieldDef.OutType == OutputType.DateTime)
                            fv = ((DateTime)fv).ToString("yyyy/MM/dd HH:mm:ss.fff");
                        fv = ((DateTime)fv).ToFileTimeUtc(); //ulong to print in hex
                    }
                    else if (fv is byte[])
                    {
                        if (fieldDef.OutType == OutputType.Ipv4Address)
                        {
                            if (((byte[])fv).Length == 4)
                                fv = new IPAddress((byte[])fv);
                            else
                                fv = String.Empty; //Invalid case, going to get emptied out.
                        }
                        else if (fieldDef.OutType == OutputType.GUID)
                        {
                            fv = new Guid((byte[])fv).ToString();
                        }
                        else if (fieldDef.OutType == OutputType.ConsoleId)
                        {
                            fv = ConvertConsoleId((byte[])fv);
                        }
                        else
                        {
                            Blob fieldBlob = (Blob)(byte[])fv;
                            fv = fieldBlob.ToString();
                        }
                    }
                    else if (fv is BlobTestHelper)
                    {
                        BlobTestHelper hlp = (BlobTestHelper)fv;
                        Blob fieldBlob = (Blob)(byte[])hlp.arr;
                        fv = fieldBlob.ToString();
                    }

                    //Separate numbers in case someone like datetime dumped it back down as a number and to do the final append.
                    if (fv is ulong)
                    {
                        if (fieldDef.OutType == OutputType.DateTime)
                            buf.Append(DateTime.FromFileTimeUtc(((long)((ulong)fv))).ToString("yyyy/MM/dd HH:mm:ss.fff"));
                        else if (fieldDef.OutType == OutputType.HexNumber || fieldDef.OutType == OutputType.Xuid || fieldDef.OutType == OutputType.SgNonce)  // added XUIDs here for Bing DCR
                            buf.Append(((ulong)fv).ToString("X"));
                        else if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((ulong)fv));
                        else if (fieldDef.OutType == OutputType.FlowToken)
                        {
                            Floken flowtoken = new Floken((ulong)fv);
                            buf.Append(flowtoken.ToString());
                        }
                        else if (fieldDef.OutType == OutputType.ConsoleId)
                            buf.Append(ConvertConsoleId((ulong)fv));
                    }
                    else if (fv is uint)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((uint)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((uint)fv).ToString("X"));
                        else if (fieldDef.OutType == OutputType.HResult)
                        {
                            xonline.common.service.HResult hr = (xonline.common.service.HResult)(uint)fv;
                            buf.Append(hr.ToString());
                            buf.Append(":");
                            if (hr.HasName)
                                buf.Append(hr.Name);
                        }
                        else if (fieldDef.OutType == OutputType.XexVersion)
                        {
                            uint dwVersion = (uint)fv;
                            buf.Append(String.Format("{0}.{1}.{2}.{3}",
                                ((dwVersion & 0xF0000000) >> 28),
                                ((dwVersion & 0x0F000000) >> 24),
                                ((dwVersion & 0x00FFFF00) >> 8),
                                (dwVersion & 0x000000FF)));
                        }
                        else if (fieldDef.OutType == OutputType.TitleName)
                        {
                            TitleId titleId = (TitleId)(uint)fv;
                            buf.Append(titleId.ToString());
                            buf.Append(":");
                            //Dev needs to add titlename. here @@TODO
                        }
                        else if (fieldDef.OutType == OutputType.Ipv4Address)
                        {
                            buf.Append(new IPAddress(VortexUtil.ConvertIPToNetwork(new IPAddress((uint)fv))));
                        }
                    }
                    else if (fv is ushort)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((ushort)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((ushort)fv).ToString("X"));
                    }
                    else if (fv is byte)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((byte)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((byte)fv).ToString("X"));
                    }
                    else if (fv is long)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((long)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((long)fv).ToString("X"));
                        else if (fieldDef.OutType == OutputType.DateTime)
                            buf.Append(DateTime.FromFileTimeUtc(((long)fv)).ToString("yyyy/MM/dd HH:mm:ss.fff"));
                    }
                    else if (fv is int)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((int)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((int)fv).ToString("X"));
                        else if (fieldDef.OutType == OutputType.HResult)
                        {
                            try
                            {
                                xonline.common.service.HResult hr = (xonline.common.service.HResult)fv;
                                buf.Append(hr.ToString());
                                buf.Append(":");
                                if (hr.HasName)
                                    buf.Append(hr.Name);
                            }
                            catch (Exception)
                            {
                                buf.Append("0x" + Convert.ToInt32(fv).ToString("X") + ":");
                            }
                        }
                    }
                    else if (fv is short)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((short)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((short)fv).ToString("X"));
                    }
                    else if (fv is sbyte)
                    {
                        if (fieldDef.OutType == OutputType.Number)
                            buf.Append(((sbyte)fv));
                        else if (fieldDef.OutType == OutputType.HexNumber)
                            buf.Append(((sbyte)fv).ToString("X"));
                    }
                    else if (fv is float)
                    {
                        buf.Append(((float)fv).ToString("R"));
                    }
                    else if (fv is double)
                    {
                        buf.Append(((double)fv).ToString("R"));
                    }
                    else
                        buf.Append(fv.ToString());
                }
            }
            catch (Exception ex)
            {
                Global.RO.Info("Swallowing possibly benign exception (negative test case)while adding data to a field:\r\n" + ex.Message);
            }
        }

        private string ConvertConsoleId(ulong consoleId)
        {
            //
            // The least significant nibble is the verification digit.  The remaining
            // 36 bits form the real console identifier.
            //     
            consoleId = consoleId & 0xFFFFFFFFFF; //Only first 5 bytes.
            UInt64 CheckDigit = (consoleId) & 0xF;
            consoleId >>= 4;

            return (consoleId.ToString() + CheckDigit.ToString()).PadLeft(12, '0');
        }
        private string ConvertConsoleId(byte[] ConsoleIdA)
        {            
            ulong consoleId = 0;
            for (int i = 0; i < 5; i++)
                consoleId = (consoleId << 8) + ConsoleIdA[i];

            UInt64 CheckDigit = (consoleId) & 0xF;
            consoleId >>= 4;

            return (consoleId.ToString() + CheckDigit.ToString()).PadLeft(12, '0');
        }

        private EtxManifest etxManifest;
        public EtxManifest EventManifest 
        {
            get
            {
                return etxManifest;
            }
            set
            {
                etxManifest = VortexUtil.CloneManifest(value);
            }
        } //Used for test purposes.        
    }

    /// <summary>
    /// A specific etx field.
    /// </summary>
    public class VortexEtxField
    {
        public EtxFieldType FieldType { get; set; }
        public uint FieldId { get; set; }

        public object FieldValue { get; set; }
        public uint FieldTypeId
        {
            get
            {
                EtxFieldType type = this.FieldType;

                //Handle convenience wrappers.
                if (type == EtxFieldType.Guid)
                    type = EtxFieldType.Blob;
                else if (this.FieldType == EtxFieldType.DateTime)
                    type = EtxFieldType.SVarInt;

                return (((uint)(type)) & 7) | (FieldId << 3);
            }
        }

        public VortexEtxField(EtxFieldType fieldType, uint fieldId, object value)
        {
            this.FieldType = fieldType;
            this.FieldId = fieldId;
            this.FieldValue = value;
        }
    }

    public struct BlobTestHelper
    {
        public byte[] arr;
        public int length;

        public static explicit operator byte[](BlobTestHelper blob)
        {
            return blob.arr;
        }
    }

    public class AutoValueTestHelper
    {
        private SpecialField field;
        private bool exactMatch = true;
        public bool ExactMatch
        {
            get { return exactMatch; }
            set { exactMatch = value; }
        }

        public AutoValues? AvType { get; set; }

        public object ExpectedValue { get; set; }
        public object PushValue { get; set; }
        public SpecialField InnerField { get { return field; } set { field = value; } }

        public AutoValueTestHelper(AutoValues? avType, object expectedValue, object pushValue)
        {
            AvType = avType;
            field = new SpecialField();
            if (AutoValues.LogStringId == avType)
                field.Id = VortexEtxEvent.LOGSTRINGID_ORDINAL;
            else
                field.Id = (uint)EtxFieldType.Special;
            ExpectedValue = expectedValue;
            PushValue = pushValue;
        }

        public AutoValueTestHelper(AutoValues avType)
            : this(avType, null, null)
        {
        }

    }

    /// <summary>
    /// Does all the actual byte stream writing work. 
    /// 7Bit encoding taken from Kevin's code. We do not support .NET's 
    /// native BinaryWriter.Write7BitEncodedInt - it breaks on read of negative ints.
    /// </summary>
    public class VortexProtocolWriter : BinaryWriter
    {

        public bool Hook_DisableSpecialFieldTerminator { get; set; }
        public bool Hook_DisableFieldTerminator { get; set; }

        private static readonly VortexEtxField FieldTerminator = new VortexEtxField(EtxFieldType.Terminator, 0, null);
        public VortexProtocolWriter()
            : base()
        {
        }

        public VortexProtocolWriter(System.IO.Stream output)
            : base(output)
        {
        }

        public VortexProtocolWriter(System.IO.Stream output, Encoding encoding)
            : base(output, encoding)
        {
        }

        public void Write(VortexEtxMessage data)
        {
            base.Write((byte)data.ProtocolType);
            Write(data.Batch);
        }

        private void Write(VortexEtxEventBatch batch)
        {
            base.Write(batch.BaseTimestamp);
            foreach (VortexEtxEvent msg in batch.Events)
            {
                Write(msg);
            }
        }

        private void Write(VortexEtxEvent msg)
        {
            if (msg.ProducerId != null)
                WriteBlob(msg.ProducerId.Length, msg.ProducerId);

            WriteVarInt(msg.EventId);
            WriteVarInt(msg.DeltaTimestamp);

            foreach (VortexEtxField field in msg.Fields)
                Write(field);

            if (!Hook_DisableFieldTerminator)
                Write(FieldTerminator);
        }

        private void Write(VortexEtxField field)
        {
            if (field.FieldValue is AutoValueTestHelper)
                return;
            if (field.FieldType != EtxFieldType.Terminator)
            {
                WriteVarInt(field.FieldTypeId);
                WriteObject(field.FieldValue);
            }
            else
                base.Write((byte)0);
        }

        private void WriteObject(object o)
        {
            //Go through supported types
            if (o is Byte)
                WriteVarInt((Byte)o);
            else if (o is UInt16)
                WriteVarInt((UInt16)o);
            else if (o is UInt32)
                WriteVarInt((UInt32)o);
            else if (o is UInt64)
                WriteVarInt((UInt64)o);
            else if (o is SByte)
                WriteVarInt((SByte)o);
            else if (o is Int16)
                WriteVarInt((Int16)o);
            else if (o is Int32)
                WriteVarInt((Int32)o);
            else if (o is Int64)
                WriteVarInt((Int64)o);
            else if (o is DateTime)
                WriteVarInt(((DateTime)o).ToFileTimeUtc());
            else if (o is float)
                Write((float)o);
            else if (o is double)
                Write((double)o);
            else if (o is byte[])
                WriteBlob((byte[])o);
            else if (o is BlobTestHelper)
            {
                BlobTestHelper hlp = (BlobTestHelper)o;
                WriteBlob(hlp.length, hlp.arr);
            }
            else if (o is Guid)
                WriteBlob(((Guid)o).ToByteArray());
            else if (o is DateTime)
                WriteVarInt((ulong)((DateTime)o).ToFileTimeUtc());
            else if (o is string)
                WriteBlob(UTF8Encoding.UTF8.GetBytes((string)o));
            else if (o is VortexEtxField)
                Write((VortexEtxField)o);
            else
                throw new InvalidCastException(o.GetType().Name + " type was unrecognized.");
        }

        private void WriteBlob(int length, byte[] bytes)
        {
            WriteVarInt((UInt64)length);
            base.Write(bytes);
        }

        private void WriteBlob(byte[] bytes)
        {
            WriteVarInt((UInt64)bytes.Length);
            base.Write(bytes);
        }
        private void WriteDateTime(DateTime dt)
        {
            WriteVarInt(DateTime.Now.ToFileTimeUtc());
        }

        private void WriteVarInt(Byte n)
        {
            WriteVarInt((UInt64)n);
        }
        private void WriteVarInt(UInt16 n)
        {
            WriteVarInt((UInt64)n);
        }
        private void WriteVarInt(UInt32 n)
        {
            WriteVarInt((UInt64)n);
        }
        /// <summary>
        /// Snapshot from VortexProt.cs
        /// </summary>
        /// <param name="v"></param>
        /// <returns></returns>
        private void WriteVarInt(UInt64 n)
        {
            while (n >= 0x80)
            {
                Write((byte)(n | 0x80));
                n = n >> 7;
            }
            Write((byte)n);
        }

        private void WriteVarInt(SByte n)
        {
            WriteVarInt((Int64)n);
        }
        private void WriteVarInt(Int16 n)
        {
            WriteVarInt((Int64)n);
        }
        private void WriteVarInt(Int32 n)
        {
            WriteVarInt((Int64)n);
        }
        /// <summary>
        /// Snapshot from VortexProt.cs
        /// </summary>
        /// <param name="v"></param>
        /// <returns></returns>
        private void WriteVarInt(Int64 n)
        {
            ulong num = ToZigZag(unchecked((ulong)n));
            WriteVarInt(num);
        }

        private ulong ToZigZag(ulong v)
        {
            // Must right-shift with a signed left-hand-side, to ensure an arithmetic 
            // shift. Basically, we want all 0's if MSB is 0 or all 1's if MSB is 1. 
            ulong signbitmask = (ulong)((long)v >> 63);
            return (v << 1) ^ signbitmask;
        }
    }
    #endregion

    /// <summary>
    /// Helper library pulled from IFLIC test cases.
    /// </summary>
    public class LogCollectorCrypto
    {

        private static readonly byte[] keyMask = new byte[] 
        {
            0xbb, 0xe9, 0x98, 0x69, 0xb9, 0x8d, 0xc8, 0xfd, 
            0x8a, 0x69, 0x19, 0xb9, 0x09, 0x88, 0xc8, 0xfd,
            0x2b, 0x09, 0xd9, 0x69, 0x39, 0xa9
        };
        private static readonly byte[] protectedKey = new byte[]
        {
            0xa7, 0x80, 0xa9, 0x04, 0x22, 0x4f, 0xd6, 0x1e, 0x03, 0x5f, 0x51, 0x02, 0xae, 0x34, 0xcb, 0x7a
        };

        private static byte[] GetKey()
        {
            byte[] signingKey = new byte[protectedKey.Length];

            for (int i = 0; i < protectedKey.Length; i++)
            {
                signingKey[i] = (byte)(keyMask[i] ^ protectedKey[i]);
            }

            return signingKey;
        }

        public static bool VerifySignature(byte[] signature, Stream content)
        {
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                content.Seek(0, SeekOrigin.Begin);
                byte[] computedSignature = hasher.ComputeHash(content);

                if (computedSignature.Length != signature.Length)
                {
                    return false;
                }

                for (uint currentByte = 0; currentByte < computedSignature.Length; ++currentByte)
                {
                    if (signature[currentByte] != computedSignature[currentByte])
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        public static string CreateSignature(Stream content)
        {
            using (HMACSHA1 hasher = new HMACSHA1(GetKey()))
            {
                byte[] computedSignature = hasher.ComputeHash(content);

                System.Text.StringBuilder sb = new System.Text.StringBuilder();
                foreach (byte chunk in computedSignature)
                {
                    sb.Append(chunk.ToString("X2"));
                }

                return sb.ToString();
            }
        }
    }

    /// <summary>
    /// This class exposes the protected fields of an AAInfo object for writing.
    /// Ripped right out of sts test and modified for my convenience.
    /// </summary>
    public class AAInfoWrapper : xonline.common.service.AAInfo
    {
        // Expose the constructor
        public AAInfoWrapper()
            : base()
        {
            _ipAddressInternet = "";
            _certDeviceId = "";
            _samlToken = "";
        }

        // These properties are serialized to the AuthZ header
        public new ulong PassportPuid { get { return _passportPuid; } set { _passportPuid = value; } }
        public new string IpAddressInternet { set { _ipAddressInternet = value; } }
        public new Floken FlowToken { set { _flowToken = value; } }
        public new ulong? LiveXuid { set { _liveXuid = value; } }
        public new ulong PassportCId { get { return _passportCId; } set { _passportCId = value; } }
        public new DateTime NotAfter { get { return _notAfterDateTime; } set { _notAfterDateTime = value; } }
        public new DateTime IssueInstant { get { return _issueInstantDateTime; } set { _issueInstantDateTime = value; } }
        public new string CertDeviceId { get { return _certDeviceId; } set { _certDeviceId = value; } }
        public string SamlToken { get { return _samlToken; } set { _samlToken = value; } }

        // These properties are not serialized
        public xonline.common.service.XblSamlToken SamlSecurityToken { set { _xblSamlToken = value; } }
        public new System.Net.IPAddress OriginatingIP { set { _originatingIP = value; } }
        public new byte? CountryId { set { _countryId = value; } }
        public new System.Collections.BitArray UserPrivileges { set { _userPrivileges = value; } }

        private VortexEtxMessage message;
                
        public void FillOutAAinfo(VortexEtxMessage message)
        {
            this.message = message;
            if (message != null)
                foreach (VortexEtxEvent evt in message.Batch.Events)
                {
                    foreach (VortexEtxField f in evt.Fields)
                    {
                        FillInData(evt, f, false);
                    }
                    foreach (VortexEtxField f in evt.HeaderFields)
                    {
                        FillInData(evt, f, true);
                    }
                }
        }

        public void FillInData(VortexEtxEvent evt, VortexEtxField f, bool fromHeader)
        {
            if (f.FieldValue is AutoValueTestHelper)
            {
                AutoValueTestHelper avh = (AutoValueTestHelper)f.FieldValue;

                DataField fDef = null;
                if (fromHeader)
                    fDef = evt.GetHeaderDefinition(f.FieldId);
                else
                    fDef = evt.GetFieldDefinition(f.FieldId);
                switch (avh.AvType)
                {

                    case AutoValues.FlowToken:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt64)
                                    avh.ExpectedValue = (ulong)0;
                                else
                                    avh.ExpectedValue = "FT0";
                            }
                        }
                        break;
                    case AutoValues.Ipv4Address:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt32)
                                {
                                    avh.ExpectedValue = VortexUtil.ConvertIPToNetwork(VortexUtil.LocalIPAddress());
                                }
                                else
                                    avh.ExpectedValue = VortexUtil.LocalIPAddress().ToString();
                                IpAddressInternet = avh.ExpectedValue.ToString();
                            }
                        }
                        break;
                    case AutoValues.Timestamp:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt64)
                                    avh.ExpectedValue = (ulong)message.Batch.BaseTimestamp;
                                else if (fDef.InType == DataFieldType.Int64)
                                    avh.ExpectedValue = (long)message.Batch.BaseTimestamp;
                                else
                                    avh.ExpectedValue = DateTime.FromFileTimeUtc(message.Batch.BaseTimestamp).ToString("yyyy/MM/dd HH:mm:ss.fff");
                            }
                        }
                        break;
                    case AutoValues.LogStringId:
                        break;
                    default:
                        avh.ExpectedValue = ""; //Empty string if unsupported.                                    
                        break;
                }
                if (avh.ExpectedValue == null)
                    avh.ExpectedValue = avh.PushValue;
            }
        }

        #region AAInfo Abstract Members

        // No need to implement these.

        protected override void PopulateLiveXuid()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserInfo()
        {
            throw new NotImplementedException();
        }

        protected override void PopulateUserPrivileges()
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}

namespace ServerTestFramework.LiveService.Vortex.CAKE
{
    #region CAKE Helpers

    /// <summary>
    /// Base class for NPDB CAKE settings. Defines the general structure of 
    /// what it means to be a CAKE npdb setting and how to write yourself into NPDB.
    /// If you are something that gets written directly into NPDB you must implement
    /// GetMultisettingName() so that NPDBSetting knows where to write the serialized XML.
    /// </summary>
    public class NPDBSetting : IXmlSerializable
    {
        protected virtual string GetMultisettingName()
        {
            throw new NotImplementedException();
        }

        public void AddUpdateToServer()
        {
            Global.XEnv.MultiSettingAdd(Global.XEnv.GetEnv(), VortexUtil.vortex_Component, "-1", "ALL", GetMultisettingName(), ToXmlString());
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }

        public void DeleteALLFromServer()
        {
            Global.XEnv.MultiSettingDelete(Global.XEnv.GetEnv(), VortexUtil.vortex_Component, "-1", "ALL", GetMultisettingName());
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }

        public void DeleteFromServer()
        {
            Global.XEnv.MultiSettingDeleteValue(Global.XEnv.GetEnv(), VortexUtil.vortex_Component, "-1", "ALL", GetMultisettingName(), this.ToXmlString());
            Global.XEnv.ForceConfigReload(VortexUtil.vortex_Interface);
        }

        public void LoadFromNPDB()
        {
            throw new NotImplementedException();
        }

        public bool ExistsInServer()
        {
            string[] vals = new string[] { "Remove this later. Don't need this right now since we're not shipping CAKE so I'm just gonna disable it." };//Global.XEnv.MultiSettingRead(this.GetMultisettingName());

            string expectedVal = ToXmlString();
            foreach (string val in vals)
            {
                if (val == expectedVal)
                    return true;
            }
            return false;
        }

        public string ToXmlString()
        {
            MemoryStream stream = new MemoryStream();
            XmlWriter writer = XmlWriter.Create(stream);

            XmlSerializer serializer = new XmlSerializer(this.GetType());
            serializer.Serialize(stream, this);

            if (stream == null || stream.Length == 0)
                return null;

            stream.Flush();
            stream.Position = 0;
            StreamReader sr = new StreamReader(stream);
            string s = sr.ReadToEnd();
            return s.Remove(0, s.IndexOf("\r\n") + 2); //Take out the standard xml header thingy

        }

        #region IXmlSerializable Members

        public virtual System.Xml.Schema.XmlSchema GetSchema()
        {
            throw new NotImplementedException();
        }

        public virtual void ReadXml(XmlReader reader)
        {
            throw new NotImplementedException();
        }

        public virtual void WriteXml(XmlWriter writer)
        {
            throw new NotImplementedException();
        }

        #endregion
    }

    [Serializable]
    public class EventBuilder : NPDBSetting, IXmlSerializable
    {
        private string Name { get; set; }

        [XmlIgnore]
        public Dictionary<string, string> fields = new Dictionary<string, string>();

        public EventBuilder(string name)
            : this()
        {
            this.Name = name;
        }

        public EventBuilder()
        {
            fields = new Dictionary<string, string>();
        }

        public static EventBuilder Create(string name, string[] names, string[] values)
        {
            CAKE.EventBuilder builder = new CAKE.EventBuilder(name);
            for (int k = 0; k < names.Length; k++)
                builder.fields.Add(names[k], values[k]);

            return builder;
        }

        public static EventBuilder Create(string name, string names, string values)
        {
            return Create(name, new string[] { names }, new string[] { values });
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("EventBuilder");

            this.Name = reader["name"];
            reader.ReadStartElement("EventBuilder");
            if (reader.NodeType == XmlNodeType.None)
                return;
            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                string key = reader.Name;
                reader.ReadStartElement();
                string value = reader.ReadString();
                reader.ReadEndElement();
                fields.Add(key, value);
            }
            reader.ReadEndElement();

        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            if (Name != null)
                writer.WriteAttributeString("name", Name);

            foreach (string key in fields.Keys)
            {
                writer.WriteStartElement(key);
                writer.WriteValue(fields[key]);
                writer.WriteEndElement();
            }
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }
    }

    [Serializable]
    public class EventBuilderRef : NPDBSetting, IXmlSerializable
    {
        [XmlIgnore]
        public string Name { get; set; }

        public EventBuilderRef(string name)
        {
            Name = name;
        }

        public EventBuilderRef()
        {
        }

        public static EventBuilderRef Create(string name)
        {
            CAKE.EventBuilderRef builderRef = new CAKE.EventBuilderRef(name);

            return builderRef;
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("EventBuilderRef");

            this.Name = reader["name"];
            reader.ReadStartElement("EventBuilderRef");
        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            if (Name != null)
                writer.WriteAttributeString("name", Name);
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }
    }

    [Serializable]
    public class EventSink : NPDBSetting, IXmlSerializable
    {
        public string Name { get; set; }
        public string InitParams { get; set; }

        [XmlIgnore]
        public Dictionary<string, string> fields = new Dictionary<string, string>();

        public EventSink(string name)
            : this()
        {
            this.Name = name;
        }

        public EventSink()
        {
            fields = new Dictionary<string, string>();
        }

        public static EventSink Create(string name, string[] names, string[] values)
        {
            CAKE.EventSink sink = new CAKE.EventSink(name);
            sink.InitParams = "target=remote;enable=yes";
            for (int k = 0; k < names.Length; k++)
                sink.fields.Add(names[k], values[k]);

            return sink;
        }

        public static EventSink Create(string name, string names, string values)
        {
            return Create(name, new string[] { names }, new string[] { values });
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("EventSink");

            this.Name = reader["name"];
            this.InitParams = reader["initparams"];
            reader.ReadStartElement("EventSink");
            if (reader.NodeType == XmlNodeType.None)
                return;
            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                string key = reader.Name;
                reader.ReadStartElement();
                string value = reader.ReadString();
                reader.ReadEndElement();
                fields.Add(key, value);
            }
            reader.ReadEndElement();

        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            if (Name != null)
                writer.WriteAttributeString("name", Name);

            if (InitParams != null)
                writer.WriteAttributeString("initparams", InitParams);

            foreach (string key in fields.Keys)
            {
                writer.WriteStartElement(key);
                writer.WriteValue(fields[key]);
                writer.WriteEndElement();
            }
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }
    }

    [Serializable]
    public class Log : NPDBSetting, IXmlSerializable
    {
        [XmlIgnore]
        public List<Stream> Streams { get; set; }

        [XmlIgnore]
        public string Name { get; set; }

        public void AddStream(Stream str)
        {
            Streams.Add(str);
        }

        public void RemoveStream(Stream str)
        {
            RemoveStream(str.Name);
        }

        public void RemoveStream(string name)
        {
            for (int k = 0; k < Streams.Count; k++)
            {
                if (Streams[k].Name == name)
                {
                    Streams.RemoveAt(k);
                    break;
                }
            }
        }

        public Log()
        {
            Streams = new List<Stream>();
        }
        public Log(string name)
            : this()
        {
            Name = name;
        }

        public static Log Create(string name, Stream[] arr)
        {
            CAKE.Log log = new CAKE.Log(name);

            if (arr != null && arr.Length > 0)
            {
                foreach (Stream s in arr)
                {
                    log.AddStream(s);
                }
            }

            return log;
        }

        public static Log Create(string name, Stream arr)
        {
            return Create(name, new Stream[] { arr });
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("Log");

            this.Name = reader["id"];
            reader.ReadStartElement("Log");

            XmlSerializer serializer = new XmlSerializer(typeof(Stream));

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None)
                Streams.Add((Stream)serializer.Deserialize(reader));
            reader.ReadEndElement();
        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            if (Name != null)
                writer.WriteAttributeString("id", Name);
            XmlSerializer serializer = new XmlSerializer(typeof(Stream));
            foreach (Stream str in Streams)
            {
                serializer.Serialize(writer, str);
            }
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }


        #region NPDBSetting Members
        protected override string GetMultisettingName()
        {
            //Replace with proper NPDB setting.
            return "vortex_cake_log_config_xml";
        }
        #endregion
    }

    [Serializable]
    public class Query : NPDBSetting, IXmlSerializable
    {
        List<EventSink> sinks;
        [XmlIgnore]
        public string Name { get; set; }

        public void AddSink(EventSink sink)
        {
            sinks.Add(sink);
        }

        public Query()
        {
            sinks = new List<EventSink>();
        }

        public Query(string name)
            : this()
        {
            Name = name;
        }

        public static Query Create(string name, EventSink[] arr)
        {
            CAKE.Query query = new CAKE.Query(name);

            if (arr != null && arr.Length > 0)
            {
                foreach (EventSink s in arr)
                {
                    query.AddSink(s);
                }
            }

            return query;
        }

        public static Query Create(string name, EventSink sink)
        {
            return Create(name, new EventSink[] { sink });
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("Query");

            this.Name = reader["name"];
            reader.ReadStartElement("Query");
            if (reader.NodeType == XmlNodeType.None)
                return;

            XmlSerializer serializer = new XmlSerializer(typeof(EventSink));

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None)
                sinks.Add((EventSink)serializer.Deserialize(reader));
            reader.ReadEndElement();
        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EventSink));

            if (Name != null)
                writer.WriteAttributeString("name", Name);

            foreach (EventSink evtSink in sinks)
            {
                serializer.Serialize(writer, evtSink);
            }
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        #region NPDBSetting Members
        protected override string GetMultisettingName()
        {
            //Replace with proper NPDB setting.
            return "vortex_cake_query_config_xml";
        }
        #endregion
    }

    [Serializable]
    public class Stream : NPDBSetting, IXmlSerializable
    {
        [XmlIgnore]
        public List<EventBuilderRef> BuilderRefs { get; set; }

        [XmlIgnore]
        public List<EventBuilder> Builders { get; set; }

        [XmlIgnore]
        public string Name { get; set; }


        public Stream()
        {
            Builders = new List<EventBuilder>();
            BuilderRefs = new List<EventBuilderRef>();
        }
        public Stream(string name)
            : this()
        {
            Name = name;
        }

        public static Stream Create(string name, EventBuilder builder)
        {
            CAKE.Stream stream = new CAKE.Stream(name);
            stream.Builders.Add(builder);
            return stream;
        }

        public static Stream Create(string name, EventBuilderRef builderRef)
        {
            CAKE.Stream stream = new CAKE.Stream(name);
            stream.BuilderRefs.Add(builderRef);
            return stream;
        }

        public override void ReadXml(System.Xml.XmlReader reader)
        {
            if (reader.NodeType == XmlNodeType.None)
                reader.ReadToFollowing("Stream");

            this.Name = reader["name"];
            reader.ReadStartElement("Stream");


            XmlSerializer serializer = new XmlSerializer(typeof(EventBuilder));
            XmlSerializer refSerializer = new XmlSerializer(typeof(EventBuilderRef));

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement && reader.NodeType != XmlNodeType.None)
            {
                if (reader.Name == "EventBuilder")
                    Builders.Add((EventBuilder)serializer.Deserialize(reader));
                else if (reader.Name == "EventBuilderRef")
                    BuilderRefs.Add((EventBuilderRef)refSerializer.Deserialize(reader));
            }

            reader.ReadEndElement();

        }

        public override void WriteXml(System.Xml.XmlWriter writer)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EventBuilder));
            XmlSerializer refSerializer = new XmlSerializer(typeof(EventBuilderRef));

            if (Name != null)
                writer.WriteAttributeString("name", Name);

            foreach (EventBuilder builder in Builders)
                serializer.Serialize(writer, builder);

            foreach (EventBuilderRef builderRef in BuilderRefs)
                serializer.Serialize(writer, builderRef);
        }

        public override System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\xrlvortexlogstring.cs ===
using System;
using System.IO;
using System.Runtime.InteropServices;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using System.Net.Sockets;
using System.Net;
using System.Collections.Generic;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities;
using xonline.common.core.etx;


namespace ServerTestFramework.LiveService.Vortex
{
    /// <summary>
    /// Summary description for XRLLogString.
    /// </summary>
    public class XRLLogStringVortex : XRLPayload
    {
        public ushort logLinesLength;

        [XRLPayloadFld(SizeParam = "logLinesLength")]
        public string ll;

        public virtual string logLine
        {
            get
            {
                return ll;
            }
            set
            {
                ll = value;
            }
        }

        public XRLLogStringVortex()
        {
            ServiceId = XOService.Vortex;
            this.Slot.AddService(XOService.Vortex);            
        }

        protected override string GetServiceName()
        {
            return @"/vortex/logstring.ashx";
        }


        override public bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VortexUtil.vortex_VirtualInterface));
        }

        protected override void ReadResponse(MemoryStream responseStream)
        {
            // override this so base class doesn't throw exception
            // this is really handled by Execute
        }
    }

    /// <summary>
    /// Summary description for XRLLogString.
    /// </summary>
    public class XRLLogBinaryVortex : XRLLogStringVortex
    {
        [WireInfo(Serialize = false)] //Hide me!
        public int logBytesLength;

        [XRLPayloadFld(SizeParam = "logBytesLength")]
        public byte[] logBytes;

        [WireInfo(Serialize = false)] //Hide me!
        public VortexEtxMessage message;        

        public override string logLine
        {
            get
            {
                return ll;
            }
            set
            {
                ll = value;
                string[] strings = logLine.Split('|');
                List<VortexEtxField> fields = new List<VortexEtxField>();
                if (strings.Length >= 1)
                    fields.Add(new VortexEtxField(EtxFieldType.Special, 1, new VortexEtxField(EtxFieldType.String, 1, strings[0])));

                for (int k = 1; k < strings.Length; k++)
                    fields.Add(new VortexEtxField(EtxFieldType.String, (uint)k + 1, strings[k]));

                VortexEtxEvent evt = new VortexEtxEvent(fields, 1);
                VortexEtxMessage msg = new VortexEtxMessage(new VortexEtxEventBatch(evt), VortexProtocolType.DistMon);
                logBytes = msg.ToArray();
                logBytesLength = logBytes.Length;
            }
        }

        protected override string GetServiceName()
        {
            return @"/vortex/logbinary.ashx";
        }

        public override void ManualPopulateSlot()
        {
            PopulateSlot(ref Slot);
            
            //Uhh anything better than this?
            Slot.userPuid0 = 1;
            Slot.userPuid1 = 2;
            Slot.userPuid2 = 3;
            Slot.userPuid3 = 4;
            Slot.liNonce = (long)VortexUtil.nonceMagicNumber;
            
            AutoValueTestHelper culture = null;
            byte languageId = 0;
            byte countryId = 0;

            if (message != null)
            {
                foreach (VortexEtxEvent evt in message.Batch.Events)
                {
                    foreach (VortexEtxField f in evt.Fields)
                    {
                        FillInData(evt, f, ref languageId, ref countryId, ref culture, false);
                    }
                    
                    foreach (VortexEtxField f in evt.HeaderFields)
                    {
                        FillInData(evt, f, ref languageId, ref countryId, ref culture, true);
                    }
                    
                    //After we're done with the event clean up on the culture - it needs both language and country to be present
                    if (culture != null)
                    {
                        string[] arr = Locale.BuildValidLocaleList((uint)languageId, (uint)languageId, CountryDictionary.CountryCode(countryId));
                        if (arr.Length > 0)
                            culture.ExpectedValue = arr[0];
                    }
                }
            }
            ManualSlotSetup =true;
        }

        public void FillInData(VortexEtxEvent evt, VortexEtxField f, ref byte languageId, ref byte countryId, ref AutoValueTestHelper culture, bool fromHeader)
        {
            if (f.FieldValue is AutoValueTestHelper)
            {
                ManualSlotSetup = true;

                AutoValueTestHelper avh = (AutoValueTestHelper)f.FieldValue;
                
                DataField fDef;
                if (fromHeader)
                    fDef = evt.GetHeaderDefinition(f.FieldId);
                else
                    fDef = evt.GetFieldDefinition(f.FieldId);

                if (fDef == null)
                    return;
                switch (avh.AvType)
                {
                    case AutoValues.CountryId:
                        {
                            if (avh.PushValue != null)
                            {
                                byte value = Convert.ToByte(avh.PushValue);

                                if (value == Byte.MaxValue)
                                {
                                    value = (byte)103;
                                    avh.PushValue = value;
                                }

                                Slot.SetRegionInfo(value, 0);

                                try
                                {
                                    if (fDef.InType == DataFieldType.AnsiString) //Convert it, otherwise keep the value
                                        avh.ExpectedValue = CountryDictionary.CountryCode(value);
                                }
                                catch (Exception)
                                {
                                    avh.ExpectedValue = String.Empty;
                                }
                                countryId = value;
                            }
                        }
                        break;
                    case AutoValues.FlowToken:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt64)
                                    avh.ExpectedValue = Slot.flowToken;
				else
                                    avh.ExpectedValue = new Floken(Slot.flowToken).ToString();
                            }

                        }
                        break;
                    case AutoValues.CultureId:
                        {
                            culture = avh;
                        }
                        break;
                    case AutoValues.Ipv4Address:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt32)
                                {
                                    avh.ExpectedValue = VortexUtil.ConvertIPToNetwork(VortexUtil.LocalIPAddress());
                                }
                                else
                                    avh.ExpectedValue = VortexUtil.LocalIPAddress().ToString();
                            }
                        }
                        break;
                    case AutoValues.LanguageId:
                        {
                            if (avh.PushValue != null)
                            {
                                UInt32 maxVal = UserFlagsUtil.XONLINE_USER_LANGUAGE_MASK >> UserFlagsUtil.XONLINE_USER_LANGUAGE_SHIFT;
                                byte value = Convert.ToByte(avh.PushValue);

                                if (value > maxVal)
                                {
                                    value = (byte)10;
                                    avh.PushValue = value;
                                }

                                Slot.SetRegionInfo(0, value);

                                try
                                {
                                    if (fDef.InType == DataFieldType.AnsiString)
                                        avh.ExpectedValue = Locale.NeutralCultureFromLanguage(value);
                                }
                                catch (Exception)
                                {
                                    avh.ExpectedValue = String.Empty;
                                }
                                languageId = (byte)value;
                            }
                        }
                        break;
                    case AutoValues.MachineId:
                        {
                            if (avh.PushValue != null)
                                Slot.machinePuid = Convert.ToUInt64(avh.PushValue);
                        }
                        break;
                    case AutoValues.Timestamp:
                        {
                            if (avh.ExpectedValue == null)
                            {
                                if (fDef.InType == DataFieldType.UInt64)
                                    avh.ExpectedValue = (ulong)message.Batch.BaseTimestamp;
                                else if (fDef.InType == DataFieldType.Int64)
                                    avh.ExpectedValue = (long)message.Batch.BaseTimestamp;
                                else
                                    avh.ExpectedValue = DateTime.FromFileTimeUtc(message.Batch.BaseTimestamp).ToString("yyyy/MM/dd HH:mm:ss.fff");
                            }
                        }
                        break;
                    case AutoValues.TitleId:
                        {
                            if (avh.PushValue != null)
                                Slot.titleId = Convert.ToUInt32(avh.PushValue);
                        }
                        break;
                    case AutoValues.LogStringId:
                        break;
                    case AutoValues.MembershipType:
                        {
                            if (avh.PushValue != null)
                            {
                                byte value = Convert.ToByte(avh.PushValue);

                                if (value == Byte.MaxValue)
                                {
                                    value = (byte)3;
                                    avh.PushValue = value;
                                }

                                Slot.userFlag0 = UserFlagsUtil.SetUserTierId(Slot.userFlag0, value);
                                Slot.userFlag1 = UserFlagsUtil.SetUserTierId(Slot.userFlag1, (byte)0);
                                Slot.userFlag2 = UserFlagsUtil.SetUserTierId(Slot.userFlag2, (byte)0);
                                Slot.userFlag3 = UserFlagsUtil.SetUserTierId(Slot.userFlag3, (byte)0);

                                try
                                {
                                    if (fDef.InType == DataFieldType.AnsiString)
                                        avh.ExpectedValue = xonline.common.service.XOn.UserTierToString(value);
                                }
                                catch (Exception)
                                {
                                    avh.ExpectedValue = String.Empty;
                                }
                            }
                        }
                        break;
                    case AutoValues.PrimarySgNonce:
                        {
                            avh.ExpectedValue = VortexUtil.nonceMagicNumber;
                        }
                        break;
                    default:
                        avh.ExpectedValue = ""; //Empty string if unsupported.
                        break;
                }
                if (avh.ExpectedValue == null) //If purposefully left null it means it will get filled in with the push value.
                    avh.ExpectedValue = avh.PushValue;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AAInfo.cs ===
//
// AAInfo.cs aka ActiveAuthInfo
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This is a class that exposes the ActiveAuth related client data from the 
// ActiveAuthModule / ActiveAuthGateway.  This is only the base class, which holds all the 
// data and has handy accessors.  There are 2 child classes that actually implement the 
// functionality to populate this class. This class can be used in more of a "read-only" 
// context, but cannot populate the LiveXuid, UserInfo, or UserPrivileges fields.
//
// To use this class directly from a standard front door (has Webstore dependency)
//  
//   #using STF.common.service;
//   ...
//   AAInfo aainfo = AAInfoMiddleTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ... 
//
// To use this class if your component lives on the internet tier and runns the 
// aamodule.dll in-process:
//
//   #using STF.common.service;
//   ...
//   AAInfo aainfo = AAInfoInternetTier.Current;
//   ulong puid = aainfo.LiveXuid;
//   ...
//
// To use this class in the "read-only" context:
//
//   #using STF.common.service;
//   ...
//   AAInfo aainfo = AAInfo.Current;
//   Floken flowToken = aainfo.FlowToken;
//   ...
// 
// To use it indirectly via SGInfo (sorry for the extra step):
//
//   if (SGInfo.IsActiveAuth)
//   {
//       // This check is only necessary if your code doesn't know what tier it is being 
//       // called from, but is still capable of linking against xblsecurity.dll and
//       // Webstore libraries.
//       
//       AAInfo aainfo;
//       if (AAInfo.IsInternetTier)
//       {
//           aainfo = AAInfoInternetTier.Current;
//       }
//       else if (AAInfo.IsMiddleTier)
//       {
//           aainfo = AAInfoMiddleTier.Current;
//       }
//
//       // OR, just do AAInfo.Current for the simpler instance.
//       ...
//   }
//   else
//   {
//       SGInfo sginfo = SGInfo.Current;
//       ...
//   }
//
// You can also do the check
//
//   if (AAInfo.IsActiveAuthAvailable)
//   ...
//
// If your code can run on either the Internet tier or Middle tier, that's odd and should 
// be thought about at length. But if you insist, check the AAInfo.IsInternetTier and 
// AAInfo.IsMiddleTier properties. If you are still in doubt, just use the 
// AAInfoInternetTier class - it will work securely from any tier but incur a perf hit.
//
// Author: kgoodier 6/2007
// Updated: kgoodier 1/2009
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Diagnostics;
using System.ServiceModel;

using STF.common.mgmt;
using STF.common.config;

[assembly: XomAreaDefinition(XomAreaName.aainfo)]

namespace STF.common.service
{

public class AAInfo 
{
    // -------------------------------------------------------------------------
    // Current - this is how a consumer, like a front-door, can retrieve a  
    // previously created/found ActiveAuthInfo for a request.
    // NOTE: This only retrieves the value form the Context, and never creates
    // a new AAInfo
    // -------------------------------------------------------------------------
    public static AAInfo Current
    {
        get
        {
            HttpContextAdapter ctx = HttpContextAdapter.Current;
            AAInfo aa = (AAInfo)null;

            if (ctx != null)
            {
                // @@@ we should probably remove these 3 separate caches and collapse them 
                // to one. There are a few edge cases that still need to be worked out, 
                // namely removing AAInfoMiddleTier and AAInfoInternetTier. Until then, 
                // we'll grab from their caches, but won't put it back there.

                // Location 1/3: MiddleTier cache. It has the most hoops to jump through.
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCacheMTier];
                }

                // Location 2/3: InternetTier cache.
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCacheITier];
                }

                // Last chance: the "read-only" version. 
                if (aa == null)
                {
                    aa = (AAInfo)ctx.Items[c_CtxKey_AAInfoCache];
                }

                if (aa != null)
                {
                    return aa;
                }

                // Ok. Not cached. We'll deserialize from the appropriate place, but it 
                // will only be an "AAInfo" instance, so you lose some functionality.  
                // Don't call any of those "Populatexxx" functions.

                aa = new AAInfo();

                if (AAInfo.IsMiddleTier)
                {
                    // In the http headers, which would have come from the 
                    // ActiveAuthGateway.
                    if (!TryMarshallFromHeaders(ctx.Request.Headers, ref aa))
                    {
                        aa = null;
                    }
                }
                else if (AAInfo.IsInternetTier)
                {
                    // In the local context, which would have come from the 
                    // ActiveAuthModule running in our process.
                    if (!TryMarshallFromContext(ctx, ref aa))
                    {
                        aa = null;
                    }
                }

                // Put back in our cache for later use. Note our children won't grab from 
                // here.
                if (aa != null)
                {
                    ctx.Items[c_CtxKey_AAInfoCache] = aa;
                }
            }

            return aa;
        }
    }

    // -------------------------------------------------------------------------
    //
    // Public properties and accessors
    //
    // -------------------------------------------------------------------------

    public string CertDeviceId
    {
        get { return _certDeviceId; }
    }
    
    public string GamerTag
    {
        get { 
            if (null != _xblSamlToken)
                return _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_gamertag0);
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND, "GamerTag");
        }
    }
    
    public ulong PassportCId
    {
        get { 
            if (0 == _passportCId && null != _xblSamlToken)
                _passportCId = ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_cid0));
            return _passportCId;
        }
    }
    
    public ulong PassportPuid
    {
        get { 
            if (0 == _passportPuid && null != _xblSamlToken)
                _passportPuid = ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_puid0));
            return _passportPuid;
        }
    }

    public byte PlatformType
    {
        get { 
            if (null != _xblSamlToken)
                return byte.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype));
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_DATA_NOTFOUND, "PlatformType");
        }
    }
    
    public string IpAddressInternet 
    {
        get { 
            return _ipAddressInternet; 
        }
    }

    public DateTime IssueInstant
    {
        get {
            if (null != _xblSamlToken)
            {
                return _xblSamlToken.NotBefore;
            }
            else
                return _issueInstantDateTime;
        }
    }

    public DateTime NotAfter
    {
        get {
            if (null != _xblSamlToken)
                return _xblSamlToken.ValidTo;
            else
                return _notAfterDateTime; 
        }
    }

    public IPAddress OriginatingIP
    {
        get
        {
            if(_originatingIP == null)
            {
                ushort srcPort = 0;
                SGAddressValidator.GetSourceAddress(HttpContextAdapter.Current, ref _originatingIP, ref srcPort);
            }

            return _originatingIP;
        }
    }

    public ulong LiveXuid
    {
        get 
        { 
            if (_liveXuid == null)
            {
                if (null == _xblSamlToken)
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateLiveXuidFromXCache();
                    if (!IsUserValid)
                    {
                        PopulateLiveXuid(); 
                    }
                    AAInfoCounters.IncLoadXuid(startTime.TimeElapsed * 1000);
                }
                else
                {
                    string value;
                    if ( _xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_xuid0, out value))
                    {
                        _liveXuid = ulong.Parse(value);
                    }
                    else
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID, "LiveXuid");
                    }
                }
            }
            return (ulong)_liveXuid; 
        }
    }

    // Lighter-weight property that only looks at XCache -- currently used in common logging code
    public ulong LiveXuidFromXCache
    {
        get 
        {
            string value;
            ulong xuid = _liveXuid ?? 0;

            if (_liveXuid == null)
            {
                if (null != _xblSamlToken)
                {
                    if (_xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_xuid0, out value))
                    {
                        _liveXuid = xuid = ulong.Parse(value);
                    }
                }
                else
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateLiveXuidFromXCache();
                    xuid = (ulong) _liveXuid;

                    // reset in edge case where we didn't find the XUID
                    if (_liveXuid == 0)
                        _liveXuid = null;

                    AAInfoCounters.IncLoadXuid(startTime.TimeElapsed * 1000);
                }
            }

            return xuid; 
        }
    }

    // Note: This is one of many user-related fields we can expose for free, but we aren't 
    // now because no one has requested them.  Please keep this in mind.
 
    public byte CountryId
    {
        get 
        {
            if (_countryId == null)
            {
                if (null != _xblSamlToken)  // Did you mean VerifyUserCountryId? Datatypes for CountryId don't match from different AAInfo sources!
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_AAINFO_TOKEN_FIELD_NOTVALID, "CountryId");

                XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                PopulateUserInfo();
                AAInfoCounters.IncLoadUserInfo(startTime.TimeElapsed * 1000);
            }
            return (byte)_countryId;
        }
    }

    public BitArray UserPrivileges
    {
        get
        {
            if (_userPrivileges == null)
            {
                if (null == _xblSamlToken)
                {
                    XomRequestTimeElapsed startTime = new XomRequestTimeElapsed();
                    PopulateUserPrivileges();
                    AAInfoCounters.IncLoadPrivileges(startTime.TimeElapsed * 1000);
                }
                else
                {
                    PopulateUserPrivilegesFromToken();
                }
            }
            return _userPrivileges;
        }
    }

    public bool HasPrivilege(int privilege)
    {
        return UserPrivileges[privilege];
    }

    public bool IsUserValid
    {
        get { return LiveXuid > 0; }
    }

    public XblSamlToken XblSamlToken
    {
        get { return _xblSamlToken; }
    }

    public Floken FlowToken
    {
        get 
        { 
            return _flowToken; 
        }
    }

    // -------------------------------------------------------------------------
    // IsCached - returns true if AAInfo is available in the local cache, or false if not.
    // -------------------------------------------------------------------------
    public static bool IsCached
    {
        get
        {
            try
            {
                HttpContextAdapter ctx = HttpContextAdapter.Current;

                if (ctx == null)
                    return false;

                if (null != ctx.Items[c_CtxKey_AAInfoCache])
                    return true;

                if (null != ctx.Items[c_CtxKey_AAInfoCacheITier])
                    return true;

                if (null != ctx.Items[c_CtxKey_AAInfoCacheMTier])
                    return true;

                return false;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }

    // -------------------------------------------------------------------------
    // ClearCache - clears the AAInfo.Current AAInfo object from the HttpContext cache.  
    // Bit of a hack to work around an issue with auto-floken-grabbing code.
    // -------------------------------------------------------------------------
    public static void ClearCache()
    {
        HttpContextAdapter.Current.Items[c_CtxKey_AAInfoCache] = null;
    }

    // -------------------------------------------------------------------------
    // IsActiveAuthAvailable - returns true if AAInfo is available somewhere, either in 
    // the httpcontext (from aamodule directly) or in the http headers (from authsg 
    // forwarder).
    // @@@ DOES NOT LOOK AT THE LOCAL CACHE (it should, and we should change that once we 
    // clean up the AAInfoMiddleTier and AAInfoInternetTier mess)
    // -------------------------------------------------------------------------
    public static bool IsActiveAuthAvailable
    {
        get
        {
            return IsInternetTier || IsMiddleTier;
        }
    }

    // -------------------------------------------------------------------------
    // IsInternetTier - returns true if it appears the AAInfo is coming from the Internet 
    // tier, implying you should use AAInfoInternetTier.Current. This is not 100% reliable 
    // but is pretty good.
    // -------------------------------------------------------------------------
    public static bool IsInternetTier
    {
        get
        {
            HttpContextAdapter ctx = HttpContextAdapter.Current;

            // In context? Implies local aamodule --> Internet tier
            if (ctx != null &&
                ctx.Items[c_CtxKey_PassportPuid] != null &&
                ctx.Items[c_CtxKey_IpAddressInternet] != null)
            {
                return true;
            }

            return false;
        }
    }


    // -------------------------------------------------------------------------
    // IsMiddleTier - returns true if it appears the AAInfo is coming from the middle 
    // tier, implying you should use AAInfoMiddleTier.Current. This is not 100% reliable 
    // but is pretty good.
    // -------------------------------------------------------------------------
    public static bool IsMiddleTier
    {
        get
        {
            // In context? Implies local aamodule --> Internet tier. It's possible the 
            // sender could have included an "Authz" http header, so we need to lock this 
            // check down a bit by making sure there is also nothing in the context and 
            // the request didn't come from a real SG.
            try
            {
                HttpContextAdapter ctx = HttpContextAdapter.Current;

                if (ctx != null &&
                    ctx.Request != null &&
                    ctx.Request.Headers[XHttpHdr.AUTHZ] != null &&
                    !IsInternetTier)
                {
                    IPAddress srcIP = null;
                    ushort    srcPort  = 0;
                    SGAddressValidator.GetSourceAddress(ctx, ref srcIP, ref srcPort);

                    if (SGAddressValidator.Check(srcIP, srcPort) == SGAddressValidator.Answer.Yes)
                    {
                        Xom.NtEvent(XEvent.Id.AAINFO_INVALID_REQUEST, 
                            "IsMiddleTier: \"{0}\" header found, but request came from a real SG ({1}:{2}). XRL: {3}",
                            XHttpHdr.AUTHZ, srcIP.ToString(), srcPort, ctx.Request.Url.LocalPath
                    );

                        return false;
                    }

                    // If not from SG, or unknown (xblob case), then we're ok 
                    return true;
                }

                return false;
            }
            catch (Exception)
            {
                return false;
            }
        }
    }

    // -------------------------------------------------------------------------
    //
    // Public validators (SGInfo like)
    //
    // -------------------------------------------------------------------------

    public void VerifyAttribute( string name, Object value )
    {
        bool isValid = false;
        
        if (value is byte)
            isValid = ((byte)value == byte.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is ulong)
            isValid = ((ulong)value == ulong.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is uint)
        {
            if (XblSamlToken.name_attribute_titleid == name)
                isValid = ((uint)value == uint.Parse(_xblSamlToken.GetAttributeValue(name), System.Globalization.NumberStyles.AllowHexSpecifier));
            else
                isValid = ((uint)value == uint.Parse(_xblSamlToken.GetAttributeValue(name)));
        }
        if (value is int)
            isValid = ((int)value == int.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is ushort)
            isValid = ((ushort)value == ushort.Parse(_xblSamlToken.GetAttributeValue(name)));
        if (value is string)
            isValid = ((string)value == _xblSamlToken.GetAttributeValue(name));
        if (!isValid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyAttribute value:" + value.ToString() + " " + name + ":" + _xblSamlToken.GetAttributeValue(name)
                );
        }
    }

    public void VerifyCertDeviceId( string value )
    {
        if (value != _certDeviceId)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyCertDeviceId value:" + value.ToString() + " CertDeviceId:" + _certDeviceId
                );
        }
    }

    public void VerifyMachineId( ulong value )
    {
        if (value != ulong.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyMachineId value:" + value.ToString() + " " + XblSamlToken.name_attribute_machineid + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_machineid)
                );
        }
    }

    public void VerifyPassportId( ulong value )
    {
        if (value != PassportPuid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyPassportId value:" + value.ToString() + " PassportPuid:" + ((Puid)PassportPuid).ToString()
                );
        }
    }

    public void VerifyPlatformType( byte value )
    {
        if (value != byte.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyPlatformType value:" + value.ToString() + " " + XblSamlToken.name_attribute_platformtype + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_platformtype)
                );
        }
    }

    public void VerifyTitleId( uint value )
    {
        if (value != uint.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleid), System.Globalization.NumberStyles.AllowHexSpecifier))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyTitleId value:" + value.ToString() + " " + XblSamlToken.name_attribute_titleid + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleid)
                );
        }
    }

    public void VerifyTitleVersion( uint value )
    {
        if (value != uint.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleversion)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyTitleVersion value:" + value.ToString() + " " + XblSamlToken.name_attribute_titleversion + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_titleversion)
                );
        }
    }

    public void VerifyUserCountryId( int value )
    {
        if (value != int.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_country0)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserCountryId value:" + value.ToString() + " " + XblSamlToken.name_attribute_country0 + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_country0)
                );
        }
    }

    public void VerifyUserId( ulong value )
    {
        if (value != LiveXuid)
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserId value:" + value.ToString() + " LiveXuid:" + LiveXuid.ToString()
                );
        }
    }

    public void VerifyUserTier( int value )
    {
        if (value != int.Parse(_xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_tier0)))
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyUserTier value:" + value.ToString() + " " + XblSamlToken.name_attribute_tier0 + ":" + _xblSamlToken.GetAttributeValue(XblSamlToken.name_attribute_tier0)
                );
        }
    }

    public void VerifyXblSamlToken()
    {
        if ( null == _xblSamlToken )
        {
            throw new XRLException( HResult.XONLINE_E_AUTHDATA_MISMATCH, XEvent.Id.AAINFO_DATA_VERIFICATION_ERROR, 
                "VerifyXblSamlToken value: NULL"
                );
        }
    }

    static readonly byte[] AAInfoXBancKeyPrefix = new byte[] {
        (byte)'A', (byte)'A', (byte)'I', (byte)'n', (byte)'f', (byte)'o'
    };

    public byte[] AAInfoXBancKey
    {
        get
        {
            MemoryStream ms = new MemoryStream(18);
            BinaryWriter bw = new BinaryWriter(ms);
            bw.Write(AAInfo.AAInfoXBancKeyPrefix);
            bw.Write(ProtocolVersion);  // no collisions for ZDT
            bw.Write(LiveXuid);
            return ms.ToArray();
        }
    }


    // -------------------------------------------------------------------------
    //
    // Private members below here, nothing to see, move along.
    //
    // -------------------------------------------------------------------------

    
    protected UInt32 ProtocolVersion
    {
        // Increment when wire protocol changes!
        get { return WireData.MakeSchemaVersion(2, 1); }
    }

    public bool UseXBanc
    {
        get { return _fUseXBanc; }
        set { _fUseXBanc = value; }
    }

    // -------------------------------------------------------------------------
    // MarshallToHeaders
    //
    // Input for 'headers' should come from WebClient.Headers or HttpRequest.Headers 
    // (HttpContext.Current.Request.Headers). Only used by ActiveAuthGateway.
    // -------------------------------------------------------------------------
    public static void MarshallToHeaders(
        NameValueCollection headers, 
        AAInfo              aa)
    {
        string base64string = aa.ConvertToHttpHeaderValue();
        headers[XHttpHdr.AUTHZ] = base64string;
    }

    // -------------------------------------------------------------------------
    // TryMarshallFromContext
    // -------------------------------------------------------------------------
    public static bool TryMarshallFromContext(
        HttpContext ctx, 
        ref AAInfo  aa)
    {
        return TryMarshallFromContext(new HttpContextAdapter(ctx), ref aa);
    }

    public static bool TryMarshallFromContext(
        HttpContextAdapter ctx,
        ref AAInfo aa)
    {
        ulong?      passportPuid;
        string      ipAddressInternet;
        ulong?      xuid;
        ulong?      passportCId;
        DateTime?   issueInstant;
        DateTime?   notAfter;
        string      certDeviceId;
        string      samlToken;
        string      flowTokenString;
       
        passportPuid      = (ulong?)(ctx.Items[c_CtxKey_PassportPuid]);
        ipAddressInternet = (string)(ctx.Items[c_CtxKey_IpAddressInternet]);
        xuid              = (ulong?)(ctx.Items[c_CtxKey_LiveXuid]);
        passportCId       = (ulong?)(ctx.Items[c_CtxKey_PassportCId]);
        issueInstant      = (DateTime?)(ctx.Items[c_CtxKey_IssueInstantDateTime]);
        notAfter          = (DateTime?)(ctx.Items[c_CtxKey_NotAfterDateTime]);
        certDeviceId      = (string)(ctx.Items[c_CtxKey_certDeviceId]);
        samlToken         = (string)(ctx.Items[c_CtxKey_samlToken]);
        flowTokenString   = (string)(ctx.Items[c_CtxKey_flowToken]);
        
       
        // Passport puid and ip address are required. xuid is optional.
        if (passportPuid == null ||
            ipAddressInternet == null)
        {
            return false;
        }

        aa._passportPuid = (ulong)passportPuid;
        aa._ipAddressInternet = ipAddressInternet;
        if (xuid != null)
        {
            aa._liveXuid = xuid;
        }
        aa._passportCId = (ulong)passportCId;
        aa._issueInstantDateTime = (DateTime)issueInstant;
        aa._notAfterDateTime = (DateTime)notAfter;
        aa._certDeviceId = certDeviceId;
        aa._samlToken = samlToken;
        aa._flowToken = new Floken(flowTokenString);
        if ( 0 < aa._samlToken.Length )
        {
            aa._xblSamlToken = new XblSamlToken( aa._samlToken );
        }
        
        return true;
    }

    // -------------------------------------------------------------------------
    // TryMarshallFromHeaders
    // -------------------------------------------------------------------------
    public static bool TryMarshallFromHeaders(
        NameValueCollection headers, 
        ref AAInfo          aa)
    {
        string base64string = headers[XHttpHdr.AUTHZ];
        if (base64string == null)
        {
            return false;
        }

        aa.ReadFromHttpHeaderValue(base64string);
        return true;
    }

    // -------------------------------------------------------------------------
    // CreateFromAuthZHeader
    // -------------------------------------------------------------------------
    public static AAInfo CreateFromAuthZHeader(
        string              authzHdr)
    {
        AAInfo aa = new AAInfo();
        aa.ReadFromHttpHeaderValue(authzHdr);
        return aa;
    }

    // -------------------------------------------------------------------------
    // BitArrayToIntArray - convert the user privileges from a BitArray to an int[] array. 
    // Useful for serialization and such.
    // -------------------------------------------------------------------------
    public static int[] BitArrayToIntArray(BitArray userPrivileges)
    {
        if (userPrivileges == null)
            return null;

        // I hate using int instead of uint, but the BitArray constructor takes in an int 
        // array, so we're kinda stuck using it.
        int[] privs = new int[(userPrivileges.Length+31) / 32]; // round up
        for (int bit = 0; bit < userPrivileges.Length; bit++)
        {
            if (userPrivileges[bit])
            {
                privs[bit / 32] |= (1 << (bit % 32));
            }
        }
        return privs;
    }


    // -------------------------------------------------------------------------
    // AAInfo default constructor 
    // 
    // Doesn't do much, unlike SGInfo.  
    // -------------------------------------------------------------------------
    protected AAInfo()
    {
        _fUseXBanc = true;

        _passportPuid = 0;
        _ipAddressInternet = null;
        _liveXuid = null;
        _countryId = null;
        _userPrivileges = null;
        _originatingIP = null;
    }

    // -------------------------------------------------------------------------
    // AAInfo marshalling constructor
    //
    // Used by the marshalling code
    // -------------------------------------------------------------------------
    protected AAInfo(ulong passportPuid, string ipAddressInternet)
        : this()
    {
        _passportPuid = passportPuid;
        _ipAddressInternet = ipAddressInternet;
    }


    // -------------------------------------------------------------------------
    // ConvertToHttpHeaderValue - serializes object into a base64 encoded string for use 
    // in an HTTP header.
    // -------------------------------------------------------------------------
    protected string ConvertToHttpHeaderValue()
    {
        MemoryStream ms = new MemoryStream(500); // very rough guess of size
        BinaryWriter bw = new BinaryWriter(ms);

        bw.Write(FullQualifiedName); 
        bw.Write(ProtocolVersion); 
        bw.Write(_passportPuid);
        bw.Write(_ipAddressInternet);
        if (_liveXuid != null)
        {
            bw.Write((ulong)_liveXuid);
        }
        else
        {
            bw.Write((ulong)0);
        }
        bw.Write(_passportCId);
        bw.Write(_issueInstantDateTime.ToBinary());
        bw.Write(_notAfterDateTime.ToBinary());
        bw.Write(_certDeviceId);
        bw.Write(_samlToken);
        _flowToken.Write(bw);

        // we don't write the extra fields. at the moment, the only time we need to 
        // serialize this object is for the authsg to send it to a front door, and in that 
        // case, only the passportPuid and ipAddressInternet are available to the authsg.
        
        return Convert.ToBase64String(ms.ToArray());  // .net call
    }
    
    // -------------------------------------------------------------------------
    // ReadFromHttpHeaderValue - populates object from base64 encoded string that comes 
    // from a HTTP header.
    // -------------------------------------------------------------------------
    protected void ReadFromHttpHeaderValue(string base64string)
    {
        byte[] bytes = Convert.FromBase64String(base64string);
        MemoryStream ms = new MemoryStream(bytes);
        BinaryReader br = new BinaryReader(ms);

        string fullQualifiedName = br.ReadString();  // interesting, but ignored for now
        uint protocolVersion     = br.ReadUInt32();
        //if (protocolVersion > ProtocolVersion)
        //{
        //    throw new Exception(String.Format(
        //        "Version mismatch: Expected name {0}, ver {1}. Got name {2}, ver {3}.",
        //        FullQualifiedName,
        //        ProtocolVersion,
        //        fullQualifiedName,
        //        protocolVersion));
        //}

        _passportPuid            = br.ReadUInt64();
        _ipAddressInternet       = br.ReadString();

        if (protocolVersion >= WireData.MakeSchemaVersion(1, 1))
        {
            ulong xuid           = br.ReadUInt64();
            if (xuid > 0)
            {
                _liveXuid = xuid;
            }

            _passportCId            = br.ReadUInt64();
            _issueInstantDateTime   = DateTime.FromBinary(br.ReadInt64());
            _notAfterDateTime       = DateTime.FromBinary(br.ReadInt64());
            _certDeviceId           = br.ReadString();
            _samlToken              = br.ReadString();

            if ( 0 < _samlToken.Length )
            {
                _xblSamlToken = new XblSamlToken( _samlToken );
            }
        }
        if (protocolVersion >= WireData.MakeSchemaVersion(2, 1))
        {
            _flowToken              = new Floken(br);
        }
        
    }

    // -------------------------------------------------------------------------
    // PopulateLiveXuidFromXCache - look up passport puid in xcache and map to a live 
    // xuid.  
    //
    // Inputs  : _passportPuid
    // Outputs : _liveXuid (will be 0 if lookup failed)
    // -------------------------------------------------------------------------
    protected void PopulateLiveXuidFromXCache()
    {
        _liveXuid = 0;  // never null

        if (PassportPuid == 0)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_WARNING, "PopulateLiveXuidFromXCache: passportpuid is 0, can't look up user");
            return;
        }

        // if this code appears to be running in a server context, try using
        // XCache to lookup the user puid rather than making a separate stored
        // procedure call to UODB.
        if (HttpContextAdapter.Current != null)
        {
            try
            {
                _liveXuid = XCache.LookupPUID(PassportPuid);
            }
            catch (Exception e)
            {
                // @@@ event here?
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XCache: XCache exception: " + e.Message);
            }
        }
        if (_liveXuid > 0)
        {
            AAInfoCounters.IncXCacheHits();
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW, 
                     String.Format("XCache: ppuid 0x{0:X} mapped to xuid 0x{1:X}", 
                     PassportPuid, _liveXuid));
        }
        else
        {
            AAInfoCounters.IncXCacheMisses();
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL, 
                     String.Format("XCache: ppuid 0x{0:X} not found", 
                     PassportPuid));
        }
    }

    protected void PopulateUserPrivilegesFromToken()
    {
        _userPrivileges = new BitArray(XOn.XONLINE_MAX_PRIVILEGE_ID);
        string userPrivileges;

        if (_xblSamlToken.TryGetAttributeValue(XblSamlToken.name_attribute_privileges0, out userPrivileges))
        {
            string[] privileges = userPrivileges.Split(',');

            foreach (string privilege in privileges)
            {
                _userPrivileges[int.Parse(privilege)] = true;
            }
        }
    }
    
    // -------------------------------------------------------------------------
    // TryGetFromXBanc - try to populate class from the XBanc cache
    //
    // Returns true if succeeded, or false if entry wasn't found in XBanc.
    // -------------------------------------------------------------------------
    protected bool TryGetFromXBanc()
    {
        if (!UseXBanc || !IsUserValid)
        {
            return false;
        }

        XBanc xb = new XBanc();
        byte[] xbancValue;
        HResult hr = xb.Query(AAInfoXBancKey, out xbancValue);

        if (! hr.IsOk())
        {
            // xbanc will log an event for most codes, but not S_FALSE (not found) or 
            // E_INVALIDARG.
            if (hr == HResult.S_FALSE)
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL,
                         String.Format("XBanc.Query: LiveXuid 0x{0:X} not found", LiveXuid));
            }
            else if (hr == HResult.E_INVALIDARG)
            {
                // @@@ log event instead of trace
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XBanc.Query: invalid args!");
            }
            else
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, 
                         String.Format("XBanc.Query: failed with hr = {0}", hr));
            }
            AAInfoCounters.IncXBancMisses();
            return false;
        }
        
        Xom.Trace(XomAreaName.aainfo, LogLevel.L_LOW,
                 String.Format("XBanc: found entry for xuid 0x{0:X}.",
                 LiveXuid));

        // Deserialize from xbanc value

        MemoryStream ms = new MemoryStream(xbancValue);
        BinaryReader br = new BinaryReader(ms);

        _countryId = br.ReadByte();
        byte[] privs = br.ReadBytes(XOn.XONLINE_NUM_PRIVILEGE_DWORDS * 4);
        _userPrivileges = new BitArray(privs);
        Debug.Assert(_userPrivileges.Length == XOn.XONLINE_MAX_PRIVILEGE_ID);

        AAInfoCounters.IncXBancHits();
        return true;
    }

    // -------------------------------------------------------------------------
    // PutToXBanc - cache ourself to XBanc
    //
    // Returns true if successfully inserted into XBanc, or false if an error occurred.
    // -------------------------------------------------------------------------
    protected bool PutToXBanc()
    {
        if (!UseXBanc)
        {
            return false;
        }

        // Serialize to xbanc value

        MemoryStream ms = new MemoryStream(50);
        BinaryWriter bw = new BinaryWriter(ms);

        bw.Write(CountryId);
        int[] privs = BitArrayToIntArray(UserPrivileges);
        Debug.Assert(privs.Length == XOn.XONLINE_NUM_PRIVILEGE_DWORDS);
        for (int i = 0; i < privs.Length; i++)
        {
            bw.Write(privs[i]);
        }
        
        byte[] xbancValue = ms.ToArray();
       
        XBanc xb = new XBanc();
        uint expirationTimeInSeconds = Config.GetUIntSetting(Setting.aainfo_xbancExpirationInSeconds);
        HResult hr = xb.Insert(
            AAInfoXBancKey,
            xbancValue,
            expirationTimeInSeconds,    // absolute time
            0);                         // sliding time

        if (hr != HResult.S_OK)
        {
            if (hr == HResult.S_FALSE || hr == HResult.E_ACCESSDENIED)
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_NORMAL,
                         String.Format("Xbanc.SetData: data already existed for LiveXuid 0x{0:X}", LiveXuid));
                // entry IS there, we just didn't put it there.
                return true;
            }
            else if (hr == HResult.E_INVALIDARG)
            {
                // @@@ log event instead of trace
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR, "XBanc.SetData: invalid args!");
            }
            else
            {
                Xom.Trace(XomAreaName.aainfo, LogLevel.L_ERROR,
                         String.Format("XBanc.SetData: failed with hr = {0}", hr));
            }
            return false;
        }

        return true;
    }


    // -------------------------------------------------------------------------
    //
    // Constants used internally. Don't reference them unless your name is 
    // ActiveAuthModule.
    //
    // -------------------------------------------------------------------------

    public const string c_CtxKey_PassportPuid         = "AAInfo_PassportPuid";
    public const string c_CtxKey_IpAddressInternet    = "AAInfo_IpAddressInternet";
    public const string c_CtxKey_LiveXuid             = "AAInfo_LiveXuid";
    public const string c_CtxKey_PassportCId          = "AAInfo_PassportCId";
    public const string c_CtxKey_NotAfterDateTime     = "AAInfo_NotAfterDateTime";
    public const string c_CtxKey_IssueInstantDateTime = "AAInfo_IssueInstantDateTime";
    public const string c_CtxKey_certDeviceId         = "AAInfo_certDeviceId";
    public const string c_CtxKey_samlToken            = "AAInfo_samlToken";
    public const string c_CtxKey_flowToken            = "AAInfo_flowToken";
    public const string c_CtxKey_AAInfoCacheITier     = "AAInfo_CacheCurrentInternetTier";
    public const string c_CtxKey_AAInfoCacheMTier     = "AAInfo_CacheCurrentMiddleTier";
    public const string c_CtxKey_AAInfoCache          = "AAInfo_CacheCurrent";

    protected string FullQualifiedName
    {
        get { return this.GetType().AssemblyQualifiedName; } 
    }


    // -------------------------------------------------------------------------
    //
    // Private members for holding state
    //
    // -------------------------------------------------------------------------

    protected bool          _fUseXBanc;

    // Native properties
    //
    // These come from ActiveAuthModule

    protected ulong         _passportPuid;
    protected string        _ipAddressInternet;
    protected ulong         _passportCId;
    protected DateTime      _notAfterDateTime;
    protected DateTime      _issueInstantDateTime;
    protected string        _certDeviceId;
    protected string        _samlToken;
    protected XblSamlToken  _xblSamlToken;
    protected Floken        _flowToken = Floken.None;

    // AuthSG ip when MiddleTier, otherwise an External IP
    protected IPAddress     _originatingIP;

    // Extended properties
    //
    // We have to look these up. We do it on-demand.

    protected ulong?        _liveXuid;
    protected int?          _countryId;
    protected BitArray      _userPrivileges;

    // -------------------------------------------------------------------------
    //
    // Virtual methods, to be implemented by the children.
    //
    // We'll provide no implementation so that we can still use AAInfo in a "read-only" 
    // manner, but you can't call these methods.
    //
    // -------------------------------------------------------------------------

    virtual protected void PopulateLiveXuid()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    virtual protected void PopulateUserInfo()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    virtual protected void PopulateUserPrivileges()
    {
        throw new NotImplementedException("Not implemented in AAInfo. Please use AAInfoMiddlerTier or AAInfoInternetTier.");
    }

    // -------------------------------------------------------------------------
    //
    // Override(s).
    //
    // -------------------------------------------------------------------------

    public override string ToString()
    {
        try
        {
            StringBuilder bldr = new StringBuilder();

            bldr.Append("InternetIP:  ");
            bldr.Append(IpAddressInternet.ToString());
            bldr.Append("\r\nOriginatingIP:    ");
            bldr.Append(OriginatingIP.ToString());
            bldr.Append("\r\nPassportPuid:   0x");
            bldr.Append(PassportPuid.ToString("X"));
            bldr.Append("\r\nLiveXuid:  0x");
            bldr.Append(LiveXuidFromXCache.ToString("X"));

            if(_countryId != null)
            {
                bldr.Append("\r\nCountryId:   ");
                bldr.Append(((int)_countryId).ToString());
            }

            return bldr.ToString();
        }
        catch(Exception e)
        {
            return "Error building AAInfo.ToString(): " + e.ToString();
        }
    }

}


[XomPerformanceCounterCategoryAttr( "AAInfo", "Xbox Live Active Auth Info", true )]
public class AAInfoCounters : XomPerformanceCounterCategory
{
    // Rate: Load Privileges
    // Rate: Load UserInfo
    // Rate: Load Xuid
    // Rate: XBanc AAInfo hits
    // Rate: XBanc AAInfo misses
    // Rate: XCache Xuid hits
    // Rate: XCache Xuid misses
    // Time: Avg Load Privileges (ms)
    // Time: Avg Load UserInfo (ms)
    // Time: Avg Load Xuid (ms)
    // Total: Load Privileges
    // Total: Load UserInfo
    // Total: Load Xuid
    // Total: XBanc AAInfo hits
    // Total: XBanc AAInfo misses
    // Total: XCache Xuid hits
    // Total: XCache Xuid misses
    
    [XomPerformanceCounterAttr(
        "Rate: Load Privileges",
        "Load Privileges calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Rate: Load UserInfo",
        "Load UserInfo calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Rate: Load Xuid",
        "Load Xuid calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateLoadXuid;

    [XomPerformanceCounterAttr(
        "Rate: XBanc AAInfo hits",
        "XBanc AAInfo hits calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXBancHits;

    [XomPerformanceCounterAttr(
        "Rate: XBanc AAInfo misses",
        "XBanc AAInfo misses calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXBancMisses;

    [XomPerformanceCounterAttr(
        "Rate: XCache Xuid hits",
        "XCache Xuid hits calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXCacheHits;

    [XomPerformanceCounterAttr(
        "Rate: XCache Xuid misses",
        "XCache Xuid misses calls per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
    public PerformanceCounter RateXCacheMisses;


    [XomPerformanceCounterAttr(
        "Time: Avg Load Privileges (ms)",
        "Average time to load privileges, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Time: Avg Load Privileges (base)",
        "Avg Load Privileges (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadPrivilegesBase;

    [XomPerformanceCounterAttr(
        "Time: Avg Load UserInfo (ms)",
        "Average time to load userinfo, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Time: Avg Load UserInfo (base)",
        "Avg Load UserInfo (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadUserInfoBase;

    [XomPerformanceCounterAttr(
        "Time: Avg Load Xuid (ms)",
        "Average time to load xuid, in milliseconds",
         PerformanceCounterType.AverageTimer32)]
    public PerformanceCounter TimeLoadXuid;
    
    [XomPerformanceCounterAttr(
        "Time: Avg Load Xuid (base)",
        "Avg Load Xuid (base)",
         PerformanceCounterType.AverageBase)]
    public PerformanceCounter TimeLoadXuidBase;


    [XomPerformanceCounterAttr(
        "Total: Load Privileges",
        "Load Privileges total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadPrivileges;

    [XomPerformanceCounterAttr(
        "Total: Load UserInfo",
        "Load UserInfo total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadUserInfo;

    [XomPerformanceCounterAttr(
        "Total: Load Xuid",
        "Load Xuid total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalLoadXuid;

    [XomPerformanceCounterAttr(
        "Total: XBanc AAInfo hits",
        "XBanc AAInfo hits total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXBancHits;

    [XomPerformanceCounterAttr(
        "Total: XBanc AAInfo misses",
        "XBanc AAInfo misses total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXBancMisses;

    [XomPerformanceCounterAttr(
        "Total: XCache Xuid hits",
        "XCache Xuid hits total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXCacheHits;

    [XomPerformanceCounterAttr(
        "Total: XCache Xuid misses",
        "XCache Xuid misses total calls",
         PerformanceCounterType.NumberOfItems64)]
    public PerformanceCounter TotalXCacheMisses;

    static public AAInfoCounters Counters = new AAInfoCounters();

    static public void IncLoadPrivileges(long elapsedTime)
    {
        Counters.RateLoadPrivileges.Increment();
        Counters.TotalLoadPrivileges.Increment();
        Counters.TimeLoadPrivileges.IncrementBy(elapsedTime);
        Counters.TimeLoadPrivilegesBase.Increment();
    }

    static public void IncLoadUserInfo(long elapsedTime)
    {
        Counters.RateLoadUserInfo.Increment();
        Counters.TotalLoadUserInfo.Increment();
        Counters.TimeLoadUserInfo.IncrementBy(elapsedTime);
        Counters.TimeLoadUserInfoBase.Increment();
    }

    static public void IncLoadXuid(long elapsedTime)
    {
        Counters.RateLoadXuid.Increment();
        Counters.TotalLoadXuid.Increment();
        Counters.TimeLoadXuid.IncrementBy(elapsedTime);
        Counters.TimeLoadXuidBase.Increment();
    }

    static public void IncXBancHits()
    {
        Counters.RateXBancHits.Increment();
        Counters.TotalXBancHits.Increment();
    }

    static public void IncXBancMisses()
    {
        Counters.RateXBancMisses.Increment();
        Counters.TotalXBancMisses.Increment();
    }

    static public void IncXCacheHits()
    {
        Counters.RateXCacheHits.Increment();
        Counters.TotalXCacheHits.Increment();
    }

    static public void IncXCacheMisses()
    {
        Counters.RateXCacheMisses.Increment();
        Counters.TotalXCacheMisses.Increment();
    }


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AccessToken.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using STF.common.service;

using STF.common.mgmt;
using STF.common.config;

[assembly: XomAreaDefinition(XomAreaName.atTrace)]

namespace STF.common.protocol 
{

    public class AccessToken
    {
        public ushort _operation;
        public ushort _version = accessTokenVersion;
        public uint   _serviceId;
        public uint   _flags;
        public ulong  _userPuid;
        public ulong  _xboxPuid;
        public ushort _pathNameSize;
        public string _pathName;
        public ushort _signatureSize;
        public byte[] _signature;
        
        // Alternative SignOnBehalf URL
        protected string _altSignUrl = null;
    
        public const ushort baseTokenSize = 32;
        public const ushort accessTokenVersion = 1;

        string _verifyUrl
        {
            get
            {
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/VerifySignature.ashx";
            }
        }

        string _signUrl
        {
            get
            {
                if(_altSignUrl == null)
                {
                    IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                    return info.Protocol + "://" + info.IPAddressString + ':' + info.Port + '/' + info.VDir + "/SignOnBehalf.ashx";
                }
                else
                {
                    return _altSignUrl;
                }
            }
        }

        int _xsigTimeout
        {
            get
            {
                IVirtualInterfaceInfo info = Config.GetVirtualInterface(VirtualInterface.xsig_int, Config.SiteId);
                return info.Timeout;
            }
        }

        public virtual void ReadFrom(BinaryReader r)
        {
            // read common data
            _operation    = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: operation="+_operation.ToString("d"));
            _version      = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: version="+_version.ToString("d"));
            _serviceId    = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: serviceId="+_serviceId.ToString("X"));
            _flags        = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: flags="+_flags.ToString("X"));
            _userPuid     = r.ReadUInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: userPuid="+_userPuid.ToString("X"));
            _xboxPuid     = r.ReadUInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: xboxPuid="+_xboxPuid.ToString("X"));
            _pathNameSize = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathNameSize="+_pathNameSize.ToString("d"));
            if ( _pathNameSize > 0 )
            {
                _pathName = Encoding.UTF8.GetString(r.ReadBytes(_pathNameSize));
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: pathName="+_pathName);
            }

            // read data specific to request token
            ReadFromInternal(r);

            // read signature data if present
            _signatureSize = r.ReadUInt16();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "AccessToken: ReadFrom: signatureSize="+_signatureSize.ToString("d"));
            if ( _signatureSize > 0 )
            {
                _signature = r.ReadBytes(_signatureSize);
            }
        }
        
        public virtual void WriteTo(BinaryWriter w)
        {
            // write everything but the signature
            WriteToSign(w);
            
            // write the signature
            _signatureSize = (ushort) ((_signature == null ? 0 : ProtocolConstants.sizeSignature));

            w.Write(_signatureSize);
            if ( _signatureSize > 0 )
            {
                w.Write(_signature);
            }
        }
        
        // WriteToSign
        // Write all data excluding signature field.  Used to create byte array
        // to sign or validate using signature server.
        public virtual void WriteToSign(BinaryWriter w)
        {
            byte[] encodedName = null;
            
            _pathNameSize = 0;
            if ( _pathName != null )
            {
                encodedName = Encoding.UTF8.GetBytes(_pathName);
                _pathNameSize = (ushort) encodedName.Length;
            }
            
            w.Write(_operation);
            w.Write(_version);
            w.Write(_serviceId);
            w.Write(_flags);
            w.Write(_userPuid);
            w.Write(_xboxPuid);
            w.Write(_pathNameSize);
            if ( _pathNameSize > 0 )
            {
                w.Write(encodedName);
            }

            // write data specific to request token
            WriteToInternal(w);
        }
    
        protected virtual void ReadFromInternal(BinaryReader r)
        {
        }
        
        protected virtual void WriteToInternal(BinaryWriter w)
        {
        }

        protected virtual ushort SizeInternal()
        {
            return 0;
        }
        
        // Size
        // Return the size of the AccessToken in bytes
        public virtual ushort Size()
        {
            return (ushort) (baseTokenSize + _pathNameSize + _signatureSize + SizeInternal());
        }

        public virtual void Validate()
        {
            if ( _version != AccessToken.accessTokenVersion )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid version: " + _version);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_147, 
                    "Validate: invalid version: " + _version);
            }
            if ( _pathNameSize == 0 || _pathNameSize > ProtocolConstants.maxSizeName )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid pathNameSize: " + _pathNameSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_148, 
                    "Validate: invalid pathNameSize: " + _pathNameSize);
            }
            if ( _pathNameSize != _pathName.Length )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_149, 
                    "Validate: pathNameSize mismatch.");
            }
            if ( _signatureSize != 0 && _signatureSize != ProtocolConstants.sizeSignature )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid signature size: " + _signatureSize);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_150, 
                    "Validate: invalid signature size: " + _signatureSize);
            }
            
            // This check needs to be removed if we ever make use of the
            // flags field in the protocol.
            if ( _flags != 0 && _flags != 1 )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid flags: " + _flags);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_151, 
                    "Validate: invalid flags: " + _flags);
            }
        }

        // this version of SignOnBehalf will take the authData from SGInfo
        public virtual void SignOnBehalf(XOService serviceId)
        {
            SGInfo sgInfo = SGInfo.Current;
            
            XSigAuthData authData = new XSigAuthData();
            authData._titleID = sgInfo.TitleId;
            authData._titleVersion = sgInfo.TitleVersion;
            authData._userID1 = sgInfo.LogonUsers[0].qwUserID;
            authData._userID2 = sgInfo.LogonUsers[1].qwUserID;
            authData._userID3 = sgInfo.LogonUsers[2].qwUserID;
            authData._userID4 = sgInfo.LogonUsers[3].qwUserID;
            authData._XboxID = sgInfo.MachineId;
            
            SignOnBehalf(serviceId, authData);
        }

        public virtual void SignOnBehalf(XOService serviceId, XSigAuthData authData)
        {
            XSigSignOnBehalfRequest signRequest = new XSigSignOnBehalfRequest();
            signRequest._serviceId = (uint) serviceId;
            signRequest._authData = authData;            
            
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            WriteToSign(w);
            byte[] b = m.ToArray();
            SHA1 sha1 = new SHA1CryptoServiceProvider();
            signRequest._digest = sha1.ComputeHash(b);

            // Make a single byte array with all of the required data needed
            // for the signature server request.  Making just 1 Write call
            // to send the request data instead of 3 separate Write calls for
            // the individual components makes the thread less likely to get
            // interrupted in midstream and thus less susceptable to timeouts.
            byte[] requestData = (byte[]) signRequest;
            
            HResult hr = HResult.S_OK;
            
            try
            {
                WebRequest req = WebRequest.Create( _signUrl);
                req.Timeout = _xsigTimeout;
                req.Method = "POST";
                req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
                req.ContentLength = requestData.Length;
                
                Stream reqStream = req.GetRequestStream();
                w = new BinaryWriter(reqStream);
                w.Write(requestData);
                reqStream.Close();

                WebResponse resp = req.GetResponse();
                Stream respStream = resp.GetResponseStream();
                BinaryReader r = new BinaryReader(respStream);
                hr = r.ReadUInt32();
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: hr = " + hr);
                _signature = r.ReadBytes(ProtocolConstants.sizeSignature); //TODO: fix this
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: XSig returned signature: " + ByteConvert.ToString(_signature));
            }
            catch (Exception e)
            {
                if ( e is WebException )
                {
                    WebException we = ((WebException) e);
                    string xerr = "";
                    string responseText = "";
                    
                    if ( we.Response != null )
                    {
                        StreamReader sr = new StreamReader(we.Response.GetResponseStream());
                        responseText = sr.ReadToEnd();
                        
                        if ( we.Response.Headers != null )
                        {
                            xerr = we.Response.Headers["X-Err"];
                        }
                    }
                    
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + we + ", response: " + responseText);

                    if ( xerr != null && xerr != "" )
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: X-Err: " + xerr);
                        hr = HResult.Parse(xerr);
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SignOnBehalf: No X-Err header found.");
                        hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: caught exception: " + e);
                    hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                }
            }
            
            if ( HResult.Failed(hr) )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "SignOnBehalf: failed with hr = " + hr);
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_152, "SignOnBehalf: failed with hr = " + hr);
            }
        }

        public virtual uint SigningService
        {
            get
            {
                uint serviceId = BitConverter.ToUInt32(_signature, 4);
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "SigningService.get: signed on behalf of service: " + serviceId.ToString("x"));
                return serviceId;
            }
        }
    
        public virtual void VerifySignature()
        {
            VerifySignature((XOService)Int32.MinValue);
        }

        public virtual void VerifySignature(XOService serviceId)
        {
            MemoryStream m = new MemoryStream();
            BinaryWriter w = new BinaryWriter(m);
            WriteToSign(w);
            byte[] b = m.ToArray();
            SHA1 sha1 = new SHA1CryptoServiceProvider();
            byte[] digest = sha1.ComputeHash(b);
            
            HResult hr = HResult.E_FAIL;
            int expectedServiceId = (int) serviceId;
            
            try
            {
                // If serviceId == Int32.MinValue, then we don't care about
                // what service created the signature.
                if ( expectedServiceId != Int32.MinValue )
                {
                    // the service id that created the signature is stored as
                    // bytes 5-8 of the signature blob
                    uint actualServiceId = BitConverter.ToUInt32(_signature, 4);
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, String.Format("VerifySignature: expected service id: {0}, actual service id: {1}", expectedServiceId, actualServiceId));

                    // Check the service id that was included in the
                    // signature.
                    if ( actualServiceId != expectedServiceId )
                    {
                        throw new
                            XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_153,
                                String.Format("VerifySignature: expected service id: {0}, found service id: {1}", expectedServiceId, actualServiceId));
                    }

                    // Also check the service id that was included in the
                    // protocol request.
                    if ( _serviceId != expectedServiceId )
                    {
                        throw new
                            XRLException(HResult.XONLINE_E_STORAGE_INVALID_ACCESS_TOKEN, XEvent.Id.COMMON_CODE_154,
                                String.Format("VerifySignature: expected service id: {0}, protocol service id: {1}", expectedServiceId, _serviceId));
                    }
                }

                // Make a single byte array with all of the required data
                // needed for the signature server request.  Making just 1
                // Write call to send the request data instead of 2 separate
                // Write calls for the digest and signature makes the thread
                // less likely to get interrupted in midstream and thus less
                // susceptable to timeouts.
                byte[] requestData = new byte[digest.Length + _signature.Length];
                Array.Copy(digest, 0, requestData, 0, digest.Length);
                Array.Copy(_signature, 0, requestData, digest.Length, _signature.Length);

                WebRequest req = WebRequest.Create(_verifyUrl);
                req.Timeout = _xsigTimeout;
                req.Method = "POST";
                req.ContentType = "xon/" + ((int)XOService.Signature_Server).ToString("x");
                req.ContentLength = digest.Length + _signature.Length;
                
                Stream reqStream = req.GetRequestStream();
                w = new BinaryWriter(reqStream);
                w.Write(requestData);
                reqStream.Close();

                WebResponse resp = req.GetResponse();
                Stream respStream = resp.GetResponseStream();
                BinaryReader r = new BinaryReader(respStream);
                hr = r.ReadUInt32();
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: hr = " + hr);
            }
            catch (Exception e)
            {
                if ( e is WebException )
                {
                    WebException we = ((WebException) e);
                    string xerr = "";
                    string responseText = "";

                    if ( we.Response != null )
                    {
                        StreamReader sr = new StreamReader(we.Response.GetResponseStream());
                        responseText = sr.ReadToEnd();

                        if ( we.Response.Headers != null )
                        {
                            xerr = we.Response.Headers["X-Err"];
                        }
                    }
                    
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + we + ", response: " + responseText);
                    
                    if ( xerr != null && xerr != "" )
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: X-Err: " + xerr);
                        hr = HResult.Parse(xerr);

                        // We will log a security error event that contains the
                        // specific xerr from the signature server and all of
                        // the SGInfo associated with the request.
                        Xom.NtEvent(XEvent.Id.COMMON_HACK_7, we,
                            "AccessToken.VerifySignature: signature server returned hr = " + xerr
                        );
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "VerifySignature: No X-Err header found.");

                        if (we.Status == WebExceptionStatus.Timeout)
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_12, we, 
                               "AccessToken.VerifySignature: signature server timeout error; current timeout is " + _xsigTimeout + " ms.  " +
                               "Verify that the signature server is running and there is connectivity to STFD."
                            );
                        }
                        else
                        {
                            Xom.NtEvent(XEvent.Id.COMMON_COMM_13, we, 
                                "AccessToken.VerifySignature: failed to receive response from signature server."
                            );
                        }
                        hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: caught exception: " + e);
                    hr = HResult.XONLINE_E_ACCESS_TOKEN_ERROR;
                }
            }
            
            if ( HResult.Failed(hr) )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "VerifySignature: failed with hr = " + hr);
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_155, "VerifySignature: failed");
            }
        }
    
        public override string ToString()
        {
            return
                " _operation:"+((ushort)_operation)+
                " _version:"+_version+
                " _serviceId:0x"+_serviceId.ToString("X")+
                " _flags:"+_flags+
                " _userPuid:0x"+_userPuid.ToString("X")+
                " _xboxPuid:0x"+_xboxPuid.ToString("X")+
                " _pathNameSize:"+_pathNameSize+
                " _pathName:"+_pathName+
                " _signatureSize:"+_signatureSize+
                " _signature:"+(_signature!=null ? "(binary)" : "null");
        }
        
        public void SetAltSignUrl(
            string altSignUrl
        )
        {
            _altSignUrl = altSignUrl;
        }
    }

    public class ReadFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public ReadFileToken()
        {
        }
        
        public ReadFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }
        public override void Validate()
        {
            base.Validate();

            // TODO: there should be base class that ReadFileToken and EnumerateFilesToken derive from.  For now, let enumerate use ReadFileToken class
            if ( _operation != (ushort) Operation.FileRead && _operation != (ushort) Operation.FileEnumerate &&
                 _operation != (ushort) Operation.ReadTitleFiles)
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_156, 
                    "Validate: invalid operation: " + _operation);
            }

            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime() )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_157,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }

    public class WriteFileToken : AccessToken
    {
        public long _tokenExpirationDate;
        public long _fileExpirationDate;
        public uint _maxFileSize;

        public WriteFileToken()
        {
        }
        
        public WriteFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: tokenExpirationDate="+_tokenExpirationDate.ToString());
            _fileExpirationDate = r.ReadInt64();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: fileExpirationDate="+_fileExpirationDate.ToString());
            _maxFileSize = r.ReadUInt32();
            Xom.Trace(XomAreaName.atTrace, LogLevel.L_LOW, "WriteFileToken: ReadFrom: maxFileSize="+_maxFileSize.ToString());
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
            w.Write(_fileExpirationDate);
            w.Write(_maxFileSize);
        }

        protected override ushort SizeInternal()
        {
            return 20;
        }

        public override void Validate()
        {
            base.Validate();
            
            if ( _operation != (ushort) Operation.FileWrite )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_158, 
                    "Validate: invalid operation: " + _operation);
            }

            // DateTime.Now gives us localtime; calling ToFileTime() adds
            // UTC offset giving us a result that is the current time in UTC
            long now = DateTime.Now.ToFileTime();
            
            if ( _fileExpirationDate != 0 && _fileExpirationDate < now )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: fileExpirationDate is in the past.");
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_159,
                    "Validate: fileExpirationDate is in the past: " + _fileExpirationDate);
            }
            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < now )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_160,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }

        public override string ToString()
        {
            string baseString = base.ToString();
            return baseString +
                " _fileExpirationDate:" + 
                " _maxFileSize:"+_maxFileSize;
        }
    }
    
    public class RemoveFileToken : AccessToken
    {
        public long _tokenExpirationDate;

        public RemoveFileToken()
        {
        }
        
        public RemoveFileToken(BinaryReader r)
        {
            this.ReadFrom(r);
        }
        
        protected override void ReadFromInternal(BinaryReader r)
        {
            _tokenExpirationDate = r.ReadInt64();
        }

        protected override void WriteToInternal(BinaryWriter w)
        {
            w.Write(_tokenExpirationDate);
        }

        protected override ushort SizeInternal()
        {
            return 8;
        }
    
        public override void Validate()
        {
            base.Validate();
            
            if ( _operation != (ushort) Operation.FileRemove )
            {
                Xom.Trace(XomAreaName.atTrace, LogLevel.L_ERROR, "Validate: invalid operation: " + _operation);
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_161, 
                    "Validate: invalid operation: " + _operation);
            }
            if ( _tokenExpirationDate != 0 && _tokenExpirationDate < DateTime.Now.ToFileTime() )
            {
                throw new XRLException(
                    HResult.XONLINE_E_STORAGE_INVALID_REQUEST, XEvent.Id.COMMON_CODE_162,
                    "Validate: tokenExpirationDate is in the past: " + _tokenExpirationDate);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\Vortexbase.cs ===
using System;
using System.Reflection;
using System.Text;
using System.IO;
using System.Web;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Globalization;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.Linq;

using System.Data;
using System.Data.Sql;
using System.Data.SqlTypes;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using XRLLogBinary = ServerTestFramework.LiveService.StringServer.XRLLogBinary;
using xonline.common.config;
using xonline.common.core.etx;
using xonline.common.core.etx.extensions;
using xonline.common.service;
using xonline.common.utilities2;

namespace ServerTestFramework.LiveService.Vortex
{
#region Core base classes
    /// <summary>
    /// Daddy class that listens in to XomLog and accumulates logs in a List<string>.
    /// </summary>
    public class BaseXomListener
    {
        //public const string clickstreamQuery = "vxclickstreamcount";
        public const string eventTypeCountQuery = "VxEventTypeCountQuery";
        public const string passthroughQuery = "VxPassthroughQuery";
        static int _reqRefCount;
        protected static bool xomListening = false;
        private static List<string> incomingXomLogs = new List<string>();
        private static List<string> componentAreas = new List<string>();
        private static List<string> componentAreasStopped = new List<string>();        
        public static bool Logging { get; set; }

        static BaseXomListener()
        {
            Logging = true;
        }

        /// <summary>
        /// Returns a COPY!!!!!! We don't want anyone screwing with the original.
        /// </summary>
        protected static List<string> IncomingXomLogs
        {
            get
            {
                List<string> copyLogs;
                lock (incomingXomLogs)
                {
                    copyLogs = new List<string>(incomingXomLogs);
                }
            
                return copyLogs;
            }
        }

        public static int CachedLogCount
        {
            get
            {
                return IncomingXomLogs.Count;
            }
        }

        /// <summary>
        /// Starts listening to the XomLog remote.
        /// </summary>
        public static void StartXomListener(string component, string area, string interfaceVal)
        {
            string key = string.Format("{0}|{1}|{2}", component, area, interfaceVal);
            
            lock (componentAreas)
            {
                if (!componentAreas.Contains(key))
                {
                    IPEndPoint[] xmgmtIPs = ManagementListener.GetXmgmtEndPoints(interfaceVal);

                    foreach (IPEndPoint xmgmtIP in xmgmtIPs)
                    {                        
                        ManagementListener.Listen(xmgmtIP, component, area, Listener);
                        Log("Listening to vortexsvc::log on {0}", xmgmtIP);
                        xomListening = true;
                    }
                    componentAreas.Add(key);

                    if (componentAreasStopped.Contains(key))
                        componentAreasStopped.Remove(key);
                }
            }
        }       

        /// <summary>
        /// Stops listening to the XomLog remote.
        /// </summary>
        public static void StopXomListener(string component, string area, string interfaceVal)
        {
            string key = string.Format("{0}|{1}|{2}", component, area, interfaceVal);
            lock (componentAreas)
            {
                if (componentAreas.Contains(key))
                {
                    IPEndPoint[] xmgmtIPs = ManagementListener.GetXmgmtEndPoints(interfaceVal);

                    foreach (IPEndPoint xmgmtIP in xmgmtIPs)
                    {
                        ManagementListener.Stop(xmgmtIP, component, area, Listener);
                        Log("Listening to vortexsvc::log on {0}", xmgmtIP);
                    }                                                            

                    componentAreasStopped.Add(key);
                    componentAreas.Remove(key);

                    if (componentAreas.Count == 0)
                        xomListening = false;
                }                                
            }
        }

        /// <summary>
        /// Stops listening to the XomLog remote.
        /// </summary>
        public static void StopAllXomListeners()
        {
            lock (componentAreas)
            {
                string[] caCopy = componentAreas.ToArray();
                foreach (string ca in caCopy)
                {
                    string[] cas = ca.Split('|');
                    StopXomListener(cas[0], cas[1], cas[2]);
                }                
            }
        }
        /// <summary>
        /// Starts everything stopped by StopAllXomListeners()
        /// </summary>
        public static void RestartXomListeners()
        {
            lock (componentAreas)
            {
                string[] caCopy = componentAreasStopped.ToArray();
                componentAreasStopped.Clear();

                foreach (string ca in caCopy)
                {
                    string[] cas = ca.Split('|');
                    StartXomListener(cas[0], cas[1], cas[2]);
                }                
            }
        }       
        

        /// <summary>
        /// Used to add a dependency to the integrity of the incomingXomLogs cache. If something is using the object, we won't clear.
        /// </summary>
        public static int ReqRefCount
        {
            get { return _reqRefCount; }
            set
            {
                //Take advantage of the setter to clear logs.
                lock (incomingXomLogs)
                {
                    if (value > 0)
                        _reqRefCount = value;
                    else
                    {
                        _reqRefCount = 0;
                        incomingXomLogs.Clear();
                    }
                }
            }
        }

        /// <summary>
        /// Empties out the cache of logs that have been received.
        /// </summary>
        public static void FlushXomLogCache()
        {
            lock (incomingXomLogs)
            {
                incomingXomLogs.Clear();
            }
        }

        public static void Log(string val, params object[] args)
        {
            if (Logging)
            {
                if (args != null && args.Length > 0)
                    Global.RO.Debug(val, args);
                else
                    Global.RO.Debug(val);
            }
        }        

        /// <summary>
        /// Gets called whenever we receive a log.
        /// </summary>
        /// <param name="dgram"></param>
        public static void Listener(ManagementListener.Datagram dgram)
        {
            if (dgram != null)
            {
                Log(dgram.ToString());
            }
            else
            {
                Log("Dropping log, datagram was null.");
                return;
            }

            if (dgram.Text == null)
            {
                Log("Dropping log, see previous debug line.");
                return;
            }            

            lock (incomingXomLogs)
            {
                incomingXomLogs.Add(String.Format("{0}${1}${2}", DateTime.Now, dgram.Flowtoken, dgram.Text));
            }
        }

        /// <summary>
        /// Parses out the fields from the incoming xomlog. Moved out mainly to get
        /// ugly code out of the main methods.
        /// </summary>
        /// <param name="incomingString"></param>
        /// <param name="respTime"></param>
        /// <param name="payload"></param>
        public void ParseRemoteLog(string incomingString, out DateTime respTime, out String payload, out string flowToken)
        {
            string[] fields = incomingString.Split(new char[] {'$'}, 3);            
            
            respTime = DateTime.MinValue;
            DateTime.TryParse(fields[0], out respTime); //Arrival time.
            flowToken = fields[1];
            payload = fields[2];  //Actual log.                        
        }
    }

    /// <summary>
    /// Represents a high level log passing through vortex.
    /// </summary>
    public abstract class VortexLogBase : BaseXomListener
    {
        /// <summary>
        /// This is used for logging latency and for timing waits. Start it off with object creation time as a starting value.
        /// </summary>
        protected DateTime reqTime = DateTime.Now;
        private int queryWindow = 5000;
        protected bool foundMatch;
        protected string flowToken = "FT0";        
        bool validateNotProcessed = false;

        /// <summary>
        /// Long to hold the privacy Treatment flags that we are using
        /// </summary>
        private PrivacyTreatments privacyTreatment = PrivacyTreatments.PassThrough;

        /// <summary>
        /// Gets or sets the privacy treatment.
        /// </summary>
        /// <value>The privacy treatment.</value>
        public PrivacyTreatments PrivacyTreatment
        {
            get
            {
                return privacyTreatment;
            }
            set
            {
                privacyTreatment = value;
            }
        }

        /// <summary>
        /// Used to determine the maximum wait.
        /// </summary>
        public int QueryWindowMS
        {
            get
            {
                return queryWindow;
            }
            set
            {
                queryWindow = value;
            }
        }

        public string ExpectedResultOverride { get; set; }

        /// <summary>
        /// If this is set to true, validation checks that the item did not go through to processing.
        /// </summary>
        public bool ValidateNotProcessed
        {
            get
            {
                return validateNotProcessed;
            }
            set
            {
                validateNotProcessed = value;
            }
        }

        protected static Report ro = new Report("Vortex");

        public void CheckLogs(object logLine)
        {                  
            DateTime startTime = DateTime.Now;
            //Give it a shot 'tries' times with sleeps after every attempt of 1 second. Tries
            //is calculated by getting the number of tries needed to reach 1.25 times the query length.
            //This should give it enough time to outlast the worst case scenario, results
            //that span across 2 query windows.
            
            int sleepTime = 1000;
            int tries = (int)Math.Ceiling((((double)QueryWindowMS)*1.25d)/sleepTime);

            if (tries > 20) //Cap it at 20. Adjust sleeptime.
            {
                tries = 20;
                sleepTime = (int)((QueryWindowMS * 1.25) / 20);
            }

            for (int i = 0; i < tries; i++)
            {
                lock (IncomingXomLogs)
                {
                    //Standard for loop so I can keep track of the index and clean up afterwards.                        
                    for (int k = 0; k < IncomingXomLogs.Count; k++)
                    {
                        String payload;
                        DateTime respTime;
                        string flowToken;

                        ParseRemoteLog(IncomingXomLogs[k], out respTime, out payload, out flowToken);

                        if (CompareExpectedVsReceived(logLine, payload))
                        {
                            //Now compare flowtokens: 
                            if (flowToken != this.flowToken)
                                throw new Exception(String.Format("Flowtoken didn't match. Obtained:{0} Expected:{1}", flowToken, this.flowToken));
                            if (validateNotProcessed)
                                throw new Exception("Found the logline we didn't want! Check the logs.");
                            //Time spent waiting for this to be found.
                            TimeSpan timeSpent = DateTime.Now - respTime;
                            Log("Found my matching log!");
                            Log(String.Format("Log:{0}", payload));
                            Log(String.Format("It took {0} seconds for the response to go through vortex and get to the remote log target.", timeSpent.TotalSeconds));
                            foundMatch = true;
                            IncomingXomLogs.RemoveAt(0);
                            return;
                        }
                        else
                        {
                            if ((((DateTime.Now - (startTime)).TotalMilliseconds * 1.50) > (double)QueryWindowMS) && ValidateNotProcessed)
                            {
                                ro.Debug("Waited 1.5 times the query window and saw nothing on the pipeline.");
                                return;
                            }
                        }
                    }
                }

                ResetValidationState();
                AfterValidationFailure();
                Thread.Sleep(sleepTime);
            }
        }

        /// <summary>
        /// Actually does the validation by generating an expected logline and matching it to the server code.
        /// It calls GenerateExpectedLogLine and tries to match it to the incoming xom logs.
        /// </summary>
        public void Validate()
        {
            //Validation start
            DateTime valStart = DateTime.Now;

            string expectedLogLine = GenerateExpectedResult();
            if (ExpectedResultOverride != null)
                expectedLogLine = ExpectedResultOverride;
            foundMatch = false;
            if (validateNotProcessed)
                Log("Starting the search for the absence of the following log:");
            else
                Log("Starting the search for my matching log:");
            Log(expectedLogLine.ToString());            

            try
            {
                CheckLogs(expectedLogLine);
            }
            catch (ThreadAbortException)
            {
            }
            catch (Exception)
            {
                Log("Exception while trying to validate that the logline was passed through.");
                throw;
            }
            finally
            {
                if ((!foundMatch && !validateNotProcessed) || validateNotProcessed)
                {
                    ro.Debug("Dumping cache of received loglines."); ///@@@ probably should show only the ones in the time range of this test case.

                    ro.Debug("-------");
                    lock (IncomingXomLogs)
                    {
                        foreach (string str in IncomingXomLogs)
                        {
                            ro.Debug(str);
                        }
                    }
                    ro.Debug("-------");
                }
                else if (!validateNotProcessed)
                {
                    AfterValidationSuccess();
                }                
            }

            if (!foundMatch && !validateNotProcessed)            
                throw new Exception("Could not find a match for the generated logline. Possible culprit (batched cases might throw this off): \r\n" + expectedLogLine);            
        }

        protected virtual void SendRequestInternal()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Generates the content and sends the request.
        /// Starts the validation method.
        /// </summary>
        public void SendRequest(bool validate)
        {
            //Make sure we're tracking before we send out the request to avoid clearing out the incoming requests cache.
            if (validate)
                ReqRefCount++;

            try
            {
                reqTime = DateTime.Now;
                
                SendRequestInternal();

                if (validate)
                {
                    if (!xomListening)
                    {
                        ro.Warn("We can't validate if we're not listening for logs. Call VortexHTTP.StartRemoteListener() before using this class and StopRemoteListener() when you are done.");
                        throw new Exception("Test assembly tried to validate without listening for the data we need to validate.");
                    }
                    this.Validate();
                }
            }
            finally
            {
                if (validate)
                    ReqRefCount--;
            }
        }
        /// <summary>
        /// Generates the content and sends the request.
        /// Starts the validation method.
        /// </summary>
        public void SendRequest()
        {
            SendRequest(true);
        }

        /// <summary>
        /// Virtual method meant to be overriden by the derived classes. This will be called by clients and
        /// inside validation methods to generate an expected result to compare against the server result.
        /// </summary>
        /// <returns></returns>
        public virtual string GenerateExpectedResult()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Compares a payload received from the xom listener to the one generated by the class.
        /// </summary>
        /// <param name="generatedPayload"></param>
        /// <param name="serverPayload"></param>
        /// <returns></returns>
        public virtual bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            throw new NotImplementedException();
        }        

        /// <summary>
        /// Called after we try to validate and fail.
        /// </summary>
        public virtual void AfterValidationFailure()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Called after we try to validate and succeed. Do nothing by default.
        /// </summary>
        public virtual void AfterValidationSuccess()
        {            
        }

        /// <summary>
        /// Called whenever you're done with iterating over the incomingXomLogs so if you do some aggregation type of stuff,
        /// you can reset your state every time we iterate.
        /// </summary>
        public virtual void ResetValidationState()
        {
            //Do nothing
        }
    }

#endregion Core base classes

#region Base classes that define the type of data sent to vortex
    /// <summary>
    /// Stuff that goes in through string inputs. 
    /// </summary>
    public abstract class VortexStringInputBase : VortexLogBase
    {
        protected Dictionary<string, string> parameters;
        protected Dictionary<string, bool> filteredParams;        

        /// <summary>
        /// Initializes a Logstring2 object. Takes in the URL to use for the http requests. 
        /// </summary>        
        public VortexStringInputBase()
        {
            this.parameters = new Dictionary<string, string>();
            this.filteredParams = new Dictionary<string, bool>();
        }

        /// <summary>
        /// Generates parameters. They will follow the format XX=valueXX.
        /// </summary>
        /// <param name="additionalParameters"></param>
        public void GenerateParameters(int additionalParameters)
        {
            Random rand = new Random();
            int rangeMin = 1, rangeMax = 35;

            if (additionalParameters > rangeMax)
            {
                rangeMax = additionalParameters;
                //Just add them sequentially at this point...

                for (int k = 1; k <= additionalParameters; k++)
                {
                    if (parameters.ContainsKey(k.ToString()))
                        additionalParameters++; //skip and add one to the end.
                    else
                        parameters.Add(k.ToString(), String.Format("value{0}", k));
                }
            }
            else
            {
                for (int k = 1; k < additionalParameters; k++)
                {
                    int index = rand.Next(rangeMin, rangeMax);

                    while (parameters.ContainsKey(index.ToString()))
                    {
                        index = (index + 1) % (rangeMax + 1); // If I go over the max roll over 
                        if (index == 0) //I HATE ZEROES ok not really we usually start from 1 on the logs
                            index++;
                    }
                    parameters.Add(index.ToString(), String.Format("value{0}", index));
                }
            }
        }

        /// <summary>
        /// Adds or updates a parameter using a straight mapping to an int to identify the field.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(string type, string value)
        {
            AddUpdateParameter(type, value, false);
        }

        /// <summary>
        /// Adds or updates a parameter. If it's filtered it won't show up on the expected output.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(string type, string value, bool filtered)
        {
            if (parameters.ContainsKey(type))
                parameters[type] = value;
            else
                parameters.Add(type, value);

            if (filteredParams.ContainsKey(type))
                filteredParams[type] = filtered;
            else
                filteredParams.Add(type, filtered);
        }

        /// <summary>
        /// Adds or updates a parameter. Converts the int into a string.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(int type, string value)
        {
            AddUpdateParameter(type.ToString(), value, false);
        }

        /// <summary>
        /// Adds or updates a parameter using a straight mapping to an int to identify the field.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(int type, string value, bool filtered)
        {
            AddUpdateParameter(type.ToString(), value, filtered);
        }

        /// <summary>
        /// Starts over on the params.
        /// </summary>
        public void ClearParameters()
        {
            parameters.Clear();
            filteredParams.Clear();
        }

    }

    /// <summary>
    /// Stuff that goes in through Vortex protocol stream input.
    /// </summary>
    public abstract class VortexProtocolInputBase : VortexLogBase
    {        
        private static bool verifyCleanser = true;
        protected VortexEtxMessage customMessage = null;
        protected VortexEtxMessage sentMessage;        
        protected int runningCount;
        protected Dictionary<uint, List<VortexEtxField>> parameters;
        protected Dictionary<uint, List<VortexEtxField>> headerValues;
        protected uint defaultHeaderVersion = 2;
        protected byte[] customContent = null;
        public static Dictionary<uint, Event> HeaderDefinitions = new Dictionary<uint,Event>();
        public EtxManifest etxEventManifest;
        public EtxManifest EtxEventManifest 
        {
            get
            { 
                return etxEventManifest; 
            }
            set
            {
                etxEventManifest = CloneManifest(value);                                
                foreach (Producer p in etxEventManifest.Producers)
                    foreach (Event e in p.Events)
                    {
                        e.HeaderFields.Clear();
                        if (HeaderDefinitions.ContainsKey(e.HeaderVersion))
                        {
                            e.HeaderFields.AddRange(HeaderDefinitions[e.HeaderVersion].DataFields);
                        }
                        else if (e.HeaderVersion == 0)
                        {
                            e.HeaderFields.AddRange(HeaderDefinitions[defaultHeaderVersion].DataFields);
                            e.HeaderVersion = (byte)defaultHeaderVersion;
                        }
                    }
            }
        }

        public static bool VerifyCleanser
        {
            get
            {
                return verifyCleanser;
            }
            set
            {
                verifyCleanser = value;
            }
        }

        public string[] ExpectedResultOverrides { get; set; }
        public VortexEtxMessage SentMessage { get { return sentMessage; } }
        protected bool SGInfoAvailable = false;
        protected bool AAInfoAvailable = false;

        /// <summary>
        /// The content of the UDP message.
        /// </summary>
        public VortexEtxMessage CustomMessage
        {
            get { return customMessage; }
            set { customMessage = value; }
        }

        public byte[] ProducerID
        {
            get;
            set;
        }

        /// <summary>
        /// The content of the HTTP request.
        /// </summary>
        public byte[] CustomContent
        {
            get { return customContent; }
            set { customContent = value; }
        }

        /// <summary>
        /// Initializes a Logstring2 object. Takes in the URL to use for the http requests. 
        /// </summary>        
        public VortexProtocolInputBase()
        {
            this.parameters = new Dictionary<uint, List<VortexEtxField>>();
            this.headerValues = new Dictionary<uint, List<VortexEtxField>>();
            this.ProducerID = new byte[] { (byte)0 };            
        }
        /// <summary>
        /// Static konstructor.
        /// </summary>
        static VortexProtocolInputBase()
        {
            HeaderDefinitions = new Dictionary<uint, Event>();
            GetServerHeaders();
        }    

        /// <summary>
        /// Adds or updates a parameter. If it's filtered it won't show up on the expected output.
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(VortexEtxField value)
        {
            AddUpdateParameter(0, value);
        }

        /// <summary>
        /// Adds or updates a parameter. 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(uint eventOrdinal, VortexEtxField value)
        {
            if (parameters.ContainsKey(eventOrdinal))
                parameters[eventOrdinal].Add(value);
            else
                parameters.Add(eventOrdinal, new List<VortexEtxField>(new VortexEtxField[] { value }));
            
        }

        /// <summary>
        /// Adds or updates a parameter. 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateHeaderValue(uint eventId, VortexEtxField value)
        {
            if (headerValues.ContainsKey(eventId))
            {
                for (int k = 0; k < headerValues[eventId].Count; k++)
                {
                    if (headerValues[eventId][k].FieldId == value.FieldId)
                        return;
                }

                headerValues[eventId].Add(value);
            }
            else
                headerValues.Add(eventId, new List<VortexEtxField>(new VortexEtxField[] { value }));
        }

        /// <summary>
        /// Adds or updates a parameter. 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(uint eventOrdinal, EtxFieldType type, uint ordinal, object value)
        {
            VortexEtxField field = new VortexEtxField(type, ordinal, value);
            AddUpdateParameter(eventOrdinal, field);
        }

        /// <summary>
        /// Adds or updates a parameter. 
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(EtxFieldType type, uint ordinal, object value)
        {
            AddUpdateParameter(0, type, ordinal, value);
        }

        /// <summary>
        /// Starts over on the params.
        /// </summary>
        public void ClearParameters()
        {
            parameters.Clear();
        }
       
        //For a given producer (assumed to be stored by the test class' manifest)
        //Generate data matching each datatype, outType, and autovalue.
        public void GenerateDataForManifestProducer(Producer p)
        {            
            foreach (Event e in p.Events)
            {
                this.ProducerID = p.Fingerprint;

                foreach (DataField df in e.DataFields)
                {
                    EtxFieldType fieldType;
                    object data;
                    GenerateData(df, out fieldType, out data);
                    if (df.AutoValue != null && df.AutoValueCreator != null && df.AutoValueCreator == AutoValueCreators.LiveService)
                    {
                        if (df.AutoValueCreator != null)
                        {
                            if (df.AutoValue == AutoValues.LogStringId)
                                data = (e.LogStringId == null) ? e.Symbol : e.LogStringId;
                            this.AddUpdateParameter(e.Ordinal, EtxFieldType.AutovalueWrapper, df.Ordinal, new AutoValueTestHelper(df.AutoValue ?? AutoValues.WebRepGroupId, null, data));
                        }
                    }
                    else
                    {
                        if (df.Name.Contains("SPECIALFIELD"))
                            this.AddUpdateParameter(e.Ordinal, new VortexEtxField(EtxFieldType.Special, df.Ordinal, new VortexEtxField(EtxFieldType.String, VortexEtxEvent.LOGSTRINGID_ORDINAL, data )));
                        else
                            this.AddUpdateParameter(e.Ordinal, fieldType, df.Ordinal, data);
                    }
                }

                if (e.HeaderVersion == 0)
                    e.HeaderVersion = 2;

                if (VortexHTTPBinary.HeaderDefinitions.ContainsKey(e.HeaderVersion))
                {
                    Event header = VortexHTTPBinary.HeaderDefinitions[e.HeaderVersion];
                    foreach (DataField df in header.DataFields)
                    {
                        EtxFieldType fieldType;
                        object data;
                        GenerateData(df, out fieldType, out data);
                        if (df.AutoValue != null && df.AutoValueCreator != null && df.AutoValueCreator == AutoValueCreators.LiveService)
                        {
                            if (df.AutoValueCreator != null)
                            {
                                if (df.AutoValue == AutoValues.LogStringId)
                                    data = (e.LogStringId == null) ? e.Symbol : e.LogStringId;
                                this.AddUpdateHeaderValue(e.Ordinal, new VortexEtxField(EtxFieldType.AutovalueWrapper, df.Ordinal, new AutoValueTestHelper(df.AutoValue ?? AutoValues.WebRepGroupId, null, data)));
                            }
                        }
                        else
                            this.AddUpdateHeaderValue(e.Ordinal, new VortexEtxField(EtxFieldType.AutovalueWrapper, df.Ordinal, new AutoValueTestHelper(null, string.Empty, null)));
                    }
                }
            }
            
        }
        public string[] GenerateExpectedStrings()
        {            
            List<string> list = new List<string>();

            if (ExpectedResultOverrides != null)
                return ExpectedResultOverrides;
            
            if (sentMessage != null)
            {
                foreach (VortexEtxEvent evt in sentMessage.Batch.Events)
                {                    
                    evt.EventManifest = EtxEventManifest;

                    if (this.PrivacyTreatment == PrivacyTreatments.PassThrough)
                    {
                        string evtString = evt.ToString();
                        list.Add(evtString);
                    }

                    if (0 != (this.PrivacyTreatment & PrivacyTreatments.LBI))
                    {
                        string evtString = evt.ToString(PrivacyTreatments.LBI);
                        list.Add(evtString);
                    }

                    if (0 != (this.PrivacyTreatment & PrivacyTreatments.MBI))
                    {
                        string evtString = evt.ToString(PrivacyTreatments.MBI);
                        list.Add(evtString);
                    }
                }
                ExpectedResultOverrides = list.ToArray(); //For test perf do this once
            }
            else
                ExpectedResultOverrides = new string[] { };

            return ExpectedResultOverrides;
        }
        
        List<String> foundStrings = new List<String>();
        public bool CompareExpectedVsReceived(string serverPayload)
        {
            string[] expectedStrings = GenerateExpectedStrings();
            foreach (string s in expectedStrings)
            {
                if (!foundStrings.Contains(s) && s == serverPayload)
                {
                    Global.RO.Debug("Match:{0}", serverPayload);
                    runningCount++;
                    foundStrings.Add(s);
                    break;
                }
            }            

            //If we actually found an exact count, return found.
            int expectedCount = (sentMessage != null) ? sentMessage.Batch.Events.Count : expectedStrings.Length;
            if (runningCount == expectedCount && (runningCount != 0))
                return true;

            return false;
        }

        public void ClearParametersAndHeaders()
        {
            this.parameters.Clear();
            this.headerValues.Clear();
        }

        public byte[] BuildContent()
        {
            
            VortexEtxMessage message;
            if (CustomContent != null)                            
                return CustomContent;            
            else if (CustomMessage != null)            
                message = CustomMessage;            
            else
            {
                VortexEtxEventBatch etxEventBatch = new VortexEtxEventBatch();
                foreach (uint key in parameters.Keys)
                {
                    VortexEtxEvent etxEvent = new VortexEtxEvent(parameters[key], ProducerID, (uint)key);
                    etxEventBatch.AddEvent(etxEvent);
                }                

                message = new VortexEtxMessage(etxEventBatch, VortexProtocolType.DistMon);                
            }

            sentMessage = message;


            //Add headers
            foreach (VortexEtxEvent etxEvent in message.Batch.Events)
            {
                etxEvent.EventManifest = EtxEventManifest;
                if (headerValues.ContainsKey(etxEvent.EventId))
                    etxEvent.HeaderFields.AddRange(headerValues[etxEvent.EventId]);
                else
                {
                    Event h = HeaderDefinitions[3];

                    EtxFieldType fieldType;
                    object data;
                    foreach (DataField df in h.DataFields)
                    {
                        GenerateData(df, out fieldType, out data);
                        if (df.AutoValue != null && df.AutoValueCreator != null && df.AutoValueCreator == AutoValueCreators.LiveService)
                        {
                            if (df.AutoValueCreator != null)
                            {
                                if (df.AutoValue == AutoValues.LogStringId)
                                    data = etxEvent.GetLogstringId();
                                AddUpdateHeaderValue(etxEvent.EventId, new VortexEtxField(EtxFieldType.AutovalueWrapper, df.Ordinal, new AutoValueTestHelper(df.AutoValue ?? AutoValues.WebRepGroupId, null, data)));
                            }
                        }
                    }
                    etxEvent.HeaderFields.AddRange(headerValues[etxEvent.EventId]);
                }
            }
            headerValues.Clear();


            return message.ToArray();
        }

        public override void AfterValidationSuccess()
        {
            //Let's look at the cleanser!!
            ValidateCleanserFiles();
            
            //Reverting perf optimization
            ExpectedResultOverrides = null;
            ExpectedResultOverride = null;
            Global.RO.Info("Clearing out expected result overrides after validation success.");
        }
        /// <summary>
        /// Checks for both files that match the ETX manifest event fingerprint, and the manifest definition itself.
        /// </summary>
        private void ValidateCleanserFiles()
        {
            if (this.EtxEventManifest != null && verifyCleanser)
            {
                IPEndPoint[] ipEps = ManagementListener.GetXmgmtEndPoints(Interface.cleanser);
                Dictionary<VortexEtxEvent, bool> foundDict = new Dictionary<VortexEtxEvent, bool>();

                //Try 5 times in 10 seconds. It better be there by then.
                for (int k = 0; k < 5; k++)
                {
                    if (k != 0)
                        Thread.Sleep(2000);

                    foreach (IPEndPoint ipEp in ipEps)
                    {
                        string approot = Global.XEnv.GetSetting("setup_logroot");
                        string baseConfigPath = String.Format("\\\\{0}\\{1}\\app\\cleanser\\data", ipEp.Address, approot.Replace(":", "$"));
                        DateTime now = DateTime.UtcNow;
                        string nowPath = String.Format("{0}\\{1}\\{2}", now.Year, now.Month, now.Day);

                        foreach (VortexEtxEvent evt in sentMessage.Batch.Events)
                        {
                            if (!foundDict.ContainsKey(evt))
                                foundDict.Add(evt, false);
                            List<string> logStringIds = new List<string>();
                            if (PrivacyTreatment == PrivacyTreatments.PassThrough)
                            {
                                logStringIds.Add(evt.GetLogstringId());
                            }

                            if (0 != (PrivacyTreatment & PrivacyTreatments.LBI))
                            {
                                logStringIds.Add("LBI-" + evt.GetLogstringId());
                            }
                            
                            if (0 != (PrivacyTreatment & PrivacyTreatments.MBI))
                            {
                                logStringIds.Add("MBI-" + evt.GetLogstringId());
                            }

                            //MASKING A "BUG" - work in progress on dev side. This will be configurable in a later test checkin.
                            //Event e = ApplyHeaders(evt.EventManifest.GetEventByOrdinal(evt.ProducerId, evt.EventId));
                            Event e = evt.EventManifest.GetEventByOrdinal(evt.ProducerId, evt.EventId);

                            foreach (string logstringId in logStringIds)
                            {
                                string definitionPath = String.Format("{0}\\{1}\\{2}-{3}.etx.xml", baseConfigPath, logstringId, e.Fingerprint, (HeaderDefinitions.ContainsKey(e.HeaderVersion) ? e.HeaderVersion : 0));
                                string logfilesPath = String.Format("{0}\\{1}\\{2}", baseConfigPath, logstringId, nowPath);

                                try
                                {
                                    if (!File.Exists(definitionPath))
                                    {
                                        Global.RO.Info("Could not find the definition file for this manifest. Looking for:" + definitionPath);
                                    }
                                    else
                                    {
                                        Producer dummyProducer = new Producer("dummy", Blob.Parse("00"));
                                        string text = File.ReadAllText(definitionPath);
                                        Event innerE = new Event(XElement.Parse(text));
                                        if (!e.Equals(innerE))
                                        {
                                            Global.RO.Info("The manifest saved and the one in the test weren't the same! Looking for event with symbol:" + e.Symbol + " and producer id:" + ((Blob)evt.ProducerId) + "in file:" + definitionPath);
                                        }
                                    }

                                    if (!Directory.Exists(logfilesPath))
                                    {
                                        Global.RO.Info("Uhhh this directory should totally exist. Something's wrong. Looking for:" + logfilesPath);
                                    }
                                    else
                                    {
                                        DirectoryInfo di = new DirectoryInfo(logfilesPath);
                                        FileInfo[] files = di.GetFiles(String.Format("*{0}-{1}*", e.Fingerprint, (HeaderDefinitions.ContainsKey(e.HeaderVersion) ? e.HeaderVersion : 0)));

                                        if (files.Length == 0)
                                        {
                                            Global.RO.Info("This directory should have files that match the event fingerprint!!! Whaaat! Directory:" + logfilesPath);
                                        }
                                        else
                                        {
                                            foundDict[evt] = true;
                                        }
                                    }

                                }
                                catch (Exception)
                                {
                                    //File handle might still be open let the cleanser finish.
                                    Global.RO.Info("Retrying search. Reasons for a legitimate retry are probably related to the tests outrunning the cleanser. (Handle not released, folder not created, file not created)");
                                }
                            }
                        }                        
                    }
                    
                    foreach (VortexEtxEvent e in sentMessage.Batch.Events)
                    {
                        if (foundDict[e] == false) //Find at least one of each.
                            break;
                        return;
                    }
                }

                foreach (VortexEtxEvent e in sentMessage.Batch.Events)
                {
                    if (foundDict[e] == false) //Find at least one of each.
                        throw new Exception("Failed to find an event manifest or a well named cleanser log file. Review the test case's logs to figure out which one triggered the failure. Unfortunately it may not be immediately obvious where the problem occured if we're in an expended environment (which one really got the logline???).");
                }
            }
        }     

        public static void GetServerHeaders()
        {
            string sqlCmd = "p_etx_get_event_headers";

            string connStr = Config.GetSingleInterface(Interface.npdb).SqlConnectionString;

            using (SqlConnection sql = new SqlConnection(connStr))
            {
                sql.Open();

                using (SqlCommand cmd = new SqlCommand(sqlCmd, sql))
                {
                    cmd.CommandType = CommandType.Text;
                    SqlDataReader s = cmd.ExecuteReader();

                    while (s.Read())
                    {                        
                        Event h = new Event(XElement.Parse((string)s[6]));
                        HeaderDefinitions.Add(h.Value, h);
                    }
                }
            }
        }

        /// <summary>
        /// Just generates data for each datatype.
        /// </summary>
        /// <param name="inType"></param>
        /// <param name="outType"></param>
        /// <param name="data"></param>
        public void GenerateData(DataField df, out EtxFieldType outType, out object data)
        {
            DataFieldType inType = GetNativeAutovalueType(df);
            data = null;
            switch (inType)
            {
                case DataFieldType.UnicodeString:
                    outType = EtxFieldType.String;
                    VortexUtil.RandomUnicodeString str = new VortexUtil.RandomUnicodeString();
                    data = str.GetString(5);
                    break;
                case DataFieldType.AnsiString:
                    outType = EtxFieldType.String;
                    data = "TestString Replace me!";
                    break;
                case DataFieldType.Binary:
                    outType = EtxFieldType.Blob;
                    //Let's check for values that need to be of certain sizes to be valid. 
                    if (df.OutType == OutputType.ConsoleId)
                        data = new byte[] { 0x05, 0x35, 0xbd, 0xa5, 0xe8 }; //Ian's console id to make the output recognizable.
                    //data = VortexUtil.GenerateRandomBlob(5);
                    else if (df.OutType == OutputType.Ipv4Address)
                        data = VortexUtil.GenerateRandomBlob(4);
                    else
                        data = VortexUtil.GenerateRandomBlob(16);
                    break;
                case DataFieldType.Double:
                    outType = EtxFieldType.Double;
                    data = Double.MaxValue;
                    break;
                case DataFieldType.Float:
                    outType = EtxFieldType.Single;
                    data = float.MaxValue;
                    break;
                case DataFieldType.Int16:
                    outType = EtxFieldType.SVarInt;
                    data = Int16.MaxValue;
                    break;
                case DataFieldType.Int32:
                    outType = EtxFieldType.SVarInt;
                    data = Int32.MaxValue/4;
                    break;
                case DataFieldType.Int64:
                    outType = EtxFieldType.SVarInt;
                    data = DateTime.Now.ToFileTimeUtc(); //Convenient for certain tests :)
                    break;
                case DataFieldType.Int8:
                    outType = EtxFieldType.SVarInt;
                    data = sbyte.MaxValue;
                    break;
                case DataFieldType.UInt16:
                    outType = EtxFieldType.VarInt;
                    data = UInt16.MaxValue;
                    break;
                case DataFieldType.UInt32:
                    outType = EtxFieldType.VarInt;
                    data = (UInt32)270544960; //Just like it for IP addresses
                    if (df.OutType == OutputType.HResult)
                        data = (UInt32)0x8015B00B;
                    break;
                case DataFieldType.UInt64:
                    outType = EtxFieldType.VarInt;
                    //data = (ulong)DateTime.Now.ToFileTimeUtc(); //Convenient for certain tests :)
                    data = (ulong)0x0B4A720c22;
                    break;
                case DataFieldType.UInt8:
                    outType = EtxFieldType.VarInt;
                    data = byte.MaxValue;
                    break;
                case DataFieldType.GUID:
                    outType = EtxFieldType.Guid;
                    data = Guid.NewGuid();
                    break;
                default:
                    outType = EtxFieldType.String;
                    break;
            }
        }

        public DataFieldType GetNativeAutovalueType(DataField df)
        {
            DataFieldType returnType = df.InType;
            if (df.AutoValue != null && df.AutoValueCreator != null && df.AutoValueCreator == AutoValueCreators.LiveService)
            {
                switch (df.AutoValue)
                {
                    case AutoValues.CountryId:
                    case AutoValues.MembershipType:
                    case AutoValues.LanguageId:
                        returnType = DataFieldType.UInt8;
                        break;
                    default:
                        returnType = df.InType;
                        break;

                }
            }
            return returnType;
        }

        public static EtxManifest CloneManifest(EtxManifest man)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(EtxManifest));
            MemoryStream ms = new MemoryStream();
            serializer.Serialize(ms, man);
            ms.Position = 0;
            XmlReader reader = XmlReader.Create(ms);
            return new EtxManifest(reader);
        }

    }    
#endregion  

#region Base classes that define the input listener the data is sent to.
    /// <summary>
    /// Represents an HTTP request sent to vortex
    /// </summary>
    public abstract class VortexHTTPString : VortexStringInputBase
    {
        protected string customQS;
        protected bool fKeepAlive = false;
        protected string method = "GET";
        protected string customContent = null;
        protected string reqUrl;
        
        private bool useXrl = false;    

        #region Public properties
        /// <summary>
        /// The content of the HTTP request.
        /// </summary>
        public String CustomContent
        {
            get { return customContent; }
            set { customContent = value; }
        }

        /// <summary>
        /// Send the request using an XRL object.
        /// </summary>
        public bool UseXRL
        {
            get { return useXrl; }
            set { useXrl = value; }
        }

        /// <summary>
        /// Custom query string. Overrides any parameters or any of that crap.
        /// </summary>
        public String CustomQS
        {
            get { return customQS; }
            set { customQS = value; }
        }

        /// <summary>
        /// The method of the HTTP request. (i.e. GET)
        /// </summary>
        public String Method
        {
            get { return method; }
            set { method = value; }
        }

        /// <summary>
        /// Used for the HTTP request.
        /// </summary>
        public bool KeepAlive
        {
            get { return fKeepAlive; }
            set { fKeepAlive = value; }
        }

        /// <summary>
        /// URL to hit in the HTTP request.
        /// </summary>
        public String RequestURL
        {
            get { return reqUrl; }
            set { reqUrl = value; }
        }

        #endregion Public properties

        /// <summary>
        /// Initializes a Logstring2 object. Takes in the URL to use for the http requests. 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="category"></param>
        /// <param name="timeStamp"></param>
        public VortexHTTPString(string url)
        {
            this.reqUrl = url;
        }

        protected override void SendRequestInternal()
        {
            if (useXrl)
                SendXRLRequest();
            else
                SendHTTPRequest();
        }

        private void SendHTTPRequest()
        {
            String reqUrl = GetRequestURL();
            reqTime = DateTime.Now;

            string content = BuildContent();
            VortexUtil.PostRequest(reqUrl, method, VortexUtil.StringToBytes(content), fKeepAlive);
        }
        protected virtual void SendXRLRequest()
        {
            throw new Exception("Not implemented.");            
        }        

        /// <summary>
        /// Returns the URL + query string that would be used to hit the server.
        /// </summary>
        /// <returns></returns>
        public string GetRequestURL()
        {
            StringBuilder url = new StringBuilder(reqUrl);
            url.Append(BuildQueryString());

            return url.ToString();
        }

        /// <summary>
        /// Uses the parameters dictionary to generate a query string, and post it to the reqUrl using TCP haxorz
        /// </summary>
        /// <param name="ep"></param>
        /// <param name="fReadResponse"></param>
        public void SendRequestFast(IPEndPoint ep, bool fReadResponse)
        {
            String queryString = BuildQueryString();
            String content = BuildContent();

            VortexUtil.PostRequestFast(ep, String.Format("{0}{1}", reqUrl, queryString), method, VortexUtil.StringToBytes(content), fKeepAlive);
        }

        /// <summary>
        /// Generates the query string.
        /// </summary>
        /// <returns></returns>
        public virtual string BuildQueryString()
        {
            if (!String.IsNullOrEmpty(customQS))
                return customQS;
            else
                return string.Empty;
        }

        public virtual string BuildContent()
        {
            if (!String.IsNullOrEmpty(CustomContent))
                return CustomContent;
            else
                return null;
        }

        /// <summary>
        /// In StreamInsight, we have a set window for our histogram query. This method will sleep for the required time + 1 second, then trigger a CTI event.
        /// to flush out the logs.
        /// </summary>
        public override void  AfterValidationFailure()
        {            
            //Trigger a CTI
            /*CTIs don't exist without StreamInsight.	    
            string flushUrl = reqUrl.Substring(0, reqUrl.LastIndexOf("/")) + "/logstring2.ashx?v1=CTIFLUSH"; //Kinda hacky... transforms the reqUrl into logstring2 and posts
            VortexUtil.PostRequest(flushUrl, "GET", null, false);
            */
        }
    }

    /// <summary>
    /// Vortex UDP listener + Vortex protocol stream
    /// </summary>
    public class VortexUDPBinary : VortexProtocolInputBase
    {           
        protected string virtualInterface;        

        bool useDirect = false;        

        IVxTransport transport;        

        #region Public properties

        public bool UseDirect
        {
            get { return useDirect; }
            set 
            {                
                if (value)
                    transport = new DirectUdpTransport(virtualInterface);
                else
                    transport = new SgUdpTransport(virtualInterface);

                useDirect = value;
            }
        }

        #endregion Public properties

        /// <summary>
        /// Initializes a UDP object. 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="category"></param>
        /// <param name="timeStamp"></param>
        public VortexUDPBinary(string virtualInterface)
        {
            this.virtualInterface = virtualInterface;
            if (this.virtualInterface == null)
            {
                throw new ArgumentNullException("virtualInterface", "VirtualInterface not specified!");
            }

            if (useDirect)
                transport = new DirectUdpTransport(virtualInterface);
            else
                transport = new SgUdpTransport(virtualInterface);
        }

        public void ResetTransport()
        {
            if (useDirect)
                transport = new DirectUdpTransport(virtualInterface);
            else
                transport = new SgUdpTransport(virtualInterface);
        }

        protected override void SendRequestInternal()
        {
            byte[] message = BuildMessage();
            transport.Send(message);

            if ((transport is SgUdpTransport))
            {
                ulong nonce = ((SgUdpTransport)transport).NonceValue;
                foreach (VortexEtxEvent evt in sentMessage.Batch.Events)
                    evt.nonce = nonce;
                this.SGInfoAvailable = true;
            }
            else
            {
                foreach (VortexEtxEvent evt in sentMessage.Batch.Events)
                    evt.nonce = 0;
                SGInfoAvailable = false;
            }
        }

        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)serverPayload);
        }
        
        public override void AfterValidationFailure()
        {
            /* No StreamInsight
            VortexUDPBinary flusher = new VortexUDPBinary(virtualInterface);
            flusher.UseDirect = true;
            flusher.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, 0, 7401667));
            flusher.SendRequest(false); //VERY IMPORTANT TO SAY FALSE THANKS.
            runningCount = 0;
             */
        }
        public override string GenerateExpectedResult()
        {
            runningCount = 0; //We'll do comparisons soon after a generate...
            string[] outStrs = this.GenerateExpectedStrings();
            string outBuf = String.Empty;

            foreach (string s in outStrs)
            {
                outBuf += s + "\r\n";
            }
            return outBuf; //Not really used.
        }
        public byte[] BuildMessage()
        {
            return BuildContent();
	}
    }

    /// <summary>
    /// Vortex UDP listener + Vortex protocol stream
    /// </summary>
    public class VortexUDPBinaryXRL : VortexProtocolInputBase
    {           
        private bool setSGInfo = true;
        private string reqUrl;
        #region Public properties
               
        /// <summary>
        /// URL to hit in the HTTP request.
        /// </summary>
        public string RequestURL
        {
            get { return reqUrl; }
            set { reqUrl = value; }
        }
                
        /// <summary>
        /// Set or don't set SGInfo into the fakesg.
        /// </summary>
        public bool SetSGInfo
        {
            get { return setSGInfo; }
            set
            {
                SGInfoAvailable = value;
                setSGInfo = value;
            }
        }
        
        #endregion Public properties

        /// <summary>
        /// Initializes a VortexHTTPBinary object. Takes in the URL to use for the http requests. 
        /// </summary>
        /// <param name="url"></param>        
        public VortexUDPBinaryXRL(string url)
        {
            this.reqUrl = url;
            this.SGInfoAvailable = true;
        }

        protected override void SendRequestInternal()
        {
            SendXRLRequest();            
        }        

        protected virtual void SendXRLRequest()
        {
            XRLLogBinaryVortex binaryReq = new XRLLogBinaryVortex();
            binaryReq.transport=FDTransaction.Transports.UDP;

            binaryReq.IgnoreUDPReceive = true;
	    binaryReq.SetHttpHeader = false;
            binaryReq.logBytes = BuildContent();
            binaryReq.logBytesLength = binaryReq.logBytes.Length;
            binaryReq.message = sentMessage;
            if (SetSGInfo)
                binaryReq.ManualPopulateSlot();

            binaryReq.Execute();
        }        

        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)serverPayload);
        }

        public override void AfterValidationFailure()
        {            
        }

        public override string GenerateExpectedResult()
        {
            runningCount = 0; //We'll do comparisons soon after a generate...
            string[] outStrs = this.GenerateExpectedStrings();
            string outBuf = String.Empty;

            foreach (string s in outStrs)
            {
                outBuf += s + "\r\n";
            }
            return outBuf; //Not really used.
        }


    }

    /// <summary>
    /// Vortex UDP listener + Vortex protocol stream
    /// </summary>
    public class VortexHTTPBinary : VortexProtocolInputBase
    {
        protected string customQS;
        protected bool fKeepAlive = false;
        protected string method = "POST";        
        protected string reqUrl;        
        private bool useXrl = true;
        private bool setSGInfo = true;
        private bool setAAInfo = true;
        #region Public properties        
        
        /// <summary>
        /// Custom query string. Overrides any parameters or any of that crap.
        /// </summary>
        public String CustomQS
        {
            get { return customQS; }
            set { customQS = value; }
        }

        /// <summary>
        /// The method of the HTTP request. (i.e. GET)
        /// </summary>
        public String Method
        {
            get { return method; }
            set { method = value; }
        }

        /// <summary>
        /// Used for the HTTP request.
        /// </summary>
        public bool KeepAlive
        {
            get { return fKeepAlive; }
            set { fKeepAlive = value; }
        }

        /// <summary>
        /// URL to hit in the HTTP request.
        /// </summary>
        public string RequestURL
        {
            get { return reqUrl; }
            set { reqUrl = value; }
        }

        /// <summary>
        /// Set or don't set AAInfo in the request header.
        /// </summary>
        public bool SetAAInfo
        {
            get { return setAAInfo; }
            set 
            {
                AAInfoAvailable = value;
                setAAInfo = value; 
            }
        }

        /// <summary>
        /// Set or don't set SGInfo into the fakesg.
        /// </summary>
        public bool SetSGInfo
        {
            get { return setSGInfo; }
            set 
            {
                SGInfoAvailable = value;
                setSGInfo = value; 
            }
        }

        /// <summary>
        /// Use the XRL object or just call directly.
        /// </summary>
        public bool UseXRL
        {
            get { return useXrl; }
            set { useXrl = value; }
        }
        #endregion Public properties

        /// <summary>
        /// Initializes a VortexHTTPBinary object. Takes in the URL to use for the http requests. 
        /// </summary>
        /// <param name="url"></param>        
        public VortexHTTPBinary(string url)
        {
            this.reqUrl = url;
            this.SGInfoAvailable = true;
        }        

        protected override void SendRequestInternal()
        {
            if (useXrl)
                SendXRLRequest();
            else
                SendHTTPRequest();
        }

        private void SendHTTPRequest()
        {
            String reqUrl = GetRequestURL();
            reqTime = DateTime.Now;

            byte[] content = BuildContent();
            
            NameValueCollection headers = new NameValueCollection();

            AAInfoWrapper info = new AAInfoWrapper();
            info.FillOutAAinfo(sentMessage);
            
            AAInfo.MarshallToHeaders(headers, info);
            if (SetAAInfo)                
                VortexUtil.PostRequest(reqUrl, method, content, fKeepAlive, headers);
            else
                VortexUtil.PostRequest(reqUrl, method, content, fKeepAlive);
        }
      
        protected virtual void SendXRLRequest()
        {
            XRLLogBinaryVortex binaryReq = new XRLLogBinaryVortex();
            binaryReq.logBytes = BuildContent();
            binaryReq.logBytesLength = binaryReq.logBytes.Length;
            binaryReq.message = sentMessage;
            if (SetSGInfo)
                binaryReq.ManualPopulateSlot();            

            binaryReq.Execute();
        }        

        /// <summary>
        /// Returns the URL + query string that would be used to hit the server.
        /// </summary>
        /// <returns></returns>
        public string GetRequestURL()
        {
            StringBuilder url = new StringBuilder(reqUrl);
            url.Append(BuildQueryString());

            return url.ToString();
        }

        /// <summary>
        /// Uses the parameters dictionary to generate a query string, and post it to the reqUrl using TCP haxorz
        /// </summary>
        /// <param name="ep"></param>
        /// <param name="fReadResponse"></param>
        public void SendRequestFast(IPEndPoint ep, bool fReadResponse)
        {
            String queryString = BuildQueryString();
            byte[] content = BuildContent();
            VortexUtil.PostRequestFast(ep, String.Format("{0}{1}", reqUrl, queryString), method, content, fKeepAlive);            
        }

        /// <summary>
        /// Generates the query string.
        /// </summary>
        /// <returns></returns>
        public virtual string BuildQueryString()
        {
            if (!String.IsNullOrEmpty(customQS))
                return customQS;
            else
                return string.Empty;
        }                     

        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)serverPayload);
        }

        public override void AfterValidationFailure()
        {
            /* No need to flush with Vortex FD...
            VortexHTTPBinary flusher = new VortexHTTPBinary(this.RequestURL);                        
            flusher.useXrl = this.useXrl;
            flusher.AddUpdateParameter(new VortexEtxField(EtxFieldType.VarInt, 1, 7401667));
            flusher.SendRequest(false); //VERY IMPORTANT TO SAY FALSE THANKS.
            runningCount = 0;
             */
        }
        
        public override string GenerateExpectedResult()
        {
            runningCount = 0; //We'll do comparisons soon after a generate...
            string[] outStrs = this.GenerateExpectedStrings();
            string outBuf = String.Empty;

            foreach (string s in outStrs)
            {
                outBuf += s + "\r\n";
            }
            return outBuf; //Not really used.
        }

        
    }

#endregion

#region Miscellaneous classes
    /// <summary>
    /// Used to validate clickstream counts
    /// </summary>
    public class VortexClickstreamCount : VortexStringInputBase
    {
        string area;
        string pageName;
        string eventType;
        int count;
        int runningCount;
        int windowSizeSeconds = 5;

        public VortexClickstreamCount(string area, string pageName, string eventType, int count, int windowSizeSeconds)
        {
            ReqRefCount++; //Build a log dependency 
            this.area = area;
            this.pageName = pageName;
            this.eventType = eventType;
            this.count = count;
            this.windowSizeSeconds = windowSizeSeconds;
            this.QueryWindowMS = windowSizeSeconds * 1000;
        }

        /// <summary>
        /// Resets the running count of events of this type we've seen - usually validation is preceded by this generate call. 
        /// </summary>
        /// <returns></returns>
        public override string GenerateExpectedResult()
        {
            runningCount = 0; //We'll do comparisons soon after a generate...
            return String.Format("{0}|{1}|{2}|{3}|{4}", area, windowSizeSeconds, count, pageName, eventType);
        }

        public override void AfterValidationFailure()
        {
            //@@@Replace with UDP flusher since it's cleaner... right now UDP doesn't work with the CS query.
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg);
            url = "http://" + viIP.ToString() + "/vortex/logstring2.ashx";


            VortexLS2 flusher = new VortexLS2(url);
            flusher.AddUpdateParameter(1, "flush");
            flusher.SendRequest(false);
        }

        public bool CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {
            //Clean out timestamp
            serverPayload = serverPayload.Substring(serverPayload.IndexOf("|") + 1);

            string[] serverFields = serverPayload.Split('|');
            string[] generatedFields = generatedPayload.Split('|');
            if (serverFields[0] == generatedFields[0] && generatedFields[3] == serverFields[3] && generatedFields[4] == serverFields[4])
            {
                //Keep a count of the totals we've seen over all time windows.
                runningCount += Convert.ToInt32(serverFields[2]);
                //@@@TODOWouldn't catch extra data if we happen to match the size during an accumulation... it would stop as a success... probably scan through inc logs and re-validate the total for safety.
                // Returns success if we're an exact match OR if our IDs are the same and the running count has added up to the expected count.
                return runningCount == this.count;
            }
            else
                return false;
        }
        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }

        public override void ResetValidationState()
        {
            runningCount = 0;
        }

        ~VortexClickstreamCount()
        {
            ReqRefCount--; //Release a log dependency
        }
    }

    /// <summary>
    /// Used to validate event type counts
    /// </summary>
    public class VortexEventtypeCount : VortexStringInputBase
    {
        string area;        
        int count;
        int runningCount;
        int windowSizeSeconds = 60;

        public VortexEventtypeCount(string area, int count, int windowSizeSeconds)
        {
            ReqRefCount++; //Build a log dependency 
            this.area = area;            
            this.count = count;
            this.windowSizeSeconds = windowSizeSeconds;
            this.QueryWindowMS = windowSizeSeconds * 1000;
        }

        /// <summary>
        /// Resets the running count of events of this type we've seen - usually validation is preceded by this generate call. 
        /// </summary>
        /// <returns></returns>
        public override string GenerateExpectedResult()
        {
            runningCount = 0; //We'll do comparisons soon after a generate...
            return String.Format("EVENTCOUNT|{0}|{1}|{2}", windowSizeSeconds, count, area);
        }

        public override void AfterValidationFailure()
        {
            //@@@Replace with UDP flusher since it's cleaner... right now UDP doesn't work with the CS query.
            string url;
            IPEndPoint viIP;

            viIP = Global.XEnv.GetVirtualInterface(VirtualInterface.authsg);
            url = "http://" + viIP.ToString() + "/vortex/logstring2.ashx";


            VortexLS2 flusher = new VortexLS2(url);
            flusher.AddUpdateParameter(1, "flush");
            flusher.SendRequest(false);
        }

        public bool CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {
            string[] serverFields = serverPayload.Split('|');
            string[] generatedFields = generatedPayload.Split('|');
            if (serverFields[0] == generatedFields[0] && generatedFields[2] == serverFields[2] && generatedFields[3] == serverFields[3])
            {
                //Keep a count of the totals we've seen over all time windows.
                runningCount += Convert.ToInt32(serverFields[2]);
                //@@@TODOWouldn't catch extra data if we happen to match the size during an accumulation... it would stop as a success... probably scan through inc logs and re-validate the total for safety.
                // Returns success if we're an exact match OR if our IDs are the same and the running count has added up to the expected count.
                return runningCount == this.count;
            }
            else
                return false;
        }
        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }

        public override void ResetValidationState()
        {
            runningCount = 0;
        }

        ~VortexEventtypeCount()
        {
            ReqRefCount--; //Release a log dependency
        }
    }        

    /// <summary>
    /// Used to validate debug traces if needed.
    /// </summary>
    public class VortexTraceListener : BaseXomListener
    {
        public static void StartTraceListener()
        {
            BaseXomListener.StartXomListener(VortexUtil.vortex_Component, "vortextrace", VortexUtil.vortex_Interface);
            ReqRefCount++;
        }

        public static void StopTraceListener()
        {
            BaseXomListener.StopXomListener(VortexUtil.vortex_Component, "vortextrace", VortexUtil.vortex_Interface);
            ReqRefCount--;
        }

        /// <summary>
        /// Traces - not going too hardcore on this one, just going
        /// to check that a string is contained, like an error code 
        /// for example.
        /// </summary>
        /// <param name="val"></param>
        /// <returns></returns>
        public static bool CheckIfContained(string val)
        {
            foreach (string s in IncomingXomLogs)
            {
                if (s.Contains(val))
                    return true;
            }
            return false;
        }
    }    
#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AccelerationProxyProt.cs ===
using System;
using System.IO;

namespace STF.common.service
{
    public class AccelerationDefs
    {
///////////////////////////////////////////////////////////////////////////////////////////
// PROTOCOL VERSIONS
//
// 1 -- initial protocol version.
//
// 2 -- added optimistic concurrency via versions.  QUERY_EX_RESP and SET_DATA_EX_REQ added.
//
///////////////////////////////////////////////////////////////////////////////////////////

        public const uint ACCELERATION_PROTOCOL_VERSION_CURRENT = 2;
        public const uint ACCELERATION_MESSAGE_HEADER_SIZE = 16;
        public const uint ACCELERATION_MAX_PACKET_SIZE = 16384;
        public const uint ACCELERATION_INCREMENT_HALFLIFE_INFINITE = 0xFFFFFFFF;
        public const uint ACCELERATION_SET_DATA_VERSION_OVERWRITE = 0xFFFFFFFF;
    }

    public enum ACCELERATION_MSG_TYPES
    {
        // request types:
        XBMSG_MIN_REQ                    = 1000,
        XBMSG_QUERY_REQ                  = 1000,
        XBMSG_INSERT_REQ                 = 1001,
        XBMSG_REMOVE_REQ                 = 1002,
        XBMSG_SET_DATA_REQ               = 1003,
        XBMSG_CONTINUATION_REQ           = 1004,
        XBMSG_INCREMENT_REQ              = 1005,
        XBMSG_CHANGELIST_REQ             = 1006,
        XBMSG_MAX_REQ                    = 1006,

        // response types:
        XBMSG_MIN_RESP                   = 1100,
        XBMSG_EMPTY_RESP                 = 1100,
        XBMSG_QUERY_RESP                 = 1101,
        XBMSG_INSERT_RESP                = 1102,
        XBMSG_REMOVE_RESP                = 1103,
        XBMSG_SET_DATA_RESP              = 1104,
        XBMSG_INCREMENT_RESP             = 1105,
        XBMSG_CHANGELIST_RESP            = 1106,
        XBMSG_MAX_RESP                   = 1106,
    };
    
    public class AccelerationMessageHeader : WireData
    {
        public uint dwProtocolVersion;
        public uint dwMsgType;
        public uint dwMsgLen;
        public uint dwSeqNum;

        public AccelerationMessageHeader()
        {
        }

        public AccelerationMessageHeader(ACCELERATION_MSG_TYPES eType)
        {
            dwProtocolVersion = AccelerationDefs.ACCELERATION_PROTOCOL_VERSION_CURRENT;
            dwMsgType = (uint)eType;
        }

        public override int Size()
        {
            return (int)AccelerationDefs.ACCELERATION_MESSAGE_HEADER_SIZE;
        }

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::WriteStream binaryWriter is null");
            }

            if ((dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_REQ) ||
                (dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_REQ))
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::WriteStream dwMsgType not a valid request type.");                
            }

            dwMsgLen = (uint)Size();
            
            binaryWriter.Write(dwProtocolVersion);
            binaryWriter.Write(dwMsgType);
            binaryWriter.Write(dwMsgLen);
            binaryWriter.Write(dwSeqNum);
        }
    
        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::ReadStream binaryReader is null");
            }

            try
            {
                dwProtocolVersion = binaryReader.ReadUInt32();
                dwMsgType = binaryReader.ReadUInt32();
                dwMsgLen = binaryReader.ReadUInt32();
                dwSeqNum = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read response object header", e);
            }
            
            if ((dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_RESP) ||
                (dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new Exception("Fatal Error - AccelerationMessageHeader::ReadStream dwMsgType not a valid response type.");                
            }
            
            return this;
        }
    }

    public class AccelerationQueryRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public byte[] rgbKey;

        public AccelerationQueryRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_QUERY_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationQueryResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwValueSize;
        public uint dwValidSeconds;
        public uint dwVersion;
        public byte[] rgbValue;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwValueSize = binaryReader.ReadUInt32();
                dwValidSeconds = binaryReader.ReadUInt32();
                dwVersion = binaryReader.ReadUInt32();
                rgbValue = binaryReader.ReadBytes((int)dwValueSize);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationInsertRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public AccelerationInsertRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_INSERT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 16 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationInsertRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class AccelerationInsertResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationInsertResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read insert response object", e);
            }
            
            return this;
        }
    }

    public class AccelerationRemoveRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public bool fMatchExact;
        public byte[] rgbKey;

        public AccelerationRemoveRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_REMOVE_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 8 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationRemoveRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(fMatchExact ? (uint)1 : (uint)0);            

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationRemoveResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationRemoveResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read remove response object", e);
            }

            return this;
        }
    }

    public class AccelerationSetDataRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public uint dwValueSize;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public uint dwVersion;
        public byte[] rgbKey;
        public byte[] rgbValue;

        public AccelerationSetDataRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_SET_DATA_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 20 + ((rgbKey == null) ? 0 : rgbKey.Length) + ((rgbValue == null) ? 0 : rgbValue.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationSetDataRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            dwValueSize = (rgbValue == null) ? 0 : (uint)rgbValue.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(dwValueSize);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);
            binaryWriter.Write(dwVersion);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }

            if (rgbValue != null)
            {
                binaryWriter.Write(rgbValue);
            }
        }
    }

    public class AccelerationSetDataResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwVersion;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationSetDataResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwVersion = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read setdata response object", e);
            }

            return this;
        }
    }

    public class AccelerationIncrementRequest : AccelerationMessageHeader
    {
        public uint dwKeySize;
        public ulong qwIncrementAmount;
        public uint dwHalfLifeSeconds;
        public uint dwAbsoluteSeconds;
        public uint dwSlidingSeconds;
        public byte[] rgbKey;

        public AccelerationIncrementRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_INCREMENT_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 24 + ((rgbKey == null) ? 0 : rgbKey.Length);
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationIncrementRequest::WriteStream binaryWriter is null");
            }

            dwKeySize = (rgbKey == null) ? 0 : (uint)rgbKey.Length;
            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwKeySize);
            binaryWriter.Write(qwIncrementAmount);
            binaryWriter.Write(dwHalfLifeSeconds);
            binaryWriter.Write(dwAbsoluteSeconds);
            binaryWriter.Write(dwSlidingSeconds);

            if (rgbKey != null)
            {
                binaryWriter.Write(rgbKey);
            }
        }
    }

    public class AccelerationIncrementResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public ulong qwResult;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationIncrementResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                qwResult = binaryReader.ReadUInt64();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read increment response object", e);
            }
            
            return this;
        }
    }

    public class AccelerationChangelistRequest : AccelerationMessageHeader
    {
        public uint dwChangeID;

        public AccelerationChangelistRequest() : base(ACCELERATION_MSG_TYPES.XBMSG_CHANGELIST_REQ)
        {
        }

        public override int Size()
        {
            return base.Size() + 4;
        }
        
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            if (binaryWriter == null)
            {
                throw new Exception("Fatal Error - AccelerationChangelistRequest::WriteStream binaryWriter is null");
            }

            base.WriteStream(binaryWriter);
            
            binaryWriter.Write(dwChangeID);
        }
    }

    public class AccelerationChangelistResponse : AccelerationMessageHeader
    {
        public HResult hr;
        public uint dwNewChangeID;
        public uint dwNumChanges;

        [WireInfo(SizeParam="dwNumChanges")]
        public AccelerationChangelistItem[] rgChanges;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationQueryResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
                dwNewChangeID = binaryReader.ReadUInt32();
                dwNumChanges = binaryReader.ReadUInt32();

                rgChanges = new AccelerationChangelistItem[dwNumChanges];
                for (uint iChange = 0; iChange < dwNumChanges; iChange++)
                {
                    rgChanges[iChange] = new AccelerationChangelistItem();
                    rgChanges[iChange].ReadStream(binaryReader);
                }
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationChangelistItem : WireData
    {
        public uint cbKey;
        
        [WireInfo(SizeParam="dwSize")]
        public byte[] rgbKey;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationChangelistItem::ReadStream binaryReader is null");
            }

            try
            {
                cbKey = binaryReader.ReadUInt32();
                rgbKey = binaryReader.ReadBytes((int)cbKey);
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read query response object", e);
            }

            return this;
        }
    }

    public class AccelerationEmptyResponse : AccelerationMessageHeader
    {
        public HResult hr;

        public override WireData ReadStream(BinaryReader binaryReader)
        {
            if (binaryReader == null)
            {
                throw new Exception("Fatal Error - AccelerationEmptyResponse::ReadStream binaryReader is null");
            }

            try
            {
                base.ReadStream(binaryReader);

                hr = binaryReader.ReadUInt32();
            }
            catch (EndOfStreamException e)
            {
                throw new XRLException(HResult.XONLINE_E_END_OF_STREAM, XEvent.Id.ACCELERATION_END_OF_STREAM, "Reached end of stream trying to read empty response object", e);
            }
            
            return this;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\vortex\VortexLS.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Net;
using System.Threading;
using System.Globalization;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using xonline.common.config;


namespace ServerTestFramework.LiveService.Vortex
{
    /// <summary>
    /// Some predefined fields we want to fill out.
    /// </summary>
    public enum LS2Fields
    {        
        Area = 1,
        EventType = 9999, //Not really. These are strings. Map them later.
        PageName = 10000
    }    

    public class VortexLS2 : VortexHTTPString
    {
        public VortexLS2(string url)
            : base(url)
        {
        }

        public string GetLS2FieldName(LS2Fields field)
        {
            string result;
            switch (field)
            {
                case LS2Fields.PageName:
                   result = "pageName";
                   break;
                case LS2Fields.EventType:
                   result = "events";
                   break;
                default:
                   return (String.Format("v{0}", (int)field));
            }
            return result;
        }

        public bool  CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {   
            return serverPayload == generatedPayload;
        }
        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }

        /// <summary>
        /// Generates the query string.
        /// </summary>
        /// <returns></returns>
        public override string BuildQueryString()
        {
            if (!String.IsNullOrEmpty(CustomQS))
                return CustomQS;
            
            StringBuilder queryString = new StringBuilder("?");

            foreach (string index in parameters.Keys)
            {
                if (!filteredParams.ContainsKey(index) || filteredParams[index] == false)
                    queryString.AppendFormat("&{0}={1}", index, HttpUtility.UrlEncode(parameters[index]));
            }

            if (queryString.Length != 1)
                queryString.Remove(1, 1); //Remove the first & at index 1        

            return queryString.ToString();
        }
        
        /// <summary>
        /// Lots of playing with strings here. First we grab the query string, turn the &s into |s, then we turn the vXX format stuff into a dictionary.
        /// With that we create our ordered string.
        /// </summary>
        /// <returns></returns>
        public override string GenerateExpectedResult()
        {
            Uri url = new Uri(GetRequestURL());
            string eventID = String.Empty;
            string rawPayload;            
            DateTime Timestamp = DateTime.UtcNow;            

            if (!String.IsNullOrEmpty(url.Query) && url.Query.Length > 1)
                rawPayload = url.Query.Substring(1).Replace('&', '|'); // trim off leading "?" and replace "&" with "|"            
            else
                rawPayload = "";                        
            
            NameValueCollection fields = new NameValueCollection();            
            List<string> sortedKeys = new List<string>();

            string[] fieldArr = rawPayload.Split('|');

            foreach (string s in fieldArr)
            {
                string[] kvp = s.Split('=');
                string key = HttpUtility.UrlDecode(kvp[0]);
                string value;

                if (kvp.Length == 1)
                {
                    value = key;
                    key = null;                    
                }
                else
                    value = HttpUtility.UrlDecode(kvp[1]);

                fields.Add(key, value);

                if (!sortedKeys.Contains(key))
                    sortedKeys.Add(key);
            }
	    
            StringBuilder payloadBuf = new StringBuilder(String.Empty);                        

            foreach (string key in sortedKeys)
            {
                if (key != "v1")
                {
                    if (fields[key] != null)
                        payloadBuf.AppendFormat("{0}={1}|", key, fields[key]);                    
                    else
                        payloadBuf.AppendFormat("{0}={1}|", key, string.Empty);
                }
            }

            if ( (sortedKeys.Count > 0) && payloadBuf.Length != 0)
                payloadBuf.Remove(payloadBuf.Length - 1, 1);

            rawPayload = payloadBuf.ToString();

            if (sortedKeys.Contains("v1"))
                eventID = fields["v1"];
            
             if (string.IsNullOrEmpty(eventID) && string.IsNullOrEmpty(rawPayload))
                 return string.Empty;
             else if (String.IsNullOrEmpty(rawPayload))
                 return String.Format("LS-{0}", eventID);
             else if (string.IsNullOrEmpty(eventID))
                 return String.Format("LS-{0}", rawPayload);
             else                 
                return String.Format("LS-{0}|{1}", eventID, rawPayload);            
        }
        
        /// <summary>
        /// Adds or updates a parameter using the LS2Fields enum to identify the field
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(LS2Fields type, string value)
        {
            AddUpdateParameter(GetLS2FieldName(type), value, false);
        }

        /// <summary>
        /// Adds or updates a parameter using the LS2Fields enum to identify the field
        /// </summary>
        /// <param name="type"></param>
        /// <param name="value"></param>
        public void AddUpdateParameter(LS2Fields type, string value, bool filtered)
        {
            AddUpdateParameter(GetLS2FieldName(type), value, filtered);
        }

        public new void AddUpdateParameter(int type, string value)
        {
            base.AddUpdateParameter(String.Format("v{0}", type), value);
        }
        
        public new void AddUpdateParameter(int type, string value, bool filtered)            
        {
            base.AddUpdateParameter(String.Format("v{0}", type), value, filtered);
        }

        /// <summary>
        /// Generates parameters. They will follow the format vXX=valueXX.
        /// </summary>
        /// <param name="additionalParameters"></param>
        public new void GenerateParameters(int additionalParameters)
        {
            base.GenerateParameters(additionalParameters);
            lock (parameters)
            {
                Dictionary<string, string> oldPs = parameters;
                parameters = new Dictionary<string, string>();
                foreach (string p in oldPs.Keys)
                {
                    int num;
                    if (Int32.TryParse(p, out num))
                    {
                        string pMod = "v"+num.ToString();
                        AddUpdateParameter(pMod, oldPs[p]);
                    }
                    else
                        AddUpdateParameter(p, oldPs[p]);                    
                }                
            }
        }
    }

    /// <summary>
    /// Logstring format. 2 bytes for length, null character separated strings.
    /// </summary>
    public class VortexLS : VortexHTTPString
    {        
        public VortexLS(string url)
            : base(url)
        {
            UseXRL = true;        
            this.method = "POST";
        }

        public void SetReqTime()
        {
            reqTime = DateTime.Now;
        }

        public bool CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {
            return serverPayload == generatedPayload;
        }

        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }

        public override string GenerateExpectedResult()
        {   
            String newLog = BuildContent();
            
            string id = "logstring.ashx";
            int idx = newLog.IndexOf("|"); //Index of the first pipe
            
            if (newLog.Length > 2)
            {
                if (idx != -1)
                    id = newLog.Substring(2, idx - 2); //Skip the first two bytes, grab the first field.
                else
                    id = newLog.Substring(2, newLog.Length - 2); //Skip the first two bytes, grab the first field.
            }            

            //return String.Format("{0}|{1}", id, String.IsNullOrEmpty(newLog) ? newLog : newLog.Substring(2));
            //For CAKE. May be temporary
            return String.Format("LS-{0}", String.IsNullOrEmpty(newLog) ? newLog : newLog.Substring(2));
        }        

        public override string BuildContent()
        {
            if (CustomContent != null) //Only null, to be able to test empty content
                return CustomContent;

            StringBuilder contentBuf = new StringBuilder(String.Empty);

            //Find the max
            int max = 0;
            foreach (string indexStr in parameters.Keys)
            {
                
                int index;
                if (int.TryParse(indexStr, out index))
                {
                    if (max < index)
                        max = index;
                }
            }

            for (int k = 0; k <= max; k++)
            {
                if (parameters.ContainsKey(k.ToString()))
                    contentBuf.AppendFormat("{0}|", parameters[k.ToString()]);
            }            
            
		    if (contentBuf.Length != 0)
                contentBuf.Remove(contentBuf.Length - 1, 1);

            Byte[] bytes = BitConverter.GetBytes((ushort)contentBuf.Length);
            contentBuf.Insert(0, (char)bytes[0]);
            contentBuf.Insert(0, (char)bytes[1]);

            return contentBuf.ToString();
        }

        protected override void SendXRLRequest()
        {
            XRLLogStringVortex vrtxReq = new XRLLogStringVortex();
            vrtxReq.logLine = BuildContent();
            vrtxReq.logLine = (vrtxReq.logLine.Length > 2) ? vrtxReq.logLine.Substring(2) : String.Empty;

            vrtxReq.logLinesLength = (ushort)vrtxReq.logLine.Length;

            if (!vrtxReq.Execute(Global.XEnv.GetVirtualInterface(VortexUtil.vortex_VirtualInterface)))
                throw new UnexpectedTestResultException("XRLLogString simple logline failed: " + vrtxReq.GetDumpString());
            if (vrtxReq.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLLogString simple logline returned XErr=0x{0:x}", vrtxReq.XErr));
        }
    }

    /// <summary>
    /// Represents a UDP log passing through vortex. Not in use right now.
    /// </summary>
    public class VortexLS_UDP : VortexStringInputBase
    {
        protected string customMessage = null;
        protected string reqUrl;
        protected string virtualInterface;

        bool useDirect = false;
        IVxTransport transport;

        #region Public properties
        /// <summary>
        /// The content of the UDP message.
        /// </summary>
        public string CustomMessage
        {
            get { return customMessage; }
            set { customMessage = value; }
        }

        public bool UseDirect
        {
            get { return useDirect; }
            set
            {
                if (value)
                    transport = new DirectUdpTransport(virtualInterface);
                else
                    transport = new SgUdpTransport(virtualInterface);

                useDirect = value;
            }
        }

        #endregion Public properties

        /// <summary>
        /// Initializes a UDP object. 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="category"></param>
        /// <param name="timeStamp"></param>
        public VortexLS_UDP(string virtualInterface)
        {
            this.virtualInterface = virtualInterface;
            if (this.virtualInterface == null)
            {
                throw new ArgumentNullException("virtualInterface", "VirtualInterface not specified!");
            }

            if (useDirect)
                transport = new DirectUdpTransport(virtualInterface);
            else
                transport = new SgUdpTransport(virtualInterface);
        }       
        

        public override void AfterValidationFailure()
        {
            VortexLS_UDP flusher = new VortexLS_UDP(virtualInterface);
            flusher.useDirect = true;
            flusher.AddUpdateParameter(1, "flush");
            flusher.SendRequest(false); //VERY IMPORTANT TO SAY FALSE THANKS.
        }

        public void SetReqTime()
        {
            reqTime = DateTime.Now;
        }

        public bool CompareExpectedVsReceived(string generatedPayload, string serverPayload)
        {
            //For now the times won't match exactly so let's forget about that particular comparison. We can add a +-X minutes match later                        
            serverPayload = serverPayload.Substring(serverPayload.IndexOf("|") + 1);

            return serverPayload == generatedPayload;        
        }
        public override bool CompareExpectedVsReceived(object generatedPayload, object serverPayload)
        {
            return CompareExpectedVsReceived((string)generatedPayload, (string)serverPayload);
        }


        public override string GenerateExpectedResult()
        {
            String newLog = BuildMessage();

            string id = "udp";
            int idx = newLog.IndexOf("|"); //Index of the first pipe

            if (newLog.Length > 2)
            {
                if (idx != -1)
                    id = newLog.Substring(0, idx); //Skip the first two bytes, grab the first field.
                else
                    id = newLog.Substring(0, newLog.Length); //Skip the first two bytes, grab the first field.
            }

            return String.Format("{0}|{1}", id, newLog);
        }

        public string BuildMessage()
        {
            if (CustomMessage != null) //Only null, to be able to test empty content
                return CustomMessage;

            StringBuilder contentBuf = new StringBuilder(String.Empty);

            //Find the max
            int max = 0;
            foreach (string indexStr in parameters.Keys)
            {

                int index;
                if (int.TryParse(indexStr, out index))
                {
                    if (max < index)
                        max = index;
                }
            }

            for (int k = 0; k <= max; k++)
            {
                if (filteredParams.ContainsKey(k.ToString()) && !filteredParams[k.ToString()])
                    contentBuf.AppendFormat("{0}|", parameters[k.ToString()]);
            }

            if (contentBuf.Length != 0)
                contentBuf.Remove(contentBuf.Length - 1, 1);

            return contentBuf.ToString();
        }
    }
   
    public class VortexLSBatch
    {
        List<VortexLS> batchedReqs;
        string url;

        public VortexLSBatch(string url)
        {
            this.url = url;
            batchedReqs = new List<VortexLS>();
        }
        
        public void AddVortexReq(VortexLS vLs)
        {
            batchedReqs.Add(vLs);
        }

        public void RemoveVortexReq(VortexLS vLs)
        {
            batchedReqs.Remove(vLs);
        }

        public void Clear()
        {
            batchedReqs.Clear();
        }

        /// <summary>
        /// Uses the VortexLS methods to generate a batched request. Individually validates each logline.
        /// </summary>
        public void SendBatchedReq()
        {
            SendBatchedReq(true);
        }
        
        /// <summary>
        /// Uses the VortexLS methods to generate a batched request. Individually validates each logline.
        /// </summary>
        public void SendBatchedReq(bool validate)
        {
            if (validate)
                VortexLS.ReqRefCount++;            
            try
            {
                VortexLS baseReq = new VortexLS(url);                
                StringBuilder contentBuf = new StringBuilder(String.Empty);                
                
                foreach (VortexLS vReq in batchedReqs)
                {
                    contentBuf.AppendFormat("{0}\n", vReq.BuildContent().Substring(2));
                    vReq.SetReqTime();
                }
                contentBuf.Remove(contentBuf.Length - 1, 1);

                ushort len = (ushort)(contentBuf.Length); //@@@Test with mismatched lengths.
                contentBuf.Insert(0, System.Text.Encoding.UTF8.GetString(BitConverter.GetBytes(len)));

                baseReq.CustomContent = contentBuf.ToString();                

                baseReq.SendRequest(false);                

                if (validate)
                {
                    //Validate every logline went through... wait for it... in reverse!!!!!!!!!!!!!!!!! 
                    batchedReqs.Reverse();
                    foreach (VortexLS vReq in batchedReqs)
                    {                           
                        vReq.Validate();
                    }
                }
            }            
            finally
            {
                if (validate)
                    VortexLS.ReqRefCount--;
            }
        }
    }

       
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AccelerationProxy.cs ===
using System;
using System.IO;
using System.Collections;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

using STF.common.config;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.AccelerationProxy)]
    
namespace STF.common.service
{
    public class Acceleration
    {
        protected static uint m_dwMaxKeyLength;

        internal AccelerationConnectionCluster _cluster;
        public string InterfaceName
        {
            get
            {
                return _cluster.InterfaceName;
            }
        }

        public delegate void AccelerationNotificationHandler(byte[][] keys);
        public delegate void AccelerationNotificationFailureHandler();
        
        static Acceleration()
        {
            // config setting change handler.
            Config.SettingChange += new SettingChangeEventHandler(Acceleration.ChangeSetting);
            m_dwMaxKeyLength = Config.GetUIntSetting(Setting.acceleration_max_key_length);
        }

        public Acceleration(string iface)
        {
            _cluster = AccelerationConnectionCluster.BuildCluster(iface);
        }

        public void RegisterNotificationHandler(AccelerationNotificationHandler notificationCallback)
        {
            _cluster.RegisterNotificationHandler(notificationCallback);
        }

        public void RegisterNotificationFailureHandler(AccelerationNotificationFailureHandler failureCallback)
        {
            _cluster.RegisterNotificationFailureHandler(failureCallback);
        }

        public void UnregisterHandlers()
        {
            _cluster.UnregisterHandlers();
        }
                
        public static bool CompareByteArrays(byte[] array1, byte[] array2)
        {
            if (array1 == null) return (array2 == null);
            if (array2 == null) return false;
            if (array1.Length != array2.Length) return false;
            for (int i = 0; i < array1.Length; i++)
            {
                if (array1[i] != array2[i]) return false;
            }
            return true;
        }

        public bool ValidateKey(byte[] key)
        {
            /* TODO: add this to enforce that users call Init() before anything else.
            if (!m_fInitialized)
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_NOT_INITIALIZED, "AccelerationProxy accessed without being initialized.  Did you forget to call Acceleration.Init() in your startup code?");
                return false;
            }
            */
            
            if ((key == null) ||
                (key.Length == 0) ||
                (key.Length > m_dwMaxKeyLength))
            {
                return false;
            }

            return true;
        }

        public bool ValidateValue(byte[] value)
        {
            if ((value == null) ||
                (value.Length == 0))
            {
                return false;
            }

            return true;
        }
        
        protected uint HashKeyToBucket(byte[] key)
        {
            uint sum = 0;
            for (int i = 0; i < key.Length; i++)
            {
                sum += (uint)key[i];
            }

            return sum % _cluster.GetNumBuckets();
        }

        public static uint GetExtendedError(Exception e, byte[] rgbStream)
        {
            if (e is XRLException)
            {
                XRLException xrle = (XRLException)e;
                
                // check for a failure code from the inh server.
                if ((xrle.HResult == HResult.XONLINE_E_END_OF_STREAM) &&
                    (rgbStream != null))
                {
                    try
                    {
                        AccelerationEmptyResponse response = new AccelerationEmptyResponse();
                        response.ReadBytes(rgbStream);

                        // return the hr from the server.
                        return response.hr;
                    }
                    catch (Exception)
                    {
                        // couldnt get anything more.  we can eat this exception.
                    }
                }

                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REQUEST_FAILED, xrle, "Acceleration caught an XRLException (via GetExtendedError)");

                // return exception failure.
                return xrle.HResult;
            }
            else
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REQUEST_FAILED, e, "Acceleration caught an exception (via GetExtendedError)");
                
                // generic send failure.
                return HResult.E_ABORT;
            }
        }
        
        public uint Query(byte[] key, out byte[] value)
        {
            uint validSeconds;
            uint version;
            return Query(key, out value, out validSeconds, out version);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds)
        {
            uint version;
            return Query(key, out value, out validSeconds, out version);
        }

        public uint Query(byte[] key, out byte[] value, out uint validSeconds, out uint version)
        {
            uint[] rgValidSeconds;
            uint[] rgVersions;
            byte[][] values;
            uint[] retVals;

            retVals = Query(new byte[][]{key}, out values, out rgValidSeconds, out rgVersions);

            value = values[0];
            validSeconds = rgValidSeconds[0];
            version = rgVersions[0];
            return retVals[0];
         }

        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds)
        {
            uint[] rgVersions;
            return Query(keys, out values, out validSeconds, out rgVersions);
        }
        
        public uint[] Query(byte[][] keys, out byte[][] values, out uint[] validSeconds, out uint[] versions)
        {
            values = null;
            validSeconds = null;
            versions = null;
            
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            validSeconds = new uint[keys.Length];
            versions = new uint[keys.Length];
            values = new byte[keys.Length][];

            // If the client has requested that all acceleration queries fail,
            // then don't even bother with the real query.
            if (XbancMiss.HandleBehaviorInjectionQuery(retVals))
            {
                return retVals;
            }

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                // assume failure for each key until proven otherwise.
                retVals[iKey] = HResult.E_ABORT;
                
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                    continue;
                }
                
                AccelerationQueryRequest request = new AccelerationQueryRequest();
                request.rgbKey = keys[iKey];
                context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
            }

            _cluster.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (context._wtObjects[iKey] == null)
                {
                    // we never sent this key to acceleration.  it likely has a prior success/error code from above.
                    continue;
                }
                else if (context._wtObjects[iKey]._response == null)
                {
                    // we got nothing back from acceleration.
                    retVals[iKey] = HResult.E_ABORT;
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationQueryResponse response = new AccelerationQueryResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        values[iKey] = response.rgbValue;
                        validSeconds[iKey] = response.dwValidSeconds;
                        versions[iKey] = response.dwVersion;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Insert(byte[] key, byte[] value)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0});
            return retVals[0];
        }

        public uint Insert(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = Insert(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds});
            return retVals[0];
        }

        public uint[] Insert(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if (keys == null)
            {
                return null;
            }
            
            // Insert is now identical to SetData with version = 0.
            uint[] versions = new uint[keys.Length];
            return SetData(keys, values, absoluteExpiries, slidingExpiries, versions);
        }

        public uint Remove(byte[] key)
        {
            uint[] retVals = Remove(new byte[][]{key});
            return retVals[0];
        }

        public uint[] Remove(byte[][] keys)
        {
            if ((keys == null) || (keys.Length == 0))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationRemoveRequest request = new AccelerationRemoveRequest();
                    request.rgbKey = keys[iKey];
                    request.fMatchExact = true;
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationRemoveResponse response = new AccelerationRemoveResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Remove(byte[] key, bool matchExact)
        {
            if (matchExact == true)
            {
                return Remove(key);
            }
            
            if (!ValidateKey(key))
            {
                return HResult.E_INVALIDARG;
            }
            
            // make a request copy for each server.
            uint cServers = _cluster.GetNumServers();
            AccelerationRemoveRequest[] requests = new AccelerationRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new AccelerationRemoveRequest();
                requests[iServer].rgbKey = key;
                requests[iServer].fMatchExact = false;
            }

            try
            {
                // we treat these sends as fire and forget.
                _cluster.SendToAllServers(requests);
                return HResult.S_OK;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_REMOVE_FAILED, e, "Acceleration.Remove() caught exception");

                return HResult.E_ABORT;
            }
        }


        // old (protocol version 1 style) SetData API assumes always overwrite.  we translate that to pass
        // AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE as the version.
        public uint SetData(byte[] key, byte[] value)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0}, new uint[]{AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE});
            return retVals[0];
        }
        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds)
        {
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, new uint[]{AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE});
            return retVals[0];
        }
        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries)
        {
            if (keys == null)
            {
                return null;
            }
            
            uint[] versions = new uint[keys.Length];
            for (int iKey = 0; iKey < keys.Length; iKey++)
            {
                versions[iKey] = AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE;
            }
            return SetData(keys, values, absoluteExpiries, slidingExpiries, versions);
        }

        // new (protocol version 2) SetData API requires a version to write.  E_ACCESSDENIED is returned if any existing value
        // does not match the specified version.  a successful write will internally increment the version.
        public uint SetData(byte[] key, byte[] value, ref uint version)
        {
            uint[] versions = new uint[]{version};
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{0}, new uint[]{0}, versions);
            version = versions[0];
            return retVals[0];
        }

        public uint SetData(byte[] key, byte[] value, uint absoluteSeconds, uint slidingSeconds, ref uint version)
        {
            uint[] versions = new uint[]{version};
            uint[] retVals = SetData(new byte[][]{key}, new byte[][]{value}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, versions);
            version = versions[0];
            return retVals[0];
        }

        public uint[] SetData(byte[][] keys, byte[][] values, uint[] absoluteExpiries, uint[] slidingExpiries, uint[] versions)
        {
            if ((keys == null) || (values == null) || (absoluteExpiries == null) || (slidingExpiries == null) || (versions == null) ||
                (keys.Length == 0) || (values.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length) || (versions.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || !ValidateValue(values[iKey]))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationSetDataRequest request = new AccelerationSetDataRequest();
                    request.rgbKey = keys[iKey];
                    request.rgbValue = values[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    request.dwVersion = versions[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationSetDataResponse response = new AccelerationSetDataResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        retVals[iKey] = response.hr;
                        versions[iKey] = response.dwVersion;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint Increment(byte[] key, ulong amount, out ulong result)
        {
            return Increment(key, amount, AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, out ulong result)
        {
            return Increment(key, amount, halfLifeSeconds, 0, 0, out result);
        }

        public uint Increment(byte[] key, ulong amount, uint halfLifeSeconds, uint absoluteSeconds, uint slidingSeconds, out ulong result)
        {
            ulong[] results;
            uint[] retVals = Increment(new byte[][]{key}, new ulong[]{amount}, new uint[]{halfLifeSeconds}, new uint[]{absoluteSeconds}, new uint[]{slidingSeconds}, out results);
            
            result = results[0];
            return retVals[0];
        }

        public uint[] Increment(byte[][] keys, ulong[] amounts, out ulong[] results)
        {
            uint[] halfLives = new uint[keys.Length];
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                halfLives[iKey] = AccelerationDefs.ACCELERATION_INCREMENT_HALFLIFE_INFINITE;
            }
            return Increment(keys, amounts, halfLives, new uint[keys.Length], new uint[keys.Length], out results);
        }
        
        public uint[] Increment(byte[][] keys, ulong[] amounts, uint[] halfLives, uint[] absoluteExpiries, uint[] slidingExpiries, out ulong[] results)
        {
            results = null;
            
            if ((keys == null) || (amounts == null) || (halfLives == null) || (absoluteExpiries == null) || (slidingExpiries == null) ||
                (keys.Length == 0) || (amounts.Length != keys.Length) || (halfLives.Length != keys.Length) || (absoluteExpiries.Length != keys.Length) ||(slidingExpiries.Length != keys.Length))
            {
                return null;
            }

            uint[] retVals = new uint[keys.Length];
            results = new ulong[keys.Length];

            AccelerationContext context = new AccelerationContext(keys.Length);

            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if (!ValidateKey(keys[iKey]) || (halfLives[iKey] == 0))
                {
                    retVals[iKey] = HResult.E_INVALIDARG;
                }
                else
                {
                    AccelerationIncrementRequest request = new AccelerationIncrementRequest();
                    request.rgbKey = keys[iKey];
                    request.qwIncrementAmount = amounts[iKey];
                    request.dwHalfLifeSeconds = halfLives[iKey];
                    request.dwAbsoluteSeconds = absoluteExpiries[iKey];
                    request.dwSlidingSeconds = slidingExpiries[iKey];
                    context.AddRequest(iKey, HashKeyToBucket(keys[iKey]), request);
                }
            }

            _cluster.SendContext(context);
            
            for (uint iKey = 0; iKey < keys.Length; iKey++)
            {
                if ((context._wtObjects[iKey] == null) ||
                    (context._wtObjects[iKey]._response == null))
                {
                    // prior error?
                    if (retVals[iKey] == 0)
                    {
                        retVals[iKey] = HResult.E_ABORT;
                    }
                }
                else
                {
                    try
                    {
                        // parse the response.
                        AccelerationIncrementResponse response = new AccelerationIncrementResponse();
                        response.ReadBytes(context._wtObjects[iKey]._response);

                        results[iKey] = response.qwResult;
                        retVals[iKey] = response.hr;
                    }
                    catch (Exception e)
                    {
                        retVals[iKey] = GetExtendedError(e, context._wtObjects[iKey]._response);
                    }
                }
            }
            
            return retVals;
        }

        public uint[] Health()
        {            
            // make a request copy for each server.
            uint cServers = _cluster.GetNumServers();
            AccelerationRemoveRequest[] requests = new AccelerationRemoveRequest[cServers];            
            for (uint iServer = 0; iServer < cServers; iServer++)
            {
                requests[iServer] = new AccelerationRemoveRequest();
                requests[iServer].rgbKey = System.Text.Encoding.ASCII.GetBytes("Health");
                requests[iServer].fMatchExact = true;
            }

            uint[] hrs = _cluster.SendToAllServers(requests, true);

            return hrs;
        }

        public static void ChangeSetting(object sender, SettingChangeEventArgs e)
        {
        }

    }

    internal class AccelerationContext
    {
        public AccelerationWaitTableObject[] _wtObjects;
        public int _keysRemaining;
        public ManualResetEvent _event = null;

        public AccelerationContext(int numRequests)
        {
            _keysRemaining = 0;
            _wtObjects = new AccelerationWaitTableObject[numRequests];
            _event = new ManualResetEvent(false);
        }

        public void AddRequest(uint keyIndex, uint bucket, AccelerationMessageHeader request)
        {
            _wtObjects[keyIndex] = new AccelerationWaitTableObject(this, keyIndex, bucket, request);
            _keysRemaining++;
        }
    }

    internal class AccelerationWaitTableObject
    {
        public AccelerationContext _context;
        public AccelerationMessageHeader _request;
        public byte[] _response;
        public uint _keyIndex;
        public uint _seqnum;
        public uint _bucket;

        public XomRequestTimeElapsed _waitTime;

        public AccelerationWaitTableObject(AccelerationContext context, uint keyIndex, uint bucket, AccelerationMessageHeader request)
        {
            _context = context;
            _keyIndex = keyIndex;
            _bucket = bucket;
            _request = request;
            _seqnum = 0;
        }
    }

    // singleton class for each cluster
    internal class AccelerationConnectionCluster
    {
        internal const int LOCK_TIMEOUT = 30000;
        internal const int REPLY_TIMEOUT = 3000;

        private static Hashtable _htClusters = null;

        private string _iface = null;
        public string InterfaceName
        {
            get
            {
                return _iface;
            }
        }

        // an array of InhConnection objects, use
        // GetInhConnection to access it.
        private ReaderWriterLock _rwlConnections = null;
        private int[] _bucketMap = null;
        private AccelerationConnection[] _connections = null;

        // fast fail
        internal FastFailHelper _fastFailHelper = null;
        internal string _timeoutSetting = null;

        // notification callbacks
        internal Acceleration.AccelerationNotificationHandler _notificationCallback = null;
        internal Acceleration.AccelerationNotificationFailureHandler _failureCallback = null;

        static AccelerationConnectionCluster()
        {
            // setup config change handlers.
            Config.InterfaceBucketChange += new InterfaceBucketChangeEventHandler(AccelerationConnectionCluster.ChangeBucketMap);
            Config.ServerListChange += new ServerListChangeEventHandler(AccelerationConnectionCluster.ChangeServerList);

            _htClusters = new Hashtable();
        }

        internal AccelerationConnectionCluster(string iface)
        {
            _iface = iface;

            // create a fast fail helper.
            _fastFailHelper = GetFastFailHelper(iface);
            _timeoutSetting = GetTimeoutSetting(iface);

            // create reader/writer lock for static connection management.
            _rwlConnections = new ReaderWriterLock();

            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // first get the servers.
                    string[] serverList = Config.GetServerListByInterface(iface);
                    _connections = new AccelerationConnection[serverList.Length];

                    for (int iServer = 0; iServer < _connections.Length; iServer++)
                    {
                        IInterfaceInfo ifaceinfo = Config.GetInterface(serverList[iServer], iface);

                        // create the new InhConnection object
                        Xom.Trace(XomAreaName.AccelerationProxy, 
                            LogLevel.L_NORMAL,
                            "AccelerationConnection.InitConnections: creating new InhConnection to Inh server "
                            + iServer.ToString()
                            + ", IP address "
                            + ifaceinfo.IPAddressString);
                        
                        _connections[iServer] = new AccelerationConnection(ifaceinfo, serverList[iServer], this);
                    }
                    
                    // now we have to make the bucket map. 
                    uint numBuckets = Config.GetBucketCount(iface);
                    _bucketMap = new int[numBuckets];
                   
                    for (int iBucket = 0; iBucket < numBuckets; iBucket++)
                    {
                        _bucketMap[iBucket] = -1;
                        
                        IBucketServer b = Config.GetBucketServer(iface, (uint)iBucket);

                        // find this bucket's server in the list of servers
                        for (int iServer = 0; iServer < serverList.Length; iServer++)
                        {
                            if (0 == String.Compare(b.CurrentServerName, serverList[iServer], StringComparison.OrdinalIgnoreCase))
                            {
                                // found it.
                                _bucketMap[iBucket] = iServer;
                                break;
                            }
                        }

                        if (_bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_BUCKET_MAP_FAILED, "Could not map bucket " + iBucket.ToString() + "to server " + b.CurrentServerName);
                        }
                    }
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public static AccelerationConnectionCluster FindCluster(string iface)
        {
            lock (_htClusters.SyncRoot)
            {
                return (AccelerationConnectionCluster)_htClusters[iface];
            }
        }

        public static AccelerationConnectionCluster BuildCluster(string iface)
        {
            lock (_htClusters.SyncRoot)
            {
                AccelerationConnectionCluster cluster = FindCluster(iface);
                if (cluster == null)
                {
                    cluster = new AccelerationConnectionCluster(iface);
                    _htClusters[iface] = cluster;
                }

                return cluster;
            }
        }

        public static void ChangeBucketMap(object sender, InterfaceBucketChangeEventArgs e)
        {
            AccelerationConnectionCluster cluster = FindCluster(e.Interface);
            if (cluster == null)
            {
                // we're only concerned with acceleration's buckets.
                return;
            }
            
            if (0 == String.Compare(e.ValueNew.CurrentServerName, e.ValueOld.CurrentServerName, StringComparison.OrdinalIgnoreCase))
            {
                // no change that we care about.
                return;
            }
            
            bool fChanged = false;

            cluster._rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = cluster._rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {            
                    for (int iServer = 0; iServer < cluster._connections.Length; iServer++)
                    {
                        if (0 == String.Compare(e.ValueNew.CurrentServerName, cluster._connections[iServer].GetServerName(), StringComparison.OrdinalIgnoreCase))
                        {
                            cluster._bucketMap[e.Bucket] = iServer;
                            fChanged = true;
                            break;
                        }
                    }
                }
                finally
                {
                    cluster._rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                cluster._rwlConnections.ReleaseReaderLock();
            }

            if (!fChanged)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.ACCELERATION_PROXY_BUCKET_CHANGE_FAILED, "AccelerationConnection::ChangeBucketMap() could not find a connection to server " + e.ValueNew.CurrentServerName);
            }
        }

        public static void ChangeServerList(object sender, ServerListChangeEventArgs e)
        {
            AccelerationConnectionCluster cluster = FindCluster(e.Interface);
            if (cluster == null)
            {
                // we're only concerned with acceleration's servers.
                return;
            }

            cluster._rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // build a translation map for the indices.
                int[] iIndexMap = new int[cluster._connections.Length];

                for (int iOldServer = 0; iOldServer < cluster._connections.Length; iOldServer++)
                {
                    iIndexMap[iOldServer] = -1;
                    for (int iNewServer = 0; iNewServer < e.ValueNew.Length; iNewServer++)
                    {
                        if (0 == String.Compare(cluster._connections[iOldServer].GetServerName(), e.ValueNew[iNewServer], StringComparison.OrdinalIgnoreCase))
                        {
                            iIndexMap[iOldServer] = iNewServer;
                        }
                    }
                }

                LockCookie lc = cluster._rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    // make a new connection list and copy over any old connections that still remain.
                    AccelerationConnection[] newConnections = new AccelerationConnection[e.ValueNew.Length];
                    for (int iOldServer = 0; iOldServer < cluster._connections.Length; iOldServer++)
                    {
                        if (iIndexMap[iOldServer] == -1)
                        {
                            // not in the map -- we dont need this one anymore.
                            cluster._connections[iOldServer].Shutdown(false);
                        }
                        else
                        {
                            newConnections[iIndexMap[iOldServer]] = cluster._connections[iOldServer];
                        }                

                        cluster._connections[iOldServer] = null;
                    }

                    // make new connections
                    for (int iNewServer = 0; iNewServer < newConnections.Length; iNewServer++)
                    {
                        if (newConnections[iNewServer] == null)
                        {
                            IInterfaceInfo ifaceinfo = Config.GetInterface(e.ValueNew[iNewServer], cluster._iface);

                            // create the new InhConnection object
                            Xom.Trace(XomAreaName.AccelerationProxy,
                                LogLevel.L_NORMAL,
                                "AccelerationConnection.ChangeServerList: creating new InhConnection to Inh server "
                                + iNewServer.ToString()
                                + ", IP address "
                                + ifaceinfo.IPAddressString);
                            
                            newConnections[iNewServer] = new AccelerationConnection(ifaceinfo, e.ValueNew[iNewServer], cluster);
                        }
                    }

                    // switch to the new connection list
                    cluster._connections = newConnections;

                    // rearrange the bucket map
                    for (int iBucket = 0; iBucket < cluster._bucketMap.Length; iBucket++)
                    {
                        cluster._bucketMap[iBucket] = iIndexMap[cluster._bucketMap[iBucket]];
                        if (cluster._bucketMap[iBucket] == -1)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SERVER_CHANGE_FAILED, "Could not map bucket " + iBucket.ToString() + "to server.  Check config for consistency.");
                        }
                    }
                }
                finally
                {
                    cluster._rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                cluster._rwlConnections.ReleaseReaderLock();
            }
        }

        public uint GetNumBuckets()
        {
            uint cBuckets = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cBuckets = (uint)_bucketMap.Length;
            _rwlConnections.ReleaseReaderLock();
            return cBuckets;
        }

        public uint GetNumServers()
        {
            uint cServers = 0;
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            cServers = (uint)_connections.Length;
            _rwlConnections.ReleaseReaderLock();
            return cServers;
        }

        public AccelerationConnection GetInhConnection(uint bucketNum)
        {
            AccelerationConnection xbcRet = null;
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                int iServer = _bucketMap[bucketNum];
                if (iServer != -1)
                {
                    xbcRet = _connections[iServer];
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return xbcRet;
        }

        public void RegisterNotificationHandler(Acceleration.AccelerationNotificationHandler notificationCallback)
        {
            _notificationCallback += notificationCallback;
        }

        public void RegisterNotificationFailureHandler(Acceleration.AccelerationNotificationFailureHandler failureCallback)
        {
            _failureCallback += failureCallback;
        }

        public void UnregisterHandlers()
        {
            _notificationCallback = null;
            _failureCallback = null;
        }

        public void ShutdownAll()
        {
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                LockCookie lc = _rwlConnections.UpgradeToWriterLock(LOCK_TIMEOUT);
                try
                {
                    Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL, "AccelerationConnection.ShutdownAll: called");
                    foreach (AccelerationConnection inhConnection in _connections)
                    {
                        inhConnection.Shutdown(true);
                    }
                    Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL, "AccelerationConnection.ShutdownAll: complete");
                }
                finally
                {
                    _rwlConnections.DowngradeFromWriterLock(ref lc);
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }
        }

        public void SendToAllServers(AccelerationMessageHeader[] requests)
        {
            SendToAllServers(requests, false);
        }
        
        public uint[] SendToAllServers(AccelerationMessageHeader[] requests, bool fWait)
        {
            int timeout = REPLY_TIMEOUT;
            uint[] retVals = null;
            
            _rwlConnections.AcquireReaderLock(LOCK_TIMEOUT);
            try
            {
                // need a copy per server.
                if (requests.Length != _connections.Length)
                {
                    throw new ApplicationException( "AccelerationConnection.SendToAllServers(): incorrect number of servers specified.  This should only happen during an Acceleration INH server list change.");
                }
                
                AccelerationContext context = new AccelerationContext(_connections.Length);

                // add all requests before sending any.
                for (uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    context.AddRequest(iServer, 0, requests[iServer]);
                }

                // now send the requests.
                for(uint iServer = 0; iServer < _connections.Length; iServer++)
                {
                    if (!(_connections[iServer].SendToServer(context._wtObjects[iServer])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iServer] = null;
                    }
                }

                if (fWait)
                {
                    if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
                    {
                        // timed out.  find all the missing replies and remove from waittables.
                        for (uint iServer = 0; iServer < context._wtObjects.Length; iServer++)
                        {
                            if ((context._wtObjects[iServer] != null) && (context._wtObjects[iServer]._response == null))
                            {
                                _connections[iServer].TimeoutWaitTableObject(context._wtObjects[iServer]);
                            }
                        }
                    }

                    retVals = new uint[_connections.Length];
                    for (uint iResponse = 0; iResponse < _connections.Length; iResponse++)
                    {
                        if ((context._wtObjects[iResponse] == null) || 
                            (context._wtObjects[iResponse]._response == null))
                        {
                            retVals[iResponse] = HResult.E_ABORT;
                        }
                        else
                        {
                            try
                            {
                                // parse the response.
                                AccelerationEmptyResponse response = new AccelerationEmptyResponse();
                                response.ReadBytes(context._wtObjects[iResponse]._response);

                                retVals[iResponse] = response.hr;
                            }
                            catch (Exception)
                            {
                                retVals[iResponse] = HResult.E_ABORT;
                            }                            
                        }
                    }
                }
            }
            finally
            {
                _rwlConnections.ReleaseReaderLock();
            }

            return retVals;
        }

        public void SendContext(AccelerationContext context)
        {
            int timeout = REPLY_TIMEOUT;
            try
            {
                timeout = Config.GetIntSetting(_timeoutSetting);
                if (timeout == 0)
                {
                    // this means acceleration is disabled.  dont bother trying to send anything.
                    return;
                }
            }
            catch (Exception)
            {
                // eat this is if the setting doesnt exist.
            }
            
            for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
            {
                if (context._wtObjects[iKey] != null)
                {
                    AccelerationConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                    if (!(xbc.SendToServer(context._wtObjects[iKey])))
                    {
                        // failed to send this object.
                        Interlocked.Decrement(ref context._keysRemaining);
                        context._wtObjects[iKey] = null;
                    }
                }
            }

            if ((context._keysRemaining > 0) && !(context._event.WaitOne(timeout, false)))
            {
                // timed out.  find all the missing replies and remove from waittables.
                for (uint iKey = 0; iKey < context._wtObjects.Length; iKey++)
                {
                    if ((context._wtObjects[iKey] != null) && (context._wtObjects[iKey]._response == null))
                    {
                        AccelerationConnection xbc = GetInhConnection(context._wtObjects[iKey]._bucket);
                        xbc.TimeoutWaitTableObject(context._wtObjects[iKey]);
                    }
                }
            }
        }



        internal static string GetTimeoutSetting(string iface)
        {
            switch (iface.ToLower())
            {
                case "notificationcache":
                    return Setting.NotificationCache_replyTimeout;
                    
                case "presencecache":
                    return Setting.PresenceCache_replyTimeout;
                    
                case "profilecache":
                    return Setting.ProfileCache_replyTimeout;
                    
                case "acceleration":
                    return Setting.acceleration_replyTimeout;
            }

            throw new ApplicationException("Unknown acceleration cluster interface: " + iface);
        }

        internal static FastFailHelper GetFastFailHelper(string iface)
        {
            switch (iface.ToLower())
            {
                case "notificationcache":
                    return new FastFailHelper(
                        Setting.NotificationCache_fastFailTimeoutThresholdCount, 
                        Setting.NotificationCache_fastFailTimeoutTimespanSeconds, 
                        Setting.NotificationCache_fastFailBlockIntervalSeconds);
                    
                case "presencecache":
                    return new FastFailHelper(
                        Setting.PresenceCache_fastFailTimeoutThresholdCount, 
                        Setting.PresenceCache_fastFailTimeoutTimespanSeconds, 
                        Setting.PresenceCache_fastFailBlockIntervalSeconds);
                    
                case "profilecache":
                    return new FastFailHelper(
                        Setting.ProfileCache_fastFailTimeoutThresholdCount, 
                        Setting.ProfileCache_fastFailTimeoutTimespanSeconds, 
                        Setting.ProfileCache_fastFailBlockIntervalSeconds);
                    
                case "acceleration":
                    return new FastFailHelper(
                        Setting.acceleration_fastFailTimeoutThresholdCount, 
                        Setting.acceleration_fastFailTimeoutTimespanSeconds, 
                        Setting.acceleration_fastFailBlockIntervalSeconds);
            }

            throw new ApplicationException("Unknown acceleration cluster interface: " + iface);
        }
    }

    internal class AccelerationConnection
    {
        internal const int SEND_QUEUE_TIMEOUT = 1000;

        private Socket _socket;
        private IInterfaceInfo _interfaceInfo;
        private string _serverName;
        private int _seqNum = 1;

        private AccelerationConnectionCluster _cluster;

        // asynch send stuff
        private bool _shutdown;
        private LockFreeQueue<AccelerationWaitTableObject> _sendQueue;
        private AutoResetEvent _sendQueueEvent;
        private Hashtable _waitTable;
        private XboxLiveThread _sendThread;
        private XboxLiveThread _receiveThread;

        // perf counter instance specific to this connection
        private AccelerationConnectionCounters _instanceCounters;

        private XboxLiveThread _notificationThread;
        private uint _lastChangeID = 0;
        
        public string GetServerName()
        {
            return _serverName;
        }

        public AccelerationConnection(IInterfaceInfo interfaceInfo, string serverName, AccelerationConnectionCluster cluster)
        {
            _cluster = cluster;
            
            // This contains the IP:port info we need to connect to the
            // INH server.
            _interfaceInfo = interfaceInfo;

            // we use the server name to match connections to buckets.
            _serverName = serverName;

            // Get a perf counter instance for this particular connection
            string instanceString = Config.ComponentName + " -> " + _interfaceInfo.Interface + " : " + _interfaceInfo.IPAddressString;
            _instanceCounters = AccelerationConnectionCounters.Total[instanceString];

            // We call Connect() here to create the initial socket and connect
            // it to the INH server. That way, if there are any fundamental
            // communications problems, this thread will see the SocketException
            // right away, and won't have to wait until a Send attempt fails.
            try
            {
                Connect();
            }
            catch (SocketException)
            {
                // dont puke here if the server isnt up yet.
            }

            _shutdown = false;

            // This is a queue of requests to be sent to the INH server.
            _sendQueue = new LockFreeQueue<AccelerationWaitTableObject>(false);

            // When a new item is put into the queue, this event is signaled,
            // which will wake up the SendThread if it has gone to sleep
            _sendQueueEvent = new AutoResetEvent(false);

            // This is a table of requests which have been sent to the INH
            // server, and are waiting on a response from the INH server
            // It is syncronized because it is shared between the SendThread,
            // the ReceiveThread, and the calling thread (via the Timeout method)
            _waitTable = Hashtable.Synchronized(new Hashtable());

            // Start the send thread
            _sendThread = new XboxLiveThread(new ThreadStart(this.SendThread));
            _sendThread.IsBackground = true;
            _sendThread.Start();

            // Start the receive thread
            _receiveThread = new XboxLiveThread(new ThreadStart(this.ReceiveThread));
            _receiveThread.IsBackground = true;
            _receiveThread.Start();

            // setup the notification poll thread.
            _notificationThread = new XboxLiveThread(new ThreadStart(this.PollForNotifications));
            _notificationThread.IsBackground = true;
            _notificationThread.Start();

            Xom.Trace(XomAreaName.AccelerationProxy,
                LogLevel.L_NORMAL,
                "AccelerationConnection.ctor: AccelerationConnection creation successful for "
                + _interfaceInfo.IPAddressString);
        }

        public void Shutdown()
        {
            Shutdown(true);
        }
        public void Shutdown(bool fWait)
        {
            Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL,
                "Acceleration.Shutdown: Shutdown called for InhConnection to "
                + _interfaceInfo.IPAddressString);

            // set the shutdown flag, which will tell the send and receive
            // threads to begin shutting down
            _shutdown = true;

            if (fWait)
            {
                // wait for the send and receive threads to shutdown
                _sendThread.Join();
                _receiveThread.Join();
                _notificationThread.Join();
            }

            Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_LOW,
                "Acceleration.Shutdown: InhConnection successfully shutdown for  "
                + _interfaceInfo.IPAddressString);
        }

        public bool IsValidConnection()
        {
            return (_socket != null && _socket.Connected);
        }

        // Gets the current socket connection, verifying the health of the socket
        // and (re)connecting it if required
        public void Connect()
        {
            if (IsValidConnection())
            {
                return;
            }
            
            try
            {
                _instanceCounters.ConnectionAttempts.Increment();
                AccelerationConnectionCounters.Total.ConnectionAttempts.Increment();
                
                // create a new socket
                Xom.Trace(XomAreaName.AccelerationProxy, LogLevel.L_NORMAL,
                    "XPNFD.InhConnection.GetSocket: creating new socket connection to "
                    + _interfaceInfo.IPAddressString);
                
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream,
                    ProtocolType.Tcp);

                // connect to the specified INH server
                IPEndPoint ipEndPoint =
                    new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                _socket.Connect(ipEndPoint);
            }
            catch (SocketException se)
            {
                Disconnect();
                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CONNECT_FAILED, "Could not establish socket to " + _serverName + ".  The server is probably not running yet.\r\n" + se.ToString());
            }
        }
        
        public void Disconnect()
        {
            lock (this)
            {
                if (_socket != null)
                {
                    try
                    {
                        _socket.Shutdown(SocketShutdown.Both);
                        _socket.Close();
                    }
                    catch (SocketException)
                    {
                        // eat any exception here.  we're closing anyway.
                    }
                    
                    _socket = null;
                }
            }
        }

        public bool Send(byte[] msg, uint seqNum)
        {
            bool fRetry = true;
            
            while ( IsValidConnection() )
            {
                try
                {
                    // break up msg into packets small enough to be received by the server.
                    int cbStart = 0;
                    int cbLeft = msg.Length;
                    while (cbLeft > 0)
                    {
                        int maxSize = (int)AccelerationDefs.ACCELERATION_MAX_PACKET_SIZE;
                        
                        if (cbStart > 0)
                        {
                            // this isnt the first packet.  make a continuation header to send first.
                            AccelerationMessageHeader header = new AccelerationMessageHeader(ACCELERATION_MSG_TYPES.XBMSG_CONTINUATION_REQ);

                            // the header contribuites to the packet size.
                            maxSize -= header.Size();
                            
                            header.dwMsgLen = (cbLeft > maxSize) ? AccelerationDefs.ACCELERATION_MAX_PACKET_SIZE : (uint)(cbLeft + header.Size());
                            header.dwSeqNum = seqNum;

                            // cant use header.WriteStream() here because it overwrites dwMsgLen.
                            MemoryStream stream = new MemoryStream();
                            BinaryWriter writer = new BinaryWriter(stream);
                            writer.Write(header.dwProtocolVersion);
                            writer.Write(header.dwMsgType);
                            writer.Write(header.dwMsgLen);
                            writer.Write(header.dwSeqNum);

                            // send the header
                            _socket.Send(stream.ToArray());
                        }
                        
                        int cbSent = _socket.Send(
                            msg, 
                            cbStart, 
                            (cbLeft > maxSize) ? maxSize : cbLeft,
                            SocketFlags.None);

                        cbStart += cbSent;
                        cbLeft -= cbSent;
                    }
                    
                    return true;
                }
                catch (SocketException se)
                {
                    Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SEND_FAILED, se, "Unexpected exception caught." + (fRetry ? " Will attempt 1 retry." : ""));
                    
                    if (fRetry)
                    {
                        fRetry = false;
                        Disconnect();
                        Connect();
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            
            Disconnect();
            return false;
        }

        public byte[] Recv()
        {
            if( IsValidConnection() )
            {
                try
                {
                    return ReceiveAccelerationMessage(_socket);
                }
                catch(Exception e)
                {
                    Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e, "Unexpected exception caught");
                }
            }
            
            Disconnect();
            return null;
        }

        protected uint GetNextSequenceNumber()
        {
            return (uint)Interlocked.Increment(ref _seqNum);
        }

        public bool SendToServer(AccelerationWaitTableObject wto)
        {
            // check fast fail first.
            if (_cluster._fastFailHelper.InFastFailState(_interfaceInfo.IPAddressString))
            {
                return false;
            }
            
            _instanceCounters.RequestRate.Increment();
            AccelerationConnectionCounters.Total.RequestRate.Increment();
            wto._waitTime = new XomRequestTimeElapsed();

            wto._seqnum = GetNextSequenceNumber();
            wto._request.dwSeqNum = wto._seqnum;
            _sendQueue.Enqueue(wto);
            _sendQueueEvent.Set();

            _instanceCounters.EnqueueRate.Increment();
            _instanceCounters.QueueSize.Increment();
            AccelerationConnectionCounters.Total.EnqueueRate.Increment();
            AccelerationConnectionCounters.Total.QueueSize.Increment();

            return true;
        }

        public void TimeoutWaitTableObject(AccelerationWaitTableObject wto)
        {
            // timed out waiting for a response.  remove it from the wait table.
            AccelerationWaitTableObject wtoRemoved;
            lock (_waitTable.SyncRoot)
            {
                wtoRemoved = (AccelerationWaitTableObject)_waitTable[wto._seqnum];
                _waitTable.Remove(wto._seqnum);
            }
            if (wtoRemoved != null)
            {
                _instanceCounters.WaitTableSize.Decrement();
                AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                _instanceCounters.ConcurrentRequests.Decrement();
                AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();
            }

            // report failure to fail fast.
            _cluster._fastFailHelper.ReportFailure(_interfaceInfo.IPAddressString, "Timed out.");

            _instanceCounters.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            _instanceCounters.RequestTimeAvgBase.Increment();
            AccelerationConnectionCounters.Total.RequestTimeAvg.IncrementBy(wto._waitTime.TimeElapsed);
            AccelerationConnectionCounters.Total.RequestTimeAvgBase.Increment();
        }            

        public void DrainSendQueue()
        {
            // loop until queue is empty
            while (true)
            {
                AccelerationWaitTableObject wto = (AccelerationWaitTableObject)_sendQueue.Dequeue();
                if (wto != null)
                {
                    bool fSent = false;
                    // queue is syncronized
                    try
                    {                        
                        // update the queue wait perf counters
                        long elapsed = wto._waitTime.TimeElapsed;
                        AccelerationConnectionCounters.Total.QueueWaitTimeAvg.IncrementBy(elapsed);
                        AccelerationConnectionCounters.Total.QueueWaitTimeAvgBase.Increment();
                        _instanceCounters.QueueWaitTimeAvg.IncrementBy(elapsed);
                        _instanceCounters.QueueWaitTimeAvgBase.Increment();

                        AccelerationConnectionCounters.Total.QueueSize.Decrement();
                        _instanceCounters.QueueSize.Decrement();

                        _instanceCounters.ConcurrentRequests.Increment();
                        AccelerationConnectionCounters.Total.ConcurrentRequests.Increment();
                        // if we are supposed to wait for a response from the
                        // INH server, then put this context into the wait
                        // table.
                        // We want to so this *before* we actually send,
                        // because the INH server could respond before we've 
                        // finished adding the context to the wait table.

                        // store the current time in the context
                        wto._waitTime = new XomRequestTimeElapsed();

                        _waitTable.Add(wto._seqnum, wto);

                        // update perf counters
                        AccelerationConnectionCounters.Total.WaitTableSize.Increment();
                        _instanceCounters.WaitTableSize.Increment();

                        // now do the send
                        Connect();
                        fSent = Send((byte[])(wto._request), wto._seqnum);
                    }
                    finally
                    {
                        if (!fSent)
                        {
                            _instanceCounters.ConcurrentRequests.Decrement();
                            AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();
                            
                            // removes the item from the wait table, regardless of if it's there or not.
                            AccelerationWaitTableObject wtoRemoved;
                            lock (_waitTable.SyncRoot)
                            {
                                wtoRemoved = (AccelerationWaitTableObject)_waitTable[wto._seqnum];
                                _waitTable.Remove(wto._seqnum);
                            }
                            if (wtoRemoved != null)
                            {
                                _instanceCounters.WaitTableSize.Decrement();
                                AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                            }

                            if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                            {
                                wto._context._event.Set();
                            }
                        }
                    }
                }
                else
                {
                    // queue is empty, break out of the loop and go back to sleep.
                    break;
                }
            }
        }

        public void SendThread()
        {
            try
            {
                // keep processing work items on the queue until we break out of
                // this loop because the _shutdown flag is set
                while (!_shutdown)
                {
                    try
                    {
                        // Wait for an item to be put on the queue
                        if (_sendQueueEvent.WaitOne(SEND_QUEUE_TIMEOUT, false))
                        {
                            // we have work to do
                            DrainSendQueue();
                        }
                    }
                    catch (Exception e)
                    {
                        try
                        {
                            // we don't want an exception to cause this thread to
                            // terminate, so we catch it, log it, and move along
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_SEND_FAILED, e, 
                                "Unexpected Exception thrown in SendThread for connection to INH at {0}",
                                _interfaceInfo.IPAddressString
                            );
                        }
                        catch (Exception)
                        {
                            // eat anything else that could possibly go wrong.
                        }
                    }
                }
            }
            finally
            {
                try
                {
                    // kill the socket. If we don't do this, the receive
                    // thread will never exit.
                    Disconnect();
                }
                catch (Exception)
                {
                    // eat anything else that could possibly go wrong.
                }
            }            
        }

        public void ReceiveMessage()
        {
            try
            {
                // read a response.
                byte[] rgbResp = Recv();
                if (rgbResp == null)
                {
                    return;
                }

                // get the sequence number
                AccelerationMessageHeader response = new AccelerationMessageHeader();
                response.ReadBytes(rgbResp);

                // find the matching Context in the wait table.
                AccelerationWaitTableObject wto;
                lock (_waitTable.SyncRoot)
                {
                    wto = (AccelerationWaitTableObject)_waitTable[response.dwSeqNum];
                    _waitTable.Remove(response.dwSeqNum);
                }

                if (wto == null)
                {
                    // this is expected for contexts that werent waiting (e.g. multi-server remove requests).  do nothing.
                }
                else
                {
                    _instanceCounters.ConcurrentRequests.Decrement();
                    AccelerationConnectionCounters.Total.ConcurrentRequests.Decrement();

                    wto._response = rgbResp;

                    // Update perf counters
                    long elapsed = wto._waitTime.TimeElapsed;
                    AccelerationConnectionCounters.Total.WaitTableSize.Decrement();
                    AccelerationConnectionCounters.Total.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    AccelerationConnectionCounters.Total.WaitTableWaitTimeAvgBase.Increment();
                    _instanceCounters.WaitTableSize.Decrement();
                    _instanceCounters.WaitTableWaitTimeAvg.IncrementBy(elapsed);
                    _instanceCounters.WaitTableWaitTimeAvgBase.Increment();
                    
                    _cluster._fastFailHelper.ReportSuccess(_interfaceInfo.IPAddressString);

                    if (0 == Interlocked.Decrement(ref wto._context._keysRemaining))
                    {
                        wto._context._event.Set();
                    }
                }
            }
            catch (Exception)
            {
                // Any exceptions at all leave the stream in a bad state. We could be half way
                // through a message, or the socket could have failed, or ?
                // In any of these situations, we invalidate the socket, so we will 
                // reconnect. If there are messages already in the receive buffer,
                // they are going to be lost.
                // Any affected contexts will eventually be timed out and removed from the wait
                // table. Since we didn't successfully receive a complete message
                // we don't really trust the sequence number enough to associate this
                // exception with any particular context, so we don't do anything
                // with the exception except log it.
                // However, during a shutdown, the send thread kills the socket for us,
                // so if we are shutting down, we just eat the exception and move merrily
                // along
                if (!_shutdown)
                {
                    Disconnect();
                    throw;
                }
            }
        }

        public void ReceiveThread()
        {
            // keep receiving messages from the INH server until we break out of
            // this loop because the _shutdown flag is set
            while (!_shutdown)
            {
                try
                {
                    // dont try to receive if the socket is dead.
                    if (IsValidConnection())
                    {
                        ReceiveMessage();
                    }
                    else
                    {
                        Thread.Sleep(1000);
                    }
                }
                catch (Exception e)
                {
                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e,
                            "Unexpected Exception thrown in ReceiveThread for InhConnection to {0}",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }

        public void PollForNotifications()
        {
            // dedicated socket for changelist requests.  this avoids having the changelist request block behind other
            // pending requests.  this is important because we expect notifications to result in reciprocal calls to query
            // the data for changed keys.  we dont want to wait for all of those queries to complete before learning
            // of any further changes.
            Socket sock = null;
            
            while (!_shutdown)
            {
                try
                {
                    Thread.Sleep(Config.GetIntSetting(Setting.acceleration_notificationPollInterval));
                    
                    if ((_cluster._notificationCallback == null) && (_cluster._failureCallback == null))
                    {
                        // nobody's listening.
                        goto lDone;
                    }

                    if (sock == null)
                    {
                        sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

                        // connect to the specified INH server
                        IPEndPoint ipEndPoint = new IPEndPoint(_interfaceInfo.IPAddress, _interfaceInfo.Port);
                        sock.Connect(ipEndPoint);

                        sock.ReceiveTimeout = 2 * Config.GetIntSetting(Setting.acceleration_notificationPollInterval);
                    }
                    
                    int timeout = AccelerationConnectionCluster.REPLY_TIMEOUT;
                    try
                    {
                        timeout = Config.GetIntSetting(_cluster._timeoutSetting);
                        if (timeout == 0)
                        {
                            // this means acceleration is disabled.  dont bother trying to send anything.
                            goto lDone;
                        }
                    }
                    catch (Exception)
                    {
                        // eat this is if the setting doesnt exist.
                    }
                    
                    uint hr = HResult.E_ABORT;
                        
                    AccelerationChangelistRequest request = new AccelerationChangelistRequest();
                    request.dwChangeID = _lastChangeID;

                    // send the changelist request
                    sock.Send((byte[])request);
                    byte[] rgbResponse = ReceiveAccelerationMessage(sock);

                    // here we should have a changelist response.
                    AccelerationChangelistResponse response = new AccelerationChangelistResponse();
                    try
                    {
                        // parse the response.
                        response.ReadBytes(rgbResponse);
                        hr = response.hr;
                    }
                    catch (Exception e)
                    {
                        hr = Acceleration.GetExtendedError(e, rgbResponse);
                    }

                    if (HResult.Failed(hr))
                    {
                        // arrgh?
                        goto lDone;
                    }

                    if (hr == HResult.S_FALSE)
                    {
                        // we dropped some notifications.  fire the failure callback.
                        if (_cluster._failureCallback != null)
                        {
                            try
                            {
                                _cluster._failureCallback();
                            }
                            catch (Exception e)
                            {
                                Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CALLBACK_EXCEPTION, e,
                                    "PollForNotifications() caught exception in failure callback"
                                );
                            }
                        }
                    }

                    // update the change id.
                    _lastChangeID = response.dwNewChangeID;

                    if (response.dwNumChanges == 0)
                    {
                        // no changes.
                        goto lDone;
                    }

                    // build the key list.
                    byte[][] rgKeys = new byte[response.dwNumChanges][];
                    for (int iKey = 0; iKey < rgKeys.Length; iKey++)
                    {
                        rgKeys[iKey] = response.rgChanges[iKey].rgbKey;
                    }

                    // call the notification callback
                    if (_cluster._notificationCallback != null)
                    {
                        try
                        {
                            _cluster._notificationCallback(rgKeys);
                        }
                        catch (Exception e)
                        {
                            Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_CALLBACK_EXCEPTION, e, "PollForNotifications() caught exception in notification callback");
                        }
                    }
                    
                lDone:

                    continue;
                }
                catch (Exception e)
                {
                    // reconnect after any socket error.
                    if ((e is SocketException) || (sock == null) || !sock.Connected)
                    {
                        sock = null;
                    }

                    // we don't want an exception to cause this thread to
                    // terminate, so we catch it, log it, and move along
                    try
                    {
                        Xom.NtEvent(XEvent.Id.ACCELERATION_PROXY_RECEIVE_FAILED, e,
                            "Unexpected Exception thrown in PollForNotifications for InhConnection to {0}.",
                            _interfaceInfo.IPAddressString
                        );
                    }
                    catch (Exception)
                    {
                        // eat anything else that could possibly go wrong.
                    }
                }
            }
        }


        public byte[] ReceiveAccelerationMessage(Socket sock)
        {
            // buffer to receive header.
            byte[] headerBuf = new byte[AccelerationDefs.ACCELERATION_MESSAGE_HEADER_SIZE];

            int cTotalBytes = 0;
            while (cTotalBytes < headerBuf.Length)
            {
                int cBytes = sock.Receive(headerBuf, cTotalBytes, headerBuf.Length - cTotalBytes, SocketFlags.None);
                if (cBytes == 0)
                {
                    throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Received 0 bytes");
                }
                else
                {
                    cTotalBytes += cBytes;
                }
            }

            AccelerationMessageHeader msgHeader = new AccelerationMessageHeader();
            msgHeader.ReadBytes(headerBuf);

            // basic checks on header
            if (msgHeader.dwProtocolVersion != AccelerationDefs.ACCELERATION_PROTOCOL_VERSION_CURRENT)
            {
                throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Protocol Mismatch.  protocol received = " + msgHeader.dwProtocolVersion);
            }
            if ((msgHeader.dwMsgType < (uint)ACCELERATION_MSG_TYPES.XBMSG_MIN_RESP) ||
                (msgHeader.dwMsgType > (uint)ACCELERATION_MSG_TYPES.XBMSG_MAX_RESP))
            {
                throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Unknown response type: " + msgHeader.dwMsgType);
            }
            
            // make a new buffer for header + data
            byte[] buf = new byte[msgHeader.dwMsgLen];

            // copy the header
            System.Buffer.BlockCopy(headerBuf, 0, buf, 0, headerBuf.Length);
            
            while (cTotalBytes < buf.Length)
            {
                int cBytes = sock.Receive(buf, cTotalBytes, buf.Length - cTotalBytes, SocketFlags.None);
                if (cBytes == 0)
                {
                    throw new ApplicationException( "AccelerationConnection.ReceiveAccelerationMessage(): Received 0 bytes");
                }
                else
                {
                    cTotalBytes += cBytes;
                }
            }

            return buf;
        }

    }
    
    [XomPerformanceCounterCategoryAttr( "Acceleration Proxy", "XBox Live Acceleration Service Proxy: Connections to Acceleration INH Servers", true )]
    public class AccelerationConnectionCounters : XomPerformanceCounterCategory
    {
        public virtual AccelerationConnectionCounters this[string instanceName]
        {
            get
            {
                return (AccelerationConnectionCounters) GetInstance(instanceName);
            }
        }

        static public AccelerationConnectionCounters Total = new AccelerationConnectionCounters();

        public AccelerationConnectionCounters() : base()
        {
            RequestRate.RawValue = 0;
            RequestTimeAvg.RawValue = 0;
            RequestTimeAvgBase.RawValue = 0;
            ConnectionAttempts.RawValue = 0;
            ConcurrentRequests.RawValue = 0;
            EnqueueRate.RawValue = 0;
            QueueSize.RawValue = 0;
            QueueWaitTimeAvg.RawValue = 0;
            QueueWaitTimeAvgBase.RawValue = 0;
            WaitTableSize.RawValue = 0;
            WaitTableWaitTimeAvg.RawValue = 0;
            WaitTableWaitTimeAvgBase.RawValue = 0;
        }

        [XomPerformanceCounterAttr(
            "Request Rate", 
            "Number of requests per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestRate;

        [XomPerformanceCounterAttr(
            "Request Time Average", 
            "Average time taken per request.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter RequestTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Request Time Average Base", 
            "Base for average time taken per request.", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter RequestTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Connection attempts", 
            "Total number of attempts to connect this socket.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConnectionAttempts;

        [XomPerformanceCounterAttr(
            "Concurrent requests", 
            "Total number of requests waiting for a response.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter ConcurrentRequests;

        [XomPerformanceCounterAttr(
            "Enqueue Rate", 
            "Number of requests per second added to send queue waiting to be sent to the INH server", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter EnqueueRate;

        [XomPerformanceCounterAttr(
            "Queue Size", 
            "Total number of requests in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter QueueSize;

        [XomPerformanceCounterAttr(
            "Queue Wait Time Average", 
            "Average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter QueueWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Queue Wait Time Average Base", 
            "Base for average time a request is in the send queue waiting to be sent to the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter QueueWaitTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Wait Table Size", 
            "Total number of requests waiting in the wait table for a response from the INH server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter WaitTableSize;

        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average", 
            "Average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter WaitTableWaitTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Wait Table Wait Time Average Base", 
            "Base for average time a request is waiting in the wait table waiting for a response from the INH server", 
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter WaitTableWaitTimeAvgBase;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ArbitrationProt.cs ===
/*==========================================================================
 *
 *  ArbitrationProt.cs -- This module defines the wire protocol for Arbitration service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using System.IO;
using STF.common.service;


namespace STF.common.protocol 
{
    public enum ArbitrationSessionOutcome { Undetermined, Successful, Minority, Failed, Problematic }

    public class ArbitrationXUIDAndTrust : WireData
    {
        [WireInfo(HexString=true)]
        public ulong qwUserID;
        [WireInfo(HexString=true)]
        public uint dwUserFlags;
        public float userTrust;
    }
    
    public class ArbitrationBundle : WireData
    {
        public int index;
        public uint count;
        public double totalTrust;
    }
    
    public class ArbitrationXboxInfo : WireData
    {
        public byte timeExtendCount;
        public byte reportCount;
        [WireInfo(HexString=true)]
        public ushort reportFlags;
        [WireInfo(HexString=true)]
        public ulong xboxID;
        public int userCount;
        [WireInfo(SizeParam="userCount")]        
        public ArbitrationXUIDAndTrust[] users;
        public double trust;
        public byte normalizedTrust;
        public int bundleIndex;
        public int diconnectedXboxCount;
        [WireInfo(SizeParam="diconnectedXboxCount", HexString=true)]        
        public ulong[] diconnectedXboxes;
    }

    public class ArbitrationSuspiciousInfo : WireData
    {
        public int type; // 1, 2, or 3
        public int messageLen;
        public string message;
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount", HexString=true)]        
        public ulong[] xboxes;
        public int userCount;
        [WireInfo(SizeParam="userCount", HexString=true)]        
        public ulong[] users;
    }

    public class ArbitrationTitleParameters : WireData
    {
        public double BaseTrust; // Base trust rewarded per Xbox
        public double MinorityQuorum;
        public double UserTournamentAmplification;
        public double PublisherTournamentAmplification;
        public uint BaseSessionTime;
        public double FermiK; // Constant in Fermi function
    }

    //
    // Request for DebugResult
    //
    public class ArbitrationDebugResultRequest : XRLObject2
    {
        public ushort version;
        [WireInfo(HexString=true)]
        public ushort flags;
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;

        public byte[] sessionKey
        {
            get
            {
                MemoryStream titleIDSessionIDAndNonceMemStream = new MemoryStream(20);
                BinaryWriter writer = new BinaryWriter(titleIDSessionIDAndNonceMemStream);
                writer.Write(titleID);
                writer.Write(sessionID);
                writer.Write(sessionNonce);
                return (byte[])titleIDSessionIDAndNonceMemStream.ToArray();
            }
        }
    }
    
    //
    // Response from DebugResult request
    //
    public class ArbitrationDebugResultResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint titleID;
        [WireInfo(HexString=true)]
        public ulong sessionID;
        [WireInfo(HexString=true)]
        public ulong sessionNonce;
        public ArbitrationTitleParameters titleParameters;
        [WireInfo(HexString=true)]
        public ushort flags;
        public ushort maxSessionSeconds;
        public ushort secondsLeftTillTimeout;
        public DateTime startTime;
        public double sessionSeconds;
        
        public int xboxCount;
        [WireInfo(SizeParam="xboxCount")]        
        public ArbitrationXboxInfo[] xboxes;

        public int teamTicketCount;
        
        public double totalTrust;
        public uint reportCount;
        public bool arbitrated;
        
        public int result; // ArbitrationSessionOutcome
        public int nonProblematicResult; // ArbitrationSessionOutcome
        public float trustModificationScale;

        public int bundleCount;
        [WireInfo(SizeParam="bundleCount")]        
        public ArbitrationBundle[] bundles;
        public int submittedBundleIndex;
        
        public int suspiciousInfoCount;
        [WireInfo(SizeParam="suspiciousInfoCount")]        
        public ArbitrationSuspiciousInfo[] suspiciousInfo;
    }
    
    
    // 
    // Request for ReportResult
    //
    public class ArbitrationReportResultRequest : XRLObject2
	{
		public class Flags
		{
			public const ushort VoluntarilyQuit=0x8000;
			public const ushort SessionHost=0x4000;
			public const ushort LostConnectivity=0x2000;
			public const ushort LostConnectivityInfoSubmit=0x1000;
			public const ushort SuspiciousInfo1Submit=0x0800;
			public const ushort SuspiciousInfo2Submit=0x0400;
			public const ushort SuspiciousInfo3Submit=0x0200;
			public const ushort StatsBundleInfoSubmit=0x0100;
			public const ushort TournamentBundleInfoSubmit=0x0080;

			public const ushort flagMask=VoluntarilyQuit|SessionHost|LostConnectivity|LostConnectivityInfoSubmit|SuspiciousInfo1Submit|SuspiciousInfo2Submit|SuspiciousInfo3Submit|StatsBundleInfoSubmit|TournamentBundleInfoSubmit;

		}

		public ushort protocolVersion=1;
		public ushort flags=0;
		public uint titleId=XOn.DASH_TITLE_ID;
		public ulong sessionId=0UL;
		public ulong sessionNonce=0UL;
		public LostConnectivityInfo lostConnectivityInfo=null;
		public SuspiciousInfo type1SuspiciousInfo= null;
		public SuspiciousInfo type2SuspiciousInfo= null;
		public SuspiciousInfo type3SuspiciousInfo= null;
		public StatsBundle statsBundle= null;
		public TournamentBundle tournamentBundle=null;
        

        public override void WriteStream(BinaryWriter binaryWriter)
        {
            binaryWriter.Write(protocolVersion);
            binaryWriter.Write(flags);
            binaryWriter.Write(titleId);
            binaryWriter.Write(sessionId);
            binaryWriter.Write(sessionNonce);
            if (lostConnectivityInfo != null) lostConnectivityInfo.WriteStream(binaryWriter);
    		if (type1SuspiciousInfo != null) type1SuspiciousInfo.WriteStream(binaryWriter);
    		if (type2SuspiciousInfo!= null) type2SuspiciousInfo.WriteStream(binaryWriter);
    		if (type3SuspiciousInfo!= null) type3SuspiciousInfo.WriteStream(binaryWriter);
    		if (statsBundle!= null) statsBundle.WriteStream(binaryWriter);
    		if (tournamentBundle!= null) tournamentBundle.WriteStream(binaryWriter);;
            
        }
            
        

    }
    
	/// <summary>
	/// Arbitration ReportResult request LostConnectivityInfo wiredata
	/// </summary>
	public class LostConnectivityInfo : WireData
	{
		public byte xboxPuidLen=0;
		public ulong[] xboxPuid=null;
	}
	
	/// <summary>
	/// Arbitration ReportResult request SuspiciousInfo wiredata
	/// </summary>
	public class SuspiciousInfo : WireData
	{
		public byte messageLen=0;
		public byte[] message=null;
		public byte relatedXboxLen=0;
		public ulong[] relatedXbox=null;
		public byte relatedUserLen=0;
		public ulong[] relatedUser=null;
	}

	/// <summary>
	/// Arbitration ReportResult request StatsBundle wiredata
	/// </summary>
	public class StatsBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}

	/// <summary>
	/// Arbitration ReportResult request TournamentBundle wiredata
	/// </summary>
	public class TournamentBundle : WireData
	{
		public uint bundleLen=0;
		public byte[] bundle=null;
	}
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\assert.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.diagnostics
{
    [ComVisible(false)]
    public class Assert
    {
        public static void IsTrue(bool f)
        {
            IsTrue(f, "Assertion failed!");
        }
        
        public static void IsTrue(bool f, string msg)
        {
            if (!f) 
                throw new AssertionFailedException(msg);
        }
        
        
        public static void AreEqual(int expected, int got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(int expected, int got, string msg)
        {
            if (expected != got)
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " does not equal " + got.ToString() + 
                    (msg == null ? "" : msg));
        }
        public static void AreEqual(uint expected, uint got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(uint expected, uint got, string msg)
        {
            if (expected != got)
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " (" + expected.ToString("x8") + ") " + 
                    "does not equal " + got.ToString() + " (" + got.ToString("x8") + ")" + 
                    (msg == null ? "" : msg));
        }
        public static void AreEqual(long expected, long got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(long expected, long got, string msg)
        {
            if (expected != got)
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " does not equal " + got.ToString() + 
                    (msg == null ? "" : msg));

        }
        public static void AreEqual(ulong expected, ulong got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(ulong expected, ulong got, string msg)
        {
            if (expected != got)
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " does not equal " + got.ToString() +
                    (msg == null ? "" : msg));
        }
        public static void AreEqual(IComparable expected, object got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(IComparable expected, object got, string msg)
        {
            if (expected == null && got == null)
            {
                return;
            }
            if (expected == null && got != null) {
                throw new AssertionFailedException("Assertion failed!  Expected null, Got " + got.ToString() +
                    (msg == null ? "" : msg));
            }
            if (expected != null && got == null) {
                throw new AssertionFailedException("Assertion failed!  Expected " + expected.ToString() + ", Got null" +
                    (msg == null ? "" : msg));
            }
            if (got.GetType() != expected.GetType()) {
               throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " is not the same type as " + got.ToString() +
                    (msg == null ? "" : msg));
            }
            if (0 != expected.CompareTo(got)) {
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " does not equal " + got.ToString() +
                    (msg == null ? "" : msg));
            }
        }

        public static void AreEqual(object expected, object got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(object expected, object got, string msg)
        {
            if (expected == null && got == null)
            {
                return;
            }
            if (expected == null && got != null) {
                throw new AssertionFailedException("Assertion failed!  Expected null, Got " + got.ToString() + 
                    (msg == null ? "" : msg));
            }
            if (expected != null && got == null) {
                throw new AssertionFailedException("Assertion failed!  Expected " + expected.ToString() + ", Got null" + 
                    (msg == null ? "" : msg));
            }
            if (got.GetType() != expected.GetType()) {
               throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " is not the same type as " + got.ToString() +
                    (msg == null ? "" : msg));
            }
            if (expected.ToString() != got.ToString()) {
                throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " does not equal " + got.ToString() +
                    (msg == null ? "" : msg));
            }
        }

        public static void AreEqual(Array expected, Array got)
        {
            AreEqual(expected, got, null);
        }
        public static void AreEqual(Array expected, Array got, string msg)
        {
            if (expected == null && got == null)
            {
                return;
            }
            if (expected == null && got != null) {
                throw new AssertionFailedException("Assertion failed!  Expected null, Got " + got.ToString() + 
                    (msg == null ? "" : msg));
            }
            if (expected != null && got == null) {
                throw new AssertionFailedException("Assertion failed!  Expected " + expected.ToString() + ", Got null" + 
                    (msg == null ? "" : msg));
            }
            
            if (expected.Length != got.Length) {
                throw new AssertionFailedException("Assertion failed!  Number of elements in first array don't equal the number of elements in the second!" + 
                    (msg == null ? "" : msg));
            }   
            if (expected.Length == 0) {
                return;
            }     
            if (got.GetValue(new int[] {0}).GetType() != expected.GetValue(new int[] {0}).GetType()) {
               throw new AssertionFailedException("Assertion failed!  " + expected.ToString() + " is not the same type as " + got.ToString() + 
                    (msg == null ? "" : msg));
            }
            for(int i = 0; i < expected.Length; i++)
            {
                if (expected.GetValue(new int[] {i}) is IComparable &&
                    got.GetValue(new int[] {i}) is IComparable)
                {
                    if (0 != ((IComparable)expected.GetValue(new int[] {i})).CompareTo(got.GetValue(new int[] {i}))) 
                    {
                        throw new AssertionFailedException("Assertion failed!  In element " + i + " of the array, " + expected.GetValue(new int[] {i}).ToString() + " does not equal " + got.GetValue(new int[] {i}).ToString() +
                            (msg == null ? "" : msg));
                    }    
                }
                else
                {
                    if (expected.GetValue(new int[] {i}) != got.GetValue(new int[] {i})) 
                    {
                        throw new AssertionFailedException("Assertion failed!  In element " + i + " of the array, " + expected.GetValue(new int[] {i}).ToString() + " does not equal " + got.GetValue(new int[] {i}).ToString() +
                            (msg == null ? "" : msg));
                    }    
                }                
                
                    
            }        
        }
    }
    
    [ComVisible(false)]
    public class AssertionFailedException : ApplicationException
    {
        public AssertionFailedException()                           : base()        {}
        public AssertionFailedException(string msg )                : base(msg)     {}
        public AssertionFailedException(string msg, Exception e)    : base(msg, e)  {}
        
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\BinaryWriterWrapper.cs ===
using System.IO;

namespace STF.common.service
{
    public class BinaryWriterWrapper:BinaryWriter
    {
	    public BinaryWriterWrapper(Stream s):base(s)
	    {
	    }

        public override void Write(byte [] arrData)
        {
    		if (null != arrData && 0 == arrData.Length)
    		{
                /*
                    The only case we want to handle is when the array is a Byte Array of 0 length
                    Because: Writing a zero length byte array into a HttpResponseStream in Dot Net 2.0 will throw an Argument Exception.
                             This does not happen in 1.1
                */
    			return;	
    		}

		    base.Write(arrData);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ArrayUtil.cs ===
using System;

namespace STF.common.utilities2
{
    public static class ArrayUtil
    {
        public static bool CompareArrays<T>(T[] left, T[] right) where T: IEquatable<T>
        {
            if (left.Length != right.Length)
            {
                return false;
            }

            for (int idx = 0; idx < left.Length; ++idx)
            {
                if (!left[idx].Equals(right[idx]))
                {
                    return false;
                }
            }

            return true;
        }

        public static void SplitArray<T>(T[] orig, int splitIdx, out T[] left, out T[] right)
        {
            if (orig.Length < splitIdx)
            {
                throw new ArgumentException(String.Format(
                        "Splitting an array that's smaller than the split index. Array length is {0}. Split index is {1}.",
                        orig.Length, splitIdx));
            }

            left = new T[splitIdx];
            right = new T[orig.Length - splitIdx];

            Array.ConstrainedCopy(orig, 0, left, 0, left.Length);
            Array.ConstrainedCopy(orig, splitIdx, right, 0, right.Length);
        }

        public static T[] CombineArrays<T>(params T[][] arrays)
        {
            // Iterate once to get the size.
            int size = 0;
            Array.ForEach(arrays, delegate(T[] ts) { size += ts.Length; } );

            // Iterate again to copy.
            T[] combined = new T[size];
            int copied = 0;
            Array.ForEach(arrays, delegate(T[] ts) { ts.CopyTo(combined, copied); copied += ts.Length; } );
            return combined;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AvatarAssetId.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace STF.common.config
{
    // An avatar asset id (sometimes call an avatar item id in places like XLAST)
    // is a structure packed into a guid.
    //
    // For reference, indexes into the byte array returned by System.Guid are ordered like this:
    //   03020100-0504-0706-0809-0a0b0c0d0e0f
    //
    // There are multiple version of the avatar asset id guid structure for different purposes.
    // The version is encoded into the low nybble of byte 7
    //
    // version 0 -> free avatar asset from console flash
    // version 1 -> awarded avatar asset
    // version 2 -> marketplace asset available for purchase
    //
    // The structure of free (TOC) assets (version 0) is as follows:
    // ID Structure:  gggggggg-xxxx-0y0b-Cppp-pppppppppppp
    //   g: Category mask
    //   x: TOC asset index
    //   y: Version
    //   b: Body mask
    //   p: asset pack id
    //
    // The structure of awarded assets (version 1) is as follows:
    // ID Structure:  gggggggg-xxxx-ryrb-Crrr-rrrrtttttttt
    //   g: Category mask
    //   x: Id unique to the title
    //   y: Version
    //   b: Body mask
    //   r: Random number generated by XLAST
    //   t: Title ID

    public class AvatarAssetId
    {
        public const byte AVATAR_ASSET_VERSION_FREE         = 0;
        public const byte AVATAR_ASSET_VERSION_AWARD        = 1;
        public const byte AVATAR_ASSET_VERSION_MARKETPLACE  = 2;

        public enum BodyType : byte
        {
            Unknown = 0,
            Male = 1,
            Female = 2,
            All = 3
        }

        public AvatarAssetId(Guid id)
        {
            this.id = id;
            this.bytes = id.ToByteArray();
        }

        private Guid id;
        public Guid Id
        {
            get { return id; }
        }

        private byte[] bytes;
        public byte[] Bytes
        {
            get { return bytes; }
        }

        public byte Version
        {
            get { return (byte)(bytes[7] & 0xF); }
        }

        public byte BodyTypeMask
        {
            get
            {
                return (byte)(bytes[6] & 0xF);
            }
        }

        public uint BodyComponent
        {
            get
            {
                return (((uint)bytes[3]) << 24) + (((uint)bytes[2]) << 16) + (((uint)bytes[1]) << 8) + (uint)bytes[0];
            }
        }

        public uint TitleId
        {
            get
            {
                if (Version != AVATAR_ASSET_VERSION_AWARD)
                    return 0;
                return (((uint)bytes[12]) << 24) + (((uint)bytes[13]) << 16) + (((uint)bytes[14]) << 8) + (uint)bytes[15];
            }
        }

        public uint AwardOrdinal
        {
            get
            {
                if (Version != AVATAR_ASSET_VERSION_AWARD)
                    return 0;
                return (((uint)bytes[5]) << 8) + (uint)bytes[4];
            }
        }

        public static implicit operator Guid(AvatarAssetId value)
        {
            return value.Id;
        }

        public static implicit operator AvatarAssetId(Guid value)
        {
            return new AvatarAssetId(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\BehaviorInjection.cs ===
using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Threading;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;

using STF.common.config;

namespace STF.common.service
{
    public abstract class BehaviorInjection
    {
        public string InjectionName { get { return _injectionName; } }
        public bool IsPassThrough { get { return _isPassThrough; } }
        public string InjectionLine
        {
            get { return String.Format("{0};{1};{2}", _injectionName, _specificParams, _genericParams); }
        }

        protected BehaviorInjection(string injectionName, string specificParams, string genericParams)
        {
            _injectionName = injectionName;
            _specificParams = specificParams;
            _genericParams = genericParams;
            _isPassThrough = ParameterParsingUtil.ParseAsNameValuePairs(genericParams)["passThrough"] != null;
        }

        private readonly string _injectionName;
        private readonly string _genericParams;
        private readonly string _specificParams;
        private readonly bool _isPassThrough;
    }


    public sealed class UrlRedirect : BehaviorInjection
    {
        public string Url { get { return _url; } }

        private UrlRedirect(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            _url = specificParams;
        }

        public static UrlRedirect Create(BehaviorRequest behaviorRequest)
        {
            return new UrlRedirect(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private readonly string _url;
    }

    internal sealed class SprocFailure : BehaviorInjection
    {
        public void PerformFailureAction(string db, string sproc)
        {
            if (StripDbPrefixes(sproc.ToLower()) == _sproc || StripWebstorePrefixes(db.ToLower()) == _db)
            {
                if (_timeoutInMs.HasValue)
                {
                    Thread.Sleep(_timeoutInMs.Value);
                }
                if (_ex != null)
                {
                    throw _ex;
                }
            }
        }

        private SprocFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            if (String.IsNullOrEmpty(parameters["sproc"]) && String.IsNullOrEmpty(parameters["db"]))
            {
                throw new Exception(String.Format("SprocFailure must have one of sproc name or db name associated with it, but neither was found in '{0}'.", specificParams));
            }
            if (!String.IsNullOrEmpty(parameters["sproc"])  && !String.IsNullOrEmpty(parameters["db"]))
            {
                throw new Exception(String.Format("SprocFailure must have one of sproc name or db name associated with it, but both were found in '{0}'.", specificParams));
            }
            if (String.IsNullOrEmpty(parameters["exception"]) && String.IsNullOrEmpty(parameters["timeoutMS"]))
            {
                throw new Exception(String.Format("SprocFailure must have at least one of 'exception' and 'timeoutMS' but neither was found in '{0}'.", specificParams));
            }

            if (!String.IsNullOrEmpty(parameters["sproc"]))
            {
                _sproc = StripDbPrefixes(parameters["sproc"].ToLower());
            }

            if (!String.IsNullOrEmpty(parameters["db"]))
            {
                _db = parameters["db"].ToLower();
            }

            if (!String.IsNullOrEmpty(parameters["timeoutMS"]))
            {
                _timeoutInMs = Int32.Parse(parameters["timeoutMS"]);
            }

            // Exception is harder--we need to find that exception type and create our exception to throw later.
            if (!String.IsNullOrEmpty(parameters["exception"]))
            {
                Type exType = Type.GetType(parameters["exception"], true);
                ConstructorInfo ci = exType.GetConstructor(new Type[] { typeof(string) });
                _ex = (Exception)ci.Invoke(new object[] { String.Format("Sproc '{0}' failing by client request.", _sproc) });
            }
        }

        // This actually only normalizes the sproc in one way, which I found to be
        // the most common in our codebase. A more sophisticated solution could be used
        // if we find things with brackets or somthing.
        private string StripDbPrefixes(string rawSproc)
        {
            string prefix = "dbo.";
            if (rawSproc.StartsWith(prefix))
            {
                return rawSproc.Remove(0, prefix.Length);
            }
            else
            {
                return rawSproc;
            }
        }

        private string StripWebstorePrefixes(string rawDb)
        {
            int separatorIndex = rawDb.LastIndexOf('\\');

            if (separatorIndex != -1)
            {
                return rawDb.Substring(separatorIndex + 1);
            }
            else
            {
                return rawDb;
            }
        }

        public static void HandleBehaviorInjection(string db, string sproc)
        {
            // Short-circuit on an empty stored-proc
            if (String.IsNullOrEmpty(db) && String.IsNullOrEmpty(sproc))
            {
                return;
            }

            List<SprocFailure> sprocFailures;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjections("SprocFailure", out sprocFailures))
            {
                sprocFailures.ForEach(delegate(SprocFailure sf) { sf.PerformFailureAction(db, sproc); });
            }
        }

        public static SprocFailure Create(BehaviorRequest behaviorRequest)
        {
            return new SprocFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private readonly string _sproc;
        private readonly string _db;
        private readonly Exception _ex;
        private readonly int? _timeoutInMs;
    }

    public sealed class ABCHFailure : BehaviorInjection
    {
        public static void HandleBehaviorInjectionFailure()
        {
            bool forceFail = ForceFailOn;
            if (forceFail)
            {
                throw new ApplicationException("ABCHFailure behavior injected.");
            }
        }

        public static bool ForceFailOn
        {
            get
            {
                ABCHFailure obj;
                return RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("ABCHFailure", out obj);
            }
        }

        private ABCHFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            if (!String.IsNullOrEmpty(specificParams))
            {
                throw new Exception(String.Format("ABCHFailure takes no parameters, but the parameter string '{0}' was passed.", specificParams));
            }
        }

        public static ABCHFailure Create(BehaviorRequest behaviorRequest)
        {
            return new ABCHFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }
    }


    public sealed class XbancMiss : BehaviorInjection
    {
        public bool ForceMiss { get { return true; } }

        public static bool HandleBehaviorInjectionQuery(uint[] retVals)
        {
            bool forceMiss = ForceMissOn;
            if (forceMiss)
            {
                for (int idx = 0; idx < retVals.Length; ++idx)
                {
                    retVals[idx] = HResult.S_FALSE;
                }
            }
            return forceMiss;
        }

        public static bool ForceMissOn
        {
            get
            {
                XbancMiss xbancMiss;
                return RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("XbancMiss", out xbancMiss) && xbancMiss.ForceMiss;
            }
        }

        private XbancMiss(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            if (!String.IsNullOrEmpty(specificParams))
            {
                throw new Exception(String.Format("XbancMiss takes no parameters, but the parameter string '{0}' was passed.", specificParams));
            }
        }

        public static XbancMiss Create(BehaviorRequest behaviorRequest)
        {
            return new XbancMiss(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }
    }

    public sealed class NpdbOverrideInjection : BehaviorInjection, ConfigInstance.IConfigurationOverride
    {
        public static string GetInjectedNpdbValue(string setting, string value)
        {
            List<NpdbOverrideInjection> npdbOverrides;
            if (!IsBlackListedSetting(setting) && RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjections("NpdbOverride", out npdbOverrides))
            {
                NpdbOverrideInjection noi = npdbOverrides.Find(delegate(NpdbOverrideInjection n) { return n._setting == setting; });
                if (noi != null)
                {
                    return noi._value;
                }
            }
            return value;
        }

        private NpdbOverrideInjection(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams, '\\');
            if (parameters.Count != 2 || String.IsNullOrEmpty(parameters["setting"]) || String.IsNullOrEmpty(parameters["value"]))
            {
                throw new Exception(String.Format(
                    "NpdbOverride takes exactly two parameters--'setting' and 'value'. Parameter string was {0}.", specificParams));
            }

            _setting = parameters["setting"];
            _value = parameters["value"];

            Config.DefaultInstance.ConfigurationOverride = this;
        }

        string ConfigInstance.IConfigurationOverride.GetInjectedNpdbValue(string setting, string value)
        {
            return NpdbOverrideInjection.GetInjectedNpdbValue(setting, value);
        }

        public static NpdbOverrideInjection Create(BehaviorRequest behaviorRequest)
        {
            return new NpdbOverrideInjection(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        private static bool IsBlackListedSetting(string setting)
        {
            return Array.Exists(s_blacklistedSettings, delegate(string s) { return setting == s; } );
        }

        private readonly string _setting;
        private readonly string _value;

        private static string[] s_blacklistedSettings = new string[] { Setting.bif_AllowBehaviorInjections };
    }


    public sealed class BehaviorRequest
    {
        public BehaviorRequest(string name, string specificParams, string genericParams)
        {
            // We need to trim the name before checking if the injection is registered
            _name = name.Trim();

            if (!RequestHeaderBehaviorInjectionMgr.IsBehaviorRegistered(_name))
            {
                throw new Exception(String.Format("Client is requesting unregistered behavior '{0}'.", name));
            }

            _specificParams = specificParams.Trim();
            _genericParams = genericParams.Trim();
        }

        public string Name { get { return _name; } }
        public string SpecificParams { get { return _specificParams; } }
        public string GenericParams { get { return _genericParams; } }

        private readonly string _name;
        private readonly string _specificParams;
        private readonly string _genericParams;
    }

    public sealed class DmpFailure : BehaviorInjection
    {
        public delegate void PostCallDelegate();

        internal class DmpApiBehavior
        {
            internal DmpApiBehavior(string api)
            {
                Api = api;
            }

            public string Api;
        }

        internal class DmpApiFailure : DmpApiBehavior
        {
            internal DmpApiFailure(string api, string error) : base(api)
            {
                Error = error;
            }
            public string Error;
        }

        internal class DmpApiTimeout : DmpApiBehavior
        {
            internal DmpApiTimeout(string api, int timeoutMillis) : base(api)
            {
                TimeoutMillis = timeoutMillis;
            }

            public int TimeoutMillis;
        }

        internal class DmpApiOutOfMemory : DmpApiBehavior
        {
            internal DmpApiOutOfMemory(string api) : base(api)
            {
            }
        }

        internal static DmpApiBehavior CreateNewDmpApiBehavior(string api, string error, string timeout)
        {
            if ( string.IsNullOrEmpty(api) )
            {
                throw new ArgumentNullException("CreateNewDmpApiBehavior must have an API name associated with it but none was found.");
            }

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new ArgumentException("CreateNewDmpApiBehavior must have either an error name or a timeout associated with it but none was found.");
            }

            if ( !string.IsNullOrEmpty(error) )
            {
                if ( error.Equals("System.OutOfMemoryException", StringComparison.InvariantCultureIgnoreCase) )
                {
                    return new DmpApiOutOfMemory(api);
                }
                else
                {
                    return new DmpApiFailure(api, error);
                }
            }
            else
            {
                int timeoutMillis = 1;
                return new DmpApiTimeout(api, timeoutMillis);
            }
        }

        internal static DmpApiBehavior CreateNewDmpApiBehavior(XmlReader rdr)
        {
            if ( rdr == null ) throw new ArgumentNullException("rdr");
            if ( rdr.NodeType != XmlNodeType.Element ) throw new ArgumentException("rdr must be positioned at an Element node.");

            string api = rdr.GetAttribute("api");
            string error = rdr.GetAttribute("error");
            string timeout = rdr.GetAttribute("timeout");

            return CreateNewDmpApiBehavior(api, error, timeout);
        }

        private DmpFailure(string injectionName, string specificParams, string genericParams) :
            base(injectionName, specificParams, genericParams)
        {
            List<DmpApiBehavior> apiBehaviorList = new List<DmpApiBehavior>();


            string xmlRootTag = "<" + injectionName + "List>";

            if ( specificParams.StartsWith(xmlRootTag) )
            {
                apiBehaviorList = InitBehaviorListFromXml(specificParams);
            }
            else
            {
                NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);
                string api = parameters["api"];
                string error = parameters["error"];
                string timeout = parameters["timeout"];

                apiBehaviorList.Add(CreateNewDmpApiBehavior(api, error, timeout));
            }

            _dmpApiBehaviors = apiBehaviorList;
        }

        private List<DmpApiBehavior> InitBehaviorListFromXml(string xmlText)
        {
            string rootElementName = this.InjectionName + "List";

            List<DmpApiBehavior> apiBehaviorList = new List<DmpApiBehavior>();

            XmlReader rdr = new XmlTextReader(new StringReader(xmlText));
            rdr.MoveToContent();
            while (rdr.EOF == false)
            {
                if (rdr.Name == rootElementName)
                {
                    if (rdr.NodeType == XmlNodeType.EndElement)
                    {
                        rdr.Skip();
                    }
                    else
                    {
                        rdr.ReadStartElement();
                    }
                    continue;
                }

                if (rdr.Name == this.InjectionName)
                {
                    apiBehaviorList.Add(CreateNewDmpApiBehavior(rdr));
                }
                rdr.Skip();
            }

            return apiBehaviorList;
        }

        private static bool CanRetryError(string dmpError)
        {
            switch (dmpError)
            {
            case "DMP_E_UNKNOWNSERVER_ERROR":
            case "DMP_E_CONFIGURATION_ERROR":
            case "DMP_E_SYSTEM_INTERNAL_ERROR":
            case "DMP_E_PROMO_POINTS_UNAVAILIABLE":
                return true;
            default:
                return false;
            }
        }

        public PostCallDelegate PerformFailureAction(string dmpApi, ref int timeout)
        {
            PostCallDelegate noop = delegate() { };

            foreach (DmpApiBehavior apiBehavior in _dmpApiBehaviors)
            {
                if (apiBehavior.Api.Equals(dmpApi, StringComparison.InvariantCultureIgnoreCase))
                {
                    if ( apiBehavior is DmpApiFailure)
                    {
                        string dmpError = ((DmpApiFailure)apiBehavior).Error;

                        string detailMessage = "This error was artifically injected and was not generated by the actual DMP service.";

                        string canRetry = CanRetryError(dmpError).ToString().ToLower();

                        string innerXml = string.Format("<DMPErrorInfo xmlns=\"http://schemas.microsoft.com/DMP/2004/09/API\"><Property>DMP</Property><Error>{0}</Error><DetailMessage>{1}</DetailMessage><CanRetry>{2}</CanRetry></DMPErrorInfo>", dmpError, detailMessage, canRetry);

                        // create a Details element to return in the SoapException
                        XmlDocument doc = new XmlDocument();
                        XmlNode detailNode = doc.CreateNode(XmlNodeType.Element, SoapException.DetailElementName.Name, SoapException.DetailElementName.Namespace);

                        // construct the SoapException
                        SoapException se = new SoapException(detailMessage, SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri, detailNode);

                        // overwrite the InnerXml with the serialized DMPErrorInfo
                        se.Detail.InnerXml = innerXml;

                        throw se;
                    }
                    else if ( apiBehavior is DmpApiOutOfMemory )
                    {
                        PostCallDelegate postCall = delegate()
                            {
                                throw new OutOfMemoryException(string.Format("Artificial OutOfMemory exception introduced by BehaviorInjection. Call to DMP.{0} was successfully made", apiBehavior.Api));
                            };

                        return postCall;
                    }
                    else if ( apiBehavior is DmpApiTimeout )
                    {
                       timeout = ((DmpApiTimeout)apiBehavior).TimeoutMillis;

                        // For timeouts, it is possible that the DMP API call can
                        // succeed even with a timeout of 1 ms specified.
                        //
                        // This is presumably because the web service call completes
                        // before the internal timer has a chance to fire.
                        //
                        // This delegate will be called immediately after the DMP call
                        // completes and will force an artifical timeout exception.
                        PostCallDelegate postCall = delegate()
                            {
                                throw new WebException(string.Format("Artificial timeout for {0} introduced by BehaviorInjection. Call to DMP.{0} was successfully made", apiBehavior.Api), WebExceptionStatus.Timeout);
                            };

                        return postCall;
                    }
                }
            }

            return noop;
        }

        public static PostCallDelegate HandleBehaviorInjection(string dmpApi, ref int timeout)
        {
            PostCallDelegate noop = delegate() { };

            if ( string.IsNullOrEmpty(dmpApi) )
            {
                return noop;
            }

            DmpFailure dmpFailure;
            if ( RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("DmpFailure", out dmpFailure) )
            {
                return dmpFailure.PerformFailureAction(dmpApi, ref timeout);
            }
            else
            {
                // not a timeout so return a noop delegate
                return noop;
            }
        }

        public static DmpFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DmpFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        List<DmpApiBehavior> _dmpApiBehaviors = null;
    }

    public sealed class PassportLoginFailure : BehaviorInjection
    {
        private PassportLoginFailure(string injectionName, string specificParams, string genericParams) :
            base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);
            string faultcode = parameters["faultcode"];
            string faultstring = parameters["faultstring"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(faultcode) && string.IsNullOrEmpty(timeout) )
            {
                throw new ArgumentNullException("PassportLoginFailure must have at least one of 'faultcode' or 'timeout' but neither was found in '{0}'.", specificParams);
            }

            if ( !string.IsNullOrEmpty(faultcode) )
            {
                _faultcode = faultcode;
                _faultstring = faultstring;
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 0;
                }
            }
        }

        public string PerformFailureAction(ref int timeout)
        {
            string xmlReply = null;

            if ( !string.IsNullOrEmpty(_faultcode) )
            {
                string xmlReplyFormat =
                    "<?xml version='1.0' encoding='UTF-8'?>" +
                    "<S:Envelope xmlns:S='http://schemas.xmlsoap.org/soap/envelope/' xmlns:wsse='http://schemas.xmlsoap.org/ws/2002/04/secext' xmlns:psf='http://schemas.microsoft.com/Passport/SoapServices/SOAPFault'>" +
                        "<S:Fault>" +
                            "<faultcode>0x{0}</faultcode>" +
                            "<faultstring>{1} (this error was artificially injected and was not returned by the actual Passport Login API)</faultstring>" +
                        "</S:Fault>" +
                    "</S:Envelope>";

                xmlReply = string.Format(xmlReplyFormat, (_faultcode ?? ""), (_faultstring ?? ""));
            }
            else
            {
                // If the timeout value is 0, force an artificial timeout WebException to be thrown.
                // Between the granularity of the .NET timeout mechanism and the low latency of the
                // Passport EncryptedProxiedAuth API, specifying a timeout of 1 millisecond often
                // results in a successful call rather than a timeout.
                if ( _timeoutMillis.HasValue && _timeoutMillis.Value == 0 )
                {
                    throw new WebException("Artificial timeout introduced by BehaviorInjection.  No call to WLID was actually made.", WebExceptionStatus.Timeout);
                }

                timeout = _timeoutMillis.Value;
            }

            return xmlReply;
        }

        public static string HandleBehaviorInjection(ref int timeout)
        {
            PassportLoginFailure ppFailure;
            if ( RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("PassportLoginFailure", out ppFailure) )
            {
                return ppFailure.PerformFailureAction(ref timeout);
            }

            return null;
        }

        public static PassportLoginFailure Create(BehaviorRequest behaviorRequest)
        {
            return new PassportLoginFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string  _faultcode     = string.Empty;
        string  _faultstring   = string.Empty;
        int?    _timeoutMillis = 0;
    }

    public sealed class MusicnetFailure : BehaviorInjection
    {
        public void PerformFailureAction(string api, string server, string transactionId, ref int timeout)
        {
            if ( api.Equals(_api, StringComparison.InvariantCultureIgnoreCase) )
            {
                if ( _timeoutMillis.HasValue )
                {
                    timeout = _timeoutMillis.Value;
                }
                else
                {
                    string detailMsg = "This error was artifically injected and was not generated by the actual DMP service.";

                    string innerXml = string.Format("<EcommerceB2BServiceException xmlns=\"http://ws.musicnet.com\"><code>{0}</code><details>{1}</details><message>{2}</message><server>{3}</server><transactionId>{4}</transactionId></EcommerceB2BServiceException>", _error, detailMsg, _message ?? "", server, transactionId);

                    // create a Details element to return in the SoapException
                    XmlDocument doc = new XmlDocument();
                    XmlNode detailNode = doc.CreateNode(XmlNodeType.Element, SoapException.DetailElementName.Name, SoapException.DetailElementName.Namespace);

                    // construct the SoapException
                    SoapException se = new SoapException(detailMsg, SoapException.ClientFaultCode, HttpContext.Current.Request.Url.AbsoluteUri, detailNode);

                    // overwrite the InnerXml with the serialized DMPErrorInfo
                    se.Detail.InnerXml = innerXml;

                    throw se;
                }
            }
        }

        private MusicnetFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("MusicnetFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("MusicnetFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(error) )
            {
                _error = error;
                _message = parameters["message"];
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 1;
                }
            }

        }

        public static void HandleBehaviorInjection(string api, string transactionId, ref int timeout)
        {
            MusicnetFailure mnetFailure;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("MusicnetFailure", out mnetFailure))
            {
                mnetFailure.PerformFailureAction(api, Environment.MachineName, transactionId, ref timeout);
            }
        }

        public static MusicnetFailure Create(BehaviorRequest behaviorRequest)
        {
            return new MusicnetFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string _api = string.Empty;
        string _error = string.Empty;
        string _message = string.Empty;
        int?   _timeoutMillis;
    }

    public sealed class DummyScsFailure : BehaviorInjection
    {
        private DummyScsFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("ScsFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("DummyScsFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }
        }

        public static DummyScsFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyScsFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
        }
    }
    public sealed class DummyCTPFailure : BehaviorInjection
    {
        private DummyCTPFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if (string.IsNullOrEmpty(api))
            {
                throw new Exception(String.Format("ctpFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if (string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout))
            {
                throw new Exception(String.Format("DummyCTPFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }
        }

        public static DummyCTPFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyCTPFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
        }
    }

    public sealed class UpsFailure : BehaviorInjection
    {
        private UpsFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("UpsFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("UpsFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(timeout) )
            {
                _timeoutMillis = Int32.Parse(timeout);
            }
            else
            {
                _timeoutMillis = 0;
            }
        }

        public static void HandleBehaviorInjection(string api, ref int timeout)
        {
            UpsFailure upsFailure;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("UpsFailure", out upsFailure))
            {
                upsFailure.PerformFailureAction(api, ref timeout);
            }
        }

        public static UpsFailure Create(BehaviorRequest behaviorRequest)
        {
            return new UpsFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
            if ( api.Equals(_api, StringComparison.InvariantCultureIgnoreCase) )
            {
                // If the timeout value is 0, force an artificial timeout WebException to be thrown.
                // Between the granularity of the .NET timeout mechanism and the low latency of UPS,
                // specifying a timeout of 1 millisecond often results in a successful call rather than
                // a timeout.
                if ( _timeoutMillis.HasValue )
                {
                    if ( _timeoutMillis.Value == 0 )
                    {
                        throw new WebException("Artificial UPS timeout introduced by BehaviorInjection.  No call to UPS was actually made.", WebExceptionStatus.Timeout);
                    }
                    else
                    {
                        timeout = _timeoutMillis.Value;
                    }
                }
            }
        }

        string _api;
        int? _timeoutMillis;
    }

    public sealed class DummyFinBusFailure : BehaviorInjection
    {
        public void PerformFailureAction(string api, ref int timeout)
        {
            // This method should never be called because the FinBusPublisher service will replace the
            // behavior injection handler for FinBusFailure with one that has the EDIS FaultException
            // contract compiled in.
            throw new Exception(string.Format("DummyFinBusFailure.PerformFailureAction: called for api: {0}; this should never happen!", api));
        }

        private DummyFinBusFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("FinBusFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string errorCode = parameters["errorCode"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(errorCode) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("FinBusFailure must have at least one of 'errorCode' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(errorCode) )
            {
                // 1002 is the one known error code that has been returned by FinBus
                _errorCode = SafeConvert.ToInt32(errorCode, 1002);
                _message = parameters["message"];
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 1;
                }
            }

        }

        public static void HandleBehaviorInjection(string api, ref int timeout)
        {
            // This method should never be called because the FinBusPublisher service will replace the
            // behavior injection handler for FinBusFailure with one that has the EDIS FaultException
            // contract compiled in.
            throw new Exception(string.Format("DummyFinBusFailure.HandleBehaviorInjection: called for api: {0}; this should never happen!", api));
        }

        public static DummyFinBusFailure Create(BehaviorRequest behaviorRequest)
        {
            return new DummyFinBusFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        string _api = string.Empty;
        int? _errorCode;
        string _message = string.Empty;
        int?   _timeoutMillis;
    }

    public static class ParameterParsingUtil
    {
        public static List<BehaviorRequest> ParseAllBehaviors(string allBehaviors)
        {
            List<BehaviorRequest> behaviorRequests = new List<BehaviorRequest>();
            if (!String.IsNullOrEmpty(allBehaviors))
            {
                foreach (string request in allBehaviors.Split(','))
                {
                    behaviorRequests.Add(ParseBehaviorLine(request));
                }
            }
            return behaviorRequests;
        }

        public static NameValueCollection ParseAsNameValuePairs(string nameValueParams)
        {
            return ParseAsNameValuePairsImpl(nameValueParams, GetSplittingStrategy(null));
        }

        public static NameValueCollection ParseAsNameValuePairs(string nameValueParams, char escapeChar)
        {
            return ParseAsNameValuePairsImpl(nameValueParams, GetSplittingStrategy(escapeChar));
        }

        private static NameValueCollection ParseAsNameValuePairsImpl(string nameValueParams, ISplittingStrategy splitter)
        {
            NameValueCollection nvc = new NameValueCollection();

            if (!String.IsNullOrEmpty(nameValueParams))
            {
                foreach (string nameValue in splitter.Split(nameValueParams, ':'))
                {
                    string[] nameAndValue = nameValue.Split('=');
                    if (nameAndValue.Length != 2)
                    {
                        throw new Exception(String.Format(
                            "The behavior injection parameter string '{0}' parses incorrectly at parameter '{1}'.", nameValueParams, nameValue));
                    }
                    nvc[nameAndValue[0]] = nameAndValue[1];
                }
            }
            return nvc;
        }

        private static BehaviorRequest ParseBehaviorLine(string line)
        {
            string[] requestParts = line.Split(';');
            return new BehaviorRequest(requestParts[0], requestParts[1], requestParts.Length == 3 ? requestParts[2] : String.Empty);
        }

        private static ISplittingStrategy GetSplittingStrategy(char? escape)
        {
            if (escape.HasValue)
            {
                return new EscapingSplittingStrategy(escape.Value);
            }
            else
            {
                return NormalSplittingStrategy.GetInstance();
            }
        }

        private interface ISplittingStrategy
        {
            string[] Split(string s, char delim);
        }

        private class NormalSplittingStrategy : ISplittingStrategy
        {
            private NormalSplittingStrategy() { }

            public static NormalSplittingStrategy GetInstance()
            {
                return _instance;
            }

            public string[] Split(string s, char delim)
            {
                return s.Split(delim);
            }

            private static NormalSplittingStrategy _instance = new NormalSplittingStrategy();
        }

        private class EscapingSplittingStrategy : ISplittingStrategy
        {
            public EscapingSplittingStrategy(char escape)
            {
                _escape = escape;
            }

            public string[] Split(string s, char delim)
            {
                // First, replace escaped chars with a special character--converting the char to a string because for some reason replace won't do that.
                s = s.Replace(String.Format("{0}{1}", _escape, delim), new string(SPECIAL_CHAR, 1));

                // Now do our normal split:
                string[] initialSplit = s.Split(delim);

                // Walk through the initial split and replace the spacial character with the delimiter.
                return Array.ConvertAll<string, string>(initialSplit, delegate(string init) { return init.Replace(SPECIAL_CHAR, delim); });
            }

            private readonly char _escape;
            private const char SPECIAL_CHAR = (char)0x14; // This is the "Device Control 4" in the ASCII table. Hard to imagine anything having this in it.
        }
    }


    public static class RequestHeaderBehaviorInjectionMgr
    {
        static RequestHeaderBehaviorInjectionMgr()
        {
            AddBehaviorInjectionFactory("AlternateBillingUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateMusicNetUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateDmpUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateWmisUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePassportUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpCredentialServiceApiUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpProfileServiceApiUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternatePpEncryptedProxiedAuthUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateUpsUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateABCHUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateSingleRatingSessionUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateAggregatorSessionUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("AlternateFinBusUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
            AddBehaviorInjectionFactory("SprocFailure", SprocFailure.Create, BehaviorInjectionFactoryFlags.AllowMultiple);
            AddBehaviorInjectionFactory("XbancMiss", XbancMiss.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("ABCHFailure", ABCHFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("NpdbOverride", NpdbOverrideInjection.Create, BehaviorInjectionFactoryFlags.AllowMultiple);
            AddBehaviorInjectionFactory("DmpFailure", DmpFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("PassportLoginFailure", PassportLoginFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("MusicnetFailure", MusicnetFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("ScsFailure", DummyScsFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("UpsFailure", UpsFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("FinBusFailure", DummyFinBusFailure.Create, BehaviorInjectionFactoryFlags.None);
            AddBehaviorInjectionFactory("AlternateCTPUrl", UrlRedirect.Create, BehaviorInjectionFactoryFlags.AllowLegacy);
        }

        public static bool TryGetBehaviorInjection<T>(string injectionName, out T t)
            where T : BehaviorInjection
        {
            t = null;

            // If we don't allow injections at all, let's not incur this cost and potential for errors.
            if (!AllowBehaviorInjection)
            {
                return false;
            }

            if (TestBehaviorInjectionFactoryFlags(injectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
            {
                throw new Exception(String.Format(
                    "Injection '{0}' allows multiples, but you are asking for only one. That is likely an error.", injectionName));
            }

            List<T> ts = null;
            if (TryGetBehaviorInjectionsImpl(injectionName, out ts))
            {
                t = ts[0];
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool TryGetBehaviorInjections<T>(string injectionName, out List<T> ts)
            where T : BehaviorInjection
        {
            ts = null;

            // If we don't allow injections at all, let's not incur this cost and potential for errors.
            if (!AllowBehaviorInjection)
            {
                return false;
            }

            if (!TestBehaviorInjectionFactoryFlags(injectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
            {
                throw new Exception(String.Format(
                    "Injection {0} does not have the BehaviorInjectionFactoryFlags.AllowMultiple flag, but you asked for multiple.", injectionName));
            }

            return TryGetBehaviorInjectionsImpl(injectionName, out ts);
        }

        private static bool TryGetBehaviorInjectionsImpl<T>(string injectionName, out List<T> ts)
            where T : BehaviorInjection
        {
            // See if we have a registered behavior injection for this name. If not, that is considered an error,
            // since someone missed a step in creating the injection point.

            if (!IsBehaviorRegistered(injectionName))
            {
                throw new Exception(
                    String.Format("Attempting to get an injection behavior object for a non-registered injection name '{0}'.", injectionName));
            }

            ts = null;

            // Get the headers--if they are there, we have work to do. Otherwise, we just return false;
            List<BehaviorInjection> injections = null;
            if (!s_tdh.Data.TryGetValue(injectionName, out injections))
            {
                return false;
            }
            // Use our creation delegate to crfeate a BehaviorInjection-derived class.
            ts = injections.ConvertAll<T>(delegate(BehaviorInjection bi) { return (T) bi; } );
            return true;
        }


        public static void AddBehaviorInjections(NameValueCollection headers)
        {
            // If we allow behavior injections, then parse everything out.
            // If not, then we rely on the fact that s_tdh will always return us a valid
            // (empty) dictionary and therefore lookups will fail gracefully.
            if (AllowBehaviorInjection)
            {
                s_tdh.Data = new BehaviorInjectionDictionary(headers);
            }
        }

        public static void AddPassThroughBehaviorInjections(NameValueCollection headers)
        {
            foreach (List<BehaviorInjection> bis in s_tdh.Data.Values)
            {
                foreach (BehaviorInjection bi in bis)
                {
                    if (bi.IsPassThrough)
                    {
                        headers.Add(BEHAVIOR_INJECTION_KEY, bi.InjectionLine);
                    }
                }
            }
        }

        public static void ClearBehaviorInjections()
        {
            s_tdh.Data = null;
        }

        public static bool IsBehaviorRegistered(string behaviorName)
        {
            return FindRegisteredBehavior(behaviorName) != null;
        }

        private static BehaviorInjectionFactory FindRegisteredBehavior(string behaviorName)
        {
            return _behaviorInjectionFactories[behaviorName.ToLower()];
        }

        public static void AddBehaviorInjectionFactory(string behaviorName, BehaviorInjectionFactoryDelegate factoryDelegate, BehaviorInjectionFactoryFlags factoryFlags)
        {
            BehaviorInjectionFactory factory = new BehaviorInjectionFactory(behaviorName, factoryDelegate, factoryFlags);

            // add all factories to the dictionary
            _behaviorInjectionFactories.Add(behaviorName.ToLower(), factory);

            // legacy factories also need to be added to the legacy list
            if ( (factoryFlags & BehaviorInjectionFactoryFlags.AllowLegacy) == BehaviorInjectionFactoryFlags.AllowLegacy )
            {
                _legacyBehaviorInjectionFactories.Add(factory);
            }
        }

        public static void RemoveBehaviorInjectionFactory(string behaviorName)
        {
            _behaviorInjectionFactories.Remove(behaviorName.ToLower());
        }

        private static bool TestBehaviorInjectionFactoryFlags(string injectionName, BehaviorInjectionFactoryFlags flags)
        {
            return (FindRegisteredBehavior(injectionName).Flags & flags) == flags;
        }

        private static bool AllowBehaviorInjection
        {
            get
            {
                return Config.IsTestEnvironment() && Config.GetBoolSetting(Setting.bif_AllowBehaviorInjections);
            }
        }

        private sealed class BehaviorInjectionDictionary : Dictionary<string, List<BehaviorInjection>>
        {
            public BehaviorInjectionDictionary()
            {
            }

            public BehaviorInjectionDictionary(NameValueCollection headers)
            {
                // Get all the "new version" injections.
                AddBehaviorRequests(headers[BEHAVIOR_INJECTION_KEY]);

                // Get all the "legacy" injections.
                AddLegacyBehaviorRequests(headers);
            }

            private void AddBehaviorRequests(string requestHeader)
            {
                List<BehaviorRequest> behaviorRequests = ParameterParsingUtil.ParseAllBehaviors(requestHeader);
                behaviorRequests.ForEach(AddItem);
            }

            private void AddLegacyBehaviorRequests(NameValueCollection headers)
            {
                foreach (BehaviorInjectionFactory bif in _legacyBehaviorInjectionFactories)
                {
                    if (headers[bif.BehaviorName] != null)
                    {
                        AddItem(new BehaviorRequest(bif.BehaviorName, headers[bif.BehaviorName], String.Empty));
                    }
                }
            }

            private void AddItem(BehaviorRequest br)
            {
                AddItem(FindRegisteredBehavior(br.Name).FactoryDelegate(br));
            }

            private void AddItem(BehaviorInjection bi)
            {
                if (ContainsKey(bi.InjectionName))
                {
                    if (!TestBehaviorInjectionFactoryFlags(bi.InjectionName, BehaviorInjectionFactoryFlags.AllowMultiple))
                    {
                        throw new Exception(String.Format("Can only specify injection '{0}' once per request.", bi.InjectionName));
                    }
                }
                else
                {
                    this[bi.InjectionName] = new List<BehaviorInjection>();
                }

                this[bi.InjectionName].Add(bi);
            }
        }

        private static ThreadDataHelper<BehaviorInjectionDictionary> s_tdh = new ThreadDataHelper<BehaviorInjectionDictionary>();
        public readonly static string BEHAVIOR_INJECTION_KEY = "BEHAVIOR_INJECTIONS";

        // All active BehaviorInjectionFactories are tracked in this dictionary.  The key is
        // the behaviorName (e.g. "StoredProc", "ScsFailure") in lower-case.
        private static Dictionary<string,BehaviorInjectionFactory> _behaviorInjectionFactories = new Dictionary<string,BehaviorInjectionFactory>();


        // Legacy factories need to be quickly accessed so while they exist in the dictionary,
        // they are also tracked separately in a legacy-specific list so the dictionary does not
        // need to be scanned every time an injection is handled.
        private static List<BehaviorInjectionFactory> _legacyBehaviorInjectionFactories = new List<BehaviorInjectionFactory>();

        public delegate BehaviorInjection BehaviorInjectionFactoryDelegate(BehaviorRequest behaviorRequest);

        [Flags]
        public enum BehaviorInjectionFactoryFlags
        {
            None            = 0x00,
            AllowLegacy     = 0x01,
            AllowMultiple   = 0x02,
        }

        private sealed class BehaviorInjectionFactory
        {
            public BehaviorInjectionFactory(string behaviorName, BehaviorInjectionFactoryDelegate factoryDelegate, BehaviorInjectionFactoryFlags flags)
            {
                _behaviorName = behaviorName;
                _factoryDelegate = factoryDelegate;
                _flags = flags;
            }

            public string BehaviorName { get { return _behaviorName; } }
            public BehaviorInjectionFactoryDelegate FactoryDelegate { get { return _factoryDelegate; } }
            public BehaviorInjectionFactoryFlags Flags { get { return _flags; } }

            private readonly string _behaviorName;
            private readonly BehaviorInjectionFactoryDelegate _factoryDelegate;
            private readonly BehaviorInjectionFactoryFlags _flags;
        }
    }


    /*
     * Thin wrapper over TLS data. Pretty simple.
     */
    internal sealed class ThreadDataHelper<T>
        where T : class, new()
    {
        public ThreadDataHelper()
        {
            _tls = Thread.AllocateDataSlot();
        }

        public T Data
        {
            get { return (T) (Thread.GetData(_tls) ?? new T()); }
            set { Thread.SetData(_tls, value); }
        }

        private LocalDataStoreSlot _tls;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AvatarManifest.cs ===
using System;
using System.IO;
using STF.common.config;

namespace STF.common.service
{
    public class AvatarManifest : WireData
    {
        // A note about byte ordering:
        // This structure is generally manipulated on an Xbox 360 and sent to
        // the service as a byte stream (varbinary(1000)). So integer members are
        // generally stored in the byte stream in big-endian format.

        // *********
        // XDK classes
        // *********

        // ARGB Color; 8-8-8-8 bit unsigned normalized integer components packed into
        // a 32 bit integer.  The normalized color is packed into 32 bits using 8 bit
        // unsigned, normalized integers for the alpha, red, green, and blue components.
        // The alpha component is stored in the most significant bits and the blue
        // component in the least significant bits (A8R8G8B8):
        // [32] aaaaaaaa rrrrrrrr gggggggg bbbbbbbb [0]
        public class XMCOLOR : WireData
        {
            // note: C# doesn't have unions, so we just keep the uint
            [WireInfo(BigEndian = false)]
            public uint c;
        }

        public enum XAVATAR_COMPONENT_MASK : ushort
        {
            None        = 0x0000,
            Head        = 0x0001,
            Body        = 0x0002,
            Hair        = 0x0004,
            Shirt       = 0x0008,
            Trousers    = 0x0010,
            Shoes       = 0x0020,
            Hat         = 0x0040,
            Gloves      = 0x0080,
            Glasses     = 0x0100,
            Wristwear   = 0x0200,
            Earrings    = 0x0400,
            Ring        = 0x0800,
            Carryable   = 0x1000,
            All         = 0x1FFF
        }

        public enum XAVATAR_COMPONENT
        {
             Head       =  0,
             Body       =  1,
             Hair       =  2,
             Shirt      =  3,
             Trousers   =  4,
             Shoes      =  5,
             Hat        =  6,
             Gloves     =  7,
             Glasses    =  8,
             Wristwear  =  9,
             Earrings   = 10,
             Ring       = 11,
             Carryable  = 12,
             Count      = 13,
             ForceDWORD = 0x7fffffff
        }

        public class XAVATAR_COMPONENT_INFO : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId            ModelAssetId;

            [WireInfo(BigEndian = true)]
            public ushort ComponentMask;

            public ushort padding;

            [WireInfo(ArraySize = 3)]
            public XMCOLOR[]                CustomColors = new XMCOLOR[3];
        }

        const int CONSOLE_ID_SIZE = 5;

        // *********
        // supporting enums and classes
        // *********

        // Scoped enumeration of blend shapes that can be applied to an 
        // avatar model after loading.
        public enum Shape_e
        {
            Chin = 0,
            Nose,
            Ear,
            Count
        };

        // Scoped enumeration of dynamic textures that can be applied to an
        // avatar model after loading.
        public enum Texture_e
        {
            Mouth = 0,
            Eye,
            EyeBrow,
            FacialHair,
            EyeShadow,
            SkinFeatures,
            Count
        };

        // Scoped enumeration of dynamic colors that can be applied to an
        // avatar model using pixel shader constants.
        public enum Color_e
        {
            Skin = 0,
            Hair,
            Mouth,
            Iris,
            EyeBrow,
            EyeShadow,
            FacialHair,
            SkinFeatures1,
            SkinFeatures2,
            Count
        };

        // A 2d scale, rotation, translation matrix representing the exact
        // placement of a dynamic texture on the avatar.
        public class TexturePlacement_c : WireData
        {
            [WireInfo(BigEndian = true)]
            public float                Scale;
            [WireInfo(BigEndian = true)]
            public float Rotation;
            [WireInfo(BigEndian = true, ArraySize = 2)]
            public float[]              Translation = new float[2];
        };

        // Structure defining a single replacement texture, including the
        // the asset to replace it with, and placement of the texture.
        public class ReplacementTexture_c : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId        TextureAssetId;
            public TexturePlacement_c   Placement;
        };

        // Structure defining a single blend-shape to be applied to the
        // asset after download.
        public class BlendShape_c : WireData
        {
            [WireInfo(SerializeAs = typeof(Guid), BigEndian = true)]
            public AvatarAssetId        BlendShapeAssetId;
        };

        // *********
        // the data
        // *********

        [WireInfo(BigEndian = true)]
        public uint Version;

        // Finally we begin the actual data members. First the weight and
        // height factors for the avatar. These will be applied to the 
        // skeleton to make it fatter/thinner and taller/shorter.
        [WireInfo(BigEndian = true)]
        public float                    WeightFactor;
        [WireInfo(BigEndian = true)]
        public float                    HeightFactor;

        // Next, identifiers for blend-shape assets that are be applied to
        // this model after it has downloaded. The order of this array
        // corresponds exactly to the Shape_e enumeration above.
        [WireInfo(ArraySize = (int)Shape_e.Count)]
        public BlendShape_c[]           BlendShapes = new BlendShape_c[(int)Shape_e.Count];
        
        // A list of replacement textures to be applied to the model after
        // it has downloaded, including the asset to replace it with, and
        // placement of that texture. The order of this array corresponds
        // exactly to the Texture_e enumeration above.
        [WireInfo(ArraySize = (int)Texture_e.Count)]
        public ReplacementTexture_c[]   ReplacementTextures = new ReplacementTexture_c[(int)Texture_e.Count];

        // A list of dynamic color attributes for the avatar model. These
        // are implemented as pixel shader constants. The order of this
        // array corresponds exactly to the Color_e enumeration above.
        [WireInfo(ArraySize = (int)Color_e.Count)]
        public XMCOLOR[]                DynamicColors = new XMCOLOR[(int)Color_e.Count];
        
        // Next the component info for the body and head components. These
        // must always be present, and so are listed here explicitly.
        public XAVATAR_COMPONENT_INFO   BodyComponentInfo;
        public XAVATAR_COMPONENT_INFO   HeadComponentInfo;

        // Next, the additional component info for all other assets to
        // be associated with the avatar, such as shirts, shoes, etc.
        [WireInfo(ArraySize = (int)XAVATAR_COMPONENT.Count)]
        public XAVATAR_COMPONENT_INFO[] ComponentInfo = new XAVATAR_COMPONENT_INFO[(int)XAVATAR_COMPONENT.Count];

        // Finally, an array of previous, exact assets that match
        // each component mask. These are used as fall-back assets
        // when we need to put an asset on to a slot, but don't
        // have a user selection to use. To avoid running out of
        // space in the manifest, we only store 4 components; the
        // exact components tracked are determined by whoever
        // first writes the manifest (but atm are shoes, trousers,
        // shirt and hair)
        [WireInfo(ArraySize = 4)]
        public XAVATAR_COMPONENT_INFO[] PreviousRequiredComponentInfo = new XAVATAR_COMPONENT_INFO[4];

        // We track the XUID of the manifest's owner so that during
        // asset retrieval we can figure out if we can read the
        // asset from the user's profile.  If there is no valid XUID,
        // we just fall back to our other methods of asset retrieval.
        [WireInfo(BigEndian = true)]
        public Puid                     OwnerXuid;

        // This is a runtime setting that we write into the manifest when
        // it is read locally.  This allows the avatar core to know if
        // the manifest is for a local user (even if they are not
        // signed in).
        [WireInfo(ArraySize = CONSOLE_ID_SIZE)]
        public byte[]                   SrcConsoleId;

        public static AvatarManifest Read(byte[] bytes)
        {
            if (bytes == null)
            {
                return null;
            }

            AvatarManifest manifest = new AvatarManifest();

            MemoryStream stream = new MemoryStream(bytes, false);

            manifest.ReadStream(stream);

            return manifest;
        }

        // When we're converting the manifest back to bytes, we need to serialize the data
        // to bytes, then pad it with 0 bytes to make the length correct (1000).
        public override void WriteStream(BinaryWriter binaryWriter)
        {
            long beginPosition = binaryWriter.BaseStream.Position;

            base.WriteStream(binaryWriter);

            while (binaryWriter.BaseStream.Position < beginPosition + XOn.XONLINE_MAX_SETTING_VALUE_BYTES)
            {
                binaryWriter.Write((byte)0);
            }

            if (binaryWriter.BaseStream.Position - beginPosition != XOn.XONLINE_MAX_SETTING_VALUE_BYTES)
            {
                throw new ApplicationException(string.Format("AvatarManifest serialized length is incorrect. Expected {0} bytes, length is {1} bytes", XOn.XONLINE_MAX_SETTING_VALUE_BYTES, binaryWriter.BaseStream.Position - beginPosition));
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\BlockUtil.cs ===
using System;
using System.Collections.Generic;

using STF.common.service;

namespace STF.common.protocol
{
    public class XeGenericBlock : WireData
    {
        public const int BLOCK_MAX_LEN = 3000;

        [WireInfo(Min=1, Max=BLOCK_MAX_LEN)]
        public ushort blockLength;

        [WireInfo(SizeParam="blockLength", LimitString=true)]
        public byte[] block;
    }

    public class BlockSerializer
    {
        public BlockSerializer(byte[] bytes, int minBlocks, int maxBlocks)
        {
            _bytes = bytes;
            if (minBlocks > maxBlocks)
            {
                throw new ArgumentException("minBlocks cannot be greater than maxBlocks");
            }
            _minBlocks = minBlocks;
            _maxBlocks = maxBlocks;
            _blockCount = ( (bytes.Length - 1) / MAX_BLOCK_LEN) + 1;
        }

        public bool IsEmptyBlockCount
        {
            get
            {
                return _bytes.Length == 0;
            }
        }

        public bool IsBlockCountOutOfRange
        {
            get
            {
                return _blockCount < _minBlocks || _blockCount > _maxBlocks;
            }
        }

        public XeGenericBlock[] Serialize()
        {
            if (IsEmptyBlockCount || IsBlockCountOutOfRange)
            {
                throw new Exception("Cannot serialize the bytes into a XeGenericblock--you should do verification with IsEmptyBlockCount and IsBlockCountOutOfRange.");
            }

            int currentBlockLen = _bytes.Length;
            int thisBlockLen = 0;

            XeGenericBlock[] blocks = new XeGenericBlock[_blockCount];

            for (int i = 0; i < _blockCount; ++i)
            {
                thisBlockLen = Math.Min( MAX_BLOCK_LEN, currentBlockLen );
                currentBlockLen -= thisBlockLen;

                blocks[i] = new XeGenericBlock();
                blocks[i].blockLength = (ushort)thisBlockLen;
                blocks[i].block = new byte[thisBlockLen];
                Array.Copy(_bytes, i * MAX_BLOCK_LEN, blocks[i].block, 0, thisBlockLen);
            }

            return blocks;
        }

        private readonly byte[] _bytes;
        private readonly int _minBlocks;
        private readonly int _maxBlocks;
        private readonly int _blockCount;

        private const int MAX_BLOCK_LEN = XeGenericBlock.BLOCK_MAX_LEN;
    }

    public class BlockDeserializer
    {
        public BlockDeserializer(XeGenericBlock[] blocks)
        {
            _blocks = blocks;
        }

        public byte[] Deserialize()
        {
            List<byte> listBytes = new List<byte>();
            foreach (XeGenericBlock block in _blocks)
            {
                listBytes.AddRange(block.block);
            }
            return listBytes.ToArray();
        }

        private readonly XeGenericBlock[] _blocks;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\BucketServer.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(false)]
public class BucketServer : IBucketServer
{
    public BucketServer(string iface)
    {
        _iface = iface;
    }

    public IInterfaceInfo CurrentServer
    {
        get { return Config.GetInterface(_currentServerName, _iface); }
    }

    public string CurrentServerName
    {
        get { return _currentServerName; }
        set { _currentServerName = value; } 
    }

    public IInterfaceInfo NextServer
    {
        get { return Config.GetInterface(_nextServerName, _iface); }
    }

    public string NextServerName
    {
        get { return _nextServerName; }
        set { _nextServerName = value; } 
    }    

    public DateTime NextServerStart
    {
        get { return _nextServerStart; }
        set { _nextServerStart = value; }
    }

    public string Info1
    {
        get { return _info1; }
        set { _info1 = value; }
    }

    public string Info2
    {
        get { return _info2; }
        set { _info2 = value; }
    }

    public string Info3
    {
        get { return _info3; }
        set { _info3 = value; }
    }

    public string Info4
    {
        get { return _info4; }
        set { _info4 = value; }
    }

    public override string ToString()
    {
        return "{"
            +_iface.ToString()+","
            +(_currentServerName == null ? "<null>" : _currentServerName)+","
            +(_nextServerName == null ? "<null>" : _nextServerName)+","
            +_nextServerStart.ToString()+","
            +(_info1 == null ? "<null>" : _info1)+","
            +(_info2 == null ? "<null>" : _info2)+","
            +(_info3 == null ? "<null>" : _info3)+","
            +(_info4 == null ? "<null>" : _info4)+"}";
    }

    private string _iface;

    private string _currentServerName;
    private string _nextServerName;
    private DateTime _nextServerStart;
    private string _info1;
    private string _info2;
    private string _info3;
    private string _info4;
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ByteOrder.cs ===
using System;
using System.Runtime.InteropServices;
using System.Net;

namespace STF.common.utilities2
{

[ComVisible(false)]
public static class ByteOrder
{
    public static Int16 Revert(Int16 value)
    {
        return (Int16)Revert((UInt16)value);
    }

    public static UInt16 Revert(UInt16 value)
    {
        return (UInt16)(
            (0x00FF & (value >> 8)) |
            (0xFF00 & (value << 8))
            );
    }

    public static Int32 Revert(Int32 value)
    {
        return (Int32)Revert((UInt32)value);
    }

    public static UInt32 Revert(UInt32 value)
    {
        return (
            (0x000000FF & (value >> 24)) |
            (0x0000FF00 & (value >> 8)) |
            (0x00FF0000 & (value << 8)) |
            (0xFF000000 & (value << 24))
            );
    }

    public static Int64 Revert(Int64 value)
    {
        return (Int64)Revert((UInt64)value);
    }

    public static UInt64 Revert(UInt64 value)
    {
        return (
            (0x00000000000000FF & (value >> 56)) |
            (0x000000000000FF00 & (value >> 40)) |
            (0x0000000000FF0000 & (value >> 24)) |
            (0x00000000FF000000 & (value >> 8)) |
            (0x000000FF00000000 & (value << 8)) |
            (0x0000FF0000000000 & (value << 24)) |
            (0x00FF000000000000 & (value << 40)) |
            (0xFF00000000000000 & (value << 56))
            );
    }

    public static float Revert(float value)
    {
        byte[] bytes = BitConverter.GetBytes(value);

        Array.Reverse(bytes);

        return BitConverter.ToSingle(bytes, 0);
    }

    public static double Revert(double value)
    {
        byte[] bytes = BitConverter.GetBytes(value);

        Array.Reverse(bytes);

        return BitConverter.ToDouble(bytes, 0);
    }

    public static Guid Revert(Guid value)
    {
        return new Guid(RevertGuidBytesInline(value.ToByteArray()));
    }

    public static byte[] RevertGuidBytesInline(byte[] bytes)
    {
        if (bytes == null)
        {
            return null;
        }

        if (bytes.Length != 16)
        {
            throw new ArgumentException("Cannot revert Guid byte array, length '" + bytes.Length + "' invalid, must be 16");
        }

        Array.Reverse(bytes, 0, 4);
        Array.Reverse(bytes, 4, 2);
        Array.Reverse(bytes, 6, 2);

        return bytes;
    }

    public static UInt32 IpStringToUInt32(string ip)
    {
        return IpAddressToUInt32(IPAddress.Parse(ip));
    }

    public static UInt32 IpAddressToUInt32(IPAddress ip)
    {
        byte[] addr = ip.GetAddressBytes();
        return 
            ((UInt32)addr[0]) + 
            ((UInt32)addr[1] << 8) + 
            ((UInt32)addr[2] << 16) + 
            ((UInt32)addr[3] << 24);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Blob.cs ===
// 
// Blob.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Blob class
// Xbox Online Service
//
// Represents a byte array, but provides lots of helpers for dealing with it, including 
// equality, to/from string, implicit casting, hashcodes, xml serialization, and more.

using System;
using System.Text;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace STF.common.utilities2
{
    // ------------------------------------------------------------------------------
    // class Blob
    //
    // This is a lightweight wrapper around byte[].  It provides lots of nice functions 
    // and helpers, but DOES NOT DEEP CLONE the original array or blob. So if you make a 
    // blob around a byte array and then change the byte array, your blob will change.  
    // Ditto if you create a new blob from another blob.  
    // ------------------------------------------------------------------------------
    public struct Blob : IEquatable<Blob>, IComparable<Blob>, IXmlSerializable
    {
        private byte[] _value;

        public static Blob Empty
        {
            get { return new Blob(); }
        }

        private Blob(byte[] value)
        {
            _value = value;
        }

        private Blob(string s)
        {
            if (String.IsNullOrEmpty(s))
                throw new ArgumentException("s cannot be null");

            if (s.StartsWith("0x"))
                s = s.Substring(2);

            if ((s.Length % 2) == 1)
                s = "0" + s;

            _value = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                _value[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }
        }

        private static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'f')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'F')
                return (byte)(c - 'A' + 10);
            throw new FormatException("Invalid hex character: " + c);
        }

        public int Length
        {
            get 
            { 
                return (_value != null) ? _value.Length : 0; 
            }
        }

        public byte this[int i]
        {
            get { return _value[i]; }
            set { _value[i] = value; }
        }

        public override int GetHashCode()
        {
            if (_value == null)
                return 0;

            int hashCode = _value[0];
            for(int i = 1; i < _value.Length; i++)
            {
                // 1718205583 is prime
                hashCode = hashCode * 1718205583 + _value[i];
            }
            return hashCode;
        }

        public static implicit operator Blob(byte[] value)
        {
            return new Blob(value);
        }

        public static implicit operator byte[](Blob blob)
        {
            return blob._value;
        }

        public static bool operator ==(Blob b1, Blob b2)
        {
            return b1.Equals(b2);
        }

        public static bool operator !=(Blob b1, Blob b2)
        {
            return !b1.Equals(b2);
        }

        public override bool Equals(object o)
        {
            if (o == null) 
                return base.Equals(o);
            if (!(o is Blob))
                throw new InvalidCastException("The object argument is not a Blob object");
            return Equals((Blob)o);
        }

        public bool Equals(Blob other)
        {
            return CompareTo(other) == 0;
        }

        public int CompareTo(Blob other)
        {
            if (this.Length == 0 && other.Length == 0)
            {
                return 0;
            }
            else if (this.Length == 0)
            {
                return -1;
            }
            else if (other.Length == 0)
            {
                return 1;
            }
            else if (this.Length != other.Length)
            {
                // bit odd, but what else to do?
                return this.Length - other.Length;
            }
            else
            {
                for (int i = 0; i < this.Length; i++)
                {
                    if (this[i] != other[i])
                    {
                        return this[i] - other[i];
                    }
                }
                return 0;
            }
        }

        public static Blob Parse(string s)
        {
            return new Blob(s);
        }

        public static bool TryParse(string s, out Blob blob)
        {
            try
            {
                blob = Blob.Parse(s);
                return true;
            }
            catch
            {
                blob = new Blob();
                return false;
            }
        }           

        public void ReadXml(XmlReader reader)
        {
            string s = reader.ReadElementContentAsString();

        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteValue(_value.ToString());
        }

        public XmlSchema GetSchema()
        {
            return (null);
        }

        private readonly static char[] _hexCharLookup = new char[] { 
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' 
        };

        public override string ToString()
        {
            if (_value == null)
                return String.Empty;

            char[] charstr = new char[_value.Length * 2];
            int charPos = 0;
            for (int i = 0; i < _value.Length; i++)
            {
                byte v = _value[i];
                charstr[charPos++] = _hexCharLookup[(v & 0xF0) >> 4];
                charstr[charPos++] = _hexCharLookup[(v & 0x0F)];
            }
            return new string(charstr);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\AccountsProtocol.cs ===
using System;
using System.IO;
using STF.common.mgmt;
using STF.common.service;
using STF.core.wiredata;

[assembly: XomAreaDefinition(XomAreaName.passportTrace)]

namespace STF.common.protocol
{
    public enum ServiceTypeEnum : uint
    {
        Unknown     = 0,
        XboxLive    = 1,
        Zune        = 2,
    }

    public enum UserAgeGroupEnum : uint
    {
        Child = 0,
        Teen = 1,
        Adult = 2,
    }

    public enum ClientTypeEnum : uint
    {
        Unknown     = 0,
        Xbox1       = 1,
        Xenon       = 2,
        Panorama    = 4,
        Web         = 8,
        ZuneDorado  = 16,
        WindowsPhone = 32,

        // Xuacs.GetSupportedCountries uses this value to retreive a static list of countries for Windows Phone
        // versions Mango and below. It is not intended for use anywhere else.
        WindowsPhoneMango = 64,
    }

    public enum KeyId : int
    {
        Ctp = 1
    }

    public class AddressInfoData : WireData
    {
        public ushort street1Length = 0;

        [WireInfo(SizeParam="street1Length")]
        public string street1 = "";

        public ushort street2Length = 0;

        [WireInfo(SizeParam="street2Length")]
        public string street2 = "";

        public ushort cityLength = 0;

        [WireInfo(SizeParam="cityLength")]
        public string city = "";

        public ushort districtLength = 0;

        [WireInfo(SizeParam="districtLength")]
        public string district = "";

        public ushort stateLength = 0;

        [WireInfo(SizeParam="stateLength")]
        public string state = "";

        public ushort postalCodeLength = 0;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode = "";
    }

    public class PhoneInfoData : WireData
    {
        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension = "";
    }

    public class CreditCardInfoData : WireData
    {
        public byte     cardType;

        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        [WireInfo(Min=0, Max=XOn.MAX_CC_NUMBER_SIZE*XOn.UTF8_MULT)]
        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        public ushort   ccvNumberLength = 0;

        [WireInfo(SizeParam="ccvNumberLength", MaskString=true)]
        public string   ccvNumber = "";

        [WireInfo(MaskString=true)]
        public DateTime expirationDate = new DateTime(2001,11,15);
    }

    public class CreditCardInfoDataEx : WireData
    {
        public byte cardType;

        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort accountNumberLength = 0;

        [WireInfo(SizeParam = "accountNumberLength", MaskString = true)]
        public string encryptedAccountNumber = "";

        public ushort lastFourAccountNumberLength = 0;

        [WireInfo(SizeParam = "lastFourAccountNumberLength", MaskString = true)]
        public string lastFourAccountNumber = "";

        public ushort ccvNumberLength = 0;

        [WireInfo(SizeParam = "ccvNumberLength", MaskString = true)]
        public string encryptedCcvNumber = "";

        [WireInfo(MaskString = true)]
        public DateTime expirationDate = new DateTime(2001, 11, 15);
    }

    public class DirectDebitInfoData : WireData
    {
        public ushort   accountHolderNameLength = 0;

        [WireInfo(SizeParam="accountHolderNameLength")]
        public string   accountHolderName = "";

        public ushort   accountNumberLength = 0;

        [WireInfo(SizeParam="accountNumberLength", MaskString=true)]
        public string   accountNumber = "";

        [WireInfo(Min=0, Max=XOn.MAX_BANK_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam="bankCodeLength")]
        public string bankCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_BRANCH_CODE_SIZE*XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam="branchCodeLength")]
        public string branchCode = "";

        [WireInfo(Min=0, Max=XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam="checkDigitsLength")]
        public string checkDigits = "";
    }

    public class DirectDebitInfoDataEx : WireData
    {
        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort accountNumberLength = 0;

        [WireInfo(SizeParam = "accountNumberLength", MaskString = true)]
        public string encryptedAccountNumber = "";

        public ushort lastFourAccountNumberLength = 0;

        [WireInfo(SizeParam = "lastFourAccountNumberLength", MaskString = true)]
        public string lastFourAccountNumber = "";

        [WireInfo(Min = 0, Max = XOn.MAX_BANK_CODE_SIZE * XOn.UTF8_MULT)]
        public ushort bankCodeLength;

        [WireInfo(SizeParam = "bankCodeLength")]
        public string bankCode = "";

        [WireInfo(Min = 0, Max = XOn.MAX_BRANCH_CODE_SIZE * XOn.UTF8_MULT)]
        public ushort branchCodeLength;

        [WireInfo(SizeParam = "branchCodeLength")]
        public string branchCode = "";

        [WireInfo(Min = 0, Max = XOn.MAX_CHECK_DIGITS_SIZE)]
        public ushort checkDigitsLength;

        [WireInfo(SizeParam = "checkDigitsLength")]
        public string checkDigits = "";
    }

    public class WholesaleInfoData : WireData
    {
        public ushort accountHolderNameLength = 0;

        [WireInfo(SizeParam = "accountHolderNameLength")]
        public string accountHolderName = "";

        public ushort externalReferenceIdLength = 0;

        [WireInfo(SizeParam = "externalReferenceIdLength", MaskString = true)]
        public string externalReferenceId = "";

        public ushort wholesalePartnerLength = 0;

        [WireInfo(SizeParam = "wholesalePartnerLength", MaskString = true)]
        public string wholesalePartner = "";

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam = "encryptedPasswordLength", MaskString = true)]
        public string encryptedPassword = "";
    }

    public class BillingAgreementDetails  : WireData
    {
        public ushort payerEmailLength;

        [WireInfo(SizeParam = "payerEmailLength")]
        public string payerEmail;

        public ushort billingAgreementIdLength;

        [WireInfo(SizeParam = "billingAgreementIdLength")]
        public string billingAgreementId;

        public ushort firstNameLength;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public ushort middleNameLength;

        [WireInfo(SizeParam = "middleNameLength")]
        public string middleName;

        public ushort payerBusinessLength;

        [WireInfo(SizeParam = "payerBusinessLength")]
        public string payerBusiness;

        public ushort payerCountryLength;

        [WireInfo(SizeParam = "payerCountryLength")]
        public string payerCountry;

        public ushort billingAgreementDescriptionLength;

        [WireInfo(SizeParam = "billingAgreementDescriptionLength")]
        public string billingAgreementDescription;
    }

    public class PayPalPayinInfoData : WireData
    {
        public PayPalPayinInfoData()
        {
            billingAgreementDetails = new BillingAgreementDetails();
        }

        public BillingAgreementDetails billingAgreementDetails;
    }

    public class InicisPayinInfoData : WireData
    {
        public ushort billKeyLength;

        [WireInfo( SizeParam = "billKeyLength" )]
        public string billKey;

        public ushort buyerEmailLength;

        [WireInfo( SizeParam = "buyerEmailLength" )]
        public string buyerEmail;

        public ushort firstNameLength;

        [WireInfo( SizeParam = "firstNameLength" )]
        public string firstName;

        public ushort identifierLength;

        [WireInfo( SizeParam = "identifierLength" )]
        public string identifier;

        public ushort lastNameLength;

        [WireInfo( SizeParam = "lastNameLength" )]
        public string lastName;

        public ushort subTypeLength;

        [WireInfo( SizeParam = "subTypeLength" )]
        public string subType;
    }

    public class PassportCredentialInfoData : WireData
    {
        [WireInfo(HexString=true)]
        public Puid PassportPuid;

        public ushort PassportMemberNameLength = 0;
    
        [WireInfo(SizeParam="PassportMemberNameLength")]
        public string PassportMemberName;

        public bool IsActive;	
    }



    


    // requests that contain account creation information should
    // implement this so the common utilities can be created
    public interface ICreateAccountRequest
    {
        string FirstName { get; }
        string LastName { get; }
        string Gamertag { get; }
        string Email { get; }
        PhoneInfoData PhoneInfo { get; }
        AddressInfoData AddressInfo { get; }
        byte PaymentInstrumentType { get; }
        CreditCardInfoData CreditCardInfo { get ; }
        DirectDebitInfoData DirectDebitInfo { get; }
        WholesaleInfoData WholesaleInfo { get; }
        byte CountryId { get; }
        ushort LanguageId { get; }
        string CountryCode { get; }
        DateTime BirthDate { get; }
        ulong MachinePuid { get; }
        byte MsftOptIn { get; }
        byte PartnerOptIn { get; }
    }

    public interface ICreateAccountRequestEx
    {
        string FirstName { get; }
        string LastName { get; }
        string Gamertag { get; }
        string Email { get; }
        PhoneInfoData PhoneInfo { get; }
        AddressInfoData AddressInfo { get; }
        byte PaymentInstrumentType { get; }
        CreditCardInfoDataEx CreditCardInfo { get; }
        DirectDebitInfoDataEx DirectDebitInfo { get; }
        WholesaleInfoData WholesaleInfo { get; }
        byte CountryId { get; }
        ushort LanguageId { get; }
        string CountryCode { get; }
        DateTime BirthDate { get; }
        ulong MachinePuid { get; }
        byte MsftOptIn { get; }
        byte PartnerOptIn { get; }
    }

    public abstract class CreateUserResponse : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid = 0;
    }

    public interface ITrustedCreateAccountRequest : ICreateAccountRequest
    {
        ulong UserPassportPuid { get; }
        ulong OwnerPassportPuid { get; }
    }


    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateLiveAccountRequest : XRLObject2, ICreateAccountRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateLiveAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }

        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class CreateLiveAccountRequestEx : XRLObject2, ICreateAccountRequestEx
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString = true)]
        public uint titleId = 0;

        [WireInfo(Min = 0, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 0, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = "";

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam = "reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize = false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateLiveAccountEx.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoDataEx CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoDataEx DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }

        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateLiveAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    public class CreateLiveAccountExtra : XRLObject2
    {
        public bool createArgoProfile;
    }

    public class CreateLiveAccountEntryPoint : XRLObject2
    {
        public uint serviceType;
        public uint clientType;
    }


    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateWholesaleAccountRequest : XRLObject2, ICreateAccountRequest {

        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong offlineXuid = 0;

        [WireInfo(HexString = true)]
        public uint wholesalePartnerId = 0;

        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public DateTime birthdate;

        [WireInfo(Min = 1, Max = XOn.MAX_EMAIL_SIZE * XOn.UTF8_MULT)]
        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public int parentalControlGroupId = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public WholesaleInfoData wholesaleInfo;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam = "reservedBytesLength")]
        public byte[] reservedBytes;

        [WireInfo(Serialize = false)]
        public string countryCode;

        [WireInfo(MinSchemaVersion = "6.1")]
        public byte msftOptIn;

        [WireInfo(MinSchemaVersion = "6.1")]
        public byte partnerOptIn;

        public override string Xrl
        {
            get { return "/xuacs/CreateWholesaleAccount.ashx"; }
        }

        // ICreateWholesaleAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return new CreditCardInfoData(); }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return new DirectDebitInfoData(); }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return wholesaleInfo; }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateWholesaleAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xboxKey;

        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }


    public class GetPaymentInstrumentsRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort maxResults;

        [WireInfo(MinSchemaVersion="5.4")]
        public bool includePayPalPayin = false;

        [WireInfo(MinSchemaVersion="5.4")]
        public bool includeExpiredCreditCards = true;

        [WireInfo(MinSchemaVersion="7.1")]
        public bool includeInicisPayin = false;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetPaymentInstruments.ashx"; }
        }
    }

    public class PaymentInstrumentInfo : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public byte creditCardType = 0;

        public ushort accountNumberLastFourLength = 0;

        [WireInfo(SizeParam="accountNumberLastFourLength")]
        public string accountNumberLastFour;
    }

    public class PaymentInstrumentInfoEx : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public byte paymentInstrumentType = 0;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(MinSchemaVersion = "3.3")]
        public WholesaleInfoData wholesaleInfo;

        [WireInfo(MinSchemaVersion = "5.4")]
        public PayPalPayinInfoData paypalPayinInfo;

        [WireInfo( MinSchemaVersion = "7.1" )]
        public InicisPayinInfoData inicisPayinInfo;
    }

    public class GetPaymentInstrumentsResponse : XRLObject2
    {
        public ushort count;

        [WireInfo(SizeParam="count")]
        public PaymentInstrumentInfoEx[] paymentInstrumentInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class CreateXboxComAccountRequest : XRLObject2, ITrustedCreateAccountRequest
    {
        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong userPassportPuid = 0;

        [WireInfo(HexString=true)]
        public ulong ownerPassportPuid = 0;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeCreateXboxComAccount.ashx"; }
        }

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public ulong UserPassportPuid
        {
            get { return userPassportPuid; }
        }
        public ulong OwnerPassportPuid
        {
            get { return ownerPassportPuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
    }

    public class CreateXboxComAccountResponse : CreateUserResponse
    {
    }

    [WireDataEncryption(AsOfSchemaVersion = "6.1")]
    public class CreateWindowsMobileAccountRequest : XRLObject2, ITrustedCreateAccountRequest
    {
        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";

        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPassportPuid = 0;

        [WireInfo(HexString = true)]
        public ulong ownerPassportPuid = 0;

        public DateTime birthdate;

        public ushort emailLength = 0;

        [WireInfo(SizeParam = "emailLength")]
        public string email = "";

        [WireInfo(Min = 1, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte parentalControlGroupId = 0;

        public byte msftOptIn;

        public byte partnerOptIn;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize = false)]
        public string countryCode;

        // ICreateAccountRequest properties
        public string FirstName
        {
            get { return firstName; }
        }
        public string LastName
        {
            get { return lastName; }
        }
        public string Gamertag
        {
            get { return gamertag; }
        }
        public string Email
        {
            get { return email; }
        }
        public PhoneInfoData PhoneInfo
        {
            get { return phoneInfo; }
        }
        public AddressInfoData AddressInfo
        {
            get { return addressInfo; }
        }
        public byte PaymentInstrumentType
        {
            get { return paymentInstrumentType; }
        }
        public CreditCardInfoData CreditCardInfo
        {
            get { return creditCardInfo; }
        }
        public DirectDebitInfoData DirectDebitInfo
        {
            get { return directDebitInfo; }
        }
        public WholesaleInfoData WholesaleInfo
        {
            get { return new WholesaleInfoData(); }
        }
        public byte CountryId
        {
            get { return countryId; }
        }
        public ushort LanguageId
        {
            get { return languageId; }
        }
        public string CountryCode
        {
            get { return STF.common.utilities.CountryDictionary.CountryCode(countryId); }
        }
        public DateTime BirthDate
        {
            get { return birthdate; }
        }
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        public ulong UserPassportPuid
        {
            get { return userPassportPuid; }
        }
        public ulong OwnerPassportPuid
        {
            get { return ownerPassportPuid; }
        }
        public byte MsftOptIn
        {
            get { return msftOptIn; }
        }
        public byte PartnerOptIn
        {
            get { return partnerOptIn; }
        }
        public int ParentalControlGroupId
        {
            get { return parentalControlGroupId; }
        }
    }

    public class CreateWindowsMobileAccountResponse : CreateUserResponse
    {
    }

    public class GenerateGamertagRequest : XRLObject2
    {
        [WireInfo(Min = 0, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort seedLength = 0;

        [WireInfo(SizeParam = "seedLength")]
        public string seed;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public int gamertagSuggestionType;

        public byte countryId = 103;

        public override string Xrl
        {
            get { return "/xuacs/GenerateGamertag.ashx"; }
        }
    }

    public class GenerateGamertagResponse : XRLObject2
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam = "gamertagLength")]
        public string gamertag = "";
    }

    public class PassportGetUserDataRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetUserData.ashx"; }
        }
    }

    public class PassportGetUserDataResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte countryId;

        [WireInfo(Min=0, Max=XOn.MAX_EMAIL_SIZE*XOn.UTF8_MULT)]
        public ushort emailLength = 0;

        [WireInfo(SizeParam="emailLength")]
        public string email;
    }

    public class XePassportGetMemberNameRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetMemberName.ashx"; }
        }
    }

    public class XePassportGetMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort userPmnLength = 0;

        [WireInfo(SizeParam="userPmnLength")]
        public string userPmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPmnLength = 0;

        [WireInfo(SizeParam="parentPmnLength")]
        public string parentPmn;

        [WireInfo(Min=0, Max=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN, MinSchemaVersion="3.1")]
        public ushort cidLength = 0;

        [WireInfo(SizeParam="cidLength", MinSchemaVersion="3.1")]
        public string userCid;
    }

    public class XePassportGetFriendMemberNameRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;


        [WireInfo(HexString=true)]
        public ulong friendPuid;


        public override string Xrl
        {
            get { return "/xuacs/XePassportGetFriendMemberName.ashx"; }
        }
    }

    public class XePassportGetFriendMemberNameResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort friendPmnLength = 0;

        [WireInfo(SizeParam="friendPmnLength")]
        public string friendPmn;
    }

    public class XePassportGetBuddyGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort buddyPmnLength = 0;

        [WireInfo(SizeParam="buddyPmnLength")]
        public string buddyPmn;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetBuddyGamertag.ashx"; }
        }
    }

    public class XePassportGetBuddyGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong buddyPuid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort buddyGamertagLength = 0;

        [WireInfo(SizeParam="buddyGamertagLength")]
        public string buddyGamertag;
    }

    public class XeABCHGetContactlistGamertagsRequest : XRLObject2WithFlags
    {
        static ushort QueryAtSignupForUsersInABCHandXBL         = 0x0001;
        static ushort QueryAtLoginForUsersInABCHandXBL          = 0x0002;

        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ushort requestFlags;

        public override string Xrl
        {
            get { return "/xuacs/XeABCHGetContactlistGamertags.ashx"; }
        }

        public bool queryAtSignupForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtSignupForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtSignupForUsersInABCHandXBL, value, ref requestFlags);
            }
        }

        public bool queryAtLoginForUsersInABCHandXBL
        {
            get
            {
                return IsFlagSet(QueryAtLoginForUsersInABCHandXBL, requestFlags);
            }
            set
            {
                SetFlag(QueryAtLoginForUsersInABCHandXBL, value, ref requestFlags);
            }
        }
    }

    public class XeABCHGetContactlistGamertagsResponse : XRLObject2
    {
        public ushort ABCHGetContactlistItemCount;

        [WireInfo(SizeParam="ABCHGetContactlistItemCount")]
        public ABCHGetContactlistItem [] items;
    }

    public class ABCHGetContactlistItem : XRLObject2WithFlags
    {
        static ushort UserInABCH            = 0x0001;
        static ushort UserInXBL             = 0x0002;

        public ABCHGetContactlistItem()
        {
            responseFlags = 0;
        }

        [WireInfo(HexString=true)]
        public ulong puid;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort pmnLength = 0;

        [WireInfo(SizeParam="pmnLength")]
        public string pmn;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort displayNameLength = 0;

        [WireInfo(SizeParam="displayNameLength")]
        public string displayName;

        public ushort responseFlags;

        public bool userInABCH
        {
            get
            {
                return IsFlagSet(UserInABCH, responseFlags);
            }
            set
            {
                SetFlag(UserInABCH, value, ref responseFlags);
            }
        }

        public bool userInXBL
        {
            get
            {
                return IsFlagSet(UserInXBL, responseFlags);
            }
            set
            {
                SetFlag(UserInXBL, value, ref responseFlags);
            }
        }
    }

    public class XeUserGetAgeRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAge.ashx"; }
        }
    }

    public class XeUserGetAgeResponse : XRLObject2
    {
        public byte userAge;
    }

    public class XeUserGetAgeGroupRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAgeGroup.ashx"; }
        }
    }

    public class XeUserGetAgeGroupResponse : XRLObject2
    {
        public uint userAgeGroup;
    }

    public class XeUpsGetProfileRequest : XRLObject2
    {
        public ulong  puid;

        public ushort attributesLength = 0;

        [WireInfo(SizeParam="attributesLength")]
        public string attributes;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsGetProfile.ashx"; }
        }
    }

    public class XeUpsGetProfileResponse : XRLObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;
    }

    public class XeUpsUpdateProfileRequest : XRLObject2
    {
        public ushort profileLength = 0;

        [WireInfo(SizeParam="profileLength")]
        public string profile;

        public override string Xrl
        {
            get { return "/xuacs/XeUpsUpdateProfile.ashx"; }
        }
    }

    public class ReadProfileSettingsRequest : XRLObject2
    {
        public override string Xrl
        {
            get { return "/xuacs/XeReadProfileSettings.ashx"; }
        }
    }

    public class ReadProfileSettingsResponse : XRLObject2
    {
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class AddPaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeAddPaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class AddPaymentInstrumentRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeAddPaymentInstrumentEx.ashx"; }
        }
    }

    public class AddPaymentInstrumentResponse : XRLObject2
    {
        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;
    }

    public class RemovePaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public override string Xrl
        {
            get { return "/xuacs/XeRemovePaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class UpdatePaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeUpdatePaymentInstrument.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class UpdatePaymentInstrumentRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong userPuid;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam = "paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        public override string Xrl
        {
            get { return "/xuacs/XeUpdatePaymentInstrumentEx.ashx"; }
        }
    }

    public class GetUserInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        public override string Xrl
        {
            get { return "/xuacs/XeGetUserInfo.ashx"; }
        }
    }

    public class GetUserInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        public byte age;
    }

    public class GetLinkedGamertagRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeGetLinkedGamertag.ashx"; }
        }
    }

    public class GetLinkedGamertagResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class LinkXbox1AccountRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phoneInfo == null ? "" : phoneInfo.phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneInfo == null ? "" : phoneInfo.phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeLinkXbox1Account.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersRequest : XRLObject2
    {
        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetEncryptedProxyParameters.ashx"; }
        }
    }

    public class XePassportGetEncryptedProxyParametersResponse : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort loginTokenRequestLength = 0;

        [WireInfo(SizeParam="loginTokenRequestLength")]
        public string loginTokenRequest;

        public uint publicKeyPublicExponent;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN, Max=XOn.XONLINE_PASSPORT_PUBLIC_KEY_MODULUS_MAX_LEN)]
        public ushort publicKeyModulusLength;

        [WireInfo(SizeParam="publicKeyModulusLength")]
        public byte[] publicKeyModulus;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_PUBLIC_KEY_DIGEST_LEN)]
        public byte[] publicKeyDigest;
    }

    public class XePassportCreateRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength = 0;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(MinSchemaVersion = "4.0")]
        public byte countryId = 0;

        [WireInfo(MinSchemaVersion = "4.0")]
        public DateTime birthdate = DateTime.FromFileTimeUtc(0);

        // Max = 1 specifies that the data is optional, no other way to declare that in wiredata
        [WireInfo(MinSchemaVersion = "7.1", Max = 1)]
        public ushort accountProofLength;

        [WireInfo(MinSchemaVersion = "7.1", SizeParam = "accountProofLength")]
        public ProofData[] accountProof;

        public override string Xrl
        {
            get { return "/xuacs/XePassportCreate.ashx"; }
        }
    }

    public class GetDependentSignedPuidRequest : XRLObject2
    {
        public PassportToken ownerSessionToken;

        public Puid targetXuid;

        public override string Xrl
        {
            get { return "/xuacs/GetDependentSignedPuid.ashx"; }
        }
    }

    public class GetDependentSignedPuidResponse : XRLObject2
    {
        public PassportToken sessionToken;
    }

    public class XePassportCreateResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;
    }

    public class XePassportLoginRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort encryptedSessionKeyLength = 0;

        [WireInfo(SizeParam="encryptedSessionKeyLength")]
        public byte[] encryptedSessionKey;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_TOKEN_REQUEST_MAX_LEN)]
        public ushort encryptedTokenRequestLength = 0;

        [WireInfo(SizeParam="encryptedTokenRequestLength")]
        public byte[] encryptedTokenRequest;

        [WireInfo(MinSchemaVersion="3.0")]
        public int serviceId = 0;

        public override string Xrl
        {
            get { return "/xuacs/XePassportLogin.ashx"; }
        }
    }

    public class XePassportLoginResponse : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Min=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MIN_LEN, Max=XOn.XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort nonceLength;

        [WireInfo(SizeParam="nonceLength", MinSchemaVersion="3.0")]
        public byte[] nonce;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN, MinSchemaVersion="3.0")]
        public ushort cipherValueLength;

        [WireInfo(SizeParam="cipherValueLength", MinSchemaVersion="3.0")]
        public byte[] cipherValue;
    }

    public class XePassportChangePasswordRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort passportMemberNameLength = 0;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        public override string Xrl
        {
            get { return "/xuacs/XePassportChangePassword.ashx"; }
        }
    }

    public class XePassportGetSecretQuestionsRequest : XRLObject2
    {
        public ushort countryId;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetSecretQuestions.ashx"; }
        }
    }

    public class PassportSecretQuestion : XRLObject2
    {
        [WireInfo(Min=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)]
        public ushort secretQuestionLength;

        [WireInfo(SizeParam="secretQuestionLength")]
        public string secretQuestion;
    }

    public class XePassportGetSecretQuestionsResponse : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT)]
        public ushort secretQuestionsCount;

        [WireInfo(SizeParam="secretQuestionsCount")]
        public PassportSecretQuestion[] secretQuestions;
    }

    public class XeRecoverAccountRequest : XRLObject2
    {
        [WireInfo(MinSchemaVersion = "6.1")]
        public byte visitorSigninAccountFlag;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeRecoverAccount.ashx"; }
        }
    }

    public class XeRecoverAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] key;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public ushort domainLength;

        [WireInfo(SizeParam="domainLength")]
        public string domain;

        [WireInfo(Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public ushort realmLength;

        [WireInfo(SizeParam="realmLength")]
        public string realm;
    }

    public class MigrateXbox1UserRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        public ushort userPassportMemberNameLength;

        [WireInfo(SizeParam="userPassportMemberNameLength")]
        public string userPassportMemberName;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXbox1User.ashx"; }
        }
    }

    public class MigrateXbox1UserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class XeSetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte msftOptIn;

        public byte partnerOptIn;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeSetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong  userPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfo.ashx"; }
        }
    }

    public class XeGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;

        [WireInfo(MinSchemaVersion = "3.2")]
        public byte isLightweight;
    }

    public class XeUserGetAccountInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid userPuid;

        [WireInfo(HexString=true)]
        public Puid machinePuid;

        [WireInfo(HexString=true)]
        public TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUserGetAccountInfo.ashx"; }
        }
    }

    public class XeUserGetAccountInfoResponse : XRLObject2
    {
        [WireInfo(Min=0, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Min=0, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public AddressInfoData addressInfo;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte age;
    }


    public class GetUserTenureRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public Puid    userPuid;

        [WireInfo(HexString=true)]
        public TitleId titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/GetUserTenure.ashx"; }
        }
    }

    public class GetUserTenureResponse : XRLObject2
    {
        public int      tenureLevel;

        public int      tenureMilestone;

        public DateTime nextMilestoneDate;
    }

    public class XeGetAccountInfoFromPassportRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong  machinePuid;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetAccountInfoFromPassport.ashx"; }
        }
    }

    public class XeGetUserTypeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserType.ashx"; }
        }
    }

    public class XeGetUserTypeResponse : XRLObject2
    {
        public byte userType;

        // the UserType property is a value within the range of the UserTypeEnum
        public byte UserType
        {
            get { return (byte)(userType & 0x7f); }
        }

        // the HasGamerProfile property is true if the high bit is set
        public bool HasGamerProfile
        {
            get { return (userType & 0x80) == 0x80; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class MigrateXboxComUserRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString=true)]
        public ulong offlineXuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        public ushort languageId;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken = "";

        [WireInfo(Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        [WireInfo(Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;

        [WireInfo(Serialize=false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXboxComUser.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class MigrateXboxComUserRequestEx : XRLObject2
    {
        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        [WireInfo(HexString = true)]
        public ulong offlineXuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryId;

        public ushort languageId;

        [WireInfo(HexString = true)]
        public ulong offerId = 0;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = "";

        [WireInfo(Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName;

        [WireInfo(Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName;

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;

        [WireInfo(Serialize = false)]
        public string countryCode;

        public override string Xrl
        {
            get { return "/xuacs/XeMigrateXboxComUserEx.ashx"; }
        }
    }

    public class MigrateXboxComUserResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(ArraySize=(int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;

        [WireInfo(Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public ushort domainLength;
        [WireInfo(SizeParam="domainLength", Max=XOn.XONLINE_USERDOMAIN_SIZE)]
        public string domain;

        public ushort realmLength;
        [WireInfo(SizeParam="realmLength", Max=XOn.XONLINE_REALM_NAME_SIZE)]
        public string realm;

        public int parentalControlGroupId;

        public int cultureId;
    }

    public class ChangeSubscriptionPaymentInstrumentRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public ushort paymentInstrumentIdLength = 0;

        [WireInfo(SizeParam="paymentInstrumentIdLength")]
        public string paymentInstrumentId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeChangeSubscriptionPaymentInstrument.ashx"; }
        }
    }

    public class VerifyBillingInfoRequest : XRLObject2, IRecoveryRequest
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_PREFIX_SIZE)]
        public ushort phonePrefixLength;

        [WireInfo(SizeParam="phonePrefixLength")]
        public string phonePrefix;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_NUMBER_SIZE)]
        public ushort phoneNumberLength;

        [WireInfo(SizeParam="phoneNumberLength")]
        public string phoneNumber;

        [WireInfo(Min=0, Max=XOn.MAX_PHONE_EXTENSION_SIZE)]
        public ushort phoneExtensionLength;

        [WireInfo(SizeParam="phoneExtensionLength")]
        public string phoneExtension;

        [WireInfo(Min=0, Max=XOn.MAX_POSTALCODE_SIZE)]
        public ushort postalCodeLength;

        [WireInfo(SizeParam="postalCodeLength")]
        public string postalCode;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NAME_SIZE)]
        public ushort cardHolderLength;

        [WireInfo(SizeParam="cardHolderLength")]
        public string cardHolder;

        [WireInfo(Min=1, Max=XOn.MAX_CC_NUMBER_SIZE)]
        public ushort cardNumberLength;

        [WireInfo(SizeParam="cardNumberLength", MaskString=true)]
        public string cardNumber;


        // IRecoveryRequest properties
        public string PostalCode
        {
            get { return postalCode; }
        }
        public string PhonePrefix
        {
            get { return phonePrefix; }
        }
        public string PhoneNumber
        {
            get { return phoneNumber; }
        }
        public string PhoneExtension
        {
            get { return phoneExtension; }
        }
        public string CardHolder
        {
            get { return cardHolder; }
        }
        public string CardNumber
        {
            get { return cardNumber; }
        }

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyBillingInfo.ashx"; }
        }
    }

    public class VerifyBillingInfoResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort firstNameLength;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName;

        public ushort lastNameLength;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName;

        public DateTime birthdate;

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public byte msftOptIn;

        public byte partnerOptIn;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class VerifyParentCreditCardRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public uint titleId = 0;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPassportMemberNameLength = 0;

        [WireInfo(SizeParam="parentPassportMemberNameLength")]
        public string parentPassportMemberName;

        [WireInfo(Min=0, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        [WireInfo(Min=1, Max=XOn.MAX_FIRSTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam="firstNameLength")]
        public string firstName = "";

        [WireInfo(Min=1, Max=XOn.MAX_LASTNAME_SIZE*XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam="lastNameLength")]
        public string lastName = "";

        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoData creditCardInfo;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyParentCreditCard.ashx"; }
        }
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class VerifyParentCreditCardRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public uint titleId = 0;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedParentPassportPuid;

        [WireInfo(Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort parentPassportMemberNameLength = 0;

        [WireInfo(SizeParam = "parentPassportMemberNameLength")]
        public string parentPassportMemberName;

        [WireInfo(Min = 0, Max = XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        [WireInfo(Min = 1, Max = XOn.MAX_FIRSTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort firstNameLength = 0;

        [WireInfo(SizeParam = "firstNameLength")]
        public string firstName = "";

        [WireInfo(Min = 1, Max = XOn.MAX_LASTNAME_SIZE * XOn.UTF8_MULT)]
        public ushort lastNameLength = 0;

        [WireInfo(SizeParam = "lastNameLength")]
        public string lastName = "";

        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public CreditCardInfoDataEx creditCardInfo;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeVerifyParentCreditCardEx.ashx"; }
        }
    }

    public class XeGetUserWebInfoRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint) ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeGetUserWebInfo.ashx"; }
        }
    }

    public class XeGetUserWebInfoResponse : XRLObject2
    {
        [WireInfo(Serialize=false)]
        public static DateTime dummyMinDate = new DateTime(1900, 1, 1);

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH)]
        public uint[] userPrivileges;

        public uint tier;

        public DateTime lastWebActivity;

        public int parentalControlGroupId;

        [WireInfo(MinSchemaVersion="2.0")]
        public byte userType;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool billingUnavailable;

        [WireInfo(MinSchemaVersion="4.0")]
        public bool isLightweight;

        [WireInfo(MinSchemaVersion="5.5")]
        public ushort billingAccountIdLength;

        [WireInfo(MinSchemaVersion="5.5", SizeParam="billingAccountIdLength")]
        public string billingAccountId;

        [WireInfo(MinSchemaVersion="6.1")]
        public bool isFreeGamertagChangeEligible;

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime lastMigratedDate;   

        [WireInfo(MinSchemaVersion="6.6")]
        public DateTime migrationEligibilityDate;    

        [WireInfo(MinSchemaVersion="6.6")]
        public bool isMigrationEligible;    

        [WireInfo(MinSchemaVersion="6.8")]
        public bool isParentallyControlled;    

        public override WireData ReadStream( BinaryReader binaryReader )
        {
            base.ReadStream( binaryReader );

            if( dummyMinDate == lastWebActivity )
            {
                lastWebActivity = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == lastMigratedDate)
            {
                lastMigratedDate = DateTime.FromFileTimeUtc(0);
            }

            if( dummyMinDate == migrationEligibilityDate)
            {
                migrationEligibilityDate = DateTime.FromFileTimeUtc(0);
            }

            return this;
        }

        public override void WriteStream( BinaryWriter binaryWriter )
        {
            if( DateTime.MinValue == lastWebActivity )
            {
                lastWebActivity = dummyMinDate;
            }

            if( DateTime.MinValue == lastMigratedDate)
            {
                lastMigratedDate= dummyMinDate;
            }

            if( DateTime.MinValue == migrationEligibilityDate)
            {
                migrationEligibilityDate = dummyMinDate;
            }

            base.WriteStream( binaryWriter );
        }
    }

    public class XeUpdateXboxComActivityRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public uint serviceType = (uint) ServiceTypeEnum.XboxLive;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/XeUpdateXboxComActivity.ashx"; }
        }
    }

    public class XeReserveGamertagRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max=64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength  = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public override string Xrl
        {
            get { return "/xuacs/XeReserveGamertag.ashx"; }
        }
    }

    public class XeReserveGamertagSuggestedName : XRLObject2
    {
        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam="nameLength")]
        public string name;
    }

    public class XeReserveGamertagResponse : XRLObject2
    {
        public HResult hr;

        [WireInfo(Max=64)]
        public ushort nameCount;

        [WireInfo(SizeParam="nameCount")]
        public XeReserveGamertagSuggestedName[] names;
    }

    public class XeGetGamertagSuggestionsRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid;

        public byte countryId;

        [WireInfo(Max = 64)]
        public ushort maxSuggestedNames;

        [WireInfo(Min = 0, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort seedLength = 0;

        [WireInfo(SizeParam = "seedLength")]
        public string seed;

        public override string Xrl
        {
            get { return "/xuacs/XeGetGamertagSuggestions.ashx"; }
        }
    }

    public class XeGetGamertagSuggestionsSuggestedName : WireData
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort nameLength;

        [WireInfo(SizeParam = "nameLength")]
        public string name;
    }

    public class XeGetGamertagSuggestionsResponse : XRLObject2
    {
        [WireInfo(Max = 64)]
        public ushort nameCount;

        [WireInfo(SizeParam = "nameCount")]
        public XeGetGamertagSuggestionsSuggestedName[] names;
    }

    public class XeTroubleshootAccountRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeTroubleshootAccount.ashx"; }
        }
    }

    public class XeTroubleshootAccountResponse : XRLObject2
    {
        public int newTOS;

        public int nameChangeRequired;

        public int downgraded;

        public DateTime suspendedUntil = DateTime.UtcNow;

        public ushort totalDaysSuspended;

        public DateTime voiceBannedUntil = DateTime.UtcNow;

        public ushort totalDaysVoiceBanned;

        public HResult billingHR;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int userPassportInvalid;

        [WireInfo(MinSchemaVersion = "5.1")]
        public int ownerPassportInvalid;

        [WireInfo(MinSchemaVersion = "9.0")]
        public int gamertagRecycled;

        [WireInfo(Max=1024)]
        public ushort reservedBytesLength;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;
    }

    public class XeAcknowledgeDowngradeRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userId;

        public override string Xrl
        {
            get { return "/xuacs/XeAcknowledgeDowngrade.ashx"; }
        }
    }

    public class XeAccountQueryRequest : XRLObject2
    {
        public uint requestType;

        [WireInfo(Max=2048)]
        public ushort requestBytesLength;

        [WireInfo(SizeParam="requestBytesLength")]
        public byte[] requestBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeAccountQuery.ashx"; }
        }
    }

    public class XeAccountQueryResponse : XRLObject2
    {
        [WireInfo(Max=2048)]
        public ushort responseBytesLength;

        [WireInfo(SizeParam="responseBytesLength")]
        public byte[] responseBytes;
    }

    public class DisableSubscriptionRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public bool addViolation;

        public override string Xrl
        {
            get { return "/xuacs/DisableSubscription.ashx"; }
        }
    }

    public class GetNoAgeOutRequest : XRLObject2
    {
        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/GetNoAgeOut.ashx"; }
        }
    }

    public class GetNoAgeOutResponse : XRLObject2
    {
        public bool noAgeOut;
    }

    public class ArgoAuthenticateAccountResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        [WireInfo(HexString=true)]
        public ulong offerId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId;

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        [WireInfo(Min=0, Max=32)]
        public ushort clientDataLength;

        [WireInfo(SizeParam="clientDataLength")]
        public byte[] clientData;
    }

    public class ArgoAuthenticateAccountRequest : XRLObject2
    {
        public ushort passportTicketLength = 0;

        [WireInfo(SizeParam="passportTicketLength")]
        public string passportTicket;

        public override string Xrl
        {
            get { return "/xuacs/ArgoAuthenticateAccount.ashx"; }
        }
    }

    public class ArgoGetAccountStatusResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public uint userBillingAccountStatus;

        [WireInfo(HexString=true)]
        public ulong offerId = 0;

        public ushort serviceInstanceIdLength = 0;

        [WireInfo(SizeParam="serviceInstanceIdLength")]
        public string serviceInstanceId;

        public int subscriptionStatusId;

        public DateTime purchaseDate;

        public DateTime endDate;

        public bool hasViolations;

        [WireInfo(HexString=true)]
        public ulong renewalOfferId = 0;
    }

    public class ArgoGetAccountStatusRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public override string Xrl
        {
            get { return "/xuacs/ArgoGetAccountStatus.ashx"; }
        }
    }

    public class ArgoTestCreateAccountResponse : XRLObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        [WireInfo(HexString=true)]
        public ulong xboxLivePuid;

        [WireInfo(HexString=true)]
        public ulong passportPuid;

        public ushort passportMemberNameLength;

        [WireInfo(SizeParam="passportMemberNameLength")]
        public string passportMemberName;

        public ushort passportPasswordLength;

        [WireInfo(SizeParam="passportPasswordLength")]
        public string passportPassword;

        public uint pointsBalance;
    }

    public class ArgoTestCreateAccountRequest : XRLObject2
    {
        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoTestCreateAccountExRequest : XRLObject2
    {
        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public bool isChildAccount;

        public bool hasPurchaseContentPrivilege;

        public bool hasExplicitContentPrivilege;

        public bool addPoints;

        public bool addSubscription;

        public override string Xrl
        {
            get { return "/xuacs/ArgoTestCreateAccount.ashx"; }
        }
    }

    public class ArgoSignInSubscriptionInfo : XRLObject2
    {
        public ulong offerId;

        public ushort billingInstanceIdLength;

        [WireInfo(SizeParam="billingInstanceIdLength")]
        public string billingInstanceId;

        public ushort subscriptionStatusLength;

        [WireInfo(SizeParam="subscriptionStatusLength")]
        public string subscriptionStatus;

        public bool hasViolations;

        public bool hasPendingCancel;

        public ushort musicNetSkuLength;

        [WireInfo(SizeParam="musicNetSkuLength")]
        public string musicNetSku;

        public DateTime startDate;

        public DateTime endDate;
    }

    public class ArgoSignInResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public bool nameChangeRequired;

        public bool acceptedTermsOfService;

        public bool accountSuspended;

        public bool subscriptionLapsed;

        public bool billingUnavailable;

        public ushort gamertagLength;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag;

        public byte countryId;

        public ushort geoCountryCodeLength;

        [WireInfo(SizeParam="geoCountryCodeLength")]
        public string geoCountryCode;

        public bool parentallyControlled;

        [WireInfo(ArraySize=XOn.PRIVILEGE_DWORD_LENGTH*4)]
        public byte[] userPrivileges;

        public uint pointsBalance;

        public ArgoSignInSubscriptionInfo subInfo;
    }

    public class ArgoSignInRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid;

        public ushort clientVersionLength = 0;

        [WireInfo(SizeParam="clientVersionLength")]
        public string clientVersion;

        public override string Xrl
        {
            get { return "/xuacs/ArgoSignIn.ashx"; }
        }
    }

    public class AcceptTermsOfServiceRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        public uint titleId = 0;

        public uint serviceType = 0;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get { return "/xuacs/AcceptTermsOfService.ashx"; }
        }
    }

    public class SwitchUserPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldUserPassportPuid;

        public ushort oldUserPassportMemberNameLength;

        [WireInfo(SizeParam="oldUserPassportMemberNameLength")]
        public string oldUserPassportMemberName;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public ushort reservedBytesLength = 0;

        [WireInfo(SizeParam="reservedBytesLength")]
        public byte[] reservedBytes;

        public override string Xrl
        {
            get { return "/xuacs/XeSwitchUserPassport.ashx"; }
        }
    }

    public class XeReplaceOwnerPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceOwnerPassport.ashx"; }
        }
    }

    public class SwitchOwnerPassportRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        [WireInfo(HexString = true)]
        public Puid machinePuid;

        [WireInfo(HexString = true)]
        public uint titleId;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOldOwnerPassportPuid;

        [WireInfo(ArraySize = XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewOwnerPassportPuid;

        public override string Xrl
        {
            get { return "/xuacs/SwitchOwnerPassport.ashx"; }
        }
    }

    public class SwitchUserCountryRequest : XRLObject2
    {
        public Guid trackingGuid;

        [WireInfo(HexString = true)]
        public Puid userPuid;

        public AddressInfoData addressInfo;

        public byte countryId;

        public int cultureId;

        public override string Xrl
        {
            get { return "/xuacs/SwitchUserCountry.ashx"; }
        }
    }

    public class SwitchUserDateOfBirthRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public Puid userPuid;

        public DateTime newDateOfBirth;

        public override string Xrl
        {
            get { return "/xuacs/SwitchUserDateOfBirth.ashx"; }
        }
    }

    public class XeReplaceUserPassportRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong userPuid = 0;

        [WireInfo(HexString=true)]
        public ulong machinePuid;

        [WireInfo(HexString=true)]
        public uint titleId;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedNewUserPassportPuid;

        public ushort newUserPassportMemberNameLength;

        [WireInfo(SizeParam="newUserPassportMemberNameLength")]
        public string newUserPassportMemberName;

        public bool transferBalance;

        public override string Xrl
        {
            get { return "/xuacs/XeReplaceUserPassport.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameRequest : XRLObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam="memberNameLength")]
        public string memberName;

        public override string Xrl
        {
            get { return "/xuacs/XePassportGetPuidFromMemberName.ashx"; }
        }
    }

    public class XePassportGetPuidFromMemberNameResponse : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong passportPuid;
    }

    [WireDataEncryption(AsOfSchemaVersion="5.4")]
    public class GraduateUserRequest : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoData creditCardInfo;

        public DirectDebitInfoData directDebitInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion = "5.4")]
    public class GraduateUserRequestEx : XRLObject2
    {
        [WireInfo(HexString = true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString = true)]
        public ulong userPuid;

        public AddressInfoData addressInfo;

        public PhoneInfoData phoneInfo;

        public byte paymentInstrumentType = 0;

        public CreditCardInfoDataEx creditCardInfo;

        public DirectDebitInfoDataEx directDebitInfo;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class CreateUserRequest : XRLObject2
    {
        [WireInfo(HexString=true)]
        public ulong machinePuid = 0;

        [WireInfo(HexString=true)]
        public ulong offlineXuid = 0;

        [WireInfo(Min=1, Max=XOn.XONLINE_NAME_MAX_SIZE)]
        public ushort gamertagLength = 0;

        [WireInfo(SizeParam="gamertagLength")]
        public string gamertag = "";

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedUserPassportPuid;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] signedOwnerPassportPuid;

        public DateTime birthdate;

        [WireInfo(Min=1, Max=XOn.MAX_DASH_LANG_ID)]
        public ushort languageId;

        public byte countryId;

        public bool msftOptIn;

        public bool partnerOptIn;
    }

    [WireDataEncryption(AsOfSchemaVersion = "6.8")]
    public class CreateBulkUserRequest : CreateUserRequest
    {
        public ushort emailLength;

        [WireInfo(SizeParam = "emailLength")]
        public string email;

        public bool isFreeGamertagChangeEligible = false;

        public override string Xrl
        {
            get { return "/xuacs/CreateBulkUser.ashx"; }
        }
    }

    public class CreateBulkUserResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class CreateUserAndBillableAccountRequest : CreateUserRequest
    {
        public ushort emailLength;

        [WireInfo(SizeParam="emailLength")]
        public string email;

        public bool isFreeGamertagChangeEligible = false;

        [WireInfo(MinSchemaVersion = "6.7")]
        public ushort notificationFlags = 0;

        public override string Xrl
        {
            get { return "/xuacs/CreateUserAndBillableAccount.ashx"; }
        }
    }

    public class CreateUserAndBillableAccountResponse : CreateUserResponse
    {
        [WireInfo(ArraySize = (int)XOn.XONLINE_KEY_LENGTH)]
        public byte[] xenonKey;
    }

    [WireDataEncryption(AsOfSchemaVersion="6.2")]
    public class PassportCreateGeneratedRequest : XRLObject2
    {
        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort sessionKeyLength = 0;

        [WireInfo(SizeParam="sessionKeyLength")]
        public byte[] sessionKey;

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_SESSION_KEY_MAX_LEN)]
        public ushort sessionIVLength = 0;

        [WireInfo(SizeParam="sessionIVLength")]
        public byte[] sessionIV;

        [WireInfo(HexString = true)]
        public Puid machinePuid = 0;

        [WireInfo(Min=0, Max=XOn.XONLINE_NAME_MAX_SIZE, MinSchemaVersion = "6.7")]
        public ushort seedLength = 0;

        [WireInfo(SizeParam="seedLength", MinSchemaVersion = "6.7")]
        public string seed = "";

        [WireInfo(Max=XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN, MinSchemaVersion="6.7")]
        public ushort ownerPassportMemberNameLength = 0;

        [WireInfo(SizeParam="ownerPassportMemberNameLength", MinSchemaVersion="6.7")]
        public string ownerPassportMemberName;

        public DateTime birthdate;

        public byte countryId;

        public override string Xrl
        {
            get { return "/xuacs/PassportCreateGenerated.ashx"; }
        }
    }

    public class PassportCreateGeneratedResponse : XRLObject2
    {
        [WireInfo(Min = 1, Max = XOn.XONLINE_PASSPORT_MEMBER_NAME_MAX_LEN)]
        public ushort memberNameLength = 0;

        [WireInfo(SizeParam = "memberNameLength")]
        public string memberName = "";

        [WireInfo(Max=XOn.XONLINE_PASSPORT_ENCRYPTED_PASSWORD_MAX_LEN)]
        public ushort encryptedPasswordLength = 0;

        [WireInfo(SizeParam="encryptedPasswordLength")]
        public byte[] encryptedPassword;

        [WireInfo(ArraySize=XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN)]
        public byte[] sessionToken;
    }


    public class XeGetPassportCredentialListByNameRequest : XRLObject2
    {
        public ushort memberNameLength;

        [WireInfo(SizeParam="memberNameLength")]
        public string memberName;
    
        public override string Xrl
        {
            get { return "/xuacs/XeGetPassportCredentialListByName.ashx"; }
        }
    }



    public class XeGetPassportCredentialListByNameResponse : XRLObject2
    {
        public ushort passportCredentialCount;
    
        [WireInfo(SizeParam="passportCredentialCount")]
        public PassportCredentialInfoData [] credentials;                    

    }

    public class GetKeyRequest : XRLObject2
    {
        public ushort keyId = 0;

        public override string Xrl
        {
            get { return "/xuacs/GetKey.ashx"; }
        }
    }

    public class GetKeyResponse : XRLObject2
    {
        public ushort publicKeyLength = 0;

        [WireInfo(SizeParam = "publicKeyLength")]
        public string publicKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CacheTable.cs ===
//
// CacheTable.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//  This provides a size-limited cache that maintains size by purging the least used cache items.
//
//  To use it, simply instantiate CacheTable<K,V> in code, and either provide a delegate for resolving items 
//  on cache misses or use the TryGetValue/ContainsKey methods and the Add method to add missing items.
//
// Xbox Online Common Managed Code
// Xbox Online Service
//
// Author: Hoop Somuah (hsomu)
//
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using STF.common.mgmt;

namespace STF.common.service
{
    [ComVisible(false)]
    public interface IMeasurable
    {
        uint GetSize();
    }

    [ComVisible(false)]
    public delegate V ResolveCacheMissDelegate<K, V>(K key);

    /// <summary>
    /// Implements a fixed size LRU cache for data.
    /// </summary>
    /// <typeparam name="K">The type of the keys in the cache</typeparam>
    /// <typeparam name="V">The type of the values in the cache. V must implement IMeasurable to allow cache size to be measured</typeparam>
    /// <remarks>
    /// This class is very much like a special case dictionary. Items that have not been "touched" in a long time are removed from the Cache if it gets very large.
    /// </remarks>
    [ComVisible(false)]
    public class CacheTable<K, V>
        where V : IMeasurable
    {
        private readonly CacheTableCounters instanceCounter;
        private readonly Dictionary<K, CacheEntry<K, V>> table;
        private readonly LinkedList<K> mruList;
        private readonly ResolveCacheMissDelegate<K, V> itemResolver;
        private readonly Object _syncRoot;
        private uint _maxSize;
        private uint _size;

        /// <summary>
        /// Initializes a new instance of the CacheTable that doesn't resolve items when cache misses's occur.
        /// </summary>
        /// <param name="name">The name of the cache.</param>
        /// <param name="maxSize">The maximum size of the cache.</param>
        public CacheTable(string name, uint maxSize):this(name, maxSize, null){}

        /// <summary>
        /// Initializes a new instance of the CacheTable with an item resolver that is called on a cache miss.
        /// </summary>
        /// <param name="name">The name of the cache.</param>
        /// <param name="maxSize">The maximum size of the cache.</param>
        /// <param name="itemResolver">A delegate to a method that will get called when a cache miss occurs.</param>
        public CacheTable(string name, uint maxSize, ResolveCacheMissDelegate<K, V> itemResolver)
        {
            this.instanceCounter = CacheTableCounters.GetCounter(name);
            
            this._maxSize = maxSize;
            this.instanceCounter.InitializeCounter(maxSize);
            
            this._size = 0;
            
            this.table = new Dictionary<K, CacheEntry<K, V>>();
            this.mruList = new LinkedList<K>();
            this.itemResolver = itemResolver;
            this._syncRoot = new Object();
        }
	
        public Object SyncRoot
        {
            get { return _syncRoot; }
        }

        /// <summary>
        /// Gets the Maximum Size the Cache can grow to.
        /// </summary>
        /// <remarks>
        /// If an items is added to the cache after it reaches MaxSize or when Size + item.GetSize() > MaxSize, then
        /// the least used items in the cache are ejected to make room for the new entry.
        /// </remarks>
        public uint MaxSize
        {
            get { return this._maxSize; }
            set
            {
                lock (this._syncRoot)
                {
                    if (value < this._maxSize)
                    {
                        ShrinkCache(value);
                    }
                    long change = value - (long)this._maxSize;

                    this._maxSize = value;

                    this.instanceCounter.ChangeCacheMaxSize(change);
                }
            }
        }

        /// <summary>
        /// Gets the number of key/value pairs contained in the CacheTable
        /// </summary>
        public int Count
        {
            get { return table.Count; }
        }
	
        /// <summary>
        /// Gets the current size of the cache.
        /// </summary>
        /// <remarks>
        /// This is the sum of the values returned by calling IMeasurable.GetSize() on each item when items are inserted or changed.
        /// </remarks>
        public uint Size
        {
            get { return this._size; }
        }

        /// <summary>
        /// Updates the size of the cache.
        /// </summary>
        /// <remarks>
        /// amount to change the cache size by. If change is negative the cache size is reduced.
        /// 
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>        
        void ChangeSize(long sizeChange, long countChange)
        {
            long newSize = this._size + sizeChange;
            
            Debug.Assert(newSize >= 0, "Size should never become negative!");
            
            Debug.Assert(countChange >= -this.table.Count, "Count should never become negative!");

            this._size = (uint)newSize;
            this.instanceCounter.ChangeCacheSize(sizeChange, countChange);
        }

        /// <summary>
        /// Clears all items form the cache.
        /// </summary>
        public void Flush()
        {
            lock (this._syncRoot)
            {
                ChangeSize(-this._size, -this.table.Count);

                this.table.Clear();
                this.mruList.Clear();
            }
        }

        /// <summary>
        /// Determines whether the Cache contains the specified key
        /// </summary>
        /// <param name="key">The key to locate in the Cache</param>
        /// <returns>true if the Cache contains an element with the specified key; otherwise, false</returns>
        /// <remarks>This method approaches an O(1) operation.</remarks>
        public bool ContainsKey(K key)
        {
            return table.ContainsKey(key);
        }

        /// <summary>
        /// Adds the specified key and value to the cache.
        /// </summary>
        /// <param name="key">The key of the element to add</param>
        /// <param name="data">The value of the element to add. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        /// <returns></returns>
        public void Add(K key, V data)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }
            lock (this._syncRoot)
            {
                if (table.ContainsKey(key))
                {
                    throw new ArgumentException("key already exists");
                }
                InternalAdd(key, data);
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key of the value to get or set.</param>
        /// <returns>
        /// The value associated with the specified key. If the specified key is not found and there is no item resolver, a get operation throws a KeyNotFoundException. 
        /// A set operation creates a new element with the specified key if one doesn't exist, otherwise it replaces the exisitng entry and adjusts the cache size accordingly. 
        /// </returns>
        public V this[K key]
        {
            get
            {
                if (key == null)
                {
                    throw new ArgumentNullException("key", "The cache does not support null keys");
                }

                V value;
                if (InternalTryGetValue(key, out value))
                    return value;

                throw new KeyNotFoundException();
            }
            set
            {
                lock (this._syncRoot)
                {
                    CacheEntry<K, V> entry;

                    if (!this.table.TryGetValue(key, out entry))
                    {
                        InternalAdd(key, value);
                    }
                    else
                    {
                        /* replace existing entry in cache */
                        uint oldDataSize = entry.Data.GetSize();
                        uint dataSize = value.GetSize();

                        long sizeChange = dataSize - (long)oldDataSize;
                        if (sizeChange > 0)
                        {
                            EnsureCacheSize((uint)sizeChange);
                        }

                        ChangeSize(sizeChange, 0);
                        this.table[key].Data = value;
                        MakeMRU(entry);
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key of the value to get</param>
        /// <param name="value">When this method returns, contains the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized.</param>
        /// <returns>true if the Cache contains an element with the specified key; otherwise, false.</returns>
        /// <remarks>
        /// This method combines the functionality of the ContainsKey method and the Item property.
        /// If the key is not found, then the value parameter gets the appropriate default value for the value type TValue; for example, 0 (zero) for integer types, false for Boolean types, and a null reference (Nothing in Visual Basic) for reference types.
        /// Use the TryGetValue method if you are not usign an item resolver and your code frequently attempts to access keys that are not in the cache. Using this method is more efficient than catching the KeyNotFoundException thrown by the Item property when there is a cache miss and no item resolver exists.
        /// </remarks>
        public bool TryGetValue(K key, out V value)
        {
            if (key == null)
            {
                throw new ArgumentNullException("key");
            }

            return InternalTryGetValue(key, out value);
        }

        /// <summary>
        /// Try to read cached data.
        /// </summary>
        /// <remarks>
        /// We're using a double-check lock pattern below to avoid locking on reads 
        /// although The FindExistingKey method will lock briefly if the key is found 
        /// to update the MRU list. 
        /// </remarks>
        private bool InternalTryGetValue(K key, out V value)
        {
            if (FindExistingEntry(key, out value))
            {
                this.instanceCounter.MarkCacheHit();
                return true;
            }
            else
            {
                if (itemResolver == null)
                {
                    value = default(V);
                    this.instanceCounter.MarkCacheMiss();
                    return false;
                }
                else
                {
                    lock (this._syncRoot)
                    {
                        if (FindExistingEntry(key, out value))
                        {
                            this.instanceCounter.MarkCacheHit();
                            return true;
                        }

                        value = itemResolver.Invoke(key);
                        this.InternalAdd(key, value);
                    }

                    this.instanceCounter.MarkCacheMiss();
                    return true;
                }
            }
        }

        /// <summary>
        /// Search for an item in the cache and if found, move ti to the front of the MRU 
        /// </summary>
        /// <param name="key">The key of the element to look up.</param>
        /// <param name="value">The value of the element if found.</param>
        /// <returns></returns>
        private bool FindExistingEntry(K key, out V value)
        {
            CacheEntry<K, V> entry;
            if (table.TryGetValue(key, out entry))
            {
                MakeMRU(entry);
                value = entry.Data;
                return true;
            }
            else
            {
                value = default(V);
                return false;
            }
        }

        /// <summary>
        /// Make the given CacheEntry the most recently used item in the mry list.
        /// </summary>
        /// <param name="entry">The enrty to bring to the front of the list.</param>
        private void MakeMRU(CacheEntry<K, V> entry)
        {
            /* Perf Note: It's not clear to me whether the cost of this lock is going to be more due to:
             *      A) The cost of acquiring and releasing the lock or
             *      B) The bottleneck created for cache reads. (This is a cache wide lock).
             */
            lock (this._syncRoot)
            {
                this.mruList.Remove(entry.MruNode);
                this.mruList.AddFirst(entry.MruNode);
            }
        }

        /// <summary>
        /// Add a new item to the Cache
        /// </summary>
        /// <param name="key">The key of the element to add</param>
        /// <param name="data">The value of the element to add. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        /// <remarks>
        /// <para>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </para>
        /// <para>
        /// It might seem that compiler optimizations or processor 
        /// re-ordering will break the double-check lock pattern used before calling 
        /// this from the InternalTryGetValue method.
        /// (http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)
        /// write re-ordering will NOT occur because the second write is not in the same 
        /// method and the Dictionary.Add method will not be inlined to bring it in 
        /// (it's already NGen compiled and it's a virtual call)
        /// </para>
        /// </remarks>
        private void InternalAdd(K key, V data)
        {
            uint dataSize = data.GetSize();
            EnsureCacheSize(dataSize);

            CacheEntry<K, V> entry = new CacheEntry<K, V>(key, data);
            
            this.ChangeSize(dataSize, 1);
            
            mruList.AddFirst(entry.MruNode);
            this.table.Add(key, entry);
        }

        /// <summary>
        /// Make sure the cache has enough space to grow by dataSize.
        /// If it doesn't,
        /// remove items from the end of the queue until there's enough space
        /// </summary>
        /// <param name="dataSize">size table should grow to acommodatey</param>
        /// <remarks>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>
        private void EnsureCacheSize(uint dataSize)
        {
            if (this._maxSize < (this._size + dataSize))
            {
                if (dataSize > this._maxSize)
                    throw new InvalidOperationException("data being inserted exceeds the maximum cache size");

                uint targetSize = this._maxSize - dataSize;
                ShrinkCache(targetSize);
            }
        }

        /// <summary>
        /// Purge some items from the cache to make room for new items or to acommodate a change in 
        /// MaxSize.
        /// </summary>
        /// <param name="targetSize">The size the cache needs to be reduced to</param>
        /// <remarks>
        /// This method is not thread safe, lock on _syncRoot before calling it.
        /// </remarks>
        private void ShrinkCache(uint targetSize)
        {
            uint sizeChange = 0;
            uint numPurges = 0;
            while (this._size - sizeChange > targetSize)
            {
                K lruKey = this.mruList.Last.Value;
                CacheEntry<K, V> lruEntry = this.table[lruKey];
                this.mruList.RemoveLast();
                this.table.Remove(lruKey);
                sizeChange += lruEntry.Data.GetSize();
                numPurges++;
            } 

            this.ChangeSize(-sizeChange, -numPurges);
        }

        class CacheEntry<KK, VV>
        {
            private LinkedListNode<KK> _mruNode;
            private VV _data;

            public CacheEntry(KK key, VV data)
            {
                this._data = data;
                this._mruNode = new LinkedListNode<KK>(key);
            }

            public LinkedListNode<KK> MruNode
            {
                get { return _mruNode; }
            }

            public VV Data
            {
                get { return _data; }
                set { _data = value; }
            }
        }
    }



    [ComVisible(false)]
    [XomPerformanceCounterCategoryAttr( "Common Cache Table", "XBox Online Cache", true )]
    public class CacheTableCounters : XomPerformanceCounterCategory
    {
        public void InitializeCounter(long maxSize)
        {
            this.CacheMaxSize.RawValue = maxSize;
            this.CacheUsePercentageBase.RawValue = maxSize;
            this.CacheTotalEntries.RawValue = 0;
            this.CacheSize.RawValue = 0;
            this.CacheHits.RawValue = 0;
            this.CacheMisses.RawValue = 0;
            this.CacheHitRatio.RawValue = 0;
            this.CacheHitRatioBase.RawValue = 0;
            this.CacheTurnoverRate.RawValue = 0;
            this.CacheUsePercentage.RawValue = 0;
        }

        public void ChangeCacheMaxSize(long change)
        {
            this.CacheMaxSize.RawValue += change;
            this.CacheUsePercentageBase.RawValue += change;
        }

        public void ChangeCacheSize(long sizeChange, long countChange)
        {
            this.CacheSize.RawValue += sizeChange;
            this.CacheUsePercentage.RawValue += sizeChange;

            this.CacheTotalEntries.RawValue += countChange;
            this.CacheTurnoverRate.RawValue += Math.Abs(countChange);
        }

        public void MarkCacheHit() { IncrementReads(true); }
        public void MarkCacheMiss() { IncrementReads(false); }
        public void UnMarkCacheHit() { DecrementReads(true); }
        public void UnMarkCacheMiss() { DecrementReads(false); }

        private void IncrementReads(bool isCacheHit)
        {
            if (isCacheHit)
            {
                this.CacheHits.Increment();
                this.CacheHitRatio.Increment();
            }
            else
            {
                this.CacheMisses.Increment();
            }

            this.CacheHitRatioBase.Increment();

            // protect from 32-bit overflow
            if (CacheHitRatioBase.RawValue > 0x70000000)
            {
                CacheHitRatio.RawValue >>= 16;
                CacheHitRatioBase.RawValue >>= 16;
            }
        }
        private void DecrementReads(bool wasCacheHit)
        {
            if (wasCacheHit)
            {
                this.CacheHits.Decrement();
                this.CacheHitRatio.Decrement();
            }
            else
            {
                this.CacheMisses.Decrement();
            }

            this.CacheHitRatioBase.Decrement();
        }

        public static CacheTableCounters GetCounter(string name)
        {
            return (CacheTableCounters)Counters.GetInstance(name);
        }

        static private CacheTableCounters Counters = new CacheTableCounters();

        [XomPerformanceCounterAttr("Cache Entries", "Number of entries in the cache", PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter CacheTotalEntries;

        [XomPerformanceCounterAttr("Cache Size", "Current cache size. This is the sum of the sizes of all the entries", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheSize;

        [XomPerformanceCounterAttr("Cache Maximum Size", "This is the maximum allowable cache size", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheMaxSize;

        [XomPerformanceCounterAttr("Cache Hits", "The total number of requests served from the cache", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheHits;

        [XomPerformanceCounterAttr("Cache Misses", "The number of failed cache requests", PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CacheMisses;

        [XomPerformanceCounterAttr("Cache Hit Ratio", "The ratio of cache hits to cache misses", PerformanceCounterType.RawFraction)]
        public PerformanceCounter CacheHitRatio;

        [XomPerformanceCounterAttr("Cache Hit Ratio Base", "Base for the ratio of cache hits to cache misses", PerformanceCounterType.RawBase)]
        public PerformanceCounter CacheHitRatioBase;

        [XomPerformanceCounterAttr("Cache Turnover Rate", "The number of additions to and removals from the cache per second", PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CacheTurnoverRate;

        [XomPerformanceCounterAttr("Cache Use Percentage", "Percentage of Cache That is filled", PerformanceCounterType.RawFraction)]
        public PerformanceCounter CacheUsePercentage;

        [XomPerformanceCounterAttr("Cache Use Percentage Base", "Base for percentage of Cache That is filled", PerformanceCounterType.RawBase)]
        public PerformanceCounter CacheUsePercentageBase;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CertUtil.cs ===
//
// CertUtil.cs
//
// Stuff to deal with certificates
//

using System;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Security.Cryptography.X509Certificates;

namespace STF.common.utilities2
{
    //
    // CertUtil
    //
    // Exposes one public static method: GetCertificate - that returns a
    // X509Certificate given the subject of the certificate
    //

    [ComVisible(false)]
    public class CertUtil
    {
        public static X509Certificate GetCurrentUserCertificate(string certSubject)
        {
            // call LoadUserProfile
            IntPtr logonToken = WindowsIdentity.GetCurrent().Token;

            PROFILEINFO info = new PROFILEINFO();
            info.dwSize = Marshal.SizeOf(info);
            info.lpUserName = WindowsIdentity.GetCurrent().Name;
            info.dwFlags = 1; // P_NOUI

            if ( false == WinApiLoadUserProfile(logonToken, ref info) )
            {
                throw new System.ComponentModel.Win32Exception();
            }

            uint dwFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetLocalMachineCertificate(string certSubject)
        {
            uint dwFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
            return GetCertificate(dwFlags, certSubject);
        }

        public static X509Certificate GetCertificate(uint dwFlags, string certSubject)
        {
            IntPtr hSystemStore = IntPtr.Zero;
            IntPtr hCert        = IntPtr.Zero;

            try
            {
                hSystemStore = WinApiCertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                    0, IntPtr.Zero, dwFlags, "MY");

                if(hSystemStore == IntPtr.Zero)
                {
                    throw new Exception("WinApiCertOpenStore failed. Error=" +
                        Marshal.GetLastWin32Error());
                }

                hCert = WinApiCertFindCertificateInStore(hSystemStore,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0,
                    CERT_FIND_SUBJECT_STR_W, certSubject, IntPtr.Zero);

                if(hCert == IntPtr.Zero)
                {
                    throw new Exception(string.Format("Failed to find certificate '{0}'. Error={1}",
                        certSubject, Marshal.GetLastWin32Error()));
                }

                return new X509Certificate(hCert);
            }
            finally
            {
                if(hCert != IntPtr.Zero)
                    WinApiCertFreeCertificateContext(hCert);

                if(hSystemStore != IntPtr.Zero)
                {
                    if(WinApiCertCloseStore(hSystemStore, 0) == 0)
                    {
                        throw new Exception("WinApiCertCloseStore failed. Error=" + Marshal.GetLastWin32Error());
                    }
                }
            }
        }

        public static string GetKeyFileName(X509Certificate cert)
        {
            IntPtr hProvider = IntPtr.Zero;
            bool freeProvider = false;
            UInt32 acquireFlags = CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_SILENT_FLAG;
            int _keyNumber = 0;
            string keyFileName = null;
            byte[] keyFileBytes = null;

            //
            // Determine whether there is private key information available for this certificate in the key store
            //
            if (WinApiCryptAcquireCertificatePrivateKey(cert.Handle,
                 acquireFlags,
                 IntPtr.Zero,
                 ref hProvider,
                 ref _keyNumber,
                 ref freeProvider))
            {
                IntPtr pBytes = IntPtr.Zero;    // Native Memory for the CRYPT_KEY_PROV_INFO structure
                int cbBytes = 0;                // Native Memory size

                try
                {
                    if (WinApiCryptGetProvParam(hProvider,
                            CryptGetProvParamType.PP_UNIQUE_CONTAINER,
                            IntPtr.Zero,
                            ref cbBytes,
                            0))
                    {
                        pBytes = Marshal.AllocHGlobal(cbBytes);

                        if (WinApiCryptGetProvParam(hProvider,
                                CryptGetProvParamType.PP_UNIQUE_CONTAINER,
                                pBytes,
                                ref cbBytes,
                                0))
                        {
                            keyFileBytes = new byte[cbBytes];
                            Marshal.Copy(pBytes, keyFileBytes, 0, cbBytes);

                            keyFileName = System.Text.Encoding.ASCII.GetString(keyFileBytes, 0, keyFileBytes.Length - 1);
                        }
                    }
                }
                finally
                {
                    if (freeProvider)
                        WinApiCryptReleaseContext(hProvider, 0);

                    if (pBytes != IntPtr.Zero)
                    {
                        Marshal.FreeHGlobal(pBytes);
                    }
                }
            }
            else
            {
                throw new Exception("WinApiCryptAcquireCertificatePrivateKey failed. Error = " + Marshal.GetLastWin32Error());
            }

            if (keyFileName == null)
            {
                throw new Exception("GetKeyFileName: Unable to obtain private key file name. Error = " + Marshal.GetLastWin32Error());
            }

            return keyFileName;
        }

        struct PROFILEINFO {
            public int dwSize;
            public int dwFlags;
            public String lpUserName;
            public String lpProfilePath;
            public String lpDefaultPath;
            public String lpServerName;
            public String lpPolicyPath;
            public IntPtr hProfile;
        }

        [DllImport("userenv.dll", EntryPoint="LoadUserProfile", SetLastError=true, CallingConvention=CallingConvention.StdCall, CharSet=CharSet.Auto)]
        static extern bool WinApiLoadUserProfile(IntPtr hToken, ref PROFILEINFO lpProfileInfo);


        [DllImport("crypt32.dll",  EntryPoint="CryptDecodeObject",
            ExactSpelling=true, SetLastError=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern int WinApiCryptDecodeObject(
            UInt32 dwCertEncodingType,
            UInt32 structType,
            byte[] pbEncoded,
            UInt32 cbEncoded,
            UInt32 dwFlags,
            byte[] pvStructInfo,
            ref UInt32 pcbStructInfo);

        [DllImport("crypt32.dll", EntryPoint="CertCreateCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertCreateCertificateContext(
            UInt32 dwCertEncodingType,
            byte[] pbCertEncoded,
            UInt32 cbCertEncoded);

        [DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertGetCertificateContextProperty(
            IntPtr pCertContext,
            UInt32 dwPropId,
            byte[] pvData,
            ref UInt32 pcbData);

        [DllImport("crypt32.dll", EntryPoint="CertFreeCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertFreeCertificateContext(
            IntPtr pCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertOpenStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertOpenStore(
            UInt32 storeProvider,
            UInt32 dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            UInt32 dwFlags,
            string pvPara);

        [DllImport("crypt32.dll", EntryPoint="CertFindCertificateInStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertFindCertificateInStore(
          IntPtr hCertStore,
          UInt32 dwCertEncodingType,
          UInt32 dwFindFlags,
          UInt32 dwFindType,
          string pvFindPara,
          IntPtr pPrevCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertCloseStore",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertCloseStore(
            IntPtr hCertStore,
            UInt32 dwFlags);


        [DllImport("crypt32.dll", EntryPoint = "CryptAcquireCertificatePrivateKey",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        protected static extern bool WinApiCryptAcquireCertificatePrivateKey(
            IntPtr pCert,
            UInt32 dwFlags,
            IntPtr pvReserved,
            ref IntPtr phCryptProv,
            ref int pdwKeySpec,
            ref bool pfCallerFreeProv);

        [DllImport("advapi32.dll", EntryPoint = "CryptGetProvParam",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        internal extern static bool WinApiCryptGetProvParam(
            IntPtr hCryptProv,
            CryptGetProvParamType dwParam,
            IntPtr pvData,
            ref int pcbData,
            uint dwFlags);

        [DllImport("advapi32.dll", EntryPoint = "CryptReleaseContext",
            SetLastError = true, ExactSpelling = true,
            CallingConvention = CallingConvention.StdCall)]
        internal extern static bool WinApiCryptReleaseContext(IntPtr hProv, uint dwFlags);

        protected const UInt32 CRYPT_ASN_ENCODING       = 0x00000001;
        protected const UInt32 CERT_KEY_IDENTIFIER_PROP_ID = 20;
        protected const UInt32 RSA_CSP_PUBLICKEYBLOB    = 19;
        protected const UInt32 X509_ASN_ENCODING        = 0x00000001;
        protected const UInt32 PKCS_7_ASN_ENCODING      = 0x00010000;
        protected const byte   PUBLICKEYBLOB            = 0x6;
        protected const byte   CUR_BLOB_VERSION         = 2;
        protected const UInt32 ALG_CLASS_SIGNATURE      = (1 << 13);
        protected const UInt32 ALG_CLASS_KEY_EXCHANGE   = (5 << 13);
        protected const UInt32 ALG_TYPE_RSA             = (2 << 9);
        protected const UInt32 ALG_SID_RSA_ANY          = 0;
        protected const UInt32 CALG_RSA_SIGN            = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY);
        protected const UInt32 CALG_RSA_KEYX            = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY);
        protected const UInt32 CERT_STORE_PROV_SYSTEM_W = 10;
        protected const Int32  CERT_SYSTEM_STORE_LOCATION_SHIFT =16;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER = (CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE = (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_COMPARE_NAME_STR_W  = 8;
        protected const Int32  CERT_COMPARE_SHIFT       = 16;
        protected const UInt32 CERT_INFO_SUBJECT_FLAG   = 7;
        protected const UInt32 CERT_FIND_SUBJECT_STR_W  = (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | CERT_INFO_SUBJECT_FLAG);
        protected const UInt32 CERT_CLOSE_STORE_FORCE_FLAG = 0x00000001;
        protected const UInt32 CERT_CLOSE_STORE_CHECK_FLAG = 0x00000002;
        protected const UInt32 CERT_STORE_READONLY_FLAG = 0x00008000;

        protected const UInt32 CRYPT_ACQUIRE_COMPARE_KEY_FLAG   = 0x00000004;
        protected const UInt32 CRYPT_ACQUIRE_SILENT_FLAG        = 0x00000040;

        internal enum CryptGetProvParamType
        {
            PP_ENUMALGS = 1,
            PP_ENUMCONTAINERS = 2,
            PP_IMPTYPE = 3,
            PP_NAME = 4,
            PP_VERSION = 5,
            PP_CONTAINER = 6,
            PP_CHANGE_PASSWORD = 7,
            PP_KEYSET_SEC_DESCR = 8,
            PP_CERTCHAIN = 9,
            PP_KEY_TYPE_SUBTYPE = 10,
            PP_PROVTYPE = 16,
            PP_KEYSTORAGE = 17,
            PP_APPLI_CERT = 18,
            PP_SYM_KEYSIZE = 19,
            PP_SESSION_KEYSIZE = 20,
            PP_UI_PROMPT = 21,
            PP_ENUMALGS_EX = 22,
            PP_ENUMMANDROOTS = 25,
            PP_ENUMELECTROOTS = 26,
            PP_KEYSET_TYPE = 27,
            PP_ADMIN_PIN = 31,
            PP_KEYEXCHANGE_PIN = 32,
            PP_SIGNATURE_PIN = 33,
            PP_SIG_KEYSIZE_INC = 34,
            PP_KEYX_KEYSIZE_INC = 35,
            PP_UNIQUE_CONTAINER = 36,
            PP_SGC_INFO = 37,
            PP_USE_HARDWARE_RNG = 38,
            PP_KEYSPEC = 39,
            PP_ENUMEX_SIGNING_PROT = 40,
            PP_CRYPT_COUNT_KEY_USE = 41,
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\clientVersion.cs ===
// 
// ClientVersion.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Client Version Data
// Xbox Online Service
// 

using STF.common.service;


namespace STF.common.protocol 
{
    public class ClientVersion : WireData
    {
        // Need default constructor for deserialization
        public ClientVersion()
        {
        }
        
        public ClientVersion(ulong version)
        {
            Version = version;
        }
        
        public ClientVersion(ushort wMajor, ushort wMinor, ushort wQFE, ushort wBuild)
        {
            wMajorVersion = wMajor;
            wMinorVersion = wMinor;
            wQFENumber = wQFE;
            wBuildNumber = wBuild;
        }
        
        public ushort               wMajorVersion;
        public ushort               wMinorVersion;
        public ushort               wBuildNumber;
        public ushort               wQFENumber;

        public ulong Version
        {
            get 
            { 
                return Create(wMajorVersion, wMinorVersion, wQFENumber, wBuildNumber);
            }
                
            set 
            {
                wMajorVersion = (ushort) (value >> (int)48);
                wMinorVersion = (ushort) (value >> (int)32);
                wQFENumber = (ushort) (value >> (int)16);
                wBuildNumber = (ushort) (value);
            }
        }

        public static explicit operator ulong (ClientVersion client)
        {
            return client.Version;
        }
        
        public static ulong Create(ushort wMajor, ushort wMinor, ushort wQFE, ushort wBuild)
        {
            return ((ulong)wMajor << 48) + ((ulong)wMinor << 32) + ((ulong)wQFE << 16) + ((ulong)wBuild); 
        }               
    }


    public class XboxVersion
    {
        //
        // Xenon XDK Released Clients    
        //  This data is pulled from http://teams/sites/xsoft/Release%20and%20Status/XeDKReleaseHistory.xls
        //
        public static ulong FEB_2005_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1242 ); // released 1/31/2005
        public static ulong DEC_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1141 ); // released 12/10/2004
        public static ulong NOV_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 1029 ); // released 10/29/2004
        public static ulong OCT_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0930 ); // released 9/30/2004
        public static ulong SEPT_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0834 ); // released 9/2/2004
        public static ulong AUG_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0731 ); // released 8/2/2004
        public static ulong JULY_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0634 ); // released 7/2/2004
        public static ulong JUNE_2004_ALPHA_XEDK_2   = ClientVersion.Create( 0, 0, 1, 0530 ); // released 6/16/2004
        public static ulong JUNE_2004_ALPHA_XEDK     = ClientVersion.Create( 0, 0, 0, 0530 ); // released 5/27/2004
        public static ulong MAY_2004_ALPHA_XEDK      = ClientVersion.Create( 0, 0, 0, 0431 ); // released 4/30/2004
        public static ulong APRIL_2004_ALPHA_XEDK    = ClientVersion.Create( 0, 0, 0, 0338 ); // released 4/2/2004
        public static ulong A6_ALPHA_XEDK            = ClientVersion.Create( 0, 0, 0, 0211 ); // released 2/20/2004
        public static ulong A5_ALPHA_XEDK            = ClientVersion.Create( 0, 0, 0, 0199 ); // released 2/6/2004


        //
        // XBOX 1 XDK Released Clients    
        //  This data is pulled from http://teams/sites/xsoft/Release%20and%20Status/Archive/XDKReleaseHistory.xls
        //
        public static ulong DEC_2003_3_XDK     = ClientVersion.Create( 0, 0, 6, 5849 );   // released 5/19/2004
        public static ulong DEC_2003_2_XDK     = ClientVersion.Create( 0, 0, 4, 5849 );   // released 4/22/2004
        public static ulong DEC_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5849 );   // released 12/19/2003
        public static ulong NOV_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5788 );   // released 11/20/2003
        public static ulong NOV_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5788 );   // released 11/12/2003
        public static ulong AUG_2003_4_XDK     = ClientVersion.Create( 0, 0, 5, 5659 );   // released 11/20/2003
        public static ulong AUG_2003_3_XDK     = ClientVersion.Create( 0, 0, 4, 5659 );   // released 10/3/2003
        public static ulong AUG_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5659 );   // released 9/30/2003
        public static ulong AUG_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5659 );   // released 7/30/2003
        public static ulong JUNE_2003_3_XDK    = ClientVersion.Create( 0, 0, 4, 5558 );   // released 10/3/2003
        public static ulong JUNE_2003_2_XDK    = ClientVersion.Create( 0, 0, 2, 5558 );   // released 6/20/2003
        public static ulong JUNE_2003_XDK      = ClientVersion.Create( 0, 0, 0, 5558 );   // released 5/30/2003
        public static ulong APRIL_2003_2_XDK   = ClientVersion.Create( 0, 0, 2, 5455 );   // released 4/18/2003
        public static ulong APRIL_2003_XDK     = ClientVersion.Create( 0, 0, 0, 5455 );   // released 4/4/2003
        public static ulong FEB_2003_4_XDK     = ClientVersion.Create( 0, 0, 4, 5344 );   // released 4/9/2003
        public static ulong FEB_2003_3_XDK     = ClientVersion.Create( 0, 0, 3, 5344 );   // released 3/18/2003
        public static ulong FEB_2003_2_XDK     = ClientVersion.Create( 0, 0, 2, 5344 );   // released 2/17/2003
        public static ulong FEB_2003_XDK       = ClientVersion.Create( 0, 0, 0, 5344 );   // released 2/4/2003
        public static ulong DEC_2002_4_XDK     = ClientVersion.Create( 0, 0, 5, 5233 );   // released 4/9/2003
        public static ulong DEC_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5233 );   // released 3/18/2003
        public static ulong DEC_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5233 );   // released 2/17/2003
        public static ulong DEC_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5233 );   // released 12/12/2002
        public static ulong NOV_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5120 );   // released 4/9/2003
        public static ulong NOV_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5120 );   // released 3/18/2003
        public static ulong NOV_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5120 );   // released 10/31/2002
        public static ulong OCT_2002_3_XDK     = ClientVersion.Create( 0, 0, 4, 5028 );   // released 3/18/2003
        public static ulong OCT_2002_2_XDK     = ClientVersion.Create( 0, 0, 3, 5028 );   // released 10/18/2003
        public static ulong OCT_2002_XDK       = ClientVersion.Create( 0, 0, 0, 5028 );   // released 10/4/2002
        public static ulong SEPT_2002_5_XDK    = ClientVersion.Create( 0, 0, 7, 4928 );   // released 3/18/2003
        public static ulong SEPT_2002_4_XDK    = ClientVersion.Create( 0, 0, 4, 4928 );   // released 10/18/2003
        public static ulong SEPT_2002_3_XDK    = ClientVersion.Create( 0, 0, 3, 4928 );   // released 10/3/2003
        public static ulong SEPT_2002_2_XDK    = ClientVersion.Create( 0, 0, 2, 4928 );   // released 9/12/2002
        public static ulong SEPT_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4928 );   // released 8/28/2002
        public static ulong AUG_2002_5_XDK     = ClientVersion.Create( 0, 0, 9, 4831 );   // released 10/18/2003
        public static ulong AUG_2002_4_XDK     = ClientVersion.Create( 0, 0, 8, 4831 );   // released 9/12/2003
        public static ulong AUG_2002_3_XDK     = ClientVersion.Create( 0, 0, 6, 4831 );   // released 8/29/2003
        public static ulong AUG_2002_2_XDK     = ClientVersion.Create( 0, 0, 5, 4831 );   // released 8/23/2002
        public static ulong AUG_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4831 );   // released 7/31/2002
        public static ulong JULY_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4721 );   // released 6/26/2002
        public static ulong JUNE_2002_XDK      = ClientVersion.Create( 0, 0, 0, 4627 );   // released 6/5/2002
        public static ulong MAY_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4531 );   // released 4/28/2002
        public static ulong APRIL_2002_XDK     = ClientVersion.Create( 0, 0, 0, 4432 );   // released 3/29/2002
        public static ulong MAR_2002_2_XDK     = ClientVersion.Create( 0, 0, 2, 4361 );   // released 3/15/2002
        public static ulong MAR_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4361 );   // released 2/28/2002
        public static ulong FEB_2002_2_XDK     = ClientVersion.Create( 0, 0, 2, 4242 );   // released 3/15/2002
        public static ulong FEB_2002_XDK       = ClientVersion.Create( 0, 0, 0, 4242 );   // released 1/30/2002
        public static ulong DEC_2001_4_XDK     = ClientVersion.Create( 0, 0, 7, 4134 );   // released 3/19/2002
        public static ulong DEC_2001_3_XDK     = ClientVersion.Create( 0, 0, 6, 4134 );   // released 1/29/2002
        public static ulong DEC_2001_2_XDK     = ClientVersion.Create( 0, 0, 2, 4134 );   // released 1/3/2002
        public static ulong DEC_2001_XDK       = ClientVersion.Create( 0, 0, 0, 4134 );   // released 12/11/2001
        public static ulong NOV_2001_4_XDK     = ClientVersion.Create( 0, 0, 5, 4039 );   // released 3/19/2002
        public static ulong NOV_2001_3_XDK     = ClientVersion.Create( 0, 0, 4, 4039 );   // released 1/29/2002
        public static ulong NOV_2001_2_XDK     = ClientVersion.Create( 0, 0, 2, 4039 );   // released 11/9/2001
        public static ulong NOV_2001_XDK       = ClientVersion.Create( 0, 0, 0, 4039 );   // released 10/30/2001
        public static ulong AUG_2001_4_XDK     = ClientVersion.Create( 0, 0, 0, 3950 );   // released 1/29/2002
        public static ulong AUG_2001_3_XDK     = ClientVersion.Create( 0, 0, 0, 3948 );   // released 11/9/2001
        public static ulong AUG_2001_2_XDK     = ClientVersion.Create( 0, 0, 0, 3941 );   // released 9/18/2001
        public static ulong AUG_2001_XDK       = ClientVersion.Create( 0, 0, 0, 3911 );   // released 8/13/2001
    }


} // namespace STF.common.protocol
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ComponentInfo.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{

[ComVisible(false)]
public class ComponentInfo : IComponentInfo
{
    private string _component = STF.common.config.Component.unknown;
    private string _executable = null;
    private Installer _installer = Installer.unspecified;
    private string _username = null;
    private string _password = null;
    private string _info1 = null;
    private string _info2 = null;

    public string Component
    {
        get { return _component; }
        set { _component = value; }
    }

    public string Executable
    {
        get { return _executable; }
        set { _executable = value; }
    }

    public Installer Installer
    {
        get { return _installer; }
        set { _installer = value; }
    }

    public string Username
    {
        get { return _username; }
        set { _username = value; }
    }

    public string Password
    {
        get { return _password; }
        set { _password = value; }
    }

    public string Info1
    {
        get { return _info1; }
        set { _info1 = value; }
    }

    public string Info2
    {
        get { return _info2; }
        set { _info2 = value; }
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CleanserProtocol.cs ===
// 
// CleanserProtocol.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// The ideal location for this file is in private/common/protocol
// However, that would require CommonConfig to pull in all of the
// protocols in building out the dll, and for C++ components using
// CommonConfig.tlh, we'll get duplicate struct definitions.
// Alternatively, we could specify a new XLUSE macro in the sources
// files (either to pull in just this file or to pull in a new 
// directory for reporting protocols), but that adds a step to component
// creation. Since any component that wants instrumentation will 
// have to pull in the management infrastructure, this is the best
// middle ground.
//

using System;
using System.Runtime.InteropServices;
using STF.common.service;
using STF.common.utilities2;

namespace STF.common.mgmt 
{    
    using WireData = STF.common.service.WireData;
    
    [ComVisible(false)]
    public enum RPT_MSG_TYPE : byte
    {
        RPT_MSG_NONE = 0,
        RPT_MSG_CONNECT = 1,
        RPT_MSG_DISCONNECT = 2,
        RPT_MSG_DATA = 3,
        RPT_MSG_KEEPALIVE = 4,
        RPT_MSG_DATA_2 = 5,
        RPT_MSG_DATA_3 = 6
    }

    [ComVisible(false)]
    public class ReportMessageBase : WireData
    {
	static public int cMinMessageSizeBytes = 12;

        public ReportMessageBase() 
            : this(0)
        {
        }

        public ReportMessageBase(RPT_MSG_TYPE msgType)
        {
            bMsgType = (byte)msgType;
            bReserved = 0;
            usSize = 0;
            llTime = DateTime.UtcNow.ToFileTimeUtc( );
        }

        public byte bMsgType;
        public byte bReserved;

        // Note: this is normally supposed to be the size of the payload after the 12 
        // bytes of headers. There seem to be some exceptions to this rule, such as for 
        // ReportMessageConnect. Head's up, here be dragons.

        public ushort usSize;
        public long llTime;
    }

    [ComVisible(false)]
    public class ReportMessageConnect : ReportMessageBase
    {
        public ReportMessageConnect( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_CONNECT)
        {
            vcServer = "Unknown";
            iComponentID = 0;
        }
    
        public Int32 iComponentID;

        // Note: using usSize for this is WRONG, but we have to maintain back-compat, so 
        // it is what it is.
        [WireInfo(SizeParam = "usSize")]
        public string vcServer;  // NPDB t_Servers.VC_SERVER nvarchar(64)
    }

    [ComVisible(false)]
    public class ReportMessageData : ReportMessageBase
    {
        public ReportMessageData( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_DATA)
        {
            szMessage = null;
        }

        // Note: this is lazy... but it works.
        [WireInfo(SizeParam="usSize")]
        public string szMessage;
    }

    [ComVisible(false)]
    public class ReportMessageData2 : ReportMessageBase 
    {
        public ReportMessageData2( ) 
            : base(RPT_MSG_TYPE.RPT_MSG_DATA_2)
        {
            szMessageSize = 0;
            szMessage = null;
            LogStringIdSize = 0;
            EtxEventFingerprintSize = 0;
            WebRepGroupId = 0;
            EtxEventHeaderVersion = 0;
            EtxEventFingerprint = null;
            LogStringId = null;
        }

        public ReportMessageData2(ReportMessageData md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
        }

        public ushort szMessageSize;
        [WireInfo(SizeParam="szMessageSize")]
        public string szMessage;

        public ushort LogStringIdSize;
        [WireInfo(Max=16)]
        public ushort EtxEventFingerprintSize;
        public uint WebRepGroupId;
        public byte EtxEventHeaderVersion;

        [WireInfo(SizeParam="EtxEventFingerprintSize")]
        public byte[] EtxEventFingerprint;
        [WireInfo(SizeParam="LogStringIdSize")]
        public string LogStringId;
    }

    [ComVisible(false)]
    public class ReportMessageData3 : ReportMessageBase
    {
        public ReportMessageData3()
            : base(RPT_MSG_TYPE.RPT_MSG_DATA_3)
        {
            szMessageSize = 0;
            szMessage = null;
            LogStringIdSize = 0;
            EtxEventFingerprintSize = 0;
            EtxEventHeaderVersion = 0;
            EtxEventFingerprint = null;
            LogStringId = null;
            FileNameKeySize = 0;
            FileNameKey = null;
        }

        public ReportMessageData3(ReportMessageData md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
        }

        public ReportMessageData3(ReportMessageData2 md)
            : this()
        {
            szMessageSize = md.usSize;
            szMessage = md.szMessage;
            LogStringIdSize = md.LogStringIdSize;
            EtxEventFingerprintSize = md.EtxEventFingerprintSize;
            EtxEventHeaderVersion = md.EtxEventHeaderVersion;
            EtxEventFingerprint = md.EtxEventFingerprint;
            LogStringId = md.LogStringId;

            if (md.EtxEventFingerprint != null && md.EtxEventFingerprint.Length > 0)
            {
                FileNameKey = String.Format("{0}-{1}", (Blob)md.EtxEventFingerprint, EtxEventHeaderVersion);
            }
            else
            {
                FileNameKey = String.Format("EMPTY-{0}", EtxEventHeaderVersion); 
            }

            FileNameKeySize = (ushort)FileNameKey.Length;
        }

        public ushort szMessageSize;
        [WireInfo(SizeParam = "szMessageSize")]
        public string szMessage;

        public ushort LogStringIdSize;
        [WireInfo(Max = 16)]
        public ushort EtxEventFingerprintSize;
        public byte EtxEventHeaderVersion;

        [WireInfo(SizeParam = "EtxEventFingerprintSize")]
        public byte[] EtxEventFingerprint;
        [WireInfo(SizeParam = "LogStringIdSize")]
        public string LogStringId;

        public ushort FileNameKeySize;
        [WireInfo(SizeParam = "FileNameKeySize")]
        public string FileNameKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CollectionUtil.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;

namespace STF.common.utilities2
{

[ComVisible(false)]
public class CollectionUtil
{
    public static string ToString(ICollection items)
    {
        if (items == null)
        {
            return "<null>";
        }

        StringBuilder sb = new StringBuilder();
        sb.Append("{");
        foreach (Object o in items)
        {
            sb.Append(o.ToString());
            sb.Append(",");
        }
        // pop the last "," off the string, but only if there
        // was at least one element in the collection
        if (items.Count > 0)
        {
            sb.Remove(sb.Length-1, 1);
        }
        sb.Append("}");
        return sb.ToString();
    }

    // note: do not use this method with a type of collection where
    // order is not deterministic. This method considers two collections
    // equal if, when you enumerate through each collection in lockstep,
    // each element of the collection compares equal. This will work fine
    // for objects of type Array, ArrayList, SortedList, Queue, and any
    // other class that implements ICollection where the order is 
    // deterministic in some fashion. For example, you may find that the
    // results of this method are unpredictable when used on Hashtable objects
    public static bool Equals(ICollection items1, ICollection items2)
    {
        // if both are null, then they are considered equal
        if (items1 == null && items2 == null)
        {
            return true;
        }

        // if either one by itself is null, they are not considered equal
        if (items1 == null || items2 == null)
        {
            return false;
        }

        // if they are not the same size, they are not considered equal
        if (items1.Count != items2.Count)
        {
            return false;
        }

        // if each corresponding element does compare equal (according to Object.Equals)
        // note, since we've already checked the length, this loop assumes the lengths
        // are equal
        IEnumerator enum1 = items1.GetEnumerator();
        IEnumerator enum2 = items2.GetEnumerator();
        while (enum1.MoveNext())
        {
            enum2.MoveNext();
            if (!enum1.Current.Equals(enum2.Current))
            {
                return false;
            }
        }

        // if we get here, all the elements matched, so the collections are considered equal
        return true;
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigAttribute.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Security.Permissions;
using System.Text;

namespace STF.common.config
{
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]
    public sealed class ConfigAttribute : Attribute
    {
        private readonly string _component;

        public ConfigAttribute(string component)
        {
            _component = component;
        }


        public string Component
        {
            get
            {
                return _component;
            }
        }

        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public static string GetComponent()
        {
            if (_CachedComponent != null)
            {
                return _CachedComponent;
            }

            // We can't user the assembly-qualified or this will fail test code, such as StfLive 
            string typeName = typeof(ConfigAttribute).FullName;
            string component = null;

            List<Assembly> assemblyList = new List<Assembly>();

            foreach (Assembly assembly in AppDomain.CurrentDomain.GetAssemblies())
            {
                try
                {
                    object[] attributes = assembly.GetCustomAttributes(false);

                    foreach (object attribute in attributes)
                    {
                        Type attributeType = ((Attribute)attribute).GetType();
                        if (attributeType.FullName != typeName) continue;
                        MemberInfo[] nameMemberList = attributeType.GetMember("Component");

                        if (nameMemberList == null || nameMemberList.Length == 0)
                        {
                            throw new InvalidOperationException(
                                "ConfigAttribute must have a readable string property named 'Component'." +
                                "The property cannot be found on '" + attributeType.AssemblyQualifiedName + "'"
                            );
                        }

                        PropertyInfo configNameProperty = nameMemberList[0] as PropertyInfo;

                        if (configNameProperty == null)
                        {
                            throw new InvalidOperationException(
                                "ConfigAttribute must have a read-only string property named 'Component'." +
                                "A member by that name was found on '" + attributeType.AssemblyQualifiedName + "', but it is not a property."
                            );
                        }

                        if (!configNameProperty.CanRead)
                        {
                            throw new InvalidOperationException(
                                "ConfigAttribute must have a readable string property named 'Component'." +
                                "A property by that name was found on '" + attributeType.AssemblyQualifiedName + "', but it is not readable."
                            );
                        }

                        if (configNameProperty.PropertyType != typeof(string))
                        {
                            throw new InvalidOperationException(
                                "ConfigAttribute must have a readable string property named 'Component'." +
                                "A readable property by that name was found on '" + attributeType.AssemblyQualifiedName + "', but it is not a string"
                            );
                        }

                        // record the name. we keep going looking for more, and 
                        // will overwrite this if we find  others.  it is  okay
                        // though because we throw later if  we  find  mulitple

                        assemblyList.Add(assembly);
                        component = (string)configNameProperty.GetValue(attribute, null);
                    }
                }

                catch (FileNotFoundException)
                {
                    // if we can't load one of the files in the manifest,  then
                    // that is okay.  we just won't get any attributes from  it
                }
            }

            // We expect exactly one assembly.  Anything more is ambiguous
            // and we throw with enough info to track it down and  resolve

            if (assemblyList.Count > 1)
            {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.AppendLine("Multiple assemblies in the same process are attributed with the ConfigAttribute.  Instances were found in:\r\n");

                foreach (Assembly assembly in assemblyList)
                {
                    stringBuilder.AppendFormat("    {0} ({1})\r\n", assembly.FullName, assembly.GlobalAssemblyCache ? "Loaded from GAC" : assembly.Location);
                }

                throw new InvalidOperationException(stringBuilder.ToString());
            }

            if (component != null)
                _CachedComponent = component;
            else
            {
                // No assemblies were marked with ComponentNameAttribute - lets return the process name
                _CachedComponent = Process.GetCurrentProcess().ProcessName;
            }

            return _CachedComponent;
        }

        [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]
        public static string GetFriendlyComponent()
        {
            return FriendlyComponent.Get(GetComponent());
        }
        
        private static string _CachedComponent = null;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigEventClasses.cs ===
using System;
using System.Runtime.InteropServices;

namespace STF.common.config
{
    // The delegate for being notified of changes to server lists,
    // and it's EventArgs class

    [ComVisible(false)]
    public delegate void ServerListChangeEventHandler(
        object sender,
        ServerListChangeEventArgs e);

    [ComVisible(false)]
    public class ServerListChangeEventArgs :
        EventArgs,
        IServerListChangeEventArgs
    {
        private readonly string _environment;
        private readonly string _iface;
        private readonly string[] _valueOld;
        private readonly string[] _valueNew;

        public ServerListChangeEventArgs(
            string environment,
            string iface,
            string[] valueOld,
            string[] valueNew)
        {
            _environment = environment;
            _iface = iface;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public string Interface
        {
            get
            {
                return _iface;
            }
        }

        public string[] ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public string[] ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to Interfaces,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void InterfaceChangeEventHandler(
        object sender,
        InterfaceChangeEventArgs e);

    [ComVisible(false)]
    public class InterfaceChangeEventArgs :
        EventArgs,
        IInterfaceChangeEventArgs
    {
        private readonly string _environment;
        private readonly string _server;
        private readonly string _iface;
        private readonly IInterfaceInfo _valueOld;
        private readonly IInterfaceInfo _valueNew;

        public InterfaceChangeEventArgs(
            string environment,
            string server,
            string iface,
            IInterfaceInfo valueOld,
            IInterfaceInfo valueNew)
        {
            _environment = environment;
            _server = server;
            _iface = iface;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public string Server
        {
            get
            {
                return _server;
            }
        }

        public string Interface
        {
            get
            {
                return _iface;
            }
        }

        public IInterfaceInfo ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public IInterfaceInfo ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to Interface Buckets,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void InterfaceBucketChangeEventHandler(
        object sender,
        InterfaceBucketChangeEventArgs e);

    [ComVisible(false)]
    public class InterfaceBucketChangeEventArgs :
        EventArgs,
        IInterfaceBucketChangeEventArgs
    {
        private readonly string _environment;
        private readonly uint _titleId;
        private readonly uint _bucket;
        private readonly string _iface;
        private readonly IBucketServer _valueOld;
        private readonly IBucketServer _valueNew;

        public InterfaceBucketChangeEventArgs(
            string environment,
            uint titleId,
            uint bucket,
            string iface,
            IBucketServer valueOld,
            IBucketServer valueNew)
        {
            _environment = environment;
            _titleId = titleId;
            _bucket = bucket;
            _iface = iface;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public uint TitleId
        {
            get
            {
                return _titleId;
            }
        }

        public uint Bucket
        {
            get
            {
                return _bucket;
            }
        }

        public string Interface
        {
            get
            {
                return _iface;
            }
        }

        public IBucketServer ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public IBucketServer ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }


    // The delegate for being notified of changes to VirtualInterfaces,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void VirtualInterfaceChangeEventHandler(
        object sender,
        VirtualInterfaceChangeEventArgs e);

    [ComVisible(false)]
    public class VirtualInterfaceChangeEventArgs :
        EventArgs,
        IVirtualInterfaceChangeEventArgs
    {
        private readonly string _environment;
        private readonly int _siteId;
        private readonly string _virtualInterface;
        private readonly IVirtualInterfaceInfo _valueOld;
        private readonly IVirtualInterfaceInfo _valueNew;

        public VirtualInterfaceChangeEventArgs(
            string environment,
            int siteId,
            string virtualInterface,
            IVirtualInterfaceInfo valueOld,
            IVirtualInterfaceInfo valueNew)
        {
            _environment = environment;
            _siteId = siteId;
            _virtualInterface = virtualInterface;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public int SiteId
        {
            get
            {
                return _siteId;
            }
        }

        public string VirtualInterface
        {
            get
            {
                return _virtualInterface;
            }
        }

        public IVirtualInterfaceInfo ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public IVirtualInterfaceInfo ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to virtual interface lists,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void VirtualInterfaceListChangeEventHandler(
        object sender,
        VirtualInterfaceListChangeEventArgs e);

    [ComVisible(false)]
    public class VirtualInterfaceListChangeEventArgs :
        EventArgs,
        IVirtualInterfaceListChangeEventArgs
    {
        private readonly string _environment;
        private readonly int _siteId;
        private readonly string[] _valueOld;
        private readonly string[] _valueNew;

        public VirtualInterfaceListChangeEventArgs(
            string environment,
            int siteId,
            string[] valueOld,
            string[] valueNew)
        {
            _environment = environment;
            _siteId = siteId;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public int SiteId
        {
            get
            {
                return _siteId;
            }
        }

        public string[] ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public string[] ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to Settings,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void SettingChangeEventHandler(
        object sender,
        SettingChangeEventArgs e);

    [ComVisible(false)]
    public class SettingChangeEventArgs :
        EventArgs,
        ISettingChangeEventArgs
    {
        private readonly string _environment;
        private readonly int _siteId;
        private readonly string _server;
        private readonly string _component;
        private readonly string _setting;
        private readonly string _valueOld;
        private readonly string _valueNew;

        public SettingChangeEventArgs(
            string environment,
            int siteId,
            string server,
            string component,
            string setting,
            string valueOld,
            string valueNew)
        {
            _environment = environment;
            _siteId = siteId;
            _server = server;
            _component = component;
            _setting = setting;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public int SiteId
        {
            get
            {
                return _siteId;
            }
        }

        public string Server
        {
            get
            {
                return _server;
            }
        }

        public string Component
        {
            get
            {
                return _component;
            }
        }

        public string Setting
        {
            get
            {
                return _setting;
            }
        }

        public string ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public string ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to MultiSettings,
    // and it's EventArgs class
    [ComVisible(false)]
    public delegate void MultiSettingChangeEventHandler(
        object sender,
        MultiSettingChangeEventArgs e);

    [ComVisible(false)]
    public class MultiSettingChangeEventArgs :
        EventArgs,
        IMultiSettingChangeEventArgs
    {
        private readonly string _environment;
        private readonly string _server;
        private readonly int _siteId;
        private readonly string _component;
        private readonly string _multiSetting;
        private readonly string[] _valueOld;
        private readonly string[] _valueNew;

        public MultiSettingChangeEventArgs(
            string environment,
            int siteId,
            string server,
            string component,
            string multiSetting,
            string[] valueOld,
            string[] valueNew)
        {
            _environment = environment;
            _siteId = siteId;
            _server = server;
            _component = component;
            _multiSetting = multiSetting;
            _valueOld = valueOld;
            _valueNew = valueNew;
        }

        public string Environment
        {
            get
            {
                return _environment;
            }
        }

        public int SiteId
        {
            get
            {
                return _siteId;
            }
        }

        public string Server
        {
            get
            {
                return _server;
            }
        }

        public string Component
        {
            get
            {
                return _component;
            }
        }

        public string MultiSetting
        {
            get
            {
                return _multiSetting;
            }
        }

        public string[] ValueOld
        {
            get
            {
                return _valueOld;
            }
        }

        public string[] ValueNew
        {
            get
            {
                return _valueNew;
            }
        }
    }

    // The delegate for being notified of changes to t_game_config table.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void GameConfigChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to t_xdelay_settings.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void XdelaySettingsChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to t_xdelay_settings.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void XrlMappingsChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to t_health_mappings.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void HealthMappingsChangeEventHandler(
        object sender,
        EventArgs e);


    // The delegate for being notified of changes to t_live_registry_settings.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void LiveRegistrySettingsChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to t_service_keys.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void ServiceKeysChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to t_config_blobs.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void ConfigBlobChangeEventHandler(
        object sender,
        EventArgs e);

    // The delegate for being notified of changes to the etx manifest.
    // This event uses the default EventArgs class, since
    // no information is passed
    [ComVisible(false)]
    public delegate void EtxManifestChangeEventHandler(
        object sender,
        EventArgs e);

    // General npdb notification event handler.  Used only for testing.
    [ComVisible(false)]
    public delegate void RefreshTypeEventHandler(NpdbRefreshTypes npdbRefreshType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigEventLogger.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

namespace STF.common.config
{

// This class implements a couple of static methods to log stuff to the
// NT event log. Both the ConfigInterop and Config classes inherit these methods.
// We don't use the xmgmt event logging stuff because xmgmt needs to use
// Config during it's startup. We're putting this stuff in a base class
// so we can make it protected. We don't want non-Config code calling these
// methods directly - we want non-config code to go through xmgmt.
[ComVisible(false)]
public class ConfigEventLogger
{
    public const int MaxEventLength = 32000;

    private static EventLogEntryType XEventIdToEventLogEntryType(ConfigEvent.Id eventId)
    {
        if (ConfigEvent.SeverityFromId(eventId) == ConfigEvent.Severity.Info)
        {
            return EventLogEntryType.Information;
        }

        if (ConfigEvent.SeverityFromId(eventId) == ConfigEvent.Severity.Warning)
        {
            return EventLogEntryType.Warning;
        }

        return EventLogEntryType.Error;
    }

    private static UInt16 XEventIdToEventLogEventId(ConfigEvent.Id eventId)
    {
        return (UInt16) ConfigEvent.MessageFromId(eventId);
    }

    internal static void LogNtEvent(string component, string msg, ConfigEvent.Id eventId)
    {
        StringBuilder eventText = new StringBuilder();
        eventText.Append("\r\n\r\n----- CommonConfig -----\r\n");
        eventText.Append(msg);
        eventText.Append("\r\n");

        int start;
        int len;
        int maxIndex = eventText.Length - 1;

        for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
            len = Math.Min(eventText.Length - start, ConfigEventLogger.MaxEventLength);
            EventLog.WriteEntry(
                component,
                eventText.ToString( start, len ),
                XEventIdToEventLogEntryType( eventId ),
                XEventIdToEventLogEventId( eventId ),
                0,
                null );
        }
    }

    internal static void LogNtEvent(string component, Exception e, string stackTrace, ConfigEvent.Id eventId)
    {
        StringBuilder eventText = new StringBuilder();
        eventText.Append("\r\n\r\n----- Exception in CommonConfig -----\r\n");
        eventText.Append(e.GetType().ToString() + ": " + e.Message + "\r\n");
        eventText.Append(stackTrace);
        eventText.Append("\r\n");

        int start;
        int len;
        int maxIndex = eventText.Length - 1;

        for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
            len = Math.Min( eventText.Length - start, ConfigEventLogger.MaxEventLength );
            EventLog.WriteEntry(
                component,
                eventText.ToString( start, len ),
                XEventIdToEventLogEntryType( eventId ),
                XEventIdToEventLogEventId( eventId ),
                0,
                null );
        }
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigEvent.cs ===
using System;
using System.Diagnostics;

namespace STF.common.config {
    internal partial class ConfigEvent {
        public enum Severity : uint {
            Info    = 0x40000000,
            Warning = 0x80000000,
            Error   = 0xC0000000
        }

        public static Severity SeverityFromId(ConfigEvent.Id eventId)
        {
            uint severity = ((uint) eventId) & 0xC0000000;
            Debug.Assert(severity != 0);
            return (Severity) severity;
        }

        public static ushort MessageFromId(ConfigEvent.Id eventId)
        {
            return (ushort) (((uint) eventId) & 0xFFFF);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigEvent.Id.cs ===
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES 
/////////////////////////////////////////////////////////////////////////////// 
 
using System; 
 
namespace STF.common.config 
{ 
    internal partial class ConfigEvent 
    { 
        public enum Id : uint 
        { 
            SGINFO_CALL_SOURCE_INVALID = 40001 | ConfigEvent.Severity.Error,
            SGINFO_VERIFY_PRIVILEGE = 40002 | ConfigEvent.Severity.Error,
            XMGMT_FAILED_TO_REGISTER_ASSEMBLY = 40050 | ConfigEvent.Severity.Warning,
            HEALTH_REQUEST_FAILED = 40051 | ConfigEvent.Severity.Error,
            HEALTH_INITIALIZE_INTEROP_FAILED = 40052 | ConfigEvent.Severity.Error,
            HEALTH_REGISTERNATIVEHEALTHBLOCK_FAILED = 40053 | ConfigEvent.Severity.Error,
            HEALTH_LISTENER_CALLBACK_REQUEST_FAILED = 40054 | ConfigEvent.Severity.Error,
            HEALTH_LISTENER_CALLBACK_FAILED = 40055 | ConfigEvent.Severity.Error,
            MSNRR_EXTERNAL_EXCEPTION = 40056 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_INFO_SERVICE_KEYS_CHANGE = 40057 | ConfigEvent.Severity.Info,
            COMMON_CONFIG_SERVICE_KEYS_CHANGE = 40058 | ConfigEvent.Severity.Error,
            COMMON_CODE_20 = 50845 | ConfigEvent.Severity.Error,
            CRYPTO_GENERAL_ERROR = 50846 | ConfigEvent.Severity.Error,
            COMMON_CODE_22 = 50847 | ConfigEvent.Severity.Error,
            COMMON_CODE_23 = 50848 | ConfigEvent.Severity.Error,
            COMMON_CODE_24 = 50849 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR = 50850 | ConfigEvent.Severity.Error,
            COMMON_CODE_26 = 50851 | ConfigEvent.Severity.Error,
            COMMON_CODE_27 = 50852 | ConfigEvent.Severity.Error,
            COMMON_CODE_28 = 50853 | ConfigEvent.Severity.Error,
            COMMON_CODE_29 = 50854 | ConfigEvent.Severity.Error,
            COMMON_CODE_30 = 50855 | ConfigEvent.Severity.Error,
            COMMON_CODE_31 = 50856 | ConfigEvent.Severity.Error,
            COMMON_CODE_32 = 50857 | ConfigEvent.Severity.Error,
            COMMON_CODE_33 = 50858 | ConfigEvent.Severity.Error,
            COMMON_CODE_34 = 50859 | ConfigEvent.Severity.Error,
            COMMON_CODE_35 = 50860 | ConfigEvent.Severity.Error,
            COMMON_CODE_36 = 50861 | ConfigEvent.Severity.Error,
            COMMON_CODE_37 = 50862 | ConfigEvent.Severity.Error,
            COMMON_CODE_38 = 50863 | ConfigEvent.Severity.Error,
            MC_PLUGIN_ERROR = 50864 | ConfigEvent.Severity.Error,
            MC_PLUGIN_ERROR_1 = 50865 | ConfigEvent.Severity.Error,
            COMMON_CODE_41 = 50866 | ConfigEvent.Severity.Error,
            COMMON_CODE_42 = 50867 | ConfigEvent.Severity.Error,
            COMMON_CODE_43 = 50868 | ConfigEvent.Severity.Error,
            COMMON_CODE_46 = 50871 | ConfigEvent.Severity.Error,
            COMMON_CODE_48 = 50873 | ConfigEvent.Severity.Error,
            QUERY_BAD_PARAMETER = 50876 | ConfigEvent.Severity.Error,
            QUERY_BAD_PARAMETER_1 = 50877 | ConfigEvent.Severity.Error,
            COMMON_CODE_53 = 50878 | ConfigEvent.Severity.Error,
            COMMON_CODE_54 = 50879 | ConfigEvent.Severity.Error,
            COMMON_CODE_55 = 50880 | ConfigEvent.Severity.Error,
            COMMON_CODE_56 = 50881 | ConfigEvent.Severity.Error,
            COMMON_CODE_57 = 50882 | ConfigEvent.Severity.Error,
            COMMON_CODE_58 = 50883 | ConfigEvent.Severity.Error,
            COMMON_CODE_59 = 50884 | ConfigEvent.Severity.Error,
            MC_BAD_PARAMETER = 50885 | ConfigEvent.Severity.Error,
            MC_BAD_PARAMETER_1 = 50886 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_1 = 50887 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_2 = 50888 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_3 = 50889 | ConfigEvent.Severity.Error,
            MC_BAD_PARAMETER_2 = 50890 | ConfigEvent.Severity.Error,
            COMMON_CODE_66 = 50891 | ConfigEvent.Severity.Error,
            MC_BAD_CODE = 50892 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_1 = 50893 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_2 = 50894 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_3 = 50895 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_4 = 50896 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_5 = 50897 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_6 = 50898 | ConfigEvent.Severity.Error,
            COMMON_CODE_74 = 50899 | ConfigEvent.Severity.Error,
            COMMON_CODE_75 = 50900 | ConfigEvent.Severity.Error,
            COMMON_CODE_76 = 50901 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_7 = 50902 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_8 = 50903 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_9 = 50904 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_10 = 50905 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_11 = 50906 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_12 = 50907 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_13 = 50908 | ConfigEvent.Severity.Error,
            MC_BAD_CODE_14 = 50909 | ConfigEvent.Severity.Error,
            COMMON_CODE_85 = 50910 | ConfigEvent.Severity.Error,
            COMMON_CODE_86 = 50911 | ConfigEvent.Severity.Error,
            FORBIDDEN_NAMES_LOAD_FAILURE = 50912 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_5 = 50913 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_6 = 50914 | ConfigEvent.Severity.Error,
            MC_APPLICATION_ERROR_7 = 50915 | ConfigEvent.Severity.Error,
            COMMON_CODE_91 = 50916 | ConfigEvent.Severity.Error,
            COMMON_CODE_92 = 50917 | ConfigEvent.Severity.Error,
            MGMT_GENERIC_ERROR = 50918 | ConfigEvent.Severity.Error,
            MGMT_GENERIC_ERROR_1 = 50919 | ConfigEvent.Severity.Error,
            MGMT_GENERIC_ERROR_2 = 50920 | ConfigEvent.Severity.Error,
            MGMT_GENERIC_ERROR_3 = 50921 | ConfigEvent.Severity.Error,
            COMMON_CODE_97 = 50922 | ConfigEvent.Severity.Error,
            MGMT_GENERIC_ERROR_4 = 50923 | ConfigEvent.Severity.Error,
            COMMON_CODE_99 = 50924 | ConfigEvent.Severity.Error,
            COMMON_CODE_100 = 50925 | ConfigEvent.Severity.Error,
            COMMON_CODE_101 = 50926 | ConfigEvent.Severity.Error,
            COMMON_CODE_102 = 50927 | ConfigEvent.Severity.Error,
            COMMON_CODE_103 = 50928 | ConfigEvent.Severity.Error,
            COMMON_CODE_104 = 50929 | ConfigEvent.Severity.Error,
            COMMON_CODE_105 = 50930 | ConfigEvent.Severity.Error,
            COMMON_CODE_106 = 50931 | ConfigEvent.Severity.Error,
            COMMON_CODE_107 = 50932 | ConfigEvent.Severity.Error,
            COMMON_CODE_108 = 50933 | ConfigEvent.Severity.Error,
            COMMON_CODE_109 = 50934 | ConfigEvent.Severity.Error,
            HEALTH_GENERIC_ERROR_1 = 50935 | ConfigEvent.Severity.Error,
            SQL_EXECUTE_READER = 50936 | ConfigEvent.Severity.Error,
            SQL_EXECUTE_READER_BEHAVIOR = 50937 | ConfigEvent.Severity.Error,
            SQL_EXECUTE_NON_QUERY = 50938 | ConfigEvent.Severity.Error,
            SQL_EXECUTE_SCALAR = 50939 | ConfigEvent.Severity.Error,
            COUNTRY_LIST_MISSING = 50940 | ConfigEvent.Severity.Error,
            COMMON_CODE_117 = 50942 | ConfigEvent.Severity.Error,
            COMMON_CODE_118 = 50943 | ConfigEvent.Severity.Error,
            COMMON_CODE_119 = 50944 | ConfigEvent.Severity.Error,
            COMMON_CODE_120 = 50945 | ConfigEvent.Severity.Error,
            COMMON_CODE_121 = 50946 | ConfigEvent.Severity.Error,
            COMMON_CODE_122 = 50947 | ConfigEvent.Severity.Error,
            MUSICNET_EXTERNAL_EXCEPTION = 50958 | ConfigEvent.Severity.Error,
            COMMON_CODE_146 = 50971 | ConfigEvent.Severity.Error,
            COMMON_CODE_147 = 50972 | ConfigEvent.Severity.Error,
            COMMON_CODE_148 = 50973 | ConfigEvent.Severity.Error,
            COMMON_CODE_149 = 50974 | ConfigEvent.Severity.Error,
            COMMON_CODE_150 = 50975 | ConfigEvent.Severity.Error,
            COMMON_CODE_151 = 50976 | ConfigEvent.Severity.Error,
            COMMON_CODE_152 = 50977 | ConfigEvent.Severity.Error,
            COMMON_CODE_153 = 50978 | ConfigEvent.Severity.Error,
            COMMON_CODE_154 = 50979 | ConfigEvent.Severity.Error,
            COMMON_CODE_155 = 50980 | ConfigEvent.Severity.Error,
            COMMON_CODE_156 = 50981 | ConfigEvent.Severity.Error,
            COMMON_CODE_157 = 50982 | ConfigEvent.Severity.Error,
            COMMON_CODE_158 = 50983 | ConfigEvent.Severity.Error,
            COMMON_CODE_159 = 50984 | ConfigEvent.Severity.Error,
            COMMON_CODE_160 = 50985 | ConfigEvent.Severity.Error,
            COMMON_CODE_161 = 50986 | ConfigEvent.Severity.Error,
            COMMON_CODE_162 = 50987 | ConfigEvent.Severity.Error,
            COMMON_CODE_163 = 50988 | ConfigEvent.Severity.Error,
            COMMON_CODE_164 = 50989 | ConfigEvent.Severity.Error,
            COMMON_CODE_165 = 50990 | ConfigEvent.Severity.Error,
            COMMON_CODE_166 = 50991 | ConfigEvent.Severity.Error,
            COMMON_CODE_167 = 50992 | ConfigEvent.Severity.Error,
            COMMON_CODE_168 = 50993 | ConfigEvent.Severity.Error,
            COMMON_CODE_169 = 50994 | ConfigEvent.Severity.Error,
            COMMON_CODE_170 = 50995 | ConfigEvent.Severity.Error,
            COMMON_CODE_171 = 50996 | ConfigEvent.Severity.Error,
            COMMON_CODE_172 = 50997 | ConfigEvent.Severity.Error,
            COMMON_CODE_173 = 50998 | ConfigEvent.Severity.Error,
            COMMON_CODE_174 = 50999 | ConfigEvent.Severity.Error,
            COMMON_CODE_175 = 51000 | ConfigEvent.Severity.Error,
            COMMON_CODE_176 = 51001 | ConfigEvent.Severity.Error,
            COMMON_CODE_177 = 51002 | ConfigEvent.Severity.Error,
            COMMON_CODE_178 = 51003 | ConfigEvent.Severity.Error,
            COMMON_CODE_179 = 51004 | ConfigEvent.Severity.Error,
            COMMON_CODE_180 = 51005 | ConfigEvent.Severity.Error,
            COMMON_CODE_181 = 51006 | ConfigEvent.Severity.Error,
            COMMON_CODE_182 = 51007 | ConfigEvent.Severity.Error,
            COMMON_CODE_183 = 51008 | ConfigEvent.Severity.Error,
            COMMON_CODE_184 = 51009 | ConfigEvent.Severity.Error,
            COMMON_CODE_185 = 51010 | ConfigEvent.Severity.Error,
            WEBSTORE_EXECUTE_ERROR = 51011 | ConfigEvent.Severity.Error,
            WEBSTORE_EXECUTE_TIMEOUT_ERROR = 51012 | ConfigEvent.Severity.Error,
            WEBSTORE_EXECUTE_DEADLOCK_ERROR = 51013 | ConfigEvent.Severity.Error,
            COMMON_CODE_189 = 51014 | ConfigEvent.Severity.Error,
            COMMON_CODE_190 = 51015 | ConfigEvent.Severity.Error,
            COMMON_CODE_191 = 51016 | ConfigEvent.Severity.Error,
            COMMON_CODE_192 = 51017 | ConfigEvent.Severity.Error,
            COMMON_CODE_193 = 51018 | ConfigEvent.Severity.Error,
            COMMON_CODE_194 = 51019 | ConfigEvent.Severity.Error,
            COMMON_CODE_195 = 51020 | ConfigEvent.Severity.Error,
            COMMON_CODE_196 = 51021 | ConfigEvent.Severity.Error,
            COMMON_CODE_197 = 51022 | ConfigEvent.Severity.Error,
            COMMON_CODE_198 = 51023 | ConfigEvent.Severity.Error,
            COMMON_CODE_199 = 51024 | ConfigEvent.Severity.Error,
            COMMON_CODE_200 = 51025 | ConfigEvent.Severity.Error,
            DEPRECATED_SYNCCAST_EXTERNAL_EXCEPTION = 51030 | ConfigEvent.Severity.Error,
            COMMON_CODE_208 = 51033 | ConfigEvent.Severity.Error,
            COMMON_CODE_209 = 51034 | ConfigEvent.Severity.Error,
            COMMON_CODE_210 = 51035 | ConfigEvent.Severity.Error,
            COMMON_CODE_211 = 51036 | ConfigEvent.Severity.Error,
            COMMON_CODE_212 = 51037 | ConfigEvent.Severity.Error,
            COMMON_CODE_213 = 51038 | ConfigEvent.Severity.Error,
            COMMON_CODE_214 = 51039 | ConfigEvent.Severity.Error,
            COMMON_CODE_215 = 51040 | ConfigEvent.Severity.Error,
            COMMON_CODE_216 = 51041 | ConfigEvent.Severity.Error,
            COMMON_CODE_217 = 51042 | ConfigEvent.Severity.Error,
            COMMON_CODE_218 = 51043 | ConfigEvent.Severity.Error,
            COMMON_CODE_219 = 51044 | ConfigEvent.Severity.Error,
            COMMON_CODE_220 = 51045 | ConfigEvent.Severity.Error,
            COMMON_CODE_221 = 51046 | ConfigEvent.Severity.Error,
            COMMON_CODE_222 = 51047 | ConfigEvent.Severity.Error,
            COMMON_CODE_223 = 51048 | ConfigEvent.Severity.Error,
            COMMON_CODE_224 = 51049 | ConfigEvent.Severity.Error,
            COMMON_CODE_225 = 51050 | ConfigEvent.Severity.Error,
            COMMON_CODE_226 = 51051 | ConfigEvent.Severity.Error,
            COMMON_CODE_227 = 51052 | ConfigEvent.Severity.Error,
            COMMON_CODE_228 = 51053 | ConfigEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_229 = 51054 | ConfigEvent.Severity.Error,
            DEPRECATED_COMMON_CODE_230 = 51055 | ConfigEvent.Severity.Error,
            COMMON_CODE_231 = 51056 | ConfigEvent.Severity.Error,
            COMMON_CODE_232 = 51057 | ConfigEvent.Severity.Error,
            WMIS_EXTERNAL_EXCEPTION = 51058 | ConfigEvent.Severity.Error,
            COMMON_CODE_MATCH_STARTMIGRATE_FAILED = 51059 | ConfigEvent.Severity.Error,
            COMMON_CODE_MATCH_MIGRATESTATUS_FAILED_SPROC = 51060 | ConfigEvent.Severity.Error,
            COMMON_CODE_MATCH_UPDLTC_TV_FAILED = 51061 | ConfigEvent.Severity.Error,
            COMMON_CODE_MATCH_UPDLTC_NPDB_FAILED = 51062 | ConfigEvent.Severity.Error,
            COMMON_CODE_LSPLIB_SQLEXCEPTION = 51063 | ConfigEvent.Severity.Error,
            HEALTH_REPORT_RED = 51064 | ConfigEvent.Severity.Error,
            HEALTH_ENGINE_FAILURE = 51065 | ConfigEvent.Severity.Error,
            FEAPP_INITIALIZATION_METHOD_FAILED = 51066 | ConfigEvent.Severity.Error,
            FEAPP_INITIALIZATION_METHOD_NOT_FOUND = 51067 | ConfigEvent.Severity.Error,
            FAST_FAIL_MISSING_COUNTERS = 51068 | ConfigEvent.Severity.Error,
            FAST_FAIL_MISSING_RESOURCE = 51069 | ConfigEvent.Severity.Error,
            FEAPP_COMPRESSION_ERROR = 51070 | ConfigEvent.Severity.Error,
            UNHANDLED_THREAD_EXCEPTION = 51071 | ConfigEvent.Severity.Error,
            FEAPP_INIT_FAILURE = 51072 | ConfigEvent.Severity.Error,
            FORBIDDEN_NAMES_EXCLUDED_TITLES_CONFIG_ERROR = 51073 | ConfigEvent.Severity.Error,
            COMMON_COMM_6 = 51231 | ConfigEvent.Severity.Error,
            COMMON_COMM_7 = 51232 | ConfigEvent.Severity.Error,
            COMMON_COMM_8 = 51233 | ConfigEvent.Severity.Error,
            COMMON_COMM_9 = 51234 | ConfigEvent.Severity.Error,
            COMMON_COMM_10 = 51235 | ConfigEvent.Severity.Error,
            COMMON_COMM_11 = 51236 | ConfigEvent.Severity.Error,
            COMMON_COMM_12 = 51237 | ConfigEvent.Severity.Error,
            COMMON_COMM_13 = 51238 | ConfigEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE = 51239 | ConfigEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_1 = 51240 | ConfigEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_2 = 51241 | ConfigEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_3 = 51242 | ConfigEvent.Severity.Error,
            XCACHE_CLIENT_BROKEN_PIPE_4 = 51243 | ConfigEvent.Severity.Error,
            XCACHE_SERVER_BUSY = 51244 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE = 51245 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_1 = 51246 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_2 = 51247 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_3 = 51248 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_4 = 51249 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_5 = 51250 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_6 = 51251 | ConfigEvent.Severity.Error,
            PIPE_FAILURE = 51252 | ConfigEvent.Severity.Error,
            PIPE_FAILURE_1 = 51253 | ConfigEvent.Severity.Error,
            PIPE_FAILURE_2 = 51254 | ConfigEvent.Severity.Error,
            AUTHDATA_SG_COMMUNICATION_ERROR = 51255 | ConfigEvent.Severity.Error,
            COMMON_COMM_31 = 51256 | ConfigEvent.Severity.Error,
            AUTHDATA_SG_COMMUNICATION_ERROR_1 = 51257 | ConfigEvent.Severity.Error,
            MC_XRL_REQUEST_ERROR = 51258 | ConfigEvent.Severity.Error,
            COMMON_COMM_34 = 51259 | ConfigEvent.Severity.Error,
            COMMON_COMM_35 = 51260 | ConfigEvent.Severity.Error,
            COMMON_COMM_36 = 51261 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_MESSAGE_7 = 51262 | ConfigEvent.Severity.Error,
            XCACHE_INVALID_RESPONSE_1 = 51263 | ConfigEvent.Severity.Error,
            FORBIDDEN_NAMES_LOAD_SUCCESS = 51264 | ConfigEvent.Severity.Info,
            FORBIDDEN_NAMES_UNVETTED_STRING = 51265 | ConfigEvent.Severity.Error,
            MUSICNET_ACCOUNT_CREATE_FAILED = 51354 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_69 = 51394 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_70 = 51395 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_71 = 51396 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_72 = 51397 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_73 = 51398 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_74 = 51399 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_75 = 51400 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_76 = 51401 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_77 = 51402 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_78 = 51403 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_79 = 51404 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_80 = 51405 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_81 = 51406 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_82 = 51407 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_83 = 51408 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_84 = 51409 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_85 = 51410 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_86 = 51411 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_87 = 51412 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_88 = 51413 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_89 = 51414 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_90 = 51415 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_91 = 51416 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_92 = 51417 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_93 = 51418 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_94 = 51419 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_95 = 51420 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_96 = 51421 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_97 = 51422 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_98 = 51423 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_99 = 51424 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_100 = 51425 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_101 = 51426 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_102 = 51427 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_103 = 51428 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_104 = 51429 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_105 = 51430 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_106 = 51431 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_107 = 51432 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_108 = 51433 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_109 = 51434 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_110 = 51435 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_111 = 51436 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_112 = 51437 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_113 = 51438 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_114 = 51439 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_115 = 51440 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_116 = 51441 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_117 = 51442 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_118 = 51443 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_119 = 51444 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_120 = 51445 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_121 = 51446 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_122 = 51447 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_123 = 51448 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_124 = 51449 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_125 = 51450 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_126 = 51451 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_127 = 51452 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_128 = 51453 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_129 = 51454 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_130 = 51455 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_131 = 51456 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_132 = 51457 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_133 = 51458 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_134 = 51459 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_135 = 51460 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_136 = 51461 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_137 = 51462 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_138 = 51463 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_139 = 51464 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_140 = 51465 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_141 = 51466 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_142 = 51467 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_143 = 51468 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_144 = 51469 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_145 = 51470 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_146 = 51471 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_147 = 51472 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_148 = 51473 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_149 = 51474 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_150 = 51475 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_151 = 51476 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_152 = 51477 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_153 = 51478 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_154 = 51479 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_155 = 51480 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_156 = 51481 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_157 = 51482 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_158 = 51483 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_159 = 51484 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_160 = 51485 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_161 = 51486 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_162 = 51487 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_163 = 51488 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_164 = 51489 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_165 = 51490 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_166 = 51491 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_167 = 51492 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_168 = 51493 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_169 = 51494 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_170 = 51495 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_171 = 51496 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_172 = 51497 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_173 = 51498 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_174 = 51499 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_175 = 51500 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_176 = 51501 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_177 = 51502 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_178 = 51503 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_179 = 51504 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_180 = 51505 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_181 = 51506 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_182 = 51507 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_183 = 51508 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_184 = 51509 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_185 = 51510 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_186 = 51511 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_187 = 51512 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_188 = 51513 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_189 = 51514 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_190 = 51515 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_191 = 51516 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_192 = 51517 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_193 = 51518 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_194 = 51519 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_195 = 51520 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_196 = 51521 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_197 = 51522 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_198 = 51523 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_199 = 51524 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_200 = 51525 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_201 = 51526 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_202 = 51527 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_203 = 51528 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_204 = 51529 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_205 = 51530 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_206 = 51531 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_207 = 51532 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_208 = 51533 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_209 = 51534 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_210 = 51535 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_211 = 51536 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_212 = 51537 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_213 = 51538 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_214 = 51539 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_215 = 51540 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_216 = 51541 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_217 = 51542 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_218 = 51543 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_219 = 51544 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_220 = 51545 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_221 = 51546 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_222 = 51547 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_223 = 51548 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_224 = 51549 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_225 = 51550 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_226 = 51551 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_227 = 51552 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_228 = 51553 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_229 = 51554 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_230 = 51555 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_231 = 51556 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_232 = 51557 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_233 = 51558 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_234 = 51559 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_235 = 51560 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_236 = 51561 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_237 = 51562 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_238 = 51563 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_239 = 51564 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_240 = 51565 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_241 = 51566 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_242 = 51567 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_243 = 51568 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_244 = 51569 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_245 = 51570 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_246 = 51571 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_247 = 51572 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_248 = 51573 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_249 = 51574 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_250 = 51575 | ConfigEvent.Severity.Error,
            DEPRECATED_COMMON_CONFIG_251 = 51576 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_252 = 51577 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_253 = 51578 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_254 = 51579 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_255 = 51580 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_256 = 51581 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_257 = 51582 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_258 = 51583 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_259 = 51584 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_260 = 51585 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_261 = 51586 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_262 = 51587 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_263 = 51588 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_264 = 51589 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_265 = 51590 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_266 = 51591 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_PIPE_HANDLE_DISPOSED = 51593 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_270 = 51595 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_272 = 51597 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_274 = 51599 | ConfigEvent.Severity.Error,
            MC_SGINFO_IS_OFF = 51600 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_276 = 51601 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_277 = 51602 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_278 = 51603 | ConfigEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_4 = 51604 | ConfigEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_5 = 51605 | ConfigEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_6 = 51606 | ConfigEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_7 = 51607 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_283 = 51608 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_284 = 51609 | ConfigEvent.Severity.Error,
            MC_BAD_CONFIG_DATA_8 = 51610 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_286 = 51611 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_287 = 51612 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_288 = 51613 | ConfigEvent.Severity.Error,
            MGMT_CRITICAL_ERROR = 51614 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE = 51615 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_291 = 51616 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_292 = 51617 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_293 = 51618 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_1 = 51619 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_2 = 51620 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_3 = 51621 | ConfigEvent.Severity.Error,
            MGMT_INIT_WARNING = 51622 | ConfigEvent.Severity.Warning,
            MGMT_INIT_FAILURE_4 = 51623 | ConfigEvent.Severity.Error,
            MGMT_SRV_DISCONNECT = 51624 | ConfigEvent.Severity.Error,
            MGMT_SRV_DISCONNECT_1 = 51625 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_5 = 51626 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_6 = 51627 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING = 51628 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_1 = 51629 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_2 = 51630 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_3 = 51631 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_307 = 51632 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_4 = 51633 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_5 = 51634 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_310 = 51635 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_311 = 51636 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_6 = 51637 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_7 = 51638 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_8 = 51639 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_9 = 51640 | ConfigEvent.Severity.Error,
            MGMT_SUBCOMPONENT_WARNING_10 = 51641 | ConfigEvent.Severity.Error,
            MGMT_REMOTE_TARGET_WARNING = 51642 | ConfigEvent.Severity.Warning,
            COMMON_CONFIG_318 = 51643 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_319 = 51644 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_320 = 51645 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_321 = 51646 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_322 = 51647 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_323 = 51648 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_324 = 51649 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_325 = 51650 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_326 = 51651 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_327 = 51652 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_328 = 51653 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_329 = 51654 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_330 = 51655 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_331 = 51656 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_332 = 51657 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_333 = 51658 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_334 = 51659 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_335 = 51660 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_336 = 51661 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_337 = 51662 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_338 = 51663 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_339 = 51664 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_7 = 51665 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_8 = 51666 | ConfigEvent.Severity.Error,
            MGMT_INIT_FAILURE_9 = 51667 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_REPORTMESSAGECOMPONENTID_FAILURE = 51668 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_ADDREPORTMESSAGECOMPONENTIDMAPPING_FAILURE = 51669 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_INTEROP_REPORTMESSAGECLEANSERVIRTUALINTERFACE_FAILURE = 51670 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_340 = 51671 | ConfigEvent.Severity.Error,
            MGMT_READ_FAILURE = 51672 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_BAD_XLAST_FILE = 51674 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC = 51675 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_1 = 51676 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_2 = 51677 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_LTC_TIB_OUTOFSYNC = 51678 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_UNEXPECTED_MODE_IN_XLAST = 51679 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_MISSING_MODE_IN_XLAST = 51680 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_NONEXT = 51681 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_MISSING_BUCKET = 51682 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_EXPMIGRATE_FAILED_NOTSTARTED = 51683 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_LTC_TIB_OUTOFSYNC = 51684 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ADDRR_FAILED_MISSING_BUCKET = 51685 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_ADDRR_FAILED_DUPE_SERVER = 51686 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_UPDLTC_INVALID_LTC = 51687 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_DEFAULTBUCKETS_OVERWRITE = 51688 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_CONFIRMSERVER_BADSERVER = 51689 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_PREPLTC_TID_MISMATCH = 51690 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_NO_PARTMAP = 51691 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_MATCH_PREPCONFIG_TID_MISMATCH = 51692 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_GET_REFRESH_FUNCTIONS = 51693 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_HEALTH_CHANGE = 51694 | ConfigEvent.Severity.Error,
            COMMON_SETTING_BATCH_CONSTRUCTION = 51695 | ConfigEvent.Severity.Error,
            COMMON_SETTING_BATCH_QUERY = 51696 | ConfigEvent.Severity.Error,
            COMMON_SETTING_BATCH_SETTING_DELETED = 51697 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_REGISTER_DYNAMIC_SETTING_FAILURE = 51698 | ConfigEvent.Severity.Error,
            COMMON_BUCKETS_BATCH_CONSTRUCTION = 51699 | ConfigEvent.Severity.Error,
            COMMON_BUCKET_BATCH_QUERY = 51700 | ConfigEvent.Severity.Error,
            COMMON_BUCKET_BATCH_DELETED = 51701 | ConfigEvent.Severity.Error,
            COMMON_CONFIG_LIVE_REGISTRY_SETTINGS_CHANGE = 51702 | ConfigEvent.Severity.Error,
            PERFORMANCE_COUNTERS_0 = 51703 | ConfigEvent.Severity.Error,
            COMMON_HACK_4 = 52329 | ConfigEvent.Severity.Warning,
            COMMON_HACK_5 = 52330 | ConfigEvent.Severity.Warning,
            COMMON_HACK_6 = 52331 | ConfigEvent.Severity.Warning,
            COMMON_HACK_7 = 52332 | ConfigEvent.Severity.Warning,
            COMMON_HACK_8 = 52333 | ConfigEvent.Severity.Warning,
            COMMON_HACK_9 = 52334 | ConfigEvent.Severity.Warning,
            COMMON_HACK_10 = 52335 | ConfigEvent.Severity.Warning,
            COMMON_HACK_11 = 52336 | ConfigEvent.Severity.Warning,
            COMMON_HACK_12 = 52337 | ConfigEvent.Severity.Warning,
            COMMON_HACK_13 = 52338 | ConfigEvent.Severity.Warning,
            COMMON_HACK_14 = 52339 | ConfigEvent.Severity.Warning,
            COMMON_HACK_15 = 52340 | ConfigEvent.Severity.Warning,
            COMMON_HACK_16 = 52341 | ConfigEvent.Severity.Warning,
            COMMON_HACK_17 = 52342 | ConfigEvent.Severity.Warning,
            COMMON_HACK_18 = 52343 | ConfigEvent.Severity.Warning,
            COMMON_HACK_19 = 52344 | ConfigEvent.Severity.Warning,
            COMMON_HACK_20 = 52345 | ConfigEvent.Severity.Warning,
            COMMON_HACK_21 = 52346 | ConfigEvent.Severity.Warning,
            COMMON_HACK_22 = 52347 | ConfigEvent.Severity.Warning,
            COMMON_HACK_23 = 52348 | ConfigEvent.Severity.Warning,
            COMMON_HACK_24 = 52349 | ConfigEvent.Severity.Warning,
            COMMON_HACK_25 = 52350 | ConfigEvent.Severity.Warning,
            COMMON_HACK_26 = 52351 | ConfigEvent.Severity.Warning,
            COMMON_HACK_27 = 52352 | ConfigEvent.Severity.Warning,
            COMMON_HACK_28 = 52353 | ConfigEvent.Severity.Warning,
            COMMON_HACK_33 = 52358 | ConfigEvent.Severity.Warning,
            COMMON_HACK_34 = 52359 | ConfigEvent.Severity.Warning,
            COMMON_HACK_40 = 52365 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS = 52366 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_1 = 52367 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_2 = 52368 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_3 = 52369 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_4 = 52370 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_5 = 52371 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_6 = 52372 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_TEAM_TICKETS_7 = 52373 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_BUNDLED_AUTHDATA = 52374 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR = 52375 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_1 = 52376 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_2 = 52377 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_HTTP_AUTHDATA = 52378 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA = 52379 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_1 = 52380 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_2 = 52381 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_3 = 52382 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_4 = 52383 | ConfigEvent.Severity.Warning,
            AUTHDATA_BAD_SG_AUTHDATA_5 = 52384 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_3 = 52385 | ConfigEvent.Severity.Warning,
            COMMON_HACK_61 = 52386 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_4 = 52387 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_5 = 52388 | ConfigEvent.Severity.Warning,
            COMMON_HACK_64 = 52389 | ConfigEvent.Severity.Warning,
            COMMON_HACK_65 = 52390 | ConfigEvent.Severity.Warning,
            COMMON_HACK_66 = 52391 | ConfigEvent.Severity.Warning,
            COMMON_HACK_67 = 52392 | ConfigEvent.Severity.Warning,
            COMMON_HACK_68 = 52393 | ConfigEvent.Severity.Warning,
            COMMON_HACK_69 = 52394 | ConfigEvent.Severity.Warning,
            COMMON_HACK_70 = 52395 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_6 = 52396 | ConfigEvent.Severity.Warning,
            COMMON_HACK_72 = 52397 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_7 = 52398 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_8 = 52399 | ConfigEvent.Severity.Warning,
            AUTHDATA_VERIFICATION_ERROR_9 = 52400 | ConfigEvent.Severity.Warning,
            COMMON_HACK_76 = 52401 | ConfigEvent.Severity.Warning,
            COMMON_HACK_77 = 52402 | ConfigEvent.Severity.Warning,
            COMMON_HACK_78 = 52403 | ConfigEvent.Severity.Warning,
            COMMON_HACK_79 = 52404 | ConfigEvent.Severity.Warning,
            COMMON_HACK_80 = 52405 | ConfigEvent.Severity.Warning,
            HACK_CONTENT_NOT_FOUND = 52406 | ConfigEvent.Severity.Warning,
            USER_AGENT_MISSING = 52412 | ConfigEvent.Severity.Error,
            USER_AGENT_INVALID = 52413 | ConfigEvent.Severity.Error,
            AAINFO_INVALID_REQUEST = 52414 | ConfigEvent.Severity.Error,
            COMMON_HACK_81 = 52415 | ConfigEvent.Severity.Error,
            AUTHDATA_VERIFICATION_ERROR_10 = 52416 | ConfigEvent.Severity.Error,
            COMMON_INFO_4 = 52529 | ConfigEvent.Severity.Info,
            COMMON_INFO_5 = 52530 | ConfigEvent.Severity.Info,
            COMMON_INFO_6 = 52531 | ConfigEvent.Severity.Info,
            COMMON_INFO_7 = 52532 | ConfigEvent.Severity.Info,
            COMMON_INFO_8 = 52533 | ConfigEvent.Severity.Info,
            COMMON_INFO_9 = 52534 | ConfigEvent.Severity.Info,
            COMMON_INFO_10 = 52535 | ConfigEvent.Severity.Info,
            COMMON_INFO_11 = 52536 | ConfigEvent.Severity.Info,
            COMMON_INFO_12 = 52537 | ConfigEvent.Severity.Info,
            COMMON_INFO_13 = 52538 | ConfigEvent.Severity.Info,
            COMMON_INFO_14 = 52539 | ConfigEvent.Severity.Info,
            COMMON_INFO_15 = 52540 | ConfigEvent.Severity.Info,
            COMMON_INFO_16 = 52541 | ConfigEvent.Severity.Info,
            COMMON_INFO_17 = 52542 | ConfigEvent.Severity.Info,
            COMMON_INFO_18 = 52543 | ConfigEvent.Severity.Info,
            COMMON_INFO_19 = 52544 | ConfigEvent.Severity.Info,
            COMMON_INFO_20 = 52545 | ConfigEvent.Severity.Info,
            COMMON_INFO_21 = 52546 | ConfigEvent.Severity.Info,
            COMMON_INFO_22 = 52547 | ConfigEvent.Severity.Info,
            COMMON_INFO_23 = 52548 | ConfigEvent.Severity.Info,
            COMMON_INFO_24 = 52549 | ConfigEvent.Severity.Info,
            COMMON_INFO_25 = 52550 | ConfigEvent.Severity.Info,
            COMMON_INFO_26 = 52551 | ConfigEvent.Severity.Info,
            COMMON_INFO_27 = 52552 | ConfigEvent.Severity.Info,
            COMMON_INFO_28 = 52553 | ConfigEvent.Severity.Info,
            COMMON_INFO_29 = 52554 | ConfigEvent.Severity.Info,
            COMMON_INFO_30 = 52555 | ConfigEvent.Severity.Info,
            COMMON_INFO_31 = 52556 | ConfigEvent.Severity.Info,
            COMMON_INFO_32 = 52557 | ConfigEvent.Severity.Info,
            COMMON_INFO_33 = 52558 | ConfigEvent.Severity.Info,
            COMMON_INFO_34 = 52559 | ConfigEvent.Severity.Info,
            COMMON_INFO_35 = 52560 | ConfigEvent.Severity.Info,
            COMMON_INFO_36 = 52561 | ConfigEvent.Severity.Info,
            COMMON_INFO_37 = 52562 | ConfigEvent.Severity.Info,
            COMMON_INFO_38 = 52563 | ConfigEvent.Severity.Info,
            COMMON_INFO_39 = 52564 | ConfigEvent.Severity.Info,
            COMMON_INFO_40 = 52565 | ConfigEvent.Severity.Info,
            MC_APPDOMAIN_STARTED = 52566 | ConfigEvent.Severity.Info,
            MC_APPDOMAIN_STARTED_1 = 52567 | ConfigEvent.Severity.Info,
            COMMON_INFO_43 = 52568 | ConfigEvent.Severity.Info,
            COMMON_INFO_44 = 52569 | ConfigEvent.Severity.Info,
            COMMON_INFO_45 = 52570 | ConfigEvent.Severity.Info,
            COMMON_INFO_46 = 52571 | ConfigEvent.Severity.Info,
            COMMON_INFO_47 = 52572 | ConfigEvent.Severity.Info,
            COMMON_INFO_48 = 52573 | ConfigEvent.Severity.Info,
            MGMT_SRV_CONNECTED = 52574 | ConfigEvent.Severity.Info,
            REPORTINGTARGET_RECONNECTED = 52575 | ConfigEvent.Severity.Info,
            CONFIG_CHANGE_PROCESSED = 52576 | ConfigEvent.Severity.Info,
            HEALTH_REPORT_GREEN = 52577 | ConfigEvent.Severity.Info,
            COMMON_CONFIG_INFO_HEALTH_CHANGE = 52578 | ConfigEvent.Severity.Info,
            COMMON_SETTING_BATCH_COUNT = 52579 | ConfigEvent.Severity.Info,
            COMMON_BUCKET_COUNT = 52580 | ConfigEvent.Severity.Info,
            COMMON_CONFIG_INFO_LIVE_REGISTRY_SETTINGS_CHANGE = 52581 | ConfigEvent.Severity.Info,
            COMMON_CONFIG_INFO_CONFIG_BLOBS_CHANGE = 52582 | ConfigEvent.Severity.Info,
            COMMON_CONFIG_INFO_ETX_MANIFEST_CHANGE = 52583 | ConfigEvent.Severity.Info,
            COMMON_WARNING_0 = 52725 | ConfigEvent.Severity.Warning,
            HEALTH_REPORT_YELLOW = 52726 | ConfigEvent.Severity.Warning,
            AUDIT_INVALID_SUBSYSTEM = 63800 | ConfigEvent.Severity.Error,
            AUDIT_NO_SETTING = 63801 | ConfigEvent.Severity.Error,
            AUDIT_LOG_FAILURE = 63802 | ConfigEvent.Severity.Error,
 
           // AUTOGENERATED - do not add ids here 
        } 
    } 
} 
 
/////////////////////////////////////////////////////////////////////////////// 
// AUTO GENERATED FILE 
// MODIFY THE CORRESPONDING .xml AND .xsl FILES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Config.cs ===
using System.Collections.Generic;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace STF.common.config
{
    [ComVisible(true)]
    public enum Installer
    {
        unspecified,
        installutil,    // identifies a component as one that installutil can be run on
        xblsvc          // identifies a component as one that can be run with the -install parameter
    }

    [ComVisible(true)]
    public enum Site
    {
        // This is used to get a virtual interface for the "main" site, defined as the site
        // that contains NPDB, since NPDB is guaranteed to be a singleton
        main,

        // This is used to get a virtual interface for the same site as the server
        // that is making the request
        same,

        // This is used to get the only instance of a virtual interface in the service,
        // no matter what site it's in
        only
    }

    // No explicit initialization is required by the component
    // to get configuration information. The current environment name, siteid, server name,
    // and component name are detected automatically by the class. The current
    // component name is set to the current assembly name for C# components. Non-C#
    // components or C# components that need or want to specify a different component name
    // (e.g. shared code) may use one of the GetSetting overrides.
    [ComVisible(false)]
    public class Config : ConfigEventLogger
    {
        private static ConfigInstance _defaultInstance = null;
        private static readonly List<ConfigInstance> _instances = new List<ConfigInstance>();
        // Event fowarder delegates
        // EtxManifestChange
        private static void ForwardEtxManifestChange(
            object sender,
            EventArgs e)
        {
            OnEtxManifestChange(e);
        }

        private static readonly EtxManifestChangeEventHandler forwardEtxManifestChange = ForwardEtxManifestChange;

        // Event forwarder delegates.
        // ServerListChange
        private static void ForwardServerListChange(
            object sender,
            ServerListChangeEventArgs e)
        {
            OnServerListChange(e);
        }

        private static readonly ServerListChangeEventHandler forwardServerListChange = ForwardServerListChange;

        // InterfaceChange
        private static void ForwardInterfaceChange(
            object sender,
            InterfaceChangeEventArgs e)
        {
            OnInterfaceChange(e);
        }

        private static readonly InterfaceChangeEventHandler forwardInterfaceChange = ForwardInterfaceChange;

        // InterfaceBucketChange
        private static void ForwardInterfaceBucketChange(
            object sender,
            InterfaceBucketChangeEventArgs e)
        {
            OnInterfaceBucketChange(e);
        }

        private static readonly InterfaceBucketChangeEventHandler forwardInterfaceBucketChange = ForwardInterfaceBucketChange;

        // VirtualInterfaceChange
        private static void ForwardVirtualInterfaceChange(
            object sender,
            VirtualInterfaceChangeEventArgs e)
        {
            OnVirtualInterfaceChange(e);
        }

        private static readonly VirtualInterfaceChangeEventHandler forwardVirtualInterfaceChange = ForwardVirtualInterfaceChange;

        // VirtualInterfaceListChange
        private static void ForwardVirtualInterfaceListChange(
            object sender,
            VirtualInterfaceListChangeEventArgs e)
        {
            OnVirtualInterfaceListChange(e);
        }

        private static readonly VirtualInterfaceListChangeEventHandler forwardVirtualInterfaceListChange = ForwardVirtualInterfaceListChange;

        // SettingChange
        private static void ForwardSettingChange(
            object sender,
            SettingChangeEventArgs e)
        {
            OnSettingChange(e);
        }

        private static readonly SettingChangeEventHandler forwardSettingChange = ForwardSettingChange;

        // MultiSettingChange
        private static void ForwardMultiSettingChange(
            object sender,
            MultiSettingChangeEventArgs e)
        {
            OnMultiSettingChange(e);
        }

        private static readonly MultiSettingChangeEventHandler forwardMultiSettingChange = ForwardMultiSettingChange;

        // GameConfigChange
        private static void ForwardGameConfigChange(
            object sender,
            EventArgs e)
        {
            OnGameConfigChange(e);
        }

        private static readonly GameConfigChangeEventHandler forwardGameConfigChange = ForwardGameConfigChange;

        // XdelaySettingsChange
        private static void ForwardXdelaySettingsChange(
            object sender,
            EventArgs e)
        {
            OnXdelaySettingsChange(e);
        }

        private static readonly XdelaySettingsChangeEventHandler forwardXdelaySettingsChange = ForwardXdelaySettingsChange;

        // XrlMappingsChange
        private static void ForwardXrlMappingsChange(
            object sender,
            EventArgs e)
        {
            OnXrlMappingsChange(e);
        }

        private static readonly XrlMappingsChangeEventHandler forwardXrlMappingsChange = ForwardXrlMappingsChange;

        // HealthMappingsChange
        private static void ForwardHealthMappingsChange(
            object sender,
            EventArgs e)
        {
            OnHealthMappingsChange(e);
        }

        private static readonly HealthMappingsChangeEventHandler forwardHealthMappingsChange = ForwardHealthMappingsChange;

        // LiveRegistrySettingsChange
        private static void ForwardLiveRegistrySettingsChange(
            object sender,
            EventArgs e)
        {
            OnLiveRegistrySettingsChange(e);
        }

        private static readonly LiveRegistrySettingsChangeEventHandler forwardLiveRegistrySettingsChange = ForwardLiveRegistrySettingsChange;

        // LiveRegistrySettingsChange
        private static void ForwardServiceKeysChange(
            object sender,
            EventArgs e)
        {
            OnServiceKeysChange(e);
        }

        private static readonly ServiceKeysChangeEventHandler forwardServiceKeysChange = ForwardServiceKeysChange;

        // _npdbRefreshNotification
        private static void ForwardNpdbRefreshNotification(NpdbRefreshTypes npdbRefreshType)
        {
            OnNpdbRefresh(npdbRefreshType);
        }
        private static readonly RefreshTypeEventHandler forwardNpdbRefreshNotification = ForwardNpdbRefreshNotification;

        // We need the reader writer lock to be initialized before any
        // member is called, so we initialize it in a static constructor.
        // We also use this opportunity to attach our global change
        // event handlers.
        private static object _initLock = new object();
        private static void InitializeDefault()
        {
            lock (_initLock)
            {
                if (_defaultInstance != null)
                    return;

                _defaultInstance = ConfigInstance.Create();
                _instances.Add(_defaultInstance);

                _defaultInstance.ServerListChange += forwardServerListChange;
                _defaultInstance.InterfaceChange += forwardInterfaceChange;
                _defaultInstance.InterfaceBucketChange += forwardInterfaceBucketChange;
                _defaultInstance.VirtualInterfaceChange += forwardVirtualInterfaceChange;
                _defaultInstance.VirtualInterfaceListChange += forwardVirtualInterfaceListChange;
                _defaultInstance.SettingChange += forwardSettingChange;
                _defaultInstance.MultiSettingChange += forwardMultiSettingChange;
                _defaultInstance.GameConfigChange += forwardGameConfigChange;
                _defaultInstance.XdelaySettingsChange += forwardXdelaySettingsChange;
                _defaultInstance.XrlMappingsChange += forwardXrlMappingsChange;
                _defaultInstance.HealthMappingsChange += forwardHealthMappingsChange;
                _defaultInstance.LiveRegistrySettingsChange += forwardLiveRegistrySettingsChange;
            _defaultInstance.EtxManifestChange += forwardEtxManifestChange;
                _defaultInstance.ServiceKeysChange += forwardServiceKeysChange;
                _defaultInstance._npdbRefreshNotification += forwardNpdbRefreshNotification;
            }
        }

        // this is relative to HKLM

        public static ConfigInstance DefaultInstance
        {
            get
            {
                if (_defaultInstance == null)
                    InitializeDefault();

                return _defaultInstance;
            }
        }

        public static Int64 LatestChangeId
        {
            get
            {
                return DefaultInstance.LatestChangeId;
            }
        }

        public static TimeSpan MinEventInterval
        {
            get
            {
                return DefaultInstance.MinEventInterval;
            }
        }

        public static int CacheRefreshInterval
        {
            get
            {
                return DefaultInstance.CacheRefreshInterval;
            }
        }

        //While this could be use for other things, it is currently planned to be used for testing
        #region NPDB Refresh Type Notification

        public static event RefreshTypeEventHandler _npdbRefreshNotification = null;
        protected static void OnNpdbRefresh(NpdbRefreshTypes npdbRefreshType)
        {
            if (null != _npdbRefreshNotification)
            {
                _npdbRefreshNotification(npdbRefreshType);
            }
        }

        #endregion

        public static void CheckForUpdates()
        {
            DefaultInstance.CheckForUpdates();
        }


        public static string NpdbServer
        {
            get
            {
                return DefaultInstance.NpdbServer;
            }
            set
            {
                DefaultInstance.NpdbServer = value;
            }
        }

        public static string NpdbDatabase
        {
            get
            {
                return DefaultInstance.NpdbDatabase;
            }
            set
            {
                DefaultInstance.NpdbDatabase = value;
            }
        }

        public static System.Reflection.Assembly Assembly
        {
            [MethodImpl(MethodImplOptions.NoInlining)]
            get
            {
                return DefaultInstance.Assembly;
            }

            set {
                DefaultInstance.Assembly = value;
            }
        }

        public static string AssemblyPath
        {
            get
            {
                return DefaultInstance.AssemblyPath;
            }
        }

        public static string AssemblyDirectory
        {
            get
            {
                return DefaultInstance.AssemblyDirectory;
            }
        }

        public static string SqlApplicationName
        {
            get
            {
                return DefaultInstance.SqlApplicationName;
            }

            set
            {
                DefaultInstance.SqlApplicationName = value;
            }
        }
        public static string ComponentName
        {
            get
            {
                return DefaultInstance.ComponentName;
            }

            // This set method is provided for C++ clients accessing
            // config through COM interop. For these components,
            // GetCallingAssembly().GetName().Name resolves to
            // CommonConfig, instead of the caller's executable.
            // this results in the Component property resolving to
            // Component.unknown, which means that component specific
            // overrides don't work. It also means that the NT events
            // are written with ComponentName "CommonConfig" which gets
            // very confusing because it's hard to tell which NT events
            // came from which C++ components. Allowing C++ compoents
            // to set their Component name will resolve both of these
            // difficulties.
            set
            {
                DefaultInstance.ComponentName = value;
            }
        }
        
        public static int NpdbConnectionTimeout
        {
            get
            {
                return DefaultInstance.NpdbConnectionTimeout;
            }
            set
            {
                DefaultInstance.NpdbConnectionTimeout = value;
            }
        }
        
        public static string NpdbConnectionStringWithTimeout(int timeout)
        {
            return DefaultInstance.NpdbConnectionStringWithTimeout(timeout);
        }        

        public static string NpdbConnectionString
        {
            get
            {
                return DefaultInstance.NpdbConnectionString;
            }
        }

        public static string NativeNpdbConnectionString
        {
            get
            {
                return DefaultInstance.NativeNpdbConnectionString;
            }
        }

        public static string Environment
        {
            get
            {
                return DefaultInstance.Environment;
            }
        }

        public static string EnvironmentType
        {
            get
            {
                return DefaultInstance.EnvironmentType;
            }
        }

        // Some features are only allowed in test environments.  Encapsulate what
        // constitutes a test environment here
        public static bool IsTestEnvironment()
        {
            return DefaultInstance.IsTestEnvironment();
        }

        public static int SiteId
        {
            get
            {
                return DefaultInstance.SiteId;
            }
        }

        public static int MainSiteId
        {
            get
            {
                return DefaultInstance.MainSiteId;
            }
        }

        public static string Server
        {
            get
            {
                return DefaultInstance.Server;
            }
        }

        /// <summary>
        /// DO NOT USE!!!  SERIOUSLY!!!  WHAT ARE YOU THINKING???
        /// This is a Test Only Method.
        /// DO NOT USE!!!  SERIOUSLY!!!
        /// </summary>
        public static string ServerSet_TestOnly_DoNotUse
        {
            set
            {
                DefaultInstance.ServerSet_TestOnly_DoNotUse = value;
            }
        }

        /// <summary>
        /// Gets the ID used by the cleanser's ReportMessage protocol based on the current component.
        /// 0 is returned if no mapping for the current component has been defined.
        /// </summary>
        public static int ReportMessageComponentId
        {
            get
            {
                return DefaultInstance.ReportMessageComponentId;
            }
        }

        public static string ReportMessageCleanserVirtualInterface
        {
            get
            {
                return DefaultInstance.ReportMessageCleanserVirtualInterface;
            }
        }

        // Allows components to add additional mappings without having to modify the default mappings in
        // the Component class.
        public static void AddReportMessageComponentIdMapping(string component, int reportMessageId)
        {
            DefaultInstance.AddReportMessageComponentIdMapping(component, reportMessageId);
        }

        public static void RemoveReportMessageComponentIdMapping(string component)
        {
            DefaultInstance.RemoveReportMessageComponentIdMapping(component);
        }

        // This method discards all cached configuration information,
        // forcing it to be reread from the source. Services can use this
        // in response to an xmgmt command asking them to reread configuration data.
        public static void DiscardCachedValues()
        {
            DefaultInstance.DiscardCachedValues();
        }

        public static void GetServerInfo(string server, out int siteId)
        {
            DefaultInstance.GetServerInfo(server, out siteId);
        }

        // Gets a list of server names that are exposing a particular interface name
        public static string[] GetServerListByInterface(string iface)
        {
            return DefaultInstance.GetServerListByInterface(iface);
        }

        // attach ServerListChangeEventHandler delegates to this event to be notified
        // when server lists change in NPDB
        public static event ServerListChangeEventHandler ServerListChange;
        protected static void OnServerListChange(ServerListChangeEventArgs e)
        {
            if (ServerListChange != null)
            {
                ServerListChange(null, e);
            }
            else
            {
                // This is ok to do because DefaultInstance is NEVER exposed
                // in any way other than through the Config static methods i.e.
                // no one except the Config class will ever register event handlers.
                // So, an empty delegate list here should have the same behavior 
                // as an empty delegate list on the ConfigInstance class, which will
                // never be the case for DefaultInstance since Config always registers
                // its handlers.
                VetoServerListChange();
            }
        }

        // if the ServerListChangeHandler wants to veto the change, it calls
        // VetoServerListChange, which sets the _approveServerListChange flag to false
        public static void VetoServerListChange()
        {
            // ServerListChangeEventHandlers call this method if they
            // need to indicate that the server list change indicated by
            // the ServerListChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoServerListChange();
        }

        public static IInterfaceInfo GetInterface(
            string iface)
        {
            return DefaultInstance.GetInterface(iface);
        }


        public static IInterfaceInfo GetInterface(
            string server,
            string iface)
        {
            return DefaultInstance.GetInterface(server, iface);
        }


        public static IInterfaceInfo GetInterface(
            string environment,
            string server,
            string iface)
        {
            return DefaultInstance.GetInterface(environment, server, iface);
        }



        // attach InterfaceChangeEventHandler delegates to this event to be notified
        // when interface info changes in NPDB
        public static event InterfaceChangeEventHandler InterfaceChange;
        protected static void OnInterfaceChange(InterfaceChangeEventArgs e)
        {
            if (InterfaceChange != null)
            {
                InterfaceChange(null, e);
            }
            else
            {
                // This is ok to do because DefaultInstance is NEVER exposed
                // in any way other than through the Config static methods i.e.
                // no one except the Config class will ever register event handlers.
                // So, an empty delegate list here should have the same behavior 
                // as an empty delegate list on the ConfigInstance class, which will
                // never be the case for DefaultInstance since Config always registers
                // its handlers.
                VetoInterfaceChange();
            }
        }

        // if the InterfaceChangeHandler wants to veto the change, it calls
        // VetoInterfaceChange, which sets the _approveInterfaceChange flag to false
        public static void VetoInterfaceChange()
        {
            // InterfaceChangeEventHandlers call this method if they
            // need to indicate that the interface change indicated by
            // the InterfaceChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoInterfaceChange();
        }

        // Retrieves the information required to reach a particular interface,
        // when the caller expects only one server to expose that interface.
        // A good example of when this might be used is when querying for
        // a non-partitioned database interface. The interface is not virtual,
        // but there will still only be one instance of that interface because
        // the data is not partitioned. If more than one server exposes the
        // specified interface, then an ApplicationException will be thrown
        public static IInterfaceInfo GetSingleInterface(string iface)
        {
            return DefaultInstance.GetSingleInterface(iface);
        }

        public static IBucketServer GetBucketServer(string iface, uint bucket)
        {
            return DefaultInstance.GetBucketServer(iface, bucket);
        }

        public static IBucketServer GetTitleBucketServer(
            string iface,
            uint titleId,
            uint bucket)
        {
            return DefaultInstance.GetTitleBucketServer(iface, titleId, bucket);
        }

        // attach InterfaceBucketChangeEventHandler delegates to this event to be notified
        // when interface bucket info changes in NPDB
        public static event InterfaceBucketChangeEventHandler InterfaceBucketChange;
        protected static void OnInterfaceBucketChange(InterfaceBucketChangeEventArgs e)
        {
            if(InterfaceBucketChange != null)
            {
                InterfaceBucketChange(null, e);
            }
            else
            {
                // This is ok to do because DefaultInstance is NEVER exposed
                // in any way other than through the Config static methods i.e.
                // no one except the Config class will ever register event handlers.
                // So, an empty delegate list here should have the same behavior 
                // as an empty delegate list on the ConfigInstance class, which will
                // never be the case for DefaultInstance since Config always registers
                // its handlers.
                VetoInterfaceBucketChange();
            }
        }

        // if the InterfaceBucketChangeHandler wants to veto the change, it calls
        // VetoInterfaceBucketChange, which sets the _approveInterfaceBucketChange
        // flag to false
        public static void VetoInterfaceBucketChange()
        {
            // InterfaceBucketChangeEventHandlers call this method if they
            // need to indicate that the interface change indicated by
            // the InterfaceBucketChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoInterfaceBucketChange();
        }


        public static uint GetBucketNum(string iface, ulong hashValue)
        {
            return DefaultInstance.GetBucketNum(iface, hashValue);
        }

        public static uint GetRandomBucketNum(string iface)
        {
            return DefaultInstance.GetRandomBucketNum(iface);
        }


        public static uint GetBucketCount(string iface)
        {
            return DefaultInstance.GetBucketCount(iface);
        }


        public static bool TryGetBucketCount(string iface, out uint bucketCount)
        {
            return DefaultInstance.TryGetBucketCount(iface, out bucketCount);
        }

        public static void CompleteMigration(string iface, uint bucket)
        {
            DefaultInstance.CompleteMigration(iface, bucket);
        }

        // this method does not modify the interface bucket cache - we rely on the usual
        // detection and notification procedure to take care of that
        public static void CompleteTitleMigration(string iface, uint titleId, uint bucket)
        {
            DefaultInstance.CompleteTitleMigration(iface, titleId, bucket);
        }

        public static string[] GetVirtualInterfaceListBySite(Site site)
        {
            return DefaultInstance.GetVirtualInterfaceListBySite(site);
        }

        public static string[] GetVirtualInterfaceListBySite(int siteId)
        {
            return DefaultInstance.GetVirtualInterfaceListBySite(siteId);
        }

        // attach VirtualInterfaceListChangeEventHandler delegates to this event to be notified
        // when virtual interface lists change in NPDB
        public static event VirtualInterfaceListChangeEventHandler VirtualInterfaceListChange;
        protected static void OnVirtualInterfaceListChange(VirtualInterfaceListChangeEventArgs e)
        {
            if (VirtualInterfaceListChange != null)
            {
                VirtualInterfaceListChange(null, e);
            }
            else
            {
                // This is ok to do because DefaultInstance is NEVER exposed
                // in any way other than through the Config static methods i.e.
                // no one except the Config class will ever register event handlers.
                // So, an empty delegate list here should have the same behavior 
                // as an empty delegate list on the ConfigInstance class, which will
                // never be the case for DefaultInstance since Config always registers
                // its handlers.
                VetoVirtualInterfaceListChange();
            }
        }

        // if the VirtualInterfaceListChangeHandler wants to veto the change, it calls
        // VetoVirtualInterfaceListChange, which sets the _approveVirtualInterfaceListChange flag to false
        public static void VetoVirtualInterfaceListChange()
        {
            // VirtualInterfaceListChangeEventHandlers call this method if they
            // need to indicate that the virtual interface list change indicated by
            // the VirtualInterfaceListChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoVirtualInterfaceListChange();
        }

        public static IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(Site site)
        {
            return DefaultInstance.GetVirtualInterfaceInfoBySite(site);
        }

        public static IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(int siteId)
        {
            return DefaultInstance.GetVirtualInterfaceInfoBySite(siteId);
        }

        // Retrieves the information required to reach a virtual interface.
        public static bool TryGetVirtualInterface(string virtualInterface, out IVirtualInterfaceInfo virtualInterfaceInfo)
        {
            return DefaultInstance.TryGetVirtualInterface(virtualInterface, out virtualInterfaceInfo);
        }

        // Retrieves the information required to reach a virtual interface.
        public static IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface)
        {
            return DefaultInstance.GetVirtualInterface(virtualInterface);
        }

        public static IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, Site site)
        {
            return DefaultInstance.GetVirtualInterface(virtualInterface, site);
        }

        public static IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, int siteId)
        {
            return DefaultInstance.GetVirtualInterface(virtualInterface, siteId);
        }

        // attach VirtualInterfaceChangeEventHandler delegates to this event to be notified
        // when virtual interface info changes in NPDB
        public static event VirtualInterfaceChangeEventHandler VirtualInterfaceChange;
        protected static void OnVirtualInterfaceChange(VirtualInterfaceChangeEventArgs e)
        {
            if (VirtualInterfaceChange != null)
            {
                VirtualInterfaceChange(null, e);
            }
            else
            {
                // This is ok to do because DefaultInstance is NEVER exposed
                // in any way other than through the Config static methods i.e.
                // no one except the Config class will ever register event handlers.
                // So, an empty delegate list here should have the same behavior 
                // as an empty delegate list on the ConfigInstance class, which will
                // never be the case for DefaultInstance since Config always registers
                // its handlers.
                VetoVirtualInterfaceChange();
            }
        }

        // if the VirtualInterfaceChangeHandler wants to veto the change, it calls
        // VetoVirtualInterfaceChange, which sets the _approveVirtualInterfaceChange flag to false
        public static void VetoVirtualInterfaceChange()
        {
            // VirtualInterfaceChangeEventHandlers call this method if they
            // need to indicate that the virtual interface change indicated by
            // the VirtualInterfaceChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoVirtualInterfaceChange();
        }

        // use this API to retrieve the value for a boolean setting for the
        // current component on the current server
        public static bool GetBoolSetting(string setting)
        {
            return DefaultInstance.GetBoolSetting(setting);
        }

        // use this API to convert the value for a boolean setting
        // for instance, when the string value is given in a SettingChangeEventArgs
        public static bool ConvertBoolSetting(string settingValue)
        {
            string val = (settingValue ?? "").ToLower();
            return (val == "1" || val == "yes" || val == "true" || val == "on");
        }

        // use this API to retrieve the value for a signed integer setting for the
        // current component on the current server
        public static int GetIntSetting(string setting)
        {
            return DefaultInstance.GetIntSetting(setting);
        }

        // use this API to retrieve the value for an unsigned integer setting for the
        // current component on the current server
        public static uint GetUIntSetting(string setting)
        {
            return DefaultInstance.GetUIntSetting(setting);
        }

        // use this API to retrieve the value for an IP address as an unsigned integer setting for the
        // current component on the current server
        public static uint GetUIntIpSetting(string setting)
        {
            return DefaultInstance.GetUIntIpSetting(setting);
        }

        // use this API to retrieve the value for a signed integer setting for the
        // current component on the current server
        public static long GetLongSetting(string setting)
        {
            return DefaultInstance.GetLongSetting(setting);
        }

        // use this API to retrieve the value for an unsigned integer setting for the
        // current component on the current server
        public static ulong GetULongSetting(string setting)
        {
            return DefaultInstance.GetULongSetting(setting);
        }

        // use this API to retrieve the value for a double precision floating point setting for the
        // current component on the current server
        public static double GetDoubleSetting(string setting)
        {
            return DefaultInstance.GetDoubleSetting(setting);
        }

        // use this API to retrieve the value for a setting for the
        // current component on the current server
        public static string GetSetting(string setting)
        {
            return DefaultInstance.GetSetting(setting);
        }

        // Gets a setting from the blob table
        public static byte[] GetBlobSetting(string setting)
        {
            return DefaultInstance.GetBlobSetting(setting);
        }

        // attach SettingChangeEventHandler delegates to this event to be notified
        // when settings change in NPDB
        public static event SettingChangeEventHandler SettingChange;
        protected static void OnSettingChange(SettingChangeEventArgs e)
        {
            if (SettingChange != null)
            {
                SettingChange(null, e);
            }
        }

        // if the SettingChangeEventHandler wants to veto the change, it calls
        // VetoSetingChange, which sets the _approveSettingsChange flag to false
        public static void VetoSettingChange()
        {
            // SettingChangeEventHandlers call this method if they
            // need to indicate that the setting change indicated by
            // the SettingChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoSettingChange();
        }

        public static void TryCacheSettings(
            params string[] settings)
        {
            DefaultInstance.TryCacheSettings(settings);
        }


        public static void RegisterDynamicSetting(string setting)
        {
            DefaultInstance.RegisterDynamicSetting(setting);
        }

        public static void UnRegisterDynamicSetting(string setting)
        {
            DefaultInstance.UnRegisterDynamicSetting(setting);
        }

        // use this API to retrieve the values for a multisetting for the
        // current component on the current server
        public static string[] GetMultiSetting(
            string multiSetting)
        {
            return DefaultInstance.GetMultiSetting(multiSetting);
        }

        // this API provides a way to explicitly specify the component name
        // may be useful for shared code
        public static string[] GetMultiSetting(
            string multiSetting,
            string component)
        {
            return DefaultInstance.GetMultiSetting(multiSetting, component);
        }

        // this API provides a way to explicitly specify the environment, siteid, server, and component
        public static string[] GetMultiSetting(
            string environment,
            int siteId,
            string server,
            string component,
            string multiSetting)
        {
            return DefaultInstance.GetMultiSetting(environment, siteId, server, component, multiSetting);
        }

        // attach MultiSettingChangeEventHandler delegates to this event to be notified
        // when multi settings change in NPDB
        public static event MultiSettingChangeEventHandler MultiSettingChange;
        protected static void OnMultiSettingChange(MultiSettingChangeEventArgs e)
        {
            if (MultiSettingChange != null)
            {
                MultiSettingChange(null, e);
            }
        }

        // if the MultiSettingChangeEventHandler wants to veto the change, it calls
        // VetoMultiSettingChange, which sets the _approveMultiSettingChange flag to false
        public static void VetoMultiSettingChange()
        {
            // MultiSettingChangeEventHandlers call this method if they
            // need to indicate that the multi setting change indicated by
            // the MultiSettingChangeEventArgs should not be committed
            // to the cache
            DefaultInstance.VetoMultiSettingChange();
        }


        // the following methods are intended for use by Setup and not services
        public static string[] GetInstallUnitListByServer(
            string server)
        {
            return DefaultInstance.GetInstallUnitListByServer(server);
        }

        public static InstallUnitInfo[] GetInstallUnitInfoByServer(
            string server)
        {
            return DefaultInstance.GetInstallUnitInfoByServer(server);
        }

        public static string[] GetInstallUnitListByServer(
            string environment,
            string server)
        {
            return DefaultInstance.GetInstallUnitListByServer(environment, server);
        }

        public static InstallUnitInfo[] GetInstallUnitInfoByServer(
            string environment,
            string server)
        {
            throw new Exception("not yet implemented");
        }

        public static IInstallUnitInfo GetInstallUnit(string installUnit)
        {
            return DefaultInstance.GetInstallUnit(installUnit);
        }

        public static string[] GetComponentListByServer(
            string server)
        {
            return DefaultInstance.GetComponentListByServer(server);
        }

        public static ComponentInfo[] GetComponentInfoByServer(
            string server)
        {
            return DefaultInstance.GetComponentInfoByServer(server);
        }

        public static string[] GetComponentListByServer(
            string environment,
            string server)
        {
            return DefaultInstance.GetComponentListByServer(environment, server);
        }


        public static bool CheckServerConfiguration(string environment, string server, string component)
        {
            return DefaultInstance.CheckServerConfiguration(environment, server, component);
        }

        public static ComponentInfo[] GetComponentInfoByServer(
            string environment,
            string server)
        {
            return DefaultInstance.GetComponentInfoByServer(environment, server);
        }

        public static IComponentInfo GetComponent(string component)
        {
            return DefaultInstance.GetComponent(component);
        }

        public static string[] GetInterfaceListByServer(
            string server)
        {
            return DefaultInstance.GetInterfaceListByServer(server);
        }

        public static InterfaceInfo[] GetInterfaceInfoByServer(
            string server)
        {
            return DefaultInstance.GetInterfaceInfoByServer(server);
        }

        public static string[] GetInterfaceListByServer(
            string environment,
            string server)
        {
            return DefaultInstance.GetInterfaceListByServer(environment, server);
        }

        // also used by SG, in addition to setup
        public static InterfaceInfo[] GetInterfaceInfoByServer(
            string environment,
            string server)
        {
            return DefaultInstance.GetInterfaceInfoByServer(environment, server);
        }

        // attach GameConfigChangeEventHandler delegates to this event to be notified
        // when t_game_config is modified in NPDB
        public static event GameConfigChangeEventHandler GameConfigChange;
        protected static void OnGameConfigChange(EventArgs e)
        {
            if (GameConfigChange != null)
            {
                GameConfigChange(null, e);
            }
        }

        // attach XdelaySettingsChangeEventHandler delegates to this event to be notified
        // when t_xdelay_settings is modified in NPDB
        public static event XdelaySettingsChangeEventHandler XdelaySettingsChange;
        protected static void OnXdelaySettingsChange(EventArgs e)
        {
            if (XdelaySettingsChange != null)
            {
                XdelaySettingsChange(null, e);
            }
        }

        // attach XrlMappingsChangeEventHandler delegates to this event to be notified
        // when t_xdelay_settings is modified in NPDB
        public static event XrlMappingsChangeEventHandler XrlMappingsChange;
        protected static void OnXrlMappingsChange(EventArgs e)
        {
            if (XrlMappingsChange != null)
            {
                XrlMappingsChange(null, e);
            }
        }

        // attach HealthMappingsChangeEventHandler delegates to this event to be notified
        // when t_health_mappings is modified in NPDB
        public static event HealthMappingsChangeEventHandler HealthMappingsChange;
        protected static void OnHealthMappingsChange(EventArgs e)
        {
            if (HealthMappingsChange != null)
            {
                HealthMappingsChange(null, e);
            }
        }


        // attach LiveRegistrySettingsChangeEventHandler delegates to this event to be notified
        // when t_live_registry_settings is modified in NPDB
        public static event LiveRegistrySettingsChangeEventHandler LiveRegistrySettingsChange;
        protected static void OnLiveRegistrySettingsChange(EventArgs e)
        {
            if (LiveRegistrySettingsChange != null)
            {
                LiveRegistrySettingsChange(null, e);
            }
        }

        // attach SeviceKeyChangeEventHandler delegates to this event to be notified
        // when t_service_keys is modified in NPDB
        public static event ServiceKeysChangeEventHandler ServiceKeysChange;
        protected static void OnServiceKeysChange(EventArgs e)
        {
            if (ServiceKeysChange != null)
            {
                ServiceKeysChange(null, e);
            }
        }

        // attach EtxManifestChangeEventHandler delegates to this event to be notified
        // when an etx manifest table is modified in NPDB
        public static event EtxManifestChangeEventHandler EtxManifestChange;
        protected static void OnEtxManifestChange(EventArgs e)
        {
            if (EtxManifestChange != null)
            {
                EtxManifestChange(null, e);
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="server"></param>
        /// <param name="iface"></param>
        public static void AddServerInterfaceConfiguration(
            string environment,
            string server,
            string iface)
        {
            DefaultInstance.AddServerInterfaceConfiguration(environment, server, iface);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="server"></param>
        /// <param name="iface"></param>
        public static void RemoveServerInterfaceConfiguration(
            string environment,
            string server,
            string iface)
        {
            DefaultInstance.RemoveServerInterfaceConfiguration(environment, server, iface);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="userrole"></param>
        /// <returns></returns>
        public static IUserRole GetUserRole(string userrole)
        {
            return DefaultInstance.GetUserRole(userrole);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="environment"></param>
        /// <param name="userrole"></param>
        /// <returns></returns>
        public static IUserRole GetUserRole(string environment, string userrole)
        {
            return DefaultInstance.GetUserRole(environment, userrole);
        }


#if TEST
    public static void SetSingleInterface(string iface, IInterfaceInfo info)
    {
        DefaultInstance.SetSingleInterface(iface, info);
    }

    public static void SetInterface(string server, string iface, IInterfaceInfo info)
    {
        DefaultInstance.SetInterface(server, iface, info);
    }
#endif

    }

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigInterop.cs ===
using System;
using System.Runtime.InteropServices;
using System.Threading;


namespace STF.common.config
{

// This class exists for COM interop - it implements the IConfig interface
// which is exported by tlbexp and consumed by COM clients. These methods simply
// call the static Config methods.

// 
// Since this object is used by c++ components, any exceptions thrown by common
//  config are lost in the translation. To avoid this, the Interop methods all catch their
//  own exceptions and log NT events before re-throwing. 
//
    [ComVisible(true)]
[GuidAttribute("07623A8A-002E-4906-B931-DD31819A5812")] // fix the guid, so it doesn't change with each build
[ClassInterfaceAttribute(ClassInterfaceType.None)]  // force clients to use the IConfig interface
public class ConfigInterop : ConfigEventLogger, IConfig
{
    public ConfigInterop()
    {
        // create delegates to the change events that translate them
        // into calls to the ConfigListener
        _serverListChangeEventHandler           = new ServerListChangeEventHandler(this.ServerListChange);
        _interfaceChangeEventHandler            = new InterfaceChangeEventHandler(this.InterfaceChange);
        _interfaceBucketChangeEventHandler      = new InterfaceBucketChangeEventHandler(this.InterfaceBucketChange);
        _virtualInterfaceChangeEventHandler     = new VirtualInterfaceChangeEventHandler(this.VirtualInterfaceChange);
        _virtualInterfaceListChangeEventHandler = new VirtualInterfaceListChangeEventHandler(this.VirtualInterfaceListChange);
        _settingChangeEventHandler              = new SettingChangeEventHandler(this.SettingChange);
        _multiSettingChangeEventHandler         = new MultiSettingChangeEventHandler(this.MultiSettingChange);
        _gameConfigChangeEventHandler           = new GameConfigChangeEventHandler(this.GameConfigChange);
        _xdelaySettingsChangeEventHandler       = new XdelaySettingsChangeEventHandler(this.XdelaySettingsChange);
        _xrlMappingsChangeEventHandler          = new XrlMappingsChangeEventHandler(this.XrlMappingsChange);
    }

    private void ServerListChange(object sender, ServerListChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.ServerListChange(e);
        }
    }

    private void InterfaceChange(object sender, InterfaceChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.InterfaceChange(e);
        }
    }

    private void InterfaceBucketChange(object sender, InterfaceBucketChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.InterfaceBucketChange(e);
        }
    }

    private void VirtualInterfaceChange(object sender, VirtualInterfaceChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.VirtualInterfaceChange(e);
        }
    }

    private void VirtualInterfaceListChange(object sender, VirtualInterfaceListChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.VirtualInterfaceListChange(e);
        }
    }

    private void SettingChange(object sender, SettingChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.SettingChange(e);
        }
    }

    private void MultiSettingChange(object sender, MultiSettingChangeEventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.MultiSettingChange(e);
        }
    }

    private void GameConfigChange(object sender, EventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.GameConfigChange();
        }
    }

    private void XdelaySettingsChange(object sender, EventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.XdelaySettingsChange();
        }
    }

    private void XrlMappingsChange(object sender, EventArgs e)
    {
        if (ConfigListener != null)
        {
            ConfigListener.XrlMappingsChange();
        }
    }

    public void VetoInterfaceBucketChange()
    {
        Config.VetoInterfaceBucketChange(); ;
    }

    public void VetoInterfaceChange()
    {
        Config.VetoInterfaceChange();
    }

    public void VetoMultiSettingChange()
    {
        Config.VetoMultiSettingChange();
    }

    public void VetoServerListChange()
    {
        Config.VetoServerListChange();
    }

    public void VetoSettingChange()
    {
        Config.VetoSettingChange();
    }

    public void VetoVirtualInterfaceChange()
    {
        Config.VetoVirtualInterfaceChange();
    }

    public void VetoVirtualInterfaceListChange()
    {
        Config.VetoVirtualInterfaceListChange();
    }
    
    public string InstallUnitToString(string installUnit)
    {
        return installUnit;
    }

    public string ComponentToString(string component)
    {
        return component;
    }

    public string InterfaceToString(string iface)
    {
        return iface;
    }

    public string VirtualInterfaceToString(string viface)
    {
        return viface;
    }

    public string SettingToString(string setting)
    {
        return setting;
    }

    public string MultiSettingToString(string multiSetting)
    {
        return multiSetting;
    }

    public string InstallerToString(Installer installer)
    {
        return installer.ToString();
    }

    public string SiteToString(Site site)
    {
        return site.ToString();
    }

    public void CheckForUpdates()
    {
        Config.CheckForUpdates();
    }

    private IConfigListener _configListener = null;

    private ServerListChangeEventHandler           _serverListChangeEventHandler           = null;
    private InterfaceChangeEventHandler            _interfaceChangeEventHandler            = null;
    private InterfaceBucketChangeEventHandler      _interfaceBucketChangeEventHandler      = null;
    private VirtualInterfaceChangeEventHandler     _virtualInterfaceChangeEventHandler     = null;
    private VirtualInterfaceListChangeEventHandler _virtualInterfaceListChangeEventHandler = null;
    private SettingChangeEventHandler              _settingChangeEventHandler              = null;
    private MultiSettingChangeEventHandler         _multiSettingChangeEventHandler         = null;
    private GameConfigChangeEventHandler           _gameConfigChangeEventHandler           = null;
    private XdelaySettingsChangeEventHandler       _xdelaySettingsChangeEventHandler       = null;
    private XrlMappingsChangeEventHandler          _xrlMappingsChangeEventHandler          = null;

    public IConfigListener ConfigListener
    {
        set
        {
            if (_configListener != null)
            {
                Marshal.ReleaseComObject(_configListener);
            }
            
            _configListener = value;

            if (null != _configListener) 
            {
                // attach delegates
                Config.ServerListChange           += _serverListChangeEventHandler;
                Config.InterfaceChange            += _interfaceChangeEventHandler;
                Config.InterfaceBucketChange      += _interfaceBucketChangeEventHandler;
                Config.VirtualInterfaceChange     += _virtualInterfaceChangeEventHandler;
                Config.VirtualInterfaceListChange += _virtualInterfaceListChangeEventHandler;
                Config.SettingChange              += _settingChangeEventHandler;
                Config.MultiSettingChange         += _multiSettingChangeEventHandler;
                Config.GameConfigChange           += _gameConfigChangeEventHandler;
                Config.XdelaySettingsChange       += _xdelaySettingsChangeEventHandler;
                Config.XrlMappingsChange          += _xrlMappingsChangeEventHandler;
            }
            else 
            {
                // detach delegates
                Config.ServerListChange           -= _serverListChangeEventHandler;
                Config.InterfaceChange            -= _interfaceChangeEventHandler;
                Config.InterfaceBucketChange      -= _interfaceBucketChangeEventHandler;
                Config.VirtualInterfaceChange     -= _virtualInterfaceChangeEventHandler;
                Config.VirtualInterfaceListChange -= _virtualInterfaceListChangeEventHandler;
                Config.SettingChange              -= _settingChangeEventHandler;
                Config.MultiSettingChange         -= _multiSettingChangeEventHandler;
                Config.GameConfigChange           -= _gameConfigChangeEventHandler;
                Config.XdelaySettingsChange       -= _xdelaySettingsChangeEventHandler;
                Config.XrlMappingsChange          -= _xrlMappingsChangeEventHandler;
            }
        }
        get
        {
            return _configListener;
        }
    }

    public string Environment
    {
        get
        {
            string environment = null;

            try
            {
                environment = Config.Environment;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_186);
                throw;
            }

            return environment;
        }
    }

    public int SiteId
    {
        get
        {
            int siteId = 0;

            try
            {
                siteId = Config.SiteId;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_187);
                throw;
            }

            return siteId;
        }
    }

    public string Server
    {
        get
        {
            string server = null;

            try
            {
                server = Config.Server;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_188);
                throw;
            }

            return server;
        }
    }

    public string ServerSet_TestOnly_DoNotUse
    {
        set
        {
            try
            {
                Config.ServerSet_TestOnly_DoNotUse = value;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_189);
                throw;
            }
        }
    }

    public string NpdbDatabase
    {
        get
        {
            try
            {
                return Config.NpdbDatabase;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_190);
                throw;
            }
        }
    }

    public string NpdbServer
    {
        get
        {
            try
            {
                return Config.NpdbServer;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_190);
                throw;
            }
        }
    }

    public string NpdbConnectionString
    {
        get
        {
            try
            {
                return Config.NativeNpdbConnectionString;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_190);
                throw;
            }
        }
    }
    
    public string Component
    {
        get
        {
            string component = STF.common.config.Component.unknown;

            try
            {
                component = Config.ComponentName;
            }
            catch (Exception e)
            {
                Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_191);
                throw;
            }

            return component;
        }
    }

    public string ComponentName
    {
        get
        {
            string componentName = null;

            try
            {
                componentName = Config.ComponentName;
            }
            catch (Exception e)
            {
                Config.LogNtEvent("CommonConfig", e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_192);
                throw;
            }

            return componentName;
        }
        set
        {
            try
            {
                Config.ComponentName = value;
            }
            catch (Exception e)
            {
                Config.LogNtEvent("CommonConfig", e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_193);
                throw;
            }
        }
    }

    public int ReportMessageComponentId 
    { 
        get
        {
            int componentId = 0;

            try
            {
                componentId = Config.ReportMessageComponentId;
            }
            catch (Exception e)
            {
                Config.LogNtEvent("CommonConfig", e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_INTEROP_REPORTMESSAGECOMPONENTID_FAILURE);
                throw;
            }

            return componentId;
        }
    }

    public string ReportMessageCleanserVirtualInterface 
    { 
        get
        {
            string virtInt = "";

            try
            {
                virtInt = Config.ReportMessageCleanserVirtualInterface;
            }
            catch (Exception e)
            {
                Config.LogNtEvent("CommonConfig", e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_INTEROP_REPORTMESSAGECLEANSERVIRTUALINTERFACE_FAILURE);
                throw;
            }

            return virtInt;
        }
    }

    public void AddReportMessageComponentIdMapping(string component, int reportMessageId)
    {
        try
        {
            Config.AddReportMessageComponentIdMapping(component, reportMessageId);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_INTEROP_ADDREPORTMESSAGECOMPONENTIDMAPPING_FAILURE);
            throw;
        }

        return;
    }

    public void GetServerInfo(string server, out int siteId)
    {
        try
        {
            Config.GetServerInfo(server, out siteId);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_194);
            throw;
        }

        return;
    }

    public string[] GetServerListByInterface(string iface)
    {
        string[] serverList = null;
        
        try
        {
            serverList = Config.GetServerListByInterface(iface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_195);
            throw;
        }

        return serverList;
    }

    public IInterfaceInfo GetInterface(string server, string iface)
    {
        IInterfaceInfo interfaceInfo = null;
        
        try
        {
            interfaceInfo = Config.GetInterface(server, iface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_196);
            throw;
        }

        return interfaceInfo;
    }

    public IInterfaceInfo GetInterface(string iface)
    {
        IInterfaceInfo interfaceInfo = null;
        
        try
        {
            interfaceInfo = Config.GetInterface(iface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_196);
            throw;
        }

        return interfaceInfo;
    }

    public IInterfaceInfo GetSingleInterface(string iface)
    {
        IInterfaceInfo interfaceInfo = null;
        
        try
        {
            interfaceInfo = Config.GetSingleInterface(iface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_197);
            throw;
        }

        return interfaceInfo;
    }

    public IBucketServer GetBucketServer(string iface, uint bucket)
    {
        IBucketServer bucketServer = null;

        try
        {
            bucketServer = Config.GetBucketServer(iface, bucket);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_198);
            throw;
        }
        return bucketServer;
    }

    public IBucketServer GetTitleBucketServer(string iface, uint titleId, uint bucket)
    {
        IBucketServer bucketServer = null;

        try
        {
            bucketServer = Config.GetTitleBucketServer(iface, titleId, bucket);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_199);
            throw;
        }
        return bucketServer;
    }

    public uint GetBucketNum(string iface, ulong hashValue)
    {
        uint bucketNum = 0;

        try
        {
            bucketNum = Config.GetBucketNum(iface, hashValue);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_200);
            throw;
        }
        return bucketNum;
    }

    public uint GetBucketCount(string iface)
    {
        uint bucketCount = 0;

        try
        {
            bucketCount = Config.GetBucketCount(iface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_201);
            throw;
        }
        return bucketCount;
    }

    public void CompleteMigration(string iface, uint bucket)
    {
        try
        {
            Config.CompleteMigration(iface, bucket);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_202);
            throw;
        }
        return;
    }

    public void CompleteTitleMigration(string iface, uint titleId, uint bucket)
    {
        try
        {
            Config.CompleteTitleMigration(iface, titleId, bucket);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_203);
            throw;
        }
        return;
    }

    public string[] GetVirtualInterfaceListBySite(Site site)
    {
        string[] virtualInterface = null;
        
        try
        {
            virtualInterface = Config.GetVirtualInterfaceListBySite(site);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_204);
            throw;
        }

        return virtualInterface;
    }

    public string[] GetVirtualInterfaceListBySite(int siteId)
    {
        string[] virtualInterface = null;
        
        try
        {
            virtualInterface = Config.GetVirtualInterfaceListBySite(siteId);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_205);
            throw;
        }

        return virtualInterface;
    }

    public IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(Site site)
    {        
        IVirtualInterfaceInfo[] virtualInterfaceInfo = null;
        
        try
        {
            virtualInterfaceInfo = Config.GetVirtualInterfaceInfoBySite(site);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_206);
            throw;
        }

        return virtualInterfaceInfo;
    }

    public IVirtualInterfaceInfo[] GetVirtualInterfaceInfoBySite(int siteId)
    {
        IVirtualInterfaceInfo[] virtualInterfaceInfo = null;
        
        try
        {
            virtualInterfaceInfo = Config.GetVirtualInterfaceInfoBySite(siteId);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_207);
            throw;
        }

        return virtualInterfaceInfo;
    }

    public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface)
    {
        IVirtualInterfaceInfo virtualInterfaceInfo = null;
        
        try
        {
             virtualInterfaceInfo = Config.GetVirtualInterface(virtualInterface);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_208);
            throw;
        }

        return virtualInterfaceInfo;
    }

    public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, Site site)
    {
        IVirtualInterfaceInfo virtualInterfaceInfo = null;
        
        try
        {
             virtualInterfaceInfo = Config.GetVirtualInterface(virtualInterface, site);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_209);
            throw;
        }

        return virtualInterfaceInfo;
    }

    public IVirtualInterfaceInfo GetVirtualInterface(string virtualInterface, int siteId)
    {
        IVirtualInterfaceInfo virtualInterfaceInfo = null;
        
        try
        {
             virtualInterfaceInfo = Config.GetVirtualInterface(virtualInterface, siteId);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_210);
            throw;
        }

        return virtualInterfaceInfo;
    }

    public bool GetBoolSetting(string setting)
    {
        bool    value;
        
        try
        {
            value = Config.GetBoolSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_211);
            throw;
        }

        return value;
    }

    public int GetIntSetting(string setting)
    {
        int    value;
        
        try
        {
            value = Config.GetIntSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_212);
            throw;
        }

        return value;
    }

    public uint GetUIntSetting(string setting)
    {
        uint    value;
        
        try
        {
            value = Config.GetUIntSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_213);
            throw;
        }

        return value;
    }

    public uint GetUIntIpSetting(string setting)
    {
        uint    value;
        
        try
        {
            value = Config.GetUIntIpSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_214);
            throw;
        }

        return value;
    }

    public long GetLongSetting(string setting)
    {
        long    value;
        
        try
        {
            value = Config.GetLongSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_215);
            throw;
        }

        return value;
    }

    public ulong GetULongSetting(string setting)
    {
        ulong    value;
        
        try
        {
            value = Config.GetULongSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_216);
            throw;
        }

        return value;
    }
   
    public double GetDoubleSetting(string setting)
    {
        double    value;
        
        try
        {
            value = Config.GetDoubleSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_217);
            throw;
        }

        return value;
    }
    
    public string GetSetting(string setting)
    {
        string    value;
        
        try
        {
            value = Config.GetSetting(setting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_218);
            throw;
        }

        return value;
    }

    public void RegisterDynamicSetting(string setting)
    {
        try
        {
            Config.RegisterDynamicSetting(setting);
        }
        catch(Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_REGISTER_DYNAMIC_SETTING_FAILURE);
        }
    }

    public string[] GetMultiSetting(string multiSetting)
    {
        string[] values;
        
        try
        {
            values = Config.GetMultiSetting(multiSetting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_221);
            throw;
        }

        return values;
    }

    public string[] GetMultiSetting(
        string component,
        string multiSetting)
    {
        string[] values;
        
        try
        {
            values = Config.GetMultiSetting(multiSetting, component);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_222);
            throw;
        }

        return values;
    }

    public string[] GetMultiSetting(
        string environment,
        int siteId,
        string server,
        string component,
        string multiSetting)
    {
        string[] values;

        try
        {
            values = Config.GetMultiSetting(
                environment,
                siteId,
                server,
                component,
                multiSetting);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_223);
            throw;
        }

        return values;
    }

    public string[] GetInstallUnitListByServer(
        string server)
    {
        string[] installUnitList = null;
        
        try
        {
            installUnitList = Config.GetInstallUnitListByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_224);
            throw;
        }

        return installUnitList;
    }

    public IInstallUnitInfo[] GetInstallUnitInfoByServer(
        string server)
    {
        IInstallUnitInfo[] installUnitInfo = null;
        
        try
        {
            installUnitInfo = Config.GetInstallUnitInfoByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_225);
            throw;
        }

        return installUnitInfo;
    }

    public string[] GetInstallUnitListByServer(
        string environment,
        string server)
    {
        string[] installUnitList = null;
        
        try
        {
            installUnitList = Config.GetInstallUnitListByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_226);
            throw;
        }

        return installUnitList;
    }

    public IInstallUnitInfo[] GetInstallUnitInfoByServer(
        string environment,
        string server)
    {
        IInstallUnitInfo[] installUnitInfo = null;
        
        try
        {
            installUnitInfo = Config.GetInstallUnitInfoByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_227);
            throw;
        }

        return installUnitInfo;
    }

    public IInstallUnitInfo GetInstallUnit(string installUnit)
    {
        IInstallUnitInfo installUnitInfo = null;
        
        try
        {
            installUnitInfo = Config.GetInstallUnit(installUnit);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_228);
            throw;
        }

        return installUnitInfo;
    }

    public string[] GetComponentListByServer(
        string server)
    {
        string[] componentList = null;
        
        try
        {
            componentList = Config.GetComponentListByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_229);
            throw;
        }

        return componentList;
    }

    public IComponentInfo[] GetComponentInfoByServer(
        string server)
    {
        IComponentInfo[] componentInfo = null;
        
        try
        {
            componentInfo = Config.GetComponentInfoByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_230);
            throw;
        }

        return componentInfo;
    }

    public string[] GetComponentListByServer(
        string environment,
        string server)
    {
        string[] componentList = null;
        
        try
        {
            componentList = Config.GetComponentListByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_231);
            throw;
        }

        return componentList;
    }

    public IComponentInfo[] GetComponentInfoByServer(
        string environment,
        string server)
    {
        IComponentInfo[] componentInfo = null;
        
        try
        {
            componentInfo = Config.GetComponentInfoByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_232);
            throw;
        }

        return componentInfo;
    }

    public IComponentInfo GetComponent(string component)
    {
        IComponentInfo componentInfo = null;
        
        try
        {
            componentInfo = Config.GetComponent(component);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_233);
            throw;
        }

        return componentInfo;
    }

    public string[] GetInterfaceListByServer(
        string server)
    {
        string[] interfaceList = null;
        
        try
        {
            interfaceList = Config.GetInterfaceListByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_234);
            throw;
        }

        return interfaceList;
    }

    public IInterfaceInfo[] GetInterfaceInfoByServer(
        string server)
    {
        IInterfaceInfo[] interfaceInfoList = null;
        
        try
        {
            interfaceInfoList = Config.GetInterfaceInfoByServer(server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_235);
            throw;
        }

        return interfaceInfoList;
    }

    public string[] GetInterfaceListByServer(
        string environment,
        string server)
    {
        string[] iface = null;
        
        try
        {
            iface = Config.GetInterfaceListByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_236);
            throw;
        }

        return iface;
    }

    public IInterfaceInfo[] GetInterfaceInfoByServer(
        string environment,
        string server)
    {
        IInterfaceInfo[] interfaceInfoList = null;
        
        try
        {
            interfaceInfoList = Config.GetInterfaceInfoByServer(environment, server);
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_237);
            throw;
        }

        return interfaceInfoList;
    }

    public void DiscardCachedValues()
    {
        try
        {
            Config.DiscardCachedValues();
        }
        catch (Exception e)
        {
            Config.LogNtEvent(Config.ComponentName, e, e.StackTrace, ConfigEvent.Id.COMMON_CONFIG_238);
            throw;
        }
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Convert.cs ===
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;

namespace STF.common.service
{

[ComVisible(false)]
public class ByteArray
{
    byte[] _bytes;
    int _hashCode;

    public ByteArray(byte[] bytes)
    {
        if (bytes == null || bytes.Length < 1)
        {
            throw new Exception("ByteArray: must have at least 1 byte in array");
        }
        _bytes = bytes;
        UpdateHashCode();
    }

    public void UpdateHashCode()
    {
        _hashCode = _bytes[0];
        for(int i = 1; i < _bytes.Length; i++)
        {
            // 1718205583 is prime
            _hashCode = _hashCode * 1718205583 + _bytes[i];
        }
    }

    override public int GetHashCode()
    {
        return _hashCode;
    }

    override public bool Equals(object o)
    {
        ByteArray ba = (ByteArray)o;

        return Equals( _bytes, ba._bytes );
    }

    public static bool Equals( byte[] ba1, byte[] ba2 )
    {
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    public static bool EqualOrBothNull( byte[] ba1, byte[] ba2 )
    {
        if (ba1 == null && ba2 == null)
        {
            return true;
        }
        if (ba1 == null || ba2 == null)
        {
            return false;
        }
        if (ba1.Length == ba2.Length)
        {
            for(int i = 0; i < ba1.Length; i++)
            {
                if (ba1[i] != ba2[i])
                {
                    return false;
                }
            }
            return true;
        }
        else
        {
            return false;
        }
    }

    override public string ToString()
    {
        return ByteConvert.ToString(_bytes);
    }

    public byte[] Bytes
    {
        get { return _bytes; }
    }
}

[ComVisible(false)]
public class ByteConvert
{
    //
    // turns a byte array into a hex string
    //
    public static string ToString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = 0; i < ba.Length; i++)
        {
            strb.Append(ba[i].ToString("x2"));
        }

        return strb.ToString();
    }


    //
    // turns a byte array into a hex string reversed (for little endian stuff)
    //
    public static string ToReverseString(byte[] ba)
    {
        if (ba == null)
        {
            return "0";
        }

        StringBuilder strb = new StringBuilder(ba.Length * 2);

        for(int i = ba.Length-1; i >= 0; i--)
        {
            strb.Append(ba[i].ToString("X2"));
        }

        return strb.ToString();
    }


    public static string[] ToFormattedStrings(byte[] ba)
    {
        return ToFormattedStrings(ba, UInt32.MaxValue);
    }

    public static string[] ToFormattedStrings(byte[] ba, uint maxLines)
    {
        StringBuilder hexBytes = new StringBuilder(50);
        StringBuilder strBytes = new StringBuilder(16);

        string[] lines = new string[Math.Min(maxLines, ba.Length / 16 + (ba.Length % 16 == 0 ? 0 : 1))];

        for (int i = 0; i < lines.Length; i++)
        {
            for (int j = 0; j < 16; j++)
            {
                int index = (i * 16) + j;
                if (index < ba.Length)
                {
                    byte b = ba[index];
                    hexBytes.Append(b.ToString("x2") + (j == 7 ? "-" : " "));
                    strBytes.Append(b >= 0x20 && b < 0x7f ? (char)b : '.');
                }
            }

            lines[i] = hexBytes.ToString().PadRight(48) + strBytes.ToString().PadRight(17);
            hexBytes.Length = 0;
            strBytes.Length = 0;
        }

        return lines;
    }

    //
    // turns a hex string into a byte array
    //
    public static byte[] FromString(string str)
    {
        byte[] ba = new byte[str.Length / 2];
        for (int i = 0; i < ba.Length; i++)
        {
            ba[i] = Convert.ToByte(str.Substring(i*2, 2), 16);
        }
        return ba;
    }
}

[ComVisible(false)]
public class CharConvert
{
    public static string ToString(char[] ca)
    {
        return CharConvert.ToString(ca, new UTF8Encoding());
    }


    public static string ToString(char[] ca, UTF8Encoding enc)
    {
        int c;

        // find the first null char
        for (c = 0; c < ca.Length && ca[c] != 0; c++)
            ;

        // only use the first first c non-null characters
        // to create the string.
        return enc.GetString(enc.GetBytes(ca, 0, c));
    }

    public static char[] FromString(string str)
    {
        return CharConvert.FromString(str, new UTF8Encoding());
    }

    public static char[] FromString(string str, UTF8Encoding enc)
    {
        return enc.GetChars(enc.GetBytes(str));
    }
}


[ComVisible(false)]
public class Int64Convert
{
    public static long FromIntPair(int highPart, int lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static long FromUintPair(uint highPart, uint lowPart)
    {
        return (long)(((ulong)highPart << 32) | ((ulong)lowPart & 0x00000000FFFFFFFF));
    }

    public static void ToIntPair(long val, out int highPart, out int lowPart)
    {
        highPart = (int)(val >> 32);
        lowPart = (int)(val & 0xffffffff);
    }

    public static void ToUintPair(long val, out uint highPart, out uint lowPart)
    {
        highPart = (uint)(val >> 32);
        lowPart = (uint)(val & 0xffffffff);
    }
}

/// <summary>
/// Provides methods for conversion, with a defualt if the value is null or an empty string
/// </summary>
[ComVisible(false)]
public class XmlSafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt16(str));
    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToInt32(str));
    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        return (str == String.Empty ? nDefault : XmlConvert.ToUInt64(str));
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        return (str == String.Empty ? bDefault : XmlConvert.ToBoolean(str));
    }
}



[ComVisible(false)]
public class SafeConvert
{
    public static int ToInt16(string str)
    {
        return ToInt16(str, 0);
    }
    public static short ToInt16(string str, short nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            return (str == String.Empty ? nDefault : Convert.ToInt16(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static int ToInt32(string str)
    {
        return ToInt32(str, 0);
    }
    public static int ToInt32(string str, int nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }


            return (str == String.Empty ? nDefault : Convert.ToInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static uint ToUInt32(string str)
    {
        return ToUInt32(str, 0);
    }
    public static uint ToUInt32(string str, uint nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((uint)Convert.ToInt32(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt32(str, fromBase));
        }
        catch
        {
            return nDefault;
        }

    }

    public static ulong ToUInt64(string str)
    {
        return ToUInt64(str, 0);
    }
    public static ulong ToUInt64(string str, ulong nDefault)
    {
        try
        {
            int fromBase = 10;

            if (IsHex(str))
            {
                fromBase = 16;
                if (str.StartsWith("0x"))
                    str = str.Substring(2);
            }

            if(str.StartsWith("-") && fromBase == 10)
                return ((ulong)Convert.ToInt64(str, fromBase));
            else
                return (str == String.Empty ? nDefault : Convert.ToUInt64(str, fromBase));
        }
        catch
        {
            return nDefault;
        }
    }

    public static bool ToBoolean(string str)
    {
        return ToBoolean(str, false);
    }
    public static bool ToBoolean(string str, bool bDefault)
    {
        try
        {
            return (str == String.Empty ? bDefault : Convert.ToBoolean(str));
        }
        catch
        {
            return bDefault;
        }
    }

    public static bool IsHex(string str)
    {
        return (str.StartsWith("0x") ||
            str.ToLower().IndexOfAny( new char[] { 'a', 'b', 'c', 'd', 'e', 'f' }) != -1);
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigXmgmtCmd.cs ===
using System;
using System.Runtime.InteropServices;
using STF.common.mgmt;
using STF.common.service;
using STF.common.utilities2;

namespace STF.common.config
{

[ComVisible(false)]
public class ConfigXmgmtCmd
{
    private XomAdminSession _xomAdminSession = null;
    private int _timeout = 0;

    public static void Init()
    {
        XomControl.ControlRequestEvent += ConfigXmgmtCmd.OnControlRequest;
    }

    private static void OnControlRequest(object sender, ControlRequestEventArgs args)
    {
        try
        {
            switch (args.Command)
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "Config help:\r\n" +
                        " configcache -- display the state of the config cache \r\n" +
                        " configcacheflush -- drops all cached configuration from memory\r\n" +
                        " configcacherefresh -- forces the config class to look for\r\n" +
                        "                       config updates in NPDB immediately\r\n" +
                        " ForceGC -- force an immediate garbage collection \r\n" +
                        "\r\n",
                        args.RequestId);
                    args.Handled = true;
                    break;

                case "configcache":
                    {
                        string cacheCommand = (args.CommandArgs.Length != 0) ? args.CommandArgs[0] : string.Empty;
                        XomControlConnection.SendMessage(Config.DefaultInstance.ProcessConfigCache(cacheCommand, args.CommandArgs), args.RequestId);
                        args.Handled = true;
                    }  break;

                case "configcacherefresh":
                    XomControlConnection.SendMessage(Config.DefaultInstance.ProcessConfigCacheRefresh(), args.RequestId);
                    args.Handled = true;
                    break;

                case "configcacheflush":
                    Config.DefaultInstance.DiscardCachedValues();
                    XomControlConnection.SendMessage("Cache flush successful.", args.RequestId);
                    args.Handled = true;
                    break;

                case "forcegc":
                    long bytes = GC.GetTotalMemory(true);
                    XomControlConnection.SendMessage("Collection complete. Bytes currently allocated: " + bytes + "\r\n", args.RequestId);
                    args.Handled = true;
                    break;
            }
        }
        catch (Exception e)
        {
            XomControlConnection.SendMessage("Error: " + e + "\r\n\r\n", args.RequestId);
            Xom.NtEvent(XEvent.Id.COMMON_INFO_8, Config.ComponentName + "\n" + "In Config.OnControlRequest\n" + "args.FullCommand: " + args.FullCommand + "\n" + "args.Command: " + args.Command + "\n" + "args.CommandArgs: " + CollectionUtil.ToString(args.CommandArgs) + "\n" + "args.RequestId: " + args.RequestId + "\n");
        }
    }

    public ConfigXmgmtCmd(XomAdminSession xomAdminSession, int timeout)
    {
        _xomAdminSession = xomAdminSession;
        _timeout = timeout;
    }

    public void Close()
    {
        _xomAdminSession.Close();
        _xomAdminSession = null;
    }

    private void CheckAdminSessionOpen()
    {
        if (_xomAdminSession == null)
        {
            throw new Exception("Xmgmt admin session has been closed");
        }
    }

    private string SimpleCommand(
        string process,
        string component,
        string command)
    {
        CheckAdminSessionOpen();

        string[] responses;
        int resultCode;
        _xomAdminSession.SendCommand(
            process,
            component,
            command,
            _timeout,
            out responses,
            out resultCode);

        if (responses.Length != 1)
        {
            throw new Exception(command+" command had "
                + (responses.Length - 1)
                + " responses; 1 response was expected");
        }

        return responses[0];
    }

    public bool ConfigCacheFlush(
        string process,
        string component)
    {
        string response = SimpleCommand(process, component, "configcacheflush");
        return response.Contains("successful");
    }

    public bool ConfigCacheRefresh(
        string process,
        string component)
    {
        string response = SimpleCommand(process, component, "configcacherefresh");
        if (response.StartsWith("No"))
        {
            return false;
        }
        return true;
    }

    private string ConfigCache(
        string process,
        string component,
        string subcommand)
    {
        return SimpleCommand(process, component, "configcache "+subcommand);
    }

    private string ConfigCache(
        string process,
        string component,
        string subcommand,
        string param1)
    {
        return SimpleCommand(process, component, "configcache "+subcommand+" "+param1);
    }

    private string ConfigCache(
        string process,
        string component,
        string subcommand,
        string param1,
        string param2)
    {
        return SimpleCommand(process, component, "configcache "+subcommand+" "+param1+" "+param2);
    }

    public string AssemblyPath(string process, string component)
    {
        return ConfigCache(process, component, "assemblypath");
    }

    public string CacheRefreshInterval(string process, string component)
    {
        return ConfigCache(process, component, "cacherefreshinterval");
    }

    public string Component(string process, string component)
    {
        return ConfigCache(process, component, "component");
    }

    public string ComponentName(string process, string component)
    {
        return ConfigCache(process, component, "componentname");
    }

    public string Environment(string process, string component)
    {
        return ConfigCache(process, component, "environment");
    }

    public string Interface(string process, string component, string name, string server)
    {
        return ConfigCache(process, component, "interface", name, server);
    }

    public string Interfaces(string process, string component)
    {
        return ConfigCache(process, component, "interfaces");
    }

    public string InterfaceBucket(string process, string component, string name)
    {
        return ConfigCache(process, component, "interfacebucket", name);
    }

    public string InterfaceBuckets(string process, string component)
    {
        return ConfigCache(process, component, "interfacebuckets");
    }

    public string LatestChangeId(string process, string component)
    {
        return ConfigCache(process, component, "latestchangeid");
    }

    public string MainSiteId(string process, string component)
    {
        return ConfigCache(process, component, "mainsiteid");
    }

    public string MinEventInterval(string process, string component)
    {
        return ConfigCache(process, component, "mineventinterval");
    }

    public string MultiSetting(string process, string component, string name)
    {
        return ConfigCache(process, component, "multisetting", name);
    }

    public string MultiSettings(string process, string component)
    {
        return ConfigCache(process, component, "multisettings");
    }

    public string NpdbConnectionString(string process, string component)
    {
        return ConfigCache(process, component, "npdbconnectionstring");
    }

    public string NpdbDatabase(string process, string component)
    {
        return ConfigCache(process, component, "npdbdatabase");
    }

    public string NpdbServer(string process, string component)
    {
        return ConfigCache(process, component, "npdbserver");
    }

    public string Server(string process, string component)
    {
        return ConfigCache(process, component, "server");
    }

    public string ServerList(string process, string component, string name)
    {
        return ConfigCache(process, component, "serverlist", name);
    }

    public string ServerLists(string process, string component)
    {
        return ConfigCache(process, component, "serverlists");
    }

    public string Setting(string process, string component, string name)
    {
        return ConfigCache(process, component, "setting", name);
    }

    public string Settings(string process, string component)
    {
        return ConfigCache(process, component, "settings");
    }

    public string SiteId(string process, string component)
    {
        return ConfigCache(process, component, "siteid");
    }

    public string VirtualInterface(string process, string component, string name, int siteId)
    {
        return ConfigCache(process, component, "virtualinterface", name, siteId.ToString());
    }

    public string VirtualInterfaces(string process, string component)
    {
        return ConfigCache(process, component, "virtualinterfaces");
    }

    public string VirtualInterfaceList(string process, string component, int siteId)
    {
        return ConfigCache(process, component, "virtualinterfacelist", siteId.ToString());
    }

    public string VirtualInterfaceLists(string process, string component)
    {
        return ConfigCache(process, component, "virtualinterfacelists");
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CountryConfig.cs ===
/*
 * CountryConfig.cs
 *
 */

namespace STF.common.utilities
{
    //
    // For the Spring 2006 release, this is just a placeholder class.
    //
    // For the Fall 2006 release, this class should be extended to incorporate
    // the range of config information that is currently represented in the
    // country info XML files (*.cixml) that are compiled and kept on the
    // content download servers for the clients to consume.
    //
    public class CountryConfig
    {
        public static CountryConfig GetCountryConfig(byte countryId)
        {
            CountryConfig cc = new CountryConfig();

            cc.CountryId = countryId;
            cc.RegionName = CountryDictionary.CountryCode(countryId);
            cc.PhoneRequired = true;

            if ( cc.RegionName == "DE" )
            {
                cc.PhoneRequired = false;
            }

            return cc;
        }

        public string RegionName;
        public bool PhoneRequired;
        public byte CountryId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigUtil.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Xml;

namespace STF.common.config
{
    [ComVisible(false)]
    public static class ConfigUtil
    {
        public static uint IpAddressToDword( IPAddress ip )
        {
            byte[] addr = ip.GetAddressBytes();
            return ((uint)addr[3]) + ((uint)addr[2] << 8) + ((uint)addr[1] << 16) + ((uint)addr[0] << 24);
        }

        public static string UodbWebstoreApp
        {
            get
            {
                IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Config.SiteId);

                return vInterfaceInfo.WebstoreApp;
            }
        }

        public static string SecpDbWebstoreApp
        {
           get
           {
               IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.secpdb, Config.SiteId);
               return vInterfaceInfo.WebstoreApp;
           }
        }

        public static string SecDbWebstoreApp
        {
           get
           {
               IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.secdb, Config.SiteId);
               return vInterfaceInfo.WebstoreApp;
           }
        }

        public static string TokendbWebstoreApp
        {
            get
            {
                IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.tokendb, Config.SiteId);

                return vInterfaceInfo.WebstoreApp;
            }
        }

        public static string UserCommercedbWebstoreApp
        {
            get
            {
                IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.usercommercedb, Config.SiteId);

                return vInterfaceInfo.WebstoreApp;
            }
        }

        public static string EventSysDbWebstoreApp
        {
            get
            {
                IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.eventsysdb, Config.SiteId);

                return vInterfaceInfo.WebstoreApp;
            }
        }

        public static string NpdbWebstoreApp
        {
            get
            {
                IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(VirtualInterface.npdb, Config.SiteId);

                return vInterfaceInfo.WebstoreApp;
            }
        }

        public static string GetWebstoreApp(string viface)
        {
            IVirtualInterfaceInfo vInterfaceInfo = Config.GetVirtualInterface(viface, Config.SiteId);
            return vInterfaceInfo.WebstoreApp;
        }


        public static string FECatalogDBXboxConnectionString
        {
            get
            {
                IVirtualInterfaceInfo fexbox = Config.GetVirtualInterface(VirtualInterface.fecatalogdbxbox);
                return fexbox.SqlConnectionString;
            }
        }

        public static IVirtualInterfaceInfo FECatalogDBZuneVirtualInterfaceInfo
        {
            get
            {
                string virtualInterfaceName = Config.GetSetting(Setting.catalog_activeFECatalogDBZuneVirtualInterface);

                try
                {
                    IVirtualInterfaceInfo fezune = Config.GetVirtualInterface(virtualInterfaceName);
                    return fezune;
                }
                catch (ApplicationException e)
                {
                    throw new ApplicationException(string.Format(
                        "There was a problem loading the FECatalogDBZune virtual interface '{0}' from the " +
                        "catalog_activeFECatalogDBZuneVirtualInterface setting.  Have the Zune NPDB-upgrade scripts " +
                        "been run in this environment?\n", virtualInterfaceName), e);
                }
            }
        }

        public static string FECatalogDBZuneConnectionString
        {
            get
            {
                IVirtualInterfaceInfo fezune = FECatalogDBZuneVirtualInterfaceInfo;
                return fezune.SqlConnectionString;
            }
        }

        public static IVirtualInterfaceInfo FECatalogDBSearchVirtualInterfaceInfo
        {
            get
            {
                string virtualInterfaceName = Config.GetSetting(Setting.catalog_activeFECatalogDBSearchVirtualInterface);
                try
                {
                    IVirtualInterfaceInfo feSearch = Config.GetVirtualInterface(virtualInterfaceName);
                    return feSearch;
                }
                catch (ApplicationException e)
                {
                    throw new ApplicationException(string.Format(
                        "There was a problem loading the FECatalogDBSearch virtual interface '{0}' from the " +
                        "catalog_activeFECatalogDBSearchVirtualInterface setting.  Have the Zune NPDB-upgrade scripts " +
                        "been run in this environment?\n", virtualInterfaceName), e);
                }
            }
        }

        public static string FECatalogDBSearchConnectionString
        {
            get
            {
                IVirtualInterfaceInfo feSearch = FECatalogDBSearchVirtualInterfaceInfo;
                return feSearch.SqlConnectionString;
            }
        }

        public static string NpdbConnectionString
        {
            get
            {
                return Config.NpdbConnectionString;
            }
        }

        public static string WebdbConnectionString
        {
            get
            {
                IInterfaceInfo webdb = Config.GetSingleInterface(Interface.webdb);
                return webdb.SqlConnectionString;
            }
        }

        public static string ToolsdbConnectionString
        {
            get
            {
                IInterfaceInfo toolsdb = Config.GetSingleInterface(Interface.toolsdb);
                return toolsdb.SqlConnectionString;
            }
        }

        //
        // Web services
        //
        public static string AlertsWebServiceURL
        {
            get
            {
                IVirtualInterfaceInfo wcalerts = Config.GetVirtualInterface(VirtualInterface.wcalerts, 1);
                return string.Format("http://{0}:{1}/alerts/alerts.asmx", wcalerts.IPAddressString, wcalerts.Port);
            }
        }

        public static string QueryWebServiceURL
        {
            get
            {
                IVirtualInterfaceInfo wcquery = Config.GetVirtualInterface(VirtualInterface.wcquery, 1);
                return string.Format("http://{0}:{1}/query/query.asmx", wcquery.IPAddressString, wcquery.Port);
            }
        }

        public static string PresenceWebServiceURL
        {
            get
            {
                IVirtualInterfaceInfo wcpresence = Config.GetVirtualInterface(VirtualInterface.wcpresence, 1);
                return string.Format("http://{0}:{1}/presence/presence.asmx", wcpresence.IPAddressString, wcpresence.Port);
            }
        }

        public static string GetUserCommerceWebstoreApp()
        {
            return ConfigUtil.UserCommercedbWebstoreApp;
        }

        public static string GetParams(string[,] parameters)
        {
            string str = "";

            for (int n = 0; n < parameters.GetLength(0); n++)
            {
                if (String.IsNullOrEmpty(parameters[n,0]))
                {
                    continue;
                }
                str = String.Concat(
                    str,
                    parameters[n,0],
                    "=",
                    parameters[n,1],
                    ";"
                    );
            }
            return str;
        }

        public static string[,] GetParams(string str)
        {
            if ( str == null )
            {
                return null;
            }

            string[] pairs = str.Split( new char[] { ';' } );
            pairs = Array.FindAll<string>(pairs, delegate(string s) {
                 return !String.IsNullOrEmpty(s);
            });
            string[] param;
            string[,] paramList = new string[pairs.Length, 2];
            char[] pairDelim = new char[] { '=' };

            for (int n = 0; n < pairs.Length; n++)
            {
                param = pairs[n].Split( pairDelim );

                if (param.Length != 2)
                {
// TODO: to call Xom.NtEvent now would require bringing a dependency on
// STF.server.mgmt.mc into components that don't have that now.
// Instead of logging and continuing, this should really throw an exception
// with an event id of XEvent.Id.COMMON_CONFIG_239.  I don't want to change the
// behavior of this now with all of the config churn but once everything has
// stabilized and there is a 1-box environment, I will change this.
                    return null;
                }

                paramList[n,0] = param[0].ToLower();
                paramList[n,1] = param[1];
            }

            return paramList;
        }

        public static string[,] GetParams(string str, string defaults)
        {
            bool found;
            int  index;
            int  m;
            int  n;
            int  total;

            if ( defaults == null )
            {
                return GetParams(str);
            }
            if ( str == null)
            {
                return GetParams(defaults);
            }

            string[,] pairs = GetParams(str);
            string[,] defaultPairs = GetParams(defaults);

            //
            // We have to store at least the original number of entries
            //
            total = pairs.GetLength(0);

            //
            // Count the number of pairs we will need for the final result
            //
            for (n = 0; n < defaultPairs.GetLength(0); n++)
            {
                found = false;

                for (m = 0; m < pairs.GetLength(0); m++)
                {
                    if (pairs[m,0] == defaultPairs[n,0])
                    {
                        found = true;
                        break;
                    }
                }

                if (found == false)
                {
                    total++;
                }
            }

            //
            // Build a final pairs that can hold the merged set
            //
            string[,] final = new string[total, 2];

            //
            // Copy in the original values
            //
            for (n = 0; n < pairs.GetLength(0); n++)
            {
                final[n,0] = pairs[n,0];
                final[n,1] = pairs[n,1];
            }

            //
            // Copy in the missing entries
            //
            for (index = pairs.GetLength(0), n = 0; n < defaultPairs.GetLength(0); n++)
            {
                found = false;

                for (m = 0; m < pairs.GetLength(0); m++)
                {
                    if (pairs[m,0] == defaultPairs[n,0])
                    {
                        found = true;
                        break;
                    }
                }

                if (found == false)
                {
                    final[index,0] = defaultPairs[n,0];
                    final[index,1] = defaultPairs[n,1];
                    index++;
                }
            }

            return final;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CountryList.cs ===
/*
 * CountryList.cs
 *
 * Class CountryDictionary represents a mapping from country code (byte) to
 * two-letter ISO country code.
 *
 * Copyright (c) Micrsoft Corporation. All Rights Reserved.
 *
 * Author: Steve Lamb (SLamb)
 */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;

using STF.common.config;
using STF.common.service;

namespace STF.common.utilities
{
    public class MinAge
    {
        public byte User;
        public byte Billing;
    }

    public class CountryInfo
    {
        public byte CountryId;
        public string CountryCode;
        public byte User;
        public byte Billing;
        public bool AllowDirectDebit;
        public bool AllowPayPal;
        public bool RequireCCAgeVerification;
    }

    public class CountryDictionary
    {

        private static Hashtable _countryInfo = null;
        private static Hashtable _countryInfoByCode = null;


        public static string CountryCode(byte countryId)
        {
            if (_countryInfo == null) Init();

            CountryInfo ci = CountryInfo(countryId);

            return (ci == null) ? null : ci.CountryCode;
        }

        public static byte CountryId(string countryCode)
        {
            if (_countryInfoByCode == null) Init();

            CountryInfo ci = CountryInfo(countryCode);

            return (ci == null) ? (byte)0 : ci.CountryId;

        }

        public static MinAge MinAge(byte countryId)
        {
            if (_countryInfo == null) Init();

            CountryInfo info = (CountryInfo) _countryInfo[countryId];

            MinAge age = new MinAge();
            age.User = info.User;
            age.Billing = info.Billing;
            return age;
        }

        public static CountryInfo CountryInfo(byte countryId)
        {
            if (_countryInfo == null) Init();

            return (CountryInfo) _countryInfo[countryId];

        }

        public static CountryInfo CountryInfo(string countryCode)
        {
            if (_countryInfoByCode == null) Init();

            if (String.IsNullOrEmpty(countryCode))
                return null;

            return (CountryInfo) _countryInfoByCode[countryCode.ToUpper()];
        }

        static void Init()
        {
            try
            {
                using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
                {
                    conn.Open();

                    // Execute stored procedure
                    using (SqlCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandText = "dbo.p_xuacs_get_countries";
                        cmd.CommandType = CommandType.StoredProcedure;

                        using (SqlDataReader rdr = cmd.ExecuteReader())
                        {
                            _countryInfo = new Hashtable();
                            _countryInfoByCode = new Hashtable();

                            while (rdr.Read())
                            {
                                byte countryId = rdr.GetByte(0);
                                string countryCode = rdr.GetString(1).ToUpper();

                                CountryInfo info = new CountryInfo();

                                info.CountryId = countryId;
                                info.CountryCode = countryCode;
                                info.User = rdr.GetByte(2);
                                info.Billing = rdr.GetByte(3);
                                info.AllowDirectDebit = ( rdr.GetByte(4) != 0 );
                                info.RequireCCAgeVerification = ( rdr.GetByte(5) != 0 );
                                info.AllowPayPal = ( rdr.GetByte(6) != 0 );
                                
                                _countryInfo[countryId] = info;
                                _countryInfoByCode[countryCode] = info;
                            }


                            if (_countryInfo.Count == 0)
                            {
                                throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR,
                                                       XEvent.Id.COUNTRY_LIST_MISSING,
                                                       "Calling 'p_xuacs_get_countries' returned 0 results!   (is the table populated?)");
                            }
                        }
                    }
                }
            }
            catch (Exception)
            {
                _countryInfo = null;
                _countryInfoByCode = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Crypto.cs ===
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace STF.common.service 
{
[ComVisible(false)]
public class Crypto
{
    private static RNGCryptoServiceProvider _rng = new RNGCryptoServiceProvider();    
    private static ASCIIEncoding _enc = new ASCIIEncoding();
    
    public static byte[] GetRandomBytes(uint len)
    {
        byte[] ret = new byte[len];

        _rng.GetBytes(ret);

        return ret;
    }

    public static uint GetRandomUInt32()
    {
        byte[] bytes = GetRandomBytes(4);
        return BitConverter.ToUInt32(bytes, 0);
    }

    public static ulong GetRandomUInt64()
    {
        byte[] bytes = GetRandomBytes(8);
        return BitConverter.ToUInt64(bytes, 0);
    }
    
    public static string GetRandomString(uint len)
    {
        uint n = 0;
        uint nFound = 0;
        byte[] charBytes = new byte[len];
        byte[] rndBytes = GetRandomBytes(len * 3);
        
        while (nFound < len)
        {
            if (n >= rndBytes.Length-1)
            {
                rndBytes = GetRandomBytes((len-nFound) * 3);
                n = 0;
            }

            if ((rndBytes[n] >= 48 && rndBytes[n] <= 57)     // '0'-'9'
                ||(rndBytes[n] >= 65 && rndBytes[n] <= 90)   // 'A'-'Z'
                || (rndBytes[n] >= 97 && rndBytes[n] <= 122) ) // 'a'-'z'
            {
                // in the acceptable character range, keep it
                charBytes[nFound++] = rndBytes[n];
            }

            n++;
        }

        return _enc.GetString(charBytes);
    }
    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\Domain.cs ===
/*
 * Copyright (c) 2003 Microsoft Corporation
 *
 * Storage Front-Door (stfd)
 *
 * StorageDomain.cs
 *
 * Domain policy and properties
 *
 * */

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

using STF.common.config;
using STF.common.service;
using STF.common.mgmt;

// trace area for StorageDomain code
[assembly: XomAreaDefinition(XomAreaName.domTrace)]

namespace STF.common.protocol
{
    public class StorageDomainConstants
    {
        // domain id constants for the current storage domains
        public const uint _MIN = 0;
        public const uint STATS = 0;
        public const uint TITLE = 1;
        public const uint TUSER = 2;
        public const uint TTEAM = 3;
        public const uint MSG   = 4;
        public const uint XESTATS = 5;
        public const uint GLOBAL = 6;
        public const uint PICS  = 7;
        public const uint VID   = 8;
        public const uint ZPIC  = 9;
        public const uint AVATAR  = 10;
        public const uint _MAX = 10;
    }
    

    public class StorageDomain
    {

        public uint _id;
        public string _name;
        public string _description;
        public string _webstoreApp;

        public StorageDomainPolicy _policy = new StorageDomainPolicy();

        public StorageDomainPolicy Policy
        {
            get { return _policy; }
        }

        public string Name
        {
            get { return _name; }
        }
        public uint Id
        {
            get { return _id; }
        }
        public string WebstoreApp
        {
            get { return _webstoreApp; }
        }

    }

    
    public class StorageDomainList
    {
        private static Hashtable _domainHash = null;                
        public static Hashtable DomainHash
        {
          get 
          { 
                if ( _domainHash == null )
                {
                    LoadFromDb();
                }
              return StorageDomainList._domainHash; 
          }
        }

        private static StorageDomain[] _domainList = null;

        public static StorageDomain GetDomain(string name)
        {
            return (StorageDomain) DomainHash[name];
        }

        public static StorageDomain GetDomain(uint domainId)
        {
            if ( _domainList == null )
            {
                LoadFromDb();
            }

            return (StorageDomain) _domainList[(int)domainId];
        }

       

        protected static void LoadFromDb()
        {
            SqlConnection conn = null;
            SqlCommand cmd = null;
            SqlDataReader rdr = null;

            Hashtable h = new Hashtable();
            string connString = null;

            try
            {
                connString = ConfigUtil.NpdbConnectionString;
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: NPDB connection string='" + connString + "'");
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(
                    XEvent.Id.COMMON_CONFIG_270,
                    "Domain.LoadFromDb: Failed to retrieve NPDB config data.",
                    e);
            }

            try
            {
                conn = new SqlConnection(connString);
                conn.Open();
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: opened connection.");
            }
            catch (Exception e)
            {
                throw new XRLException(
                    HResult.XONLINE_E_DATABASE_ERROR,
                    XEvent.Id.COMMON_CODE_41,
                    "Domain.LoadFromDb: failed to connect to NPDB SQL server: " + ConfigUtil.NpdbConnectionString,
                    e);
            }

            try
            {
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: calling CreateCommand");
                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_storage_get_domains";

                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: executing dbo.p_storage_get_domains");
                rdr = cmd.ExecuteReader();
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "Domain.LoadFromDb: executed dbo.p_storage_get_domains");

                while ( rdr.Read() )
                {
                    StorageDomain d = new StorageDomain();
                    d._id = (uint) rdr.GetInt32(0);
                    d._name = rdr.GetString(1);
                    d._description = rdr.GetString(2);
                    d._webstoreApp = rdr.GetString(3);
                    d._policy._maxFileSize = (ulong) rdr.GetInt64(4);
                    d._policy._cacheReadFiles = (rdr.GetByte(5) != 0);
                    d._policy._readFileCacheTimeSeconds = rdr.GetInt32(6);
                    d._policy._cacheEnumFiles = (rdr.GetByte(7) != 0);
                    d._policy._enumFileCacheTimeSeconds = rdr.GetInt32(8);
                    d._policy._quotaEnabled = (rdr.GetByte(9) != 0);
                    d._policy._allowOverwrites = (rdr.GetByte(10) != 0);
                    d._policy._allowCrossTitle = (rdr.GetByte(11) != 0);
                    d._policy._allowPreviewVersioning = (rdr.GetByte(12) != 0);
                    d._policy._pathValidationString = rdr.GetString(13);
                    //d._policy._defaultExpiryInDays = rdr.GetInt32(14);
                    if (!rdr.GetSqlInt32(14).IsNull )
                    {
                        d._policy._defaultExpiryInDays = rdr.GetInt32(14);
                    } else 
                    {
                         d._policy._defaultExpiryInDays = Int32.MaxValue;
                    }

                    if ( d._policy._pathValidationString != null && d._policy._pathValidationString.Length > 0 )
                    {
                        d._policy._pathValidationRegex = new Regex(d._policy._pathValidationString, RegexOptions.IgnoreCase|RegexOptions.Compiled);
                    }

                    h.Add(d._name, d);

                    Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL,
                        "StorageDomainList: loaded domain id=" + d._id +
                             ", name=" + d._name +
                             ", webstore app=" + d._webstoreApp +
                             ", description=" + d._description + "\r\n" +
                         "StorageDomainList: Policy for domain " + d._name + "\r\n" +
                             d._policy.ToString());
                }

                rdr.Close();
                rdr = null;

                if ( h.Count == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.STFD_MISSING_OR_BAD_CONFIG,
                        "Calling 'p_storage_get_domains' in NPDB returned 0 rows.  Check to ensure the t_storage_domains table is populated correctly." );
                }

                uint maxDomainId = 0;
                foreach (string name in h.Keys)
                {
                    StorageDomain d = (StorageDomain) h[name];
                    if ( d._id > maxDomainId )
                    {
                        maxDomainId = d._id;
                    }
                }

                StorageDomain[] domainList = new StorageDomain[maxDomainId+1];

                foreach (string name in h.Keys)
                {
                    StorageDomain d = (StorageDomain) h[name];
                    domainList[d._id] = d;
                }

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_storage_get_domain_permissions";

                rdr = cmd.ExecuteReader();

                while ( rdr.Read() )
                {
                    uint domainId = (uint) rdr.GetInt32(0);
                    uint operation = (uint) rdr.GetInt32(1);
                    uint allowed = (uint) rdr.GetInt32(2);


                    StorageDomain d = domainList[domainId];
                    if ( d == null )
                    {
                        throw new ExceptionWithEventId(
                            XEvent.Id.COMMON_CONFIG_272,
                            "Calling 'p_storage_get_domain_permissions' in NPDB returned domain id=" + domainId + " which was not found in domain list.  Check to ensure the t_storage_domains and t_storage_domain_permissions tables are populated correctly." );
                    }

                    d._policy._permissions[operation] = allowed;

                    Xom.Trace(XomAreaName.domTrace, LogLevel.L_NORMAL, "StorageDomainList: loaded domain id=" + domainId + ", operation=" + operation + ", allowed=" + allowed);
                }

                rdr.Close();
                rdr = null;

                if ( h.Count == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.STFD_MISSING_OR_BAD_CONFIG_1,
                        "Calling 'p_storage_get_domains' in NPDB returned 0 rows.  Check to ensure the t_storage_domains table is populated correctly." );
                }

                _domainHash = h;
                _domainList = domainList;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.domTrace, LogLevel.L_ERROR, "Domain.LoadFromDb: caught exception: " + e);
                throw;
            }
            finally
            {
                if ( rdr != null )
                {
                    rdr.Close();
                    rdr = null;
                }

                if ( conn != null )
                {
                    conn.Close();
                    conn = null;
                }
            }
        }

        public static void ReloadFromDb()
        {
            _domainHash = null;
            _domainList = null;
        }

        
 
    }


    public class StorageDomainPolicy
    {
        public StorageDomainPolicy()
        {
            _permissions = new uint[ProtocolConstants.maxStorageOperations];
        }

        public ulong  _maxFileSize;
        public bool   _cacheReadFiles;
        public int    _readFileCacheTimeSeconds;
        public bool   _cacheEnumFiles;
        public int    _enumFileCacheTimeSeconds;
        public bool   _quotaEnabled;
        public bool   _allowOverwrites;
        public bool   _allowCrossTitle;
        public bool   _allowPreviewVersioning;
        public string _pathValidationString;
        public Regex  _pathValidationRegex;
        public int    _defaultExpiryInDays;


        [XmlIgnore]
        public uint[] _permissions;

        public ulong MaxFileSize
        {
            get { return _maxFileSize; }
        }
        public bool CacheReadFiles
        {
            get { return _cacheReadFiles; }
        }
        public int ReadFileCacheTimeSeconds
        {
            get { return _readFileCacheTimeSeconds; }
        }
        public bool CacheEnumFiles
        {
            get { return _cacheEnumFiles; }
        }
        public int EnumFileCacheTimeSeconds
        {
            get { return _enumFileCacheTimeSeconds; }
        }
        public bool QuotaEnabled
        {
            get { return _quotaEnabled; }
        }
        public bool AllowOverwrites
        {
            get { return _allowOverwrites; }
        }
        public bool AllowCrossTitle
        {
            get { return _allowCrossTitle; }
        }
        public bool AllowPreviewVersioning
        {
            get { return _allowPreviewVersioning; }
        }
        public string PathValidationString
        {
            get { return _pathValidationString; }
        }
        public Regex PathValidationRegex
        {
            get { return _pathValidationRegex; }
        }
        public int DefaultExpiryInDays
        {
          get { return _defaultExpiryInDays; }
        }

        [XmlIgnore]
        public uint[] Permissions {
            get { return _permissions; }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();

            sb.Append("_maxFileSize: " + _maxFileSize + "\n");
            sb.Append("_cacheReadFiles: " + _cacheReadFiles + "\n");
            sb.Append("_readFileCacheTimeSeconds: " + _readFileCacheTimeSeconds + "\n");
            sb.Append("_cacheEnumFiles: " + _cacheEnumFiles + "\n");
            sb.Append("_enumFileCacheTimeSeconds: " + _enumFileCacheTimeSeconds + "\n");
            sb.Append("_quotaEnabled: " + _quotaEnabled + "\n");
            sb.Append("_allowOverwrites: " + _allowOverwrites + "\n");
            sb.Append("_allowCrossTitle: " + _allowCrossTitle + "\n");
            sb.Append("_allowPreviewVersioning: " + _allowPreviewVersioning + "\n");
            sb.Append("_pathValidationString: " + _pathValidationString + "\n");
            sb.Append("_defaultExpiryInDays: " + _defaultExpiryInDays.ToString() + "\n");

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\cronprot.cs ===
/*==========================================================================
 *
 *  cronwire.cs -- This module defines the wire protocol for cron service apis
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

using System;
using STF.common.service;

namespace STF.common.protocol 
{
    public class AddJobRequest : XRLObject2
    {
        public uint nameLen;             
        [WireInfo(SizeParam="nameLen")]        
        public string name;
        
        public uint titleId;
        
        public uint assemblyLen;
        [WireInfo(SizeParam="assemblyLen")]        
        public string assembly;
        
        public uint classLen;    
        [WireInfo(SizeParam="classLen")]        
        public string className;
    
        public uint argsLen;
        [WireInfo(SizeParam="argsLen")]        
        public string argsXml;
    
        public DateTime nextExec;
        public uint intervalSecs;
        public uint execCount;
        public uint timeoutSecs;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/addjob.ashx";
            }
        }
    }

    public class AddJobResponse : XRLObject2
    {
        public int jobId;
    }

    
    public class RemoveJobRequest : XRLObject2
    {
        public int jobId;
        public uint titleId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/removejob.ashx";
            }
        }
    }

    public class CronJobWire : XRLObject2
    {
        public int jobId;
        
        public uint nameLen;        
        [WireInfo(SizeParam="nameLen")]        
        public string name;
        
        public uint titleId;
        
        public uint assemblyLen;        
        [WireInfo(SizeParam="assemblyLen")]        
        public string assembly;
        
        public uint classLen;
        [WireInfo(SizeParam="classLen")]        
        public string className;
    
        public uint argsLen;        
        [WireInfo(SizeParam="argsLen")]        
        public string argsXml;
    
        public DateTime nextExec;
        public uint intervalSecs;
        public uint execCount;
        public uint timeoutSecs;
    
        public uint frontDoorLen;        
        [WireInfo(SizeParam="frontDoorLen")]        
        public string frontDoor;
    
    }

    public class GetJobRequest : XRLObject2
    {
        public int jobId;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/getjob.ashx";
            }
        }
    }
    
    
    public class GetJobResponse : CronJobWire
    {
    }

    public class FindJobsRequest : XRLObject2
    {
        public uint searchLen;
        
        [WireInfo(SizeParam="searchLen")]        
        public string search;
        

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/findjobs.ashx";
            }
        }
    }
    
    
    public class FindJobsResponse : XRLObject2
    {
        public int jobCount;
                
        [WireInfo(SizeParam="jobCount")]        
        public CronJobWire[] jobs;
    }
    
    
    public class CronTimeWarpRequest : XRLObject2
    {
        public long offsetSeconds;

        //
        // Helpers for client & widget code
        //
        public override string Xrl
        {
            get
            {
                return "/cron/timewarp.ashx";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CryptoMgr.cs ===
///
///  CryptoMgr.cs :  Declaration and implementation of the PUID manager class.
///
///  Date:  May 01/2002
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using STF.common.config;
using STF.common.service;
using STF.common.sql.webstore;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.cryptomgr)]

namespace STF.common.crypto
{
    /// <summary>
    /// The crypto manager is responsible for attain and maintaining key encryption keys from the UODB.
    /// </summary>
    public class CryptoReader
    {
        public static byte[] GetKey(int keyType, int keyVersion)
        {
            LoadKeysFromDatabase( keyType );

            string hashKey = GetHashKey(keyType, keyVersion);

            byte[] rawKey = (byte[]) m_keyTable[hashKey];

            // The old GetKeyWrp method threw an IndexOutOfRangeException if an unknown
            // key version was specified.  Since xsig depends on those semantics, preserve
            // them here.
            if ( rawKey == null )
            {
                throw new IndexOutOfRangeException("unknown keyVersion:" + keyVersion + " (keyType: " + keyType + ")");
            }

            return rawKey;
        }

        public static byte[] GetLatestKey(int keyType)
        {
            LoadKeysFromDatabase( keyType );
            // Since this is a brand-spankin'-new function, I don't have to go forward with the IndexOutOfRangeException like above.
            return GetKey(keyType, (int) m_keyTable[GetKeyTypeKey(keyType)]);
        }

        protected static string GetHashKey(int keyType, int keyVersion)
        {
            string hashKey = keyType.ToString("d") + ":" + keyVersion.ToString("d");
            return hashKey;
        }

        protected static string GetKeyTypeKey(int keyType)
        {
            return "keyType:" + keyType;
        }

        public static void ReloadKeys()
        {
            // force keyTable to be reloaded
            m_keyTable = new Hashtable();
        }

        //
        // Protected

        // methods
        protected static void LoadKeysFromDatabase(int keyType)
        {
            string keyTypeKey = GetKeyTypeKey(keyType);

            if ( m_keyTable[keyTypeKey] == null )
            {
                lock(syncObject)
                {
                    if ( m_keyTable[keyTypeKey] == null )
                    {
                        // create the instance of the main crypto wrapper class.
                        if ( m_cryptoWrp != null )
                        {
                            Marshal.ReleaseComObject( m_cryptoWrp );
                            m_cryptoWrp = null;
                        }
                        m_cryptoWrp = new XoCryptoWrapperClass();

                        int keyVersionsFound = 0;
                        
                        // Making SQL call to retrieve service key
                        using ( SqlConnection conn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
                        {
                            conn.Open();

                            using ( SqlCommand cmd = conn.CreateCommand() )
                            {
                                cmd.CommandText = "dbo.p_xuacs_get_servicekey_values";
                                cmd.CommandType = CommandType.StoredProcedure;

                                cmd.Parameters.Add( "@i_keyType", SqlDbType.Int ).Value = keyType;

                                Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "CryptoReader.GetKeyFromDatabase: executing stored procedure:" + cmd.CommandText + " with keyType = " + keyType );

                                // execute the stored proc.
                                using ( SqlDataReader reader = cmd.ExecuteReader() )
                                {
                                    // the results are expected in the following format.
                                    // scan the list for all entires...
                                    while ( reader.Read() )
                                    {
                                        int keyVersion;
                                        uint keySize = 0;
                                        uint masterKeyVersion;

                                        // retrieve the key version
                                        keyVersion = reader.GetInt32( 0 );

                                        // put the entry in the list.
                                        keySize = (uint) reader.GetBytes(1, 0, null, 0, 0);

                                        byte[] encryptedKey = new byte[keySize];
                                        reader.GetBytes(1, 0, encryptedKey, 0, encryptedKey.Length);

                                        // retrieve the master key version
                                        masterKeyVersion = (uint) reader.GetInt32( 2 );

                                        // decrypt the key and store the result.
                                        byte[] rawKey = m_cryptoWrp.DecryptWithMasterKeyWrp( masterKeyVersion, keySize, encryptedKey);
#if DEBUG
                                        Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_HIGH, "LoadKeysFromDatabase: loaded keyType: " + keyType + ", keyVersion: " + keyVersion + ", rawKey: 0x" + ByteConvert.ToString(rawKey) );
#endif
                                        string hashKey = GetHashKey(keyType, keyVersion);
                                        m_keyTable[hashKey] = rawKey;

                                        // increment number of key versions loaded
                                        keyVersionsFound++;
                                    }
                                }
                            }
                        }

                        // indicate all versions of the given keyType have been loaded
                        if ( keyVersionsFound > 0 )
                        {
                            m_keyTable[keyTypeKey] = keyVersionsFound;
                        }
                    }
                }
            }
        }

        static protected internal XoCryptoWrapperClass m_cryptoWrp = null;
        static protected Hashtable m_keyTable = new Hashtable();
        static object syncObject = new object();
    }

    public class KEKCryptoMgr: CryptoReader
    {
        const int c_IVSize = 16;                // should match AES_KEYSIZE in crytohelper.h
        const int c_OnlineKeySize = 16;         // should match ONLINE_KEY_LEN in crytohelper.h

        public static void GenerateNewKey( out byte[] iv, out byte[] encKey, out byte[] rawKey )
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            int keyVersion = Config.GetIntSetting(Setting.crypto_serviceKeyVersion);

            byte[] keKey = GetKey(keyType, keyVersion);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;

            // allocate memory for values.
            rawKey = new byte[c_OnlineKeySize];

            // create a random number generator
            RNGCryptoServiceProvider randGen = new RNGCryptoServiceProvider();

            // get random bytes for information.
            randGen.GetBytes( rawKey );

            encKey = new byte[c_OnlineKeySize];
            MemoryStream ms = new MemoryStream(encKey);
            ICryptoTransform cryptTrans = aes.CreateEncryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write(rawKey, 0, c_OnlineKeySize);
            cs.Close();
        }

        public static void EncryptWithKEK( int kekversion, byte[] rawDataArr, out byte[] iv, out byte[] encData)
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            byte[] keKey = GetKey(keyType, kekversion);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;


            encData = new byte[rawDataArr.Length];
            MemoryStream ms = new MemoryStream(encData);

            ICryptoTransform cryptTrans = aes.CreateEncryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write( rawDataArr, 0 , rawDataArr.Length );
            cs.Close();

            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::EncryptWithKEK):  Encrypted Data Length = " + encData.Length + ", IV data Length = " + iv.Length + ", KEKVersion = " + kekversion );
        }

        public static void DecryptWithKEK( int kekversion, byte[] iv, byte[] encData, out byte[] rawDataArr )
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            byte[] keKey = GetKey(keyType, kekversion);

            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::DecryptoWithKEK):  Encrypted Data Length = " + encData.Length + ", IV data Length = " + iv.Length + ", KEKVersion = " + kekversion );

            Debug.Assert(iv.Length == 16);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;

            // create a buffer for the raw data
            rawDataArr = new byte[ encData.Length ];

            MemoryStream ms = new MemoryStream(rawDataArr);
            ICryptoTransform cryptTrans = aes.CreateDecryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write( encData, 0, encData.Length );
            cs.Close();


            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::DecryptoWithKEK):  Raw Key Length = " + rawDataArr.Length );

        }

        public static bool GetCurrentUserKeyFromUODB(String gamerTag, out byte[] rawKey)
        {
            UInt64 userPuid = 0;
            Int32 keyEncKeyVersion = 0;
            Int32 keyVersion = 0;
            byte[] iv = null;
            byte[] key = null;

            rawKey = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_askdc_get_principal";
                ws.SetHashVal(gamerTag);
                ws.AddParameter("@vc_name", gamerTag);
                ws.AddParameter("@f_only_xenon_keys", 1);
                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.RecordsAffected > 1)
                    {
                        // Warn that there's more than 1 key that was found
                        Xom.NtEvent(XEvent.Id.CRYPTO_TOO_MANY_USER_KEYS, "There were multiple keys returned for user gamertag: " + gamerTag);
                    }
                    if (reader.Read())
                    {
                        userPuid = (ulong)reader.GetInt64(0);
                        keyEncKeyVersion = reader.GetInt32(1);
                        keyVersion = reader.GetInt32(2);
                        iv = WSClient.GetBytes(reader, "bin_iv");
                        key = WSClient.GetBytes(reader, "bin_key");
                    }
                    else
                    {
                        // Failure to read or 0 rows affected
                        Xom.NtEvent(XEvent.Id.CRYPTO_FAILED_GET_USER_KEYS, "Could not read result from p_askdc_get_principal.");
                    }
                }

                if (userPuid != 0)
                {
                    // Successfully returned from stored proc
                    DecryptWithKEK(keyEncKeyVersion, iv, key, out rawKey);
                    return true;
                }

                return false;
            }
        }

        public static void GenPPAforDBWrp( string GamerTag, byte[]rawKey, out byte [] SPPA, out byte [] PPA )
        {
            m_cryptoWrp.GenPPAforDBWrp(GamerTag, rawKey, out SPPA, out PPA);
        }
        public static byte [] DecryptWithMasterKeyWrp (uint masterkeyver, uint encPasswordLength, byte[] encPassword)
        {
            return m_cryptoWrp.DecryptWithMasterKeyWrp(masterkeyver, encPasswordLength, encPassword);
        }

        public static int GetKeyVersion()
        {
            return Config.GetIntSetting(Setting.crypto_serviceKeyVersion);
        }
    }

    public static class AesUtil
    {
        public static void Encrypt(byte[] plainText, byte[] key, byte[] iv, out byte[] cipherText)
        {
            // check arguments
            if ( plainText == null || plainText.Length <= 0 )
            {
                throw new ArgumentNullException("plainText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            cipherText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;

                // create an encryptor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateEncryptor(aes.Key, aes.IV);

                // create the streams used for encryption.
                ms = new MemoryStream();
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Write);

                // write all data to the stream.
                cs.Write(plainText, 0, plainText.Length);
                cs.FlushFinalBlock();
            }
            finally
            {
                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }

            // return the encrypted bytes from the memory stream
            cipherText = ms.ToArray();
        }

        public static void Encrypt(string plainText, byte[] key, byte[] iv, out byte[] cipherText)
        {
            // check arguments
            if ( plainText == null || plainText.Length <= 0 )
            {
                throw new ArgumentNullException("plainText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            cipherText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamWriter sw = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateEncryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream();
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Write);
                sw = new StreamWriter(cs);

                //Write all data to the stream.
                sw.Write(plainText);
                sw.Close();

            }
            finally
            {
                if ( sw != null )
                {
                    sw.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }

            // return the encrypted bytes from the memory stream
            cipherText = ms.ToArray();
        }

        public static void Decrypt(byte[] cipherText, byte[] key, byte[] iv, out string plainText)
        {
            // check arguments
            if ( cipherText == null || cipherText.Length <= 0 )
            {
                throw new ArgumentNullException("cipherText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            plainText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamReader sr = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;
                aes.Padding = PaddingMode.PKCS7;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateDecryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream(cipherText);
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Read);
                sr = new StreamReader(cs);

                // Read all data from the stream.
                plainText = sr.ReadToEnd();
            }
            finally
            {
                if ( sr != null )
                {
                    sr.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }
        }

        public static void Decrypt(byte[] cipherText, byte[] key, byte[] iv, out byte[] plainText)
        {
            // check arguments
            if ( cipherText == null || cipherText.Length <= 0 )
            {
                throw new ArgumentNullException("cipherText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            plainText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamReader sr = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;
                aes.Padding = PaddingMode.PKCS7;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateDecryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream(cipherText);
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Read);

                MemoryStream outMs = new MemoryStream();

                byte[] buf = new byte[22];

                for (;;)
                {
                    int bytesRead = cs.Read(buf, 0, buf.Length);
                    if ( bytesRead == 0 )
                    {
                        break;
                    }

                    outMs.Write(buf, 0, bytesRead);
                }

                plainText = outMs.ToArray();
            }
            finally
            {
                if ( sr != null )
                {
                    sr.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\CryptoTools.cs ===
///
///  CryptoTools.cs :  Implementation of CryptoTools class.  Handles cryptography on
///     Xbox Live system.
///
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Collections;
using STF.common.service;
using STF.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.cryptotools)]

namespace STF.common.crypto
{
    /// <summary>
    /// WIN32 Crypto API:  Unmanaged code extensions necessary for key management.
    /// </summary>
    /// NOTE:  Add more functions when deemed necessary.
    public class CryptoApi
    {
        #region Crypto API imports

        private const uint ALG_CLASS_HASH = (4 << 13);
        private const uint ALG_TYPE_ANY = (0);
        private const uint ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const uint ALG_TYPE_STREAM = (4 << 9);
        private const uint ALG_TYPE_BLOCK = (3 << 9);

        private const uint ALG_SID_DES = 1;
        private const uint ALG_SID_RC4 = 1;
        private const uint ALG_SID_RC2 = 2;
        private const uint ALG_SID_MD5 = 3;
        private const uint ALG_SID_3DES = 3;
        private const uint ALG_SID_SHA1= 4;

        public const string MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0";
        public const string MS_ENHANCED_PROV = "Microsoft Enhanced Cryptographic Provider v1.0";

        public const uint PROV_RSA_FULL = 1;

        // dwFlags definitions for CryptAcquireContext

        public const uint CRYPT_VERIFYCONTEXT   = 0xF0000000;
        public const uint CRYPT_NEWKEYSET       = 0x00000008;
        public const uint CRYPT_DELETEKEYSET    = 0x00000010;
        public const uint CRYPT_MACHINE_KEYSET  = 0x00000020;
        public const uint CRYPT_SILENT          = 0x00000040;


        public static readonly uint CALG_SHA1= (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1);
        public static readonly uint CALG_MD5 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5);
        public static readonly uint CALG_DES = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES);
        public static readonly uint CALG_RC2 = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2);
        public static readonly uint CALG_RC4 = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM| ALG_SID_RC4);
        public static readonly uint CALG_3DES= (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_3DES);

        // Use these dlls for all other pcs and servers
        const string CryptDll = "advapi32.dll";
        const string KernelDll = "kernel32.dll";

        [DllImport(CryptDll, CharSet = CharSet.Unicode)]
        public static extern bool CryptAcquireContext(  ref IntPtr phProv,
            string pszContainer,
            string pszProvider,
            uint dwProvType,
            uint dwFlags);

        [DllImport(CryptDll)]
        public static extern bool CryptReleaseContext(  IntPtr hProv,
            uint dwFlags);

        [DllImport(CryptDll)]
        public static extern bool CryptEncrypt( IntPtr hKey,
            IntPtr hHash,
            bool Final,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen,
            uint dwBufLen);

        [DllImport(CryptDll)]
        public static extern bool CryptDecrypt( IntPtr hKey,
            IntPtr hHash,
            bool Final,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen);


        [DllImport(CryptDll)]
        public static extern bool CryptImportKey( IntPtr hProv,
            byte[] pbData,
            uint dwDataLen,
            IntPtr hPubKey,
            uint dwFlags,
            ref IntPtr phKey );


        [DllImport(CryptDll)]
        public static extern bool CryptExportKey( IntPtr hKey,
            IntPtr hExpKey,
            uint dwBlobType,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen );


        [DllImport(CryptDll)]
        public static extern bool CryptDestroyKey( IntPtr hKey );


        [DllImport(CryptDll)]
        public static extern bool CryptGetUserKey( IntPtr hProv,
            uint dwKeySpec,
            ref IntPtr hKey) ;

        [DllImport(CryptDll)]
        public static extern bool CryptCreateHash( IntPtr hProv,
            uint algId,
            IntPtr hKey,
            uint flags,
            ref IntPtr hHash) ;

        [DllImport(CryptDll)]
        public static extern bool CryptHashData( IntPtr hHash,
            byte[] data,
            uint dataLength,
            uint flags);

        [DllImport(CryptDll)]
        public static extern bool CryptDeriveKey( IntPtr hProv,
            uint algId,
            IntPtr hHash,
            uint flags,
            ref IntPtr hKey) ;

        [DllImport(CryptDll)]
        public static extern bool CryptDestroyHash( IntPtr hHash );

        #endregion

        #region Error reporting imports

        public const uint NTE_BAD_UID                    = 0x80090001;
        public const uint NTE_BAD_HASH                   = 0x80090002;
        public const uint NTE_BAD_KEY                    = 0x80090003;
        public const uint NTE_BAD_LEN                    = 0x80090004;
        public const uint NTE_BAD_DATA                   = 0x80090005;
        public const uint NTE_BAD_SIGNATURE              = 0x80090006;
        public const uint NTE_BAD_VER                    = 0x80090007;
        public const uint NTE_BAD_ALGID                  = 0x80090008;
        public const uint NTE_BAD_FLAGS                  = 0x80090009;
        public const uint NTE_BAD_TYPE                   = 0x8009000A;
        public const uint NTE_BAD_KEY_STATE              = 0x8009000B;
        public const uint NTE_BAD_HASH_STATE             = 0x8009000C;
        public const uint NTE_NO_KEY                     = 0x8009000D;
        public const uint NTE_NO_MEMORY                  = 0x8009000E;
        public const uint NTE_EXISTS                     = 0x8009000F;
        public const uint NTE_PERM                       = 0x80090010;
        public const uint NTE_NOT_FOUND                  = 0x80090011;
        public const uint NTE_DOUBLE_ENCRYPT             = 0x80090012;
        public const uint NTE_BAD_PROVIDER               = 0x80090013;
        public const uint NTE_BAD_PROV_TYPE              = 0x80090014;
        public const uint NTE_BAD_PUBLIC_KEY             = 0x80090015;
        public const uint NTE_BAD_KEYSET                 = 0x80090016;
        public const uint NTE_PROV_TYPE_NOT_DEF          = 0x80090017;
        public const uint NTE_PROV_TYPE_ENTRY_BAD        = 0x80090018;
        public const uint NTE_KEYSET_NOT_DEF             = 0x80090019;
        public const uint NTE_KEYSET_ENTRY_BAD           = 0x8009001A;
        public const uint NTE_PROV_TYPE_NO_MATCH         = 0x8009001B;
        public const uint NTE_SIGNATURE_FILE_BAD         = 0x8009001C;
        public const uint NTE_PROV_DLL_NOT_FOUND         = 0x8009001E;
        public const uint NTE_BAD_KEYSET_PARAM           = 0x8009001F;
        public const uint NTE_FAIL                       = 0x80090020;
        public const uint NTE_SYS_ERR                    = 0x80090021;
        public const uint NTE_SILENT_CONTEXT             = 0x80090022;
        public const uint NTE_TOKEN_KEYSET_STORAGE_FULL  = 0x80090023;
        public const uint NTE_TEMPORARY_PROFILE          = 0x80090024;
        public const uint NTE_FIXEDPARAMETER             = 0x80090025;

        [DllImport(KernelDll)]
        public static extern uint GetLastError();

        #endregion
    }

    public class CryptoException: Exception
    {
        public CryptoException(string message) : base(message)
        {
        }

        public CryptoException(string message, Exception innerException) : base(message, innerException)
        {
        }

        public CryptoException( uint eventId, string message) : base(message)
        {
            //LogEvent(eventId, new StringBuilder(message));
        }

        public CryptoException( uint eventId, string message, Exception innerException) : base(message, innerException)
        {
            //LogEvent(eventId, message, null, innerException);
        }

        public const uint CRYPTO_GENERAL_ERROR_EVENT = 0xC000C69E;//XEvent.Id.CRYPTO_GENERAL_ERROR;
    }

    /// <summary>
    /// CryptoTools:  Cryptography tools and methods to make managing crypto32 and managed code crypto more usable.
    /// </summary>
    public class CryptoTools
    {
        public CryptoTools()
        {
        }

        /// <summary>
        /// GenerateRandomEncryptedKey:  Creates a random key and en
        /// </summary>
        /// <param name="keySize">Size of the key to generate.</param>
        /// <param name="publicMasterKeyFileName">File name that carries the public master key file.</param>
        /// <param name="masterKeyVersion">out -- returns the master key version from the file.</param>
        /// <returns></returns>
        public byte[] GenerateRandomEncryptedKey( uint keySize, string publicMasterKeyFileName, ref uint masterKeyVersion )
        {
            byte[] randomKey = null;
            byte[] encryptedKey = null;

            // make sure the size is greater than 0
            if ( keySize == 0 )
            {
                return null;
            }

            try
            {
                int bytesRead = -1;
                byte[] fileData = null;
                byte[] keyBlob = null;

                // create the random key array.
                randomKey = GenerateRandomBytes( keySize );

                // --------------------

                // get the public master key.
                using (FileStream pubMasterKeyFile = new FileStream( publicMasterKeyFileName, FileMode.Open, FileAccess.Read ))
                {

                    // read the file data.
                    fileData = new byte[ pubMasterKeyFile.Length ];

                    // read all the data out at once.
                    bytesRead = pubMasterKeyFile.Read( fileData, 0, (int)pubMasterKeyFile.Length );

                    if ( ! ReadPublicKeyFile( fileData, ref masterKeyVersion, ref keyBlob ) )
                    {
                        throw new CryptoException("Failed for read public key file.");
                    }
                }

                // --------------------
                encryptedKey = RSA_Encrypt( randomKey, keyBlob, masterKeyVersion );

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + e.Message,
                    e );
            }

            return encryptedKey;
        }

        /// <summary>
        /// RSA_Encrypt:  Does RSA encryption using the public key.
        /// </summary>
        /// <param name="rawData">data to be encrypted.</param>
        /// <param name="publicKeyBlob">Public key blob to import into CSP for encryption.</param>
        /// <param name="keyVersion">Version of the RSA key to use.</param>
        /// <returns>Encrypted binary array of raw data.</returns>
        /// <exception>Thrown if some error occurs with the encryption.  Details are in the message body.</exception>
        public byte[] RSA_Encrypt( byte[] rawData, byte[] publicKeyBlob, uint keyVersion )
        {
            byte[] encryptedKey = null;
            bool createdNewKeySet = false;
            HResult hr = 0;
            uint dataLength = 0;

            IntPtr hProv = IntPtr.Zero;
            IntPtr hKey = IntPtr.Zero;

            try
            {
                // ensure the key size.
                if ( rawData.Length >= c_masterKeySize )
                {
                    throw new CryptoException( "Invalid Key Size." );
                }

                // acquire context with the provider of the master key.
                if ( !CryptoApi.CryptAcquireContext( ref hProv,
                    c_cspContainerName + keyVersion,
                    CryptoApi.MS_ENHANCED_PROV,
                    CryptoApi.PROV_RSA_FULL,
                    CryptoApi.CRYPT_MACHINE_KEYSET )
                    )
                {
                    hr = CryptoApi.GetLastError();

                    // if not keyset exists we can create one.
                    if ( hr == CryptoApi.NTE_BAD_KEYSET )
                    {
                        if ( !CryptoApi.CryptAcquireContext( ref hProv,
                            c_cspContainerName + keyVersion,
                            CryptoApi.MS_ENHANCED_PROV,
                            CryptoApi.PROV_RSA_FULL,
                            CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_NEWKEYSET )
                            )
                        {
                            hr = CryptoApi.GetLastError();
                            throw new CryptoException( "Failed CryptAcquireContext with Win32 Error = " + hr );
                        }
                        createdNewKeySet = true;
                    }
                    else
                    {
                        throw new CryptoException( "Failed CryptAcquireContext with Win32 Error = " + hr );
                    }

                }

                // make sure we have a provider.
                if ( hProv == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL provider.  This should be impossible, something is corrupted.  Please investigate." );
                }

                // import the public key.
                if(! CryptoApi.CryptImportKey( hProv,
                    publicKeyBlob,
                    (uint)publicKeyBlob.Length,
                    IntPtr.Zero,
                    0,
                    ref hKey))
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed CryptImportKey with Win32 Error = " + hr );
                }

                // ensure we have a key handle.
                if ( hKey == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL handle for our imported key.  This should be impossible, something is corrupted.  Please investigate." );
                }

                // create our buffer at 256 bytes.
                encryptedKey = new byte[ c_masterKeySize ];
                dataLength = (uint)rawData.Length;
                rawData.CopyTo( encryptedKey, 0 );

                // perform the encryption.
                if(!CryptoApi.CryptEncrypt( hKey,
                    IntPtr.Zero,
                    true,
                    0,
                    encryptedKey,
                    ref dataLength,
                    (uint)encryptedKey.Length )
                    )
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed Encryption with Win32 Error = " + hr );
                }

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + e.Message,
                    e );
            }
            finally
            {
                // destroy the key if it exists.
                if ( hKey != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyKey(hKey);
                }

                // release the provider if it exists.
                if ( hProv != IntPtr.Zero )
                {
                    CryptoApi.CryptReleaseContext( hProv, 0 );
                }

                // if we created a new keyset we don't need it anymore.
                if ( createdNewKeySet )
                {
                    CryptoApi.CryptAcquireContext( ref hProv,
                        c_cspContainerName + keyVersion,
                        CryptoApi.MS_ENHANCED_PROV,
                        CryptoApi.PROV_RSA_FULL,
                        CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_DELETEKEYSET
                        );

                    // release the provider.
                    CryptoApi.CryptReleaseContext( hProv, 0 );

                }

            }

            return encryptedKey;
        }

        /// <summary>
        /// GetSymmetricKey:  Gets special symmetric key... it's a surprise ;)
        /// </summary>
        /// <param name="hProv">Handle to the correct provider.</param>
        /// <param name="hSymKey">handle for the symmetric key.</param>
        public static bool GetSymmetricKey ( IntPtr hProv, ref IntPtr hSymKey )
        {
            bool result = false;
            IntPtr hHash = IntPtr.Zero;

            // make sure the provider isnt' a waste of time.
            if ( hProv == IntPtr.Zero )
            {
                throw new CryptoException( "CryptoTools::GetSymmetricKey:  Key Provider is invalid." );
            }

            try
            {
                hSymKey = IntPtr.Zero;

                // create the hash object
                if(!CryptoApi.CryptCreateHash( hProv,
                                     CryptoApi.CALG_SHA1,
                                     IntPtr.Zero,
                                     0,
                                     ref hHash ) )
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptCreateHash!  Error = " + err.ToString("X") + ".\r\n" );
                }

                // Hash the password
                if(!CryptoApi.CryptHashData(
                    hHash,
                    System.Text.ASCIIEncoding.ASCII.GetBytes( c_MKSymKey ),
                    (uint)c_MKSymKey.Length,
                    0))
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptHashData!  Error = " + err.ToString("X") + ".\r\n" );
                }

                // Create a session key based on the hash of the password.
                if(!CryptoApi.CryptDeriveKey(
                    hProv,
                    CryptoApi.CALG_3DES,
                    hHash,
                    0,
                    ref hSymKey))
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptDeriveKey!  Error = " + err.ToString("X") + ".\r\n" );
                }

                result = true;
            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + e.Message,
                    e );
            }
            finally
            {
                if( hHash != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyHash(hHash);
                }
            }

            return result;
        }

        /// <summary>
        /// GenerateRandomBytes:  Generates an array of crypto safe random bytes.
        /// </summary>
        /// <param name="size">Size of array to return.</param>
        /// <returns></returns>
        public static byte[] GenerateRandomBytes( uint size )
        {
            byte[] randomKey = null;

            try
            {
                //check the size.
                if ( size < 1 )
                {
                    throw new Exception("The requested array size is invalid.  It must be > 0.");
                }

                // create the random key array.
                randomKey = new byte[ size ];
                RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

                // get our new random key.
                rng.GetBytes( randomKey );

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomBytes: (ERROR)  "  + ce.ToString() );
                randomKey = null;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomBytes: (ERROR)  "  + e.ToString() );
                randomKey = null;
            }

            return randomKey;
        }

        /// <summary>
        /// ReadPublicKeyFile:  Reads Xbox Live Key Files
        /// </summary>
        /// <param name="publicKeyFileData">File blob</param>
        /// <param name="keyVersion">Key version of the file.</param>
        /// <param name="Key Blob">The Key blob to be imported.</param>
        /// <returns>True if successfully read.</returns>
        public static bool ReadPublicKeyFile( byte[] publicKeyFileData, ref uint keyVersion, ref byte[] keyBlob )
        {
            bool result = true;

            try
            {
                if ( publicKeyFileData == null )
                {
                    result = false;
                    throw new Exception("No public key file data provided." );
                }

                MemoryStream ms = new MemoryStream( publicKeyFileData );
                BinaryReader br = new BinaryReader( ms );

                keyVersion = br.ReadUInt32();

                // read the rest of the buffer into the blob.
                keyBlob = br.ReadBytes( publicKeyFileData.Length - (int)c_keyVersionSize );
            }
            catch (Exception e)
            {
                // TODO:  add proper logging code here.
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::ReadPublicKeyFile: (ERROR)  "  + e.ToString() );
            }

            return result;
        }

        // constants
        protected const uint    c_publicKeyMagic    = 0x31415352;
        protected const uint    c_privateKeyMagic   = 0x32415352;
        protected const uint    c_ExponentSize      = 4;

        protected const uint    c_keyVersionSize    = 4;            // key versions are 4 bytes big.
        protected const string  c_MKSymKey          = "XOCryptGenRandom failed!";
        public    const string  c_cspContainerName  = "XOMasterKey";
        public    const uint    c_masterKeySize     = 256;


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\DownloadQueueProtocol.cs ===
using System;

using STF.common.service;


namespace STF.common.protocol
{
    public class CreateDownloadQueueRequest : XRLObject2
    {
        public ulong userPuid;
        public byte nameLength;
        public ushort xmlLength;

        [WireInfo( SizeParam = "nameLength" )]
        public string name;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get { return "/Lists/CreateDownloadQueue.ashx"; }
        }
    }


    public class CreateDownloadQueueResponse : XRLObject2
    {
        public int queueId;
        public DateTime lastModified;

        public CreateDownloadQueueResponse( CreateListReply reply )
        {
            queueId = reply.listId;
            lastModified = reply.lastModified;
        }
    }


    public class ModifyDownloadQueueRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort xmlLength;

        [WireInfo( SizeParam = "xmlLength" )]
        public string xmlProperties;

        public override string Xrl
        {
            get { return "/Lists/ModifyDownloadQueue.ashx"; }
        }
    }


    public class ModifyDownloadQueueResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyDownloadQueueResponse( ModifyListReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class QueryDownloadQueuesRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId; // int.MinValue is wildcard
        public DateTime lastModified;
        public int pageSize;
        public int pageNum;
        public int orderDir;

        public override string Xrl
        {
            get { return "/Lists/QueryDownloadQueues.ashx"; }
        }
    }


    public class QueryDownloadQueuesResponse : XRLObject2
    {
        public ushort totalQueues = 0;
        public ushort numQueues = 0;

        [WireInfo( SizeParam = "numQueues" )]
        public ListInfo[] resultQueues = null;

        public QueryDownloadQueuesResponse( QueryListsReply reply )
        {
            totalQueues = reply.totalLists;
            resultQueues = reply.resultLists;
            if( resultQueues != null ) {
                numQueues = (ushort) resultQueues.Length;
            }
        }
    }


    public class GrantDownloadQueueAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public ulong machinePuid;

        public override string Xrl
        {
            get { return "/Lists/GrantDownloadQueueAccess.ashx"; }  
        }
    }


/*
    public class GrantDownloadQueueAccessResponse : XRLObject2
    {
        public GrantDownloadQueueAccessResponse( GrantListAccessReply reply )
        {
        }
    }
*/


    public class RevokeDownloadQueueAccessRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public ulong machinePuid; // 0 is wildcard

        public override string Xrl
        {
            get { return "/Lists/RevokeDownloadQueueAccess.ashx"; }
        }
    }


/*
    public class RevokeDownloadQueueAccessResponse : XRLObject2
    {
        public RevokeDownloadQueueAccessResponse( RevokeListAccessReply reply )
        {
        }
    }
*/


    public class InsertDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] items;

        public override string Xrl
        {
            get { return "/Lists/InsertDownloadItems.ashx"; }
        }
    }


    public class InsertDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public InsertDownloadItemsResponse( InsertItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class DeleteDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds;

        public override string Xrl
        {
            get { return "/Lists/DeleteDownloadItems.ashx"; }
        }
    }


    public class DeleteDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public DeleteDownloadItemsResponse( DeleteItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class ModifyDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numItems;

        [WireInfo( SizeParam = "numItems" )]
        public ListItemMod[] items;

        public override string Xrl
        {
            get { return "/Lists/ModifyDownloadItems.ashx"; }
        }
    }


    public class ModifyDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public ModifyDownloadItemsResponse( ModifyItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }


    public class QueryDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public int pageSize;
        public int pageNum;
        public int orderDir;
        public ushort numIds;

        [WireInfo( SizeParam = "numIds" )]
        public Guid[] itemIds; // empty array is wildcard

        public override string Xrl
        {
            get { return "/Lists/QueryDownloadItems.ashx"; }
        }
    }


    public class QueryDownloadItemsResponse : XRLObject2
    {
        public ushort totalItems = 0;
        public DateTime lastModified = DateTime.MinValue;
        public ushort numItems = 0;

        [WireInfo( SizeParam = "numItems" )]
        public ListItem[] resultItems = null;

        public QueryDownloadItemsResponse( QueryItemsReply reply )
        {
            totalItems = reply.totalItems;
            lastModified = reply.lastModified;
            resultItems = reply.resultItems;
            if( resultItems != null ) {
                numItems = (ushort) resultItems.Length;
            }
        }
    }


    public class MoveDownloadItemsRequest : XRLObject2
    {
        public ulong userPuid;
        public int queueId;
        public DateTime lastModified;
        public ushort numIndices;

        [WireInfo( SizeParam = "numIndices" )]
        public ListItemIndex[] itemIndices;

        public override string Xrl
        {
            get { return "/Lists/MoveDownloadItems.ashx"; }
        }
    }


    public class MoveDownloadItemsResponse : XRLObject2
    {
        public DateTime lastModified;

        public MoveDownloadItemsResponse( MoveItemsReply reply )
        {
            lastModified = reply.lastModified;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\EventBuilder.cs ===
using System;
using System.Diagnostics;
using System.IO;

using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Web;
using System.Xml;

using STF.common.config;
using STF.common.exceptions;
using STF.common.mgmt;

// error CS0420: Warning as Error: a reference to a volatile field will not be treated as 
// volatile
#pragma warning disable 420

namespace STF.common.service
{
    [ComVisible(false)]
    public class EventBuilder
    {
        private static bool _showSGInfo = true;

        public static bool ShowSGInfo
        {
            get {return _showSGInfo;}
            set {_showSGInfo = value;}
        }

        private static EventLogEntryType[] _typeMapping = {
                                                              EventLogEntryType.Information,
                                                              EventLogEntryType.Information,
                                                              EventLogEntryType.Warning,
                                                              EventLogEntryType.Error
                                                          };

        // Log an NT event, bypassing xmgmt codegen
        //
        // WARNING: Avoid calling this directly where possible.   Xmgmt
        // brings all sorts of goodness, including event throttling by
        // file and line #.   Calling this directly will bypass all that goodness,
        // leaving OPs powerless against this event.
        //
        // Are you SURE you want to call this?
        // consider this instead (without the space in Xom Nt..):
        //  Xom NtEvent(YOUR_EVENT_ID, "Your Message\r\n" + EventBuilder.ExceptionToString(e));

        public static void LogEvent(XEvent.Id eventId, string message, Exception e)
        {
            LogEvent(
                XomLogTargetContext.Empty,
                Config.ComponentName,
                (sbyte)(((uint) eventId)>>30),
                (ushort) XEvent.MessageFromId(eventId),
                null,
                message,
                e);
        }

        // Do not touch this variable outside of the LogEvent method. It's important that 
        // it maintains its integrity.
        [ThreadStatic]
        private static int _logEventCallDepth = 0;

        public static void LogEvent( XomLogTargetContext msgCtx, string area, sbyte level, ushort msgId, byte [] msgData, string message, Exception e )
        {
            try
            {
                // Prevent infinite recursion - if something in LogEvent tries to log an 
                // event using Xom NtEvent (or EventBulder.LogEvent), detect that and bail 
                // out.
                //
                // Also, we don't need to use Interlocked functions nor mark it "volatile" 
                // since this is a thread static variable.
                if (++_logEventCallDepth > 1)
                {
                    // Bypass all the fancy stuff
                    string fullMessage = "[Bypassing event builder. Call depth = " + _logEventCallDepth + ", Thread id = " + Thread.CurrentThread.ManagedThreadId + "]\r\n\r\n" + message;
                    if (e != null)
                    {
                        fullMessage += "\r\n\r\n" + XblException.Format(e);
                    }
                    LogEventSimple(Config.ComponentName, level, msgId, msgData, fullMessage);
                    return;
                }
                
                System.Text.StringBuilder eventText = new System.Text.StringBuilder();
                string srcFile = null;
                ushort srcLine = 0;
                uint numSkips = 0;


                if (false == EventThrottler.FireEvent(msgId, out numSkips))
                {
                    // skip it!
                    return;
                }

                if (numSkips > 0)
                {
                    eventText.Append("EventThrottle: skipped ");
                    eventText.Append(numSkips);
                    eventText.Append(" previous events\r\n\r\n");
                }


                // always need flowtoken. We won't bother showing it if it isn't valid, 
                // though.
                if (msgCtx.FlowToken.IsValid)
                {
                    eventText.AppendLine("Floken: " + msgCtx.FlowToken.ToString());
                }

                if (e == null)
                    GetStackSrc(new StackTrace(true), out srcFile, out srcLine);
                else
                {
                    // when an exception is provided, use the line
                    // from that insetad of the provided file/line numbers
                    //
                    GetExceptionSrc(e, out srcFile, out srcLine);
                }

                if (srcFile == null)
                    eventText.Append("Source from reflection: [not available]\r\n");
                else {
                    // add the src and line
                    eventText.AppendLine("Source from reflection: " + srcFile + ":" + srcLine);
                }

                if (message != null)
                {
                    if (e != null)
                    {
                        HResult hr = XblException.GetHResult(e);
                        message = message + "; hr = " + hr.ToString();
                        if (hr.HasName)
                        {
                            message = message + " (" + hr.Name + ")";
                        }
                    }

                    eventText.AppendLine(message);
                }

                //
                // add info about the exception(s)
                //
                if (e != null)
                {
                    eventText.AppendLine();
                    eventText.Append(EventBuilder.ExceptionToString(e));
                }

                // IIS7 no longer allows testing for null request
                // in Application_Start/End.  It  throws  instead

                HttpContext context = null;
                HttpRequest request = null;
                
                try
                {
                    context = HttpContext.Current;
                    if (context != null) request = context.Request;
                }
                catch (HttpException)
                {
                }

                if (request != null)
                {
                    //
                    // add info about the current sg/aa ticket, if applicable
                    //

                    eventText.AppendLine();

                    try
                    {
                        if (SGInfo.IsActiveAuth())
                        {
                            eventText.AppendLine("----- AA Info -----");

                            AAInfo aainfo = AAInfo.Current;

                            // See if an AAInfo was actually found.  
                            if (aainfo == null)
                                eventText.AppendLine("No AA Info found.");
                            else
                            {
                                eventText.AppendLine(aainfo.ToString());
                            }
                        }
                        else if (ShowSGInfo)
                        {
                            if (SGInfo.IsAvailableInContext(context))
                            {
                                eventText.AppendLine("----- SG Info -----");

                                if (SGInfo.Current == null)
                                    eventText.AppendLine("No SG Info found.");
                                else
                                {
                                    eventText.AppendLine(SGInfo.Current.ToString());
                                }
                            }
                        }
                    }
                    catch(Exception eSgInfo)
                    {
                        // an error getting SGInfo shouldn't be fatal to event logging
                        eventText.Append("\r\nError getting SG/AA Info.\r\n");
                        eventText.Append(eSgInfo.ToString());
                    }

                    //
                    // add info about the http request
                    //

                    eventText.AppendLine();
                    eventText.AppendLine("----- Http Request -----");

                    try
                    {
                        eventText.AppendLine("URL:    " + request.RawUrl);
                        eventText.AppendLine("Headers:");

                        for (int i = 0; i < request.Headers.Count; i++)
                        {
                            string key = request.Headers.Keys[i];

                            string header = request.Headers[i];
                            eventText.Append("  ");
                            eventText.Append(request.Headers.Keys[i]);
                            eventText.Append(": ");

                            if (key == XHttpHdr.AUTHZ || key == XHttpHdr.BUNDLEDAUTHDATA || key == XHttpHdr.HTTPAUTHDATA)
                            {
                                const int truncateTo = 64;

                                if (header.Length > truncateTo)
                                {
                                    header = string.Format("{0} ({1} more bytes)", header.Substring(0, truncateTo), header.Length - truncateTo);
                                }
                            }

                            eventText.Append(header);
                            eventText.Append("\r\n");
                        }

                        eventText.AppendLine();

                        if (context.Items["XErr"] != null)
                        {
                            eventText.AppendLine("X-Err: " + ((HResult)context.Items["XErr"]));
                            eventText.AppendLine();
                        }


                        // if they have a wiredata request,  then attempt  to
                        // format it.  it's as simple as calling the ToString

                        eventText.AppendLine("----- Request Data -----");
                        string postString = string.Empty;

                        try {
                            
                            if (context.Items["XRLRequest"] != null)
                                postString = ((XRLObject2) context.Items["XRLRequest"]).ToString();

                            // joy, they have no request.  that means we failed to
                            // deserialize it, see if there is a POST input stream

                            else if (request.HttpMethod != "POST")
                                postString = "No data available";

                            else if (context.Items["NoPostBufferLog"] != null)
                                postString = "Data is marked as not loggable";

                            // they have an input stream, and we  are  allowed  to
                            // log it.  read it and format based on  content  type
                            // if all else fails then we log  a  hexadecimal  dump

                            else if (request.ContentType.StartsWith("text/xml")) {
                                postString = ToXml(request, Config.GetIntSetting(Setting.wiredata_postLimit));
                            }
                        }
                        catch {
                        }

                        try {
                            if (postString == string.Empty) {
                                postString = ToHex(request, Config.GetIntSetting(Setting.wiredata_postLimit));
                            }
                        }
                        catch {
                            // ignore exception. we don't want a double error when
                            // logging an event or we can loose the initial  error
                        }

                        // if we have anything at this point, then add it to the event

                        if (postString != string.Empty) {
                            eventText.AppendLine(postString);
                        }

                        eventText.AppendLine();

                        if (context.Items["XRLResponse"] != null)
                        {
                            eventText.Append("\r\n\r\n----- Response Data -----\r\n");
                            eventText.Append(((XRLObject2)context.Items["XRLResponse"]).ToString());
                            eventText.Append("\r\n");
                        }

                    }
                    catch (Exception eHttpContext)
                    {
                        eventText.Append("\r\nError reading HTTPContext info:\r\n");
                        eventText.Append(eHttpContext.ToString());
                    }
                }
                //
                // make sure this is an event we want to fire..
                //
                if (false == EventThrottler.FireEvent(msgId, eventText.ToString(), out numSkips))
                {
                    // skip it!
                    return;
                }

                if (numSkips > 0)
                {
                    eventText.Append("EventThrottle: skipped ");
                    eventText.Append(numSkips);
                    eventText.Append(" previous events\r\n\r\n");
                }

                // "area" is the xmgmt area, like DefaultNtLog if using Xom NtEvent. We 
                // don't use that.
                LogEventSimple(Config.ComponentName, level, msgId, msgData, eventText.ToString());

            }
            catch (Exception ex)
            {
                // no messing around, go directly to the event log
                string eStr = ex.ToString();
                int start;
                int len;
                int maxIndex = eStr.Length - 1;

                for( start = 0; start < maxIndex; start += len ) { // event string must be < 32766 characters
                    len = Math.Min( eStr.Length - start, XomLoggingControl.MaxEventLength );
                    System.Diagnostics.EventLog.WriteEntry( "EventBuilder",
                        "ERROR generating event for eventlog!!\r\n" + eStr.Substring( start, len ) + "\r\n\r\n" +
                        "This is the original message trying to be written\r\n" +
                        message,
                        System.Diagnostics.EventLogEntryType.Error,
                        (int) (((uint) XEvent.Id.COMMON_CODE_57) & 30) );
                }
            }
            finally 
            {
                _logEventCallDepth--;
            }
        }


        private static string ToXml(HttpRequest request, int maximumLength)
        {

            long position = request.InputStream.Position;
            XmlDocument document = new XmlDocument();

            request.InputStream.Seek(0, SeekOrigin.Begin);
            document.Load(request.InputStream);
            request.InputStream.Seek(position, SeekOrigin.Begin);

            StringBuilder stringBuilder   = new StringBuilder();
            StringWriter  stringWriter    = new StringWriter(stringBuilder);
            XmlWriterSettings xmlSettings = new XmlWriterSettings();

            xmlSettings.Indent = true;
            xmlSettings.IndentChars = "    ";

            XmlWriter xmlWriter = XmlWriter.Create(stringWriter, xmlSettings);
            document.WriteTo(xmlWriter);
            xmlWriter.Flush();

            if (stringBuilder.Length > maximumLength)
            {
                int length = stringBuilder.Length;
                stringBuilder.Length = maximumLength;
                stringBuilder.AppendLine("\r\n\r\nData truncated (" + (length - maximumLength) + " more bytes)");
            }

            return stringBuilder.ToString();
        }


        private static string ToHex(HttpRequest request, int maximumLength)
        {
            long length = request.InputStream.Length;
            string s    = string.Empty;

            if (length > maximumLength)
            {
                s = "\r\nData truncated (" + (length - maximumLength) + " more bytes)";
                length = maximumLength;
            }

            // allocate the buyffer and read from the beginning of the
            // stream.  reset the stream position when   done  reading

            byte[] bytes = new byte[length];
            long position = request.InputStream.Position;

            request.InputStream.Seek(0, SeekOrigin.Begin);
            request.InputStream.Read(bytes, 0, (int) length);
            request.InputStream.Seek(position, SeekOrigin.Begin);

            // convert the byte array into  a  pretty  hex  dump

            string[] lines = ByteConvert.ToFormattedStrings(bytes);
            for (int i = lines.Length - 1;  i >= 0; i--) s = lines[i] + "\r\n" + s;
            return s;
        }


        public static void LogEventSimple(string eventSource, sbyte level, ushort msgId, byte[] msgData, string eventText)
        {
            // now write to event log.  The final string may be more
            // than one entry can take, so we chunk them up.
            //
            int start;
            int len;
            int maxIndex = eventText.Length - 1;

            for (start = 0; start < maxIndex; start += len)
            {
                len = Math.Min( eventText.Length - start, STF.common.mgmt.XomLoggingControl.MaxEventLength );

                // Don't pass the msgData in. This is a sometimes huge block of binary 
                // data that we haven't actually seen a use for. If someone feels 
                // strongly about this, add it back but provide a way to log it or 
                // not--probably not should be the default.
                System.Diagnostics.EventLog.WriteEntry(
                    eventSource,
                    eventText.Substring(start, len),
                    _typeMapping[ level ],
                    msgId,
                    0);
                //msgData);
            }
        }

        //
        // Convert an exception to an ops-friendly string.
        //
        public static string ExceptionToString( Exception e )
        {
            return XblException.Format(e);
        }

        public static void GetExceptionSrc( Exception e, out string srcFile, out ushort srcLine )
        {
            Exception eCur = e;
            srcFile = null;
            srcLine = 0;

            // find the first frame with file and line info
            while (srcFile == null && eCur != null)
            {
                StackTrace stack = new StackTrace(eCur, true);

                GetStackSrc(stack, out srcFile, out srcLine);

                eCur = eCur.InnerException;
            }
        }

        public static void GetStackSrc( StackTrace stack, out string srcFile, out ushort srcLine )
        {
            srcFile = null;
            srcLine = 0;

            for (int i = 0; i < stack.FrameCount; i++)
            {
                StackFrame frame = stack.GetFrame(i);

                // skip over the uninteresting Logging/xmgmt calls..
                if (frame.GetMethod().DeclaringType != null)
                {
                    if ((frame.GetMethod().Name == "LogEvent" &&
                         frame.GetMethod().DeclaringType.FullName == "STF.common.service.EventBuilder") ||
                        (frame.GetMethod().DeclaringType.FullName.StartsWith("STF.common.mgmt")))
                    continue;
                }

                srcFile = frame.GetFileName();
                srcLine = (ushort)frame.GetFileLineNumber();

                if (srcFile != null)
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\EnumerableFormatter.cs ===
//
// This class handles formatting for anything that implements IEnumerable.
// You can use it like any other formatter and format string, but the easiest way will 
// generally be to use the static wrapper:
//
// List<int> ilist = new List<int>();
// AddStuffToList(ilist);
// string allitems = EnumerableFormatter.FormatEnumerable(ilist);
//
// If you want to pass a formatting string to each item in the list to format it, you can 
// do this:
// string allitems = EnumerableFormatter.FormatEnumerable(ilist, "format");
//
// So the following code:
// int[] ints = new int[] {1, 2, 10, 20};
// Console.WriteLine(EnumerableFormatter.FormatEnumerable(ints));
// Console.WriteLine(EnumerableFormatter.FormatEnumerable(ints, "X"));
//
// prints:
// [1, 2, 10, 20]
// [1, 2, A, 14]
//
// The same can be accomplished with this:
// Console.WriteLine(String.Format(EnumerableFormatter.Instance, "{0:ef}", ints));
// Console.WriteLine(String.Format(EnumerableFormatter.Instance, "{0:efX}", ints));
//
// For a simple formatting job like this, the static wrapper is probably preferred. For a 
// more complex thing, perhaps not.
// 

using System;
using System.Collections;
using System.Text;

namespace STF.common.utilities2
{
    public class EnumerableFormatter: ICustomFormatter, IFormatProvider
    {
        public static EnumerableFormatter Instance
        {
            get { return _instance; }
        }

        public static string FormatEnumerable(IEnumerable enumerable)
        {
            return FormatEnumerable(enumerable, String.Empty);
        }

        public static string FormatEnumerable(IEnumerable enumerable, string format)
        {
            string wholeFormat = String.Format(COMPLETE_FORMAT, FORMAT_PREFIX, format);
            return String.Format(Instance, wholeFormat, enumerable);
        }

        public object GetFormat(Type argType)
        {
            if (argType == typeof(ICustomFormatter))
            {
                return this;
            }
            else
            {
                return null;
            }
        }

        public string Format(string formatString, object argToBeFormatted, IFormatProvider nextProvider)
        {
            if (!CanHandleFormatRequest(formatString, argToBeFormatted))
            {
                return PassThroughFormat(formatString, argToBeFormatted, nextProvider);
            }

            IEnumerable args = (IEnumerable) argToBeFormatted;
            string passThroughFormat = GetPassThroughFormat(formatString);

            StringBuilder sb = new StringBuilder();
            sb.Append(BEGINNING_WRAPPER);

            bool firstItem = true;
            foreach (object o in args)
            {
                if (!firstItem)
                {
                    sb.Append(DELIMITTER);
                }
                firstItem = false;
                sb.Append(String.Format(passThroughFormat, o));
            }

            if (firstItem)
            {
                sb.Append(EMPTY);
            }

            sb.Append(ENDING_WRAPPER);
            return sb.ToString();
        }

        private static bool CanHandleFormatRequest(string formatString, object argToBeFormatted)
        {
            return !String.IsNullOrEmpty(formatString) && formatString.StartsWith(FORMAT_PREFIX) && argToBeFormatted is IEnumerable;
        }

        private static string PassThroughFormat(string formatString, object argToBeFormatted, IFormatProvider nextProvider)
        {
            if (argToBeFormatted is IFormattable)
            {
                return ((IFormattable) argToBeFormatted).ToString(formatString, nextProvider);
            }
            else
            {
                return argToBeFormatted.ToString();
            }
        }

        private static string GetPassThroughFormat(string wholeFormat)
        {
            string format = wholeFormat.Substring(FORMAT_PREFIX.Length);
            if (String.IsNullOrEmpty(format))
            {
                return SINGLE_ITEM_FORMAT;
            }
            else
            {
                return String.Format(SINGLE_ITEM_PASSTHROUGH_FORMAT, format);
            }
        }

        public const string FORMAT_PREFIX = "ef";
        private const string SINGLE_ITEM_FORMAT = "{0}";
        private const string SINGLE_ITEM_PASSTHROUGH_FORMAT = "{{0:{0}}}";
        private const string BEGINNING_WRAPPER = "[";
        private const string ENDING_WRAPPER = "]";
        private const string DELIMITTER = ", ";
        private const string EMPTY = "empty";
        private const string COMPLETE_FORMAT = "{{0:{0}{1}}}";

        private static EnumerableFormatter _instance = new EnumerableFormatter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\DumpStatic.cs ===
// The DumpStatic xmgmt command will all static members of a type. This can be especially
// useful for singletons and cached information--you can get at the data without
// breaking into a debugger. All Front doors have it automatically.
//
// For each static member, we attempt to print it in a meaningful way. To do this, we look for
// an implementation of IXmgmtDumpStaticFormatter that can handle the object. Two special-cases
// of this are the DumpStaticToStringXmgmtFormatter and the ToStringXmgmtFormatter.
//
// DumpStaticToStringXmgmtFormatter sees if the object passed in implements IXmgmtDumpStaticToString
// and if so will call DumpStaticToString on that object. This allows us to implement a special
// ToString-style function just for this purpose. This is useful in cases where ToString is used
// for something else and doesn't have the information we want.
//
// ToStringXmgmtFormatter will work on anything, since all objects have a ToString function.
//
// If neither ToString nor IXmgmtDumpStaticToString work well for an type (like Hashtable),
// you can still get good information by providing an implementation of IXmgmtDumpStaticFormatter
// that handles that specific type, and then putting it in the correct place in
// XmgmtDumpStaticFormatterFactory.
//
// I considered using ICustomFormatter and IFormatProvider, but they seem a bit heavy-handed
// for this particular purpose. If we find that richer formatting are desirable, we should
// consider that solution.


using System;
using System.Text;
using System.Reflection;
using System.Collections;

using STF.common.service;
using STF.common.utilities2;
using STF.common.mgmt;


[assembly: FrontEndAppInitialization(typeof(STF.common.service.DumpStaticMgmt), "Init")]

namespace STF.common.service
{
    // Handles the xmgmt command registration and handling. Note that the Init function is
    // called via the FrontEndAppInitialization infrastructure.
    internal static class DumpStaticMgmt
    {
        private static void Init()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(DumpStaticMgmt.OnControlRequest);
        }

        private static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch (args.Command.ToLower())
            {
                case "help":
                case "h":
                    XomControlConnection.SendMessage(
                        "DumpStatic help:\r\n" +
                        "  DumpStatic fully_qualified_type_name <optional field name> will dump all static members of the specified type,\r\n" +
                        "  or just the specifed field name.\r\n" +
                        "  example: DumpStatic STF.common.config.Config prints a heap-load of information.\r\n" +
                        "  example: DumpStatic STF.common.config.Config _rwLockTimeout only prints the lock timeout value.\r\n"
                        , args.RequestId);
                    args.Handled = true;
                    break;

                case "dumpstatic":
                    XomControlConnection.SendMessage(ProcessDumpStatic(args), args.RequestId);
                    args.Handled = true;
                    break;
            }
        }

        private static string ProcessDumpStatic(ControlRequestEventArgs args)
        {
            if (args.CommandArgs.Length != 1 && args.CommandArgs.Length != 2)
            {
                throw new ArgumentException(String.Format("args.CommandArgs.Length is {0} but must be 1 or 2.", args.CommandArgs.Length), "args");
            }

            return DumpStaticImpl.DumpStatic(args.CommandArgs[0], args.CommandArgs.Length == 2 ? args.CommandArgs[1] : null);
        }
    }

    // Side interface you can implement if for whatever reason ToString isn't a good idea
    // for your type. Otherwise use ToString.
    internal interface IXmgmtDumpStaticToString
    {
        string DumpStaticToString();
    }

    // Want rich formatting for an object type that we don't own (like .NET objects)? Implement this.
    // NOTE--these must be stateless!
    // Also, don't forget to add your implementation to XmgmtDumpStaticFormatterFactory.
    internal interface IXmgmtDumpStaticFormatter
    {
        // Returns true if the formatter can format the object passed in.
        bool CanFormat(object o);

        // Formats the object passed in.
        string Format(object o);
    }

    // Holds a cache of all available formatters. Call GetFormatter to get the appropropriate
    // formatter for a given object.
    internal static class XmgmtDumpStaticFormatterFactory
    {
        public static IXmgmtDumpStaticFormatter GetFormatter(object o)
        {
            return Array.Find(s_formatters, delegate(IXmgmtDumpStaticFormatter formatter) { return formatter.CanFormat(o); });
        }

        private static readonly IXmgmtDumpStaticFormatter[] s_formatters = new IXmgmtDumpStaticFormatter[]
            {
                new DumpStaticToStringXmgmtFormatter(),
                new HashtableXmgmtFormatter(),
                new EnumerableXmgmtFormatter(),
                new ToStringXmgmtFormatter(),
            };
    }

    // Simple formatter that uses IXmgmtDumpStaticToString.
    internal sealed class DumpStaticToStringXmgmtFormatter : IXmgmtDumpStaticFormatter
    {
        public bool CanFormat(object o)
        {
            return o is IXmgmtDumpStaticToString;
        }

        public string Format(object o)
        {
            return (o as IXmgmtDumpStaticToString).DumpStaticToString();
        }
    }

    // For IEnumerables, we want to be able to print the individual elements.
    internal sealed class EnumerableXmgmtFormatter : IXmgmtDumpStaticFormatter
    {
        public bool CanFormat(object o)
        {
            // Strings are enumerable, but that's just silly.
            return o is IEnumerable && !(o is string);
        }

        public string Format(object o)
        {
            return EnumerableFormatter.FormatEnumerable(o as IEnumerable);
        }
    }

    // If all else fails, there's always ToString.
    internal sealed class ToStringXmgmtFormatter : IXmgmtDumpStaticFormatter
    {
        public bool CanFormat(object o)
        {
            return true;
        }

        public string Format(object o)
        {
            return o.ToString();
        }
    }

    // Hashtables don't print nicely, even with the EnumerableFormatter, so
    // here's a custom formatter for them.
    // Note--we always use ToString for the Key and Value of each element.
    // We could change this to get another IXmgmtDumpStaticFormatter for
    // each of them, which would allow us to do more sophisticated formatting
    // per element.
    internal sealed class HashtableXmgmtFormatter : IXmgmtDumpStaticFormatter
    {
        public bool CanFormat(object o)
        {
            return o is Hashtable;
        }

        public string Format(object o)
        {
            StringBuilder sb = new StringBuilder();
            Hashtable ht = o as Hashtable;

            sb.AppendLine();
            foreach (DictionaryEntry entry in ht)
            {
                sb.AppendLine(String.Format("    {0} : {1}", entry.Key, entry.Value));
            }

            return sb.ToString();
        }
    }

    // Core implementation of the DumpStatic function.
    static class DumpStaticImpl
    {
        // Builds a pretty-print string of all the static members of the class whose name is passed in.
        public static string DumpStatic(string className, string fieldName)
        {
            StringBuilder sb = new StringBuilder();

            // Find the class in this assembly
            Type classToDump = Type.GetType(className, false);
            if (classToDump == null)
            {
                sb.AppendLine(String.Format("Could not find class '{0}'.", className));
                return sb.ToString();
            }

            sb.AppendLine(String.Format("Class {0}:", className));

            // Get the relevent fields and print them.
            sb.Append(DumpStaticFields(GetStaticFields(classToDump, fieldName)));

            return sb.ToString();
        }

        // Gets the fields requested. null for fieldName means all, which is why we return
        // them as an array.
        private  const BindingFlags GETFIELD_FLAGS = BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy;
        private static FieldInfo[] GetStaticFields(Type type, string fieldName)
        {
            if (fieldName == null)
            {
                return type.GetFields(GETFIELD_FLAGS);
            }
            else
            {
                FieldInfo field = type.GetField(fieldName, GETFIELD_FLAGS);
                if (field != null)
                {
                    return new FieldInfo[] { field };
                }
                else
                {
                    return new FieldInfo[0];
                }
            }
        }

        // Walk through a bunch of fields, printing each one in turn.
        private static string DumpStaticFields(FieldInfo[] fields)
        {
            StringBuilder sb = new StringBuilder();
            foreach (FieldInfo field in fields)
            {
                sb.AppendLine(DumpStaticField(field));
            }

           return sb.ToString();
        }

        // Actually print the field as a line.
        private static string DumpStaticField(FieldInfo field)
        {
            string type = field.FieldType.ToString();
            string name = field.Name;
            object value = SafeGetValue(field);

            return String.Format("  +{0} {1} = {2}", type, name, FormatValue(value));
        }

        // Uses the IXmgmtDumpStaticFormatter infrastructure described above to
        // attempt a decent print-out of the object passed in.
        private static string FormatValue(object o)
        {
            IXmgmtDumpStaticFormatter formatter = XmgmtDumpStaticFormatterFactory.GetFormatter(o);
            return formatter.Format(o);
        }

        // I found that some of the fields we go through can't be evaluated.
        // It's important that we get the information we can and print it so
        // I swallow all exceptions here.
        private static object SafeGetValue(FieldInfo field)
        {
            object value = null;
            try
            {
                value = field.GetValue(null) ?? "null";
            }
            catch (Exception e)
            {
                value = e.GetType().ToString();
            }
            return value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\EventThrottler.cs ===
using System;
using System.Text;
using System.Collections;

using STF.common.config;
using STF.common.mgmt;

namespace STF.common.service
{
    public class EventThrottler
    {

        private const ulong HNS_PER_SECOND = 10000000;

        enum ALLOW_TYPE
        {
            UNKNOWN         = 0,
            ALWAYS_ALLOW    = 1,    // This event will always occur, and isn't tracked
            SOMETIMES_ALLOW = 2,    // This event will sometimes occur (based on other params)
            NEVER_ALLOW     = 3     // This event has been squelched
        };

        class EventTrackingStuff               // sizeof() == 28
        {
            public ulong LastTime         = 0;
            public ulong FirstTimeThisSec = 0;
            public uint  NumSkips         = 0;
            public uint  UnitsLastSec     = 0;
            public uint  UnitsThisSec     = 0;
        };

        class PerEventStuff
        {
            public EventTrackingStuff evt = new EventTrackingStuff();

            public string[] Text = null;
            public ushort EventId = 0;

            public ALLOW_TYPE AllowType = ALLOW_TYPE.UNKNOWN;

            public ulong EventInterval = 0;       // Interval between allowed events in 100-nanosecond units
            public uint AlertUnitsPerSec = 0;     // either events/packets or bytes, depending on fRateUnitsAreBytes
            public uint Reserved = 0;
            
            public bool EventFired(out uint numSkips)
            {
                numSkips = 0;
                bool fireIt = true;
                
                if (AllowType == ALLOW_TYPE.ALWAYS_ALLOW)
                {
                    // always let this thru
                    return true;
                }
                    
                if (AllowType == ALLOW_TYPE.NEVER_ALLOW)
                {
                    return false;
                }


                //
                // Handle any rate tracking on second-aligned boundaries; gather an approximation
                // of the current rate when the trigger threshold is crossed in the current second.
                //
                ulong hnsNow = (ulong) DateTime.Now.ToFileTime();
    
                if( AlertUnitsPerSec > 0 )
                {
                    ulong ulNowSecs = hnsNow / HNS_PER_SECOND;
                    ulong ulThenSecs = evt.FirstTimeThisSec / HNS_PER_SECOND;
    
                    if( ulNowSecs != ulThenSecs )
                    {
                        evt.UnitsLastSec = ( ulNowSecs == ulThenSecs + 1 ) ? evt.UnitsThisSec : 0;
                        evt.UnitsThisSec = 0;
                        evt.FirstTimeThisSec = hnsNow;
                    }
                }
    
                evt.UnitsThisSec++;
    
                if( ( evt.UnitsThisSec >= AlertUnitsPerSec ) &&
                    ( ( 0 == evt.LastTime ) ||
                    ( hnsNow >= evt.LastTime + EventInterval ) ) )
                {
    
                    //
                    // We're going to allow this event; indicate how many similar ones have been skipped
                    //
                    numSkips = evt.NumSkips;
                    evt.NumSkips = 0;
    
                    evt.UnitsThisSec = 0;
                    evt.LastTime = hnsNow;
                    fireIt = true;
                }
                else
                {
                    //
                    // Make sure we track recent rate properly by resetting our counter each second when we would
                    // have alerted if it had been long enough since the last alert
                    //
                    if( ( evt.UnitsThisSec >= AlertUnitsPerSec ) &&
                        ( hnsNow >= evt.FirstTimeThisSec + HNS_PER_SECOND ) )
                    {
                        evt.UnitsThisSec = 0;
                    }
    
                    //
                    // We're suppressing this event because the outside world doesn't want to know about this kind
                    // of thing until we reach our configured rate (globally or per-IP) and it has been 'a while'
                    // since the last time we alerted
                    //
                    evt.NumSkips++;
                    fireIt = false;
                }
                
                return( fireIt );
            }
            
        };


        private static Hashtable _eventThrottlesById = new Hashtable();
        private static ArrayList _eventThrottlesByText = new ArrayList();
        private static bool _reloadConfig = true;

        static EventThrottler()
        {
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(EventThrottler.MultiSettingsChanged);
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(EventThrottler.OnControlRequest);
        }


        public static void MultiSettingsChanged(object sender, MultiSettingChangeEventArgs e)
        {
            if(e.MultiSetting != MultiSetting.xmgmt_eventThrottles)
                return;

            LoadEventSettings(e.ValueNew);
        }


        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage(
                            "EventThrottler help:\r\n" +
                            " listevents (le) -- lists all currently throttled events.\r\n" +
                            " addevent (ae) -- adds (or updates) event throttling settings.   settings are \r\n" +
                            "       separated by ';'.   They can be:\r\n" +
                            "       id=<event id> (0 if all events)\r\n" +
                            "       text=<search text>\r\n" +
                            "       freq=<always|sometimes|never>\r\n" +
                            "       intervalsecs=<seconds between events>\r\n" +
                            "       alertrate=<# of events per second>\r\n" +
                            "\r\n" +
                            "  For example, to turn off the event thrown from a missing achievement:\r\n" +
                            "   text=Achievement not found;freq=never\r\n" +
                            "  or to limit it to every 5 seconds:\r\n" +
                            "   text=Achievement not found;intervalsecs=5\r\n" +
                            "  or to allow event id 2 up to twenty times per second:\r\n" +
                            "   id=2;alertrate=20\r\n" +
                            "\r\n" +
                            "  NOTE: Events configured via xmgmt will be overwritten if the\r\n" +
                            "   xmgmt_eventThrottles setting changes!\r\n\r\n",
                            args.RequestId);
                        args.Handled = true;
                        break;

                    case "listevents":
                    case "le":
                        XomControlConnection.SendMessage(ProcessListEvents(args), args.RequestId);
                        args.Handled = true;
                        break;

                    case "addevent":
                    case "ae":
                        XomControlConnection.SendMessage(ProcessAddEvent(args), args.RequestId);
                        args.Handled = true;
                        break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static string ProcessListEvents(ControlRequestEventArgs args)
        {
            if (_eventThrottlesById.Keys.Count == 0 &&
                _eventThrottlesByText.Count == 0)
            {
                return "No events are currently throttled.\r\n";
            }

            StringBuilder bldr = new StringBuilder();

            foreach (object key in _eventThrottlesById.Keys)
            {
                PerEventStuff eventConfig = (PerEventStuff)_eventThrottlesById[key];
                bldr.Append("EventID: " + key.ToString() + "\r\n");
                bldr.Append("  Frequency:     " + eventConfig.AllowType.ToString() + "\r\n");
                bldr.Append("  Interval (hns):" + eventConfig.EventInterval + "\r\n");
                bldr.Append("  Rate:          " + eventConfig.AlertUnitsPerSec + "\r\n");
            }


            foreach (PerEventStuff eventConfig in _eventThrottlesByText)
            {
                bldr.Append("EventText: " + String.Join("*", eventConfig.Text) + "\r\n");
                bldr.Append("  Frequency:     " + eventConfig.AllowType.ToString() + "\r\n");
                bldr.Append("  Interval (hns):" + eventConfig.EventInterval + "\r\n");
                bldr.Append("  Rate:          " + eventConfig.AlertUnitsPerSec + "\r\n");
            }

            return bldr.ToString();
        }

        public static string ProcessAddEvent(ControlRequestEventArgs args)
        {
            PerEventStuff eventConfig;
            string error;

            eventConfig = GetPerEventConfig(args.CommandArgs[0], out error);
            if (error != null)
            {
                return error + "\r\n";
            }
            
            if (eventConfig.Text == null || eventConfig.Text.Length == 0)
            {
                _eventThrottlesById[eventConfig.EventId] = eventConfig;
            }
            else
            {
                _eventThrottlesByText.Add(eventConfig);    
            }
            
            return "OK";
        }

        private static void LoadEventSettings(string[] eventThrottles)
        {
            //
            // Load any pre-configured event settings
            //
            PerEventStuff eventConfig;
            string error;   
            ArrayList eventConfigsByText = new ArrayList();
            Hashtable eventConfigsById = new Hashtable();

            // since we log events in this method, make sure those calls don't recursively call back in
            _reloadConfig = false;

            if (eventThrottles == null)
            {
                eventThrottles = Config.GetMultiSetting(MultiSetting.xmgmt_eventThrottles);
            }

            if (eventThrottles != null && eventThrottles.Length != 0)
            {
                foreach (string throttle in eventThrottles)
                {
                    eventConfig = GetPerEventConfig(throttle, out error);
                    if (error != null)
                    {
                        EventBuilder.LogEvent(XEvent.Id.COMMON_CONFIG_274, error, null);
                        continue;
                    }
                    
                    if (eventConfig.Text == null || eventConfig.Text.Length == 0)
                    {
                        eventConfigsById[eventConfig.EventId] = eventConfig;
                    }
                    else
                    {
                        eventConfigsByText.Add(eventConfig);
                    }
                }
            }
            
            _eventThrottlesById = eventConfigsById;
            _eventThrottlesByText = eventConfigsByText;
        }
        
        private static PerEventStuff GetPerEventConfig(string throttle, out string error)
        {
            string[] settings = throttle.Split(new char[] { ';' });
            
            PerEventStuff evtSettings = new PerEventStuff();
            error = null;
            
            // collapse any ;'s that were preceeded by \
            for (int i = 0; i < settings.Length - 1; i++)
            {
                if (settings[i].EndsWith("\\"))
                {
                    // get rid of the escape character, and concatonate the subsequent ';'
                    settings[i] = settings[i].Substring(0, settings[i].Length-1) + ";" + settings[i+1];
                    settings[i+1] = "";
                }
            }
            
            foreach (string setting in settings)
            {
                if (setting == "")
                    continue;
                
                int eqidx = setting.IndexOf('=');
                if (eqidx == -1)
                {
                    error =  "One of the settings for xmgmt_eventThrottler contains an invalid string '" + throttle + "'";
                    evtSettings = null;
                    break;
                }
                
                string name = setting.Substring(0, eqidx).ToLower().Trim();
                string value = setting.Substring(eqidx + 1);
                
                switch (name)
                {
                case "id":
                    try
                    {
                        evtSettings.EventId = Convert.ToUInt16(value);
                    }
                    catch
                    {
                        error = "One of the settings for xmgmt_eventThrottler contains an invalid value for EventId: '" + throttle + "'";
                        evtSettings = null;
                        goto leave;
                    }    
                    break;
                    
                case "text":
                    evtSettings.Text = value.Split('*');
                    for (int i = 0; i< evtSettings.Text.Length - 1; i++)
                    {
                        if (evtSettings.Text[i] != null && evtSettings.Text[i].EndsWith("\\"))
                        {
                            // get rid of the escape character, and concatonate the subsequent '*'
                            evtSettings.Text[i] = evtSettings.Text[i].Substring(0, evtSettings.Text[i].Length-1) + "*" + evtSettings.Text[i+1];
                            evtSettings.Text[i+1] = null;
                        }
                    }        
                    break;

                case "freq":
                    switch( value.ToLower() )
                    {
                    case "maybe":
                    case "some":
                    case "sometimes":
                        evtSettings.AllowType = ALLOW_TYPE.SOMETIMES_ALLOW;
                        break;

                    case "all":
                    case "always":
                    case "yes":
                        evtSettings.AllowType = ALLOW_TYPE.ALWAYS_ALLOW;
                        break;

                    case "no":
                    case "none":
                    case "never":
                        evtSettings.AllowType = ALLOW_TYPE.NEVER_ALLOW;
                        break;

                    default:
                        error = "One of the settings for xmgmt_eventThrottler contains an invalid freq setting: '" + throttle + "'";
                        goto leave;
                    }
                    break;

                case "alertrate":
                    evtSettings.AlertUnitsPerSec = Convert.ToUInt32( value );
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "intervalsecs":
                    evtSettings.EventInterval = Convert.ToUInt64( value );
                    evtSettings.EventInterval *= HNS_PER_SECOND;
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "intervalhns":
                    evtSettings.EventInterval = Convert.ToUInt64( value );
                    if (evtSettings.AllowType == ALLOW_TYPE.UNKNOWN)
                        evtSettings.AllowType  = ALLOW_TYPE.SOMETIMES_ALLOW;
                    break;

                case "rateunits":
                case "trackperip":
                case "comment":
                    //
                    // Quietly ignore these
                    //
                    break;

                default:
                    error = "Unknown parameter '" + name + " in multisetting configuration '" + throttle + "'";
                    evtSettings = null;
                    goto leave;
                }

            }

            if (evtSettings.EventId == 0 && evtSettings.Text == null)
            {
                error = "multisetting configuration '" + throttle + " is invalid.  Either a non-zero eventid or a text search string must be specified!";
                evtSettings = null;
                goto leave;
            }
            
leave:            
            return evtSettings;
        }        


        //////////////////////////////////////////////////////////////////////////////
        public static bool FireEvent(
            uint eventid,
            out uint uiNumSkips )
        {
            uiNumSkips = 0;
            PerEventStuff eventConfig;


            if (_reloadConfig)
            {
                LoadEventSettings(null);
            }

            eventConfig = (PerEventStuff)_eventThrottlesById[(ushort)eventid];
            if (eventConfig == null)
            {
                // nothing configured for this event id
                return true;
            }
            
            return eventConfig.EventFired(out uiNumSkips);
        }
        
        
                
        
        
        //////////////////////////////////////////////////////////////////////////////
        public static bool FireEvent(
            ushort eventid,
            string eventText,
            out uint uiNumSkips )        // How many have been skipped since last allowed event
        {
            bool fFireIt = true;
            uiNumSkips = 0;


            if (_reloadConfig)
            {
                LoadEventSettings(null);
            }

            foreach (PerEventStuff eventConfig in _eventThrottlesByText)
            {
                if (eventConfig.EventId != 0 && eventConfig.EventId != eventid)
                    continue;
            
                bool match = true;
                
                // see if the text matches
                if (eventConfig.Text != null)
                {
                    int idx = 0;
                    
                    for (int i = 0; i < eventConfig.Text.Length; i++)
                    {
                        idx = eventText.IndexOf(eventConfig.Text[i], idx);
                        if (idx == -1)
                        {
                            match = false;
                            break;
                        }
                    }
                }
                
                if (match == true)
                {
                    return eventConfig.EventFired(out uiNumSkips);
                }    
            }    

            return( fFireIt );
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastFail.cs ===
//------------------------------------------------------------------------------
// FastFail
//
// If you're going to time out anyway, why not do it faster?
//
// When a certain number of failures occur (ThresholdCount) within a certain amount of
// time (ThresholdInterval), then the resource is marked as unavailable for a certain
// amount of time (BlockInterval). Then, a small number of callees are allowed to proceed
// to check the resource again, and if it is found to be ok, the resource moves back to
// the available state. If the resource is found to be bad, then it moves back to the
// unavailable state for BlockInterval seconds again. If nothing happens, another
// BlockInterval will elapse and the resource moves back to the available state
// automatically.
//
// Usage:
//
// Before accessing a resource, call InFastFailState(). If it returns false, continue on.
// If it returns true, do not access the resource.
//
// After accessing the resource, call ReportFailure() if it timed out, or call
// ReportSuccess() if it succeeded. This is somewhat important and tricky to get right.
//
// So besides the constructors, the only functions you need are:
//   InFastFailState()
//   ReportFailure()
//   ReportSuccess()
//
// Walk-through:
//
// Let's say ThresholdCount = 2, ThresholdInterval = 30 seconds, and BlockInterval = 60.
//
// You're chugging along, calling InFastFailState() and getting FALSE back, but all of a
// sudden your database dies, so you end up calling ReportFailure() at least 2 times
// within 30 seconds.
//
// Now future threads call InFastFailState() and get TRUE back for the next 60 seconds.
// Then, the next caller to InFastFailState() will get FALSE back, but subsequent callers
// still get TRUE. This is the Recovery state where we "trickle" people out to the
// resource. If that one released caller calls ReportSuccess(), the resource becomes
// available and the cycle starts over. If ReportFailure() is called, the resource becomes
// unavailable for the next 60 seconds again.
//
// If that one released caller never calls either Report function, then another caller is
// "released" in 60 / 4 seconds (15), then another 15 seconds later, then another 15
// seconds later. After 60 seconds have elapsed in this Recovery state with no Report
// function all, the resource is moved to the available state and the whole cycle starts
// over.
//
// -kgoodier January 2008
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Net;
using System.Runtime.CompilerServices;
using System.Data.SqlClient;

using STF.common.mgmt;
using STF.common.config;

// seemingly unnecessary, but stflive  rewrites
// this class under a different namespace


namespace STF.common.service
{
    // This class implements per-resource fast fail semantics
    public class FastFailInternal
    {
        protected class FastFailTracker
        {
            public int FailureCount;
            public DateTime FirstFailureTime;
            public DateTime LastRecoveryTime;
            public FFState State;

            public FastFailTracker()
            {
                FailureCount = 0;
                FirstFailureTime = DateTime.MinValue;
                LastRecoveryTime = DateTime.MinValue;
                State = FFState.Ok;
            }
        }

        public enum FFState
        {
            Ok,
            Failure,
            Recovery
        };


        public const int c_defaultThresholdCount = 2;
        public const int c_defaultThresholdIntervalSeconds = 30;
        public const int c_defaultBlockIntervalSeconds = 60;
        public const int c_defaultMaxFailureExtensions = 2;
        public const XEvent.Id c_eventIdEnterFailure = XEvent.Id.FAIL_FAST_ENTER;
        public const XEvent.Id c_eventIdExitFailure = XEvent.Id.FAIL_FAST_EXIT;
        public const int c_numAttemptsAtRecovery = 4;

        protected virtual int ThresholdCount
        {
            get { return(m_thresholdCount); }
            set { m_thresholdCount = value; }
        }

        protected virtual int ThresholdIntervalSeconds
        {
            get { return(m_thresholdIntervalSeconds); }
            set { m_thresholdIntervalSeconds = value; }
        }

        protected virtual int BlockIntervalSeconds
        {
            get { return(m_blockIntervalSeconds); }
            set { m_blockIntervalSeconds = value; }
        }

        protected virtual XEvent.Id EventIdEnterFailure
        {
            get { return(m_eventIdEnterFailure); }
            set { m_eventIdEnterFailure = value; }
        }

        protected virtual XEvent.Id EventIdExitFailure
        {
            get { return(m_eventIdExitFailure); }
            set { m_eventIdExitFailure = value; }
        }

        // Private members

        protected int m_thresholdCount;
        protected int m_thresholdIntervalSeconds;
        protected int m_blockIntervalSeconds;
        protected XEvent.Id m_eventIdEnterFailure;
        protected XEvent.Id m_eventIdExitFailure;

        protected Dictionary<string, FastFailTracker> m_FastFailTrackers;

        // ----------------------------------------------------------------------
        // GetFastFailTracker
        //
        // Retrieves object from dictionary, creating it if necessary. To protect the
        // dictionary we're using a synchronous lock. This is faster than a
        // ReaderWriterLock for short-lived locks.
        //
        // TODO: The question remains whether we really need to lock reads, it may be that
        // we can get away with only locking writes.
        // ----------------------------------------------------------------------
        [MethodImpl(MethodImplOptions.Synchronized)]
        protected FastFailTracker GetFastFailTracker(string resourceName)
        {
            FastFailTracker s;
            resourceName = resourceName.ToLower();

            if (!m_FastFailTrackers.TryGetValue(resourceName, out s))
            {
                s = new FastFailTracker();
                m_FastFailTrackers[resourceName] = s;
            }

            return s;
        }


        //
        // PUBLIC STUFF BELOW HERE
        //


        // ----------------------------------------------------------------------
        // FastFailInternal constructor
        //
        // Useful for testing and internal uses. You probably want FastFailHelper for
        // "real" code.
        // ----------------------------------------------------------------------
        public FastFailInternal()
        {
            m_thresholdCount            = c_defaultThresholdCount;
            m_thresholdIntervalSeconds  = c_defaultThresholdIntervalSeconds;
            m_blockIntervalSeconds      = c_defaultBlockIntervalSeconds;
            m_eventIdEnterFailure       = XEvent.Id.FAIL_FAST_ENTER;
            m_eventIdExitFailure        = XEvent.Id.FAIL_FAST_EXIT;
            m_FastFailTrackers          = new Dictionary<string, FastFailTracker>();
        }

        // ----------------------------------------------------------------------
        // FastFailInternal constructor 2
        //
        // Let's you override all the settings with different hard-coded values.
        // ----------------------------------------------------------------------
        internal FastFailInternal(
            int thresholdCount,
            int thresholdIntervalSeconds,
            int blockIntervalSeconds,
            XEvent.Id eventIdEnter,
            XEvent.Id eventIdExit)

            : this()
        {
            m_thresholdCount            = thresholdCount;
            m_thresholdIntervalSeconds  = thresholdIntervalSeconds;
            m_blockIntervalSeconds      = blockIntervalSeconds;
            m_eventIdEnterFailure       = eventIdEnter;
            m_eventIdExitFailure        = eventIdExit;
        }

        // ----------------------------------------------------------------------
        // GetCurrentStatus
        //
        // Returns current state of a resource. Does not change anything. Useful for xmgmt
        // commands, etc.
        //
        // Maybe we could also return the timestamps?
        // ----------------------------------------------------------------------
        public FFState GetCurrentStatus(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);
            return s.State;
        }

        // ----------------------------------------------------------------------
        // InFastFailState
        //
        // Call to check if a resource is in a failure state or not. If the answer is
        // TRUE, you should not try to access the resource in question. If the answer is
        // FALSE, you should access the resource and then call either ReportSuccess or
        // ReportFailure. Do not forget to call one of these!
        // ----------------------------------------------------------------------
        public bool InFastFailState(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            // Mainline case avoids lock
            if (s.State == FFState.Ok)
            {
                return false;
            }

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        return false;
                    }
                case FFState.Recovery:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeInFailureAndRecovery = now.Subtract(s.FirstFailureTime);
                        TimeSpan timeSinceLastRelease = now.Subtract(s.LastRecoveryTime);

                        // If we spend 1 period in Failure and 1 period in Recovery, without
                        // hearing success OR failure, give up and set the resource to Ok.
                        // Maybe the caller forgot to call ReportSuccess.
                        if (timeInFailureAndRecovery.TotalSeconds > BlockIntervalSeconds * 2)
                        {
                            if (EventIdExitFailure != 0)
                            {
                                Xom.NtEvent(EventIdExitFailure, 
                                    "Moving out of fail fast for '{0}' due to time expiration. First failure was at {1}, {2} seconds ago.",
                                    resourceName, s.FirstFailureTime, timeInFailureAndRecovery.TotalSeconds
                                );
                            }

                            s.FirstFailureTime = DateTime.MinValue;
                            s.FailureCount = 0;
                            s.State = FFState.Ok;
                            return false;
                        }

                        // Release 1 thread periodically. The period is not configurable; it
                        // is 1/4 of the BlockIntervalSeconds.

                        if (timeSinceLastRelease.TotalSeconds <= BlockIntervalSeconds / c_numAttemptsAtRecovery)
                        {
                            // too short, still blocked
                            return true;
                        }
                        else
                        {
                            // long enough, release one and reset
                            s.LastRecoveryTime = now;
                            return false;
                        }
                    }
                case FFState.Failure:
                    {
                        // if we are in the fast-fail state, check to see if we should still be in it
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);
                        if (timeSpan.TotalSeconds <= BlockIntervalSeconds)
                        {
                            // we are still failing fast
                            return true;
                        }
                        else
                        {
                            // now we have blocked for the entire interval, so move out of fast fail
                            // and let 1 thread attempt to access the resource.
                            s.State = FFState.Recovery;
                            s.LastRecoveryTime = now;
                            return false;
                        }
                    }
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }
            }
        }

        // ----------------------------------------------------------------------
        // ReportFailure
        //
        // Call this to report a resource failure.  errorMessage should provide extended
        // error information. The text of the exception for the failure is a good
        // suggestion.
        // ----------------------------------------------------------------------
        public void ReportFailure(string resourceName, string errorMessage)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);

                        if (timeSpan.TotalSeconds <= ThresholdIntervalSeconds)
                        {
                            // it hasn't been that long since the last failure, so increment the count

                            s.FailureCount++;
                        }
                        else
                        {
                            // it's been a while since we got a failure, so treat this as the first failure

                            s.FirstFailureTime = now;
                            s.FailureCount = 1;
                        }

                        if (s.FailureCount >= ThresholdCount)
                        {
                            s.State = FFState.Failure;

                            // now the last failure time becomes how we measure the fast fail duration
                            s.FirstFailureTime = now;

                            if (EventIdEnterFailure != 0)
                            {
                                Xom.NtEvent(EventIdEnterFailure, 
                                    "Moving to fast fail for '{0}', after receiving {1} failures, each within {2} seconds of each other.\r\n" + 
                                    "The resource will be fast-failed for {3} seconds (max {4} seconds, pending resource success).\r\n" +
                                    "The extended error message is: \r\n{5}",
                                    resourceName, s.FailureCount, ThresholdIntervalSeconds,
                                    BlockIntervalSeconds, BlockIntervalSeconds * 2,
                                    errorMessage == null ? "n/a" : errorMessage
                                );
                            }
                        }
                    }
                    break;
                case FFState.Recovery:
                    {
                        // Uh oh, take a step back
                        s.State = FFState.Failure;
                        s.FirstFailureTime = DateTime.UtcNow;
                        // leave s.FailureCount alone (above threshold)
                    }
                    break;
                case FFState.Failure:
                    {
                        // already failing, nothing to do
                    }
                    break;
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }

            }
        }

        // ----------------------------------------------------------------------
        // ReportSuccess
        //
        // Call this to report a resource success.
        // ----------------------------------------------------------------------
        public void ReportSuccess(string resourceName)
        {
            FastFailTracker s = GetFastFailTracker(resourceName);

            // Mainline case avoids lock
            if (s.State == FFState.Ok)
            {
                return;
            }

            lock (s)
            {
                switch (s.State)
                {
                case FFState.Ok:
                    {
                        // yay, more successes!
                    }
                    break;
                case FFState.Recovery:
                    {
                        DateTime now = DateTime.UtcNow;
                        TimeSpan timeSpan = now.Subtract(s.FirstFailureTime);
                        if (EventIdExitFailure != 0)
                        {
                            Xom.NtEvent(EventIdExitFailure, 
                                "Moving out of fail fast for '{0}' due to success report.  First failure was at {1}, {2} seconds ago.",
                                resourceName, s.FirstFailureTime, timeSpan.TotalSeconds
                            );
                        }

                        s.FirstFailureTime = DateTime.MinValue;
                        s.FailureCount = 0;
                        s.State = FFState.Ok;
                    }
                    break;
                case FFState.Failure:
                    {
                        // hmm.. shouldn't happen, maybe there were some straggler threads.
                        // we're going to stay in Failure mode. Have to move to Recovery state
                        // first.
                    }
                    break;
                default:
                    throw new Exception("Invalid state " + s.State + " for FastFailTracker.");
                }
            }
        }

    }


    // ------------------------------------------------------------------------------
    // FastFailHelper
    //
    // Extends the FastFailInternal class with handy NPDB setting wrappers. You probably
    // want to use this in "real" server code.
    // ------------------------------------------------------------------------------
    public class FastFailHelper : FastFailInternal
    {
        // Config setting names
        protected string m_thresholdCountSettingName;
        protected string m_thresholdIntervalSecondsSettingName;
        protected string m_blockIntervalSecondsSettingName;

        // This object tracks internal failures reading the config settings
        private FastFailInternal m_fastFailConfig;
        private const string c_configResourceName = "FastFailHelper NPDB";

        protected override int ThresholdCount
        {
            get
            {
                if (null != m_thresholdCountSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_thresholdCount = Config.GetIntSetting(m_thresholdCountSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_thresholdCount);
            }
        }

        protected override int ThresholdIntervalSeconds
        {
            get
            {
                if (null != m_thresholdIntervalSecondsSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_thresholdIntervalSeconds = Config.GetIntSetting(m_thresholdIntervalSecondsSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_thresholdIntervalSeconds);
            }
        }

        protected override int BlockIntervalSeconds
        {
            get
            {
                if (null != m_blockIntervalSecondsSettingName &&
                    !m_fastFailConfig.InFastFailState(c_configResourceName))
                {
                    try
                    {
                        m_blockIntervalSeconds = Config.GetIntSetting(m_blockIntervalSecondsSettingName);
                        m_fastFailConfig.ReportSuccess(c_configResourceName);
                    }
                    catch (Exception e)
                    {
                        m_fastFailConfig.ReportFailure(c_configResourceName, e.ToString());
                    }
                }

                return (m_blockIntervalSeconds);
            }
        }

        //----------------------------------------------------------------------
        // FastFailHelper constructor
        //
        // The setting names may be null, in which case the default values will be used.
        //----------------------------------------------------------------------
        public FastFailHelper(
            string thresholdCountSettingName,
            string thresholdIntervalSecondsSettingName,
            string blockIntervalSecondsSettingName)

            : base()
        {
            m_thresholdCountSettingName = thresholdCountSettingName;
            m_thresholdIntervalSecondsSettingName = thresholdIntervalSecondsSettingName;
            m_blockIntervalSecondsSettingName = blockIntervalSecondsSettingName;

            m_fastFailConfig = new FastFailInternal();
        }

        //----------------------------------------------------------------------
        // FastFailHelper constructor
        //
        // The setting names may be null, in which case the default values will be used.
        // Extra options to allow you to specify unique event ids for the "resource
        // entered fail state" and "resource exited fail state" events.  Highly
        // recommended.
        //----------------------------------------------------------------------
        public FastFailHelper(
            string thresholdCountSettingName,
            string thresholdIntervalSecondsSettingName,
            string blockIntervalSecondsSettingName,
            XEvent.Id eventIdEnterFailure,
            XEvent.Id eventIdExitFailure)

            : this(thresholdCountSettingName,
                   thresholdIntervalSecondsSettingName,
                   blockIntervalSecondsSettingName)

        {
            EventIdEnterFailure = eventIdEnterFailure;
            EventIdExitFailure = eventIdExitFailure;
        }

        // ----------------------------------------------------------------------
        // ConsiderExceptionAsFailure
        //
        // This function takes an Exception and determines if it qualifies as a "FastFail"
        // level of failure. Only certain classes of SqlException, XRLException, and
        // WebException apply. If the exception type is not one of the above, it is
        // optimistically considered a success, since we don't want potentially
        // user-generated exceptions (bad input) being considered for FastFail.
        // ----------------------------------------------------------------------
        public static bool ConsiderExceptionAsTimeout(Exception e)
        {
            if (e is SqlException)
            {
                foreach (SqlError error in (e as SqlException).Errors)
                {
                    if (SQLDefs.ERROR_LOGIN_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_LOGIN_NETWORK_ERROR == error.Number ||
                        SQLDefs.ERROR_NETWORK_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_TIMEOUT == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_CONNECTION_FAILED == error.Number ||
                        SQLDefs.ERROR_SQLCLIENT_CONNECTION_FAILED2 == error.Number ||
                        SQLDefs.ERROR_CANNOT_OPEN_DATABASE == error.Number)
                    {
                        return true;
                    }
                }
            }
            else if (e is XRLException)
            {
                SqlException se = (e as XRLException).InnerException as SqlException;
                if (null != se)
                {
                    return ConsiderExceptionAsTimeout(se);
                }
            }
            else if (e is TimeoutException)
            {
                return true;
            }
            else if (e is WebException)
            {
                WebException we = (WebException) e;
                WebExceptionStatus status = we.Status;

                if (status == WebExceptionStatus.ReceiveFailure ||
                    status == WebExceptionStatus.RequestCanceled ||
                    status == WebExceptionStatus.ServerProtocolViolation ||
                    status == WebExceptionStatus.Timeout ||
                    status == WebExceptionStatus.UnknownError ||
                    status == WebExceptionStatus.ConnectionClosed ||
                    status == WebExceptionStatus.KeepAliveFailure ||
                    status == WebExceptionStatus.PipelineFailure
                   )
                {
                    return true;
                }

                // 504 - Gateway timeout doesn't come back in the
                // WebExceptionStatus so we have to hand check it

                else {
                    HttpWebResponse response = (HttpWebResponse) ((WebException) e).Response;
                    if ((response != null) && (response.StatusCode == HttpStatusCode.GatewayTimeout)) return true;
                }
            }
            return false;
        }

        public static bool ConsiderWebExceptionAsTimeout(WebException e)
        {
            return ConsiderExceptionAsTimeout(e);
        }

        private class SQLDefs
        {
            // These errors are not from SQL Server, they must be from the data access layer, SqlClient.
            public const int ERROR_SQLCLIENT_TIMEOUT = -2;              // "Timeout expired.  The timeout period elapsed prior to completion of the operation or the server is not responding."
            public const int ERROR_SQLCLIENT_CONNECTION_FAILED = 2;     // "An error has occurred while establishing a connection to the server.  When connecting to SQL Server 2005, this failure may be caused by the fact that under the default settings SQL Server does not allow remote connections. (provider: Named Pipes Provider, error: 40 - Could not open a connection to SQL Server)"
            public const int ERROR_SQLCLIENT_CONNECTION_FAILED2 = 53;  // same as above, but this is the error code I see. argh.

            // These errors are from SQL Server (sysmessages)
            public const int ERROR_PARAM_MISSING = 201;
            public const int ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK = 601;
            public const int ERROR_DEADLOCKED_PROCESS_KILLED = 1205;
            public const int ERROR_PRIMARY_KEY_VIOLATION = 2627;
            public const int ERROR_COULD_NOT_FIND_STORED_PROC = 2812;
            public const int ERROR_TOO_MANY_PARAM = 8144;
            public const int ERROR_INVALID_PARAM_NAME = 8145;
            public const int ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES = 8143;
            public const int ERROR_DATA_TRUNCATED = 8152;
            public const int ERROR_LOGIN_TIMEOUT = 17197;
            public const int ERROR_LOGIN_NETWORK_ERROR = 17829;
            public const int ERROR_NETWORK_TIMEOUT = 17830;
            public const int ERROR_CANNOT_OPEN_DATABASE = 4060;
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ExtensionMethods.cs ===
// 
// ExtensionMethods.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Miscellaneous handy extension methods with no where else to live.
// Xbox Online Service
//

using System;

namespace STF.common.utilities2
{

public static class ExtensionMethods
{
    public static string ReplaceControlCharacters(this String str, char replacementChar)
    {
        // Optimized for the "no control character" case

        if (String.IsNullOrEmpty(str))
        {
            return str;
        }

        char[] chars = null;
        for (int i = 0; i < str.Length; i++)
        {
            if (char.IsControl(str[i]))
            {
                if (chars == null)
                {
                    // This is somewhat expensive, avoid until necessary
                    chars = str.ToCharArray();
                }
                chars[i] = replacementChar;
            }
        }
        if (chars != null)
            return new string(chars);
        else
            return str;

    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastFailCounters.cs ===
/* FastFail using the thread throttling approach - Performance Counter Support
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * Performance counters will act as the basis for relaying run-time information
 * to external monitoring system (MOM more than likely).
 *
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 *
 * USAGE OVERVIEW:
 * The FastFailResourceCategory class needs to be extended in order to get
 * performance counting working for the new resource.  The extended class must
 * do the following:
 *
 *  1. decorated with XomPerformanceCounterCategoryAttr attribute.
 *  2. create public static field of its own type (Counters is a good name,
 *     but it can be named anything).
 *  3. your default constructor must pass the name of the resource to the
 *     base constructor.
 *
 * Refer to FastFailSafeNpdbPerformanceCategory, it only does the 3 things
 * listed above.
 *
 * As convention the category name should be FastFail_[resourceName]
 *
 * current owner: jojohn
 */

namespace STF.common.service {
   using System;
   using System.Collections.Generic;
   using System.Diagnostics;

   using STF.common.mgmt;

    [XomPerformanceCounterCategoryAttr( "FastFail: SafeNPDB", "FastFail safe npdb resource", true )]
   public class FastFailSafeNpdbPerformanceCategory : FastFailPerformanceCategory {
      public FastFailSafeNpdbPerformanceCategory()
         : base("SafeNPDB") { }

      public static FastFailSafeNpdbPerformanceCategory Counters = new FastFailSafeNpdbPerformanceCategory();
   }

   public class FastFailPerformanceCategory : XomPerformanceCounterCategory {
      public static FastFailPerformanceCategory GetPerformanceCategory(string resourceName) {
         if (null == resourceName)
            throw new ArgumentNullException("resourceName");
         
         resourceName = resourceName.ToLower();

         if (resourceCategoryLookup.ContainsKey(resourceName))
            return resourceCategoryLookup[resourceName];

         Xom.NtEvent(XEvent.Id.FAST_FAIL_MISSING_COUNTERS,
            "FastFail - " + resourceName + " - " +
            "failed to locate performance counter category."
         );

         return null;
      }

      public FastFailPerformanceCategory(string resourceName) {
         if (null == resourceName)
            throw new ArgumentNullException("resourceName");

         this.resourceName = resourceName.ToLower();
         resourceCategoryLookup[this.resourceName] = this;
      }

      public FastFailPerformanceCategory this[string component] {
         get {
            if (null == component)
               throw new ArgumentNullException("component");

            return (FastFailPerformanceCategory)GetInstance(component);
         }
      }

      public string ResourceName {
         get { return resourceName; }
      }

      [XomPerformanceCounterAttr(
         "Threads, Threshold",
         "Thread threshold on threads for this resource",
         PerformanceCounterType.NumberOfItems32)]
      public PerformanceCounter ThreadThreshold;

      [XomPerformanceCounterAttr(
         "Threads, Percent Utilization",
         "Percentage of threads used for resource",
         PerformanceCounterType.RawFraction)]
      public PerformanceCounter ThreadUtilization;

      [XomPerformanceCounterAttr(
         "Threads, Percent Utilization Base",
         "Percentage of threads used for resource base",
         PerformanceCounterType.RawBase)]
      public PerformanceCounter ThreadUtilizationBase;

      [XomPerformanceCounterAttr(
         "Denial, Per Second",
         "Number of fast fail denied access to this resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter DenialRate;

      [XomPerformanceCounterAttr(
         "Denial, Total",
         "Totoal number of fast fail denied access to this resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter DenialCount;

      [XomPerformanceCounterAttr(
         "Failure, Per Second",
         "Number of fast fail denied access to this resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter FailureRate;

      [XomPerformanceCounterAttr(
         "Failure, Total",
         "Total number of fast fail denied access to this resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter FailureCount;

      [XomPerformanceCounterAttr(
         "Timeout, Per Second",
         "Number of timeouts occurring while accessing resources per second",
         PerformanceCounterType.RateOfCountsPerSecond32)]
      public PerformanceCounter TimeoutRate;

      [XomPerformanceCounterAttr(
         "Timeout, Total",
         "Total number of timeouts occurring while accessing the resource",
         PerformanceCounterType.NumberOfItems64)]
      public PerformanceCounter TimeoutCount;

      [XomPerformanceCounterAttr(
         "Request, Avr. Response Time",
         "Average request execution time for resource in (ms)",
         PerformanceCounterType.AverageTimer32)]
      public PerformanceCounter AverageResponse;

      [XomPerformanceCounterAttr(
         "Request, Avr. Response Time Base",
         "Base for the average request execution time for resource",
         PerformanceCounterType.AverageBase)]
      public PerformanceCounter AverageResponseBase;


      private string resourceName;
      private static Dictionary<string, FastFailPerformanceCategory> resourceCategoryLookup = new Dictionary<string, FastFailPerformanceCategory>();
   }

   #region FastFailResourceTracker Performance Counter Methods
   public partial class FastFailResource {
      private void AdjustEventCounters(DateTime start, DateTime end, FastFailResult result) {
         if (null != globalPerformance) {
            TimeSpan Span = end - start;

            globalPerformance.AverageResponse.IncrementBy(Span.Ticks);
            globalPerformance.AverageResponseBase.Increment();

            instancedPerformance.AverageResponse.IncrementBy(Span.Ticks);
            instancedPerformance.AverageResponseBase.Increment();

            switch (result) {
               case FastFailResult.Timeout:
                  globalPerformance.TimeoutRate.Increment();
                  globalPerformance.TimeoutCount.Increment();

                  instancedPerformance.TimeoutRate.Increment();
                  instancedPerformance.TimeoutCount.Increment();
                  break;
               case FastFailResult.Failure:
                  globalPerformance.FailureRate.Increment();
                  globalPerformance.FailureCount.Increment();

                  instancedPerformance.FailureRate.Increment();
                  instancedPerformance.FailureCount.Increment();
                  break;
            }
         }
      }

      private void IncrementDenialCounter() {
         if (null != globalPerformance) {
            globalPerformance.DenialRate.Increment();
            globalPerformance.DenialCount.Increment();

            instancedPerformance.DenialRate.Increment();
            instancedPerformance.DenialCount.Increment();
         }
      }

      private void IncrementThreadCounter() {
         if (null != globalPerformance) {
            globalPerformance.ThreadUtilization.Increment();

            instancedPerformance.ThreadUtilization.Increment();
         }
      }

      private void DecrementThreadCounter() {
         if (null != globalPerformance) {
            globalPerformance.ThreadUtilization.Decrement();

            instancedPerformance.ThreadUtilization.Decrement();
         }
      }

      private void ChangeUtilizationDenominator(uint denominator) {
         if (null != instancedPerformance) {
            instancedPerformance.ThreadThreshold.RawValue = denominator;

            instancedPerformance.ThreadUtilizationBase.RawValue = denominator;
         }
      }
   }
   #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\FastFailStatistics.cs ===
/* FastFail using the thread throttling approach - Performance Counter Support
 * ----------------------------------------------------------------------------
 * BRIEF OVERVIEW:
 * Statistics act as the basis for driving the throttling functions.
 * The values exposed represent the captured values across a sliding window of
 * time.
 * 
 * FULL OVERVIEW:
 * see: http://xblwiki/default.aspx/XboxLive/FastFailThreadsPerResource.html
 * 
 * current owner: jojohn
 */

namespace STF.common.service {
   using System;
    using System.Collections.Generic;
    using System.Text;

    using STF.common.config;

   public enum FastFailResult : uint {
      Success = 0,
      Timeout = 1,
      Failure = 2
   }

   public class FastFailClock {
      public static FastFailClock Clock = new FastFailClock();

      public virtual DateTime Now {
         get { return DateTime.UtcNow; }
      }
   }

   public class FastFailFeature {
      public const uint DefaultBucketCount = 8;

      public static uint BucketCount {
         get {
            if (!_bucketCount.HasValue) {
               try { 
                  _bucketCount = Config.GetUIntSetting(Setting.fastfail_bucketCount);

                  if (_bucketCount < 1) {
                     _bucketCount = DefaultBucketCount;

                     throw new ArgumentException(
                        "npdb bucket count setting must be at least 1",
                        Setting.fastfail_bucketCount);
                  }
               }
               catch (ApplicationException) {
                  //Setting missing
                  _bucketCount = DefaultBucketCount;
               }
               catch (Exception) {
                  _bucketCount = DefaultBucketCount;
                  throw;
               }
            }

            return _bucketCount.Value;
         }
         set {
            if (value == 0)
               throw new ArgumentException("bucket size must be larger than 0.");

            _bucketCount = value;
         }
      }

      private struct Event {
         public Event(DateTime startTime, DateTime endTime) {
            if (startTime > endTime)
               throw new ArgumentException("startTime is greater than endTime");

            this.StartTime = startTime;
            this.Duration = endTime - startTime;
         }

         public DateTime StartTime;
         public TimeSpan Duration;
      }

      private struct Accumulator {
         public void AddEvent(Event newEvent) {
            if (0 == this.Count)
               this.FirstEvent = newEvent;

            this.LastEvent = newEvent;
            this.Count++;
            this.AccumulatedDuration += newEvent.Duration;
         }

         public bool SubtractBucket(Bucket bucket) {
            this.Count -= bucket.Count;
            this.AccumulatedDuration -= bucket.AccumulatedDuration;

            return bucket.Count > 0;
         }

         public Event FirstEvent;
         public Event LastEvent;
         public uint Count;
         public TimeSpan AccumulatedDuration;
      }

      private struct Bucket {
         public void AddEvent(Event newEvent) {
            if (0 == this.Count)
               this.FirstEvent = newEvent;

            this.LastEvent = newEvent;
            this.Count++;
            this.AccumulatedDuration += newEvent.Duration;
         }

         public void Clear() {
            Count = 0;
            AccumulatedDuration = TimeSpan.Zero;
         }

         public Event FirstEvent;
         public Event LastEvent;
         public uint Count;
         public TimeSpan AccumulatedDuration;
      }

      public FastFailFeature(uint bucketCount) {
         accumulator = new Accumulator();
         trackingVector = new Bucket[bucketCount];
         activeTracker = 0;
         oldestTracker = 0;
         youngestTracker = 0;
      }

      public FastFailFeature() 
         : this (BucketCount) { }

      #region Exposed Methods
      public void IngestEvent(DateTime start, DateTime end) {
         trackingVector[activeTracker].AddEvent(new Event(start, end));
         accumulator.AddEvent(new Event(start, end));
         youngestTracker = activeTracker;
      }

      public bool ExpireBucket() {
         uint CurrentTracker = activeTracker;
         bool Result = false;

         activeTracker = NextTracker(activeTracker);

         if (accumulator.SubtractBucket(trackingVector[activeTracker])) {
            trackingVector[activeTracker].Clear();
            oldestTracker = NextTracker(oldestTracker);
            Result = true;
         }

         accumulator.FirstEvent = trackingVector[oldestTracker].FirstEvent;
         accumulator.LastEvent = trackingVector[youngestTracker].LastEvent;

         return Result;
      }

      public override string ToString() {
         StringBuilder Result = new StringBuilder();

         Result.AppendLine("Count = " + Count.ToString());
         Result.AppendLine("AccumulatedDuration = " + AccumulatedDuration.ToString());
         Result.AppendLine("AverageDuration = " + AverageDuration.ToString());
         Result.AppendLine("Rate = " + Rate.ToString());
         Result.AppendLine("LowBiasedRate = " + LowBiasedRate.ToString());
         Result.AppendLine("HighBiasedRate = " + HighBiasedRate.ToString());

         return Result.ToString();
      }
      #endregion

      #region Private Helper Methods
      private uint NextTracker(uint current) {
         return (current + 1) % Buckets;
      }
      #endregion

      #region Properties
      public KeyValuePair<DateTime, TimeSpan> FirstEvent {
         get { return new KeyValuePair<DateTime, TimeSpan>(accumulator.FirstEvent.StartTime, accumulator.FirstEvent.Duration); }
      }

      public KeyValuePair<DateTime, TimeSpan> LastEvent {
         get { return new KeyValuePair<DateTime, TimeSpan>(accumulator.LastEvent.StartTime, accumulator.LastEvent.Duration); }
      }

      public float AccumulatedDuration {
         get { return (float)accumulator.AccumulatedDuration.TotalSeconds; }
      }

      public float Count {
         get { return accumulator.Count; }
      }

      public uint Buckets {
         get { return (uint)trackingVector.Length; }
      }

      public float AverageDuration {
         get { return Count != 0 ? AccumulatedDuration / Count : 0; }
      }

      public float Rate {
         get { return Count != 0 ? Count / AccumulatedDuration : 0; }
      }

      public float LowBiasedRate {
         get { return Count != 0 ? Count / (float)(FastFailClock.Clock.Now - FirstEvent.Key).TotalSeconds : 0; }
      }

      public float HighBiasedRate {
         get { return Count != 0 ? Count / (float)(LastEvent.Key - FirstEvent.Key + LastEvent.Value).TotalSeconds : 0; }
      }
      #endregion

      private static uint? _bucketCount = null;
      private Accumulator accumulator;
      private Bucket[] trackingVector;
      private uint activeTracker;
      private uint oldestTracker;
      private uint youngestTracker;
   }

   public class FastFailFeatureAggregation {
      public FastFailFeatureAggregation() {
         bucketCount       = FastFailFeature.BucketCount;
         allRequests       = new FastFailFeature(bucketCount);
         successfulResults = new FastFailFeature(bucketCount);
         failedRequests    = new FastFailFeature(bucketCount);
         timedoutRequests  = new FastFailFeature(bucketCount);
         ingestionLock     = new object();
      }

      public void IngestEvent(DateTime start, DateTime end, FastFailResult result) {
         lock (ingestionLock) {
            allRequests.IngestEvent(start, end);

            switch (result) {
               case FastFailResult.Timeout:
                  timedoutRequests.IngestEvent(start, end);
                  break;
               case FastFailResult.Failure:
                  failedRequests.IngestEvent(start, end);
                  break;
               default:
                  successfulResults.IngestEvent(start, end);
                  break;
            }
         }
      }

      // Caller responsible for locking this (FastFailStatistics does this)
      public bool ExpireBuckets() {
         return
            allRequests.ExpireBucket() |
            successfulResults.ExpireBucket() |
            failedRequests.ExpireBucket() |
            timedoutRequests.ExpireBucket();
      }

      #region Properties
      public FastFailFeature AllRequests {
         get { return allRequests; }
      }

      public FastFailFeature SuccessfulRequests {
         get { return successfulResults; }
      }

      public FastFailFeature FailedRequests {
         get { return failedRequests; }
      }

      public FastFailFeature TimedoutRequests {
         get { return timedoutRequests; }
      }

      public uint BucketCount {
         get { return bucketCount; }
      }

      public float SuccessRatio {
         get { return allRequests.Count > 0 ? successfulResults.Count / allRequests.Count : 1.0f; }
      }

      public float FailureRatio {
         get { return allRequests.Count > 0 ? failedRequests.Count / allRequests.Count : 0.0f; }
      }

      public float TimeoutRatio {
         get { return allRequests.Count > 0 ? timedoutRequests.Count / allRequests.Count : 0.0f; }
      }
      #endregion

      private FastFailFeature allRequests;
      private FastFailFeature successfulResults;
      private FastFailFeature failedRequests;
      private FastFailFeature timedoutRequests;
      private uint bucketCount;
      private object ingestionLock;
   }

   public class FastFailStatistics {
      public FastFailStatistics(FastFailResourceConfig configuration) {
         if (null == configuration)
            throw new ArgumentNullException("configuration");

         if (configuration.CaptureTimeWindow.TotalSeconds < 1)
            throw new ArgumentException("capture window must be at least 1 second", "configuration.CaptureTimeWindow");

         this.captureTimeWindow = configuration.CaptureTimeWindow;
         this.captureExpirationMark = null;
         this.aggregatedFeatures = new FastFailFeatureAggregation();
         this.ingestionLock = new object();
      }

      public bool AdvanceWindow() {
         DateTime CurrentTick = FastFailClock.Clock.Now;
         bool StatisticsChange = false;

         if (CaptureExpirationMark <= CurrentTick) {
            TimeSpan Delta;
            uint Count;

            Delta = CurrentTick - CaptureExpirationMark;
            Count = (uint)(Delta.TotalSeconds / ExpirationPeriod.TotalSeconds) + 1;
            CaptureExpirationMark += TimeSpan.FromSeconds(ExpirationPeriod.TotalSeconds * Count);

            for (int c = 0; c < Math.Min(aggregatedFeatures.BucketCount, Count); c++)
               StatisticsChange |= aggregatedFeatures.ExpireBuckets();
         }

         return StatisticsChange;
      }

      #region Properties
      private DateTime CaptureExpirationMark {
         get {
            if (!captureExpirationMark.HasValue)
               captureExpirationMark = FastFailClock.Clock.Now + ExpirationPeriod;

            return captureExpirationMark.Value;
         }
         set { captureExpirationMark = value; }
      }

      public TimeSpan ExpirationPeriod {
         get { return TimeSpan.FromSeconds(captureTimeWindow.TotalSeconds / aggregatedFeatures.BucketCount); }
      }

      public FastFailFeatureAggregation AggregatedFeatures {
         get { return aggregatedFeatures; }
      }

      public TimeSpan CaptureTimeWindow {
         get { return captureTimeWindow; }
         set {
            if (value.TotalSeconds < 1)
               throw new ArgumentException("capture window must be at least 1 second", "value");

            captureTimeWindow = value;
            captureExpirationMark = null;
         }
      }

      public object IngestionLock {
         get { return ingestionLock; }
      }
      #endregion

      private TimeSpan captureTimeWindow;
      private DateTime? captureExpirationMark;
      private FastFailFeatureAggregation aggregatedFeatures;
      private object ingestionLock;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\VSFixTraces\ConfigItemClasses.cs ===
// This is a generated file. Please don't modify directly.
//
// This file defines a number of classes which provide a symbolic way to reference instances of configuration
// items (e.g. Interfaces, Settings, etc.). 
//
// It is generated from the private\common\config\configItems.xml file. Please update that file and this
// code will get updated automatically by the build.
//

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace STF.common.config 
{

  

    public class ReportMessageComponentInfo
    {
        public string VirtualInterface;
        public int ComponentID;

        public ReportMessageComponentInfo( int compID, string virtInterface )
        {
            ComponentID = compID;
            VirtualInterface = virtInterface;
        }
    }

    // Components
    [ComVisible(false)]
    public class Component 
    {
  
        public const string aamodule = "aamodule";
        public const string acceleration = "acceleration";
        public const string ALL = "ALL";
        public const string audit = "audit";
        public const string auditdb = "auditdb";
        public const string authsg = "authsg";
        public const string avatardb = "avatardb";
        public const string catalog = "catalog";
        public const string cleanser = "cleanser";
        public const string compplugins = "compplugins";
        public const string ContentIngestionCatalogDB = "ContentIngestionCatalogDB";
        public const string cron = "cron";
        public const string cronlib = "cronlib";
        public const string download = "download";
        public const string eventsdb = "eventsdb";
        public const string eventservice = "eventservice";
        public const string eventsink = "eventsink";
        public const string eventsysdb = "eventsysdb";
        public const string fastEspMarketplaceSearch = "fastEspMarketplaceSearch";
        public const string fbserver = "fbserver";
        public const string fecatalogdbsearch = "fecatalogdbsearch";
        public const string fecatalogdbxbox = "fecatalogdbxbox";
        public const string fecatalogdbzune = "fecatalogdbzune";
        public const string filterdb = "filterdb";
        public const string finbus = "finbus";
        public const string genealogy = "genealogy";
        public const string kdcsvc = "kdcsvc";
        public const string lbsvr = "lbsvr";
        public const string leet_leetwebcommunity_db = "leet_leetwebcommunity_db";
        public const string Lists = "Lists";
        public const string livecache = "livecache";
        public const string LiveConnectDb = "LiveConnectDb";
        public const string liveinfo = "liveinfo";
        public const string livepxy = "livepxy";
        public const string lspfd = "lspfd";
        public const string marketplacecatalog = "marketplacecatalog";
        public const string messagingfd = "messagingfd";
        public const string mixbetamanagement = "mixbetamanagement";
        public const string mixmatch = "mixmatch";
        public const string mixoffermanagement = "mixoffermanagement";
        public const string mixproductmanagement = "mixproductmanagement";
        public const string mixsettingsmanagement = "mixsettingsmanagement";
        public const string mixstats = "mixstats";
        public const string mixstorage = "mixstorage";
        public const string mixsubscriptionfamily = "mixsubscriptionfamily";
        public const string mixtitlemanagement = "mixtitlemanagement";
        public const string mixtokenmanagement = "mixtokenmanagement";
        public const string msgdb = "msgdb";
        public const string NotificationCache = "NotificationCache";
        public const string npdb = "npdb";
        public const string PresenceCache = "PresenceCache";
        public const string ProfileCache = "ProfileCache";
        public const string profileshimfd = "profileshimfd";
        public const string progressshimfd = "progressshimfd";
        public const string provisioning = "provisioning";
        public const string querydb = "querydb";
        public const string querylib = "querylib";
        public const string ratings = "ratings";
        public const string rawcatalogdb = "rawcatalogdb";
        public const string reportarchivedb = "reportarchivedb";
        public const string reportingdb = "reportingdb";
        public const string reportrealtimedb = "reportrealtimedb";
        public const string reportssisdb = "reportssisdb";
        public const string rosetta = "rosetta";
        public const string rufus = "rufus";
        public const string secdb = "secdb";
        public const string secpdb = "secpdb";
        public const string serialdb = "serialdb";
        public const string sgsvc = "sgsvc";
        public const string SocialCache = "SocialCache";
        public const string sqlns = "sqlns";
        public const string stfd = "stfd";
        public const string storedb = "storedb";
        public const string stringsvr = "stringsvr";
        public const string sts = "sts";
        public const string svctunnel = "svctunnel";
        public const string testfd = "testfd";
        public const string testfdxstsmvc = "testfdxstsmvc";
        public const string testfdxstssoap = "testfdxstssoap";
        public const string testfdxstswcf = "testfdxstswcf";
        public const string testrefl = "testrefl";
        public const string titledb = "titledb";
        public const string tokendb = "tokendb";
        public const string toolsdb = "toolsdb";
        public const string toolsmgmtsrv = "toolsmgmtsrv";
        public const string tteamdb = "tteamdb";
        public const string tuserdb = "tuserdb";
        public const string udpadpt = "udpadpt";
        public const string unknown = "unknown";
        public const string uodb = "uodb";
        public const string usercommercedb = "usercommercedb";
        public const string vortexfd = "vortexfd";
        public const string vortexinh = "vortexinh";
        public const string wcalerts = "wcalerts";
        public const string wcDebugTest = "wcDebugTest";
        public const string wcgeneral = "wcgeneral";
        public const string wcmessaging = "wcmessaging";
        public const string wcmusic = "wcmusic";
        public const string wcpresence = "wcpresence";
        public const string wcProfile = "wcProfile";
        public const string wcquery = "wcquery";
        public const string wcsignature = "wcsignature";
        public const string wcstats = "wcstats";
        public const string wcstorage = "wcstorage";
        public const string wcteams = "wcteams";
        public const string wctoolsmgmt = "wctoolsmgmt";
        public const string wcusers = "wcusers";
        public const string webdb = "webdb";
        public const string websg = "websg";
        public const string xarb = "xarb";
        public const string xarbInh = "xarbInh";
        public const string xbanc = "xbanc";
        public const string xbl4xboxcom = "xbl4xboxcom";
        public const string xblmetadb = "xblmetadb";
        public const string xbltools = "xbltools";
        public const string xbos = "xbos";
        public const string xboxcom_forums_db = "xboxcom_forums_db";
        public const string xcache = "xcache";
        public const string xcbk = "xcbk";
        public const string XConnSrv = "XConnSrv";
        public const string xcrypto = "xcrypto";
        public const string xds = "xds";
        public const string xevents = "xevents";
        public const string xlfsmon = "xlfsmon";
        public const string xmachine = "xmachine";
        public const string xmatch = "xmatch";
        public const string xmatchfd = "xmatchfd";
        public const string xmgmtsrv = "xmgmtsrv";
        public const string XNotiCache = "XNotiCache";
        public const string xpnfd = "xpnfd";
        public const string xqry = "xqry";
        public const string xrlscan = "xrlscan";
        public const string xsig = "xsig";
        public const string xstatsfd = "xstatsfd";
        public const string xsts = "xsts";
        public const string xsuppapi = "xsuppapi";
        public const string xtou = "xtou";
        public const string xuacs = "xuacs";
        public const string xuser = "xuser";
        
        // Two arrays used by the config library to initialize the mapping table between component names
        // and ReportMessage IDs (used by the cleanser service/LogTarget). Add a reportMessageId="[numeric id]" 
        // attribute to a component element in the configItems.xml file to have that component added to this list.
        
        public static string[] ReportMessageComponents = new string[]
        {
  
               "kdcsvc",
               "messagingfd",
               "profileshimfd",
               "progressshimfd",
               "ratings",
               "sgsvc",
               "stringsvr",
               "sts",
               "vortexfd",
               "xbos",
               "xcbk",
               "xmatchfd",
               "xpnfd",
               "xsig",
               "xstatsfd",
               "xuacs",        
        };

        public static ReportMessageComponentInfo[] ReportMessageComponentInfoList = new ReportMessageComponentInfo[]
        {
            
            new ReportMessageComponentInfo(30,"cleanservx"),
            
            new ReportMessageComponentInfo(18,"cleanseriis"),
            
            new ReportMessageComponentInfo(34,"cleanseriis"),
            
            new ReportMessageComponentInfo(35,"cleanseriis"),
            
            new ReportMessageComponentInfo(28,"cleanseriis"),
            
            new ReportMessageComponentInfo(23,"cleanservx"),
            
            new ReportMessageComponentInfo(8,"cleanseriis"),
            
            new ReportMessageComponentInfo(29,"cleanseriis"),
            
            new ReportMessageComponentInfo(32,"cleanservx"),
            
            new ReportMessageComponentInfo(6,"cleanseriis"),
            
            new ReportMessageComponentInfo(5,"cleanseriis"),
            
            new ReportMessageComponentInfo(26,"cleanseriis"),
            
            new ReportMessageComponentInfo(27,"cleanseriis"),
            
            new ReportMessageComponentInfo(13,"cleanseriis"),
            
            new ReportMessageComponentInfo(9,"cleanseriis"),
            
            new ReportMessageComponentInfo(7,"cleanseriis"),
                    
        };
    }

    // Mapping of component name to a friendlier name, if provided.
    [ComVisible(false)]
    public static class FriendlyComponent
    {
        public static string Get(string component)
        {
            string s;
            if (!_Mapping.TryGetValue(component, out s))
            {
                return component;
            }
            return s;
        }

        static FriendlyComponent()
        {
            _Mapping = new Dictionary<string, string>();
            
            _Mapping[Component.aamodule] = @"ActiveAuth Module";
            _Mapping[Component.acceleration] = @"Acceleration Svc";
            _Mapping[Component.authsg] = @"ActiveAuth Gateway FD";
            _Mapping[Component.catalog] = @"Catalog FD";
            _Mapping[Component.cleanser] = @"Cleanser Svc";
            _Mapping[Component.cron] = @"Cron FD";
            _Mapping[Component.eventservice] = @"EventService";
            _Mapping[Component.fastEspMarketplaceSearch] = @"Fast ESP Document Search";
            _Mapping[Component.fbserver] = @"Feedback FD";
            _Mapping[Component.finbus] = @"FinBus Publisher Svc";
            _Mapping[Component.kdcsvc] = @"KDC Svc";
            _Mapping[Component.lbsvr] = @"Leaderboard Svc";
            _Mapping[Component.Lists] = @"Lists FD";
            _Mapping[Component.livecache] = @"Livecache FD";
            _Mapping[Component.liveinfo] = @"LiveInfo FD";
            _Mapping[Component.livepxy] = @"WebCache: LiveProxy";
            _Mapping[Component.lspfd] = @"LSP FD";
            _Mapping[Component.marketplacecatalog] = @"Marketplace Catalog FD";
            _Mapping[Component.messagingfd] = @"Messaging FD";
            _Mapping[Component.mixbetamanagement] = @"Mix Beta Management";
            _Mapping[Component.mixmatch] = @"Mix Match";
            _Mapping[Component.mixoffermanagement] = @"Mix Offer Ingestion";
            _Mapping[Component.mixproductmanagement] = @"Mix Content Ingestion";
            _Mapping[Component.mixsettingsmanagement] = @"Mix Settings Management";
            _Mapping[Component.mixstats] = @"Mix Stats";
            _Mapping[Component.mixstorage] = @"Mix Storage";
            _Mapping[Component.mixsubscriptionfamily] = @"Mix Subscription Family";
            _Mapping[Component.mixtitlemanagement] = @"Mix Title Management";
            _Mapping[Component.mixtokenmanagement] = @"Mix Token Management";
            _Mapping[Component.NotificationCache] = @"Notification Cache Svc";
            _Mapping[Component.PresenceCache] = @"Presence Cache Svc";
            _Mapping[Component.ProfileCache] = @"Profile Cache Svc";
            _Mapping[Component.profileshimfd] = @"Profile Shim FD";
            _Mapping[Component.progressshimfd] = @"Progress Shim FD";
            _Mapping[Component.ratings] = @"Ratings FD";
            _Mapping[Component.sgsvc] = @"Security Gateway Svc";
            _Mapping[Component.SocialCache] = @"Social Cache Server";
            _Mapping[Component.stfd] = @"Storage FD";
            _Mapping[Component.stringsvr] = @"String FD";
            _Mapping[Component.sts] = @"STS FD";
            _Mapping[Component.svctunnel] = @"Svc Tunnel";
            _Mapping[Component.testfd] = @"Test FD";
            _Mapping[Component.testfdxstsmvc] = @"TestFD XSTS MVC";
            _Mapping[Component.testfdxstssoap] = @"TestFD XSTS SOAP";
            _Mapping[Component.testfdxstswcf] = @"TestFD XSTS WCF";
            _Mapping[Component.testrefl] = @"Test Reflector FD";
            _Mapping[Component.toolsmgmtsrv] = @"Toolsmgmt Service";
            _Mapping[Component.udpadpt] = @"UDP Adapter Svc";
            _Mapping[Component.vortexfd] = @"Vortex FD";
            _Mapping[Component.vortexinh] = @"Vortex INH";
            _Mapping[Component.wcalerts] = @"WebCache: Alerts";
            _Mapping[Component.wcDebugTest] = @"WebCache: Test";
            _Mapping[Component.wcgeneral] = @"WebCache: GeneralInfo";
            _Mapping[Component.wcmessaging] = @"WebCache: Messaging";
            _Mapping[Component.wcmusic] = @"WebCache: Music";
            _Mapping[Component.wcpresence] = @"WebCache: Presence";
            _Mapping[Component.wcProfile] = @"WebCache: Profile";
            _Mapping[Component.wcquery] = @"WebCache: Query";
            _Mapping[Component.wcsignature] = @"WebCache: Signature";
            _Mapping[Component.wcstats] = @"WebCache: Stats";
            _Mapping[Component.wcstorage] = @"WebCache: Storage";
            _Mapping[Component.wcteams] = @"WebCache: Teams";
            _Mapping[Component.wctoolsmgmt] = @"WebCache: Toolsmgmt";
            _Mapping[Component.wcusers] = @"WebCache: UserAccount";
            _Mapping[Component.websg] = @"WebSG Svc";
            _Mapping[Component.xarb] = @"Arbitration FD";
            _Mapping[Component.xarbInh] = @"Arbitration Svc";
            _Mapping[Component.xbanc] = @"XBanc Svc";
            _Mapping[Component.xbos] = @"Billing FD";
            _Mapping[Component.xcache] = @"XCache Svc";
            _Mapping[Component.xcbk] = @"Callback FD";
            _Mapping[Component.XConnSrv] = @"Connection Svc";
            _Mapping[Component.xcrypto] = @"XCrypto FD";
            _Mapping[Component.xds] = @"Diagnostics Svc";
            _Mapping[Component.xlfsmon] = @"XLFS Monitor";
            _Mapping[Component.xmachine] = @"XMachine FD";
            _Mapping[Component.xmatchfd] = @"Match FD";
            _Mapping[Component.xmgmtsrv] = @"XMgmt Svc";
            _Mapping[Component.xpnfd] = @"Presence FD";
            _Mapping[Component.xqry] = @"Query FD";
            _Mapping[Component.xsig] = @"Signature FD";
            _Mapping[Component.xstatsfd] = @"Stats FD";
            _Mapping[Component.xsts] = @"XSts FD";
            _Mapping[Component.xsuppapi] = @"Cust Support FD";
            _Mapping[Component.xtou] = @"Terms Of Use FD";
            _Mapping[Component.xuacs] = @"UserAccount FD";
            _Mapping[Component.xuser] = @"XUser FD"; 
        }

        private static Dictionary<string, string> _Mapping;
    }
    
    
    // Interfaces
    [ComVisible(false)]
    public class Interface 
    {
  
        public const string aamodule = "aamodule";
        public const string acceleration = "acceleration";
        public const string alertsApp = "alertsApp";
        public const string alertsInstance = "alertsInstance";
        public const string audit = "audit";
        public const string auditdb = "auditdb";
        public const string authsg = "authsg";
        public const string authsg_int = "authsg_int";
        public const string authsg_ssl = "authsg_ssl";
        public const string avatardb = "avatardb";
        public const string catalog = "catalog";
        public const string catalog_int = "catalog_int";
        public const string cleanser = "cleanser";
        public const string compplugins = "compplugins";
        public const string contentIngestion = "contentIngestion";
        public const string ContentIngestionCatalogDB = "ContentIngestionCatalogDB";
        public const string cron_int = "cron_int";
        public const string cronlib = "cronlib";
        public const string download = "download";
        public const string download_share = "download_share";
        public const string eventsdb = "eventsdb";
        public const string eventservice = "eventservice";
        public const string eventsink = "eventsink";
        public const string eventsysdb = "eventsysdb";
        public const string fastEspMarketplaceSearch = "fastEspMarketplaceSearch";
        public const string fbserver = "fbserver";
        public const string fbserver_int = "fbserver_int";
        public const string fecatalogdbsearch = "fecatalogdbsearch";
        public const string fecatalogdbxbox = "fecatalogdbxbox";
        public const string fecatalogdbzune = "fecatalogdbzune";
        public const string filterdb = "filterdb";
        public const string finbus = "finbus";
        public const string genealogy = "genealogy";
        public const string kdcsvc = "kdcsvc";
        public const string lbsvr = "lbsvr";
        public const string leet_leetwebcommunity_db = "leet_leetwebcommunity_db";
        public const string Lists = "Lists";
        public const string Lists_int = "Lists_int";
        public const string livecache = "livecache";
        public const string LiveConnectDb = "LiveConnectDb";
        public const string liveinfo = "liveinfo";
        public const string liveinfo_int = "liveinfo_int";
        public const string livepxy = "livepxy";
        public const string lspfd = "lspfd";
        public const string lspfd_int = "lspfd_int";
        public const string marketplacecatalog = "marketplacecatalog";
        public const string marketplacecatalog_int = "marketplacecatalog_int";
        public const string mixbetamanagement = "mixbetamanagement";
        public const string mixmatch = "mixmatch";
        public const string mixoffermanagement = "mixoffermanagement";
        public const string mixproductmanagement = "mixproductmanagement";
        public const string mixsettingsmanagement = "mixsettingsmanagement";
        public const string mixstats = "mixstats";
        public const string mixstorage = "mixstorage";
        public const string mixsubscriptionfamily = "mixsubscriptionfamily";
        public const string mixtitlemanagement = "mixtitlemanagement";
        public const string mixtokenmanagement = "mixtokenmanagement";
        public const string msgdb = "msgdb";
        public const string None = "None";
        public const string NotificationCache = "NotificationCache";
        public const string npdb = "npdb";
        public const string olapAchievements = "olapAchievements";
        public const string olapCdbCruxUsage = "olapCdbCruxUsage";
        public const string olapCruxUsage = "olapCruxUsage";
        public const string olapGameUsage = "olapGameUsage";
        public const string olapRealtime = "olapRealtime";
        public const string PresenceCache = "PresenceCache";
        public const string ProfileCache = "ProfileCache";
        public const string profilefd = "profilefd";
        public const string profilefd_int = "profilefd_int";
        public const string progressfd = "progressfd";
        public const string progressfd_int = "progressfd_int";
        public const string provisioning = "provisioning";
        public const string querydb = "querydb";
        public const string querylib = "querylib";
        public const string ratings = "ratings";
        public const string ratings_int = "ratings_int";
        public const string rawcatalogdb = "rawcatalogdb";
        public const string reportarchivedb = "reportarchivedb";
        public const string reportingdb = "reportingdb";
        public const string reportrealtimedb = "reportrealtimedb";
        public const string reportssisdb = "reportssisdb";
        public const string rosetta = "rosetta";
        public const string rufus = "rufus";
        public const string secdb = "secdb";
        public const string secpdb = "secpdb";
        public const string serialdb = "serialdb";
        public const string sgsvc = "sgsvc";
        public const string sgsvc_int = "sgsvc_int";
        public const string SocialCache = "SocialCache";
        public const string stfd_name_resolution = "stfd_name_resolution";
        public const string stfd_name_resolution_int = "stfd_name_resolution_int";
        public const string stfd_storage = "stfd_storage";
        public const string stfd_storage_int = "stfd_storage_int";
        public const string storedb = "storedb";
        public const string stringsvr = "stringsvr";
        public const string stringsvr_int = "stringsvr_int";
        public const string sts = "sts";
        public const string sts_int = "sts_int";
        public const string svctunnel = "svctunnel";
        public const string TagRecycleCronJobs = "TagRecycleCronJobs";
        public const string testfd = "testfd";
        public const string testfd_int = "testfd_int";
        public const string testfdxstsmvc = "testfdxstsmvc";
        public const string testfdxstsmvc_int = "testfdxstsmvc_int";
        public const string testfdxstssoap = "testfdxstssoap";
        public const string testfdxstssoap_int = "testfdxstssoap_int";
        public const string testfdxstswcf = "testfdxstswcf";
        public const string testfdxstswcf_int = "testfdxstswcf_int";
        public const string testrefl = "testrefl";
        public const string testrefl2 = "testrefl2";
        public const string titledb = "titledb";
        public const string tokendb = "tokendb";
        public const string toolsdb = "toolsdb";
        public const string tteamdb = "tteamdb";
        public const string tuserdb = "tuserdb";
        public const string udpadpt = "udpadpt";
        public const string uodb = "uodb";
        public const string usercommercedb = "usercommercedb";
        public const string vortexfd = "vortexfd";
        public const string vortexfd_udp = "vortexfd_udp";
        public const string vortexinh = "vortexinh";
        public const string vortexinh_udp = "vortexinh_udp";
        public const string wcalerts = "wcalerts";
        public const string wcDebugTest = "wcDebugTest";
        public const string wcgeneral = "wcgeneral";
        public const string wcmessaging = "wcmessaging";
        public const string wcmusic = "wcmusic";
        public const string wcpresence = "wcpresence";
        public const string wcprofile = "wcprofile";
        public const string wcquery = "wcquery";
        public const string wcsignature = "wcsignature";
        public const string wcstats = "wcstats";
        public const string wcstorage = "wcstorage";
        public const string wcteams = "wcteams";
        public const string wctoolsmgmt = "wctoolsmgmt";
        public const string wcusers = "wcusers";
        public const string webdb = "webdb";
        public const string websg = "websg";
        public const string websg_int = "websg_int";
        public const string xarb = "xarb";
        public const string xarb_int = "xarb_int";
        public const string xarbInh = "xarbInh";
        public const string xbanc = "xbanc";
        public const string xbl4xboxcom = "xbl4xboxcom";
        public const string xblmetadb = "xblmetadb";
        public const string xbltools = "xbltools";
        public const string xbos_autoupdate = "xbos_autoupdate";
        public const string xbos_base_subscription = "xbos_base_subscription";
        public const string xbos_billing_offering = "xbos_billing_offering";
        public const string xbos_drm = "xbos_drm";
        public const string xbos_drm_int = "xbos_drm_int";
        public const string xbos_int = "xbos_int";
        public const string xboxcom_forums_db = "xboxcom_forums_db";
        public const string xcache = "xcache";
        public const string xcbk = "xcbk";
        public const string XConnSrv = "XConnSrv";
        public const string xcrypto_int = "xcrypto_int";
        public const string xds = "xds";
        public const string xevents = "xevents";
        public const string xmachine = "xmachine";
        public const string xmachine_int = "xmachine_int";
        public const string xmatch = "xmatch";
        public const string xmatchfd = "xmatchfd";
        public const string xmatchfd_int = "xmatchfd_int";
        public const string xmgmtsrv = "xmgmtsrv";
        public const string XNotiCache = "XNotiCache";
        public const string xpnfd_messaging = "xpnfd_messaging";
        public const string xpnfd_messaging_int = "xpnfd_messaging_int";
        public const string xpnfd_presence = "xpnfd_presence";
        public const string xpnfd_presence_int = "xpnfd_presence_int";
        public const string xpnfd_teams = "xpnfd_teams";
        public const string xpnfd_teams_int = "xpnfd_teams_int";
        public const string xqry = "xqry";
        public const string xqry_int = "xqry_int";
        public const string xrlscan = "xrlscan";
        public const string xsig = "xsig";
        public const string xsig_int = "xsig_int";
        public const string xstatsfd = "xstatsfd";
        public const string xstatsfd_int = "xstatsfd_int";
        public const string xsts = "xsts";
        public const string xsts_int = "xsts_int";
        public const string xsuppapi = "xsuppapi";
        public const string xtou = "xtou";
        public const string xtou_int = "xtou_int";
        public const string xuacs = "xuacs";
        public const string xuacs_int = "xuacs_int";
        public const string xuser = "xuser";
        public const string xuser_int = "xuser_int";
    }
    
    // VirtualInterfaces
    [ComVisible(false)]
    public class VirtualInterface 
    {
  
        public const string authsg = "authsg";
        public const string authsg_int = "authsg_int";
        public const string authsg_ssl = "authsg_ssl";
        public const string avatardb = "avatardb";
        public const string catalog = "catalog";
        public const string catalog_int = "catalog_int";
        public const string cleanseriis = "cleanseriis";
        public const string cleanserinh = "cleanserinh";
        public const string cleansersg = "cleansersg";
        public const string cleanservx = "cleanservx";
        public const string contentIngestion = "contentIngestion";
        public const string cron_int = "cron_int";
        public const string download = "download";
        public const string eventservice = "eventservice";
        public const string eventsysdb = "eventsysdb";
        public const string fastEspMarketplaceSearch = "fastEspMarketplaceSearch";
        public const string fbserver = "fbserver";
        public const string fbserver_int = "fbserver_int";
        public const string fecatalogdbsearch = "fecatalogdbsearch";
        public const string fecatalogdbwatcher = "fecatalogdbwatcher";
        public const string fecatalogdbxbox = "fecatalogdbxbox";
        public const string fecatalogdbzune = "fecatalogdbzune";
        public const string kdcsvc = "kdcsvc";
        public const string Lists = "Lists";
        public const string Lists_int = "Lists_int";
        public const string livecache = "livecache";
        public const string liveinfo = "liveinfo";
        public const string liveinfo_int = "liveinfo_int";
        public const string livepxy = "livepxy";
        public const string marketplacecatalog = "marketplacecatalog";
        public const string marketplacecatalog_int = "marketplacecatalog_int";
        public const string mixbetamanagement = "mixbetamanagement";
        public const string mixmatch = "mixmatch";
        public const string mixoffermanagement = "mixoffermanagement";
        public const string mixproductmanagement = "mixproductmanagement";
        public const string mixsettingsmanagement = "mixsettingsmanagement";
        public const string mixstats = "mixstats";
        public const string mixstorage = "mixstorage";
        public const string mixsubscriptionfamily = "mixsubscriptionfamily";
        public const string mixtitlemanagement = "mixtitlemanagement";
        public const string mixtokenmanagement = "mixtokenmanagement";
        public const string msgdb = "msgdb";
        public const string None = "None";
        public const string npdb = "npdb";
        public const string profilefd = "profilefd";
        public const string profilefd_int = "profilefd_int";
        public const string progressfd = "progressfd";
        public const string progressfd_int = "progressfd_int";
        public const string ratings = "ratings";
        public const string ratings_int = "ratings_int";
        public const string secdb = "secdb";
        public const string secpdb = "secpdb";
        public const string sgsvc = "sgsvc";
        public const string SocialCache = "SocialCache";
        public const string stfd_name_resolution = "stfd_name_resolution";
        public const string stfd_name_resolution_int = "stfd_name_resolution_int";
        public const string stfd_storage = "stfd_storage";
        public const string stfd_storage_int = "stfd_storage_int";
        public const string storedb = "storedb";
        public const string stringsvr = "stringsvr";
        public const string stringsvr_int = "stringsvr_int";
        public const string sts = "sts";
        public const string sts_int = "sts_int";
        public const string svctunnel = "svctunnel";
        public const string TagRecycleCronJobs = "TagRecycleCronJobs";
        public const string testfd = "testfd";
        public const string testfd_int = "testfd_int";
        public const string testfdxstsmvc = "testfdxstsmvc";
        public const string testfdxstsmvc_int = "testfdxstsmvc_int";
        public const string testfdxstssoap = "testfdxstssoap";
        public const string testfdxstssoap_int = "testfdxstssoap_int";
        public const string testfdxstswcf = "testfdxstswcf";
        public const string testfdxstswcf_int = "testfdxstswcf_int";
        public const string testrefl = "testrefl";
        public const string testrefl2 = "testrefl2";
        public const string titledb = "titledb";
        public const string tokendb = "tokendb";
        public const string tteamdb = "tteamdb";
        public const string tuserdb = "tuserdb";
        public const string udpadpt = "udpadpt";
        public const string uodb = "uodb";
        public const string usercommercedb = "usercommercedb";
        public const string vortexfd = "vortexfd";
        public const string vortexfd_udp = "vortexfd_udp";
        public const string vortexinh = "vortexinh";
        public const string vortexinh_udp = "vortexinh_udp";
        public const string wcalerts = "wcalerts";
        public const string wcDebugTest = "wcDebugTest";
        public const string wcgeneral = "wcgeneral";
        public const string wcmessaging = "wcmessaging";
        public const string wcmusic = "wcmusic";
        public const string wcpresence = "wcpresence";
        public const string wcprofile = "wcprofile";
        public const string wcquery = "wcquery";
        public const string wcsignature = "wcsignature";
        public const string wcstats = "wcstats";
        public const string wcstorage = "wcstorage";
        public const string wcteams = "wcteams";
        public const string wctoolsmgmt = "wctoolsmgmt";
        public const string wcusers = "wcusers";
        public const string websg = "websg";
        public const string xarb = "xarb";
        public const string xarb_int = "xarb_int";
        public const string xarbInh = "xarbInh";
        public const string xbos_autoupdate = "xbos_autoupdate";
        public const string xbos_base_subscription = "xbos_base_subscription";
        public const string xbos_billing_offering = "xbos_billing_offering";
        public const string xbos_drm = "xbos_drm";
        public const string xbos_drm_int = "xbos_drm_int";
        public const string xbos_int = "xbos_int";
        public const string xcache = "xcache";
        public const string xcbk = "xcbk";
        public const string XConnSrv = "XConnSrv";
        public const string xcrypto_int = "xcrypto_int";
        public const string xds = "xds";
        public const string xmachine = "xmachine";
        public const string xmachine_int = "xmachine_int";
        public const string xmatchfd = "xmatchfd";
        public const string xmatchfd_int = "xmatchfd_int";
        public const string xpnfd_messaging = "xpnfd_messaging";
        public const string xpnfd_messaging_int = "xpnfd_messaging_int";
        public const string xpnfd_presence = "xpnfd_presence";
        public const string xpnfd_presence_int = "xpnfd_presence_int";
        public const string xpnfd_teams = "xpnfd_teams";
        public const string xpnfd_teams_int = "xpnfd_teams_int";
        public const string xqry = "xqry";
        public const string xqry_int = "xqry_int";
        public const string xsig = "xsig";
        public const string xsig_int = "xsig_int";
        public const string xstatsfd = "xstatsfd";
        public const string xstatsfd_int = "xstatsfd_int";
        public const string xsts = "xsts";
        public const string xsts_int = "xsts_int";
        public const string xsuppapi = "xsuppapi";
        public const string xtou = "xtou";
        public const string xtou_int = "xtou_int";
        public const string xuacs = "xuacs";
        public const string xuacs_int = "xuacs_int";
        public const string xuser = "xuser";
        public const string xuser_int = "xuser_int";
  
        // An array used by the HealthRequest HTTPHandler to determine which VirtualInterfaces are valid to 
        // send a health XRL request to. Add a healthCheckEnabled="true" attribute to a virtualInterface
        // element in the configItems.xml file to have that virtualInterface automatically included in this array.
          
        public static string[] VirtualInterfacesWithHealth = new string[]
        {
  
               "authsg",
               "authsg_int",
               "authsg_ssl",
               "catalog",
               "catalog_int",
               "cron_int",
               "eventservice",
               "fbserver",
               "fbserver_int",
               "Lists",
               "Lists_int",
               "livecache",
               "liveinfo",
               "liveinfo_int",
               "livepxy",
               "marketplacecatalog",
               "marketplacecatalog_int",
               "mixsubscriptionfamily",
               "profilefd",
               "profilefd_int",
               "progressfd",
               "progressfd_int",
               "stfd_name_resolution",
               "stfd_name_resolution_int",
               "stfd_storage",
               "stfd_storage_int",
               "stringsvr",
               "stringsvr_int",
               "wcalerts",
               "wcDebugTest",
               "wcgeneral",
               "wcmessaging",
               "wcmusic",
               "wcpresence",
               "wcprofile",
               "wcquery",
               "wcsignature",
               "wcstats",
               "wcstorage",
               "wcteams",
               "wctoolsmgmt",
               "wcusers",
               "xarb",
               "xarb_int",
               "xbos_autoupdate",
               "xbos_base_subscription",
               "xbos_billing_offering",
               "xbos_drm",
               "xbos_drm_int",
               "xbos_int",
               "xcbk",
               "xcrypto_int",
               "xmachine",
               "xmachine_int",
               "xmatchfd",
               "xmatchfd_int",
               "xpnfd_messaging",
               "xpnfd_messaging_int",
               "xpnfd_presence",
               "xpnfd_presence_int",
               "xpnfd_teams",
               "xpnfd_teams_int",
               "xqry",
               "xqry_int",
               "xsig",
               "xsig_int",
               "xstatsfd",
               "xstatsfd_int",
               "xsts",
               "xsts_int",
               "xsuppapi",
               "xtou",
               "xtou_int",
               "xuacs",
               "xuacs_int",
               "xuser",
               "xuser_int",
        };
    }
    
    // Settings
    [ComVisible(false)]
    public class Setting 
    {
  
        public const string aainfo_xbancExpirationInSeconds = "aainfo_xbancExpirationInSeconds";
        public const string aamodule_antidosBanTimeInSeconds = "aamodule_antidosBanTimeInSeconds";
        public const string aamodule_antidosBlockingThreshold = "aamodule_antidosBlockingThreshold";
        public const string aamodule_antidosMaxRecordsToTrack = "aamodule_antidosMaxRecordsToTrack";
        public const string aamodule_antidosThrottlingThreshold = "aamodule_antidosThrottlingThreshold";
        public const string aamodule_antidosTrackingThreshold = "aamodule_antidosTrackingThreshold";
        public const string aamodule_audienceUriMode = "aamodule_audienceUriMode";
        public const string aamodule_certificateRevocationMode = "aamodule_certificateRevocationMode";
        public const string aamodule_certificateValidationMode = "aamodule_certificateValidationMode";
        public const string aamodule_ignoreHost = "aamodule_ignoreHost";
        public const string aamodule_Rps_site = "aamodule_Rps_site";
        public const string aamodule_sts_deviceId_cert_subject_prefix = "aamodule_sts_deviceId_cert_subject_prefix";
        public const string aamodule_suppress_xmgmt_connection = "aamodule_suppress_xmgmt_connection";
        public const string aamodule_useLoadBalancerSslHeaders = "aamodule_useLoadBalancerSslHeaders";
        public const string abch_abserviceUrl = "abch_abserviceUrl";
        public const string abch_allowQueryAtLoginAsQueryAtSignup = "abch_allowQueryAtLoginAsQueryAtSignup";
        public const string abch_applicationId = "abch_applicationId";
        public const string abch_fastFailBlockIntervalSeconds = "abch_fastFailBlockIntervalSeconds";
        public const string abch_fastFailTimeoutThresholdCount = "abch_fastFailTimeoutThresholdCount";
        public const string abch_fastFailTimeoutTimespanSeconds = "abch_fastFailTimeoutTimespanSeconds";
        public const string abch_getMessengerBuddiesTimeoutSeconds = "abch_getMessengerBuddiesTimeoutSeconds";
        public const string abch_getSoapConnectionPoolSize = "abch_getSoapConnectionPoolSize";
        public const string abch_sharingServiceUrl = "abch_sharingServiceUrl";
        public const string acceleration_allocation_page_size = "acceleration_allocation_page_size";
        public const string acceleration_allocation_sizes = "acceleration_allocation_sizes";
        public const string acceleration_context_duration_alert_limit = "acceleration_context_duration_alert_limit";
        public const string acceleration_fastFailBlockIntervalSeconds = "acceleration_fastFailBlockIntervalSeconds";
        public const string acceleration_fastFailTimeoutThresholdCount = "acceleration_fastFailTimeoutThresholdCount";
        public const string acceleration_fastFailTimeoutTimespanSeconds = "acceleration_fastFailTimeoutTimespanSeconds";
        public const string acceleration_heartbeat_interval = "acceleration_heartbeat_interval";
        public const string acceleration_localCacheItemDuration = "acceleration_localCacheItemDuration";
        public const string acceleration_localCacheMaxSize = "acceleration_localCacheMaxSize";
        public const string acceleration_low_water_data_storage_bytes = "acceleration_low_water_data_storage_bytes";
        public const string acceleration_max_key_length = "acceleration_max_key_length";
        public const string acceleration_notificationChangelistSize = "acceleration_notificationChangelistSize";
        public const string acceleration_notificationPollInterval = "acceleration_notificationPollInterval";
        public const string acceleration_numHashtableBuckets = "acceleration_numHashtableBuckets";
        public const string acceleration_record_maintenance_period = "acceleration_record_maintenance_period";
        public const string acceleration_replyTimeout = "acceleration_replyTimeout";
        public const string acceleration_total_data_storage_bytes = "acceleration_total_data_storage_bytes";
        public const string authsg_allowlistheadersincoming = "authsg_allowlistheadersincoming";
        public const string authsg_allowlistheadersoutgoing = "authsg_allowlistheadersoutgoing";
        public const string authsg_sslCertSubject = "authsg_sslCertSubject";
        public const string authsg_timeoutInSeconds = "authsg_timeoutInSeconds";
        public const string authsg_whitelistheaders = "authsg_whitelistheaders";
        public const string bdk_auditEnabled = "bdk_auditEnabled";
        public const string bif_AllowBehaviorInjections = "bif_AllowBehaviorInjections";
        public const string billing_activateTokenTimeout = "billing_activateTokenTimeout";
        public const string billing_activateTokenTimeout_LiveService = "billing_activateTokenTimeout_LiveService";
        public const string billing_activateTokenTimeout_Xbox1 = "billing_activateTokenTimeout_Xbox1";
        public const string billing_addCommentTimeout = "billing_addCommentTimeout";
        public const string billing_addCommentTimeout_LiveService = "billing_addCommentTimeout_LiveService";
        public const string billing_addCommentTimeout_Xbox1 = "billing_addCommentTimeout_Xbox1";
        public const string billing_addPaymentInstrumentTimeout = "billing_addPaymentInstrumentTimeout";
        public const string billing_addPaymentInstrumentTimeout_LiveService = "billing_addPaymentInstrumentTimeout_LiveService";
        public const string billing_addPaymentInstrumentTimeout_Xbox1 = "billing_addPaymentInstrumentTimeout_Xbox1";
        public const string billing_addRoleAssignmentTimeout = "billing_addRoleAssignmentTimeout";
        public const string billing_addRoleAssignmentTimeout_LiveService = "billing_addRoleAssignmentTimeout_LiveService";
        public const string billing_addRoleAssignmentTimeout_Xbox1 = "billing_addRoleAssignmentTimeout_Xbox1";
        public const string billing_addViolationTimeout = "billing_addViolationTimeout";
        public const string billing_addViolationTimeout_LiveService = "billing_addViolationTimeout_LiveService";
        public const string billing_addViolationTimeout_Xbox1 = "billing_addViolationTimeout_Xbox1";
        public const string billing_allowEditorialPurchasesAsZeroPoints = "billing_allowEditorialPurchasesAsZeroPoints";
        public const string billing_allowFakeActivationCode = "billing_allowFakeActivationCode";
        public const string billing_allowInjectedScsErrorInRequest = "billing_allowInjectedScsErrorInRequest";
        public const string billing_allowUrlOverrideInRequest = "billing_allowUrlOverrideInRequest";
        public const string billing_bdkUrl = "billing_bdkUrl";
        public const string billing_calculateTaxTimeout = "billing_calculateTaxTimeout";
        public const string billing_calculateTaxTimeout_LiveService = "billing_calculateTaxTimeout_LiveService";
        public const string billing_calculateTaxTimeout_Xbox1 = "billing_calculateTaxTimeout_Xbox1";
        public const string billing_cancelSubscriptionTimeout = "billing_cancelSubscriptionTimeout";
        public const string billing_cancelSubscriptionTimeout_LiveService = "billing_cancelSubscriptionTimeout_LiveService";
        public const string billing_cancelSubscriptionTimeout_Xbox1 = "billing_cancelSubscriptionTimeout_Xbox1";
        public const string billing_checkProvisioningStatusTimeout = "billing_checkProvisioningStatusTimeout";
        public const string billing_checkProvisioningStatusTimeout_LiveService = "billing_checkProvisioningStatusTimeout_LiveService";
        public const string billing_checkProvisioningStatusTimeout_Xbox1 = "billing_checkProvisioningStatusTimeout_Xbox1";
        public const string billing_closeBalanceTimeout = "billing_closeBalanceTimeout";
        public const string billing_connectionLimit = "billing_connectionLimit";
        public const string billing_connectToBilling = "billing_connectToBilling";
        public const string billing_convertSubscriptionExTimeout = "billing_convertSubscriptionExTimeout";
        public const string billing_convertSubscriptionExTimeout_LiveService = "billing_convertSubscriptionExTimeout_LiveService";
        public const string billing_convertSubscriptionExTimeout_Xbox1 = "billing_convertSubscriptionExTimeout_Xbox1";
        public const string billing_convertSubscriptionTimeout = "billing_convertSubscriptionTimeout";
        public const string billing_convertSubscriptionTimeout_LiveService = "billing_convertSubscriptionTimeout_LiveService";
        public const string billing_convertSubscriptionTimeout_Xbox1 = "billing_convertSubscripti